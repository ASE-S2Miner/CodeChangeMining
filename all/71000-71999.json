[{"original_method":"/**\n         * returns a fragmentation table for this sender\n         * returns null if the sender doesn't have a fragmentation table\n         *\n         * @return the fragmentation table for this sender, or null if no table exist\n         */\n        public FragmentationTable get(Address sender) {\n            return (FragmentationTable)frag_tables.get(sender);\n        }","id":71000,"modified_method":"/**\n         * returns a fragmentation table for this sender\n         * returns null if the sender doesn't have a fragmentation table\n         * @return the fragmentation table for this sender, or null if no table exist\n         */\n        public FragmentationTable get(Address sender) {\n            synchronized(frag_tables) {\n                return (FragmentationTable)frag_tables.get(sender);\n            }\n        }","commit_id":"e726946cf912184c118edc3dec5ed157da309a53","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Fragment a packet if larger than frag_size (add a header). Otherwise just pass down. Only\n     * add a header if framentation is needed !\n     */\n    public void down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                long size=msg.getLength();\n                if(size > frag_size) {\n                     {\n                        StringBuffer sb=new StringBuffer(\"message's buffer size is \");\n                        sb.append(size).append(\", will fragment \").append(\"(frag_size=\");\n                        sb.append(frag_size).append(')');\n                        if(log.isInfoEnabled()) log.info(sb.toString());\n                    }\n                    fragment(msg);  // Fragment and pass down\n                    return;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                //don't do anything if this dude is sending out the view change\n                //we are receiving a view change,\n                //in here we check for the\n                View view=(View)evt.getArg();\n                Vector new_mbrs=view.getMembers(), left_mbrs;\n                Address mbr;\n\n                left_mbrs=Util.determineLeftMembers(members, new_mbrs);\n                members.clear();\n                members.addAll(new_mbrs);\n\n                for(int i=0; i < left_mbrs.size(); i++) {\n                    mbr=(Address)left_mbrs.elementAt(i);\n                    //the new view doesn't contain the sender, he must have left,\n                    //hence we will clear all his fragmentation tables\n                    fragment_list.remove(mbr);\n\n                        if(log.isInfoEnabled()) log.info(\"[VIEW_CHANGE] removed \" + mbr + \" from fragmentation table\");\n                }\n                break;\n\n            case Event.CONFIG:\n                passDown(evt);\n                 if(log.isInfoEnabled()) log.info(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passDown(evt);  // Pass on to the layer below us\n    }","id":71001,"modified_method":"/**\n     * Fragment a packet if larger than frag_size (add a header). Otherwise just pass down. Only\n     * add a header if framentation is needed !\n     */\n    public void down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                long size=msg.getLength();\n                if(size > frag_size) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"message's buffer size is \");\n                        sb.append(size).append(\", will fragment \").append(\"(frag_size=\");\n                        sb.append(frag_size).append(')');\n                        log.trace(sb.toString());\n                    }\n                    fragment(msg);  // Fragment and pass down\n                    return;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                //don't do anything if this dude is sending out the view change\n                //we are receiving a view change,\n                //in here we check for the\n                View view=(View)evt.getArg();\n                Vector new_mbrs=view.getMembers(), left_mbrs;\n                Address mbr;\n\n                left_mbrs=Util.determineLeftMembers(members, new_mbrs);\n                members.clear();\n                members.addAll(new_mbrs);\n\n                for(int i=0; i < left_mbrs.size(); i++) {\n                    mbr=(Address)left_mbrs.elementAt(i);\n                    //the new view doesn't contain the sender, he must have left,\n                    //hence we will clear all his fragmentation tables\n                    fragment_list.remove(mbr);\n                    if(log.isTraceEnabled()) log.trace(\"[VIEW_CHANGE] removed \" + mbr + \" from fragmentation table\");\n                }\n                break;\n\n            case Event.CONFIG:\n                passDown(evt);\n                 if(log.isDebugEnabled()) log.debug(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passDown(evt);  // Pass on to the layer below us\n    }","commit_id":"e726946cf912184c118edc3dec5ed157da309a53","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     1. Get all the fragment buffers\n     2. When all are received -> Assemble them into one big buffer\n     3. Read headers and byte buffer from big buffer\n     4. Set headers and buffer in msg\n     5. Pass msg up the stack\n     */\n    void unfragment(Message msg) {\n        FragmentationTable frag_table=null;\n        Address            sender=msg.getSrc();\n        Message            assembled_msg;\n        FragHeader         hdr=(FragHeader)msg.removeHeader(getName());\n\n         if(log.isDebugEnabled()) log.debug(\"[\" + local_addr + \"] received msg, hdr is \" + hdr);\n\n        frag_table=fragment_list.get(sender);\n        if(frag_table == null) {\n            frag_table=new FragmentationTable(sender);\n            try {\n                fragment_list.add(sender, frag_table);\n            }\n            catch(IllegalArgumentException x) { // the entry has already been added, probably in parallel from another thread\n                frag_table=fragment_list.get(sender);\n            }\n        }\n        assembled_msg=frag_table.add(hdr.id, hdr.frag_id, hdr.num_frags, msg);\n        if(assembled_msg != null) {\n            try {\n                 if(log.isInfoEnabled()) log.info(\"assembled_msg is \" + assembled_msg);\n                assembled_msg.setSrc(sender); // needed ? YES, because fragments have a null src !!\n                passUp(new Event(Event.MSG, assembled_msg));\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n            }\n        }\n    }","id":71002,"modified_method":"/**\n     1. Get all the fragment buffers\n     2. When all are received -> Assemble them into one big buffer\n     3. Read headers and byte buffer from big buffer\n     4. Set headers and buffer in msg\n     5. Pass msg up the stack\n     */\n    void unfragment(Message msg) {\n        FragmentationTable frag_table=null;\n        Address            sender=msg.getSrc();\n        Message            assembled_msg;\n        FragHeader         hdr=(FragHeader)msg.removeHeader(getName());\n\n        frag_table=fragment_list.get(sender);\n        if(frag_table == null) {\n            frag_table=new FragmentationTable(sender);\n            try {\n                fragment_list.add(sender, frag_table);\n            }\n            catch(IllegalArgumentException x) { // the entry has already been added, probably in parallel from another thread\n                frag_table=fragment_list.get(sender);\n            }\n        }\n        assembled_msg=frag_table.add(hdr.id, hdr.frag_id, hdr.num_frags, msg);\n        if(assembled_msg != null) {\n            try {\n                if(log.isTraceEnabled()) log.trace(\"assembled_msg is \" + assembled_msg);\n                assembled_msg.setSrc(sender); // needed ? YES, because fragments have a null src !!\n                passUp(new Event(Event.MSG, assembled_msg));\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n            }\n        }\n    }","commit_id":"e726946cf912184c118edc3dec5ed157da309a53","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * If event is a message, if it is fragmented, re-assemble fragments into big message and pass up\n     * the stack.\n     * todo: Filip catch the view change event so that we can clean up old members\n     */\n    public void up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Object obj=msg.getHeader(getName());\n                if(obj != null && obj instanceof FragHeader) { // needs to be defragmented\n                    unfragment(msg); // Unfragment and possibly pass up\n                    return;\n                }\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                 if(log.isInfoEnabled()) log.info(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passUp(evt); // Pass up to the layer above us by default\n    }","id":71003,"modified_method":"/**\n     * If event is a message, if it is fragmented, re-assemble fragments into big message and pass up\n     * the stack.\n     * todo: Filip catch the view change event so that we can clean up old members\n     */\n    public void up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Object obj=msg.getHeader(getName());\n                if(obj != null && obj instanceof FragHeader) { // needs to be defragmented\n                    unfragment(msg); // Unfragment and possibly pass up\n                    return;\n                }\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                 if(log.isInfoEnabled()) log.info(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passUp(evt); // Pass up to the layer above us by default\n    }","commit_id":"e726946cf912184c118edc3dec5ed157da309a53","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"frag_size\");\n        if(str != null) {\n            frag_size=Integer.parseInt(str);\n            props.remove(\"frag_size\");\n        }\n\n        str=props.getProperty(\"overhead\");\n        if(str != null) {\n            overhead=Integer.parseInt(str);\n            props.remove(\"overhead\");\n        }\n\n        int old_frag_size=frag_size;\n        frag_size-=overhead;\n        if(frag_size <=0) {\n            if(log.isErrorEnabled()) log.error(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead +\n                    \", new frag_size=\" + frag_size + \": new frag_size is invalid\");\n            return false;\n        }\n\n            if(log.isInfoEnabled()) log.info(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead +\n                    \", new frag_size=\" + frag_size);\n\n        if(props.size() > 0) {\n            System.err.println(\"FRAG2.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n        return true;\n    }","id":71004,"modified_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"frag_size\");\n        if(str != null) {\n            frag_size=Integer.parseInt(str);\n            props.remove(\"frag_size\");\n        }\n\n        str=props.getProperty(\"overhead\");\n        if(str != null) {\n            overhead=Integer.parseInt(str);\n            props.remove(\"overhead\");\n        }\n\n        int old_frag_size=frag_size;\n        frag_size-=overhead;\n        if(frag_size <=0) {\n            log.error(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead +\n                      \", new frag_size=\" + frag_size + \": new frag_size is invalid\");\n            return false;\n        }\n\n        if(log.isInfoEnabled())\n            log.info(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead + \", new frag_size=\" + frag_size);\n\n        if(props.size() > 0) {\n            System.err.println(\"FRAG2.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n        return true;\n    }","commit_id":"e726946cf912184c118edc3dec5ed157da309a53","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Send all fragments as separate messages (with same ID !).\n     Example:\n     <pre>\n     Given the generated ID is 2344, number of fragments=3, message {dst,src,buf}\n     would be fragmented into:\n\n     [2344,3,0]{dst,src,buf1},\n     [2344,3,1]{dst,src,buf2} and\n     [2344,3,2]{dst,src,buf3}\n     <\/pre>\n     */\n    void fragment(Message msg) {\n        byte[]             buffer;\n        List               fragments;\n        Event              evt;\n        FragHeader         hdr;\n        Message            frag_msg=null;\n        Address            dest=msg.getDest();\n        long               id=curr_id++; // used as seqnos\n        int                num_frags=0;\n        StringBuffer       sb;\n        Range              r;\n\n        try {\n            buffer=msg.getBuffer();\n            fragments=Util.computeFragOffsets(buffer, frag_size);\n            num_frags=fragments.size();\n\n             {\n                sb=new StringBuffer(\"fragmenting packet to \");\n                sb.append((dest != null ? dest.toString() : \"<all members>\")).append(\" (size=\").append(buffer.length);\n                sb.append(\") into \").append(num_frags).append(\" fragment(s) [frag_size=\").append(frag_size).append(']');\n                if(log.isInfoEnabled()) log.info(sb.toString());\n            }\n\n            for(int i=0; i < fragments.size(); i++) {\n                r=(Range)fragments.get(i);\n                // Copy the original msg (needed because we need to copy the headers too)\n                frag_msg=msg.copy(false); // don't copy the buffer\n                frag_msg.setBuffer(buffer, (int)r.low, (int)r.high);\n                hdr=new FragHeader(id, i, num_frags);\n\n                    if(log.isDebugEnabled()) log.debug(\"fragment's header is \" + hdr);\n                frag_msg.putHeader(name, hdr);\n                evt=new Event(Event.MSG, frag_msg);\n                passDown(evt);\n            }\n        }\n        catch(Exception e) {\n            if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n        }\n\n    }","id":71005,"modified_method":"/** Send all fragments as separate messages (with same ID !).\n     Example:\n     <pre>\n     Given the generated ID is 2344, number of fragments=3, message {dst,src,buf}\n     would be fragmented into:\n\n     [2344,3,0]{dst,src,buf1},\n     [2344,3,1]{dst,src,buf2} and\n     [2344,3,2]{dst,src,buf3}\n     <\/pre>\n     */\n    void fragment(Message msg) {\n        byte[]             buffer;\n        List               fragments;\n        Event              evt;\n        FragHeader         hdr;\n        Message            frag_msg=null;\n        Address            dest=msg.getDest();\n        long               id=curr_id++; // used as seqnos\n        int                num_frags=0;\n        StringBuffer       sb;\n        Range              r;\n\n        try {\n            buffer=msg.getBuffer();\n            fragments=Util.computeFragOffsets(buffer, frag_size);\n            num_frags=fragments.size();\n\n            if(log.isTraceEnabled()) {\n                sb=new StringBuffer(\"fragmenting packet to \");\n                sb.append((dest != null ? dest.toString() : \"<all members>\")).append(\" (size=\").append(buffer.length);\n                sb.append(\") into \").append(num_frags).append(\" fragment(s) [frag_size=\").append(frag_size).append(']');\n                log.trace(sb.toString());\n            }\n\n            for(int i=0; i < fragments.size(); i++) {\n                r=(Range)fragments.get(i);\n                // Copy the original msg (needed because we need to copy the headers too)\n                frag_msg=msg.copy(false); // don't copy the buffer, only src, dest and headers\n                frag_msg.setBuffer(buffer, (int)r.low, (int)r.high);\n                hdr=new FragHeader(id, i, num_frags);\n                frag_msg.putHeader(name, hdr);\n                evt=new Event(Event.MSG, frag_msg);\n                passDown(evt);\n            }\n        }\n        catch(Exception e) {\n            if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n        }\n    }","commit_id":"e726946cf912184c118edc3dec5ed157da309a53","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n            java.util.Enumeration e=frag_tables.elements();\n            StringBuffer buf=new StringBuffer(\"Fragmentation list contains \")\n                    .append(frag_tables.size()).append(\" tables\\n\");\n            while(e.hasMoreElements()) {\n                buf.append(e.nextElement());\n            }\n            return buf.toString();\n        }","id":71006,"modified_method":"public String toString() {\n            Map.Entry entry;\n            StringBuffer buf=new StringBuffer(\"Fragmentation list contains \");\n            synchronized(frag_tables) {\n                buf.append(frag_tables.size()).append(\" tables\\n\");\n                for(Iterator it=frag_tables.entrySet().iterator(); it.hasNext();) {\n                    entry=(Map.Entry)it.next();\n                    buf.append(entry.getKey()).append(\": \" ).append(entry.getValue()).append(\"\\n\");\n                }\n            }\n            return buf.toString();\n        }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * Adds a fragmentation table for this particular sender\n         * If this sender already has a fragmentation table, an IllegalArgumentException\n         * will be thrown.\n         *\n         * @param sender - the address of the sender, cannot be null\n         * @param table  - the fragmentation table of this sender, cannot be null\n         * @throws IllegalArgumentException if an entry for this sender already exist\n         */\n        public synchronized void add(Address sender, FragmentationTable table) throws IllegalArgumentException {\n            FragmentationTable healthCheck=(FragmentationTable)frag_tables.get(sender);\n            if(healthCheck == null) {\n                frag_tables.put(sender, table);\n            }\n            else {\n                throw new IllegalArgumentException(\"Sender <\" + sender + \"> already exists in the fragementation list.\");\n            }\n        }","id":71007,"modified_method":"/**\n         * Adds a fragmentation table for this particular sender\n         * If this sender already has a fragmentation table, an IllegalArgumentException\n         * will be thrown.\n         * @param sender - the address of the sender, cannot be null\n         * @param table  - the fragmentation table of this sender, cannot be null\n         * @throws IllegalArgumentException if an entry for this sender already exist\n         */\n        public void add(Address sender, FragmentationTable table) throws IllegalArgumentException {\n            FragmentationTable healthCheck;\n\n            synchronized(frag_tables) {\n                healthCheck=(FragmentationTable)frag_tables.get(sender);\n                if(healthCheck == null) {\n                    frag_tables.put(sender, table);\n                }\n                else {\n                    throw new IllegalArgumentException(\"Sender <\" + sender + \"> already exists in the fragementation list.\");\n                }\n            }\n        }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * returns true if this sender already holds a\n         * fragmentation for this sender, false otherwise\n         *\n         * @param sender - the sender, cannot be null\n         * @return true if this sender already has a fragmentation table\n         */\n        public boolean containsSender(Address sender) {\n            return frag_tables.containsKey(sender);\n        }","id":71008,"modified_method":"/**\n         * returns true if this sender already holds a\n         * fragmentation for this sender, false otherwise\n         * @param sender - the sender, cannot be null\n         * @return true if this sender already has a fragmentation table\n         */\n        public boolean containsSender(Address sender) {\n            synchronized(frag_tables) {\n                return frag_tables.containsKey(sender);\n            }\n        }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * returns a list of all the senders that have fragmentation tables\n         * opened.\n         *\n         * @return an array of all the senders in the fragmentation list\n         */\n        public synchronized Address[] getSenders() {\n            Address[] result=new Address[frag_tables.size()];\n            java.util.Enumeration en=frag_tables.keys();\n            int index=0;\n            while(en.hasMoreElements()) {\n                result[index++]=(Address)en.nextElement();\n            }\n            return result;\n        }","id":71009,"modified_method":"/**\n         * returns a list of all the senders that have fragmentation tables opened.\n         * @return an array of all the senders in the fragmentation list\n         */\n        public Address[] getSenders() {\n            Address[] result;\n\n            synchronized(frag_tables) {\n                int index=0;\n                result=new Address[frag_tables.size()];\n                for(Iterator it=frag_tables.keySet().iterator(); it.hasNext();) {\n                    result[index++]=(Address)it.next();\n                }\n            }\n            return result;\n        }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * returns a fragmentation table for this sender\n         * returns null if the sender doesn't have a fragmentation table\n         *\n         * @return the fragmentation table for this sender, or null if no table exist\n         */\n        public FragmentationTable get(Address sender) {\n            return (FragmentationTable)frag_tables.get(sender);\n        }","id":71010,"modified_method":"/**\n         * returns a fragmentation table for this sender\n         * returns null if the sender doesn't have a fragmentation table\n         * @return the fragmentation table for this sender, or null if no table exist\n         */\n        public FragmentationTable get(Address sender) {\n            synchronized(frag_tables) {\n                return (FragmentationTable)frag_tables.get(sender);\n            }\n        }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n         * removes the fragmentation table from the list.\n         * after this operation, the fragementation list will no longer\n         * hold a reference to this sender's fragmentation table\n         *\n         * @param sender - the sender who's fragmentation table you wish to remove, cannot be null\n         * @return true if the table was removed, false if the sender doesn't have an entry\n         */\n        public synchronized boolean remove(Address sender) {\n            boolean result=containsSender(sender);\n            frag_tables.remove(sender);\n            return result;\n        }","id":71011,"modified_method":"/**\n         * removes the fragmentation table from the list.\n         * after this operation, the fragementation list will no longer\n         * hold a reference to this sender's fragmentation table\n         * @param sender - the sender who's fragmentation table you wish to remove, cannot be null\n         * @return true if the table was removed, false if the sender doesn't have an entry\n         */\n        public boolean remove(Address sender) {\n            synchronized(frag_tables) {\n                boolean result=containsSender(sender);\n                frag_tables.remove(sender);\n                return result;\n            }\n        }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Send all fragments as separate messages (with same ID !).\n     Example:\n     <pre>\n     Given the generated ID is 2344, number of fragments=3, message {dst,src,buf}\n     would be fragmented into:\n\n     [2344,3,0]{dst,src,buf1},\n     [2344,3,1]{dst,src,buf2} and\n     [2344,3,2]{dst,src,buf3}\n     <\/pre>\n     */\n    void fragment(Message msg) {\n        byte[]             buffer;\n        List               fragments;\n        Event              evt;\n        FragHeader         hdr;\n        Message            frag_msg=null;\n        Address            dest=msg.getDest();\n        long               id=curr_id++; // used as seqnos\n        int                num_frags=0;\n        StringBuffer       sb;\n        Range              r;\n\n        try {\n            buffer=msg.getBuffer();\n            fragments=Util.computeFragOffsets(buffer, frag_size);\n            num_frags=fragments.size();\n\n             {\n                sb=new StringBuffer(\"fragmenting packet to \");\n                sb.append((dest != null ? dest.toString() : \"<all members>\")).append(\" (size=\").append(buffer.length);\n                sb.append(\") into \").append(num_frags).append(\" fragment(s) [frag_size=\").append(frag_size).append(']');\n                if(log.isInfoEnabled()) log.info(sb.toString());\n            }\n\n            for(int i=0; i < fragments.size(); i++) {\n                r=(Range)fragments.get(i);\n                // Copy the original msg (needed because we need to copy the headers too)\n                frag_msg=msg.copy(false); // don't copy the buffer\n                frag_msg.setBuffer(buffer, (int)r.low, (int)r.high);\n                hdr=new FragHeader(id, i, num_frags);\n\n                    if(log.isDebugEnabled()) log.debug(\"fragment's header is \" + hdr);\n                frag_msg.putHeader(name, hdr);\n                evt=new Event(Event.MSG, frag_msg);\n                passDown(evt);\n            }\n        }\n        catch(Exception e) {\n            if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n        }\n\n    }","id":71012,"modified_method":"/** Send all fragments as separate messages (with same ID !).\n     Example:\n     <pre>\n     Given the generated ID is 2344, number of fragments=3, message {dst,src,buf}\n     would be fragmented into:\n\n     [2344,3,0]{dst,src,buf1},\n     [2344,3,1]{dst,src,buf2} and\n     [2344,3,2]{dst,src,buf3}\n     <\/pre>\n     */\n    void fragment(Message msg) {\n        byte[]             buffer;\n        List               fragments;\n        Event              evt;\n        FragHeader         hdr;\n        Message            frag_msg=null;\n        Address            dest=msg.getDest();\n        long               id=curr_id++; // used as seqnos\n        int                num_frags=0;\n        StringBuffer       sb;\n        Range              r;\n\n        try {\n            buffer=msg.getBuffer();\n            fragments=Util.computeFragOffsets(buffer, frag_size);\n            num_frags=fragments.size();\n\n            if(log.isTraceEnabled()) {\n                sb=new StringBuffer(\"fragmenting packet to \");\n                sb.append((dest != null ? dest.toString() : \"<all members>\")).append(\" (size=\").append(buffer.length);\n                sb.append(\") into \").append(num_frags).append(\" fragment(s) [frag_size=\").append(frag_size).append(']');\n                log.trace(sb.toString());\n            }\n\n            for(int i=0; i < fragments.size(); i++) {\n                r=(Range)fragments.get(i);\n                // Copy the original msg (needed because we need to copy the headers too)\n                frag_msg=msg.copy(false); // don't copy the buffer, only src, dest and headers\n                frag_msg.setBuffer(buffer, (int)r.low, (int)r.high);\n                hdr=new FragHeader(id, i, num_frags);\n                frag_msg.putHeader(name, hdr);\n                evt=new Event(Event.MSG, frag_msg);\n                passDown(evt);\n            }\n        }\n        catch(Exception e) {\n            if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n        }\n    }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * If event is a message, if it is fragmented, re-assemble fragments into big message and pass up\n     * the stack.\n     * todo: Filip catch the view change event so that we can clean up old members\n     */\n    public void up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Object obj=msg.getHeader(getName());\n                if(obj != null && obj instanceof FragHeader) { // needs to be defragmented\n                    unfragment(msg); // Unfragment and possibly pass up\n                    return;\n                }\n                break;\n\n            case Event.SET_LOCAL_ADDRESS:\n                local_addr=(Address)evt.getArg();\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                 if(log.isInfoEnabled()) log.info(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passUp(evt); // Pass up to the layer above us by default\n    }","id":71013,"modified_method":"/**\n     * If event is a message, if it is fragmented, re-assemble fragments into big message and pass up\n     * the stack.\n     * todo: Filip catch the view change event so that we can clean up old members\n     */\n    public void up(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                Object obj=msg.getHeader(getName());\n                if(obj != null && obj instanceof FragHeader) { // needs to be defragmented\n                    unfragment(msg); // Unfragment and possibly pass up\n                    return;\n                }\n                break;\n\n            case Event.CONFIG:\n                passUp(evt);\n                 if(log.isInfoEnabled()) log.info(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passUp(evt); // Pass up to the layer above us by default\n    }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     1. Get all the fragment buffers\n     2. When all are received -> Assemble them into one big buffer\n     3. Read headers and byte buffer from big buffer\n     4. Set headers and buffer in msg\n     5. Pass msg up the stack\n     */\n    void unfragment(Message msg) {\n        FragmentationTable frag_table=null;\n        Address            sender=msg.getSrc();\n        Message            assembled_msg;\n        FragHeader         hdr=(FragHeader)msg.removeHeader(getName());\n\n         if(log.isDebugEnabled()) log.debug(\"[\" + local_addr + \"] received msg, hdr is \" + hdr);\n\n        frag_table=fragment_list.get(sender);\n        if(frag_table == null) {\n            frag_table=new FragmentationTable(sender);\n            try {\n                fragment_list.add(sender, frag_table);\n            }\n            catch(IllegalArgumentException x) { // the entry has already been added, probably in parallel from another thread\n                frag_table=fragment_list.get(sender);\n            }\n        }\n        assembled_msg=frag_table.add(hdr.id, hdr.frag_id, hdr.num_frags, msg);\n        if(assembled_msg != null) {\n            try {\n                 if(log.isInfoEnabled()) log.info(\"assembled_msg is \" + assembled_msg);\n                assembled_msg.setSrc(sender); // needed ? YES, because fragments have a null src !!\n                passUp(new Event(Event.MSG, assembled_msg));\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n            }\n        }\n    }","id":71014,"modified_method":"/**\n     1. Get all the fragment buffers\n     2. When all are received -> Assemble them into one big buffer\n     3. Read headers and byte buffer from big buffer\n     4. Set headers and buffer in msg\n     5. Pass msg up the stack\n     */\n    void unfragment(Message msg) {\n        FragmentationTable frag_table=null;\n        Address            sender=msg.getSrc();\n        Message            assembled_msg;\n        FragHeader         hdr=(FragHeader)msg.removeHeader(getName());\n\n        frag_table=fragment_list.get(sender);\n        if(frag_table == null) {\n            frag_table=new FragmentationTable(sender);\n            try {\n                fragment_list.add(sender, frag_table);\n            }\n            catch(IllegalArgumentException x) { // the entry has already been added, probably in parallel from another thread\n                frag_table=fragment_list.get(sender);\n            }\n        }\n        assembled_msg=frag_table.add(hdr.id, hdr.frag_id, hdr.num_frags, msg);\n        if(assembled_msg != null) {\n            try {\n                if(log.isTraceEnabled()) log.trace(\"assembled_msg is \" + assembled_msg);\n                assembled_msg.setSrc(sender); // needed ? YES, because fragments have a null src !!\n                passUp(new Event(Event.MSG, assembled_msg));\n            }\n            catch(Exception e) {\n                if(log.isErrorEnabled()) log.error(\"exception is \" + e);\n            }\n        }\n    }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Fragment a packet if larger than frag_size (add a header). Otherwise just pass down. Only\n     * add a header if framentation is needed !\n     */\n    public void down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                long size=msg.getLength();\n                if(size > frag_size) {\n                     {\n                        StringBuffer sb=new StringBuffer(\"message's buffer size is \");\n                        sb.append(size).append(\", will fragment \").append(\"(frag_size=\");\n                        sb.append(frag_size).append(')');\n                        if(log.isInfoEnabled()) log.info(sb.toString());\n                    }\n                    fragment(msg);  // Fragment and pass down\n                    return;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                //don't do anything if this dude is sending out the view change\n                //we are receiving a view change,\n                //in here we check for the\n                View view=(View)evt.getArg();\n                Vector new_mbrs=view.getMembers(), left_mbrs;\n                Address mbr;\n\n                left_mbrs=Util.determineLeftMembers(members, new_mbrs);\n                members.clear();\n                members.addAll(new_mbrs);\n\n                for(int i=0; i < left_mbrs.size(); i++) {\n                    mbr=(Address)left_mbrs.elementAt(i);\n                    //the new view doesn't contain the sender, he must have left,\n                    //hence we will clear all his fragmentation tables\n                    fragment_list.remove(mbr);\n\n                        if(log.isInfoEnabled()) log.info(\"[VIEW_CHANGE] removed \" + mbr + \" from fragmentation table\");\n                }\n                break;\n\n            case Event.CONFIG:\n                passDown(evt);\n                 if(log.isInfoEnabled()) log.info(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passDown(evt);  // Pass on to the layer below us\n    }","id":71015,"modified_method":"/**\n     * Fragment a packet if larger than frag_size (add a header). Otherwise just pass down. Only\n     * add a header if framentation is needed !\n     */\n    public void down(Event evt) {\n        switch(evt.getType()) {\n\n            case Event.MSG:\n                Message msg=(Message)evt.getArg();\n                long size=msg.getLength();\n                if(size > frag_size) {\n                    if(log.isTraceEnabled()) {\n                        StringBuffer sb=new StringBuffer(\"message's buffer size is \");\n                        sb.append(size).append(\", will fragment \").append(\"(frag_size=\");\n                        sb.append(frag_size).append(')');\n                        log.trace(sb.toString());\n                    }\n                    fragment(msg);  // Fragment and pass down\n                    return;\n                }\n                break;\n\n            case Event.VIEW_CHANGE:\n                //don't do anything if this dude is sending out the view change\n                //we are receiving a view change,\n                //in here we check for the\n                View view=(View)evt.getArg();\n                Vector new_mbrs=view.getMembers(), left_mbrs;\n                Address mbr;\n\n                left_mbrs=Util.determineLeftMembers(members, new_mbrs);\n                members.clear();\n                members.addAll(new_mbrs);\n\n                for(int i=0; i < left_mbrs.size(); i++) {\n                    mbr=(Address)left_mbrs.elementAt(i);\n                    //the new view doesn't contain the sender, he must have left,\n                    //hence we will clear all his fragmentation tables\n                    fragment_list.remove(mbr);\n                    if(log.isTraceEnabled()) log.trace(\"[VIEW_CHANGE] removed \" + mbr + \" from fragmentation table\");\n                }\n                break;\n\n            case Event.CONFIG:\n                passDown(evt);\n                 if(log.isDebugEnabled()) log.debug(\"received CONFIG event: \" + evt.getArg());\n                handleConfigEvent((HashMap)evt.getArg());\n                return;\n        }\n\n        passDown(evt);  // Pass on to the layer below us\n    }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"frag_size\");\n        if(str != null) {\n            frag_size=Integer.parseInt(str);\n            props.remove(\"frag_size\");\n        }\n\n        str=props.getProperty(\"overhead\");\n        if(str != null) {\n            overhead=Integer.parseInt(str);\n            props.remove(\"overhead\");\n        }\n\n        int old_frag_size=frag_size;\n        frag_size-=overhead;\n        if(frag_size <=0) {\n            if(log.isErrorEnabled()) log.error(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead +\n                    \", new frag_size=\" + frag_size + \": new frag_size is invalid\");\n            return false;\n        }\n\n            if(log.isInfoEnabled()) log.info(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead +\n                    \", new frag_size=\" + frag_size);\n\n        if(props.size() > 0) {\n            System.err.println(\"FRAG2.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n        return true;\n    }","id":71016,"modified_method":"/** Setup the Protocol instance acording to the configuration string */\n    public boolean setProperties(Properties props) {\n        String str;\n\n        super.setProperties(props);\n        str=props.getProperty(\"frag_size\");\n        if(str != null) {\n            frag_size=Integer.parseInt(str);\n            props.remove(\"frag_size\");\n        }\n\n        str=props.getProperty(\"overhead\");\n        if(str != null) {\n            overhead=Integer.parseInt(str);\n            props.remove(\"overhead\");\n        }\n\n        int old_frag_size=frag_size;\n        frag_size-=overhead;\n        if(frag_size <=0) {\n            log.error(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead +\n                      \", new frag_size=\" + frag_size + \": new frag_size is invalid\");\n            return false;\n        }\n\n        if(log.isInfoEnabled())\n            log.info(\"frag_size=\" + old_frag_size + \", overhead=\" + overhead + \", new frag_size=\" + frag_size);\n\n        if(props.size() > 0) {\n            System.err.println(\"FRAG2.setProperties(): the following properties are not recognized:\");\n            props.list(System.out);\n            return false;\n        }\n        return true;\n    }","commit_id":"1d57cc4c88f2c7f2349b860b14cef932b509346a","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void doHandshake(SocketChannel ch, SSLEngine sslEngine,\n                               boolean isClient) throws IOException {\n        s_logger.info(\"SSL: begin Handshake, isClient: \" + isClient);\n\n        SSLEngineResult engResult;\n        SSLSession sslSession = sslEngine.getSession();\n        HandshakeStatus hsStatus;\n        ByteBuffer in_pkgBuf =\n            ByteBuffer.allocate(sslSession.getPacketBufferSize() + 40);\n        ByteBuffer in_appBuf =\n            ByteBuffer.allocate(sslSession.getApplicationBufferSize() + 40);\n        ByteBuffer out_pkgBuf =\n            ByteBuffer.allocate(sslSession.getPacketBufferSize() + 40);\n        ByteBuffer out_appBuf =\n            ByteBuffer.allocate(sslSession.getApplicationBufferSize() + 40);\n        int count;\n\n        if (isClient) {\n            hsStatus = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n        } else {\n            hsStatus = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n        }\n\n        while (hsStatus != SSLEngineResult.HandshakeStatus.FINISHED) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"SSL: Handshake status \" + hsStatus);\n            }\n            engResult = null;\n            if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                out_pkgBuf.clear();\n                out_appBuf.clear();\n                out_appBuf.put(\"Hello\".getBytes());\n                engResult = sslEngine.wrap(out_appBuf, out_pkgBuf);\n                out_pkgBuf.flip();\n                int remain = out_pkgBuf.limit();\n                while (remain != 0) {\n                    remain -= ch.write(out_pkgBuf);\n                    if (remain < 0) {\n                        throw new IOException(\"Too much bytes sent?\");\n                    }\n                }\n            } else if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                in_appBuf.clear();\n                // One packet may contained multiply operation\n                if (in_pkgBuf.position() == 0 || !in_pkgBuf.hasRemaining()) {\n                    in_pkgBuf.clear();\n                    count = ch.read(in_pkgBuf);\n                    if (count == -1) {\n                        throw new IOException(\"Connection closed with -1 on reading size.\");\n                    }\n                    in_pkgBuf.flip();\n                }\n                engResult = sslEngine.unwrap(in_pkgBuf, in_appBuf);\n                ByteBuffer tmp_pkgBuf =\n                    ByteBuffer.allocate(sslSession.getPacketBufferSize() + 40);\n                int loop_count = 0;\n                while (engResult.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n                    // The client is too slow? Cut it and let it reconnect\n                    if (loop_count > 10) {\n                        throw new IOException(\"Too many times in SSL BUFFER_UNDERFLOW, disconnect guest.\");\n                    }\n                    // We need more packets to complete this operation\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"SSL: Buffer overflowed, getting more packets\");\n                    }\n                    tmp_pkgBuf.clear();\n                    count = ch.read(tmp_pkgBuf);\n                    if (count == -1) {\n                        throw new IOException(\"Connection closed with -1 on reading size.\");\n                    }\n                    tmp_pkgBuf.flip();\n                    \n                    in_pkgBuf.mark();\n                    in_pkgBuf.position(in_pkgBuf.limit());\n                    in_pkgBuf.limit(in_pkgBuf.limit() + tmp_pkgBuf.limit());\n                    in_pkgBuf.put(tmp_pkgBuf);\n                    in_pkgBuf.reset();\n                    \n                    in_appBuf.clear();\n                    engResult = sslEngine.unwrap(in_pkgBuf, in_appBuf);\n                    loop_count ++;\n                }\n            } else if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                Runnable run;\n                while ((run = sslEngine.getDelegatedTask()) != null) {\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"SSL: Running delegated task!\");\n                    }\n                    run.run();\n                }\n            } else if (hsStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n                throw new IOException(\"NOT a handshaking!\");\n            }\n            if (engResult != null && engResult.getStatus() != SSLEngineResult.Status.OK) {\n                throw new IOException(\"Fail to handshake! \" + engResult.getStatus());\n            }\n            if (engResult != null)\n                hsStatus = engResult.getHandshakeStatus();\n            else\n                hsStatus = sslEngine.getHandshakeStatus();\n        }\n    }","id":71017,"modified_method":"public static void doHandshake(SocketChannel ch, SSLEngine sslEngine,\n                               boolean isClient) throws IOException {\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"SSL: begin Handshake, isClient: \" + isClient);\n        }\n\n        SSLEngineResult engResult;\n        SSLSession sslSession = sslEngine.getSession();\n        HandshakeStatus hsStatus;\n        ByteBuffer in_pkgBuf =\n            ByteBuffer.allocate(sslSession.getPacketBufferSize() + 40);\n        ByteBuffer in_appBuf =\n            ByteBuffer.allocate(sslSession.getApplicationBufferSize() + 40);\n        ByteBuffer out_pkgBuf =\n            ByteBuffer.allocate(sslSession.getPacketBufferSize() + 40);\n        ByteBuffer out_appBuf =\n            ByteBuffer.allocate(sslSession.getApplicationBufferSize() + 40);\n        int count;\n\n        if (isClient) {\n            hsStatus = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n        } else {\n            hsStatus = SSLEngineResult.HandshakeStatus.NEED_UNWRAP;\n        }\n\n        while (hsStatus != SSLEngineResult.HandshakeStatus.FINISHED) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"SSL: Handshake status \" + hsStatus);\n            }\n            engResult = null;\n            if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                out_pkgBuf.clear();\n                out_appBuf.clear();\n                out_appBuf.put(\"Hello\".getBytes());\n                engResult = sslEngine.wrap(out_appBuf, out_pkgBuf);\n                out_pkgBuf.flip();\n                int remain = out_pkgBuf.limit();\n                while (remain != 0) {\n                    remain -= ch.write(out_pkgBuf);\n                    if (remain < 0) {\n                        throw new IOException(\"Too much bytes sent?\");\n                    }\n                }\n            } else if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                in_appBuf.clear();\n                // One packet may contained multiply operation\n                if (in_pkgBuf.position() == 0 || !in_pkgBuf.hasRemaining()) {\n                    in_pkgBuf.clear();\n                    count = ch.read(in_pkgBuf);\n                    if (count == -1) {\n                        throw new IOException(\"Connection closed with -1 on reading size.\");\n                    }\n                    in_pkgBuf.flip();\n                }\n                engResult = sslEngine.unwrap(in_pkgBuf, in_appBuf);\n                ByteBuffer tmp_pkgBuf =\n                    ByteBuffer.allocate(sslSession.getPacketBufferSize() + 40);\n                int loop_count = 0;\n                while (engResult.getStatus() == SSLEngineResult.Status.BUFFER_UNDERFLOW) {\n                    // The client is too slow? Cut it and let it reconnect\n                    if (loop_count > 10) {\n                        throw new IOException(\"Too many times in SSL BUFFER_UNDERFLOW, disconnect guest.\");\n                    }\n                    // We need more packets to complete this operation\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"SSL: Buffer overflowed, getting more packets\");\n                    }\n                    tmp_pkgBuf.clear();\n                    count = ch.read(tmp_pkgBuf);\n                    if (count == -1) {\n                        throw new IOException(\"Connection closed with -1 on reading size.\");\n                    }\n                    tmp_pkgBuf.flip();\n                    \n                    in_pkgBuf.mark();\n                    in_pkgBuf.position(in_pkgBuf.limit());\n                    in_pkgBuf.limit(in_pkgBuf.limit() + tmp_pkgBuf.limit());\n                    in_pkgBuf.put(tmp_pkgBuf);\n                    in_pkgBuf.reset();\n                    \n                    in_appBuf.clear();\n                    engResult = sslEngine.unwrap(in_pkgBuf, in_appBuf);\n                    loop_count ++;\n                }\n            } else if (hsStatus == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n                Runnable run;\n                while ((run = sslEngine.getDelegatedTask()) != null) {\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"SSL: Running delegated task!\");\n                    }\n                    run.run();\n                }\n            } else if (hsStatus == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n                throw new IOException(\"NOT a handshaking!\");\n            }\n            if (engResult != null && engResult.getStatus() != SSLEngineResult.Status.OK) {\n                throw new IOException(\"Fail to handshake! \" + engResult.getStatus());\n            }\n            if (engResult != null)\n                hsStatus = engResult.getHandshakeStatus();\n            else\n                hsStatus = sslEngine.getHandshakeStatus();\n        }\n    }","commit_id":"8ada2852bf3695fcc4f8cc74ebfa9448d3d0b4c3","url":"https://github.com/apache/cloudstack"},{"original_method":"public static SSLContext initSSLContext(boolean isClient) throws Exception {\n        SSLContext sslContext = null;\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        TrustManager[] tms;\n        \n        if (!isClient) {\n        \tchar[] passphrase = \"vmops.com\".toCharArray();\n        \tString keystorePath = \"/etc/cloud/management/cloud.keystore\";\n        \tif (new File(keystorePath).exists()) {\n        \t\tks.load(new FileInputStream(keystorePath), passphrase);\n        \t} else {\n        \t\ts_logger.warn(\"SSL: Fail to find the generated keystore. Loading fail-safe one to continue.\");\n        \t\tks.load(NioConnection.class.getResourceAsStream(\"/cloud.keystore\"), passphrase);\n        \t}\n        \tkmf.init(ks, passphrase);\n        \ttmf.init(ks);\n        \ttms = tmf.getTrustManagers();\n        } else {\n        \tks.load(null, null);\n        \tkmf.init(ks, null);\n        \ttms = new TrustManager[1];\n        \ttms[0] = new TrustAllManager();\n        }\n        \n        sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(kmf.getKeyManagers(), tms, null);\n        s_logger.info(\"SSL: SSLcontext has been initialized\");\n\n        return sslContext;\n    }","id":71018,"modified_method":"public static SSLContext initSSLContext(boolean isClient) throws Exception {\n        SSLContext sslContext = null;\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        TrustManager[] tms;\n        \n        if (!isClient) {\n        \tchar[] passphrase = \"vmops.com\".toCharArray();\n        \tString keystorePath = \"/etc/cloud/management/cloud.keystore\";\n        \tif (new File(keystorePath).exists()) {\n        \t\tks.load(new FileInputStream(keystorePath), passphrase);\n        \t} else {\n        \t\ts_logger.warn(\"SSL: Fail to find the generated keystore. Loading fail-safe one to continue.\");\n        \t\tks.load(NioConnection.class.getResourceAsStream(\"/cloud.keystore\"), passphrase);\n        \t}\n        \tkmf.init(ks, passphrase);\n        \ttmf.init(ks);\n        \ttms = tmf.getTrustManagers();\n        } else {\n        \tks.load(null, null);\n        \tkmf.init(ks, null);\n        \ttms = new TrustManager[1];\n        \ttms[0] = new TrustAllManager();\n        }\n        \n        sslContext = SSLContext.getInstance(\"TLS\");\n        sslContext.init(kmf.getKeyManagers(), tms, null);\n        if (s_logger.isTraceEnabled()) {\n        \ts_logger.trace(\"SSL: SSLcontext has been initialized\");\n        }\n\n        return sslContext;\n    }","commit_id":"8ada2852bf3695fcc4f8cc74ebfa9448d3d0b4c3","url":"https://github.com/apache/cloudstack"},{"original_method":"protected void accept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel();\n\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        Socket socket = socketChannel.socket();\n        socket.setKeepAlive(true);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Connection accepted for \" + socket);\n        }\n        \n        // Begin SSL handshake in BLOCKING mode\n        socketChannel.configureBlocking(true);\n\n        SSLEngine sslEngine = null;\n        try {\n        \tSSLContext sslContext = Link.initSSLContext(false);\n        \tsslEngine = sslContext.createSSLEngine();\n        \tsslEngine.setUseClientMode(false);\n        \tsslEngine.setNeedClientAuth(false);\n\n        \tLink.doHandshake(socketChannel, sslEngine, false);\n        \ts_logger.info(\"SSL: Handshake done\");\n        } catch (Exception e) {\n        \tthrow new IOException(\"SSL: Fail to init SSL! \" + e);\n        }\n        \n        socketChannel.configureBlocking(false);\n        InetSocketAddress saddr = (InetSocketAddress)socket.getRemoteSocketAddress();\n        Link link = new Link(saddr, this);\n        link.setSSLEngine(sslEngine);\n        link.setKey(socketChannel.register(key.selector(), SelectionKey.OP_READ, link));\n        Task task = _factory.create(Task.Type.CONNECT, link, null);\n        registerLink(saddr, link);\n        _executor.execute(task);\n    }","id":71019,"modified_method":"protected void accept(SelectionKey key) throws IOException {\n        ServerSocketChannel serverSocketChannel = (ServerSocketChannel)key.channel();\n\n        SocketChannel socketChannel = serverSocketChannel.accept();\n        Socket socket = socketChannel.socket();\n        socket.setKeepAlive(true);\n\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Connection accepted for \" + socket);\n        }\n        \n        // Begin SSL handshake in BLOCKING mode\n        socketChannel.configureBlocking(true);\n\n        SSLEngine sslEngine = null;\n        try {\n        \tSSLContext sslContext = Link.initSSLContext(false);\n        \tsslEngine = sslContext.createSSLEngine();\n        \tsslEngine.setUseClientMode(false);\n        \tsslEngine.setNeedClientAuth(false);\n\n        \tLink.doHandshake(socketChannel, sslEngine, false);\n        } catch (Exception e) {\n            logDebug(e, key, 0);\n            terminate(key);\n            return;\n        }\n        \n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"SSL: Handshake done\");\n        }\n        socketChannel.configureBlocking(false);\n        InetSocketAddress saddr = (InetSocketAddress)socket.getRemoteSocketAddress();\n        Link link = new Link(saddr, this);\n        link.setSSLEngine(sslEngine);\n        link.setKey(socketChannel.register(key.selector(), SelectionKey.OP_READ, link));\n        Task task = _factory.create(Task.Type.CONNECT, link, null);\n        registerLink(saddr, link);\n        _executor.execute(task);\n    }","commit_id":"8ada2852bf3695fcc4f8cc74ebfa9448d3d0b4c3","url":"https://github.com/apache/cloudstack"},{"original_method":"public <T> Future<T> submitToMember(Callable<T> task, Member member) {\n        if (isShutdown()) {\n            throw new RejectedExecutionException(getRejectionMessage());\n        }\n        final NodeEngine nodeEngine = getNodeEngine();\n        Invocation inv = nodeEngine.getOperationService().createInvocationBuilder(DistributedExecutorService.SERVICE_NAME,\n                new MemberCallableTaskOperation<T>(name, task), ((MemberImpl) member).getAddress()).build();\n        return invoke(inv);\n    }","id":71020,"modified_method":"public <T> Future<T> submitToMember(Callable<T> task, Member member) {\n        if (task == null) throw new NullPointerException();\n        if (isShutdown()) {\n            throw new RejectedExecutionException(getRejectionMessage());\n        }\n        final NodeEngine nodeEngine = getNodeEngine();\n        Invocation inv = nodeEngine.getOperationService().createInvocationBuilder(DistributedExecutorService.SERVICE_NAME,\n                new MemberCallableTaskOperation<T>(name, task), ((MemberImpl) member).getAddress()).build();\n        return invoke(inv);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void submitToKeyOwner(Runnable task, Object key, ExecutionCallback callback) {\n        Callable<?> callable = new RunnableAdapter(task);\n        submitToKeyOwner(callable, key, callback);\n    }","id":71021,"modified_method":"public void submitToKeyOwner(Runnable task, Object key, ExecutionCallback callback) {\n        Callable<?> callable = createRunnableAdapter(task);\n        submitToKeyOwner(callable, key, callback);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private <T> Future<T> submitToPartitionOwner(Callable<T> task, int partitionId) {\n        if (isShutdown()) {\n            throw new RejectedExecutionException(getRejectionMessage());\n        }\n        final NodeEngine nodeEngine = getNodeEngine();\n        Invocation inv = nodeEngine.getOperationService().createInvocationBuilder(DistributedExecutorService.SERVICE_NAME,\n                new CallableTaskOperation<T>(name, task), partitionId).build();\n        return invoke(inv);\n    }","id":71022,"modified_method":"private <T> Future<T> submitToPartitionOwner(Callable<T> task, int partitionId) {\n        if (task == null) throw new NullPointerException();\n        if (isShutdown()) {\n            throw new RejectedExecutionException(getRejectionMessage());\n        }\n        final NodeEngine nodeEngine = getNodeEngine();\n        Invocation inv = nodeEngine.getOperationService().createInvocationBuilder(DistributedExecutorService.SERVICE_NAME,\n                new CallableTaskOperation<T>(name, task), partitionId).build();\n        return invoke(inv);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public List<Runnable> shutdownNow() {\n        shutdown();\n        return null;\n    }","id":71023,"modified_method":"public List<Runnable> shutdownNow() {\n        shutdown();\n        return Collections.emptyList();\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void execute(Runnable command) {\n        Callable<?> callable = new RunnableAdapter(command);\n        submit(callable);\n    }","id":71024,"modified_method":"public void execute(Runnable command) {\n        Callable<?> callable = createRunnableAdapter(command);\n        submit(callable);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void executeOnKeyOwner(Runnable command, Object key) {\n        Callable<?> callable = new RunnableAdapter(command);\n        submitToKeyOwner(callable, key);\n    }","id":71025,"modified_method":"public void executeOnKeyOwner(Runnable command, Object key) {\n        Callable<?> callable = createRunnableAdapter(command);\n        submitToKeyOwner(callable, key);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void executeOnAllMembers(Runnable command) {\n        Callable<?> callable = new RunnableAdapter(command);\n        submitToAllMembers(callable);\n    }","id":71026,"modified_method":"public void executeOnAllMembers(Runnable command) {\n        Callable<?> callable = createRunnableAdapter(command);\n        submitToAllMembers(callable);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void executeOnMembers(Runnable command, Collection<Member> members) {\n        Callable<?> callable = new RunnableAdapter(command);\n        submitToMembers(callable, members);\n    }","id":71027,"modified_method":"public void executeOnMembers(Runnable command, Collection<Member> members) {\n        Callable<?> callable = createRunnableAdapter(command);\n        submitToMembers(callable, members);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void executeOnMember(Runnable command, Member member) {\n        Callable<?> callable = new RunnableAdapter(command);\n        submitToMember(callable, member);\n    }","id":71028,"modified_method":"public void executeOnMember(Runnable command, Member member) {\n        Callable<?> callable = createRunnableAdapter(command);\n        submitToMember(callable, member);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void submit(Runnable task, ExecutionCallback callback) {\n        Callable<?> callable = new RunnableAdapter(task);\n        submit(callable, callback);\n    }","id":71029,"modified_method":"public void submit(Runnable task, ExecutionCallback callback) {\n        Callable<?> callable = createRunnableAdapter(task);\n        submit(callable, callback);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Future<?> submit(Runnable task) {\n        Callable<?> callable = new RunnableAdapter(task);\n        return submit(callable);\n    }","id":71030,"modified_method":"public Future<?> submit(Runnable task) {\n        Callable<?> callable = createRunnableAdapter(task);\n        return submit(callable);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private <T> Future<T> invoke(Invocation inv) {\n        final NodeEngine nodeEngine = getNodeEngine();\n        final boolean sync = checkSync();\n        final Future future = inv.invoke();\n        if (sync) {\n            Object response;\n            try {\n                response = future.get();\n            } catch (Exception e) {\n                response = e;\n            }\n            return new FakeFuture<T>(nodeEngine.getSerializationService(), response);\n        }\n        return new FutureProxy<T>(future, nodeEngine.getSerializationService());\n    }","id":71031,"modified_method":"private <T> Future<T> invoke(Invocation inv) {\n        final NodeEngine nodeEngine = getNodeEngine();\n        final boolean sync = checkSync();\n        final Future future = inv.invoke();\n        if (sync) {\n            Object response;\n            try {\n                response = future.get();\n            } catch (Exception e) {\n                response = e;\n            }\n            return new CompletedFuture<T>(nodeEngine.getSerializationService(), response);\n        }\n        return new FutureProxy<T>(future, nodeEngine.getSerializationService());\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void submitToMember(Runnable task, Member member, ExecutionCallback callback) {\n        Callable<?> callable = new RunnableAdapter(task);\n        submitToMember(callable, member, callback);\n    }","id":71032,"modified_method":"public void submitToMember(Runnable task, Member member, ExecutionCallback callback) {\n        Callable<?> callable = createRunnableAdapter(task);\n        submitToMember(callable, member, callback);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {\n        throw new UnsupportedOperationException();\n    }","id":71033,"modified_method":"public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {\n        final List<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());\n        final List<Future<T>> result = new ArrayList<Future<T>>(tasks.size());\n        for (Callable<T> task : tasks) {\n            futures.add(submit(task));\n        }\n        for (Future<T> future : futures) {\n            Object value;\n            try {\n                value = future.get();\n            } catch (ExecutionException e) {\n                value = e;\n            }\n            result.add(new CompletedFuture<T>(getNodeEngine().getSerializationService(), value));\n        }\n        return result;\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void submitToAllMembers(Runnable task, MultiExecutionCallback callback) {\n        Callable<?> callable = new RunnableAdapter(task);\n        submitToAllMembers(callable, callback);\n    }","id":71034,"modified_method":"public void submitToAllMembers(Runnable task, MultiExecutionCallback callback) {\n        Callable<?> callable = createRunnableAdapter(task);\n        submitToAllMembers(callable, callback);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public <T> Future<T> submit(Runnable task, T result) {\n        Callable<T> callable = new RunnableAdapter<T>(task);\n        return new FutureProxy<T>(submit(callable), getNodeEngine().getSerializationService(), result);\n    }","id":71035,"modified_method":"public <T> Future<T> submit(Runnable task, T result) {\n        Callable<T> callable = createRunnableAdapter(task);\n        return new FutureProxy<T>(submit(callable), getNodeEngine().getSerializationService(), result);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public void submitToMembers(Runnable task, Collection<Member> members, MultiExecutionCallback callback) {\n        Callable<?> callable = new RunnableAdapter(task);\n        submitToMembers(callable, members, callback);\n    }","id":71036,"modified_method":"public void submitToMembers(Runnable task, Collection<Member> members, MultiExecutionCallback callback) {\n        Callable<?> callable = createRunnableAdapter(task);\n        submitToMembers(callable, members, callback);\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public V get() throws InterruptedException, ExecutionException {\n        final Object object = future.get();\n        return getResult(object);\n    }","id":71037,"modified_method":"public V get() throws InterruptedException, ExecutionException {\n        if (!done) {\n            synchronized (this) {\n                if (!done) {\n                    final Object object = future.get();\n                    value = getResult(object);\n                }\n            }\n        }\n        return value;\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"private V getResult(Object object) {\n        if (hasValue) {\n            return value;\n        }\n        if (object instanceof Data) {\n            object = serializationService.toObject((Data) object);\n        }\n        return (V) object;\n    }","id":71038,"modified_method":"private V getResult(Object object) {\n        done = true;\n        if (hasDefaultValue) {\n            return defaultValue;\n        }\n        if (object instanceof Data) {\n            object = serializationService.toObject((Data) object);\n        }\n        return (V) object;\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public FutureProxy(Future future, SerializationService serializationService) {\n        this.future = future;\n        this.serializationService = serializationService;\n        this.value = null;\n        this.hasValue = false;\n    }","id":71039,"modified_method":"public FutureProxy(Future future, SerializationService serializationService) {\n        this.future = future;\n        this.serializationService = serializationService;\n        this.defaultValue = null;\n        this.hasDefaultValue = false;\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public FutureProxy(Future future, SerializationService serializationService, V value) {\n        this.future = future;\n        this.value = value;\n        this.serializationService = serializationService;\n        this.hasValue = true;\n    }","id":71040,"modified_method":"public FutureProxy(Future future, SerializationService serializationService, V defaultValue) {\n        this.future = future;\n        this.defaultValue = defaultValue;\n        this.serializationService = serializationService;\n        this.hasDefaultValue = true;\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n        final Object object = future.get(timeout, unit);\n        return getResult(object);\n    }","id":71041,"modified_method":"public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n        if (!done) {\n            synchronized (this) {\n                if (!done) {\n                    final Object object = future.get(timeout, unit);\n                    value = getResult(object);\n                }\n            }\n        }\n        return value;\n    }","commit_id":"05ca79d7ffe65f3742b10211ac060d91cbeec286","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public AbstractPost12ConsumerConnection(ConnectionVersion4 delegate, VersionDetails providerMetaData) {\n        super(delegate, providerMetaData);\n        configurableConnection = (ConfigurableConnection) delegate;\n    }","id":71042,"modified_method":"protected AbstractPost12ConsumerConnection(ConnectionVersion4 delegate, VersionDetails providerMetaData) {\n        super(delegate, providerMetaData);\n        configurableConnection = (ConfigurableConnection) delegate;\n    }","commit_id":"37e4b1dfef29fe4e42a71e5d20e91d1a9960a8c1","url":"https://github.com/gradle/gradle"},{"original_method":"private Throwable attachCallerThreadStackTrace(Throwable failure) {\n        List<StackTraceElement> adjusted = new ArrayList<StackTraceElement>();\n        adjusted.addAll(Arrays.asList(failure.getStackTrace()));\n        List<StackTraceElement> currentThreadStack = Arrays.asList(Thread.currentThread().getStackTrace());\n        if (!currentThreadStack.isEmpty()) {\n            adjusted.addAll(currentThreadStack.subList(2, currentThreadStack.size()));\n        }\n        failure.setStackTrace(adjusted.toArray(new StackTraceElement[0]));\n        return failure;\n    }","id":71043,"modified_method":"public static Throwable attachCallerThreadStackTrace(Throwable failure) {\n        List<StackTraceElement> adjusted = new ArrayList<StackTraceElement>();\n        adjusted.addAll(Arrays.asList(failure.getStackTrace()));\n        List<StackTraceElement> currentThreadStack = Arrays.asList(Thread.currentThread().getStackTrace());\n        if (!currentThreadStack.isEmpty()) {\n            adjusted.addAll(currentThreadStack.subList(2, currentThreadStack.size()));\n        }\n        failure.setStackTrace(adjusted.toArray(new StackTraceElement[0]));\n        return failure;\n    }","commit_id":"37e4b1dfef29fe4e42a71e5d20e91d1a9960a8c1","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public ModelResults<T> get() throws GradleConnectionException, IllegalStateException {\n        BlockingResultHandler<ModelResults> handler = new BlockingResultHandler<ModelResults>(ModelResults.class);\n        get(handler);\n        return handler.getResult();\n    }","id":71044,"modified_method":"@Override\n    public ModelResults<T> get() throws GradleConnectionException, IllegalStateException {\n        BlockingResultHandler<ModelResults> handler = new BlockingResultHandler<ModelResults>(ModelResults.class);\n        get(handler);\n        ModelResults<T> result = handler.getResult();\n        for (ModelResult<T> modelResult : result) {\n            if (modelResult.getFailure() != null) {\n                BlockingResultHandler.attachCallerThreadStackTrace(modelResult.getFailure());\n            }\n        }\n        return result;\n    }","commit_id":"37e4b1dfef29fe4e42a71e5d20e91d1a9960a8c1","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public T getModel() {\n        throw new GradleConnectionException(failure.getMessage(), failure);\n    }","id":71045,"modified_method":"@Override\n    public T getModel() {\n        throw failure;\n    }","commit_id":"37e4b1dfef29fe4e42a71e5d20e91d1a9960a8c1","url":"https://github.com/gradle/gradle"},{"original_method":"public Iterable<ModelResult<T>> get() throws GradleConnectionException, IllegalStateException {\n        final List<ModelResult<T>> results = Lists.newArrayList();\n\n        for (GradleParticipantBuild participant : operationParameters.getBuilds()) {\n            ParticipantConnector participantConnector = util.createParticipantConnector(participant);\n            try {\n                final List<ModelResult<T>> participantResults = buildResultsForParticipant(participantConnector);\n                results.addAll(participantResults);\n            } catch (GradleConnectionException e) {\n                String message = String.format(\"Could not fetch models of type '%s' using client-side composite connection.\", modelType.getSimpleName());\n                results.add(new DefaultFailedModelResult<T>(participantConnector.toBuildIdentifier(), new GradleConnectionException(message, e)));\n            }\n        }\n        return results;\n    }","id":71046,"modified_method":"public Iterable<ModelResult<T>> get() throws GradleConnectionException, IllegalStateException {\n        final List<ModelResult<T>> results = Lists.newArrayList();\n\n        for (GradleParticipantBuild participant : operationParameters.getBuilds()) {\n            ParticipantConnector participantConnector = util.createParticipantConnector(participant);\n            try {\n                final List<ModelResult<T>> participantResults = buildResultsForParticipant(participantConnector);\n                results.addAll(participantResults);\n            } catch (GradleConnectionException e) {\n                results.add(new DefaultFailedModelResult<T>(participantConnector.toBuildIdentifier(), e));\n            }\n        }\n        return results;\n    }","commit_id":"37e4b1dfef29fe4e42a71e5d20e91d1a9960a8c1","url":"https://github.com/gradle/gradle"},{"original_method":"public void testBlackBox() {\n\t\t\n\t\t// set the locale to English so that log file comparisons work\n\t\tGlobalMessages.setLocale( new Locale(\"en-US\") );\n\t\t\n\t\t// Keep all log rows for at least 60 minutes as per BaseCluster.java\n\t\tCentralLogStore.init(0, 60);\n\t\t\n\t\t// do not process the output folder, there won't be any tests there\n\t\tFile dir = new File(\"testfiles/blackbox/tests\");\n\t\t\n\t\tassertTrue( dir.exists() );\n\t\tassertTrue( dir.isDirectory() );\n\t\tprocessDirectory( dir );\n\t\tassertEquals( 0, failures );\n\t}","id":71047,"modified_method":"public BlackBoxTests(File transFile, List<File> expectedFiles) {\n\t\tthis.transFile = transFile;\n\t\tthis.expectedFiles = expectedFiles;\n\t}","commit_id":"5b381620cb92b9ac1c4658505a00a6683bfae851","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void addFailure( String message ) {\n\t\tSystem.err.println(\"failure: \"+message);\n\t\tfailures++;\n\t}","id":71048,"modified_method":"protected void addFailure( String message ) {\n\t\tSystem.err.println(\"failure: \"+message);\n\t}","commit_id":"5b381620cb92b9ac1c4658505a00a6683bfae851","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean fileCompare( File expected, File actual, LogChannelInterface log ) throws IOException {\n\t\t\n\t\tint failsIn = failures;\n\t\tInputStream expectedStream = new FileInputStream( expected );\n\t\tInputStream actualStream = new FileInputStream( actual );\n\t\t\n        // compare the two files\n        \n        int goldPos = 0;\n        int tmpPos = 0;\n        byte goldBuffer[] = new byte[2048];\n        byte tmpBuffer[] = new byte[2048];\n        try {\n        \t\t// read the start of both files\n            goldPos = expectedStream.read( goldBuffer );\n            tmpPos = actualStream.read( tmpBuffer );\n            // assume lock-step\n//            if( goldPos != tmpPos ) \n//            {\n//            \taddFailure(\"Test file pointers are out of step : \"+getPath( actual ));\n//            \tassertEquals( \"Test file pointers are out of step : \"+getPath( actual ), goldPos, tmpPos );\n//            }\n            int lineno = 1;\n            int charno = 0;\n        \tint indexGold = 0;\n        \tint indexTmp = 0;\n        \tint totalGold = goldPos;\n        \tint totalTmp = tmpPos;\n            while( goldPos > 0 && tmpPos > 0 ) {\n            \tif( indexGold == goldPos ) {\n            \t\tgoldPos = expectedStream.read( goldBuffer );\n            \t\tif( goldPos > 0 ) {\n            \t\t\ttotalGold += goldPos;\n            \t\t}\n            \t\tindexGold = 0;\n            \t}\n            \tif( indexTmp == tmpPos ) {\n            \t\ttmpPos = actualStream.read( tmpBuffer );\n            \t\tif( tmpPos > 0 ) {\n            \t\t\ttotalTmp += tmpPos;\n            \t\t}\n            \t\tindexTmp = 0;\n            \t}\n        \t\tif( goldPos < 0 ) {\n        \t\t\tbreak;\n        \t\t}\n        \t\tif( tmpPos < 0 ) {\n        \t\t\tbreak;\n        \t\t}\n\n        \t\tcharno++;\n            \t\t\tif( goldBuffer[indexGold] != tmpBuffer[indexTmp] )\n            \t\t\t{\n            \t\t\t\tint start = indexTmp > 10 ? indexTmp-10 : 0;\n            \t\t\t\tint end = indexTmp < tmpBuffer.length-11 ? indexTmp+10 : tmpBuffer.length-1;\n            \t\t\t\tint offset = indexTmp-start;\n            \t\t\t\tbyte bytes[] = new byte[offset];\n            \t\t\t\tSystem.arraycopy(tmpBuffer, start, bytes, 0, bytes.length);\n            \t\t\t\tString frag = \"-->\"+new String(bytes);\n            \t\t\t\tfrag += \"[\" + (char) tmpBuffer[indexTmp] + \"]\";\n            \t\t\t\tbytes = new byte[end-start-offset];\n            \t\t\t\tSystem.arraycopy(tmpBuffer, start+offset+1, bytes, 0, bytes.length);\n            \t\t\t\tfrag += new String(bytes);\n            \t\t\t\tfrag += \"<--\";\n            \t\t\t\tString exp = goldBuffer[indexGold] < 32 ? \"\\\\\"+ (char) (goldBuffer[indexGold]-'a') : \"\"+ (char) goldBuffer[indexGold]  ;\n            \t\t\t\tString act = tmpBuffer[indexTmp] < 32 ? \"\\\\\"+ (char) (tmpBuffer[indexTmp]-'a') : \"\"+ (char) tmpBuffer[indexTmp]  ;\n            \t\t\t\tString message = \"Test files (\"+getPath(actual)+\") differ at: line \" +lineno + \" char \" +charno + \" expecting '\"+ exp + \"' but found '\" + act + \"' - \"+frag;\n            \t\t\t\taddFailure(message);\n            \t\t\t\tlog.logError(\"BlackBoxTest\", message);\n            \t\t\t\tfail( message );\n            \t\t\t} \n            \t\t\telse if( tmpBuffer[indexTmp] == '\\n' )\n            \t\t\t{\n            \t\t\t\tlineno++;\n            \t\t\t\tcharno=0;\n            \t\t\t}\n            \t\t\tindexGold++;\n            \t\t\tindexTmp++;\n            \t\t\n            }\n            if( totalGold != totalTmp ) {\n            \taddFailure( \"Comparison files are not same length\" );\n            }\n        } catch (Exception e) {\n        \taddFailure(\"Error trying to compare output files: \" + getPath(actual));\n        \te.printStackTrace();\n        \tfail( \"Error trying to compare output files: \" + getPath(actual) );\n        }\n        return failsIn == failures;\n\t\t\n\t}","id":71049,"modified_method":"public void fileCompare( File expected, File actual, LogChannelInterface log ) throws IOException {\n\t\t\n\t\tInputStream expectedStream = new FileInputStream( expected );\n\t\tInputStream actualStream = new FileInputStream( actual );\n\t\t\n        // compare the two files\n        \n        int goldPos = 0;\n        int tmpPos = 0;\n        byte goldBuffer[] = new byte[2048];\n        byte tmpBuffer[] = new byte[2048];\n        try {\n        \t\t// read the start of both files\n            goldPos = expectedStream.read( goldBuffer );\n            tmpPos = actualStream.read( tmpBuffer );\n            // assume lock-step\n//            if( goldPos != tmpPos ) \n//            {\n//            \taddFailure(\"Test file pointers are out of step : \"+getPath( actual ));\n//            \tassertEquals( \"Test file pointers are out of step : \"+getPath( actual ), goldPos, tmpPos );\n//            }\n            int lineno = 1;\n            int charno = 0;\n        \tint indexGold = 0;\n        \tint indexTmp = 0;\n        \tint totalGold = goldPos;\n        \tint totalTmp = tmpPos;\n            while( goldPos > 0 && tmpPos > 0 ) {\n            \tif( indexGold == goldPos ) {\n            \t\tgoldPos = expectedStream.read( goldBuffer );\n            \t\tif( goldPos > 0 ) {\n            \t\t\ttotalGold += goldPos;\n            \t\t}\n            \t\tindexGold = 0;\n            \t}\n            \tif( indexTmp == tmpPos ) {\n            \t\ttmpPos = actualStream.read( tmpBuffer );\n            \t\tif( tmpPos > 0 ) {\n            \t\t\ttotalTmp += tmpPos;\n            \t\t}\n            \t\tindexTmp = 0;\n            \t}\n        \t\tif( goldPos < 0 ) {\n        \t\t\tbreak;\n        \t\t}\n        \t\tif( tmpPos < 0 ) {\n        \t\t\tbreak;\n        \t\t}\n\n        \t\tcharno++;\n            \t\t\tif( goldBuffer[indexGold] != tmpBuffer[indexTmp] )\n            \t\t\t{\n            \t\t\t\tint start = indexTmp > 10 ? indexTmp-10 : 0;\n            \t\t\t\tint end = indexTmp < tmpBuffer.length-11 ? indexTmp+10 : tmpBuffer.length-1;\n            \t\t\t\tint offset = indexTmp-start;\n            \t\t\t\tbyte bytes[] = new byte[offset];\n            \t\t\t\tSystem.arraycopy(tmpBuffer, start, bytes, 0, bytes.length);\n            \t\t\t\tString frag = \"-->\"+new String(bytes);\n            \t\t\t\tfrag += \"[\" + (char) tmpBuffer[indexTmp] + \"]\";\n            \t\t\t\tbytes = new byte[end-start-offset];\n            \t\t\t\tSystem.arraycopy(tmpBuffer, start+offset+1, bytes, 0, bytes.length);\n            \t\t\t\tfrag += new String(bytes);\n            \t\t\t\tfrag += \"<--\";\n            \t\t\t\tString exp = goldBuffer[indexGold] < 32 ? \"\\\\\"+ (char) (goldBuffer[indexGold]-'a') : \"\"+ (char) goldBuffer[indexGold]  ;\n            \t\t\t\tString act = tmpBuffer[indexTmp] < 32 ? \"\\\\\"+ (char) (tmpBuffer[indexTmp]-'a') : \"\"+ (char) tmpBuffer[indexTmp]  ;\n            \t\t\t\tString message = \"Test files (\"+getPath(actual)+\") differ at: line \" +lineno + \" char \" +charno + \" expecting '\"+ exp + \"' but found '\" + act + \"' - \"+frag;\n            \t\t\t\taddFailure(message);\n            \t\t\t\tlog.logError(\"BlackBoxTest\", message);\n            \t\t\t\tfail( message );\n            \t\t\t} \n            \t\t\telse if( tmpBuffer[indexTmp] == '\\n' )\n            \t\t\t{\n            \t\t\t\tlineno++;\n            \t\t\t\tcharno=0;\n            \t\t\t}\n            \t\t\tindexGold++;\n            \t\t\tindexTmp++;\n            \t\t\n            }\n            if( totalGold != totalTmp ) {\n            \tString message = \"Comparison files are not same length. \" +\n            \t\t\t\"Expected=\" + expected.getPath() + \" (\" + totalGold + \") \" + \n            \t\t\t\"Actual=\" + actual.getPath() + \" (\" + totalTmp +\")\";\n            \taddFailure(message);\n            \tfail(message);\n            }\n        } catch (Exception e) {\n        \taddFailure(\"Error trying to compare output files: \" + getPath(actual));\n        \te.printStackTrace();\n        \tfail( \"Error trying to compare output files: \" + getPath(actual) );\n        }\n\t}","commit_id":"5b381620cb92b9ac1c4658505a00a6683bfae851","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"protected void processDirectory( File dir ) {\n\t\tFile files[] = dir.listFiles();\n\t\t\n\t\t// recursively process every folder in testfiles/blackbox/tests\n\t\tfor( int i=0; i<files.length; i++ ) \n\t\t{\n\t\t\tif( files[i].isDirectory() ) \n\t\t\t{\n\t\t\t\tprocessDirectory( files[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now process any transformations or jobs we find\n\t\tfor( int i=0; i<files.length; i++ ) \n\t\t{\n\t\t\tif( files[i].isFile() ) \n\t\t\t{\n\t\t\t\tString name = files[i].getName();\n\t\t\t\tif( name.endsWith(\".ktr\") && !name.endsWith(\"-tmp.ktr\") ) \n\t\t\t\t{\n\t\t\t\t\t// we found a transformation\n\t\t\t\t\t// see if we can find an output file\n\t\t\t\t\tList<File> expected = getExpectedOutputFile( dir, name.substring(0, name.length()-4) );\n\t\t\t\t\ttry {\n\t\t\t\t\t\trunTrans( files[i], expected );\n\t\t\t\t\t} catch ( AssertionFailedError failure ) {\n\t\t\t\t\t\t// we're going to trap these so that we can continue with the other black box tests\n\t\t\t\t\t\tSystem.err.println( failure.getMessage() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if( name.endsWith(\".kjb\") ) \n\t\t\t\t{\n\t\t\t\t\t// we found a job\n\t\t\t\t\tSystem.out.println(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}","id":71050,"modified_method":"protected static void processDirectory( File dir ) {\n\t\tFile files[] = dir.listFiles();\n\t\t\n\t\t// recursively process every folder in testfiles/blackbox/tests\n\t\tfor( int i=0; i<files.length; i++ ) \n\t\t{\n\t\t\tif( files[i].isDirectory() ) \n\t\t\t{\n\t\t\t\tprocessDirectory( files[i] );\n\t\t\t}\n\t\t}\n\t\t\n\t\t// now process any transformations or jobs we find\n\t\tfor( int i=0; i<files.length; i++ ) \n\t\t{\n\t\t\tif( files[i].isFile() ) \n\t\t\t{\n\t\t\t\tString name = files[i].getName();\n\t\t\t\tif( name.endsWith(\".ktr\") && !name.endsWith(\"-tmp.ktr\") ) \n\t\t\t\t{\n\t\t\t\t\t// we found a transformation\n\t\t\t\t\t// see if we can find an output file\n\t\t\t\t\tList<File> expected = getExpectedOutputFile( dir, name.substring(0, name.length()-4) );\n\t\t\t\t\t\n\t\t\t\t\tObject params[] = { files[i], expected };\n\t\t\t\t\tallTests.add(params);\n\t\t\t\t}\n\t\t\t\telse if( name.endsWith(\".kjb\") ) \n\t\t\t\t{\n\t\t\t\t\t// we found a job\n\t\t\t\t\tSystem.out.println(\"JOBS NOT YET HANDLED: \" + name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}","commit_id":"5b381620cb92b9ac1c4658505a00a6683bfae851","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Result runTrans(String fileName, LogChannelInterface log) throws KettleException\n\t{\n\t\tResult result = new Result();\n\t\t\n    \t// Bootstrap the Kettle API...\n    \t//\n    \tKettleEnvironment.init();\n        \n\t\tTrans trans = null;\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\ttransMeta = new TransMeta(fileName);\n\t\t\ttrans = new Trans(transMeta);\n\t\t\tresult = trans.getResult();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tresult = trans.getResult();\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\taddFailure(\"Processing has stopped because of an error: \" + getPath(fileName));\n\t\t\tlog.logError(\"BlackBoxTest\", \"Processing has stopped because of an error: \" + getPath(fileName), e);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\taddFailure(\"Can't continue because the transformation couldn't be loaded.\" + getPath(fileName));\n            log.logError(\"BlackBoxTest\", \"Can't continue because the transformation couldn't be loaded.\" + getPath(fileName));\n            return result;\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\n\t\t\t\n\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t\n\t\t\t// see if the transformation checks ok\n\t\t\tList<CheckResultInterface> remarks = new ArrayList<CheckResultInterface>();\n\t\t\ttrans.getTransMeta().checkSteps(remarks, false, null);\n\t\t\tfor( CheckResultInterface remark : remarks ) {\n\t\t\t\tif( remark.getType() == CheckResultInterface.TYPE_RESULT_ERROR ) {\n\t\t\t\t\t// add this to the log\n\t\t\t\t\taddFailure(\"Check error: \" + getPath(fileName) + \", \"+remark.getErrorCode());\n\t\t\t\t\tlog.logError(\"BlackBoxTest\", \"Check error: \" + getPath(fileName) + \", \"+remark.getErrorCode() );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// TODO move this code to a separate test\n/*\n\t\t\t// clone it and convert it back into XML and compare it with the one we started with\n\t\t\t// this tests that the clone and the conversion to and from XML are all consistent\n\t\t\tTransMeta clone = (TransMeta) trans.getTransMeta().clone();\n\t\t\tclone.setName( trans.getTransMeta().getName() );\n\t\t\tclone.setModifiedDate( trans.getTransMeta().getModifiedDate() );\n\t\t\tString xml = clone.getXML();\n\t\t\t\n\t\t\tString tmpFileName = fileName.substring(0, fileName.length()-4)+\"-tmp.ktr\";\n\t\t\tFile tmpFile = new File( tmpFileName );\n\t\t\ttry {\n\t\t\t\t// document encoding will be important here\n\t\t\t\tOutputStream stream = new FileOutputStream( tmpFile );\n\t\t\t\tstream.write( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\".getBytes() );\n\t\t\t\tstream.write( xml.getBytes(\"UTF-8\") );\n\t\t\t\tstream.close();\n\t\t\t\t// now compare the two transformation XML files\n\t\t\t\tfileCompare( new File(fileName), tmpFile, log );\n\t\t\t\t// if that succeeded we can remove the tmp file\n\t\t\t\ttmpFile.delete();\n\t\t\t} catch (Exception e)\n\t\t\t{\n\t\t\t\taddFailure(\"Could not write to tmp file: \" + getPath(tmpFileName));\n\t\t\t\tlog.logError(\"BlackBoxTest\", \"Could not write to tmp file: \" + getPath(tmpFileName), e);\n\t\t\t}\n*/\n\t\t    // allocate & run the required sub-threads\n\t\t\ttry {\n\t\t\t\ttrans.execute(null); \n\t\t\t}\n\t\t\tcatch (Exception e) {\n            \taddFailure(\"Unable to prepare and initialize this transformation: \" + getPath(fileName));\n                log.logError(\"BlackBoxTest\", \"Unable to prepare and initialize this transformation: \" + getPath(fileName));\n                return null;\n            }\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n\t\t\t\n\t\t\treturn trans.getResult();\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\taddFailure(\"Unexpected error occurred: \" + getPath(fileName));\n            log.logError(\"BlackBoxTest\", \"Unexpected error occurred: \" + getPath(fileName), ke);\n            result.setResult(false);\n            result.setNrErrors(1);\n            return result;\n\t\t}\n\t}","id":71051,"modified_method":"public Result runTrans(String fileName, LogChannelInterface log) throws KettleException\n\t{\n\t\tResult result = new Result();\n\t\t\n    \t// Bootstrap the Kettle API...\n    \t//\n    \tKettleEnvironment.init();\n        \n\t\tTrans trans = null;\n\t\tTransMeta transMeta = new TransMeta();\n\n\t\ttry\n\t\t{\n\t\t\ttransMeta = new TransMeta(fileName);\n\t\t\ttrans = new Trans(transMeta);\n\t\t\tresult = trans.getResult();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tresult = trans.getResult();\n\t\t\ttrans=null;\n\t\t\ttransMeta=null;\n\t\t\tString message = \"Processing has stopped because of an error: \" + getPath(fileName); \n\t\t\taddFailure(message);\n\t\t\tlog.logError(message, e);\n\t\t\tfail(message);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (trans==null)\n\t\t{\n\t\t\tString message = \"Can't continue because the transformation couldn't be loaded.\" + getPath(fileName);\n\t\t\taddFailure(message);\n            log.logError(message);\n            fail(message);\n            return result;\n            \n\t\t}\n\t\t\n\t\ttry\n\t\t{\n\t\t\ttrans.initializeVariablesFrom(null);\n\t\t\ttrans.getTransMeta().setInternalKettleVariables(trans);\n\t\t\t\n\t\t\ttrans.setSafeModeEnabled(true);\n\t\t\t\n\t\t\t// see if the transformation checks ok\n\t\t\tList<CheckResultInterface> remarks = new ArrayList<CheckResultInterface>();\n\t\t\ttrans.getTransMeta().checkSteps(remarks, false, null);\n\t\t\tfor( CheckResultInterface remark : remarks ) {\n\t\t\t\tif( remark.getType() == CheckResultInterface.TYPE_RESULT_ERROR ) {\n\t\t\t\t\t// add this to the log\n\t\t\t\t\taddFailure(\"Check error: \" + getPath(fileName) + \", \"+remark.getErrorCode());\n\t\t\t\t\tlog.logError(\"BlackBoxTest\", \"Check error: \" + getPath(fileName) + \", \"+remark.getErrorCode() );\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// TODO move this code to a separate test\n/*\n\t\t\t// clone it and convert it back into XML and compare it with the one we started with\n\t\t\t// this tests that the clone and the conversion to and from XML are all consistent\n\t\t\tTransMeta clone = (TransMeta) trans.getTransMeta().clone();\n\t\t\tclone.setName( trans.getTransMeta().getName() );\n\t\t\tclone.setModifiedDate( trans.getTransMeta().getModifiedDate() );\n\t\t\tString xml = clone.getXML();\n\t\t\t\n\t\t\tString tmpFileName = fileName.substring(0, fileName.length()-4)+\"-tmp.ktr\";\n\t\t\tFile tmpFile = new File( tmpFileName );\n\t\t\ttry {\n\t\t\t\t// document encoding will be important here\n\t\t\t\tOutputStream stream = new FileOutputStream( tmpFile );\n\t\t\t\tstream.write( \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\".getBytes() );\n\t\t\t\tstream.write( xml.getBytes(\"UTF-8\") );\n\t\t\t\tstream.close();\n\t\t\t\t// now compare the two transformation XML files\n\t\t\t\tfileCompare( new File(fileName), tmpFile, log );\n\t\t\t\t// if that succeeded we can remove the tmp file\n\t\t\t\ttmpFile.delete();\n\t\t\t} catch (Exception e)\n\t\t\t{\n\t\t\t\taddFailure(\"Could not write to tmp file: \" + getPath(tmpFileName));\n\t\t\t\tlog.logError(\"BlackBoxTest\", \"Could not write to tmp file: \" + getPath(tmpFileName), e);\n\t\t\t}\n*/\n\t\t    // allocate & run the required sub-threads\n\t\t\ttry {\n\t\t\t\ttrans.execute(null); \n\t\t\t} catch (Exception e) {\n            \taddFailure(\"Unable to prepare and initialize this transformation: \" + getPath(fileName));\n                log.logError(\"BlackBoxTest\", \"Unable to prepare and initialize this transformation: \" + getPath(fileName));\n                fail(\"Unable to prepare and initialize this transformation: \" + getPath(fileName));\n                return null;\n\t\t\t}\n\n\t\t\ttrans.waitUntilFinished();\n\t\t\ttrans.endProcessing(Database.LOG_STATUS_END);\n\t\t\tresult = trans.getResult();\n\t\t\t\n\t\t\t// The result flag is not set to true by a transformation - set it to true if got no errors\n\t\t\t// FIXME: Find out if there is a better way to check if a transformation has thrown an error\n\t\t\tresult.setResult(result.getNrErrors() == 0);\n\t\t\t\n\t\t\treturn result;\n\t\t}\n\t\tcatch(KettleException ke)\n\t\t{\n\t\t\taddFailure(\"Unexpected error occurred: \" + getPath(fileName));\n            log.logError(\"BlackBoxTest\", \"Unexpected error occurred: \" + getPath(fileName), ke);\n            result.setResult(false);\n            result.setNrErrors(1);\n            fail(\"Unexpected error occurred: \" + getPath(fileName));\n            return result;\n\t\t}\n\t}","commit_id":"5b381620cb92b9ac1c4658505a00a6683bfae851","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Tries to find an output file to match a transformation or job file\n\t * @param dir The directory to look in\n\t * @param baseName Name of the transformation or the job without the extension\n\t * @return\n\t */\n\tprotected List<File> getExpectedOutputFile( File dir, String baseName ) {\n\t\tList<File> files = new ArrayList<File>();\n\t\t\n\t\tfor (String extension : new String[] { \".txt\", \".csv\", \".xml\" }) {\n\t\t\tFile expected;\n\t\t\texpected = new File( dir, baseName + \".expected\"+extension );\n\t\t\tif( expected.exists() ) \n\t\t\t{\n\t\t\t\tfiles.add(expected);\n\t\t\t}\n\t\t\n\t\t\t// now see if there are perhaps multiple files generated...\n\t\t\t//\n\t\t\tboolean found=true;\n\t\t\tint nr=0;\n\t\t\twhile (found) {\n\t\t\t\texpected = new File( dir, baseName + \".expected_\"+nr+extension );\n\t\t\t\tif( expected.exists() ) \n\t\t\t\t{\n\t\t\t\t\tfiles.add(expected);\n\t\t\t\t\tnr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfound=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn files;\n\t}","id":71052,"modified_method":"/**\n\t * Tries to find an output file to match a transformation or job file\n\t * @param dir The directory to look in\n\t * @param baseName Name of the transformation or the job without the extension\n\t * @return\n\t */\t\t\n\tprotected static List<File> getExpectedOutputFile( File dir, String baseName ) {\n\t\tList<File> files = new ArrayList<File>();\n\t\t\n\t\tFile expected = new File( dir, baseName + \".fail.txt\" );\n\t\tif (expected.exists()) {\n\t\t\tfiles.add(expected);\n\t\t}\n\t\t\n\t\tfor (String extension : new String[] { \".txt\", \".csv\", \".xml\" }) {\n\t\t\texpected = new File( dir, baseName + \".expected\"+extension );\n\t\t\tif( expected.exists() ) \n\t\t\t{\n\t\t\t\tfiles.add(expected);\n\t\t\t}\n\t\t\n\t\t\t// now see if there are perhaps multiple files generated...\n\t\t\t//\n\t\t\tboolean found=true;\n\t\t\tint nr=0;\n\t\t\twhile (found) {\n\t\t\t\texpected = new File( dir, baseName + \".expected_\"+nr+extension );\n\t\t\t\tif( expected.exists() ) \n\t\t\t\t{\n\t\t\t\t\tfiles.add(expected);\n\t\t\t\t\tnr++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tfound=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn files;\n\t}","commit_id":"5b381620cb92b9ac1c4658505a00a6683bfae851","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\n  protected PsiType getClosureParameterType(GrClosableBlock closure, int index) {\n    if (!GppTypeConverter.hasTypedContext(closure)) {\n      return null;\n    }\n\n    final Pair<PsiMethod, PsiSubstitutor> pair = getOverriddenMethod(closure);\n    if (pair != null) {\n      final PsiParameter[] parameters = pair.first.getParameterList().getParameters();\n      if (parameters.length > index) {\n        return pair.second.substitute(parameters[index].getType());\n      }\n      return null;\n    }\n\n    for (PsiType constraint : getExpectedTypes(closure)) {\n      final PsiType suggestion = getSingleMethodParameterType(constraint, index, closure);\n      if (suggestion != null) {\n        return suggestion;\n      }\n    }\n    return null;\n  }","id":71053,"modified_method":"@Override\n  protected PsiType getClosureParameterType(GrClosableBlock closure, int index) {\n    if (!GppTypeConverter.hasTypedContext(closure)) {\n      return null;\n    }\n\n    final Pair<PsiMethod, PsiSubstitutor> pair = getOverriddenMethod(closure);\n    if (pair != null) {\n      final PsiParameter[] parameters = pair.first.getParameterList().getParameters();\n      if (parameters.length > index) {\n        return pair.second.substitute(parameters[index].getType());\n      }\n      return null;\n    }\n\n    final PsiElement parent = closure.getParent();\n    if (parent instanceof GrListOrMap) {\n      final GrListOrMap list = (GrListOrMap)parent;\n      if (!list.isMap()) {\n        final PsiType listType = list.getType();\n        final int argIndex = Arrays.asList(list.getInitializers()).indexOf(closure);\n        assert argIndex >= 0;\n        if (listType instanceof GrTupleType) {\n          for (PsiType type : GroovyExpectedTypesProvider.getDefaultExpectedTypes(list)) {\n            if (type instanceof PsiClassType) {\n              for (GroovyResolveResult resolveResult : GppTypeConverter\n                .getConstructorCandidates((PsiClassType)type, ((GrTupleType)listType).getComponentTypes(), closure)) {\n                final PsiElement method = resolveResult.getElement();\n                if (method instanceof PsiMethod && ((PsiMethod)method).isConstructor()) {\n                  final PsiType toCastTo =\n                    resolveResult.getSubstitutor().substitute(((PsiMethod)method).getParameterList().getParameters()[argIndex].getType());\n                  final PsiType suggestion = getSingleMethodParameterType(toCastTo, index, closure);\n                  if (suggestion != null) {\n                    return suggestion;\n                  }\n                }\n\n              }\n            }\n          }\n        }\n        return null;\n      }\n    }\n\n    for (PsiType constraint : GroovyExpectedTypesProvider.getDefaultExpectedTypes(closure)) {\n      final PsiType suggestion = getSingleMethodParameterType(constraint, index, closure);\n      if (suggestion != null) {\n        return suggestion;\n      }\n    }\n    return null;\n  }","commit_id":"fa6abf812a4fb33a80843b4a4daab382078adebb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Pair<PsiMethod, PsiSubstitutor> getOverriddenMethod(GrClosableBlock closure) {\n    final PsiElement parent = closure.getParent();\n    if (!(parent instanceof GrNamedArgument)) {\n      return null;\n    }\n\n    final GrArgumentLabel label = ((GrNamedArgument)parent).getLabel();\n    if (label == null) {\n      return null;\n    }\n\n    final String methodName = label.getName();\n    if (methodName == null) {\n      return null;\n    }\n\n    final PsiElement map = parent.getParent();\n    if (map instanceof GrListOrMap && ((GrListOrMap)map).isMap()) {\n      for (PsiType expected : getExpectedTypes((GrExpression)map)) {\n        if (expected instanceof PsiClassType) {\n          final List<Pair<PsiMethod, PsiSubstitutor>> pairs = getMethodsToOverrideImplementInInheritor((PsiClassType)expected, false);\n          final List<Pair<PsiMethod, PsiSubstitutor>> withName =\n            ContainerUtil.findAll(pairs, new Condition<Pair<PsiMethod, PsiSubstitutor>>() {\n              public boolean value(Pair<PsiMethod, PsiSubstitutor> pair) {\n                return methodName.equals(pair.first.getName());\n              }\n            });\n          if (withName.size() == 1) {\n            return withName.get(0);\n          }\n        }\n      }\n    }\n\n    return null;\n  }","id":71054,"modified_method":"@Nullable\n  private static Pair<PsiMethod, PsiSubstitutor> getOverriddenMethod(GrClosableBlock closure) {\n    final PsiElement parent = closure.getParent();\n    if (!(parent instanceof GrNamedArgument)) {\n      return null;\n    }\n\n    final GrArgumentLabel label = ((GrNamedArgument)parent).getLabel();\n    if (label == null) {\n      return null;\n    }\n\n    final String methodName = label.getName();\n    if (methodName == null) {\n      return null;\n    }\n\n    final PsiElement map = parent.getParent();\n    if (map instanceof GrListOrMap && ((GrListOrMap)map).isMap()) {\n      for (PsiType expected : GroovyExpectedTypesProvider.getDefaultExpectedTypes((GrExpression)map)) {\n        if (expected instanceof PsiClassType) {\n          final List<Pair<PsiMethod, PsiSubstitutor>> pairs = getMethodsToOverrideImplementInInheritor((PsiClassType)expected, false);\n          final List<Pair<PsiMethod, PsiSubstitutor>> withName =\n            ContainerUtil.findAll(pairs, new Condition<Pair<PsiMethod, PsiSubstitutor>>() {\n              public boolean value(Pair<PsiMethod, PsiSubstitutor> pair) {\n                return methodName.equals(pair.first.getName());\n              }\n            });\n          if (withName.size() == 1) {\n            return withName.get(0);\n          }\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"fa6abf812a4fb33a80843b4a4daab382078adebb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean hasConstructor(PsiClassType lType, PsiType[] argTypes, GroovyPsiElement context) {\n    final PsiClassType.ClassResolveResult resolveResult = lType.resolveGenerics();\n    final PsiClass psiClass = resolveResult.getElement();\n    final PsiSubstitutor substitutor = resolveResult.getSubstitutor();\n    if (psiClass == null) {\n      return false;\n    }\n\n    final GroovyResolveResult grResult = resolveResult instanceof GroovyResolveResult\n                                         ? (GroovyResolveResult)resolveResult\n                                         : new GroovyResolveResultImpl(psiClass, context, substitutor, true, true);\n    final GroovyResolveResult[] candidates = org.jetbrains.plugins.groovy.lang.psi.util.PsiUtil.getConstructorCandidates(\n      context, new GroovyResolveResult[]{grResult}, argTypes);\n    return candidates.length == 1;\n  }","id":71055,"modified_method":"private static boolean hasConstructor(PsiClassType lType, PsiType[] argTypes, GroovyPsiElement context) {\n    return getConstructorCandidates(lType, argTypes, context).length == 1;\n  }","commit_id":"fa6abf812a4fb33a80843b4a4daab382078adebb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static TypeConstraint[] calculateTypeConstraints(GrExpression expression) {\n    MyCalculator calculator = new MyCalculator(expression);\n    ((GroovyPsiElement)expression.getParent()).accept(calculator);\n    return calculator.getResult();\n  }","id":71056,"modified_method":"public static TypeConstraint[] calculateTypeConstraints(GrExpression expression) {\n    MyCalculator calculator = new MyCalculator(expression);\n    ((GroovyPsiElement)expression.getParent()).accept(calculator);\n    final TypeConstraint[] result = calculator.getResult();\n\n    List<TypeConstraint> custom = new ArrayList<TypeConstraint>();\n    for (GroovyExpectedTypesContributor contributor : GroovyExpectedTypesContributor.EP_NAME.getExtensions()) {\n      custom.addAll(contributor.calculateTypeConstraints(expression));\n    }\n\n    if (!custom.isEmpty()) {\n      custom.addAll(0, Arrays.asList(result));\n      return custom.toArray(new TypeConstraint[custom.size()]);\n    }\n\n    return result;\n  }","commit_id":"fa6abf812a4fb33a80843b4a4daab382078adebb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void clearCache() {\n    myCache.clear();\n  }","id":71057,"modified_method":"protected void clearCache() {\n    myCache.clear();\n    myQNameCache.clear();\n  }","commit_id":"745f1a4771b19b4335936239cafdbf4893d38569","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static PythonPathCache getPathCache(PsiElement foothold, PsiFile footholdFile) {\n    PythonPathCache cache = null;\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n    if (module != null) {\n      cache = PythonModulePathCache.getInstance(module);\n    }\n    else {\n      final Sdk sdk = PyBuiltinCache.findSdkForFile(footholdFile);\n      if (sdk != null) {\n        cache = PythonSdkPathCache.getInstance(foothold.getProject(), sdk);\n      }\n    }\n    return cache;\n  }","id":71058,"modified_method":"@Nullable\n  private static PythonPathCache getPathCache(PsiElement foothold) {\n    PythonPathCache cache = null;\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n    if (module != null) {\n      cache = PythonModulePathCache.getInstance(module);\n    }\n    else {\n      final Sdk sdk = PyBuiltinCache.findSdkForFile(foothold.getContainingFile());\n      if (sdk != null) {\n        cache = PythonSdkPathCache.getInstance(foothold.getProject(), sdk);\n      }\n    }\n    return cache;\n  }","commit_id":"745f1a4771b19b4335936239cafdbf4893d38569","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, @Nullable PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    PythonPathCache cache = getPathCache(foothold, footholdFile);\n    if (cache != null) {\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n\n    List<PsiElement> results;\n\n    if (PydevConsoleRunner.isInPydevConsole(foothold)) {\n      results = visitRootsInAllModules(moduleQualifiedName, foothold, footholdFile);\n    }\n    else {\n      results = visitRoots(moduleQualifiedName, foothold.getManager(), module, foothold, true);\n    }\n\n    if (cache != null) {\n      cache.put(moduleQualifiedName, results);\n    }\n    return results;\n  }","id":71059,"modified_method":"/**\n   * Returns the list of directories/files under different project roots which match the specified qualified name.\n   *\n   * @param moduleQualifiedName the qualified name to find\n   * @param foothold            the PSI element in the context of which the search is performed\n   * @return the list of matching directories or files, or an empty list if nothing was found\n   */\n  @NotNull\n  public static List<PsiElement> resolveModulesInRoots(@NotNull PyQualifiedName moduleQualifiedName, @Nullable PsiElement foothold) {\n    if (foothold == null || !foothold.isValid()) return Collections.emptyList();\n    PsiFile footholdFile = foothold.getContainingFile();\n    if (footholdFile == null || !footholdFile.isValid()) return Collections.emptyList();\n\n    PythonPathCache cache = getPathCache(foothold);\n    if (cache != null) {\n      final List<PsiElement> cachedResults = cache.get(moduleQualifiedName);\n      if (cachedResults != null) {\n        return cachedResults;\n      }\n    }\n\n    final Module module = ModuleUtil.findModuleForPsiElement(foothold);\n\n    List<PsiElement> results;\n\n    if (PydevConsoleRunner.isInPydevConsole(foothold)) {\n      results = visitRootsInAllModules(moduleQualifiedName, foothold, footholdFile);\n    }\n    else {\n      results = visitRoots(moduleQualifiedName, foothold.getManager(), module, foothold, true);\n    }\n\n    if (cache != null) {\n      cache.put(moduleQualifiedName, results);\n    }\n    return results;\n  }","commit_id":"745f1a4771b19b4335936239cafdbf4893d38569","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String findShortestImportableName(Module module, @NotNull VirtualFile vfile) {\n    PathChoosingVisitor visitor = new PathChoosingVisitor(vfile);\n    visitRoots(module, visitor);\n    final PyQualifiedName result = visitor.getResult();\n    return result == null ? null : result.toString();\n  }","id":71060,"modified_method":"@Nullable\n  public static String findShortestImportableName(Module module, @NotNull VirtualFile vfile) {\n    final PythonPathCache cache = PythonModulePathCache.getInstance(module);\n    final PyQualifiedName name = cache.getName(vfile);\n    if (name != null) {\n      return name.toString();\n    }\n    PathChoosingVisitor visitor = new PathChoosingVisitor(vfile);\n    visitRoots(module, visitor);\n    final PyQualifiedName result = visitor.getResult();\n    cache.putName(vfile, result);\n    return result == null ? null : result.toString();\n  }","commit_id":"745f1a4771b19b4335936239cafdbf4893d38569","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PyQualifiedName findShortestImportableQName(@NotNull PsiElement foothold, @NotNull VirtualFile vfile) {\n    PathChoosingVisitor visitor = new PathChoosingVisitor(vfile);\n    visitRoots(foothold, visitor);\n    return visitor.getResult();\n  }","id":71061,"modified_method":"@Nullable\n  public static PyQualifiedName findShortestImportableQName(@NotNull PsiElement foothold, @NotNull VirtualFile vfile) {\n    final PythonPathCache cache = getPathCache(foothold);\n    final PyQualifiedName name = cache != null ? cache.getName(vfile) : null;\n    if (name != null) {\n      return name;     \n    }\n    PathChoosingVisitor visitor = new PathChoosingVisitor(vfile);\n    visitRoots(foothold, visitor);\n    final PyQualifiedName result = visitor.getResult();\n    if (cache != null) {\n      cache.putName(vfile, result);\n    }\n    return result;\n  }","commit_id":"745f1a4771b19b4335936239cafdbf4893d38569","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void showDiff(@NotNull final DiffElement dir1,\n                       @NotNull final DiffElement dir2,\n                       final DirDiffSettings settings,\n                       @Nullable final Runnable onWindowClose) {\n    final DirDiffTableModel model = new DirDiffTableModel(myProject, dir1, dir2, settings);\n    if (settings.showInFrame) {\n      DirDiffFrame frame = new DirDiffFrame(myProject, model);\n      if (onWindowClose != null) {\n        final JFrame jFrame = frame.getFrame();\n        jFrame.addWindowListener(new WindowAdapter() {\n          @Override\n          public void windowClosed(WindowEvent e) {\n            onWindowClose.run();\n            jFrame.removeWindowListener(this);\n          }\n        });\n      }\n      frame.show();\n    } else {\n      DirDiffDialog dirDiffDialog = new DirDiffDialog(myProject, model);\n      if (myProject == null || myProject.isDefault()) {\n        dirDiffDialog.setModal(true);\n      }\n      if (onWindowClose != null) {\n        final Window owner = dirDiffDialog.getOwner();\n        owner.addWindowListener(new WindowAdapter() {\n          @Override\n          public void windowClosed(WindowEvent e) {\n            onWindowClose.run();\n            owner.removeWindowListener(this);\n          }\n        });\n      }\n      dirDiffDialog.show();\n    }\n  }","id":71062,"modified_method":"@Override\n  public void showDiff(@NotNull final DiffElement dir1,\n                       @NotNull final DiffElement dir2,\n                       final DirDiffSettings settings,\n                       @Nullable final Runnable onWindowClose) {\n    final DirDiffTableModel model = new DirDiffTableModel(myProject, dir1, dir2, settings);\n    if (settings.showInFrame) {\n      DirDiffFrame frame = new DirDiffFrame(myProject, model);\n      setWindowListener(onWindowClose, frame.getFrame());\n      frame.show();\n    } else {\n      DirDiffDialog dirDiffDialog = new DirDiffDialog(myProject, model);\n      if (myProject == null || myProject.isDefault()) {\n        dirDiffDialog.setModal(true);\n      }\n      setWindowListener(onWindowClose, dirDiffDialog.getOwner());\n      dirDiffDialog.show();\n    }\n  }","commit_id":"38649f76065e84ad1be90c62e31c415f6a9950e1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    for (SReference ref : ((SNode) MapSequence.fromMap(_params).get(\"selectedNode\")).getReferences()) {\n      SModelReference mr = ref.getTargetSModelReference();\n      if (mr == null) {\n        continue;\n      }\n      SModel model = mr.resolve(MPSModuleRepository.getInstance());\n      if (model == null) {\n        continue;\n      }\n      if (!(new GlobalModuleDependenciesManager(((SModule) MapSequence.fromMap(_params).get(\"module\"))).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE).contains(model.getModule()))) {\n        return true;\n      }\n    }\n    return false;\n  }","id":71063,"modified_method":"public boolean isApplicable(AnActionEvent event, final Map<String, Object> _params) {\n    return new DependencyHelper(((SNode) MapSequence.fromMap(_params).get(\"selectedNode\")), ProjectHelper.toIdeaProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")))).isApplicable();\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      for (SReference ref : ((SNode) MapSequence.fromMap(_params).get(\"selectedNode\")).getReferences()) {\n        SModelReference mr = ref.getTargetSModelReference();\n        if (mr == null) {\n          continue;\n        }\n        SModel model = mr.resolve(MPSModuleRepository.getInstance());\n        if (model == null) {\n          continue;\n        }\n        if (!(new GlobalModuleDependenciesManager(((SModule) MapSequence.fromMap(_params).get(\"module\"))).getModules(GlobalModuleDependenciesManager.Deptype.VISIBLE).contains(model.getModule()))) {\n          ((AbstractModule) ((SModule) MapSequence.fromMap(_params).get(\"module\"))).addDependency(model.getModule().getModuleReference(), false);\n        }\n      }\n      ClassLoaderManager.getInstance().reloadAll(new EmptyProgressMonitor());\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"AddMissingDependency\", t);\n      }\n    }\n  }","id":71064,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      new DependencyHelper(((SNode) MapSequence.fromMap(_params).get(\"selectedNode\")), ProjectHelper.toIdeaProject(((MPSProject) MapSequence.fromMap(_params).get(\"project\")))).execute();\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"AddMissingDependency\", t);\n      }\n    }\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n      }\n      MapSequence.fromMap(_params).put(\"selectedNode\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"selectedNode\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorContext\", event.getData(MPSEditorDataKeys.EDITOR_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"editorContext\") == null) {\n      return false;\n    }\n    return true;\n  }","id":71065,"modified_method":"protected boolean collectActionData(AnActionEvent event, final Map<String, Object> _params) {\n    if (!(super.collectActionData(event, _params))) {\n      return false;\n    }\n    {\n      SNode node = event.getData(MPSCommonDataKeys.NODE);\n      if (node != null) {\n      }\n      MapSequence.fromMap(_params).put(\"selectedNode\", node);\n    }\n    if (MapSequence.fromMap(_params).get(\"selectedNode\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"module\", event.getData(MPSCommonDataKeys.CONTEXT_MODULE));\n    if (MapSequence.fromMap(_params).get(\"module\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"editorContext\", event.getData(MPSEditorDataKeys.EDITOR_CONTEXT));\n    if (MapSequence.fromMap(_params).get(\"editorContext\") == null) {\n      return false;\n    }\n    MapSequence.fromMap(_params).put(\"project\", event.getData(MPSCommonDataKeys.MPS_PROJECT));\n    if (MapSequence.fromMap(_params).get(\"project\") == null) {\n      return false;\n    }\n    return true;\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,\n        0, false));\n    panel1.setBorder(\n        BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final com.intellij.uiDesigner.core.Spacer spacer1 = new com.intellij.uiDesigner.core.Spacer();\n    panel1.add(spacer1, new com.intellij.uiDesigner.core.GridConstraints(1, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(3, 2, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new com.intellij.uiDesigner.core.GridConstraints(2, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,\n        0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword, new com.intellij.uiDesigner.core.GridConstraints(1, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new com.intellij.uiDesigner.core.GridConstraints(2, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_EAST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer2 = new com.intellij.uiDesigner.core.Spacer();\n    panel1.add(spacer2, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(8, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null, null,\n        null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Description (what did you do,what happened instead of expected behavior):\");\n    panel2.add(label3, new com.intellij.uiDesigner.core.GridConstraints(2, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer3 = new com.intellij.uiDesigner.core.Spacer();\n    panel2.add(spacer3, new com.intellij.uiDesigner.core.GridConstraints(2, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new com.intellij.uiDesigner.core.GridConstraints(3, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null,\n        new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer4 = new com.intellij.uiDesigner.core.Spacer();\n    panel2.add(spacer4, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final com.intellij.uiDesigner.core.Spacer spacer5 = new com.intellij.uiDesigner.core.Spacer();\n    panel2.add(spacer5, new com.intellij.uiDesigner.core.GridConstraints(4, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    myHiddenCheckBox = new JCheckBox();\n    myHiddenCheckBox.setText(\"Visible only to MPS developers\");\n    myHiddenCheckBox.setToolTipText(\"Select this if you want this bug report will be visible only to you and MPS developers \");\n    panel2.add(myHiddenCheckBox, new com.intellij.uiDesigner.core.GridConstraints(7, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myExceptionContainer = new JPanel();\n    myExceptionContainer.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myExceptionContainer.setEnabled(true);\n    panel2.add(myExceptionContainer, new com.intellij.uiDesigner.core.GridConstraints(6, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null,\n        0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    myExceptionContainer.add(label5, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final com.intellij.uiDesigner.core.Spacer spacer6 = new com.intellij.uiDesigner.core.Spacer();\n    myExceptionContainer.add(spacer6, new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null, null, 0,\n        false));\n    final JScrollPane scrollPane2 = new JScrollPane();\n    myExceptionContainer.add(scrollPane2,\n        new com.intellij.uiDesigner.core.GridConstraints(1, 0, 1, 2, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_CENTER,\n            com.intellij.uiDesigner.core.GridConstraints.FILL_BOTH,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_WANT_GROW, null,\n            new Dimension(0, 220), null, 0, false));\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","id":71066,"modified_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myPanel = new JPanel();\n    myPanel.setLayout(new GridLayoutManager(2, 1, new Insets(0, 0, 0, 0), -1, -1));\n    final JPanel panel1 = new JPanel();\n    panel1.setLayout(new GridLayoutManager(3, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    panel1.setBorder(\n        BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Bugtracker login settings\", TitledBorder.LEFT, TitledBorder.DEFAULT_POSITION));\n    final Spacer spacer1 = new Spacer();\n    panel1.add(spacer1,\n        new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    myLoginPanel = new JPanel();\n    myLoginPanel.setLayout(new GridLayoutManager(3, 2, new Insets(0, 5, 0, 0), -1, -1));\n    panel1.add(myLoginPanel, new GridConstraints(2, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Username:\");\n    myLoginPanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myUsername = new JTextField();\n    myUsername.setEnabled(false);\n    myLoginPanel.add(myUsername,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,\n            GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label2 = new JLabel();\n    label2.setText(\"Password:\");\n    myLoginPanel.add(label2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myPassword = new JPasswordField();\n    myPassword.setEnabled(false);\n    myLoginPanel.add(myPassword,\n        new GridConstraints(1, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,\n            GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    myTestLoginButton = new JButton();\n    myTestLoginButton.setEnabled(false);\n    myTestLoginButton.setText(\"Test Login\");\n    myLoginPanel.add(myTestLoginButton, new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_EAST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myRegisteredRadio = new JRadioButton();\n    myRegisteredRadio.setText(\"Registered user\");\n    panel1.add(myRegisteredRadio, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myAnonymousRadio = new JRadioButton();\n    myAnonymousRadio.setSelected(true);\n    myAnonymousRadio.setText(\"Anonymous\");\n    panel1.add(myAnonymousRadio, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer2 = new Spacer();\n    panel1.add(spacer2,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final JPanel panel2 = new JPanel();\n    panel2.setLayout(new GridLayoutManager(8, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myPanel.add(panel2, new GridConstraints(1, 0, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, null, null, 0, false));\n    panel2.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(), \"Issue properties\"));\n    final JLabel label3 = new JLabel();\n    label3.setText(\"Description (what did you do,what happened instead of expected behavior):\");\n    panel2.add(label3, new GridConstraints(2, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer3 = new Spacer();\n    panel2.add(spacer3,\n        new GridConstraints(2, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final JScrollPane scrollPane1 = new JScrollPane();\n    panel2.add(scrollPane1, new GridConstraints(3, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 37), null, 0, false));\n    myDescription = new JTextArea();\n    myDescription.setEditable(true);\n    myDescription.setText(\"\");\n    scrollPane1.setViewportView(myDescription);\n    myTitleField = new JTextField();\n    panel2.add(myTitleField, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_FIXED, null, new Dimension(150, -1), null, 0, false));\n    final JLabel label4 = new JLabel();\n    label4.setText(\"Title:\");\n    panel2.add(label4, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer4 = new Spacer();\n    panel2.add(spacer4,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final Spacer spacer5 = new Spacer();\n    panel2.add(spacer5,\n        new GridConstraints(4, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    myHiddenCheckBox = new JCheckBox();\n    myHiddenCheckBox.setText(\"Visible only to MPS developers\");\n    myHiddenCheckBox.setToolTipText(\"Select this if you want this bug report will be visible only to you and MPS developers \");\n    panel2.add(myHiddenCheckBox, new GridConstraints(7, 0, 1, 2, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myExceptionContainer = new JPanel();\n    myExceptionContainer.setLayout(new GridLayoutManager(2, 2, new Insets(0, 0, 0, 0), -1, -1));\n    myExceptionContainer.setEnabled(true);\n    panel2.add(myExceptionContainer, new GridConstraints(6, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, null, null, null, 0, false));\n    final JLabel label5 = new JLabel();\n    label5.setText(\"Exception:\");\n    myExceptionContainer.add(label5, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    final Spacer spacer6 = new Spacer();\n    myExceptionContainer.add(spacer6,\n        new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_HORIZONTAL, GridConstraints.SIZEPOLICY_WANT_GROW, 1, null, null,\n            null, 0, false));\n    final JScrollPane scrollPane2 = new JScrollPane();\n    myExceptionContainer.add(scrollPane2, new GridConstraints(1, 0, 1, 2, GridConstraints.ANCHOR_CENTER, GridConstraints.FILL_BOTH,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_WANT_GROW, null, new Dimension(0, 220), null, 0, false));\n    myException = new JTextArea();\n    myException.setEditable(false);\n    scrollPane2.setViewportView(myException);\n    ButtonGroup buttonGroup;\n    buttonGroup = new ButtonGroup();\n    buttonGroup.add(myRegisteredRadio);\n    buttonGroup.add(myAnonymousRadio);\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddMissingImportsInProject_Action());\n    addAction(new AddMissingImports_Action());\n    addAction(new AddModuleToProject_Action());\n    addAction(new AddToNewFavoritesList_Action());\n    addAction(new AnalyzeClasspath_Action());\n    addAction(new AnalyzeModuleDependencies_Action());\n    addAction(new AnalyzeStacktrace_Action());\n    addAction(new CalcClassifiersInRootsStatistic_Action());\n    addAction(new CalcSNodeStatistic_Action());\n    addAction(new CloneModel_Action());\n    addAction(new CloneRoot_Action());\n    addAction(new ConvertToBinaryPersistence_Action());\n    addAction(new ConvertToFilePerRootPersistence_Action());\n    addAction(new CopyModelName_Action());\n    addAction(new CopyModuleName_Action());\n    addAction(new CopyNodeName_Action());\n    addAction(new CopyNodeReference_Action());\n    addAction(new CopyNode_Action());\n    addAction(new CutNode_Action());\n    addAction(new DeleteFavoritesList_Action());\n    addAction(new DeleteModels_Action());\n    addAction(new DeleteModules_Action());\n    addAction(new DeleteNode_Action());\n    addAction(new DeletePropertyAction_Action());\n    addAction(new DeleteReferenceAction_Action());\n    addAction(new ExpandNode_Action());\n    addAction(new FastFindNodeUsages_Action());\n    addAction(new FindConceptInstances_Action());\n    addAction(new FindModelUsages_Action());\n    addAction(new FindRootableConceptsWithoutIcons_Action());\n    addAction(new FindSpecificNodeUsages_Action());\n    addAction(new FindUnusedAndDeprecatedConcepts_Action());\n    addAction(new ForcedSaveAll_Action());\n    addAction(new GoByCurrentReferenceToIDEA_Action());\n    addAction(new GoToModel_Action());\n    addAction(new GoToModule_Action());\n    addAction(new GoToNode_Action());\n    addAction(new GoToRootNode_Action());\n    addAction(new GoToRule_Action());\n    addAction(new HighlightInstances_Action());\n    addAction(new HighlightUsages_Action());\n    addAction(new MPSProjectPaths_Action());\n    addAction(new ModelProperties_Action());\n    addAction(new ModuleProperties_Action());\n    addAction(new MoveFileOrDirectory_Action());\n    addAction(new NewDirectory_Action());\n    addAction(new NewElement_Action());\n    addAction(new NewFile_Action());\n    addAction(new NewModel_Action());\n    addAction(new NewRuntimeModule_Action());\n    addAction(new NewSolution_Action());\n    addAction(new NewSubModel_Action());\n    addAction(new NewSubTestModel_Action());\n    addAction(new OptimizeModelImports_Action());\n    addAction(new OptimizeModuleImports_Action());\n    addAction(new OptimizeProjectImports_Action());\n    addAction(new PasteNode_Action());\n    addAction(new PrintNodePosition_Action());\n    addAction(new RemoveAllBookmarks_Action());\n    addAction(new RemoveFromFavorites_Action());\n    addAction(new RemoveModuleFromProject_Action());\n    addAction(new RemoveTransientModels_Action());\n    addAction(new RenameFavoritesList_Action());\n    addAction(new RenameFileOrDirectory_Action());\n    addAction(new RenameModel_Action());\n    addAction(new RenameNamespace_Action());\n    addAction(new RenamePackage_Action());\n    addAction(new RenameSolution_Action());\n    addAction(new RevertMemoryChanges_Action());\n    addAction(new SafeDeleteModuleDependency_Action());\n    addAction(new SafeDelete_Action());\n    addAction(new SetBookmarkNoNumber_Action());\n    addAction(new SetModuleFolder_Action());\n    addAction(new SetNodePackage_Action());\n    addAction(new SetPluginIdToCompileInIdeaModules_Action());\n    addAction(new ShowBookmarksDialog_Action());\n    addAction(new ShowBookmarks_Action());\n    addAction(new ShowClassInHierarchy_Action());\n    addAction(new ShowConceptInHierarchy_Action());\n    addAction(new ShowDependenciesInViewer_Action());\n    addAction(new ShowErrorMessage_Action());\n    addAction(new ShowImplementations_Action());\n    addAction(new ShowInDependenciesViewer_Action());\n    addAction(new ShowInLogicalView_Action());\n    addAction(new ShowModuleBootstrapDependency_Action());\n    addAction(new ShowModuleDependencyLoop_Action());\n    addAction(new ShowNodeInInspector_Action());\n    addAction(new ShowNodeInfo_Action());\n    addAction(new ShowParameters_Action());\n    addAction(new ShowTodoViewer_Action());\n    addAction(new SubmitToTracker_Action());\n    // groups \n    addGroup(new AbstractFileActions_ActionGroup());\n    addGroup(new AddToFavoritesGroup_ActionGroup());\n    addGroup(new AnalyzeModule_ActionGroup());\n    addGroup(new Analyze_ActionGroup());\n    addGroup(new Bookmarks_ActionGroup());\n    addGroup(new Build_ActionGroup());\n    addGroup(new CommonModuleActions_ActionGroup());\n    addGroup(new CreateRootNode_ActionGroup());\n    addGroup(new DebugActions_ActionGroup());\n    addGroup(new DevkitActions_ActionGroup());\n    addGroup(new Edit_ActionGroup());\n    addGroup(new EditorActionsAddition_ActionGroup());\n    addGroup(new EditorInternal_ActionGroup());\n    addGroup(new EditorPopupEx_ActionGroup());\n    addGroup(new EditorPopupEx_Goto_ActionGroup());\n    addGroup(new EditorPopup_Show_ActionGroup());\n    addGroup(new FavoritesPopupWrapper_ActionGroup());\n    addGroup(new FavoritesPopup_ActionGroup());\n    addGroup(new Favorites_ActionGroup());\n    addGroup(new FileActions_ActionGroup());\n    addGroup(new FileSystemNewActions_ActionGroup());\n    addGroup(new FindModelUsages_ActionGroup());\n    addGroup(new FindUsages_ActionGroup());\n    addGroup(new FlyingActions_ActionGroup());\n    addGroup(new FolderActions_ActionGroup());\n    addGroup(new GeneratorActions_ActionGroup());\n    addGroup(new GeneratorNewActions_ActionGroup());\n    addGroup(new GoByReference_ActionGroup());\n    addGroup(new Goto_ActionGroup());\n    addGroup(new JUnitTestCaseActions_ActionGroup());\n    addGroup(new JUnitTestMethodActions_ActionGroup());\n    addGroup(new LanguageActions_ActionGroup());\n    addGroup(new LanguageNewActions_ActionGroup());\n    addGroup(new MessagesViewActions_ActionGroup());\n    addGroup(new ModelActions_ActionGroup());\n    addGroup(new ModelNewActions_ActionGroup());\n    addGroup(new ModelRefactoring_ActionGroup());\n    addGroup(new ModuleActions_ActionGroup());\n    addGroup(new NamespaceActions_ActionGroup());\n    addGroup(new NamespaceInternalActions_ActionGroup());\n    addGroup(new NamespaceMakeActions_ActionGroup());\n    addGroup(new NamespaceNewActions_ActionGroup());\n    addGroup(new NodeActions_ActionGroup());\n    addGroup(new PackageActions_ActionGroup());\n    addGroup(new PackageNewActions_ActionGroup());\n    addGroup(new PrintNodePosition_Addition_ActionGroup());\n    addGroup(new ProjectActions_ActionGroup());\n    addGroup(new ProjectNewActions_ActionGroup());\n    addGroup(new PropertyNodeActions_ActionGroup());\n    addGroup(new ReferenceNodeActions_ActionGroup());\n    addGroup(new RuntimeFolderActions_ActionGroup());\n    addGroup(new Search_ActionGroup());\n    addGroup(new SolutionActions_ActionGroup());\n    addGroup(new SolutionNewActions_ActionGroup());\n    addGroup(new SolutionRefactoring_ActionGroup());\n    addGroup(new ToolsInternal_ActionGroup());\n    addGroup(new Tools_ActionGroup());\n    addGroup(new TransientModulesActions_ActionGroup());\n    addGroup(new View_ActionGroup());\n  }","id":71067,"modified_method":"public void createGroups() {\n    // actions w/o parameters \n    addAction(new AddModuleToProject_Action());\n    addAction(new AddToNewFavoritesList_Action());\n    addAction(new AnalyzeClasspath_Action());\n    addAction(new AnalyzeModuleDependencies_Action());\n    addAction(new AnalyzeStacktrace_Action());\n    addAction(new CalcClassifiersInRootsStatistic_Action());\n    addAction(new CalcSNodeStatistic_Action());\n    addAction(new CloneModel_Action());\n    addAction(new CloneRoot_Action());\n    addAction(new ConvertToBinaryPersistence_Action());\n    addAction(new ConvertToFilePerRootPersistence_Action());\n    addAction(new CopyModelName_Action());\n    addAction(new CopyModuleName_Action());\n    addAction(new CopyNodeName_Action());\n    addAction(new CopyNodeReference_Action());\n    addAction(new CopyNode_Action());\n    addAction(new CutNode_Action());\n    addAction(new DeleteFavoritesList_Action());\n    addAction(new DeleteModels_Action());\n    addAction(new DeleteModules_Action());\n    addAction(new DeleteNode_Action());\n    addAction(new DeletePropertyAction_Action());\n    addAction(new DeleteReferenceAction_Action());\n    addAction(new ExpandNode_Action());\n    addAction(new FastFindNodeUsages_Action());\n    addAction(new FindConceptInstances_Action());\n    addAction(new FindModelUsages_Action());\n    addAction(new FindRootableConceptsWithoutIcons_Action());\n    addAction(new FindSpecificNodeUsages_Action());\n    addAction(new FindUnusedAndDeprecatedConcepts_Action());\n    addAction(new FixModuleImportsInProject_Action());\n    addAction(new FixModuleImports_Action());\n    addAction(new ForcedSaveAll_Action());\n    addAction(new GoByCurrentReferenceToIDEA_Action());\n    addAction(new GoToModel_Action());\n    addAction(new GoToModule_Action());\n    addAction(new GoToNode_Action());\n    addAction(new GoToRootNode_Action());\n    addAction(new GoToRule_Action());\n    addAction(new HighlightInstances_Action());\n    addAction(new HighlightUsages_Action());\n    addAction(new MPSProjectPaths_Action());\n    addAction(new ModelProperties_Action());\n    addAction(new ModuleProperties_Action());\n    addAction(new MoveFileOrDirectory_Action());\n    addAction(new NewDirectory_Action());\n    addAction(new NewElement_Action());\n    addAction(new NewFile_Action());\n    addAction(new NewModel_Action());\n    addAction(new NewRuntimeModule_Action());\n    addAction(new NewSolution_Action());\n    addAction(new NewSubModel_Action());\n    addAction(new NewSubTestModel_Action());\n    addAction(new OptimizeModelImports_Action());\n    addAction(new OptimizeModuleImports_Action());\n    addAction(new OptimizeProjectImports_Action());\n    addAction(new PasteNode_Action());\n    addAction(new PrintNodePosition_Action());\n    addAction(new RemoveAllBookmarks_Action());\n    addAction(new RemoveFromFavorites_Action());\n    addAction(new RemoveModuleFromProject_Action());\n    addAction(new RemoveTransientModels_Action());\n    addAction(new RenameFavoritesList_Action());\n    addAction(new RenameFileOrDirectory_Action());\n    addAction(new RenameModel_Action());\n    addAction(new RenameNamespace_Action());\n    addAction(new RenamePackage_Action());\n    addAction(new RenameSolution_Action());\n    addAction(new RevertMemoryChanges_Action());\n    addAction(new SafeDeleteModuleDependency_Action());\n    addAction(new SafeDelete_Action());\n    addAction(new SetBookmarkNoNumber_Action());\n    addAction(new SetModuleFolder_Action());\n    addAction(new SetNodePackage_Action());\n    addAction(new SetPluginIdToCompileInIdeaModules_Action());\n    addAction(new ShowBookmarksDialog_Action());\n    addAction(new ShowBookmarks_Action());\n    addAction(new ShowClassInHierarchy_Action());\n    addAction(new ShowConceptInHierarchy_Action());\n    addAction(new ShowDependenciesInViewer_Action());\n    addAction(new ShowErrorMessage_Action());\n    addAction(new ShowImplementations_Action());\n    addAction(new ShowInDependenciesViewer_Action());\n    addAction(new ShowInLogicalView_Action());\n    addAction(new ShowModuleBootstrapDependency_Action());\n    addAction(new ShowModuleDependencyLoop_Action());\n    addAction(new ShowNodeInInspector_Action());\n    addAction(new ShowNodeInfo_Action());\n    addAction(new ShowParameters_Action());\n    addAction(new ShowTodoViewer_Action());\n    addAction(new SubmitToTracker_Action());\n    // groups \n    addGroup(new AbstractFileActions_ActionGroup());\n    addGroup(new AddToFavoritesGroup_ActionGroup());\n    addGroup(new AnalyzeModule_ActionGroup());\n    addGroup(new Analyze_ActionGroup());\n    addGroup(new Bookmarks_ActionGroup());\n    addGroup(new Build_ActionGroup());\n    addGroup(new CommonModuleActions_ActionGroup());\n    addGroup(new CreateRootNode_ActionGroup());\n    addGroup(new DebugActions_ActionGroup());\n    addGroup(new DevkitActions_ActionGroup());\n    addGroup(new Edit_ActionGroup());\n    addGroup(new EditorActionsAddition_ActionGroup());\n    addGroup(new EditorInternal_ActionGroup());\n    addGroup(new EditorPopupEx_ActionGroup());\n    addGroup(new EditorPopupEx_Goto_ActionGroup());\n    addGroup(new EditorPopup_Show_ActionGroup());\n    addGroup(new FavoritesPopupWrapper_ActionGroup());\n    addGroup(new FavoritesPopup_ActionGroup());\n    addGroup(new Favorites_ActionGroup());\n    addGroup(new FileActions_ActionGroup());\n    addGroup(new FileSystemNewActions_ActionGroup());\n    addGroup(new FindModelUsages_ActionGroup());\n    addGroup(new FindUsages_ActionGroup());\n    addGroup(new FlyingActions_ActionGroup());\n    addGroup(new FolderActions_ActionGroup());\n    addGroup(new GeneratorActions_ActionGroup());\n    addGroup(new GeneratorNewActions_ActionGroup());\n    addGroup(new GoByReference_ActionGroup());\n    addGroup(new Goto_ActionGroup());\n    addGroup(new JUnitTestCaseActions_ActionGroup());\n    addGroup(new JUnitTestMethodActions_ActionGroup());\n    addGroup(new LanguageActions_ActionGroup());\n    addGroup(new LanguageNewActions_ActionGroup());\n    addGroup(new MessagesViewActions_ActionGroup());\n    addGroup(new ModelActions_ActionGroup());\n    addGroup(new ModelNewActions_ActionGroup());\n    addGroup(new ModelRefactoring_ActionGroup());\n    addGroup(new ModuleActions_ActionGroup());\n    addGroup(new NamespaceActions_ActionGroup());\n    addGroup(new NamespaceInternalActions_ActionGroup());\n    addGroup(new NamespaceMakeActions_ActionGroup());\n    addGroup(new NamespaceNewActions_ActionGroup());\n    addGroup(new NodeActions_ActionGroup());\n    addGroup(new PackageActions_ActionGroup());\n    addGroup(new PackageNewActions_ActionGroup());\n    addGroup(new PrintNodePosition_Addition_ActionGroup());\n    addGroup(new ProjectActions_ActionGroup());\n    addGroup(new ProjectNewActions_ActionGroup());\n    addGroup(new PropertyNodeActions_ActionGroup());\n    addGroup(new ReferenceNodeActions_ActionGroup());\n    addGroup(new RuntimeFolderActions_ActionGroup());\n    addGroup(new Search_ActionGroup());\n    addGroup(new SolutionActions_ActionGroup());\n    addGroup(new SolutionNewActions_ActionGroup());\n    addGroup(new SolutionRefactoring_ActionGroup());\n    addGroup(new ToolsInternal_ActionGroup());\n    addGroup(new Tools_ActionGroup());\n    addGroup(new TransientModulesActions_ActionGroup());\n    addGroup(new View_ActionGroup());\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public AddModelItem(Project project, SModel model, SModelReference modelToAdd, SModule currentModule) {\n      super(modelToAdd);\n      myProject = project;\n      myModel = model;\n      myModule = currentModule;\n    }","id":71068,"modified_method":"public AddModelItem(Project project, SModel model, SModelReference modelToImport) {\n      super(modelToImport);\n      myProject = project;\n      myModel = model;\n    }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void navigate(boolean requestFocus) {\n      final SModuleReference[] module = {null};\n      final boolean[] dependency = {true};\n\n      ModelAccess.instance().runReadAction(new Runnable() {\n        @Override\n        public void run() {\n          SModelReference mrefToImport = getModelReference();\n          SModel modelToImport = SModelRepository.getInstance().getModelDescriptor(mrefToImport);\n          SModule moduleToImport = modelToImport.getModule();\n\n          if (moduleToImport instanceof Language &&\n              myModule instanceof Solution &&\n              ((Language) moduleToImport).isAccessoryModel(mrefToImport)\n              ) {\n            dependency[0] = false;\n          }\n\n          if (!VisibilityUtil.isVisible(myModule, modelToImport)) {\n            module[0] = moduleToImport.getModuleReference();\n          }\n        }\n      });\n\n      if (module[0] != null) {\n        int res;\n        if (TemporaryModels.isTemporary(myModel)) {\n          res = JOptionPane.YES_OPTION;\n        } else {\n          res = JOptionPane.showConfirmDialog(getFrame(),\n              \"<html>Model <b>\" + getModelReference().getModelName() + \"<\/b> is owned by module <b>\" + module[0].getModuleName() +\n                  \"<\/b> which is not imported.<\/html>\\n\\n\" +\n\n                  \"Importing the module will take some time.\\n\" +\n                  \"Do you want to automatically import the module?\",\n              \"Module import\", JOptionPane.YES_NO_OPTION);\n        }\n        if (res == JOptionPane.YES_OPTION) {\n          ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n            @Override\n            public void run() {\n              if (dependency[0]) {\n                ((AbstractModule) myModule).addDependency(module[0], false);\n                ((jetbrains.mps.smodel.SModelInternal) myModel).addModelImport(getModelReference(), false);\n              } else {\n                ((AbstractModule) myModule).addUsedLanguage(module[0]);\n                ((jetbrains.mps.smodel.SModelInternal) myModel).addLanguage(module[0]);\n              }\n              ClassLoaderManager.getInstance().unloadClasses(Arrays.asList(myModule), new EmptyProgressMonitor());\n              ClassLoaderManager.getInstance().loadAllPossibleClasses(new EmptyProgressMonitor());\n            }\n          });\n        }\n      } else {\n        ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n          @Override\n          public void run() {\n            ((jetbrains.mps.smodel.SModelInternal) myModel).addModelImport(getModelReference(), false);\n          }\n        });\n      }\n    }","id":71069,"modified_method":"@Override\n    public void navigate(boolean requestFocus) {\n      SModelReference modelToImport = getModelReference();\n      new ModelImporter(myModel, getFrame()).execute(modelToImport);\n    }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImport(final Project project, final SModule module, final SModel model,\n      @Nullable BaseAction parentAction) {\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      @Override\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new AddModelItem(project, model, modelReference, module);\n      }\n\n      @Override\n      public SModelReference[] find(SearchScope scope) {\n        Condition<SModel> cond = new Condition<SModel>() {\n          @Override\n          public boolean met(SModel modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n                || SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(modelDescriptor));\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModel> iter = new ConditionalIterable<SModel>(scope.getModels(), cond);\n        List<SModelReference> filteredModelRefs = new ArrayList<SModelReference>();\n        for (SModel md : iter) {\n          filteredModelRefs.add(md.getReference());\n        }\n        return filteredModelRefs.toArray(new SModelReference[filteredModelRefs.size()]);\n      }\n\n      @Override\n      @Nullable\n      public String getPromptText() {\n        return \"Import model:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel, parentAction);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      @Override\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      @Override\n      public void elementChosen(final Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","id":71070,"modified_method":"public static void addModelImport(final Project project, final SModule module, final SModel model,\n      @Nullable BaseAction parentAction) {\n    BaseModelModel goToModelModel = new BaseModelModel(project) {\n      @Override\n      public NavigationItem doGetNavigationItem(final SModelReference modelReference) {\n        return new AddModelItem(project, model, modelReference);\n      }\n\n      @Override\n      public SModelReference[] find(SearchScope scope) {\n        Condition<SModel> cond = new Condition<SModel>() {\n          @Override\n          public boolean met(SModel modelDescriptor) {\n            boolean rightStereotype = SModelStereotype.isUserModel(modelDescriptor)\n                || SModelStereotype.isStubModelStereotype(SModelStereotype.getStereotype(modelDescriptor));\n            boolean hasModule = modelDescriptor.getModule() != null;\n            return rightStereotype && hasModule;\n          }\n        };\n        ConditionalIterable<SModel> iter = new ConditionalIterable<SModel>(scope.getModels(), cond);\n        List<SModelReference> filteredModelRefs = new ArrayList<SModelReference>();\n        for (SModel md : iter) {\n          filteredModelRefs.add(md.getReference());\n        }\n        return filteredModelRefs.toArray(new SModelReference[filteredModelRefs.size()]);\n      }\n\n      @Override\n      @Nullable\n      public String getPromptText() {\n        return \"Import model:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createPackagePopup(project, goToModelModel, parentAction);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      @Override\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      @Override\n      public void elementChosen(final Object element) {\n        ((NavigationItem) element).navigate(true);\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addModelImportByRoot(final Project project, final SModule contextModule, final SModel model,\n      String initialText, @Nullable BaseAction parentAction, final ModelImportByRootCallback callback) {\n    BaseMPSChooseModel goToNodeModel = new RootChooseModel(project, new RootNodeNameIndex()) {\n      @Override\n      public NavigationItem doGetNavigationItem(final NavigationTarget object) {\n        return new RootNodeElement(object) {\n          @Override\n          public void navigate(boolean requestFocus) {\n            ModelAccess.assertLegalRead();\n            new AddModelItem(project, model, object.getNodeReference().getModelReference(), contextModule).navigate(requestFocus);\n          }\n        };\n      }\n\n      @Override\n      @Nullable\n      public String getPromptText() {\n        return \"Import model that contains root:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText, parentAction);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      @Override\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      @Override\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            NavigationItem navigationItem = (NavigationItem) element;\n            navigationItem.navigate(true);\n            callback.importForRootAdded(navigationItem.getPresentation().getPresentableText());\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","id":71071,"modified_method":"public static void addModelImportByRoot(final Project project, final SModule contextModule, final SModel model,\n      String initialText, @Nullable BaseAction parentAction, final ModelImportByRootCallback callback) {\n    BaseMPSChooseModel goToNodeModel = new RootChooseModel(project, new RootNodeNameIndex()) {\n      @Override\n      public NavigationItem doGetNavigationItem(final NavigationTarget object) {\n        return new RootNodeElement(object) {\n          @Override\n          public void navigate(boolean requestFocus) {\n            ModelAccess.assertLegalRead();\n            new AddModelItem(project, model, object.getNodeReference().getModelReference()).navigate(requestFocus);\n          }\n        };\n      }\n\n      @Override\n      @Nullable\n      public String getPromptText() {\n        return \"Import model that contains root:\";\n      }\n    };\n    ChooseByNamePopup popup = MpsPopupFactory.createNodePopup(project, goToNodeModel, initialText, parentAction);\n\n    popup.invoke(new ChooseByNamePopupComponent.Callback() {\n      @Override\n      public void onClose() {\n        //if (GoToRootNodeAction.class.equals(myInAction)) myInAction = null;\n      }\n\n      @Override\n      public void elementChosen(final Object element) {\n        ModelAccess.instance().runWriteAction(new Runnable() {\n          @Override\n          public void run() {\n            NavigationItem navigationItem = (NavigationItem) element;\n            navigationItem.navigate(true);\n            callback.importForRootAdded(navigationItem.getPresentation().getPresentableText());\n          }\n        });\n      }\n    }, ModalityState.current(), true);\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void execute(SNode node) {\n    SLanguage language = node.getConcept().getLanguage();\n    Language languageModule = ModuleRepositoryFacade.getInstance().getModule(language.getQualifiedName(), Language.class);\n    // todo: use SLanguage for used languages in model and module! \n    ((SModelInternal) SNodeOperations.getModel(node)).addLanguage(languageModule.getModuleReference());\n    ((AbstractModule) SNodeOperations.getModel(node).getModule()).addUsedLanguage(languageModule.getModuleReference());\n  }","id":71072,"modified_method":"public void execute(SNode node) {\n    SLanguage language = node.getConcept().getLanguage();\n    Language languageModule = ModuleRepositoryFacade.getInstance().getModule(language.getQualifiedName(), Language.class);\n    Set<SModule> unloaded = ClassLoaderManager.getInstance().unloadClasses(Collections.singleton(languageModule), new EmptyProgressMonitor());\n\n    // todo: use SLanguage for used languages in model and module! \n    ((SModelInternal) SNodeOperations.getModel(node)).addLanguage(languageModule.getModuleReference());\n    ((AbstractModule) SNodeOperations.getModel(node).getModule()).addUsedLanguage(languageModule.getModuleReference());\n\n    ClassLoaderManager.getInstance().loadClasses(unloaded, new EmptyProgressMonitor());\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void collectActionsAsIntentions(AnAction action, List<AnAction> actions, DataContext dataContext) {\n    if (action instanceof ActionGroup) {\n      for (AnAction child : ((ActionGroup) action).getChildren(null)) {\n        collectActionsAsIntentions(child, actions, dataContext);\n      }\n    } else if (action instanceof BaseAction) {\n      Presentation presentation = new Presentation();\n      presentation.setDescription(action.getTemplatePresentation().getDescription());\n      action.update(new AnActionEvent(null, dataContext, \"\", presentation, ActionManager.getInstance(), 0));\n      if (presentation.isVisible()) {\n        actions.add(action);\n      }\n    }\n  }","id":71073,"modified_method":"private void collectActionsAsIntentions(AnAction action, List<AnAction> actions, DataContext dataContext) {\n    if (action instanceof ActionGroup) {\n      for (AnAction child : ((ActionGroup) action).getChildren(null)) {\n        collectActionsAsIntentions(child, actions, dataContext);\n      }\n    } else if (action instanceof BaseAction) {\n      Presentation presentation = action.getTemplatePresentation();\n      if (presentation.getIcon() == null)\n        presentation.setIcon(Icons.REAL_INTENTION);\n      action.update(new AnActionEvent(null, dataContext, \"\", presentation, ActionManager.getInstance(), 0));\n      if (presentation.isVisible()) {\n        actions.add(action);\n      }\n    }\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ModelActions_ActionGroup() {\n    super(\"ModelActions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_newActions);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_make);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.PasteNode_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_paste);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.DeleteModels_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.CloneModel_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.CopyModelName_Action\");\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.OptimizeModelImports_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.AddMissingImports_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ConvertToBinaryPersistence_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ConvertToFilePerRootPersistence_Action\");\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.platform.actions.AnalyzeDependencies_Action\");\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_check);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_modelUsages);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_refactoring);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.RevertMemoryChanges_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_mpsvcs);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_idealocalhistory);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_ideavcs);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_scripts);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_favorites);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_showHelp);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ModelProperties_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":71074,"modified_method":"public ModelActions_ActionGroup() {\n    super(\"ModelActions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_newActions);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_make);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.PasteNode_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_paste);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.DeleteModels_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.CloneModel_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.CopyModelName_Action\");\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.OptimizeModelImports_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.FixModuleImports_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ConvertToBinaryPersistence_Action\");\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ConvertToFilePerRootPersistence_Action\");\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.platform.actions.AnalyzeDependencies_Action\");\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_check);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_modelUsages);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_refactoring);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.RevertMemoryChanges_Action\");\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_mpsvcs);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_idealocalhistory);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_ideavcs);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_scripts);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_favorites);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      {\n        LabelledAnchor action = new LabelledAnchor(ModelActions_ActionGroup.LABEL_ID_showHelp);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ModelActions_ActionGroup.this.addAction(action);\n      }\n      ModelActions_ActionGroup.this.addSeparator();\n      ModelActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.ModelProperties_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ProjectActions_ActionGroup() {\n    super(\"ProjectActions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_projectNew);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_make);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_check);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.OptimizeProjectImports_Action\");\n      ProjectActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.AddMissingImportsInProject_Action\");\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_compileJava);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_runConfig);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      ProjectActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.MPSProjectPaths_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","id":71075,"modified_method":"public ProjectActions_ActionGroup() {\n    super(\"ProjectActions\", ID);\n    this.setIsInternal(false);\n    this.setPopup(false);\n    try {\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_projectNew);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_make);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_check);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.OptimizeProjectImports_Action\");\n      ProjectActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.FixModuleImportsInProject_Action\");\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_compileJava);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      {\n        LabelledAnchor action = new LabelledAnchor(ProjectActions_ActionGroup.LABEL_ID_runConfig);\n        ActionManagerEx manager = ActionManagerEx.getInstanceEx();\n        manager.registerAction(action.getId(), action, PluginId.getId(\"jetbrains.mps.ide\"));\n        ProjectActions_ActionGroup.this.addAction(action);\n      }\n      ProjectActions_ActionGroup.this.addSeparator();\n      ProjectActions_ActionGroup.this.addAction(\"jetbrains.mps.ide.actions.MPSProjectPaths_Action\");\n    } catch (Throwable t) {\n      LOG.error(\"User group error\", t);\n    }\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myWholePanel = new JPanel();\n    myWholePanel.setLayout(new com.intellij.uiDesigner.core.GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Project format:\");\n    myWholePanel.add(label1, new com.intellij.uiDesigner.core.GridConstraints(0, 0, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n        com.intellij.uiDesigner.core.GridConstraints.FILL_NONE, com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED,\n        com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myStorageFormatCombo = new JComboBox();\n    myWholePanel.add(myStorageFormatCombo,\n        new com.intellij.uiDesigner.core.GridConstraints(0, 1, 1, 1, com.intellij.uiDesigner.core.GridConstraints.ANCHOR_WEST,\n            com.intellij.uiDesigner.core.GridConstraints.FILL_HORIZONTAL,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_SHRINK | com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_CAN_GROW,\n            com.intellij.uiDesigner.core.GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n  }","id":71076,"modified_method":"/**\n   * Method generated by IntelliJ IDEA GUI Designer\n   * >>> IMPORTANT!! <<<\n   * DO NOT edit this method OR call it in your code!\n   *\n   * @noinspection ALL\n   */\n  private void $$$setupUI$$$() {\n    myWholePanel = new JPanel();\n    myWholePanel.setLayout(new GridLayoutManager(1, 2, new Insets(0, 0, 0, 0), -1, -1));\n    final JLabel label1 = new JLabel();\n    label1.setText(\"Project format:\");\n    myWholePanel.add(label1, new GridConstraints(0, 0, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_NONE, GridConstraints.SIZEPOLICY_FIXED,\n        GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n    myStorageFormatCombo = new JComboBox();\n    myWholePanel.add(myStorageFormatCombo, new GridConstraints(0, 1, 1, 1, GridConstraints.ANCHOR_WEST, GridConstraints.FILL_HORIZONTAL,\n        GridConstraints.SIZEPOLICY_CAN_SHRINK | GridConstraints.SIZEPOLICY_CAN_GROW, GridConstraints.SIZEPOLICY_FIXED, null, null, null, 0, false));\n  }","commit_id":"09040514c9d1e9c958ecbd78e33749cf37812420","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Window findWindowForBalloon(Project project) {\n    Window window = null;\n    if (project != null) {\n      window = WindowManager.getInstance().getFrame(project);\n    }\n\n    if (window == null) {\n      window = JOptionPane.getRootFrame();\n    }\n    return window;\n  }","id":71077,"modified_method":"public static Window findWindowForBalloon(Project project) {\n    return WindowManager.getInstance().getFrame(project);\n  }","commit_id":"2a64faf5830c2ccec633c1d05043b481930231ac","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void doExecute(@NotNull ActionContext context) {\n    final AbstractConceptDeclaration conceptDeclaration = (AbstractConceptDeclaration) BaseAdapter.fromNode(context.getNode());\n    final IOperationContext operationContext = context.getOperationContext();\n    List<SNode> rules = getHelginsRules(conceptDeclaration, operationContext);\n    EditorsPane editorsPane = operationContext.getComponent(EditorsPane.class);\n    IEditor currentEditor = editorsPane.getCurrentEditor();\n    \n    if (rules.size() == 1) {// single rule\n      operationContext.getComponent(MPSEditorOpener.class).openNode(rules.get(0));\n      return;\n    }\n\n    // multiple rules\n    MyMenu m = new MyMenu(rules, operationContext);\n    int x = 0;\n    int y = 0;\n    EditorCell cell = context.get(EditorCell.class);\n    if (cell != null) {\n      x = cell.getX();\n      y = cell.getY();\n    }\n    Component invoker;\n    if (currentEditor == null) {\n      invoker = context.getFrame();\n    } else {\n      invoker = currentEditor.getCurrentEditorComponent();\n    }\n    m.show(invoker, x, y);\n  }","id":71078,"modified_method":"public void doExecute(@NotNull ActionContext context) {\n    final AbstractConceptDeclaration conceptDeclaration = (AbstractConceptDeclaration) BaseAdapter.fromNode(context.getNode());\n    final IOperationContext operationContext = context.getOperationContext();\n    List<SNode> rules = getHelginsRules(conceptDeclaration, operationContext);\n    \n    if (rules.size() == 1) {// single rule\n      operationContext.getComponent(MPSEditorOpener.class).openNode(rules.get(0));\n      return;\n    }\n\n    // multiple rules\n    MyMenu m = new MyMenu(rules, operationContext);\n    int x = 0;\n    int y = 0;\n    EditorCell cell = context.get(EditorCell.class);\n    if (cell != null) {\n      x = cell.getX();\n      y = cell.getY();\n    }\n    m.show(context.getFrame(), x, y);\n  }","commit_id":"be9d86448576e08d47d625b83ca6e5168c8039f2","url":"https://github.com/JetBrains/MPS"},{"original_method":"/** applies _some_ of the common settings needed to connect via JMX */\n    public void applyJmxJavaSystemProperties(MutableMap.Builder<String,Object> result) {\n        if (!isJmx()) return ;\n        \n        Integer jmxRemotePort;\n        String hostName = getEntity().getAttribute(Attributes.HOSTNAME);\n        if (hostName==null) hostName = checkNotNull(getMachine().get().getAddress().getHostName(), \"hostname for entity \" + entity);\n        \n        result.put(\"com.sun.management.jmxremote\", null);\n\n        switch (getJmxAgentMode()) {\n        case JMXMP_AND_RMI:\n            result.put(JmxmpAgent.RMI_REGISTRY_PORT_PROPERTY, Preconditions.checkNotNull(entity.getAttribute(UsesJmx.RMI_REGISTRY_PORT), \"registry port\"));\n        case JMXMP:\n            jmxRemotePort = getEntity().getAttribute(JMX_PORT);\n            if (jmxRemotePort==null || jmxRemotePort<=0)\n                throw new IllegalStateException(\"Unsupported JMX port \"+jmxRemotePort+\" - when applying system properties (\"+getJmxAgentMode()+\" / \"+getEntity()+\")\");\n            result.put(JmxmpAgent.JMXMP_PORT_PROPERTY, jmxRemotePort);\n            // with JMXMP don't try to tell it the hostname -- it isn't needed for JMXMP, and if specified \n            // it will break if the hostname we see is not known at the server, e.g. a forwarding public IP\n            // (should not be present, but remove just to be sure)\n            result.remove(\"java.rmi.server.hostname\");\n            break;\n        case JMX_RMI_CUSTOM_AGENT:    \n            jmxRemotePort = getEntity().getAttribute(JMX_PORT);\n            if (jmxRemotePort==null || jmxRemotePort<=0)\n                throw new IllegalStateException(\"Unsupported JMX port \"+jmxRemotePort+\" - when applying system properties (\"+getJmxAgentMode()+\" / \"+getEntity()+\")\");\n            result.put(JmxRmiAgent.RMI_REGISTRY_PORT_PROPERTY, \n                    Preconditions.checkNotNull(entity.getAttribute(UsesJmx.RMI_REGISTRY_PORT), \"registry port\"));\n            result.put(JmxRmiAgent.JMX_SERVER_PORT_PROPERTY, jmxRemotePort);\n            result.put(\"java.rmi.server.hostname\", hostName);\n            break;\n        case NONE:\n            // only for mode 'NONE' - other modes use different fields\n            jmxRemotePort = fixPortsForModeNone();\n            result.put(\"com.sun.management.jmxremote.port\", jmxRemotePort);\n            result.put(\"java.rmi.server.hostname\", hostName);\n            break;\n        default:    \n            throw new IllegalStateException(\"Unsupported JMX mode - when applying system properties (\"+getJmxAgentMode()+\" / \"+getEntity()+\")\");\n        }\n        \n        if (isSecure()) {\n            // set values true, and apply keys pointing to keystore / truststore\n            getJmxSslSupport().applyAgentJmxJavaSystemProperties(result);\n        } else {\n            result.\n                put(\"com.sun.management.jmxremote.ssl\", false).\n                put(\"com.sun.management.jmxremote.authenticate\", false);\n        }\n    }","id":71079,"modified_method":"/** applies _some_ of the common settings needed to connect via JMX */\n    public void applyJmxJavaSystemProperties(MutableMap.Builder<String,Object> result) {\n        if (!isJmx()) return ;\n\n        HostAndPort jmx = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(JMX_PORT));\n        Integer jmxRemotePort = getEntity().getAttribute(JMX_PORT);\n        String hostName = jmx.getHostText();\n\n        result.put(\"com.sun.management.jmxremote\", null);\n        result.put(\"java.rmi.server.hostname\", hostName);\n\n        switch (getJmxAgentMode()) {\n        case JMXMP_AND_RMI:\n            result.put(JmxmpAgent.RMI_REGISTRY_PORT_PROPERTY, Preconditions.checkNotNull(entity.getAttribute(UsesJmx.RMI_REGISTRY_PORT), \"registry port\"));\n        case JMXMP:\n            if (jmxRemotePort==null || jmxRemotePort<=0)\n                throw new IllegalStateException(\"Unsupported JMX port \"+jmxRemotePort+\" - when applying system properties (\"+getJmxAgentMode()+\" / \"+getEntity()+\")\");\n            result.put(JmxmpAgent.JMXMP_PORT_PROPERTY, jmxRemotePort);\n            // with JMXMP don't try to tell it the hostname -- it isn't needed for JMXMP, and if specified \n            // it will break if the hostname we see is not known at the server, e.g. a forwarding public IP\n            // (should not be present, but remove just to be sure)\n            result.remove(\"java.rmi.server.hostname\");\n            break;\n        case JMX_RMI_CUSTOM_AGENT:\n            if (jmxRemotePort==null || jmxRemotePort<=0)\n                throw new IllegalStateException(\"Unsupported JMX port \"+jmxRemotePort+\" - when applying system properties (\"+getJmxAgentMode()+\" / \"+getEntity()+\")\");\n            result.put(JmxRmiAgent.RMI_REGISTRY_PORT_PROPERTY, Preconditions.checkNotNull(entity.getAttribute(UsesJmx.RMI_REGISTRY_PORT), \"registry port\"));\n            result.put(JmxRmiAgent.JMX_SERVER_PORT_PROPERTY, jmxRemotePort);\n            break;\n        case NONE:\n            jmxRemotePort = fixPortsForModeNone();\n        case JMX_RMI:\n            result.put(\"com.sun.management.jmxremote.port\", jmxRemotePort);\n            break;\n        default:\n            throw new IllegalStateException(\"Unsupported JMX mode - when applying system properties (\"+getJmxAgentMode()+\" / \"+getEntity()+\")\");\n        }\n\n        if (isSecure()) {\n            // set values true, and apply keys pointing to keystore / truststore\n            getJmxSslSupport().applyAgentJmxJavaSystemProperties(result);\n        } else {\n            result.\n                put(\"com.sun.management.jmxremote.ssl\", false).\n                put(\"com.sun.management.jmxremote.authenticate\", false);\n        }\n    }","commit_id":"6bc2410f592df048085ecbd28ee9920665e0d056","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public String getJmxUrl() {\n        init();\n        \n        String host = entity.getAttribute(Attributes.HOSTNAME);\n        if (host==null) {\n            SshMachineLocation machine = EffectorTasks.getSshMachine(entity);\n            host = machine.getAddress().getHostName();\n        }\n        \n        if (EnumSet.of(JmxAgentModes.JMXMP, JmxAgentModes.JMXMP_AND_RMI).contains(getJmxAgentMode())) {\n            HostAndPort jmxmp = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(JMX_PORT));\n            return JmxHelper.toJmxmpUrl(jmxmp.getHostText(), jmxmp.getPort());\n        } else {\n            if (getJmxAgentMode() == JmxAgentModes.NONE) {\n                fixPortsForModeNone();\n            }\n            // this will work for agent or agentless\n            return JmxHelper.toRmiJmxUrl(host,\n                    entity.getAttribute(JMX_PORT),\n                    entity.getAttribute(RMI_REGISTRY_PORT),\n                    entity.getAttribute(JMX_CONTEXT));\n        }\n    }","id":71080,"modified_method":"public String getJmxUrl() {\n        init();\n\n        HostAndPort jmx = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(JMX_PORT));\n        HostAndPort rmi = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(RMI_REGISTRY_PORT));\n\n        if (EnumSet.of(JmxAgentModes.JMXMP, JmxAgentModes.JMXMP_AND_RMI).contains(getJmxAgentMode())) {\n            return JmxHelper.toJmxmpUrl(jmx.getHostText(), jmx.getPort());\n        } else {\n            if (getJmxAgentMode() == JmxAgentModes.NONE) {\n                fixPortsForModeNone();\n            }\n            // this will work for agent or agentless\n            return JmxHelper.toRmiJmxUrl(jmx.getHostText(), jmx.getPort(), rmi.getPort(),\n                    entity.getAttribute(JMX_CONTEXT));\n        }\n    }","commit_id":"6bc2410f592df048085ecbd28ee9920665e0d056","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** installs files needed for JMX, to the runDir given in constructor, assuming the runDir has been created */ \n    public void install() {\n        if (getJmxAgentMode()!=JmxAgentModes.NONE) {\n            getMachine().get().copyTo(ResourceUtils.create(this).getResourceFromUrl(\n                getJmxAgentJarUrl()), getJmxAgentJarDestinationFilePath());\n        }\n        if (isSecure()) {\n            getJmxSslSupport().install();\n        }\n    }","id":71081,"modified_method":"/** installs files needed for JMX, to the runDir given in constructor, assuming the runDir has been created */ \n    public void install() {\n        if (EnumSet.of(JmxAgentModes.JMXMP_AND_RMI, JmxAgentModes.JMXMP, JmxAgentModes.JMX_RMI_CUSTOM_AGENT).contains(getJmxAgentMode())) {\n            getMachine().get().copyTo(ResourceUtils.create(this).getResourceFromUrl(\n                getJmxAgentJarUrl()), getJmxAgentJarDestinationFilePath());\n        }\n        if (isSecure()) {\n            getJmxSslSupport().install();\n        }\n    }","commit_id":"6bc2410f592df048085ecbd28ee9920665e0d056","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public String getJmxUrl() {\n        init();\n        \n        String host = entity.getAttribute(Attributes.HOSTNAME);\n        if (host==null) {\n            SshMachineLocation machine = EffectorTasks.getSshMachine(entity);\n            host = machine.getAddress().getHostName();\n        }\n        \n        if (getJmxAgentMode()==JmxAgentModes.JMXMP || getJmxAgentMode()==JmxAgentModes.JMXMP_AND_RMI) {\n            // only JMXMP is valid for going through firewalls (it is the default)\n            HostAndPort hp = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(JMX_PORT));\n            return JmxHelper.toJmxmpUrl(hp.getHostText(), hp.getPort());\n        } else {\n            if (getJmxAgentMode()==JmxAgentModes.NONE) {\n                fixPortsForModeNone();\n            }\n            // this will work for agent or agentless\n            return JmxHelper.toRmiJmxUrl(host, \n                    entity.getAttribute(JMX_PORT),\n                    entity.getAttribute(RMI_REGISTRY_PORT),\n                    entity.getAttribute(JMX_CONTEXT));\n        }\n    }","id":71082,"modified_method":"public String getJmxUrl() {\n        init();\n        \n        String host = entity.getAttribute(Attributes.HOSTNAME);\n        if (host==null) {\n            SshMachineLocation machine = EffectorTasks.getSshMachine(entity);\n            host = machine.getAddress().getHostName();\n        }\n        \n        if (EnumSet.of(JmxAgentModes.JMXMP, JmxAgentModes.JMXMP_AND_RMI).contains(getJmxAgentMode())) {\n            HostAndPort jmxmp = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(JMX_PORT));\n            return JmxHelper.toJmxmpUrl(jmxmp.getHostText(), jmxmp.getPort());\n        } else {\n            if (getJmxAgentMode() == JmxAgentModes.NONE) {\n                fixPortsForModeNone();\n            }\n            // this will work for agent or agentless\n            HostAndPort jmx = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(JMX_PORT));\n            HostAndPort rmi = BrooklynAccessUtils.getBrooklynAccessibleAddress(entity, entity.getAttribute(RMI_REGISTRY_PORT));\n            return JmxHelper.toRmiJmxUrl(jmx.getHostText(), jmx.getPort(), rmi.getPort(), entity.getAttribute(JMX_CONTEXT));\n        }\n    }","commit_id":"cc0830936a71c38abf07a540826e3c64a1d353a6","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public List<String> getJmxJavaConfigOptions() {\n        if (getJmxAgentMode()==JmxAgentModes.NONE)\n            return MutableList.of();\n        return MutableList.of(String.format(\"-javaagent:%s\", getJmxAgentJarDestinationFilePath()));\n    }","id":71083,"modified_method":"public List<String> getJmxJavaConfigOptions() {\n        if (EnumSet.<JmxAgentModes>of(JmxAgentModes.NONE, JmxAgentModes.JMX_RMI).contains(getJmxAgentMode())) {\n            return MutableList.of();\n        } else {\n            return MutableList.of(String.format(\"-javaagent:%s\", getJmxAgentJarDestinationFilePath()));\n        }\n    }","commit_id":"a8203c1edccaa6abf732d26a3f351312d792c73b","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static boolean isDoNotGenerate(SModelDescriptor sm) {\n    if (!(sm instanceof EditableSModelDescriptor)) return false;\n    return ((EditableSModelDescriptor) sm).isDoNotGenerate();\n  }","id":71084,"modified_method":"public static boolean isDoNotGenerate(SModelDescriptor sm) {\n    return sm instanceof EditableSModelDescriptor && ((EditableSModelDescriptor) sm).isDoNotGenerate();\n  }","commit_id":"a17b5809f46270b16a798af480407f519e74190d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<SModelDescriptor> getModelsToGenerateBeforeGeneration(SModelDescriptor model, Project project) {\n    IModule module = model.getModule();\n    if (module == null) return Collections.emptyList();\n\n    List<SModelDescriptor> result = new ArrayList<SModelDescriptor>();\n\n    ModelGenerationStatusManager statusManager = ModelGenerationStatusManager.getInstance();\n    for (TemplateModule templateModule : GenerationPartitioningUtil.getTemplateModules(model.getSModel())) {\n      Generator g = MPSModuleRepository.getInstance().getGenerator(templateModule.getReference());\n      if(g == null) continue;\n\n      for (SModelDescriptor sm : g.getOwnModelDescriptors()) {\n        if (SModelStereotype.isUserModel(sm) && statusManager.generationRequired(sm, ProjectOperationContext.get(project))) {\n          result.add(sm);\n        }\n      }\n\n      for (SModelDescriptor sm : g.getSourceLanguage().getAspectModelDescriptors()) {\n        if (statusManager.generationRequired(sm, ProjectOperationContext.get(project))) {\n          result.add(sm);\n        }\n      }\n    }\n\n    return result;\n  }","id":71085,"modified_method":"private Collection<SModelDescriptor> getModelsToGenerateBeforeGeneration(SModelDescriptor model, Project project) {\n    IModule module = model.getModule();\n    if (module == null) return Collections.emptyList();\n\n    List<SModelDescriptor> result = new ArrayList<SModelDescriptor>();\n\n    for (TemplateModule templateModule : GenerationPartitioningUtil.getTemplateModules(model.getSModel())) {\n      Generator g = MPSModuleRepository.getInstance().getGenerator(templateModule.getReference());\n      if(g == null) continue;\n\n      for (SModelDescriptor sm : g.getOwnModelDescriptors()) {\n        if (SModelStereotype.isUserModel(sm)) {\n          result.add(sm);\n        }\n      }\n\n      for (SModelDescriptor sm : g.getSourceLanguage().getAspectModelDescriptors()) {\n        result.add(sm);\n      }\n    }\n\n    return GenerationFacade.getModifiedModels(result, ProjectOperationContext.get(project));\n  }","commit_id":"a17b5809f46270b16a798af480407f519e74190d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenParameters getGenParams(Project project, boolean fullRegeneration) throws IllegalGeneratorConfigurationException {\n    Set<SModelDescriptor> modelDescriptors = new LinkedHashSet<SModelDescriptor>();\n\n    for (SModelReference m : getModels()) {\n      modelDescriptors.add(project.getComponent(ProjectScope.class).getModelDescriptor(m));\n    }\n\n    if (modelDescriptors.isEmpty()) {\n      throw new IllegalGeneratorConfigurationException(\"can't execute test configuration \" + getName());\n    }\n\n    IModule module = null;\n    for (IModule m : MPSModuleRepository.getInstance().getAllModules()) {\n      if (m.getOwnModelDescriptors().containsAll(modelDescriptors)) {\n        module = m;\n        break;\n      }\n    }\n\n    if (module == null) {\n      throw new IllegalGeneratorConfigurationException(\"there is no module that can be used to generate models \" + modelDescriptors);\n    }\n\n    List<SModelDescriptor> models = new ArrayList<SModelDescriptor>();\n    for (SModelDescriptor sm : modelDescriptors) {\n      if (!fullRegeneration && !ModelGenerationStatusManager.getInstance().generationRequired(sm, ProjectOperationContext.get(project))) {\n        continue;\n      }\n      models.add(sm);\n    }\n\n    return new GenParameters(models, module);\n  }","id":71086,"modified_method":"public GenParameters getGenParams(Project project, boolean fullRegeneration) throws IllegalGeneratorConfigurationException {\n    Set<SModelDescriptor> modelDescriptors = new LinkedHashSet<SModelDescriptor>();\n\n    for (SModelReference m : getModels()) {\n      modelDescriptors.add(project.getComponent(ProjectScope.class).getModelDescriptor(m));\n    }\n\n    if (modelDescriptors.isEmpty()) {\n      throw new IllegalGeneratorConfigurationException(\"can't execute test configuration \" + getName());\n    }\n\n    IModule module = null;\n    for (IModule m : MPSModuleRepository.getInstance().getAllModules()) {\n      if (m.getOwnModelDescriptors().containsAll(modelDescriptors)) {\n        module = m;\n        break;\n      }\n    }\n\n    if (module == null) {\n      throw new IllegalGeneratorConfigurationException(\"there is no module that can be used to generate models \" + modelDescriptors);\n    }\n\n    List<SModelDescriptor> models = new ArrayList<SModelDescriptor>();\n    if(fullRegeneration) {\n      models.addAll(modelDescriptors);\n    } else {\n      models.addAll(GenerationFacade.getModifiedModels(modelDescriptors, ProjectOperationContext.get(project)));\n    }\n    return new GenParameters(models, module);\n  }","commit_id":"a17b5809f46270b16a798af480407f519e74190d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public GenParameters getGenParams(Project project, boolean fullRegeneration) throws IllegalGeneratorConfigurationException {\n    IModule module = MPSModuleRepository.getInstance().getModule(myModuleRef);\n\n    if (module == null) {\n      throw new IllegalGeneratorConfigurationException(\"Can't find module \" + myModuleRef.getModuleFqName());\n    }\n\n    if (module instanceof Solution) {\n      Solution solution = (Solution) module;\n\n      List<SModelDescriptor> models = new ArrayList<SModelDescriptor>();\n      for (SModelDescriptor sm : solution.getOwnModelDescriptors()) {\n        if(!sm.isGeneratable()) continue;\n        if (!fullRegeneration && !ModelGenerationStatusManager.getInstance().generationRequired(sm, ProjectOperationContext.get(project))) {\n          continue;\n        }\n\n        if (GeneratorManager.isDoNotGenerate(sm)) {\n          continue;\n        }\n\n        models.add(sm);\n      }\n\n      return new GenParameters(models, solution);\n    } else if (module instanceof Language) {\n      Language lang = (Language) module;\n\n      List<SModelDescriptor> inputModels = lang.getOwnModelDescriptors();\n\n      Iterator<SModelDescriptor> it = inputModels.iterator();\n      while (it.hasNext()) {\n        SModelDescriptor model = it.next();\n        if (!model.isGeneratable() ||\n          (!fullRegeneration && !ModelGenerationStatusManager.getInstance().generationRequired(model, ProjectOperationContext.get(project))) ||\n          GeneratorManager.isDoNotGenerate(model)) {\n          it.remove();\n        }\n      }\n\n      return new GenParameters(inputModels, lang);\n    }\n\n    throw new IllegalGeneratorConfigurationException(\"Not applicable to non-language/solution module \" + myModuleRef.getModuleFqName());\n  }","id":71087,"modified_method":"public GenParameters getGenParams(Project project, boolean fullRegeneration) throws IllegalGeneratorConfigurationException {\n    IModule module = MPSModuleRepository.getInstance().getModule(myModuleRef);\n\n    if (module == null) {\n      throw new IllegalGeneratorConfigurationException(\"Can't find module \" + myModuleRef.getModuleFqName());\n    }\n\n    if (module instanceof Solution) {\n      Solution solution = (Solution) module;\n\n      List<SModelDescriptor> models = new ArrayList<SModelDescriptor>();\n      for (SModelDescriptor sm : solution.getOwnModelDescriptors()) {\n        if (!sm.isGeneratable()) continue;\n        models.add(sm);\n      }\n\n      if(!fullRegeneration) {\n        models = new ArrayList<SModelDescriptor>(GenerationFacade.getModifiedModels(models, ProjectOperationContext.get(project)));\n      }\n\n      return new GenParameters(models, solution);\n    } else if (module instanceof Language) {\n      Language lang = (Language) module;\n\n      List<SModelDescriptor> inputModels = lang.getOwnModelDescriptors();\n\n      Iterator<SModelDescriptor> it = inputModels.iterator();\n      while (it.hasNext()) {\n        SModelDescriptor model = it.next();\n        if (!model.isGeneratable()) {\n          it.remove();\n        }\n      }\n\n      if(!fullRegeneration) {\n        inputModels = new ArrayList<SModelDescriptor>(GenerationFacade.getModifiedModels(inputModels, ProjectOperationContext.get(project)));\n      }\n\n      return new GenParameters(inputModels, lang);\n    }\n\n    throw new IllegalGeneratorConfigurationException(\"Not applicable to non-language/solution module \" + myModuleRef.getModuleFqName());\n  }","commit_id":"a17b5809f46270b16a798af480407f519e74190d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void infer(EObject e, IAcceptor<JvmDeclaredType> acceptor, boolean prelinkingPhase) {\n\t\t_infer(e, acceptor, prelinkingPhase);\n\t}","id":71088,"modified_method":"public void infer(EObject e, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) {\n\t\t_infer(e, acceptor, preIndexingPhase);\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"public void _infer(EObject e, IAcceptor<JvmDeclaredType> acceptor, boolean prelinkingPhase) {\n\t\tfor (EObject child : e.eContents()) {\n\t\t\tinfer(child, acceptor, prelinkingPhase);\n\t\t}\n\t}","id":71089,"modified_method":"public void _infer(EObject e, IJvmDeclaredTypeAcceptor acceptor, boolean preIndexingPhase) {\n\t\tfor (EObject child : e.eContents()) {\n\t\t\tinfer(child, acceptor, preIndexingPhase);\n\t\t}\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"public void installDerivedState(boolean isPrelinkingPhase) {\n\t\tif (!fullyInitialized && !isInitializing) {\n\t\t\ttry {\n\t\t\t\tisInitializing = true;\n\t\t\t\tif (derivedStateComputer != null)\n\t\t\t\t\tderivedStateComputer.installDerivedState(this, isPrelinkingPhase);\n\t\t\t\tfullyInitialized = true;\n\t\t\t} finally {\n\t\t\t\tisInitializing = false;\n\t\t\t\tgetCache().clear(this);\n\t\t\t}\n\t\t}\n\t}","id":71090,"modified_method":"public void installDerivedState(boolean preIndexingPhase) {\n\t\tif (!fullyInitialized && !isInitializing) {\n\t\t\ttry {\n\t\t\t\tisInitializing = true;\n\t\t\t\tif (derivedStateComputer != null)\n\t\t\t\t\tderivedStateComputer.installDerivedState(this, preIndexingPhase);\n\t\t\t\tfullyInitialized = true;\n\t\t\t} finally {\n\t\t\t\tisInitializing = false;\n\t\t\t\tgetCache().clear(this);\n\t\t\t}\n\t\t}\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"public void infer(final EObject e, final IAcceptor<JvmDeclaredType> acceptor, final boolean prelinkingPhase) {\n    if (e instanceof Entity) {\n      _infer((Entity)e, acceptor, prelinkingPhase);\n    } else if (e != null) {\n      _infer(e, acceptor, prelinkingPhase);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(e, acceptor, prelinkingPhase).toString());\n    }\n  }","id":71091,"modified_method":"public void infer(final EObject entity, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    if (entity instanceof Entity) {\n      _infer((Entity)entity, acceptor, prelinkingPhase);\n    } else if (entity != null) {\n      _infer(entity, acceptor, prelinkingPhase);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(entity, acceptor, prelinkingPhase).toString());\n    }\n  }","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _infer(final Entity e, final IAcceptor<JvmDeclaredType> acceptor, final boolean prelinkingPhase) {\n    QualifiedName _fullyQualifiedName = this._iQualifiedNameProvider.getFullyQualifiedName(e);\n    final Procedure1<JvmGenericType> _function = new Procedure1<JvmGenericType>() {\n        public void apply(final JvmGenericType it) {\n          {\n            String _documentation = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.getDocumentation(e);\n            DomainmodelJvmModelInferrer.this._jvmTypesBuilder.setDocumentation(it, _documentation);\n            JvmParameterizedTypeReference _superType = e.getSuperType();\n            boolean _operator_notEquals = ObjectExtensions.operator_notEquals(_superType, null);\n            if (_operator_notEquals) {\n              EList<JvmTypeReference> _superTypes = it.getSuperTypes();\n              JvmParameterizedTypeReference _superType_1 = e.getSuperType();\n              JvmTypeReference _cloneWithProxies = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.cloneWithProxies(_superType_1);\n              CollectionExtensions.<JvmTypeReference>operator_add(_superTypes, _cloneWithProxies);\n            }\n            EList<Feature> _features = e.getFeatures();\n            for (final Feature f : _features) {\n              boolean matched = false;\n              if (!matched) {\n                if (f instanceof Property) {\n                  final Property _property = (Property)f;\n                  matched=true;\n                  {\n                    EList<JvmMember> _members = it.getMembers();\n                    String _name = _property.getName();\n                    JvmTypeReference _type = _property.getType();\n                    JvmField _field = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toField(_property, _name, _type);\n                    CollectionExtensions.<JvmField>operator_add(_members, _field);\n                    EList<JvmMember> _members_1 = it.getMembers();\n                    String _name_1 = _property.getName();\n                    JvmTypeReference _type_1 = _property.getType();\n                    JvmOperation _getter = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toGetter(_property, _name_1, _type_1);\n                    CollectionExtensions.<JvmOperation>operator_add(_members_1, _getter);\n                    EList<JvmMember> _members_2 = it.getMembers();\n                    String _name_2 = _property.getName();\n                    JvmTypeReference _type_2 = _property.getType();\n                    JvmOperation _setter = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toSetter(_property, _name_2, _type_2);\n                    CollectionExtensions.<JvmOperation>operator_add(_members_2, _setter);\n                  }\n                }\n              }\n              if (!matched) {\n                if (f instanceof Operation) {\n                  final Operation _operation = (Operation)f;\n                  matched=true;\n                  EList<JvmMember> _members = it.getMembers();\n                  String _name = _operation.getName();\n                  JvmTypeReference _type = _operation.getType();\n                  final Procedure1<JvmOperation> _function = new Procedure1<JvmOperation>() {\n                      public void apply(final JvmOperation it) {\n                        {\n                          String _documentation = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.getDocumentation(_operation);\n                          DomainmodelJvmModelInferrer.this._jvmTypesBuilder.setDocumentation(it, _documentation);\n                          EList<JvmFormalParameter> _params = _operation.getParams();\n                          for (final JvmFormalParameter p : _params) {\n                            EList<JvmFormalParameter> _parameters = it.getParameters();\n                            String _name = p.getName();\n                            JvmTypeReference _parameterType = p.getParameterType();\n                            JvmFormalParameter _parameter = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toParameter(p, _name, _parameterType);\n                            CollectionExtensions.<JvmFormalParameter>operator_add(_parameters, _parameter);\n                          }\n                          XExpression _body = _operation.getBody();\n                          DomainmodelJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _body);\n                        }\n                      }\n                    };\n                  JvmOperation _method = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toMethod(_operation, _name, _type, _function);\n                  CollectionExtensions.<JvmOperation>operator_add(_members, _method);\n                }\n              }\n            }\n          }\n        }\n      };\n    JvmGenericType _class = this._jvmTypesBuilder.toClass(e, _fullyQualifiedName, _function);\n    acceptor.accept(_class);\n  }","id":71092,"modified_method":"protected void _infer(final Entity entity, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    QualifiedName _fullyQualifiedName = this._iQualifiedNameProvider.getFullyQualifiedName(entity);\n    JvmGenericType _class = this._jvmTypesBuilder.toClass(entity, _fullyQualifiedName);\n    IPostIndexingInitializing<JvmGenericType> _accept = acceptor.<JvmGenericType>accept(_class);\n    final Procedure1<JvmGenericType> _function = new Procedure1<JvmGenericType>() {\n        public void apply(final JvmGenericType it) {\n          {\n            String _documentation = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.getDocumentation(entity);\n            DomainmodelJvmModelInferrer.this._jvmTypesBuilder.setDocumentation(it, _documentation);\n            JvmParameterizedTypeReference _superType = entity.getSuperType();\n            boolean _operator_notEquals = ObjectExtensions.operator_notEquals(_superType, null);\n            if (_operator_notEquals) {\n              EList<JvmTypeReference> _superTypes = it.getSuperTypes();\n              JvmParameterizedTypeReference _superType_1 = entity.getSuperType();\n              JvmTypeReference _cloneWithProxies = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.cloneWithProxies(_superType_1);\n              CollectionExtensions.<JvmTypeReference>operator_add(_superTypes, _cloneWithProxies);\n            }\n            EList<Feature> _features = entity.getFeatures();\n            for (final Feature f : _features) {\n              boolean matched = false;\n              if (!matched) {\n                if (f instanceof Property) {\n                  final Property _property = (Property)f;\n                  matched=true;\n                  {\n                    EList<JvmMember> _members = it.getMembers();\n                    String _name = _property.getName();\n                    JvmTypeReference _type = _property.getType();\n                    JvmField _field = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toField(_property, _name, _type);\n                    CollectionExtensions.<JvmField>operator_add(_members, _field);\n                    EList<JvmMember> _members_1 = it.getMembers();\n                    String _name_1 = _property.getName();\n                    JvmTypeReference _type_1 = _property.getType();\n                    JvmOperation _getter = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toGetter(_property, _name_1, _type_1);\n                    CollectionExtensions.<JvmOperation>operator_add(_members_1, _getter);\n                    EList<JvmMember> _members_2 = it.getMembers();\n                    String _name_2 = _property.getName();\n                    JvmTypeReference _type_2 = _property.getType();\n                    JvmOperation _setter = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toSetter(_property, _name_2, _type_2);\n                    CollectionExtensions.<JvmOperation>operator_add(_members_2, _setter);\n                  }\n                }\n              }\n              if (!matched) {\n                if (f instanceof Operation) {\n                  final Operation _operation = (Operation)f;\n                  matched=true;\n                  EList<JvmMember> _members = it.getMembers();\n                  String _name = _operation.getName();\n                  JvmTypeReference _type = _operation.getType();\n                  final Procedure1<JvmOperation> _function = new Procedure1<JvmOperation>() {\n                      public void apply(final JvmOperation it) {\n                        {\n                          String _documentation = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.getDocumentation(_operation);\n                          DomainmodelJvmModelInferrer.this._jvmTypesBuilder.setDocumentation(it, _documentation);\n                          EList<JvmFormalParameter> _params = _operation.getParams();\n                          for (final JvmFormalParameter p : _params) {\n                            EList<JvmFormalParameter> _parameters = it.getParameters();\n                            String _name = p.getName();\n                            JvmTypeReference _parameterType = p.getParameterType();\n                            JvmFormalParameter _parameter = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toParameter(p, _name, _parameterType);\n                            CollectionExtensions.<JvmFormalParameter>operator_add(_parameters, _parameter);\n                          }\n                          XExpression _body = _operation.getBody();\n                          DomainmodelJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _body);\n                        }\n                      }\n                    };\n                  JvmOperation _method = DomainmodelJvmModelInferrer.this._jvmTypesBuilder.toMethod(_operation, _name, _type, _function);\n                  CollectionExtensions.<JvmOperation>operator_add(_members, _method);\n                }\n              }\n            }\n          }\n        }\n      };\n    _accept.initializeLater(_function);\n  }","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"public void installDerivedState(final DerivedStateAwareResource resource, boolean isPreLinkingPhase) {\n\t\tif (resource.getContents().isEmpty())\n\t\t\treturn;\n\t\tEObject eObject = resource.getContents().get(0);\n\t\tinferrer.infer(eObject, new IAcceptor<JvmDeclaredType>() {\n\t\t\tpublic void accept(JvmDeclaredType t) {\n\t\t\t\tif(t != null)\n\t\t\t\t\tresource.getContents().add(t);\n\t\t\t}\n\t\t}, isPreLinkingPhase);\n\t}","id":71093,"modified_method":"public void installDerivedState(final DerivedStateAwareResource resource, boolean preIndexingPhase) {\n\t\tif (resource.getContents().isEmpty())\n\t\t\treturn;\n\t\tEObject eObject = resource.getContents().get(0);\n\t\tJvmDeclaredTypeAcceptor acceptor = new JvmDeclaredTypeAcceptor(resource);\n\t\tinferrer.infer(eObject, acceptor, preIndexingPhase);\n\t\tif (!preIndexingPhase) {\n\t\t\tfor (Pair<JvmDeclaredType, Procedure1<JvmDeclaredType>> initializer: acceptor.later) {\n\t\t\t\tinitializer.getValue().apply(initializer.getKey());\n\t\t\t}\n\t\t}\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public interface declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created interface declaration.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java interface of the given name.\n\t */\n\tpublic JvmGenericType toInterface(EObject sourceElement, String name, Procedure1<JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tresult.setInterface(true);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\n\t\treturn associate(sourceElement, result);\n\t}","id":71094,"modified_method":"/**\n\t * Creates a public interface declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created interface declaration.\n\t * \n\t * @return a {@link JvmGenericType} representing a Java interface of the given name.\n\t */\n\tpublic JvmGenericType toInterface(EObject sourceElement, String name, Procedure1<JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tresult.setInterface(true);\n\t\tassociate(sourceElement, result);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\n\t\treturn result;\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public class declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created class element\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name.\n\t */\n\tpublic JvmGenericType toClass(EObject sourceElement, String name, Procedure1<JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\n\t\t// if no super type add Object\n\t\tif (result.getSuperTypes().isEmpty()) {\n\t\t\tJvmTypeReference objectType = references.getTypeForName(Object.class, sourceElement);\n\t\t\tif (objectType != null)\n\t\t\t\tresult.getSuperTypes().add(objectType);\n\t\t}\n\t\t// if no constructors have been added, add a default constructor\n\t\tif (isEmpty(result.getDeclaredConstructors())) {\n\t\t\tresult.getMembers().add(toConstructor(sourceElement, result.getSimpleName(), null));\n\t\t}\n\t\treturn associate(sourceElement, result);\n\t}","id":71095,"modified_method":"/**\n\t * Creates a public class declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created class element\n\t * \n\t * @return a {@link JvmGenericType} representing a Java class of the given name.\n\t */\n\tpublic JvmGenericType toClass(EObject sourceElement, String name, Procedure1<JvmGenericType> initializer) {\n\t\tfinal JvmGenericType result = createJvmGenericType(sourceElement, name);\n\t\tif (result == null)\n\t\t\treturn null;\n\t\tassociate(sourceElement, result);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\n\t\t// if no super type add Object\n\t\tif (result.getSuperTypes().isEmpty()) {\n\t\t\tJvmTypeReference objectType = references.getTypeForName(Object.class, sourceElement);\n\t\t\tif (objectType != null)\n\t\t\t\tresult.getSuperTypes().add(objectType);\n\t\t}\n\t\t// if no constructors have been added, add a default constructor\n\t\tif (isEmpty(result.getDeclaredConstructors())) {\n\t\t\tresult.getMembers().add(toConstructor(sourceElement, result.getSimpleName(), null));\n\t\t}\n\t\treturn result;\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates and returns a constructor with the given simple name associated to the given source element. By default\n\t * the constructor will have an empty body and no arguments, hence the Java default constructor.\n\t */\n\tpublic JvmConstructor toConstructor(EObject sourceElement, String simpleName, Procedure1<JvmConstructor> init) {\n\t\tJvmConstructor constructor = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tconstructor.setSimpleName(nullSaveName(simpleName));\n\t\tconstructor.setVisibility(JvmVisibility.PUBLIC);\n\t\tif (init != null && simpleName != null)\n\t\t\tinit.apply(constructor);\n\t\treturn associate(sourceElement, constructor);\n\t}","id":71096,"modified_method":"/**\n\t * Creates and returns a constructor with the given simple name associated to the given source element. By default\n\t * the constructor will have an empty body and no arguments, hence the Java default constructor.\n\t */\n\tpublic JvmConstructor toConstructor(EObject sourceElement, String simpleName, Procedure1<JvmConstructor> init) {\n\t\tJvmConstructor constructor = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tconstructor.setSimpleName(nullSaveName(simpleName));\n\t\tconstructor.setVisibility(JvmVisibility.PUBLIC);\n\t\tassociate(sourceElement, constructor);\n\t\tif (init != null)\n\t\t\tinit.apply(constructor);\n\t\treturn constructor;\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public annotation declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created annotation\n\t * \n\t * @return a {@link JvmAnnotationType} representing a Java annatation of the given name.\n\t */\n\tpublic JvmAnnotationType toAnnotationType(EObject sourceElement, String name, Procedure1<JvmAnnotationType> initializer) {\n\t\tif (sourceElement == null)\n\t\t\treturn null;\n\t\tif (name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmAnnotationType annotationType = TypesFactory.eINSTANCE.createJvmAnnotationType();\n\t\tannotationType.setSimpleName(fullName.getSecond());\n\t\tif (fullName.getFirst() != null)\n\t\t\tannotationType.setPackageName(fullName.getFirst());\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(annotationType);\n\n\t\treturn associate(sourceElement, annotationType);\n\t}","id":71097,"modified_method":"/**\n\t * Creates a public annotation declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created annotation\n\t * \n\t * @return a {@link JvmAnnotationType} representing a Java annatation of the given name.\n\t */\n\tpublic JvmAnnotationType toAnnotationType(EObject sourceElement, String name, Procedure1<JvmAnnotationType> initializer) {\n\t\tif (sourceElement == null)\n\t\t\treturn null;\n\t\tif (name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmAnnotationType annotationType = TypesFactory.eINSTANCE.createJvmAnnotationType();\n\t\tannotationType.setSimpleName(fullName.getSecond());\n\t\tif (fullName.getFirst() != null)\n\t\t\tannotationType.setPackageName(fullName.getFirst());\n\t\tassociate(sourceElement, annotationType);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(annotationType);\n\n\t\treturn annotationType;\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public method with the given name and the given return type and associates it with the given\n\t * sourceElement.\n\t */\n\tpublic JvmOperation toMethod(EObject sourceElement, String name, JvmTypeReference returnType,\n\t\t\tProcedure1<JvmOperation> init) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tresult.setSimpleName(nullSaveName(name));\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tresult.setReturnType(cloneWithProxies(returnType));\n\t\tif (init != null && name != null)\n\t\t\tinit.apply(result);\n\t\treturn associate(sourceElement, result);\n\t}","id":71098,"modified_method":"/**\n\t * Creates a public method with the given name and the given return type and associates it with the given\n\t * sourceElement.\n\t */\n\tpublic JvmOperation toMethod(EObject sourceElement, String name, JvmTypeReference returnType,\n\t\t\tProcedure1<JvmOperation> init) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tresult.setSimpleName(nullSaveName(name));\n\t\tresult.setVisibility(JvmVisibility.PUBLIC);\n\t\tresult.setReturnType(cloneWithProxies(returnType));\n\t\tassociate(sourceElement, result);\n\t\tif (init != null)\n\t\t\tinit.apply(result);\n\t\treturn result;\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a public enum declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created enumeration type\n\t * \n\t * @return a {@link result} representing a Java class of the given name.\n\t */\n\tpublic JvmEnumerationType toEnumerationType(EObject sourceElement, String name, Procedure1<JvmEnumerationType> initializer) {\n\t\tif (sourceElement == null)\n\t\t\treturn null;\n\t\tif (name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmEnumerationType result = TypesFactory.eINSTANCE.createJvmEnumerationType();\n\t\tresult.setSimpleName(fullName.getSecond());\n\t\tif (fullName.getFirst() != null)\n\t\t\tresult.setPackageName(fullName.getFirst());\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\n\t\treturn associate(sourceElement, result);\n\t}","id":71099,"modified_method":"/**\n\t * Creates a public enum declaration, associated to the given sourceElement. It sets the given name, which might be\n\t * fully qualified using the standard Java notation.\n\t * \n\t * @param sourceElement\n\t *            the sourceElement the resulting element is associated with.\n\t * @param qualifiedName\n\t *            the qualifiedName of the resulting class.\n\t * @param initializer\n\t *            the initializer to apply on the created enumeration type\n\t * \n\t * @return a {@link result} representing a Java class of the given name.\n\t */\n\tpublic JvmEnumerationType toEnumerationType(EObject sourceElement, String name, Procedure1<JvmEnumerationType> initializer) {\n\t\tif (sourceElement == null)\n\t\t\treturn null;\n\t\tif (name == null)\n\t\t\treturn null;\n\t\tPair<String, String> fullName = splitQualifiedName(name);\n\t\tJvmEnumerationType result = TypesFactory.eINSTANCE.createJvmEnumerationType();\n\t\tresult.setSimpleName(fullName.getSecond());\n\t\tif (fullName.getFirst() != null)\n\t\t\tresult.setPackageName(fullName.getFirst());\n\t\tassociate(sourceElement, result);\n\t\tif(initializer != null) \n\t\t\tinitializer.apply(result);\n\n\t\treturn result;\n\t}","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"public void infer(final EObject m, final IAcceptor<JvmDeclaredType> acceptor, final boolean prelinkingPhase) {\n    if (m instanceof Model) {\n      _infer((Model)m, acceptor, prelinkingPhase);\n    } else if (m != null) {\n      _infer(m, acceptor, prelinkingPhase);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(m, acceptor, prelinkingPhase).toString());\n    }\n  }","id":71100,"modified_method":"public void infer(final EObject m, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    if (m instanceof Model) {\n      _infer((Model)m, acceptor, prelinkingPhase);\n    } else if (m != null) {\n      _infer(m, acceptor, prelinkingPhase);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(m, acceptor, prelinkingPhase).toString());\n    }\n  }","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _infer(final Model m, final IAcceptor<JvmDeclaredType> acceptor, final boolean prelinkingPhase) {\n      XBlockExpression _block = m.getBlock();\n      final XBlockExpression e = _block;\n      Resource _eResource = e.eResource();\n      String _name = this.name(_eResource);\n      final Procedure1<JvmGenericType> _function = new Procedure1<JvmGenericType>() {\n          public void apply(final JvmGenericType it) {\n            {\n              EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n              JvmAnnotationReference _annotation = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toAnnotation(e, java.lang.SuppressWarnings.class, \"all\");\n              CollectionExtensions.<JvmAnnotationReference>operator_add(_annotations, _annotation);\n              EList<JvmMember> _members = it.getMembers();\n              JvmTypeReference _newTypeRef = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.newTypeRef(e, Void.TYPE);\n              final Procedure1<JvmOperation> _function = new Procedure1<JvmOperation>() {\n                  public void apply(final JvmOperation it) {\n                    {\n                      it.setStatic(true);\n                      EList<JvmFormalParameter> _parameters = it.getParameters();\n                      JvmTypeReference _newTypeRef = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.newTypeRef(e, java.lang.String.class);\n                      JvmTypeReference _addArrayTypeDimension = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.addArrayTypeDimension(_newTypeRef);\n                      JvmFormalParameter _parameter = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toParameter(e, \"args\", _addArrayTypeDimension);\n                      CollectionExtensions.<JvmFormalParameter>operator_add(_parameters, _parameter);\n                      boolean _containsReturn = PureXbaseJvmModelInferrer.this.containsReturn(e);\n                      boolean _operator_not = BooleanExtensions.operator_not(_containsReturn);\n                      if (_operator_not) {\n                        final Function1<ImportManager,CharSequence> _function = new Function1<ImportManager,CharSequence>() {\n                            public CharSequence apply(final ImportManager it) {\n                              StringConcatenation _builder = new StringConcatenation();\n                              _builder.append(\"try {\");\n                              String _compile = PureXbaseJvmModelInferrer.this.compile(e, it);\n                              _builder.append(_compile, \"\");\n                              _builder.newLineIfNotEmpty();\n                              _builder.append(\"} catch (Throwable t) {}\");\n                              _builder.newLine();\n                              return _builder;\n                            }\n                          };\n                        PureXbaseJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _function);\n                      } else {\n                        final Function1<ImportManager,CharSequence> _function_1 = new Function1<ImportManager,CharSequence>() {\n                            public CharSequence apply(final ImportManager it) {\n                              StringConcatenation _builder = new StringConcatenation();\n                              _builder.append(\"try {\");\n                              _builder.newLine();\n                              _builder.append(\"\\t\");\n                              _builder.append(\"xbaseExpression();\");\n                              _builder.newLine();\n                              _builder.append(\"} catch (Throwable t) {}\");\n                              _builder.newLine();\n                              return _builder;\n                            }\n                          };\n                        PureXbaseJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _function_1);\n                      }\n                    }\n                  }\n                };\n              JvmOperation _method = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toMethod(e, \"main\", _newTypeRef, _function);\n              CollectionExtensions.<JvmOperation>operator_add(_members, _method);\n              boolean _containsReturn = PureXbaseJvmModelInferrer.this.containsReturn(e);\n              if (_containsReturn) {\n                EList<JvmMember> _members_1 = it.getMembers();\n                JvmTypeReference _newTypeRef_1 = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.newTypeRef(e, java.lang.Object.class);\n                final Procedure1<JvmOperation> _function_1 = new Procedure1<JvmOperation>() {\n                    public void apply(final JvmOperation it) {\n                      {\n                        it.setStatic(true);\n                        final Function1<ImportManager,CharSequence> _function = new Function1<ImportManager,CharSequence>() {\n                            public CharSequence apply(final ImportManager it) {\n                              StringConcatenation _builder = new StringConcatenation();\n                              _builder.append(\"if (Boolean.TRUE) {\");\n                              String _compile = PureXbaseJvmModelInferrer.this.compile(e, it);\n                              _builder.append(_compile, \"\");\n                              _builder.newLineIfNotEmpty();\n                              _builder.append(\"}\");\n                              _builder.newLine();\n                              _builder.append(\"return null;\");\n                              _builder.newLine();\n                              return _builder;\n                            }\n                          };\n                        PureXbaseJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _function);\n                      }\n                    }\n                  };\n                JvmOperation _method_1 = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toMethod(e, \"xbaseExpression\", _newTypeRef_1, _function_1);\n                CollectionExtensions.<JvmOperation>operator_add(_members_1, _method_1);\n              }\n            }\n          }\n        };\n      JvmGenericType _class = this._jvmTypesBuilder.toClass(e, _name, _function);\n      acceptor.accept(_class);\n  }","id":71101,"modified_method":"protected void _infer(final Model m, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n      XBlockExpression _block = m.getBlock();\n      final XBlockExpression e = _block;\n      Resource _eResource = e.eResource();\n      String _name = this.name(_eResource);\n      JvmGenericType _class = this._jvmTypesBuilder.toClass(e, _name);\n      IPostIndexingInitializing<JvmGenericType> _accept = acceptor.<JvmGenericType>accept(_class);\n      final Procedure1<JvmGenericType> _function = new Procedure1<JvmGenericType>() {\n          public void apply(final JvmGenericType it) {\n            {\n              EList<JvmAnnotationReference> _annotations = it.getAnnotations();\n              JvmAnnotationReference _annotation = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toAnnotation(e, java.lang.SuppressWarnings.class, \"all\");\n              CollectionExtensions.<JvmAnnotationReference>operator_add(_annotations, _annotation);\n              EList<JvmMember> _members = it.getMembers();\n              JvmTypeReference _newTypeRef = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.newTypeRef(e, Void.TYPE);\n              final Procedure1<JvmOperation> _function = new Procedure1<JvmOperation>() {\n                  public void apply(final JvmOperation it) {\n                    {\n                      it.setStatic(true);\n                      EList<JvmFormalParameter> _parameters = it.getParameters();\n                      JvmTypeReference _newTypeRef = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.newTypeRef(e, java.lang.String.class);\n                      JvmTypeReference _addArrayTypeDimension = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.addArrayTypeDimension(_newTypeRef);\n                      JvmFormalParameter _parameter = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toParameter(e, \"args\", _addArrayTypeDimension);\n                      CollectionExtensions.<JvmFormalParameter>operator_add(_parameters, _parameter);\n                      boolean _containsReturn = PureXbaseJvmModelInferrer.this.containsReturn(e);\n                      boolean _operator_not = BooleanExtensions.operator_not(_containsReturn);\n                      if (_operator_not) {\n                        final Function1<ImportManager,CharSequence> _function = new Function1<ImportManager,CharSequence>() {\n                            public CharSequence apply(final ImportManager it) {\n                              StringConcatenation _builder = new StringConcatenation();\n                              _builder.append(\"try {\");\n                              String _compile = PureXbaseJvmModelInferrer.this.compile(e, it);\n                              _builder.append(_compile, \"\");\n                              _builder.newLineIfNotEmpty();\n                              _builder.append(\"} catch (Throwable t) {}\");\n                              _builder.newLine();\n                              return _builder;\n                            }\n                          };\n                        PureXbaseJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _function);\n                      } else {\n                        final Function1<ImportManager,CharSequence> _function_1 = new Function1<ImportManager,CharSequence>() {\n                            public CharSequence apply(final ImportManager it) {\n                              StringConcatenation _builder = new StringConcatenation();\n                              _builder.append(\"try {\");\n                              _builder.newLine();\n                              _builder.append(\"\\t\");\n                              _builder.append(\"xbaseExpression();\");\n                              _builder.newLine();\n                              _builder.append(\"} catch (Throwable t) {}\");\n                              _builder.newLine();\n                              return _builder;\n                            }\n                          };\n                        PureXbaseJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _function_1);\n                      }\n                    }\n                  }\n                };\n              JvmOperation _method = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toMethod(e, \"main\", _newTypeRef, _function);\n              CollectionExtensions.<JvmOperation>operator_add(_members, _method);\n              boolean _containsReturn = PureXbaseJvmModelInferrer.this.containsReturn(e);\n              if (_containsReturn) {\n                EList<JvmMember> _members_1 = it.getMembers();\n                JvmTypeReference _newTypeRef_1 = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.newTypeRef(e, java.lang.Object.class);\n                final Procedure1<JvmOperation> _function_1 = new Procedure1<JvmOperation>() {\n                    public void apply(final JvmOperation it) {\n                      {\n                        it.setStatic(true);\n                        final Function1<ImportManager,CharSequence> _function = new Function1<ImportManager,CharSequence>() {\n                            public CharSequence apply(final ImportManager it) {\n                              StringConcatenation _builder = new StringConcatenation();\n                              _builder.append(\"if (Boolean.TRUE) {\");\n                              String _compile = PureXbaseJvmModelInferrer.this.compile(e, it);\n                              _builder.append(_compile, \"\");\n                              _builder.newLineIfNotEmpty();\n                              _builder.append(\"}\");\n                              _builder.newLine();\n                              _builder.append(\"return null;\");\n                              _builder.newLine();\n                              return _builder;\n                            }\n                          };\n                        PureXbaseJvmModelInferrer.this._jvmTypesBuilder.setBody(it, _function);\n                      }\n                    }\n                  };\n                JvmOperation _method_1 = PureXbaseJvmModelInferrer.this._jvmTypesBuilder.toMethod(e, \"xbaseExpression\", _newTypeRef_1, _function_1);\n                CollectionExtensions.<JvmOperation>operator_add(_members_1, _method_1);\n              }\n            }\n          }\n        };\n      _accept.initializeLater(_function);\n  }","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"public void infer(final EObject e, final IAcceptor<JvmDeclaredType> acceptor, final boolean prelinkingPhase) {\n    final Procedure1<JvmGenericType> _function = new Procedure1<JvmGenericType>() {\n        public void apply(final JvmGenericType it) {\n          EList<JvmMember> _members = it.getMembers();\n          JvmTypeReference _typeForName = SimpleJvmModelInferrer.this.references.getTypeForName(java.lang.String.class, e);\n          final Procedure1<JvmOperation> _function = new Procedure1<JvmOperation>() {\n              public void apply(final JvmOperation it) {\n                {\n                  EList<JvmFormalParameter> _parameters = it.getParameters();\n                  JvmTypeReference _typeForName = SimpleJvmModelInferrer.this.references.getTypeForName(java.lang.String.class, e);\n                  JvmFormalParameter _parameter = SimpleJvmModelInferrer.this._jvmTypesBuilder.toParameter(e, \"s\", _typeForName);\n                  CollectionExtensions.<JvmFormalParameter>operator_add(_parameters, _parameter);\n                  SimpleJvmModelInferrer.this._jvmTypesBuilder.setBody(it, ((XExpression) e));\n                }\n              }\n            };\n          JvmOperation _method = SimpleJvmModelInferrer.this._jvmTypesBuilder.toMethod(e, \"doStuff\", _typeForName, _function);\n          CollectionExtensions.<JvmOperation>operator_add(_members, _method);\n        }\n      };\n    JvmGenericType _class = this._jvmTypesBuilder.toClass(((XExpression) e), \"Test\", _function);\n    acceptor.accept(_class);\n  }","id":71102,"modified_method":"public void infer(final EObject e, final IJvmDeclaredTypeAcceptor acceptor, final boolean prelinkingPhase) {\n    JvmGenericType _class = this._jvmTypesBuilder.toClass(((XExpression) e), \"Test\");\n    IPostIndexingInitializing<JvmGenericType> _accept = acceptor.<JvmGenericType>accept(_class);\n    final Procedure1<JvmGenericType> _function = new Procedure1<JvmGenericType>() {\n        public void apply(final JvmGenericType it) {\n          EList<JvmMember> _members = it.getMembers();\n          JvmTypeReference _typeForName = SimpleJvmModelInferrer.this.references.getTypeForName(java.lang.String.class, e);\n          final Procedure1<JvmOperation> _function = new Procedure1<JvmOperation>() {\n              public void apply(final JvmOperation it) {\n                {\n                  EList<JvmFormalParameter> _parameters = it.getParameters();\n                  JvmTypeReference _typeForName = SimpleJvmModelInferrer.this.references.getTypeForName(java.lang.String.class, e);\n                  JvmFormalParameter _parameter = SimpleJvmModelInferrer.this._jvmTypesBuilder.toParameter(e, \"s\", _typeForName);\n                  CollectionExtensions.<JvmFormalParameter>operator_add(_parameters, _parameter);\n                  SimpleJvmModelInferrer.this._jvmTypesBuilder.setBody(it, ((XExpression) e));\n                }\n              }\n            };\n          JvmOperation _method = SimpleJvmModelInferrer.this._jvmTypesBuilder.toMethod(e, \"doStuff\", _typeForName, _function);\n          CollectionExtensions.<JvmOperation>operator_add(_members, _method);\n        }\n      };\n    _accept.initializeLater(_function);\n  }","commit_id":"075ae8c0ded1799fd803f7e55100990ee51fd5fd","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n     * @see org.apache.sling.api.resource.ResourceResolver#findResources(java.lang.String, java.lang.String)\n     */\n    public Iterator<Resource> findResources(final String query, final String language)\n    throws SlingException {\n        checkClosed();\n        try {\n            final QueryResult res = JcrResourceUtil.query(adaptTo(Session.class), query, language);\n            return new ResourceIteratorDecorator(this.factory.getResourceDecoratorTracker(), null,\n                    new JcrNodeResourceIterator(this, res.getNodes(), factory.getDynamicClassLoader()));\n        } catch (javax.jcr.query.InvalidQueryException iqe) {\n            throw new QuerySyntaxException(iqe.getMessage(), query, language, iqe);\n        } catch (RepositoryException re) {\n            throw new SlingException(re.getMessage(), re);\n        }\n    }","id":71103,"modified_method":"/**\n     * @see org.apache.sling.api.resource.ResourceResolver#findResources(java.lang.String, java.lang.String)\n     */\n    public Iterator<Resource> findResources(final String query, final String language)\n    throws SlingException {\n        checkClosed();\n        try {\n            Session session = null;\n            String workspaceName = null;\n            if (requestBoundResolver != null) {\n                session = requestBoundResolver.adaptTo(Session.class);\n                workspaceName = session.getWorkspace().getName();\n            } else {\n                session = getSession();\n            }\n            final QueryResult res = JcrResourceUtil.query(session, query, language);\n            return new ResourceIteratorDecorator(this.factory.getResourceDecoratorTracker(), workspaceName,\n                    new JcrNodeResourceIterator(this, res.getNodes(), factory.getDynamicClassLoader()));\n        } catch (javax.jcr.query.InvalidQueryException iqe) {\n            throw new QuerySyntaxException(iqe.getMessage(), query, language, iqe);\n        } catch (RepositoryException re) {\n            throw new SlingException(re.getMessage(), re);\n        }\n    }","commit_id":"0f3639636223558d8e9737b0b86f1b27c2373a96","url":"https://github.com/apache/sling"},{"original_method":"/**\n     * Returns an <code>ValueMap<\/code> object for the given\n     * <code>Resource<\/code>.\n     * This method calls {@link Resource#adaptTo(Class)} with the\n     * {@link ValueMap} class as an argument. If the <code>adaptTo<\/code>\n     * method returns a map, this map is returned. If the resource is not\n     * adaptable to a value map, next an adaption to {@link Map} is tried\n     * and if this is successful the map is wrapped as a value map.\n     * If the adaptions are not successful an empty value map is returned.\n     * If <code>null<\/code> is provided as the resource an empty map is\n     * returned as well.\n     * @param res The <code>Resource<\/code> to adapt to the value map.\n     * @return A value map.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static ValueMap getValueMap(final Resource res) {\n        ValueMap map = (res == null)\n                ? ValueMap.EMPTY\n                : res.adaptTo(ValueMap.class);\n        if (map == null) {\n            Map m = res.adaptTo(Map.class);\n            if (m != null) {\n                map = new ValueMapDecorator(m);\n            } else {\n                map = ValueMap.EMPTY;\n            }\n        }\n        return map;\n    }","id":71104,"modified_method":"/**\n     * Returns an <code>ValueMap<\/code> object for the given\n     * <code>Resource<\/code>.\n     * This method calls {@link Resource#adaptTo(Class)} with the\n     * {@link ValueMap} class as an argument. If the <code>adaptTo<\/code>\n     * method returns a map, this map is returned. If the resource is not\n     * adaptable to a value map, next an adaption to {@link Map} is tried\n     * and if this is successful the map is wrapped as a value map.\n     * If the adaptions are not successful an empty value map is returned.\n     * If <code>null<\/code> is provided as the resource an empty map is\n     * returned as well.\n     * @param res The <code>Resource<\/code> to adapt to the value map.\n     * @return A value map.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static ValueMap getValueMap(final Resource res) {\n        // adapt to ValueMap if resource is not null\n        ValueMap valueMap = (res != null)?\n            res.adaptTo(ValueMap.class) : null;\n        \n        // if no resource or no ValueMap adapter, check Map\n        if (valueMap == null) {\n            \n            Map map = (res != null) ? res.adaptTo(Map.class) : null;\n\n            // if not even adapting to map, assume an empty map\n            if (map == null) {\n                map = new HashMap<String, Object>();\n            }\n            \n            // .. and decorate the plain map\n            valueMap = new ValueMapDecorator(map);\n        }\n        \n        return valueMap;\n    }","commit_id":"546a72fed454d9b83e3c9ba5f902423d44791b0e","url":"https://github.com/apache/sling"},{"original_method":"public void testGetValueMap() {\n        // expect an empty ValueMap \n        ValueMap valueMap = ResourceUtil.getValueMap(null);\n        assertNotNull(valueMap);\n        assertEquals(0, valueMap.size());\n    }","id":71105,"modified_method":"public void test_getValueMap_direct() {\n        final ValueMap valueMap = new ValueMapDecorator(new HashMap<String, Object>());\n        valueMap.put(\"sample\", true);\n        final Resource resource = new SyntheticResource(null, \"/\", \"sample\") {\n            @Override\n            @SuppressWarnings(\"unchecked\")\n            public <Type> Type adaptTo(Class<Type> type) {\n                if (type == ValueMap.class) {\n                    return (Type) valueMap;\n                }\n                \n                return super.adaptTo(type);\n            }\n        };\n        \n        final ValueMap adapted = ResourceUtil.getValueMap(resource);\n        assertEquals(valueMap, adapted);\n        assertNotNull(adapted);\n        assertEquals(1, adapted.size());\n\n        assertEquals(true, adapted.get(\"sample\"));\n        assertEquals(Boolean.valueOf(true), adapted.get(\"sample\", Boolean.class));\n        assertEquals(Boolean.TRUE.toString(), adapted.get(\"sample\", String.class));\n    }","commit_id":"546a72fed454d9b83e3c9ba5f902423d44791b0e","url":"https://github.com/apache/sling"},{"original_method":"Score doIt(Model model, Frame fr, Frame validation, Vec vresponse) {\n      // No validation, so do on training data\n      if( validation == null ) return doAll(fr);\n\n      // Validation: need to score the set, getting a probability distribution for each class\n      // Frame has nclass vectors (nclass, or 1 for regression)\n      Frame res = model.score(validation,true);\n      // Adapt the validation set to the model\n      Frame frs[] = model.adapt(validation,true);\n      Frame adapValidation = frs[0]; // adapted validation dataset\n      // Adapt vresponse to original response\n      vresponse = vresponse.adaptTo(response, true);\n      // Dump in the prob distribution\n      adapValidation.add(\"response\",vresponse);\n      for( int i=0; i<_nclass; i++ )\n        adapValidation.add(\"Work\"+i,res.vecs()[i+1]);\n      // Compute a CM & MSE\n      doAll(adapValidation);\n      // Remove the extra adapted Vecs\n      frs[1].remove();\n      // Remove temporary result\n      // FIXME delete vresponse res.remove();\n      return this;\n    }","id":71106,"modified_method":"Score doIt(Model model, Frame fr, Frame validation, Vec vresponse) {\n      // No validation, so do on training data\n      if( validation == null ) return doAll(fr);\n\n      // Validation: need to score the set, getting a probability distribution for each class\n      // Frame has nclass vectors (nclass, or 1 for regression)\n      Frame res = model.score(validation,true);\n      // Adapt the validation set to the model\n      Frame frs[] = model.adapt(validation,true);\n      Frame adapValidation = frs[0]; // adapted validation dataset\n      // Adapt vresponse to original response\n      vresponse = _nclass > 1 ? vresponse.adaptTo(response, true) : vresponse;\n      // Dump in the prob distribution\n      adapValidation.add(\"response\",vresponse);\n      if (_nclass>1) { // Classification\n        for( int i=0; i<_nclass; i++ )\n          adapValidation.add(\"Work\"+i,res.vecs()[i+1]);\n      } else { // Regression\n        adapValidation.add(\"Work\"+0,res.vecs()[0]);\n      }\n      // Compute a CM & MSE\n      doAll(adapValidation);\n      // Remove the extra adapted Vecs\n      frs[1].remove();\n      // Remove temporary result\n      // FIXME delete vresponse res.remove();\n      return this;\n    }","commit_id":"247954a4e5fd3a8252c13192e5fbf3054b894e3d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public Vec makeTransf(final int[] domMap) { return makeTransf(domMap); }","id":71107,"modified_method":"public Vec makeTransf(final int[] domMap) { return makeTransf(domMap, null); }","commit_id":"247954a4e5fd3a8252c13192e5fbf3054b894e3d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void parseFor() {\n        assert _at(FOR_KEYWORD);\n\n        PsiBuilder.Marker loop = mark();\n\n        advance(); // FOR_KEYWORD\n\n        myBuilder.disableNewlines();\n        expect(LPAR, \"Expecting '(' to open a loop range\", TokenSet.create(RPAR, VAL_KEYWORD, VAR_KEYWORD, IDENTIFIER));\n\n        PsiBuilder.Marker parameter = mark();\n        if (at(VAL_KEYWORD) || at(VAR_KEYWORD)) advance(); // VAL_KEYWORD or VAR_KEYWORD\n        expect(IDENTIFIER, \"Expecting a variable name\", TokenSet.create(COLON));\n        if (at(COLON)) {\n            advance(); // COLON\n            myJetParsing.parseTypeRef();\n        }\n        parameter.done(LOOP_PARAMETER);\n\n        expect(IN_KEYWORD, \"Expecting 'in'\");\n\n        PsiBuilder.Marker range = mark();\n        parseExpression();\n        range.done(LOOP_RANGE);\n\n        expectNoAdvance(RPAR, \"Expecting ')'\");\n        myBuilder.restoreNewlinesState();\n\n        parseControlStructureBody();\n\n        loop.done(FOR);\n    }","id":71108,"modified_method":"private void parseFor() {\n        assert _at(FOR_KEYWORD);\n\n        PsiBuilder.Marker loop = mark();\n\n        advance(); // FOR_KEYWORD\n\n        myBuilder.disableNewlines();\n        expect(LPAR, \"Expecting '(' to open a loop range\", TokenSet.create(RPAR, VAL_KEYWORD, VAR_KEYWORD, IDENTIFIER));\n\n        PsiBuilder.Marker parameter = mark();\n        if (at(VAL_KEYWORD) || at(VAR_KEYWORD)) advance(); // VAL_KEYWORD or VAR_KEYWORD\n        if (!myJetParsing.parseIdeTemplate()) {\n            expect(IDENTIFIER, \"Expecting a variable name\", TokenSet.create(COLON));\n        }\n        if (at(COLON)) {\n            advance(); // COLON\n            myJetParsing.parseTypeRef();\n        }\n        parameter.done(LOOP_PARAMETER);\n\n        expect(IN_KEYWORD, \"Expecting 'in'\");\n\n        PsiBuilder.Marker range = mark();\n        parseExpression();\n        range.done(LOOP_RANGE);\n\n        expectNoAdvance(RPAR, \"Expecting ')'\");\n        myBuilder.restoreNewlinesState();\n\n        parseControlStructureBody();\n\n        loop.done(FOR);\n    }","commit_id":"ce48e39d4020751a07459637e8263afcfb371955","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetKeywordCompletionContributor() {\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                IMPORT_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, PACKAGE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, OVERRIDE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                AS_KEYWORD, BREAK_KEYWORD, BY_KEYWORD,\n                CATCH_KEYWORD, CONTINUE_KEYWORD,\n                DO_KEYWORD, ELSE_KEYWORD, ENUM_KEYWORD,\n                FALSE_KEYWORD, FINALLY_KEYWORD, FOR_KEYWORD,\n                GET_KEYWORD,\n                IN_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                IS_KEYWORD, NULL_KEYWORD,\n                PRIVATE_KEYWORD, PROTECTED_KEYWORD, PUBLIC_KEYWORD,\n                RETURN_KEYWORD, SET_KEYWORD, SUPER_KEYWORD,\n                CAPITALIZED_THIS_KEYWORD, THIS_KEYWORD, THROW_KEYWORD,\n                TRUE_KEYWORD, TRY_KEYWORD,\n                TYPE_KEYWORD,\n                VARARG_KEYWORD, WHEN_KEYWORD, WHERE_KEYWORD,\n                WHILE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                ELSE_KEYWORD, FALSE_KEYWORD,\n                NULL_KEYWORD, THIS_KEYWORD, TRUE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InParametersFilter(), OUT_KEYWORD);\n\n        // templates\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE, OBJECT_NAMED_TEMPLATE, CLASS_OBJECT_TEMPLATE);\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                                        IF_TEMPLATE, IF_ELSE_TEMPLATE, IF_ELSE_ONELINE_TEMPLATE,\n                                        FUN_TEMPLATE, VAL_SIMPLE_TEMPLATE, VAR_SIMPLE_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE, OBJECT_NAMED_TEMPLATE);\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                                        IF_ELSE_ONELINE_TEMPLATE);\n    }","id":71109,"modified_method":"public JetKeywordCompletionContributor() {\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                IMPORT_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, PACKAGE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, OVERRIDE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                AS_KEYWORD, BREAK_KEYWORD, BY_KEYWORD,\n                CATCH_KEYWORD, CONTINUE_KEYWORD,\n                DO_KEYWORD, ELSE_KEYWORD, ENUM_KEYWORD,\n                FALSE_KEYWORD, FINALLY_KEYWORD,\n                GET_KEYWORD,\n                IN_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                IS_KEYWORD, NULL_KEYWORD,\n                PRIVATE_KEYWORD, PROTECTED_KEYWORD, PUBLIC_KEYWORD,\n                RETURN_KEYWORD, SET_KEYWORD, SUPER_KEYWORD,\n                CAPITALIZED_THIS_KEYWORD, THIS_KEYWORD, THROW_KEYWORD,\n                TRUE_KEYWORD, TRY_KEYWORD,\n                TYPE_KEYWORD,\n                VARARG_KEYWORD, WHEN_KEYWORD, WHERE_KEYWORD,\n                WHILE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                ELSE_KEYWORD, FALSE_KEYWORD,\n                NULL_KEYWORD, THIS_KEYWORD, TRUE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InParametersFilter(), OUT_KEYWORD);\n\n        // templates\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE, OBJECT_NAMED_TEMPLATE, CLASS_OBJECT_TEMPLATE);\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                                        IF_TEMPLATE, IF_ELSE_TEMPLATE, IF_ELSE_ONELINE_TEMPLATE,\n                                        FUN_TEMPLATE, VAL_SIMPLE_TEMPLATE, VAR_SIMPLE_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE, OBJECT_NAMED_TEMPLATE, FOR_TEMPLATE);\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                                        IF_ELSE_ONELINE_TEMPLATE);\n    }","commit_id":"ce48e39d4020751a07459637e8263afcfb371955","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseReceiverType(String title, TokenSet nameFollow, int lastDot) {\n        if (lastDot == -1) { // There's no explicit receiver type specified\n            parseAnnotations(false);\n\n            if (!parseIdeTemplate()) {\n                expect(IDENTIFIER, \"Expecting \" + title + \" name or receiver type\", nameFollow);\n            }\n        } else {\n            createTruncatedBuilder(lastDot).parseTypeRef();\n\n            if (atSet(RECEIVER_TYPE_TERMINATORS)) {\n                advance(); // expectation\n            }\n            else {\n                errorWithRecovery(\"Expecting '.' before a \" + title + \" name\", nameFollow);\n            }\n\n            expect(IDENTIFIER, \"Expecting \" + title + \" name\", nameFollow);\n        }\n    }","id":71110,"modified_method":"private void parseReceiverType(String title, TokenSet nameFollow, int lastDot) {\n        if (lastDot == -1) { // There's no explicit receiver type specified\n            parseAnnotations(false);\n\n            if (!parseIdeTemplate()) {\n                expect(IDENTIFIER, \"Expecting \" + title + \" name or receiver type\", nameFollow);\n            }\n        } else {\n            if (parseIdeTemplate()) {\n                expect(DOT, \"Expecting '.' after receiver template\");\n            }\n            else {\n                createTruncatedBuilder(lastDot).parseTypeRef();\n\n                if (atSet(RECEIVER_TYPE_TERMINATORS)) {\n                    advance(); // expectation\n                }\n                else {\n                    errorWithRecovery(\"Expecting '.' before a \" + title + \" name\", nameFollow);\n                }\n            }\n\n            if (!parseIdeTemplate()) {\n                expect(IDENTIFIER, \"Expecting \" + title + \" name\", nameFollow);\n            }\n        }\n    }","commit_id":"ecdcfdb45a0b6044d0d8bd0fb9ce231053ae5f74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public IElementType parseFunction() {\n        assert _at(FUN_KEYWORD);\n\n        advance(); // FUN_KEYWORD\n\n        // Recovery for the case of class A { fun| }\n        if (at(RBRACE)) {\n            error(\"Function body expected\");\n            return FUN;\n        }\n\n        boolean typeParameterListOccurred = false;\n        if (at(LT)) {\n            parseTypeParameterList(TokenSet.create(LBRACKET, LBRACE, LPAR));\n            typeParameterListOccurred = true;\n        }\n\n        myBuilder.disableJoiningComplexTokens();\n        int lastDot = findLastBefore(RECEIVER_TYPE_TERMINATORS, TokenSet.create(LPAR), true);\n        parseReceiverType(\"function\", TokenSet.create(LT, LPAR, COLON, EQ), lastDot);\n        myBuilder.restoreJoiningComplexTokensState();\n\n        TokenSet valueParametersFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON, RPAR);\n\n        if (at(LT)) {\n            PsiBuilder.Marker error = mark();\n            parseTypeParameterList(TokenSet.orSet(TokenSet.create(LPAR), valueParametersFollow));\n            if (typeParameterListOccurred) {\n                error.error(\"Only one type parameter list is allowed for a function\"); // TODO : discuss\n            }\n            else {\n                error.drop();\n            }\n            typeParameterListOccurred = true;\n        }\n\n        parseValueParameterList(false, valueParametersFollow);\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            parseTypeRef();\n        }\n\n        parseTypeConstraintsGuarded(typeParameterListOccurred);\n\n        if (at(SEMICOLON)) {\n            advance(); // SEMICOLON\n        }\n        else if (at(EQ) || at(LBRACE)) {\n            parseFunctionBody();\n        }\n\n        return FUN;\n    }","id":71111,"modified_method":"public IElementType parseFunction() {\n        assert _at(FUN_KEYWORD);\n\n        advance(); // FUN_KEYWORD\n\n        // Recovery for the case of class A { fun| }\n        if (at(RBRACE)) {\n            error(\"Function body expected\");\n            return FUN;\n        }\n\n        boolean typeParameterListOccurred = false;\n        if (at(LT)) {\n            parseTypeParameterList(TokenSet.create(LBRACKET, LBRACE, LPAR));\n            typeParameterListOccurred = true;\n        }\n\n        myBuilder.disableJoiningComplexTokens();\n        int lastDot = findLastBefore(RECEIVER_TYPE_TERMINATORS, TokenSet.create(LPAR), true);\n        parseReceiverType(\"function\", TokenSet.create(LT, LPAR, COLON, EQ), lastDot);\n        myBuilder.restoreJoiningComplexTokensState();\n\n        TokenSet valueParametersFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON, RPAR);\n\n        if (at(LT)) {\n            PsiBuilder.Marker error = mark();\n            parseTypeParameterList(TokenSet.orSet(TokenSet.create(LPAR), valueParametersFollow));\n            if (typeParameterListOccurred) {\n                error.error(\"Only one type parameter list is allowed for a function\"); // TODO : discuss\n            }\n            else {\n                error.drop();\n            }\n            typeParameterListOccurred = true;\n        }\n\n        parseValueParameterList(false, valueParametersFollow);\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            if (!parseIdeTemplate()) {\n                parseTypeRef();\n            }\n        }\n\n        parseTypeConstraintsGuarded(typeParameterListOccurred);\n\n        if (at(SEMICOLON)) {\n            advance(); // SEMICOLON\n        }\n        else if (at(EQ) || at(LBRACE)) {\n            parseFunctionBody();\n        }\n\n        return FUN;\n    }","commit_id":"ecdcfdb45a0b6044d0d8bd0fb9ce231053ae5f74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void parseValueParameterList(boolean isFunctionTypeContents, TokenSet recoverySet) {\n        PsiBuilder.Marker parameters = mark();\n\n        myBuilder.disableNewlines();\n        expect(LPAR, \"Expecting '(\", recoverySet);\n\n        if (!at(RPAR) && !atSet(recoverySet)) {\n            while (true) {\n                if (at(COMMA)) {\n                    errorAndAdvance(\"Expecting a parameter declaration\");\n                }\n                else if (at(RPAR)) {\n                    error(\"Expecting a parameter declaration\");\n                    break;\n                }\n                if (isFunctionTypeContents) {\n                    if (!tryParseValueParameter()) {\n                        PsiBuilder.Marker valueParameter = mark();\n                        parseModifierList(MODIFIER_LIST, false); // lazy, out, ref\n                        parseTypeRef();\n                        valueParameter.done(VALUE_PARAMETER);\n                    }\n                } else {\n                    parseValueParameter();\n                }\n                if (!at(COMMA)) break;\n                advance(); // COMMA\n            }\n        }\n        expect(RPAR, \"Expecting ')'\", recoverySet);\n        myBuilder.restoreNewlinesState();\n\n        parameters.done(VALUE_PARAMETER_LIST);\n    }","id":71112,"modified_method":"public void parseValueParameterList(boolean isFunctionTypeContents, TokenSet recoverySet) {\n        PsiBuilder.Marker parameters = mark();\n\n        myBuilder.disableNewlines();\n        expect(LPAR, \"Expecting '(\", recoverySet);\n\n        if (!parseIdeTemplate()) {\n            if (!at(RPAR) && !atSet(recoverySet)) {\n                while (true) {\n                    if (at(COMMA)) {\n                        errorAndAdvance(\"Expecting a parameter declaration\");\n                    }\n                    else if (at(RPAR)) {\n                        error(\"Expecting a parameter declaration\");\n                        break;\n                    }\n                    if (isFunctionTypeContents) {\n                        if (!tryParseValueParameter()) {\n                            PsiBuilder.Marker valueParameter = mark();\n                            parseModifierList(MODIFIER_LIST, false); // lazy, out, ref\n                            parseTypeRef();\n                            valueParameter.done(VALUE_PARAMETER);\n                        }\n                    } else {\n                        parseValueParameter();\n                    }\n                    if (!at(COMMA)) break;\n                    advance(); // COMMA\n                }\n            }\n        }\n        \n        expect(RPAR, \"Expecting ')'\", recoverySet);\n        myBuilder.restoreNewlinesState();\n\n        parameters.done(VALUE_PARAMETER_LIST);\n    }","commit_id":"ecdcfdb45a0b6044d0d8bd0fb9ce231053ae5f74","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetKeywordCompletionContributor() {\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                ABSTRACT_KEYWORD, CLASS_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                IMPORT_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, PACKAGE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TRAIT_KEYWORD, TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                ABSTRACT_KEYWORD, CLASS_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                INLINE_KEYWORD, INTERNAL_KEYWORD, OBJECT_KEYWORD,\n                OPEN_KEYWORD, OVERRIDE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TRAIT_KEYWORD, TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                AS_KEYWORD, BREAK_KEYWORD, BY_KEYWORD,\n                CATCH_KEYWORD, CLASS_KEYWORD, CONTINUE_KEYWORD,\n                DO_KEYWORD, ELSE_KEYWORD, ENUM_KEYWORD,\n                FALSE_KEYWORD, FINALLY_KEYWORD, FOR_KEYWORD,\n                GET_KEYWORD,\n                IN_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                IS_KEYWORD, NULL_KEYWORD, OBJECT_KEYWORD,\n                PRIVATE_KEYWORD, PROTECTED_KEYWORD, PUBLIC_KEYWORD,\n                RETURN_KEYWORD, SET_KEYWORD, SUPER_KEYWORD,\n                CAPITALIZED_THIS_KEYWORD, THIS_KEYWORD, THROW_KEYWORD,\n                TRAIT_KEYWORD, TRUE_KEYWORD, TRY_KEYWORD,\n                TYPE_KEYWORD,\n                VARARG_KEYWORD, WHEN_KEYWORD, WHERE_KEYWORD,\n                WHILE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                ELSE_KEYWORD, FALSE_KEYWORD,\n                NULL_KEYWORD, THIS_KEYWORD, TRUE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InParametersFilter(), OUT_KEYWORD);\n\n        // templates\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE);\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE);\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                                        IF_TEMPLATE, IF_ELSE_TEMPLATE, IF_ELSE_ONELINE_TEMPLATE,\n                                        FUN_TEMPLATE, VAL_SIMPLE_TEMPLATE, VAR_SIMPLE_TEMPLATE);\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                                        IF_ELSE_ONELINE_TEMPLATE);\n    }","id":71113,"modified_method":"public JetKeywordCompletionContributor() {\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                IMPORT_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, PACKAGE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                INLINE_KEYWORD, INTERNAL_KEYWORD, OBJECT_KEYWORD,\n                OPEN_KEYWORD, OVERRIDE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                AS_KEYWORD, BREAK_KEYWORD, BY_KEYWORD,\n                CATCH_KEYWORD, CONTINUE_KEYWORD,\n                DO_KEYWORD, ELSE_KEYWORD, ENUM_KEYWORD,\n                FALSE_KEYWORD, FINALLY_KEYWORD, FOR_KEYWORD,\n                GET_KEYWORD,\n                IN_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                IS_KEYWORD, NULL_KEYWORD, OBJECT_KEYWORD,\n                PRIVATE_KEYWORD, PROTECTED_KEYWORD, PUBLIC_KEYWORD,\n                RETURN_KEYWORD, SET_KEYWORD, SUPER_KEYWORD,\n                CAPITALIZED_THIS_KEYWORD, THIS_KEYWORD, THROW_KEYWORD,\n                TRUE_KEYWORD, TRY_KEYWORD,\n                TYPE_KEYWORD,\n                VARARG_KEYWORD, WHEN_KEYWORD, WHERE_KEYWORD,\n                WHILE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                ELSE_KEYWORD, FALSE_KEYWORD,\n                NULL_KEYWORD, THIS_KEYWORD, TRUE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InParametersFilter(), OUT_KEYWORD);\n\n        // templates\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                                        IF_TEMPLATE, IF_ELSE_TEMPLATE, IF_ELSE_ONELINE_TEMPLATE,\n                                        FUN_TEMPLATE, VAL_SIMPLE_TEMPLATE, VAR_SIMPLE_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                                        IF_ELSE_ONELINE_TEMPLATE);\n    }","commit_id":"e4953f60fb242704dee5591d9afb0ea863350790","url":"https://github.com/JetBrains/kotlin"},{"original_method":"void parseClassBody() {\n        PsiBuilder.Marker body = mark();\n\n        myBuilder.enableNewlines();\n        expect(LBRACE, \"Expecting a class body\", TokenSet.create(LBRACE));\n\n        while (!eof()) {\n            if (at(RBRACE)) {\n                break;\n            }\n            parseMemberDeclaration();\n        }\n        expect(RBRACE, \"Missing '}\");\n        myBuilder.restoreNewlinesState();\n\n        body.done(CLASS_BODY);\n    }","id":71114,"modified_method":"void parseClassBody() {\n        PsiBuilder.Marker body = mark();\n\n        myBuilder.enableNewlines();\n        expect(LBRACE, \"Expecting a class body\", TokenSet.create(LBRACE));\n\n        if (!parseIdeTemplate()) {\n            while (!eof()) {\n                if (at(RBRACE)) {\n                    break;\n                }\n                parseMemberDeclaration();\n            }\n        }\n        expect(RBRACE, \"Missing '}\");\n        myBuilder.restoreNewlinesState();\n\n        body.done(CLASS_BODY);\n    }","commit_id":"e4953f60fb242704dee5591d9afb0ea863350790","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public IElementType parseClass(boolean enumClass) {\n        assert _atSet(CLASS_KEYWORD, TRAIT_KEYWORD);\n        advance(); // CLASS_KEYWORD or TRAIT_KEYWORD\n\n        expect(IDENTIFIER, \"Class name expected\", CLASS_NAME_RECOVERY_SET);\n        boolean typeParametersDeclared = parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET);\n\n        PsiBuilder.Marker beforeConstructorModifiers = mark();\n        boolean hasConstructorModifiers = parseModifierList(PRIMARY_CONSTRUCTOR_MODIFIER_LIST, false);\n\n        // Some modifiers found, but no parentheses following: class has already ended, and we are looking at something else\n        if (hasConstructorModifiers && !atSet(LPAR, LBRACE, COLON) ) {\n            beforeConstructorModifiers.rollbackTo();\n            return CLASS;\n        }\n\n        // We are still inside a class declaration\n        beforeConstructorModifiers.drop();\n\n        if (at(LPAR)) {\n            parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n        }\n        else if (hasConstructorModifiers) {\n            // A comprehensive error message for cases like:\n            //    class A private : Foo\n            // or\n            //    class A private {\n            error(\"Expecting primary constructor parameter list\");\n        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseDelegationSpecifierList();\n        }\n\n        parseTypeConstraintsGuarded(typeParametersDeclared);\n\n        if (at(LBRACE)) {\n            if (enumClass) {\n                parseEnumClassBody();\n            }\n            else {\n                parseClassBody();\n            }\n        }\n\n        return CLASS;\n    }","id":71115,"modified_method":"public IElementType parseClass(boolean enumClass) {\n        assert _atSet(CLASS_KEYWORD, TRAIT_KEYWORD);\n        advance(); // CLASS_KEYWORD or TRAIT_KEYWORD\n\n        if (!parseIdeTemplate()) {\n            expect(IDENTIFIER, \"Class name expected\", CLASS_NAME_RECOVERY_SET);\n        }\n        boolean typeParametersDeclared = parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET);\n\n        PsiBuilder.Marker beforeConstructorModifiers = mark();\n        boolean hasConstructorModifiers = parseModifierList(PRIMARY_CONSTRUCTOR_MODIFIER_LIST, false);\n\n        // Some modifiers found, but no parentheses following: class has already ended, and we are looking at something else\n        if (hasConstructorModifiers && !atSet(LPAR, LBRACE, COLON) ) {\n            beforeConstructorModifiers.rollbackTo();\n            return CLASS;\n        }\n\n        // We are still inside a class declaration\n        beforeConstructorModifiers.drop();\n\n        if (at(LPAR)) {\n            parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n        }\n        else if (hasConstructorModifiers) {\n            // A comprehensive error message for cases like:\n            //    class A private : Foo\n            // or\n            //    class A private {\n            error(\"Expecting primary constructor parameter list\");\n        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseDelegationSpecifierList();\n        }\n\n        parseTypeConstraintsGuarded(typeParametersDeclared);\n\n        if (at(LBRACE)) {\n            if (enumClass) {\n                parseEnumClassBody();\n            }\n            else {\n                parseClassBody();\n            }\n        }\n\n        return CLASS;\n    }","commit_id":"e4953f60fb242704dee5591d9afb0ea863350790","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseEnumClassBody() {\n        if (!at(LBRACE)) return;\n\n        PsiBuilder.Marker classBody = mark();\n\n        myBuilder.enableNewlines();\n        advance(); // LBRACE\n\n        while (!eof() && !at(RBRACE)) {\n            PsiBuilder.Marker entryOrMember = mark();\n\n            TokenSet constructorNameFollow = TokenSet.create(SEMICOLON, COLON, LPAR, LT, LBRACE);\n            int lastId = findLastBefore(ENUM_MEMBER_FIRST, constructorNameFollow, false);\n            TokenDetector enumDetector = new TokenDetector(ENUM_KEYWORD);\n            createTruncatedBuilder(lastId).parseModifierList(MODIFIER_LIST, enumDetector, false);\n\n            IElementType type;\n            if (at(IDENTIFIER)) {\n                parseEnumEntry();\n                type = ENUM_ENTRY;\n            }\n            else {\n                type = parseMemberDeclarationRest(enumDetector.isDetected());\n            }\n\n            if (type == null) {\n                errorAndAdvance(\"Expecting an enum entry or member declaration\");\n                entryOrMember.drop();\n            }\n            else {\n                entryOrMember.done(type);\n            }\n        }\n\n        expect(RBRACE, \"Expecting '}' to close enum class body\");\n        myBuilder.restoreNewlinesState();\n\n        classBody.done(CLASS_BODY);\n    }","id":71116,"modified_method":"private void parseEnumClassBody() {\n        if (!at(LBRACE)) return;\n\n        PsiBuilder.Marker classBody = mark();\n\n        myBuilder.enableNewlines();\n        advance(); // LBRACE\n\n        if (!parseIdeTemplate()) {\n            while (!eof() && !at(RBRACE)) {\n                PsiBuilder.Marker entryOrMember = mark();\n\n                TokenSet constructorNameFollow = TokenSet.create(SEMICOLON, COLON, LPAR, LT, LBRACE);\n                int lastId = findLastBefore(ENUM_MEMBER_FIRST, constructorNameFollow, false);\n                TokenDetector enumDetector = new TokenDetector(ENUM_KEYWORD);\n                createTruncatedBuilder(lastId).parseModifierList(MODIFIER_LIST, enumDetector, false);\n\n                IElementType type;\n                if (at(IDENTIFIER)) {\n                    parseEnumEntry();\n                    type = ENUM_ENTRY;\n                }\n                else {\n                    type = parseMemberDeclarationRest(enumDetector.isDetected());\n                }\n\n                if (type == null) {\n                    errorAndAdvance(\"Expecting an enum entry or member declaration\");\n                    entryOrMember.drop();\n                }\n                else {\n                    entryOrMember.done(type);\n                }\n            }\n        }\n\n        expect(RBRACE, \"Expecting '}' to close enum class body\");\n        myBuilder.restoreNewlinesState();\n\n        classBody.done(CLASS_BODY);\n    }","commit_id":"e4953f60fb242704dee5591d9afb0ea863350790","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetKeywordCompletionContributor() {\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                IMPORT_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, PACKAGE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                INLINE_KEYWORD, INTERNAL_KEYWORD, OBJECT_KEYWORD,\n                OPEN_KEYWORD, OVERRIDE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                AS_KEYWORD, BREAK_KEYWORD, BY_KEYWORD,\n                CATCH_KEYWORD, CONTINUE_KEYWORD,\n                DO_KEYWORD, ELSE_KEYWORD, ENUM_KEYWORD,\n                FALSE_KEYWORD, FINALLY_KEYWORD, FOR_KEYWORD,\n                GET_KEYWORD,\n                IN_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                IS_KEYWORD, NULL_KEYWORD, OBJECT_KEYWORD,\n                PRIVATE_KEYWORD, PROTECTED_KEYWORD, PUBLIC_KEYWORD,\n                RETURN_KEYWORD, SET_KEYWORD, SUPER_KEYWORD,\n                CAPITALIZED_THIS_KEYWORD, THIS_KEYWORD, THROW_KEYWORD,\n                TRUE_KEYWORD, TRY_KEYWORD,\n                TYPE_KEYWORD,\n                VARARG_KEYWORD, WHEN_KEYWORD, WHERE_KEYWORD,\n                WHILE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                ELSE_KEYWORD, FALSE_KEYWORD,\n                NULL_KEYWORD, THIS_KEYWORD, TRUE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InParametersFilter(), OUT_KEYWORD);\n\n        // templates\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                                        IF_TEMPLATE, IF_ELSE_TEMPLATE, IF_ELSE_ONELINE_TEMPLATE,\n                                        FUN_TEMPLATE, VAL_SIMPLE_TEMPLATE, VAR_SIMPLE_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                                        IF_ELSE_ONELINE_TEMPLATE);\n    }","id":71117,"modified_method":"public JetKeywordCompletionContributor() {\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                IMPORT_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, PACKAGE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                ABSTRACT_KEYWORD, ENUM_KEYWORD,\n                FINAL_KEYWORD, GET_KEYWORD,\n                INLINE_KEYWORD, INTERNAL_KEYWORD,\n                OPEN_KEYWORD, OVERRIDE_KEYWORD, PRIVATE_KEYWORD,\n                PROTECTED_KEYWORD, PUBLIC_KEYWORD, SET_KEYWORD,\n                TYPE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                AS_KEYWORD, BREAK_KEYWORD, BY_KEYWORD,\n                CATCH_KEYWORD, CONTINUE_KEYWORD,\n                DO_KEYWORD, ELSE_KEYWORD, ENUM_KEYWORD,\n                FALSE_KEYWORD, FINALLY_KEYWORD, FOR_KEYWORD,\n                GET_KEYWORD,\n                IN_KEYWORD, INLINE_KEYWORD, INTERNAL_KEYWORD,\n                IS_KEYWORD, NULL_KEYWORD,\n                PRIVATE_KEYWORD, PROTECTED_KEYWORD, PUBLIC_KEYWORD,\n                RETURN_KEYWORD, SET_KEYWORD, SUPER_KEYWORD,\n                CAPITALIZED_THIS_KEYWORD, THIS_KEYWORD, THROW_KEYWORD,\n                TRUE_KEYWORD, TRY_KEYWORD,\n                TYPE_KEYWORD,\n                VARARG_KEYWORD, WHEN_KEYWORD, WHERE_KEYWORD,\n                WHILE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                ELSE_KEYWORD, FALSE_KEYWORD,\n                NULL_KEYWORD, THIS_KEYWORD, TRUE_KEYWORD);\n\n        registerScopeKeywordsCompletion(new InParametersFilter(), OUT_KEYWORD);\n\n        // templates\n        registerScopeKeywordsCompletion(new InTopFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE);\n        registerScopeKeywordsCompletion(new InClassBodyFilter(),\n                                        FUN_TEMPLATE, VAL_WITH_TYPE_TEMPLATE, VAL_WITH_GETTER_TEMPLATE,\n                                        VAR_WITH_TYPE_TEMPLATE, VAR_WITH_GETTER_AND_SETTER_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE, OBJECT_NAMED_TEMPLATE);\n        registerScopeKeywordsCompletion(new InNonClassBlockFilter(),\n                                        IF_TEMPLATE, IF_ELSE_TEMPLATE, IF_ELSE_ONELINE_TEMPLATE,\n                                        FUN_TEMPLATE, VAL_SIMPLE_TEMPLATE, VAR_SIMPLE_TEMPLATE,\n                                        TRAIT_TEMPLATE, CLASS_TEMPLATE, OBJECT_NAMED_TEMPLATE);\n        registerScopeKeywordsCompletion(new InPropertyFilter(),\n                                        IF_ELSE_ONELINE_TEMPLATE);\n    }","commit_id":"679862778c6f4ce03c3001869d9facfa33313170","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void parseObject(boolean named, boolean optionalBody) {\n        assert _at(OBJECT_KEYWORD);\n\n        advance(); // OBJECT_KEYWORD\n\n        if (named) {\n            PsiBuilder.Marker propertyDeclaration = mark();\n            expect(IDENTIFIER, \"Expecting object name\", TokenSet.create(LBRACE));\n            propertyDeclaration.done(OBJECT_DECLARATION_NAME);\n        }\n        else {\n            if (at(IDENTIFIER)) {\n                error(\"An object expression cannot bind a name\");\n            }\n        }\n\n        if (optionalBody) {\n            if (at(COLON)) {\n                advance(); // COLON\n                parseDelegationSpecifierList();\n            }\n            if (at(LBRACE)) {\n                parseClassBody();\n            }\n        }\n        else {\n            if (at(LBRACE)) {\n                parseClassBody();\n            }\n            else {\n                expect(COLON, \"Expecting ':'\", TokenSet.create(IDENTIFIER, PACKAGE_KEYWORD));\n                parseDelegationSpecifierList();\n                parseClassBody();\n            }\n        }\n    }","id":71118,"modified_method":"public void parseObject(boolean named, boolean optionalBody) {\n        assert _at(OBJECT_KEYWORD);\n\n        advance(); // OBJECT_KEYWORD\n\n        if (named) {\n            PsiBuilder.Marker propertyDeclaration = mark();\n            if (!parseIdeTemplate()) {\n                expect(IDENTIFIER, \"Expecting object name\", TokenSet.create(LBRACE));\n            }\n            propertyDeclaration.done(OBJECT_DECLARATION_NAME);\n        }\n        else {\n            if (at(IDENTIFIER)) {\n                error(\"An object expression cannot bind a name\");\n            }\n        }\n\n        if (optionalBody) {\n            if (at(COLON)) {\n                advance(); // COLON\n                parseDelegationSpecifierList();\n            }\n            if (at(LBRACE)) {\n                parseClassBody();\n            }\n        }\n        else {\n            if (at(LBRACE)) {\n                parseClassBody();\n            }\n            else {\n                expect(COLON, \"Expecting ':'\", TokenSet.create(IDENTIFIER, PACKAGE_KEYWORD));\n                parseDelegationSpecifierList();\n                parseClassBody();\n            }\n        }\n    }","commit_id":"679862778c6f4ce03c3001869d9facfa33313170","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * Constructor.\n     */\n    public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc,\n            PageInfo pi, String prefix, String uriIn,\n            TldResourcePath tldResourcePath, ErrorDispatcher err)\n            throws JasperException {\n        super(prefix, uriIn);\n\n        this.ctxt = ctxt;\n        this.parserController = pc;\n        this.pi = pi;\n        this.err = err;\n\n        if (tldResourcePath == null) {\n            // The URI points to the TLD itself or to a JAR file in which the TLD is stored\n            tldResourcePath = generateTldResourcePath(uri, ctxt);\n        }\n\n        Jar jar;\n        try {\n            jar = tldResourcePath.getJar();\n        } catch (IOException ioe) {\n            throw new JasperException(ioe);\n        }\n\n        // Add the dependencies on the TLD to the referencing page\n        PageInfo pageInfo = ctxt.createCompiler().getPageInfo();\n        if (pageInfo != null) {\n            String path = tldResourcePath.getWebappPath();\n            // Add TLD (jar==null) / JAR (jar!=null) file to dependency list\n            pageInfo.addDependant(path, ctxt.getLastModified(path));\n            if (jar != null) {\n                // Add TLD within the JAR to the dependency list\n                String entryName = tldResourcePath.getEntryName();\n                try {\n                    pageInfo.addDependant(jar.getURL(entryName),\n                            Long.valueOf(jar.getLastModified(entryName)));\n                } catch (IOException ioe) {\n                    throw new JasperException(ioe);\n                }\n            }\n        }\n\n        // Get the representation of the TLD\n        TaglibXml taglibXml =\n                ctxt.getOptions().getTldCache().getTaglibXml(tldResourcePath);\n\n        // Populate the TagLibraryInfo attributes\n        this.jspversion = taglibXml.getJspVersion();\n        this.tlibversion = taglibXml.getTlibVersion();\n        this.shortname = taglibXml.getShortName();\n        this.urn = taglibXml.getUri();\n        this.info = taglibXml.getInfo();\n\n        this.tagLibraryValidator = createValidator(taglibXml.getValidator());\n\n        List<TagInfo> tagInfos = new ArrayList<>();\n        for (TagXml tagXml : taglibXml.getTags()) {\n            tagInfos.add(createTagInfo(tagXml));\n        }\n\n        List<TagFileInfo> tagFileInfos = new ArrayList<>();\n        for (TagFileXml tagFileXml : taglibXml.getTagFiles()) {\n            tagFileInfos.add(createTagFileInfo(tagFileXml, jar));\n        }\n\n        Set<String> names = new HashSet<>();\n        List<FunctionInfo> functionInfos = taglibXml.getFunctions();\n        // TODO Move this validation to the parsing stage\n        for (FunctionInfo functionInfo : functionInfos) {\n            String name = functionInfo.getName();\n            if (!names.add(name)) {\n                err.jspError(\"jsp.error.tld.fn.duplicate.name\", name, uri);\n            }\n        }\n\n        if (tlibversion == null) {\n            err.jspError(\"jsp.error.tld.mandatory.element.missing\", \"tlib-version\", uri);\n        }\n        if (jspversion == null) {\n            err.jspError(\"jsp.error.tld.mandatory.element.missing\", \"jsp-version\", uri);\n        }\n\n        this.tags = tagInfos.toArray(new TagInfo[tagInfos.size()]);\n        this.tagFiles = tagFileInfos.toArray(new TagFileInfo[tagFileInfos.size()]);\n        this.functions = functionInfos.toArray(new FunctionInfo[functionInfos.size()]);\n    }","id":71119,"modified_method":"/**\n     * Constructor.\n     */\n    public TagLibraryInfoImpl(JspCompilationContext ctxt, ParserController pc,\n            PageInfo pi, String prefix, String uriIn,\n            TldResourcePath tldResourcePath, ErrorDispatcher err)\n            throws JasperException {\n        super(prefix, uriIn);\n\n        this.ctxt = ctxt;\n        this.parserController = pc;\n        this.pi = pi;\n        this.err = err;\n\n        if (tldResourcePath == null) {\n            // The URI points to the TLD itself or to a JAR file in which the TLD is stored\n            tldResourcePath = generateTldResourcePath(uri, ctxt);\n        }\n\n        Jar jar;\n        try {\n            jar = tldResourcePath.getJar();\n        } catch (IOException ioe) {\n            throw new JasperException(ioe);\n        }\n\n        // Add the dependencies on the TLD to the referencing page\n        PageInfo pageInfo = ctxt.createCompiler().getPageInfo();\n        if (pageInfo != null) {\n            // If the TLD is in a JAR, that JAR may not be part of the web\n            // application\n            String path = tldResourcePath.getWebappPath();\n            if (path != null) {\n                // Add TLD (jar==null) / JAR (jar!=null) file to dependency list\n                pageInfo.addDependant(path, ctxt.getLastModified(path));\n            }\n            if (jar != null) {\n                if (path == null) {\n                    // JAR not in the web application so add it directly\n                    URL jarUrl = jar.getJarFileURL();\n                    long lastMod = -1;\n                    URLConnection urlConn = null;\n                    try {\n                        urlConn = jarUrl.openConnection();\n                        lastMod = urlConn.getLastModified();\n                    } catch (IOException ioe) {\n                        throw new JasperException(ioe);\n                    } finally {\n                        if (urlConn != null) {\n                            try {\n                                urlConn.getInputStream().close();\n                            } catch (IOException e) {\n                                // Ignore\n                            }\n                        }\n                    }\n                    pageInfo.addDependant(jarUrl.toExternalForm(),\n                            Long.valueOf(lastMod));\n                }\n                // Add TLD within the JAR to the dependency list\n                String entryName = tldResourcePath.getEntryName();\n                try {\n                    pageInfo.addDependant(jar.getURL(entryName),\n                            Long.valueOf(jar.getLastModified(entryName)));\n                } catch (IOException ioe) {\n                    throw new JasperException(ioe);\n                }\n            }\n        }\n\n        // Get the representation of the TLD\n        TaglibXml taglibXml =\n                ctxt.getOptions().getTldCache().getTaglibXml(tldResourcePath);\n\n        // Populate the TagLibraryInfo attributes\n        this.jspversion = taglibXml.getJspVersion();\n        this.tlibversion = taglibXml.getTlibVersion();\n        this.shortname = taglibXml.getShortName();\n        this.urn = taglibXml.getUri();\n        this.info = taglibXml.getInfo();\n\n        this.tagLibraryValidator = createValidator(taglibXml.getValidator());\n\n        List<TagInfo> tagInfos = new ArrayList<>();\n        for (TagXml tagXml : taglibXml.getTags()) {\n            tagInfos.add(createTagInfo(tagXml));\n        }\n\n        List<TagFileInfo> tagFileInfos = new ArrayList<>();\n        for (TagFileXml tagFileXml : taglibXml.getTagFiles()) {\n            tagFileInfos.add(createTagFileInfo(tagFileXml, jar));\n        }\n\n        Set<String> names = new HashSet<>();\n        List<FunctionInfo> functionInfos = taglibXml.getFunctions();\n        // TODO Move this validation to the parsing stage\n        for (FunctionInfo functionInfo : functionInfos) {\n            String name = functionInfo.getName();\n            if (!names.add(name)) {\n                err.jspError(\"jsp.error.tld.fn.duplicate.name\", name, uri);\n            }\n        }\n\n        if (tlibversion == null) {\n            err.jspError(\"jsp.error.tld.mandatory.element.missing\", \"tlib-version\", uri);\n        }\n        if (jspversion == null) {\n            err.jspError(\"jsp.error.tld.mandatory.element.missing\", \"jsp-version\", uri);\n        }\n\n        this.tags = tagInfos.toArray(new TagInfo[tagInfos.size()]);\n        this.tagFiles = tagFileInfos.toArray(new TagFileInfo[tagFileInfos.size()]);\n        this.functions = functionInfos.toArray(new FunctionInfo[functionInfos.size()]);\n    }","commit_id":"10e348ea24440910c9e695b231250824e1b6faf5","url":"https://github.com/apache/tomcat"},{"original_method":"@Override\n        public void visit(Node.CustomTag n) throws JasperException {\n            TagFileInfo tagFileInfo = n.getTagFileInfo();\n            if (tagFileInfo != null) {\n                String tagFilePath = tagFileInfo.getPath();\n                if (tagFilePath.startsWith(\"/META-INF/\")) {\n                    // For tags in JARs, add the TLD and the tag as a dependency\n                    TldLocation location =\n                        compiler.getCompilationContext().getTldLocation(\n                            tagFileInfo.getTagInfo().getTagLibrary().getURI());\n                    JarResource jarResource = location.getJarResource();\n                    // Add TLD\n                    pageInfo.addDependant(jarResource.getEntry(location.getName()).toString());\n                    // Add Tag\n                    pageInfo.addDependant(jarResource.getEntry(tagFilePath.substring(1)).toString());\n                } else {\n                    pageInfo.addDependant(tagFilePath);\n                }\n                Class<?> c = loadTagFile(compiler, tagFilePath, n.getTagInfo(),\n                        pageInfo);\n                n.setTagHandlerClass(c);\n            }\n            visitBody(n);\n        }","id":71120,"modified_method":"@Override\n        public void visit(Node.CustomTag n) throws JasperException {\n            TagFileInfo tagFileInfo = n.getTagFileInfo();\n            if (tagFileInfo != null) {\n                String tagFilePath = tagFileInfo.getPath();\n                if (tagFilePath.startsWith(\"/META-INF/\")) {\n                    // For tags in JARs, add the TLD and the tag as a dependency\n                    TldLocation location =\n                        compiler.getCompilationContext().getTldLocation(\n                            tagFileInfo.getTagInfo().getTagLibrary().getURI());\n                    JarResource jarResource = location.getJarResource();\n                    if (jarResource != null) {\n                        // Add TLD\n                        pageInfo.addDependant(jarResource.getEntry(location.getName()).toString());\n                        // Add Tag\n                        pageInfo.addDependant(jarResource.getEntry(tagFilePath.substring(1)).toString());\n                    }\n                    else {\n                        pageInfo.addDependant(tagFilePath);\n                    }\n                } else {\n                    pageInfo.addDependant(tagFilePath);\n                }\n                Class<?> c = loadTagFile(compiler, tagFilePath, n.getTagInfo(),\n                        pageInfo);\n                n.setTagHandlerClass(c);\n            }\n            visitBody(n);\n        }","commit_id":"af4549f8eabc30f0e9eb1be7fb2b1fe58444a3fd","url":"https://github.com/apache/tomcat"},{"original_method":"public Object resolveVariable(String name) throws XelException {\r\n\t\tthrow new UnsupportedOperationException(\"Use resolveVariable(XelContext,Object,Object) instead\");\r\n\t}","id":71121,"modified_method":"public Object resolveVariable(String name) throws XelException {\r\n\t\treturn resolveVariable(null, null, name);\r\n\t}","commit_id":"697217de8d9010694180a92ced6a553f1821005b","url":"https://github.com/zkoss/zk"},{"original_method":"public Object resolveVariable(String name) {\n\t\t\tif (custom != null) {\n\t\t\t\tfinal Object o = custom.resolveVariable(name);\n\t\t\t\tif (o != null)\n\t\t\t\t\treturn o;\n\t\t\t}\n\t\t\treturn getSegmentedLabels().get(name);\n\t\t}","id":71122,"modified_method":"public Object resolveVariable(String name) {\n\t\t\tif (custom != null) {\n\t\t\t\tfinal Object o = custom instanceof VariableResolverX ?\n\t\t\t\t\t((VariableResolverX)custom).resolveVariable(null, null, name):\n\t\t\t\t\tcustom.resolveVariable(name);\n\t\t\t\tif (o != null)\n\t\t\t\t\treturn o;\n\t\t\t}\n\t\t\treturn getSegmentedLabels().get(name);\n\t\t}","commit_id":"697217de8d9010694180a92ced6a553f1821005b","url":"https://github.com/zkoss/zk"},{"original_method":"public Object resolveVariable(String name) throws XelException {\n\t\tfinal Object o = Labels.getLabel(name);\n\t\tif (o != null)\n\t\t\treturn o;\n\n\t\tfinal RequestContext jc = RequestContexts.getCurrent();\n\t\tif (jc != null) {\n\t\t\tfinal VariableResolver parent = jc.getVariableResolver();\n\t\t\tif (parent != null)\n\t\t\t\treturn parent.resolveVariable(name);\n\t\t}\n\t\treturn null;\n\t}","id":71123,"modified_method":"public Object resolveVariable(String name) throws XelException {\n\t\tfinal Object o = Labels.getLabel(name);\n\t\tif (o != null)\n\t\t\treturn o;\n\n\t\tfinal RequestContext jc = RequestContexts.getCurrent();\n\t\tif (jc != null) {\n\t\t\tfinal VariableResolver parent = jc.getVariableResolver();\n\t\t\tif (parent != null)\n\t\t\t\treturn parent instanceof VariableResolverX ?\n\t\t\t\t\t((VariableResolverX)parent).resolveVariable(null, null, name):\n\t\t\t\t\tparent.resolveVariable(name);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"697217de8d9010694180a92ced6a553f1821005b","url":"https://github.com/zkoss/zk"},{"original_method":"public Object resolveVariable(String name) throws XelException {\n\t\tfinal RequestContext jc = RequestContexts.getCurrent();\n\t\tif (jc != null) {\n\t\t\tfinal VariableResolver parent = jc.getVariableResolver();\n\t\t\tif (parent != null)\n\t\t\t\treturn parent.resolveVariable(name);\n\t\t}\n\t\treturn null;\n\t}","id":71124,"modified_method":"public Object resolveVariable(String name) throws XelException {\n\t\tfinal RequestContext jc = RequestContexts.getCurrent();\n\t\tif (jc != null) {\n\t\t\tfinal VariableResolver parent = jc.getVariableResolver();\n\t\t\tif (parent != null)\n\t\t\t\treturn parent instanceof VariableResolverX ?\n\t\t\t\t\t((VariableResolverX)parent).resolveVariable(null, null, name):\n\t\t\t\t\tparent.resolveVariable(name);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"697217de8d9010694180a92ced6a553f1821005b","url":"https://github.com/zkoss/zk"},{"original_method":"public Object resolveVariable(String name) throws XelException {\n\t\tif (_vars != null) {\n\t\t\tfinal Object o = _vars.get(name);\n\t\t\tif (o != null)\n\t\t\t\treturn o;\n\t\t}\n\t\treturn _parent != null ? _parent.resolveVariable(name): null;\n\t}","id":71125,"modified_method":"public Object resolveVariable(String name) throws XelException {\n\t\tif (_vars != null) {\n\t\t\tfinal Object o = _vars.get(name);\n\t\t\tif (o != null)\n\t\t\t\treturn o;\n\t\t}\n\t\treturn _parent instanceof VariableResolverX ?\n\t\t\t((VariableResolverX)_parent).resolveVariable(null, null, name):\n\t\t\t_parent != null ? _parent.resolveVariable(name): null;\n\t}","commit_id":"697217de8d9010694180a92ced6a553f1821005b","url":"https://github.com/zkoss/zk"},{"original_method":"public ServletLabelResovler() {\n\t\tfinal ELContext jc = ELContexts.getCurrent();\n\t\t_parent = jc != null ? jc.getVariableResolver(): null;\n\t}","id":71126,"modified_method":"public ServletLabelResovler() {\n\t}","commit_id":"44132cb6643895fed97f76fd28f744389ea78ad1","url":"https://github.com/zkoss/zk"},{"original_method":"public Object resolveVariable(String name) throws ELException {\n\t\tfinal Object o = Labels.getLabel(name);\n\t\treturn o != null ? o:\n\t\t\t_parent != null ? _parent.resolveVariable(name): null;\n\t}","id":71127,"modified_method":"public Object resolveVariable(String name) throws ELException {\n\t\tfinal Object o = Labels.getLabel(name);\n\t\tif (o != null)\n\t\t\treturn o;\n\n\t\tfinal ELContext jc = ELContexts.getCurrent();\n\t\tif (jc != null) {\n\t\t\tfinal VariableResolver parent = jc.getVariableResolver();\n\t\t\tif (parent != null)\n\t\t\t\treturn parent.resolveVariable(name);\n\t\t}\n\t\treturn null;\n\t}","commit_id":"44132cb6643895fed97f76fd28f744389ea78ad1","url":"https://github.com/zkoss/zk"},{"original_method":"public static DRF start(Key dest, final Frame fr, final int maxDepth, final int ntrees, final int mtrys) {\n    final DRF job = new DRF(dest, fr);\n    H2O.submitTask(job.start(new H2OCountedCompleter() {\n        @Override public void compute2() { job.run(fr,maxDepth,ntrees,mtrys); tryComplete(); }\n      })); \n    return job;\n  }","id":71128,"modified_method":"public static DRF start(Key dest, final Frame fr, final int maxDepth, final int ntrees, final int mtrys, final double sampleRate) {\n    final DRF job = new DRF(dest, fr);\n    H2O.submitTask(job.start(new H2OCountedCompleter() {\n        @Override public void compute2() { job.run(fr,maxDepth,ntrees,mtrys,sampleRate); tryComplete(); }\n      })); \n    return job;\n  }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void run(Frame fr, int maxDepth, int ntrees, int mtrys) {\n    Timer t_drf = new Timer();\n    final String names[] = fr._names;\n    Vec vs[] = fr._vecs;\n    final int ncols = vs.length-1; // Last column is the response column\n\n    // Response column is the last one in the frame\n    Vec vresponse = vs[ncols];\n    final long nrows = vresponse.length();\n    int ymin = (int)vresponse.min();\n    int numClasses = vresponse._isInt ? ((int)vresponse.max()-ymin+1) : 0;\n    //if( numClasses == 2 ) numClasses = 0; // Specifically force 2 classes into a regression\n\n    // The RNG used to pick split columns\n    Random rand = new MersenneTwisterRNG(new int[]{1,2});\n\n    // Initially setup as-if an empty-split had just happened\n    Histogram hs[] = Histogram.initialHist(fr,ncols);\n    DRFTree trees[] = new DRFTree[ntrees];\n    for( int t=0; t<ntrees; t++ ) {\n      trees[t] = new DRFTree(names,mtrys,rand);\n      new UndecidedNode(trees[t],-1,hs); // The \"root\" node \n      // Make a new Vec to hold the split-number for each row (initially all zero).\n      fr.add(\"NIDs\"+t,Vec.makeZero(vs[0]));\n    }\n    int leafs[] = new int[ntrees]; // Define a \"working set\" of leaf splits, from here to tree._len\n\n    // ----\n    // One Big Loop till the tree is of proper depth.\n    // Adds a layer to the tree each pass.\n    int depth=0;\n    for( ; depth<maxDepth; depth++ ) {\n\n      // Fuse 2 conceptual passes into one:\n      // Pass 1: Score a prior Histogram, and make new DTree.Node assignments\n      // to every row.  This involves pulling out the current assigned Node,\n      // \"scoring\" the row against that Node's decision criteria, and assigning\n      // the row to a new child Node (and giving it an improved prediction).\n      // Pass 2: Build new summary Histograms on the new child Nodes every row\n      // got assigned into.  Collect counts, mean, variance, min, max per bin,\n      // per column.\n      ScoreBuildHistogram sbh = new ScoreBuildHistogram(trees,leafs,ncols,numClasses,ymin).doAll(fr);\n\n      // Reassign the new Histograms back into the DTrees\n      for( int t=0; t<ntrees; t++ ) {\n        final int tmax = trees[t]._len; // Number of total splits\n        final DTree tree = trees[t];\n        for( int i=leafs[t]; i<tmax; i++ )\n          tree.undecided(i)._hs = sbh.getFinalHisto(t,i);\n      }\n\n      // Build up the next-generation tree splits from the current histograms.\n      // Nearly all leaves will split one more level.  This loop nest is\n      //           O( #active_splits * #bins * #ncols )\n      // but is NOT over all the data.\n      boolean still_splitting=false;\n      for( int t=0; t<ntrees; t++ ) {\n        final DTree tree = trees[t];\n        final int tmax = tree._len; // Number of total splits\n        int leaf = leafs[t];\n        for( ; leaf<tmax; leaf++ ) {\n          //System.out.println(\"Tree#\"+t+\", \"+tree.undecided(leaf));\n          // Replace the Undecided with the Split decision\n          new DRFDecidedNode(tree.undecided(leaf));\n        }\n        leafs[t] = leaf;\n        // If we did not make any new splits, then the tree is split-to-death\n        if( tmax < tree._len ) still_splitting = true;\n      }\n\n      // If all trees are done, then so are we\n      if( !still_splitting ) break;\n\n      new BulkScore(trees,ncols,numClasses,ymin).doAll(fr).report( Sys.DRF__, nrows, depth );\n    }\n    Log.info(Sys.DRF__,\"DRF done in \"+t_drf);\n\n    // One more pass for final prediction error\n    Timer t_score = new Timer();\n    new BulkScore(trees,ncols,numClasses,ymin).doAll(fr).report( Sys.DRF__, nrows, depth );\n    Log.info(Sys.DRF__,\"DRF score done in \"+t_score);\n\n    // Remove temp vectors; cleanup the Frame\n    while( fr.numCols() > ncols+1 )\n      UKV.remove(fr.remove(fr.numCols()-1)._key);\n  }","id":71129,"modified_method":"private void run(Frame fr, int maxDepth, int ntrees, int mtrys, double sampleRate ) {\n    Timer t_drf = new Timer();\n    assert 0 <= ntrees && ntrees < 1000000;\n    assert 0 <= mtrys && mtrys < fr.numCols();\n    assert 0.0 <= sampleRate && sampleRate <= 1.0;\n\n    final String names[] = fr._names;\n    Vec vs[] = fr._vecs;\n    final int ncols = vs.length-1; // Last column is the response column\n\n    // Response column is the last one in the frame\n    Vec vresponse = vs[ncols];\n    final long nrows = vresponse.length();\n    int ymin = (int)vresponse.min();\n    int numClasses = vresponse._isInt ? ((int)vresponse.max()-ymin+1) : 0;\n    //if( numClasses == 2 ) numClasses = 0; // Specifically force 2 classes into a regression\n\n    // The RNG used to pick split columns\n    Random rand = new MersenneTwisterRNG(new int[]{1,2});\n\n    // Initially setup as-if an empty-split had just happened\n    Histogram hs[] = Histogram.initialHist(fr,ncols);\n    DRFTree trees[] = new DRFTree[ntrees];\n    Vec[] nids = new Vec[ntrees];\n\n    // ----\n    // Only work on so many trees at once, else get GC issues.\n    // Hand the inner loop a smaller set of trees.\n    final int NTREE=5;          // Limit of 5 trees at once\n    int depth=0;\n    for( int st = 0; st < ntrees; st+= NTREE ) {\n      int xtrees = Math.min(NTREE,ntrees-st);\n      DRFTree someTrees[] = new DRFTree[xtrees];\n      int someLeafs[] = new int[xtrees];\n\n      for( int t=0; t<xtrees; t++ ) {\n        int idx = st+t;\n        // Make a new Vec to hold the split-number for each row (initially all zero).\n        Vec vec = Vec.makeZero(vs[0]);\n        nids[idx] = vec;\n        trees[idx] = someTrees[t] = new DRFTree(fr,ncols,hs,mtrys,rand.nextLong());\n        if( sampleRate < 1.0 )\n          new Sample(someTrees[t],sampleRate).doAll(vec);\n        fr.add(\"NIDs\"+t,vec);\n      }\n\n      // Make NTREE trees at once\n      int d = makeSomeTrees(someTrees,someLeafs, xtrees, maxDepth, fr, ncols, numClasses, ymin, nrows, sampleRate);\n      if( d>depth ) depth=d;    // Actual max depth used\n\n      // Remove temp vectors; cleanup the Frame\n      while( fr.numCols() > ncols+1 )\n        fr.remove(fr.numCols()-1);\n    }\n    Log.info(Sys.DRF__,\"DRF done in \"+t_drf);\n\n    // One more pass for final prediction error\n    Timer t_score = new Timer();\n    for( int t=0; t<ntrees; t++ ) fr.add(\"NIDs\"+t,nids[t]);\n    new BulkScore(trees,ncols,numClasses,ymin,sampleRate).doAll(fr).report( Sys.DRF__, nrows, depth );\n\n    while( fr.numCols() > ncols+1 )\n      UKV.remove(fr.remove(fr.numCols()-1)._key);\n  }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"DecidedNode( UndecidedNode n ) {\n      super(n._tree,n._pid,n._nid); // Replace Undecided with this DecidedNode\n      _col = bestCol(n._hs);        // Best split-point for this tree\n      // From the splitting Undecided, get the column, min, max\n      Histogram splitH = n._hs[_col];// Histogram of the column being split\n      int nums = splitH._nbins;      // Number of split choices\n      long clss[][] = splitH._clss;  // Class histogram\n      assert nums > 1;          // Should always be some bins to split between\n      _min  = splitH._min ;     // Binning info\n      _step = splitH._step;\n      assert _step > 0;\n      _mins = splitH._mins;     // Hang onto for printing purposes\n      _maxs = splitH._maxs;     // Hang onto for printing purposes\n      _ns = new int[nums];\n      _ycls = (clss==null) ? new long[nums][] : clss;\n      _pred = new double[nums];\n      int ncols = _tree._names.length-1; // ncols: all columns, minus response\n      for( int i=0; i<nums; i++ ) { // For all split-points\n        // Setup for children splits\n        Histogram nhists[] = splitH.split(_col,i,n._hs,_tree._names,ncols);\n        _ns[i] = nhists == null ? -1 : new UndecidedNode(_tree,_nid,nhists)._nid;\n        // Also setup predictions locally\n        if( clss == null ) {                      // Regression?\n          _ycls[i] = new long[]{splitH._bins[i]}; // Number of entries in bin\n          _pred[i] = splitH. mean(i);             // Prediction is mean of bin\n        }\n      }\n    }","id":71130,"modified_method":"DecidedNode( UndecidedNode n ) {\n      super(n._tree,n._pid,n._nid); // Replace Undecided with this DecidedNode\n      _col = bestCol(n._hs);        // Best split-point for this tree\n      // From the splitting Undecided, get the column, min, max\n      Histogram splitH = n._hs[_col];// Histogram of the column being split\n      int nums = splitH._nbins;      // Number of split choices\n      long clss[][] = splitH._clss;  // Class histogram\n      assert nums > 1;          // Should always be some bins to split between\n      _min  = splitH._min ;     // Binning info\n      _step = splitH._step;\n      assert _step > 0;\n      _mins = splitH._mins;     // Hang onto for printing purposes\n      _maxs = splitH._maxs;     // Hang onto for printing purposes\n      _ns = new int[nums];\n      _ycls = (clss==null) ? new long[nums][] : clss;\n      _pred = new double[nums];\n      int ncols = _tree._ncols; // ncols: all columns, minus response\n      for( int i=0; i<nums; i++ ) { // For all split-points\n        // Setup for children splits\n        Histogram nhists[] = splitH.split(_col,i,n._hs,_tree._names,ncols);\n        _ns[i] = nhists == null ? -1 : new UndecidedNode(_tree,_nid,nhists)._nid;\n        // Also setup predictions locally\n        if( clss == null ) {                      // Regression?\n          _ycls[i] = new long[]{splitH._bins[i]}; // Number of entries in bin\n          _pred[i] = splitH. mean(i);             // Prediction is mean of bin\n        }\n      }\n    }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"BulkScore( DTree trees[], int ncols, int numClasses, int ymin ) { _trees = trees; _ncols = ncols; _numClasses = numClasses; _ymin = ymin; }","id":71131,"modified_method":"BulkScore( DTree trees[], int ncols, int numClasses, int ymin, double sampleRate ) { \n      _trees = trees; _ncols = ncols; \n      _numClasses = numClasses; _ymin = ymin; \n      _rate = (float)sampleRate;\n    }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"DTree( String[] names ) { _names = names; _ns = new Node[1]; }","id":71132,"modified_method":"DTree( String[] names, int ncols ) { _names = names; _ncols = ncols; _ns = new Node[1]; }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private double score0( Chunk chks[], int i, double y, long clss[] ) {\n      double sum=0;             // Regression: average across trees\n      long rows=0;\n      if( _numClasses > 0 )     // Classification: zero class distribution\n        Arrays.fill(clss,0);\n      // For all trees\n      for( int t=0; t<_trees.length; t++ ) {\n        final DTree tree = _trees[t];\n        // \"score\" this row on this tree.  Apply the tree decisions at each\n        // point, walking down the tree to a leaf.\n        DecidedNode prev = null;\n        Node node = tree.root();\n        while( node instanceof DecidedNode ) { // While tree-walking\n          prev = (DecidedNode)node;\n          int nid = prev.ns(chks,i);\n          if( nid == -1 ) break;\n          node = tree.node(nid);\n        }\n        // We hit the end of the tree walk.  Get this tree's prediction\n        int bin = prev.bin(chks,i);    // Which bin did we decide on?\n        long[] ycls = prev._ycls[bin]; // Classes for that bin\n        if( _numClasses == 0 ) {       // Regression?\n          long num = ycls[0];          // \"classes\" is really just bin-count\n          rows += num;                 // More total rows\n          sum  += prev._pred[bin]*num; // More total regression count\n        } else {                // Classification?\n          for( int c=0; c<_numClasses; c++ )\n            clss[c] += ycls[c]; // Compute distribution\n        }\n      }\n\n      if( _numClasses == 0 ) {\n        double prediction = sum/rows; // Average of trees is prediction\n        return prediction - y;        // Error\n      } else {\n        rows += clss[0];        // Find total rows\n        int best=0;             // Find largest class across all trees\n        for( int c=1; c<_numClasses; c++ ) {\n          rows += clss[c];\n          if( clss[c] > clss[best] ) best=c;\n        }\n        int ycls = (int)y-_ymin;   // Zero-based response class\n        if( best != ycls ) _err++; // Absolute prediction error\n        return (double)(rows-clss[best])/rows; // Error\n      }\n    }","id":71133,"modified_method":"private double score0( Chunk chks[], int i, double y, long clss[], Random rands[] ) {\n      double sum=0;             // Regression: average across trees\n      long rows=0;\n      if( _numClasses > 0 )     // Classification: zero class distribution\n        Arrays.fill(clss,0);\n      // For all trees\n      for( int t=0; t<_trees.length; t++ ) {\n        // For OOBEE error, do not score rows on trees trained on that row\n        if( rands != null && !(rands[t].nextFloat() >= _rate) ) continue;\n\n        final DTree tree = _trees[t];\n        // \"score\" this row on this tree.  Apply the tree decisions at each\n        // point, walking down the tree to a leaf.\n        DecidedNode prev = null;\n        Node node = tree.root();\n        while( node instanceof DecidedNode ) { // While tree-walking\n          prev = (DecidedNode)node;\n          int nid = prev.ns(chks,i);\n          if( nid == -1 ) break;\n          node = tree.node(nid);\n        }\n        // We hit the end of the tree walk.  Get this tree's prediction\n        int bin = prev.bin(chks,i);    // Which bin did we decide on?\n        long[] ycls = prev._ycls[bin]; // Classes for that bin\n        if( _numClasses == 0 ) {       // Regression?\n          long num = ycls[0];          // \"classes\" is really just bin-count\n          rows += num;                 // More total rows\n          sum  += prev._pred[bin]*num; // More total regression count\n        } else {                // Classification?\n          for( int c=0; c<_numClasses; c++ )\n            clss[c] += ycls[c]; // Compute distribution\n        }\n      }\n\n      if( _numClasses == 0 ) {\n        if( rows == 0 ) return 0;     // OOBEE: all rows trained, so no rows scored\n        double prediction = sum/rows; // Average of trees is prediction\n        return prediction - y;        // Error\n      } else {\n        rows += clss[0];        // Find total rows\n        int best=0;             // Find largest class across all trees\n        for( int c=1; c<_numClasses; c++ ) {\n          rows += clss[c];\n          if( clss[c] > clss[best] ) best=c;\n        }\n        if( rows == 0 ) return 0;  // OOBEE: all rows trained, so no rows scored\n        int ycls = (int)y-_ymin;   // Zero-based response class\n        if( best != ycls ) _err++; // Absolute prediction error\n        return (double)(rows-clss[ycls])/rows; // Error\n      }\n    }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public int bin( Chunk chks[], int i ) {\n      double d = chks[_col].at0(i);         // Value to split on for this row\n      int idx1 = (int)((d-_min)/_step);     // Interpolate bin#\n      assert idx1 >= 0;                     // Expect sanity\n      int bin = Math.min(idx1,_ns.length-1);// Cap at length\n      return bin;\n    }","id":71134,"modified_method":"public int bin( Chunk chks[], int i ) {\n      double d = chks[_col].at0(i);         // Value to split on for this row\n      // Note that during *scoring* (as opposed to training), we can be exposed\n      // to data which is outside the bin limits, so we must cap at both ends.\n      int idx1 = (int)((d-_min)/_step);     // Interpolate bin#\n      int bin = Math.max(Math.min(idx1,_ns.length-1),0);// Cap at length\n      return bin;\n    }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public String toString() {\n      throw H2O.unimpl();\n    }","id":71135,"modified_method":"@Override public String toString() {\n      String n= \" <= \"+_tree._names[_col]+\" <= \";\n      String s = new String();\n      for( int i=0; i<_ns.length; i++ ) \n        s += _mins[i]+n+_maxs[i]+\" = \"+Arrays.toString(_ycls[i])+\"\\n\";\n      return s;\n    }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override public void map( Chunk chks[] ) {\n      assert _ncols+1/*response variable*/+_trees.length == chks.length \n        : \"Missing columns?  ncols=\"+_ncols+\", 1 for response, ntrees=\"+_trees.length+\", and found \"+chks.length+\" vecs\";\n      Chunk ys = chks[_ncols];\n      long clss[] = new long[_numClasses]; // Shared array for computing classes\n      for( int i=0; i<ys._len; i++ ) {\n        double err = score0( chks, i, ys.at0(i), clss );\n        _sum += err*err;        // Squared error\n      }\n    }","id":71136,"modified_method":"@Override public void map( Chunk chks[] ) {\n      assert _ncols+1/*response variable*/+_trees.length == chks.length \n        : \"Missing columns?  ncols=\"+_ncols+\", 1 for response, ntrees=\"+_trees.length+\", and found \"+chks.length+\" vecs\";\n      Chunk ys = chks[_ncols];\n      long clss[] = new long[_numClasses]; // Shared array for computing classes\n\n      // Get an array of RNGs to replay the sampling in reverse, only for OOBEE.\n      // Note the fairly expense MerseenTwisterRNG built per-tree (per-chunk).\n      Random rands[] = null;\n      if( _rate < 1.0f ) {      // oobee vs full scoring?\n        rands = new Random[_trees.length];\n        for( int t=0; t<_trees.length; t++ )\n          rands[t] = _trees[t].rngForChunk(ys.cidx());\n      }\n\n      // Score all Rows\n      for( int i=0; i<ys._len; i++ ) {\n        double err = score0( chks, i, ys.at0(i), clss, rands );\n        _sum += err*err;        // Squared error\n      }\n    }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"private void run(Frame fr, int maxDepth) {\n    Timer t_gbm = new Timer();\n    final String names[] = fr._names;\n    Vec vs[] = fr._vecs;\n    final int ncols = vs.length-1; // Last column is the response column\n\n    // Response column is the last one in the frame\n    Vec vresponse = vs[ncols];\n    final long nrows = vresponse.length();\n    int ymin = (int)vresponse.min();\n    int numClasses = vresponse._isInt ? ((int)vresponse.max()-ymin+1) : 0;\n    //if( numClasses == 2 ) numClasses = 0; // Specifically force 2 classes into a regression\n\n    // Make a new Vec to hold the split-number for each row (initially all zero).\n    Vec vnids = Vec.makeZero(vs[0]);\n    fr.add(\"NIDs\",vnids);\n\n    // Initially setup as-if an empty-split had just happened\n    DTree tree = new DTree(names);\n    new UndecidedNode(tree,-1,Histogram.initialHist(fr,ncols)); // The \"root\" node\n    int leaf = 0; // Define a \"working set\" of leaf splits, from here to tree._len\n\n    // ----\n    // One Big Loop till the tree is of proper depth.\n    // Adds a layer to the tree each pass.\n    int depth=0;\n    for( ; depth<maxDepth; depth++ ) {\n\n      // Fuse 2 conceptual passes into one:\n      // Pass 1: Score a prior Histogram, and make new DTree.Node assignments to\n      // every row.  This involves pulling out the current assigned Node,\n      // \"scoring\" the row against that Node's decision criteria, and assigning\n      // the row to a new child Node (and giving it an improved prediction).\n      // Pass 2: Build new summary Histograms on the new child Nodes every row\n      // got assigned into.  Collect counts, mean, variance, min, max per bin,\n      // per column.\n      ScoreBuildHistogram sbh = new ScoreBuildHistogram(new DTree[]{tree},new int[]{leaf},ncols,numClasses,ymin).doAll(fr);\n\n      // Reassign the new Histogram back into the DTree\n      final int tmax = tree._len; // Number of total splits\n      for( int i=leaf; i<tmax; i++ )\n        tree.undecided(i)._hs = sbh.getFinalHisto(0,i);\n\n      // Build up the next-generation tree splits from the current histograms.\n      // Nearly all leaves will split one more level.  This loop nest is\n      //           O( #active_splits * #bins * #ncols )\n      // but is NOT over all the data.\n      for( ; leaf<tmax; leaf++ ) {\n        //System.out.println(tree.undecided(leaf));\n        // Replace the Undecided with the Split decision\n        new GBMDecidedNode(tree.undecided(leaf));\n      }\n\n      // If we did not make any new splits, then the tree is split-to-death\n      if( tmax == tree._len ) break;\n\n      //new BulkScore(new DTree[]{tree},numClasses,ymin).doAll(fr).report( nrows, depth );\n    }\n    Log.info(Sys.GBM__,\"GBM done in \"+t_gbm);\n\n    // One more pass for final prediction error\n    Timer t_score = new Timer();\n    new BulkScore(new DTree[]{tree},ncols,numClasses,ymin).doAll(fr).report( Sys.GBM__, nrows, depth );\n    Log.info(Sys.GBM__,\"GBM score done in \"+t_score);\n\n    // Remove temp vector; cleanup the Frame\n    UKV.remove(fr.remove(\"NIDs\")._key);\n  }","id":71137,"modified_method":"private void run(Frame fr, int maxDepth) {\n    Timer t_gbm = new Timer();\n    final String names[] = fr._names;\n    Vec vs[] = fr._vecs;\n    final int ncols = vs.length-1; // Last column is the response column\n\n    // Response column is the last one in the frame\n    Vec vresponse = vs[ncols];\n    final long nrows = vresponse.length();\n    int ymin = (int)vresponse.min();\n    int numClasses = vresponse._isInt ? ((int)vresponse.max()-ymin+1) : 0;\n    //if( numClasses == 2 ) numClasses = 0; // Specifically force 2 classes into a regression\n\n    // Make a new Vec to hold the split-number for each row (initially all zero).\n    Vec vnids = Vec.makeZero(vs[0]);\n    fr.add(\"NIDs\",vnids);\n\n    // Initially setup as-if an empty-split had just happened\n    DTree tree = new DTree(names,ncols);\n    new UndecidedNode(tree,-1,Histogram.initialHist(fr,ncols)); // The \"root\" node\n    int leaf = 0; // Define a \"working set\" of leaf splits, from here to tree._len\n\n    // ----\n    // One Big Loop till the tree is of proper depth.\n    // Adds a layer to the tree each pass.\n    int depth=0;\n    for( ; depth<maxDepth; depth++ ) {\n\n      // Fuse 2 conceptual passes into one:\n      // Pass 1: Score a prior Histogram, and make new DTree.Node assignments to\n      // every row.  This involves pulling out the current assigned Node,\n      // \"scoring\" the row against that Node's decision criteria, and assigning\n      // the row to a new child Node (and giving it an improved prediction).\n      // Pass 2: Build new summary Histograms on the new child Nodes every row\n      // got assigned into.  Collect counts, mean, variance, min, max per bin,\n      // per column.\n      ScoreBuildHistogram sbh = new ScoreBuildHistogram(new DTree[]{tree},new int[]{leaf},ncols,numClasses,ymin).doAll(fr);\n\n      // Reassign the new Histogram back into the DTree\n      final int tmax = tree._len; // Number of total splits\n      for( int i=leaf; i<tmax; i++ )\n        tree.undecided(i)._hs = sbh.getFinalHisto(0,i);\n\n      // Build up the next-generation tree splits from the current histograms.\n      // Nearly all leaves will split one more level.  This loop nest is\n      //           O( #active_splits * #bins * #ncols )\n      // but is NOT over all the data.\n      for( ; leaf<tmax; leaf++ ) {\n        //System.out.println(tree.undecided(leaf));\n        // Replace the Undecided with the Split decision\n        new GBMDecidedNode(tree.undecided(leaf));\n      }\n\n      // If we did not make any new splits, then the tree is split-to-death\n      if( tmax == tree._len ) break;\n\n      //new BulkScore(new DTree[]{tree},numClasses,ymin).doAll(fr).report( nrows, depth );\n    }\n    Log.info(Sys.GBM__,\"GBM done in \"+t_gbm);\n\n    // One more pass for final prediction error\n    Timer t_score = new Timer();\n    new BulkScore(new DTree[]{tree},ncols,numClasses,ymin,1.0).doAll(fr).report( Sys.GBM__, nrows, depth );\n    Log.info(Sys.GBM__,\"GBM score done in \"+t_score);\n\n    // Remove temp vector; cleanup the Frame\n    UKV.remove(fr.remove(\"NIDs\")._key);\n  }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void testCovtypeDRF() {\n    File file = TestUtil.find_test_file(\"../datasets/UCI/UCI-large/covtype/covtype.data\");\n    if( file == null ) return;  // Silently abort test if the large covtype is missing\n    Key fkey = NFSFileVec.make(file);\n    Key dest = Key.make(\"cov1.hex\");\n    Frame fr = ParseDataset2.parse(dest,new Key[]{fkey});\n    UKV.remove(fkey);\n    System.out.println(\"Parsed into \"+fr);\n    for( int i=0; i<fr._vecs.length; i++ )\n      System.out.println(\"Vec \"+i+\" = \"+fr._vecs[i]);\n\n    try {\n      assertEquals(581012,fr._vecs[0].length());\n\n      // Covtype: predict on last column\n      int mtrys = Math.max((int)Math.sqrt(fr.numCols()),1);\n\n      DRF drf = DRF.start(DRF.makeKey(),fr,/*maxdepth*/40,/*ntrees*/10,mtrys);\n      drf.get();                  // Block for result\n      UKV.remove(drf._dest);\n    } finally {\n      UKV.remove(dest);\n    }\n  }","id":71138,"modified_method":"public void testCovtypeDRF() {\n    File file = TestUtil.find_test_file(\"../datasets/UCI/UCI-large/covtype/covtype.data\");\n    if( file == null ) return;  // Silently abort test if the large covtype is missing\n    Key fkey = NFSFileVec.make(file);\n    Key dest = Key.make(\"cov1.hex\");\n    Frame fr = ParseDataset2.parse(dest,new Key[]{fkey});\n    UKV.remove(fkey);\n    System.out.println(\"Parsed into \"+fr);\n    for( int i=0; i<fr._vecs.length; i++ )\n      System.out.println(\"Vec \"+i+\" = \"+fr._vecs[i]);\n\n    try {\n      assertEquals(581012,fr._vecs[0].length());\n\n      // Covtype: predict on last column\n      int mtrys = Math.max((int)Math.sqrt(fr.numCols()),1);\n\n      DRF drf = DRF.start(DRF.makeKey(),fr,/*maxdepth*/40,/*ntrees*/10,mtrys,/*sampleRate*/0.67);\n      drf.get();                  // Block for result\n      UKV.remove(drf._dest);\n    } finally {\n      UKV.remove(dest);\n    }\n  }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public void testBasicDRF() {\n    File file = TestUtil.find_test_file(\"./smalldata/logreg/prostate.csv\");\n    Key fkey = NFSFileVec.make(file);\n    Key dest = Key.make(\"prostate.hex\");\n    Frame fr = ParseDataset2.parse(dest,new Key[]{fkey});\n    UKV.remove(fkey);\n    try {\n      assertEquals(380,fr._vecs[0].length());\n\n      // Prostate: predict on CAPSULE which is in column #1; move it to last column\n      UKV.remove(fr.remove(\"ID\")._key);   // Remove patient ID vector\n      Vec capsule = fr.remove(\"CAPSULE\"); // Remove capsule\n      fr.add(\"CAPSULE\",capsule);          // Move it to the end\n      int mtrys = Math.max((int)Math.sqrt(fr.numCols()),1);\n\n      DRF drf = DRF.start(DRF.makeKey(),fr,/*maxdepth*/50,/*ntrees*/2,mtrys);\n      drf.get();                  // Block for result\n      UKV.remove(drf._dest);\n    } finally {\n      UKV.remove(dest);\n    }\n  }","id":71139,"modified_method":"public void testBasicDRF() {\n    File file = TestUtil.find_test_file(\"./smalldata/logreg/prostate.csv\");\n    Key fkey = NFSFileVec.make(file);\n    Key dest = Key.make(\"prostate.hex\");\n    Frame fr = ParseDataset2.parse(dest,new Key[]{fkey});\n    UKV.remove(fkey);\n    try {\n      assertEquals(380,fr._vecs[0].length());\n\n      // Prostate: predict on CAPSULE which is in column #1; move it to last column\n      UKV.remove(fr.remove(\"ID\")._key);   // Remove patient ID vector\n      Vec capsule = fr.remove(\"CAPSULE\"); // Remove capsule\n      fr.add(\"CAPSULE\",capsule);          // Move it to the end\n      int mtrys = Math.max((int)Math.sqrt(fr.numCols()),1);\n\n      DRF drf = DRF.start(DRF.makeKey(),fr,/*maxdepth*/50,/*ntrees*/5,mtrys,/*sampleRate*/0.67);\n      drf.get();                  // Block for result\n      UKV.remove(drf._dest);\n    } finally {\n      UKV.remove(dest);\n    }\n  }","commit_id":"e7a6c31510b56dd09d9ec3e0178f79b4cffc0a4d","url":"https://github.com/h2oai/h2o-2"},{"original_method":"void add(double val) {\n      if(!_enum){\n        if (val == 0.)\n          _nzero++;\n        // first update min/max\n        if(val < _min[_min.length-1]){\n          int j = _min.length-1;\n          while(j > 0 && _min[j-1] > val)--j;\n          if(j == 0 || _min[j-1] < val){ // skip dups\n            for(int k = _min.length-1; k > j; --k)\n              _min[k] = _min[k-1];\n            _min[j] = val;\n          }\n        }\n\n        if(val > _max[_max.length-1]){\n          int j = _max.length-1;\n          while(j > 0 && _max[j-1] < val)--j;\n          if(j == 0 || _max[j-1] > val){ // skip dups\n            for(int k = _max.length-1; k > j; --k)\n              _max[k] = _max[k-1];\n            _max[j] = val;\n          }\n\n        }\n      }\n      // update the histogram\n      int binIdx = (_binsz == 1)\n          ?Math.min((int)(val-_start),_bins.length-1)\n          :Math.min(_bins.length-1,(int)((val - _start) * _binszInv));\n      ++_bins[binIdx];\n      ++_n;\n    }","id":71140,"modified_method":"void add(double val) {\n      if(!_enum){\n        if (val == 0.)\n          _nzero++;\n        // first update min/max\n        if(val < _min[_min.length-1]){\n          int j = _min.length-1;\n          while(j > 0 && _min[j-1] > val)--j;\n          if(j == 0 || _min[j-1] < val){ // skip dups\n            for(int k = _min.length-1; k > j; --k)\n              _min[k] = _min[k-1];\n            _min[j] = val;\n          }\n        }\n\n        if(val > _max[_max.length-1]){\n          int j = _max.length-1;\n          while(j > 0 && _max[j-1] < val)--j;\n          if(j == 0 || _max[j-1] > val){ // skip dups\n            for(int k = _max.length-1; k > j; --k)\n              _max[k] = _max[k-1];\n            _max[j] = val;\n          }\n\n        }\n      }\n      // update the histogram\n      int binIdx = (_binsz == 1)\n          ?Math.min((int)(val-_start),_bins.length-1)\n          :Math.max(0,Math.min(_bins.length-1,(int)((val - _start) * _binszInv)));\n      ++_bins[binIdx];\n      ++_n;\n    }","commit_id":"8321814f75ecc2522aede5dac3cd4bce650e432c","url":"https://github.com/h2oai/h2o-2"},{"original_method":"@Override\n  public void defineApproximateSoftWraps(int line1, int line2) {\n    if (!isSoftWrappingEnabled()) {\n      return;\n    }\n    int startLine = line1;\n    int endLine = line2;\n    if (line1 > line2) {\n      startLine = line2;\n      endLine = line1;\n    }\n\n    // Normalization.\n    Document document = myEditor.getDocument();\n    startLine = Math.max(0, startLine);\n    endLine = Math.min(endLine, document.getLineCount() - 1);\n\n    myApplianceManager.registerSoftWrapIfNecessary(\n      document.getCharsSequence(), document.getLineStartOffset(startLine), document.getLineEndOffset(endLine), 0, Font.PLAIN, true\n    );\n  }","id":71141,"modified_method":"@Override\n  public void defineApproximateSoftWraps(int line1, int line2) {\n    if (!isSoftWrappingEnabled()) {\n      return;\n    }\n    int startLine = line1;\n    int endLine = line2;\n    if (line1 > line2) {\n      startLine = line2;\n      endLine = line1;\n    }\n\n    // Normalization.\n    Document document = myEditor.getDocument();\n    startLine = Math.max(0, startLine);\n    endLine = Math.max(0, Math.min(endLine, document.getLineCount() - 1));\n\n    myApplianceManager.registerSoftWrapIfNecessary(\n      document.getCharsSequence(), document.getLineStartOffset(startLine), document.getLineEndOffset(endLine), 0, Font.PLAIN, true\n    );\n  }","commit_id":"4f87eee87ee0e15cb6dc095560fad7dd914876d8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Image createImage(final JTree tree) {\n      final int height = Math.min(100, tree.getSelectionCount() * tree.getRowHeight());\n      final int width = tree.getWidth();\n\n      final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n      Graphics2D g2 = (Graphics2D)image.getGraphics();\n\n      g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n\n      drawSelection(tree, g2, width);\n      return image;\n    }","id":71142,"modified_method":"public static Image createImage(final JTree tree) {\n      final int height = Math.max(20, Math.min(100, tree.getSelectionCount() * tree.getRowHeight()));\n      final int width = tree.getWidth();\n\n      final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n      Graphics2D g2 = (Graphics2D)image.getGraphics();\n\n      g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n\n      drawSelection(tree, g2, width);\n      return image;\n    }","commit_id":"b11613a29edf7beea44afc4b0c1a592dd22862d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Image createImage(final JTable table, int column) {\n      final int height = Math.min(100, table.getSelectedRowCount() * table.getRowHeight());\n      final int width = table.getColumnModel().getColumn(column).getWidth();\n\n      final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n      Graphics2D g2 = (Graphics2D)image.getGraphics();\n\n      g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n\n      drawSelection(table, column, g2, width);\n      return image;\n    }","id":71143,"modified_method":"public static Image createImage(final JTable table, int column) {\n      final int height = Math.max(20, Math.min(100, table.getSelectedRowCount() * table.getRowHeight()));\n      final int width = table.getColumnModel().getColumn(column).getWidth();\n\n      final BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n      Graphics2D g2 = (Graphics2D)image.getGraphics();\n\n      g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.7f));\n\n      drawSelection(table, column, g2, width);\n      return image;\n    }","commit_id":"b11613a29edf7beea44afc4b0c1a592dd22862d2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"ColSummary(Summary s, int colId, double [] percentiles) {\n      _summary = s;\n      _colId = colId;\n      Column c = s.ary()._cols[colId];\n      _enum = c.isEnum();\n      final long n = Math.max(c._n,1);\n      if(_enum){\n        _percentiles = null;\n        _binsz = _binszInv = 1;\n        _bins = new long[(int)n];\n        _start = 0;\n        _end = n;\n      } else {\n        _min = new double[NMAX];\n        _max = new double[NMAX];\n        Arrays.fill(_min, Double.POSITIVE_INFINITY);\n        Arrays.fill(_max, Double.NEGATIVE_INFINITY);\n        if(c.isFloat() || c.numDomainSize() > MAX_HIST_SZ){\n          _percentiles = Objects.firstNonNull(percentiles, DEFAULT_PERCENTILES);\n\n          double a = (c._max - c._min) / n;\n          double b = Math.pow(10, Math.floor(Math.log10(a)));\n          // selects among d, 5*d, and 10*d so that the number of\n          // partitions go in [start, end] is closest to n\n          if (a > 20*b/3)\n             b *= 10;\n          else if (a > 5*b/3)\n             b *= 5;\n          double start = b * Math.floor(c._min / b);\n\n          // guard against improper parse (date type) or zero c._sigma\n          double binsz = Math.max(1e-4, 3.5 *  c._sigma/ Math.cbrt(c._n));\n          // Pick smaller of two for number of bins to avoid blowup of longs\n          int nbin = Math.min(MAX_HIST_SZ,(int)((c._max - c._min) / binsz));\n          _bins = new long[nbin];\n\n          _start = start;\n          _binsz = binsz;\n          _binszInv = 1.0/binsz;\n          _end = start + nbin * binsz;\n        } else {\n          _start = c._min;\n          _end = c._max;\n          int sz = (int)c.numDomainSize();\n          _bins = new long[sz];\n          _binszInv = _binsz = 1.0;\n          _percentiles = Objects.firstNonNull(percentiles, DEFAULT_PERCENTILES);\n        }\n      }\n    }","id":71144,"modified_method":"ColSummary(Summary s, int colId, double [] percentiles) {\n      _summary = s;\n      _colId = colId;\n      Column c = s.ary()._cols[colId];\n      _enum = c.isEnum();\n      final long n = Math.max(c._n,1);\n      if(_enum){\n        _percentiles = null;\n        _binsz = _binszInv = 1;\n        _bins = new long[(int)n];\n        _start = 0;\n        _end = n;\n      } else {\n        _min = new double[NMAX];\n        _max = new double[NMAX];\n        Arrays.fill(_min, Double.POSITIVE_INFINITY);\n        Arrays.fill(_max, Double.NEGATIVE_INFINITY);\n        if(c.isFloat() || c.numDomainSize() > MAX_HIST_SZ){\n          _percentiles = Objects.firstNonNull(percentiles, DEFAULT_PERCENTILES);\n\n          double a = (c._max - c._min) / n;\n          double b = Math.pow(10, Math.floor(Math.log10(a)));\n          // selects among d, 5*d, and 10*d so that the number of\n          // partitions go in [start, end] is closest to n\n          if (a > 20*b/3)\n             b *= 10;\n          else if (a > 5*b/3)\n             b *= 5;\n          double start = b * Math.floor(c._min / b);\n\n          // guard against improper parse (date type) or zero c._sigma\n          double binsz = Math.max(1e-4, 3.5 *  c._sigma/ Math.cbrt(c._n));\n          // Pick smaller of two for number of bins to avoid blowup of longs\n          int nbin = Math.max(Math.min(MAX_HIST_SZ,(int)((c._max - c._min) / binsz)),1);\n          _bins = new long[nbin];\n\n          _start = start;\n          _binsz = binsz;\n          _binszInv = 1.0/binsz;\n          _end = start + nbin * binsz;\n        } else {\n          _start = c._min;\n          _end = c._max;\n          int sz = (int)c.numDomainSize();\n          _bins = new long[sz];\n          _binszInv = _binsz = 1.0;\n          _percentiles = Objects.firstNonNull(percentiles, DEFAULT_PERCENTILES);\n        }\n      }\n    }","commit_id":"8e3300db8ee135fedea3c0b099dea405acab23a1","url":"https://github.com/h2oai/h2o-2"},{"original_method":"public QueryParams(\r\n        final String queryString, final HandleSet queryHashes,\r\n        final HandleSet excludeHashes,\r\n        final HandleSet fullqueryHashes,\r\n        final Pattern snippetMatcher,\r\n        final String tenant,\r\n        final int maxDistance, final String prefer, final ContentDomain contentdom,\r\n        final String language,\r\n        final String navigators,\r\n        final CacheStrategy snippetCacheStrategy,\r\n        final int itemsPerPage, final int offset, final String urlMask,\r\n        final int domType, final int domMaxTargets,\r\n        final Bitfield constraint, final boolean allofconstraint,\r\n        final String site,\r\n        final String authorhash,\r\n        final int domainzone,\r\n        final String host,\r\n        final boolean specialRights,\r\n        final Segment indexSegment,\r\n        final RankingProfile ranking,\r\n        final String userAgent,\r\n        final boolean filterfailurls) {\r\n\r\n        this.queryString = queryString;\r\n        this.queryHashes = queryHashes;\r\n        this.excludeHashes = excludeHashes;\r\n        this.fullqueryHashes = fullqueryHashes;\r\n        this.snippetMatcher = snippetMatcher;\r\n        this.tenant = (tenant != null && tenant.length() == 0) ? null : tenant;\r\n        this.ranking = ranking;\r\n        this.maxDistance = maxDistance;\r\n        this.contentdom = contentdom;\r\n        this.itemsPerPage = Math.min((specialRights) ? 1000 : 100, itemsPerPage);\r\n        this.offset = Math.min((specialRights) ? 10000 : 1000, offset);\r\n        try {\r\n            this.urlMask = Pattern.compile(urlMask.toLowerCase());\r\n        } catch (final PatternSyntaxException ex) {\r\n            throw new IllegalArgumentException(\"Not a valid regular expression: \" + urlMask, ex);\r\n        }\r\n        this.urlMask_isCatchall = this.urlMask.toString().equals(catchall_pattern.toString());\r\n        try {\r\n            this.prefer = Pattern.compile(prefer);\r\n        } catch (final PatternSyntaxException ex) {\r\n            throw new IllegalArgumentException(\"Not a valid regular expression: \" + prefer, ex);\r\n        }\r\n        this.prefer_isMatchnothing = this.prefer.toString().equals(matchnothing_pattern.toString());\r\n        assert language != null;\r\n        this.targetlang = language;\r\n        this.navigators = navigators;\r\n        this.domType = domType;\r\n        this.zonecode = domainzone;\r\n        this.domMaxTargets = domMaxTargets;\r\n        this.constraint = constraint;\r\n        this.allofconstraint = allofconstraint;\r\n        this.sitehash = site; assert site == null || site.length() == 6;\r\n        this.authorhash = authorhash; assert authorhash == null || !authorhash.isEmpty();\r\n        this.snippetCacheStrategy = snippetCacheStrategy;\r\n        this.host = host;\r\n        this.remotepeer = null;\r\n        this.time = Long.valueOf(System.currentTimeMillis());\r\n        this.specialRights = specialRights;\r\n        this.indexSegment = indexSegment;\r\n        this.userAgent = userAgent;\r\n        this.transmitcount = 0;\r\n        this.filterfailurls = filterfailurls;\r\n    }","id":71145,"modified_method":"public QueryParams(\r\n        final String queryString, final HandleSet queryHashes,\r\n        final HandleSet excludeHashes,\r\n        final HandleSet fullqueryHashes,\r\n        final Pattern snippetMatcher,\r\n        final String tenant,\r\n        final int maxDistance, final String prefer, final ContentDomain contentdom,\r\n        final String language,\r\n        final String navigators,\r\n        final CacheStrategy snippetCacheStrategy,\r\n        final int itemsPerPage, final int offset, final String urlMask,\r\n        final int domType, final int domMaxTargets,\r\n        final Bitfield constraint, final boolean allofconstraint,\r\n        final String site,\r\n        final String authorhash,\r\n        final int domainzone,\r\n        final String host,\r\n        final boolean specialRights,\r\n        final Segment indexSegment,\r\n        final RankingProfile ranking,\r\n        final String userAgent,\r\n        final boolean filterfailurls) {\r\n\r\n        this.queryString = queryString;\r\n        this.queryHashes = queryHashes;\r\n        this.excludeHashes = excludeHashes;\r\n        this.fullqueryHashes = fullqueryHashes;\r\n        this.snippetMatcher = snippetMatcher;\r\n        this.tenant = (tenant != null && tenant.length() == 0) ? null : tenant;\r\n        this.ranking = ranking;\r\n        this.maxDistance = maxDistance;\r\n        this.contentdom = contentdom;\r\n        this.itemsPerPage = Math.min((specialRights) ? 10000 : 1000, itemsPerPage);\r\n        this.offset = Math.max(0, Math.min((specialRights) ? 10000 - this.itemsPerPage : 1000 - this.itemsPerPage, offset));\r\n        try {\r\n            this.urlMask = Pattern.compile(urlMask.toLowerCase());\r\n        } catch (final PatternSyntaxException ex) {\r\n            throw new IllegalArgumentException(\"Not a valid regular expression: \" + urlMask, ex);\r\n        }\r\n        this.urlMask_isCatchall = this.urlMask.toString().equals(catchall_pattern.toString());\r\n        try {\r\n            this.prefer = Pattern.compile(prefer);\r\n        } catch (final PatternSyntaxException ex) {\r\n            throw new IllegalArgumentException(\"Not a valid regular expression: \" + prefer, ex);\r\n        }\r\n        this.prefer_isMatchnothing = this.prefer.toString().equals(matchnothing_pattern.toString());\r\n        assert language != null;\r\n        this.targetlang = language;\r\n        this.navigators = navigators;\r\n        this.domType = domType;\r\n        this.zonecode = domainzone;\r\n        this.domMaxTargets = domMaxTargets;\r\n        this.constraint = constraint;\r\n        this.allofconstraint = allofconstraint;\r\n        this.sitehash = site; assert site == null || site.length() == 6;\r\n        this.authorhash = authorhash; assert authorhash == null || !authorhash.isEmpty();\r\n        this.snippetCacheStrategy = snippetCacheStrategy;\r\n        this.host = host;\r\n        this.remotepeer = null;\r\n        this.time = Long.valueOf(System.currentTimeMillis());\r\n        this.specialRights = specialRights;\r\n        this.indexSegment = indexSegment;\r\n        this.userAgent = userAgent;\r\n        this.transmitcount = 0;\r\n        this.filterfailurls = filterfailurls;\r\n    }","commit_id":"594d8f546afdfdc1dd947c4e23dc4deba597eb69","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n        final String promoteSearchPageGreeting =\n                (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ?\n                    env.getConfig(\"network.unit.description\", \"\") :\n                    env.getConfig(SwitchboardConstants.GREETING, \"\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\n        \n        final String query = (post == null) ? \"\" : post.get(\"query\", \"\");\n        prop.putHTML(\"query\", query);\n        prop.putHTML(\"querys\", query.replaceAll(\" \", \"+\"));\n        return prop;\n    }","id":71146,"modified_method":"public static serverObjects respond(final RequestHeader header, serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final serverObjects prop = new serverObjects();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n        final String promoteSearchPageGreeting =\n                (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ?\n                    env.getConfig(\"network.unit.description\", \"\") :\n                    env.getConfig(SwitchboardConstants.GREETING, \"\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\n\n        final String query = (post == null) ? \"\" : post.get(\"query\", \"\");\n        final String startRecord = (post == null) ? \"0\" : post.get(\"startRecord\", \"\");\n        final String maximumRecords = (post == null) ? \"1000\" : post.get(\"maximumRecords\", \"\");\n        prop.putHTML(\"query\", query);\n        prop.putHTML(\"startRecord\", startRecord);\n        prop.putHTML(\"maximumRecords\", maximumRecords);\n        prop.putHTML(\"querys\", query.replaceAll(\" \", \"+\"));\n        return prop;\n    }","commit_id":"594d8f546afdfdc1dd947c4e23dc4deba597eb69","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n\r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        if (!authenticated) {\r\n            final UserDB.Entry user = sb.userDB.getUser(header);\r\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\r\n        }\r\n        final boolean localhostAccess = sb.accessFromLocalhost(header);\r\n        final String promoteSearchPageGreeting =\r\n                (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ?\r\n                    env.getConfig(\"network.unit.description\", \"\") :\r\n                    env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n\r\n        // get query\r\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\r\n        String querystring =  originalquerystring.replace('+', ' ').replace('*', ' ').trim();\r\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", \"cacheonly\"));\r\n        final servletProperties prop = new servletProperties();\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        if (post != null && post.containsKey(\"segment\")) {\r\n            final String segmentName = post.get(\"segment\");\r\n            if (sb.indexSegments.segmentExist(segmentName)) {\r\n                indexSegment = sb.indexSegments.segment(segmentName);\r\n            }\r\n        } else {\r\n            // take default segment\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n\r\n        final String EXT = header.get(\"EXT\", \"\");\r\n        final boolean rss = EXT.equals(\"rss\");\r\n        final boolean json = EXT.equals(\"json\");\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        if (post == null || indexSegment == null || env == null || !searchAllowed) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"count\", \"10\");\r\n            prop.put(\"offset\", \"0\");\r\n            prop.put(\"resource\", \"global\");\r\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\r\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\r\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\r\n            prop.put(\"indexof\", \"off\");\r\n            prop.put(\"constraint\", \"\");\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n            prop.put(\"search.verify\", (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\r\n            prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n            prop.put(\"contentdom\", \"text\");\r\n            prop.put(\"contentdomCheckText\", \"1\");\r\n            prop.put(\"contentdomCheckAudio\", \"0\");\r\n            prop.put(\"contentdomCheckVideo\", \"0\");\r\n            prop.put(\"contentdomCheckImage\", \"0\");\r\n            prop.put(\"contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            prop.put(\"num-results_totalcount\", 0);\r\n            prop.put(\"num-results_offset\", 0);\r\n            prop.put(\"num-results_itemsPerPage\", 10);\r\n            prop.put(\"geoinfo\", \"0\");\r\n            prop.put(\"rss_queryenc\", \"\");\r\n            prop.put(\"meanCount\", 5);\r\n            return prop;\r\n        }\r\n\r\n        // check for JSONP\r\n        if (post.containsKey(\"callback\")) {\r\n        \tfinal String jsonp = post.get(\"callback\")+ \"([\";\r\n        \tprop.put(\"jsonp-start\", jsonp);\r\n        \tprop.put(\"jsonp-end\", \"])\");\r\n        } else {\r\n        \tprop.put(\"jsonp-start\", \"\");\r\n        \tprop.put(\"jsonp-end\", \"\");\r\n        }\r\n\r\n        // Adding CORS Access header for yacysearch.rss output\r\n        if (rss) {\r\n            final ResponseHeader outgoingHeader = new ResponseHeader();\r\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\r\n            prop.setOutgoingHeader(outgoingHeader);\r\n        }\r\n\r\n        // collect search attributes\r\n        final boolean newsearch =post.hasValue(\"query\") && post.hasValue(\"former\") && !post.get(\"query\",\"\").equalsIgnoreCase(post.get(\"former\",\"\")); //new search term\r\n\r\n        int itemsPerPage = Math.min((authenticated) ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 100 : 1000) : (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 500), post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = (newsearch) ? 0 : post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n\r\n        final int newcount;\r\n        if ( authenticated && (newcount = post.getInt(\"count\", 0)) > 0 ) {\r\n            sb.setConfig(SwitchboardConstants.SEARCH_ITEMS, newcount);\r\n        } // set new default maximumRecords if search with \"more options\"\r\n\r\n        boolean global = post.get(\"resource\", \"local\").equals(\"global\") && sb.peers.sizeConnected() > 0;\r\n        final boolean indexof = (post != null && post.get(\"indexof\",\"\").equals(\"on\"));\r\n\r\n        final String originalUrlMask;\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) { // option search all\r\n            originalUrlMask = \".*\";\r\n        } else if (!newsearch && post.containsKey(\"urlmaskfilter\")) {\r\n            originalUrlMask = post.get(\"urlmaskfilter\", \".*\");\r\n        } else {\r\n            originalUrlMask = \".*\";\r\n        }\r\n\r\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        if (!prefermask.isEmpty() && prefermask.indexOf(\".*\") < 0) {\r\n            prefermask = \".*\" + prefermask + \".*\";\r\n        }\r\n\r\n        Bitfield constraint = (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty()) ? new Bitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new Bitfield(4);\r\n            constraint.set(Condenser.flag_cat_indexof, true);\r\n        }\r\n\r\n        // SEARCH\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) ||\r\n                sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true);\r\n        global = global && indexReceiveGranted; // if the user does not want indexes from remote peers, it cannot be a global search\r\n\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n                (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\tsb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        if (clustersearch) {\r\n            global = true;\r\n        } // switches search on, but search target is limited to cluster nodes\r\n\r\n        // increase search statistic counter\r\n        if (!global) {\r\n            // we count only searches on the local peer here, because global searches\r\n            // are counted on the target peer to preserve privacy of the searcher\r\n            if (authenticated) {\r\n                // local or authenticated search requests are counted separately\r\n                // because they are not part of a public available peer statistic\r\n                sb.searchQueriesRobinsonFromLocal++;\r\n            } else {\r\n                // robinson-searches from non-authenticated requests are public\r\n                // and may be part of the public available statistic\r\n                sb.searchQueriesRobinsonFromRemote++;\r\n            }\r\n        }\r\n\r\n        // find search domain\r\n        final ContentDomain contentdom = ContentDomain.contentdomParser(post == null ? \"text\" : post.get(\"contentdom\", \"text\"));\r\n\r\n        // patch until better search profiles are available\r\n        if ((contentdom != ContentDomain.TEXT) && (itemsPerPage <= 32)) {\r\n            itemsPerPage = 64;\r\n        }\r\n\r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) {\r\n            trackerHandles = new TreeSet<Long>();\r\n        }\r\n        boolean block = false;\r\n        if (Domains.matchesList(client, sb.networkBlacklist)) {\r\n            global = false;\r\n            if (snippetFetchStrategy != null) {\r\n                snippetFetchStrategy = null;\r\n            }\r\n            block = true;\r\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \" + client + \" gets no permission to search\");\r\n        } else if (Domains.matchesList(client, sb.networkWhitelist)) {\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \" + client + \" gets no search restrictions\");\r\n        } else if (!authenticated && !localhostAccess) {\r\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\r\n            synchronized (trackerHandles) {\r\n                final int accInThreeSeconds = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\r\n                final int accInOneMinute = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\r\n                final int accInTenMinutes = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\r\n                // protections against too strong YaCy network load, reduces remote search\r\n                if (global) {\r\n                    if (accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1) {\r\n                        global = false;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed global search\");\r\n                    }\r\n                }\r\n                // protection against too many remote server snippet loads (protects traffic on server)\r\n                if (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()) {\r\n                    if (accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1) {\r\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed remote snippet loading\");\r\n                    }\r\n                }\r\n                // general load protection\r\n                if (accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60) {\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed search\");\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((!block) && (post == null || post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            String urlmask = null;\r\n\r\n            // check available memory and clean up if necessary\r\n            if (!MemoryControl.request(8000000L, false)) {\r\n                indexSegment.urlMetadata().clearCache();\r\n                SearchEventCache.cleanupEvents(true);\r\n            }\r\n\r\n            final RankingProfile ranking = sb.getRanking();\r\n\r\n            if (querystring.indexOf(\"/near\") >= 0) {\r\n            \tquerystring = querystring.replace(\"/near\", \"\");\r\n            \tranking.coeff_worddistance = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/date\") >= 0) {\r\n                querystring = querystring.replace(\"/date\", \"\");\r\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/http\") >= 0) {\r\n                querystring = querystring.replace(\"/http\", \"\");\r\n                urlmask = \"http://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/https\") >= 0) {\r\n                querystring = querystring.replace(\"/https\", \"\");\r\n                urlmask = \"https://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/ftp\") >= 0) {\r\n                querystring = querystring.replace(\"/ftp\", \"\");\r\n                urlmask = \"ftp://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/smb\") >= 0) {\r\n                querystring = querystring.replace(\"/smb\", \"\");\r\n                urlmask = \"smb://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/file\") >= 0) {\r\n                querystring = querystring.replace(\"/file\", \"\");\r\n                urlmask = \"file://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/location\") >= 0) {\r\n                querystring = querystring.replace(\"/location\", \"\");\r\n                if (constraint == null) {\r\n                    constraint = new Bitfield(4);\r\n                }\r\n                constraint.set(Condenser.flag_cat_haslocation, true);\r\n            }\r\n            final int lrp = querystring.indexOf(\"/language/\");\r\n            String lr = \"\";\r\n            if (lrp >= 0) {\r\n                if (querystring.length() >= (lrp + 11)) {\r\n                    lr = querystring.substring(lrp + 9, lrp + 11);\r\n                }\r\n\r\n                querystring = querystring.replace(\"/language/\" + lr, \"\");\r\n                lr = lr.toLowerCase();\r\n            }\r\n            final int inurl = querystring.indexOf(\"inurl:\");\r\n            if (inurl >= 0) {\r\n                int ftb = querystring.indexOf(' ', inurl);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                final String urlstr = querystring.substring(inurl + 6, ftb);\r\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\r\n                if (!urlstr.isEmpty()) {\r\n                    urlmask = \".*\" + urlstr + \".*\";\r\n                }\r\n            }\r\n            final int filetype = querystring.indexOf(\"filetype:\");\r\n            if (filetype >= 0) {\r\n                int ftb = querystring.indexOf(' ', filetype);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String ft = querystring.substring(filetype + 9, ftb);\r\n                querystring = querystring.replace(\"filetype:\" + ft, \"\");\r\n                while (!ft.isEmpty() && ft.charAt(0) == '.') ft = ft.substring(1);\r\n                if (!ft.isEmpty()) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\\\\.\" + ft;\r\n                    } else {\r\n                        urlmask = urlmask + \".*\\\\.\" + ft;\r\n                    }\r\n                }\r\n            }\r\n            String tenant = null;\r\n            if (post.containsKey(\"tenant\")) {\r\n                tenant = post.get(\"tenant\");\r\n                if (tenant != null && tenant.isEmpty()) {\r\n                    tenant = null;\r\n                }\r\n                if (tenant != null) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\" + tenant + \".*\";\r\n                    } else urlmask = \".*\" + tenant + urlmask;\r\n                }\r\n            }\r\n            final int site = querystring.indexOf(\"site:\");\r\n            String sitehash = null;\r\n            String sitehost = null;\r\n            if (site >= 0) {\r\n                int ftb = querystring.indexOf(' ', site);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                sitehost = querystring.substring(site + 5, ftb);\r\n                querystring = querystring.replace(\"site:\" + sitehost, \"\");\r\n                while (sitehost.length() > 0 && sitehost.charAt(0) == '.') {\r\n                    sitehost = sitehost.substring(1);\r\n                }\r\n                while (sitehost.endsWith(\".\")) {\r\n                    sitehost = sitehost.substring(0, sitehost.length() - 1);\r\n                }\r\n                sitehash = DigestURI.hosthash(sitehost);\r\n            }\r\n\r\n            final int heuristicScroogle = querystring.indexOf(\"heuristic:scroogle\");\r\n            if (heuristicScroogle >= 0) {\r\n                querystring = querystring.replace(\"heuristic:scroogle\", \"\");\r\n            }\r\n\r\n            final int heuristicBlekko = querystring.indexOf(\"heuristic:blekko\");\r\n            if (heuristicBlekko >= 0) {\r\n                querystring = querystring.replace(\"heuristic:blekko\", \"\");\r\n            }\r\n\r\n            final int authori = querystring.indexOf(\"author:\");\r\n        \tString authorhash = null;\r\n            if (authori >= 0) {\r\n            \t// check if the author was given with single quotes or without\r\n            \tfinal boolean quotes = (querystring.charAt(authori + 7) == (char) 39);\r\n            \tString author;\r\n            \tif (quotes) {\r\n                    int ftb = querystring.indexOf((char) 39, authori + 8);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length() + 1;\r\n                    }\r\n                    author = querystring.substring(authori + 8, ftb);\r\n                    querystring = querystring.replace(\"author:'\" + author + \"'\", \"\");\r\n            \t} else {\r\n                    int ftb = querystring.indexOf(' ', authori);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length();\r\n                    }\r\n                    author = querystring.substring(authori + 7, ftb);\r\n                    querystring = querystring.replace(\"author:\" + author, \"\");\r\n            \t}\r\n            \tauthorhash = ASCII.String(Word.word2hash(author));\r\n            }\r\n            final int tld = querystring.indexOf(\"tld:\");\r\n            if (tld >= 0) {\r\n                int ftb = querystring.indexOf(' ', tld);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String domain = querystring.substring(tld + 4, ftb);\r\n                querystring = querystring.replace(\"tld:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') {\r\n                    domain = domain.substring(1);\r\n                }\r\n                if (domain.indexOf('.') < 0) {\r\n                    domain = \"\\\\.\" + domain;\r\n                } // is tld\r\n                if (domain.length() > 0) {\r\n                    urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\" + ((urlmask != null) ? urlmask : \"\");\r\n                }\r\n            }\r\n            if (urlmask == null || urlmask.isEmpty()) {\r\n                urlmask = originalUrlMask;\r\n            } //if no urlmask was given\r\n\r\n            // read the language from the language-restrict option 'lr'\r\n            // if no one is given, use the user agent or the system language as default\r\n            String language = (post == null) ? lr : post.get(\"lr\", lr);\r\n            if (language.startsWith(\"lang_\")) {\r\n                language = language.substring(5);\r\n            }\r\n            if (!ISO639.exists(language)) {\r\n                // find out language of the user by reading of the user-agent string\r\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\r\n                if (agent == null) {\r\n                    agent = System.getProperty(\"user.language\");\r\n                }\r\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\r\n                if (language == null) {\r\n                    language = \"en\";\r\n                }\r\n            }\r\n\r\n            // navigation\r\n            final String navigation = (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"\");\r\n\r\n            // the query\r\n            final TreeSet<String>[] query = QueryParams.cleanQuery(querystring.trim()); // converts also umlaute\r\n\r\n            final int maxDistance = (querystring.indexOf('\"') >= 0) ? query.length - 1 : Integer.MAX_VALUE;\r\n\r\n            // filter out stopwords\r\n            final SortedSet<String> filtered = SetTools.joinConstructive(query[0], Switchboard.stopwords);\r\n            if (!filtered.isEmpty()) {\r\n                SetTools.excludeDestructive(query[0], Switchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post != null && post.containsKey(\"deleteref\")) {\r\n                try {\r\n                    if (!sb.verifyAuthentication(header, true)) {\r\n                        prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                        return prop;\r\n                    }\r\n\r\n                    // delete the index entry locally\r\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                    indexSegment.termIndex().remove(Word.words2hashesHandles(query[0]), delHash.getBytes());\r\n\r\n                    // make new news message with negative voting\r\n                    if (!sb.isRobinsonMode()) {\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"urlhash\", delHash);\r\n                        map.put(\"vote\", \"negative\");\r\n                        map.put(\"refid\", \"\");\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map);\r\n                    }\r\n                } catch (final IOException e) {\r\n                    Log.logException(e);\r\n                }\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post != null && post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(UTF8.getBytes(recommendHash));\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    Document[] documents = null;\r\n                    try {\r\n                        documents = sb.loader.loadDocuments(sb.loader.request(metadata.url(), true, false), CacheStrategy.IFEXIST, 5000, Integer.MAX_VALUE);\r\n                    } catch (final IOException e) {\r\n                    } catch (final Parser.Failure e) {\r\n                    }\r\n                    if (documents != null) {\r\n                        // create a news message\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", metadata.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", metadata.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\r\n                        map.put(\"author\", documents[0].dc_creator());\r\n                        map.put(\"tags\", documents[0].dc_subject(' '));\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_ADD, map);\r\n                        documents[0].close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean globalsearch = (global) && indexReceiveGranted;\r\n\r\n            // do the search\r\n            final HandleSet queryHashes = Word.words2hashesHandles(query[0]);\r\n            final Pattern snippetPattern = QueryParams.stringSearchPattern(originalquerystring);\r\n\r\n            // check filters\r\n            try {\r\n                Pattern.compile(urlmask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal URL mask, not a valid regex: \" + urlmask);\r\n                prop.put(\"urlmaskerror\", 1);\r\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\r\n                urlmask = \".*\";\r\n            }\r\n\r\n            try {\r\n                Pattern.compile(prefermask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal prefer mask, not a valid regex: \" + prefermask);\r\n                prop.put(\"prefermaskerror\", 1);\r\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\r\n                prefermask = \"\";\r\n            }\r\n\r\n            final QueryParams theQuery = new QueryParams(\r\n                    originalquerystring,\r\n                    queryHashes,\r\n                    Word.words2hashesHandles(query[1]),\r\n                    Word.words2hashesHandles(query[2]),\r\n                    snippetPattern,\r\n                    tenant,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdom,\r\n                    language,\r\n                    navigation,\r\n                    snippetFetchStrategy,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? QueryParams.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? QueryParams.SEARCHDOM_GLOBALDHT : QueryParams.SEARCHDOM_LOCAL),\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    sitehash,\r\n                    authorhash,\r\n                    DigestURI.TLD_any_zone_filter,\r\n                    client,\r\n                    authenticated,\r\n                    indexSegment,\r\n                    ranking,\r\n                    header.get(RequestHeader.USER_AGENT, \"\"),\r\n                    sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false) && sb.peers.mySeed().getFlagAcceptRemoteIndex());\r\n            EventTracker.delete(EventTracker.EClass.SEARCH);\r\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theQuery.id(true), SearchEvent.Type.INITIALIZATION, \"\", 0, 0), false);\r\n\r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(3000);\r\n\r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(Switchboard.blueList);\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + QueryParams.hashSet2hashString(theQuery.queryHashes) + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            yacyChannel.channels(yacyChannel.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            final long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (SearchEventCache.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\r\n                offset = 0;\r\n            }\r\n            final SearchEvent theSearch = SearchEventCache.getEvent(\r\n                theQuery, sb.peers, sb.tables, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false, sb.loader,\r\n                (int) sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\r\n                      sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_ROBINSON, 0),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_MULTIWORD, 0));\r\n\r\n            if (offset == 0) {\r\n                if (sitehost != null && sb.getConfigBool(\"heuristic.site\", false) && authenticated) {\r\n                    sb.heuristicSite(theSearch, sitehost);\r\n                }\r\n                if ((heuristicScroogle >= 0  || sb.getConfigBool(\"heuristic.scroogle\", false)) && authenticated) {\r\n                    sb.heuristicScroogle(theSearch);\r\n                }\r\n                if ((heuristicBlekko >= 0  || sb.getConfigBool(\"heuristic.blekko\", false)) && authenticated) {\r\n                    sb.heuristicRSS(\"http://blekko.com/ws/$+/rss\", theSearch, \"blekko\");\r\n                }\r\n            }\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    \"local-unfiltered(\" + theSearch.getRankingResult().getLocalIndexCount() + \"), \" +\r\n                    \"-local_miss(\" + theSearch.getRankingResult().getMissCount() + \"), \" +\r\n                    \"-local_sortout(\" + theSearch.getRankingResult().getSortOutCount() + \"), \" +\r\n                    \"remote(\" + theSearch.getRankingResult().getRemoteResourceSize() + \") links found, \" +\r\n                    (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.result().getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.result().getSnippetComputationTime();\r\n            AccessTracker.add(AccessTracker.Location.local, theQuery);\r\n\r\n            // check suggestions\r\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\r\n\r\n            prop.put(\"meanCount\", meanMax);\r\n            if (meanMax > 0 && !json && !rss) {\r\n                final DidYouMean didYouMean = new DidYouMean(indexSegment.termIndex(), querystring);\r\n            \tfinal Iterator<String> meanIt = didYouMean.getSuggestions(100, 5).iterator();\r\n                int meanCount = 0;\r\n                String suggestion;\r\n                while( meanCount<meanMax && meanIt.hasNext()) {\r\n                    suggestion = meanIt.next();\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_word\", suggestion);\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_url\",\r\n                            QueryParams.navurl(\"html\", 0, theQuery, suggestion, originalUrlMask.toString(), theQuery.navigators).toString()\r\n    \t             );\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_sep\",\"|\");\r\n                    meanCount++;\r\n                }\r\n                prop.put(\"didYouMean_suggestions_\"+(meanCount-1)+\"_sep\",\"\");\r\n                prop.put(\"didYouMean\", meanCount>0 ? 1:0);\r\n                prop.put(\"didYouMean_suggestions\", meanCount);\r\n            } else {\r\n                prop.put(\"didYouMean\", 0);\r\n            }\r\n\r\n            // find geographic info\r\n            final SortedSet<Location> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\r\n            if (coordinates == null || coordinates.isEmpty() || offset > 0) {\r\n                prop.put(\"geoinfo\", \"0\");\r\n            } else {\r\n                int i = 0;\r\n                for (final Location c: coordinates) {\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\r\n                    i++;\r\n                    if (i >= 10) break;\r\n                }\r\n                prop.put(\"geoinfo_loc\", i);\r\n                prop.put(\"geoinfo\", \"1\");\r\n            }\r\n\r\n            // update the search tracker\r\n            try {\r\n                synchronized (trackerHandles) {\r\n                    trackerHandles.add(theQuery.time);\r\n                    while (trackerHandles.size() > 600) {\r\n                        if (!trackerHandles.remove(trackerHandles.first())) break;\r\n                    }\r\n                }\r\n                sb.localSearchTracker.put(client, trackerHandles);\r\n            \tif (sb.localSearchTracker.size() > 100) {\r\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\r\n                }\r\n            \tif (MemoryControl.shortStatus()) sb.localSearchTracker.clear();\r\n            } catch (final Exception e) {\r\n                Log.logException(e);\r\n            }\r\n\r\n            final int indexcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", Formatter.number(0, true));\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", Formatter.number(indexcount, true));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_localMissCount\", Formatter.number(theSearch.getRankingResult().getMissCount(), true));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.getRankingResult().getRemoteIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.getRankingResult().getRemotePeerCount(), true));\r\n\r\n            // compose page navigation\r\n            final StringBuilder resnav = new StringBuilder();\r\n            final int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n            } else {\r\n            \tresnav.append(\"<a id=\\\"prevpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, theQuery, null, originalUrlMask, navigation).toString());\r\n            \tresnav.append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n            }\r\n            final int numberofpages = Math.min(10, 1 + ((indexcount - 1) / theQuery.displayResults()));\r\n\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n                } else {\r\n                    resnav.append(\"<a href=\\\"\");\r\n                    resnav.append(QueryParams.navurl(\"html\", i, theQuery, null, originalUrlMask, navigation).toString());\r\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" />\");\r\n            } else {\r\n                resnav.append(\"<a id=\\\"nextpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, theQuery, null, originalUrlMask, navigation).toString());\r\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>\");\r\n            }\r\n            final String resnavs = resnav.toString();\r\n            prop.put(\"num-results_resnav\", resnavs);\r\n            prop.put(\"pageNavBottom\", (indexcount - offset > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\r\n            prop.put(\"pageNavBottom_resnav\", resnavs);\r\n\r\n            // generate the search result lines; the content will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n\r\n            // process result of search\r\n            if (!filtered.isEmpty()) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.isEmpty()) {\r\n                if (post.get(\"query\", post.get(\"search\", \"\")).length() < 2) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(':') == -1) {\r\n                hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8090\"));\r\n            }\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n\r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.putHTML(\"former\", originalquerystring);\r\n        prop.put(\"count\", itemsPerPage);\r\n        prop.put(\"offset\", offset);\r\n        prop.put(\"resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"urlmaskfilter\", originalUrlMask);\r\n        prop.putHTML(\"prefermaskfilter\", prefermask);\r\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\r\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        prop.put(\"searchdomswitches\", sb.getConfigBool(\"search.text\", true) || sb.getConfigBool(\"search.audio\", true) || sb.getConfigBool(\"search.video\", true) || sb.getConfigBool(\"search.image\", true) || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n\r\n        // copy properties for \"more options\" link\r\n        prop.put(\"searchdomswitches_count\", prop.get(\"count\"));\r\n        prop.put(\"searchdomswitches_urlmaskfilter\", prop.get(\"urlmaskfilter\"));\r\n        prop.put(\"searchdomswitches_prefermaskfilter\", prop.get(\"prefermaskfilter\"));\r\n        prop.put(\"searchdomswitches_cat\", prop.get(\"cat\"));\r\n        prop.put(\"searchdomswitches_constraint\", prop.get(\"constraint\"));\r\n        prop.put(\"searchdomswitches_contentdom\", prop.get(\"contentdom\"));\r\n        prop.put(\"searchdomswitches_former\", prop.get(\"former\"));\r\n        prop.put(\"searchdomswitches_meanCount\", prop.get(\"meanCount\"));\r\n\r\n        // for RSS: don't HTML encode some elements\r\n        prop.putXML(\"rss_query\", originalquerystring);\r\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":71147,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\r\n        final Switchboard sb = (Switchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        final boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n\r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        if (!authenticated) {\r\n            final UserDB.Entry user = sb.userDB.getUser(header);\r\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\r\n        }\r\n        final boolean localhostAccess = sb.accessFromLocalhost(header);\r\n        final String promoteSearchPageGreeting =\r\n                (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ?\r\n                    env.getConfig(\"network.unit.description\", \"\") :\r\n                    env.getConfig(SwitchboardConstants.GREETING, \"\");\r\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n\r\n        // get query\r\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\r\n        String querystring =  originalquerystring.replace('+', ' ').replace('*', ' ').trim();\r\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", \"cacheonly\"));\r\n        final servletProperties prop = new servletProperties();\r\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\r\n\r\n        // get segment\r\n        Segment indexSegment = null;\r\n        if (post != null && post.containsKey(\"segment\")) {\r\n            final String segmentName = post.get(\"segment\");\r\n            if (sb.indexSegments.segmentExist(segmentName)) {\r\n                indexSegment = sb.indexSegments.segment(segmentName);\r\n            }\r\n        } else {\r\n            // take default segment\r\n            indexSegment = sb.indexSegments.segment(Segments.Process.PUBLIC);\r\n        }\r\n\r\n        final String EXT = header.get(\"EXT\", \"\");\r\n        final boolean rss = EXT.equals(\"rss\");\r\n        final boolean json = EXT.equals(\"json\");\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.put(\"promoteSearchPageGreeting.homepage\", sb.getConfig(SwitchboardConstants.GREETING_HOMEPAGE, \"\"));\r\n        prop.put(\"promoteSearchPageGreeting.smallImage\", sb.getConfig(SwitchboardConstants.GREETING_SMALL_IMAGE, \"\"));\r\n        if (post == null || indexSegment == null || env == null || !searchAllowed) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"count\", \"10\");\r\n            prop.put(\"offset\", \"0\");\r\n            prop.put(\"resource\", \"global\");\r\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\r\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\r\n            prop.put(\"tenant\", (post == null) ? \"\" : post.get(\"tenant\", \"\"));\r\n            prop.put(\"indexof\", \"off\");\r\n            prop.put(\"constraint\", \"\");\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n            prop.put(\"search.verify\", (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\r\n            prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n            prop.put(\"contentdom\", \"text\");\r\n            prop.put(\"contentdomCheckText\", \"1\");\r\n            prop.put(\"contentdomCheckAudio\", \"0\");\r\n            prop.put(\"contentdomCheckVideo\", \"0\");\r\n            prop.put(\"contentdomCheckImage\", \"0\");\r\n            prop.put(\"contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            prop.put(\"num-results_totalcount\", 0);\r\n            prop.put(\"num-results_offset\", 0);\r\n            prop.put(\"num-results_itemsPerPage\", 10);\r\n            prop.put(\"geoinfo\", \"0\");\r\n            prop.put(\"rss_queryenc\", \"\");\r\n            prop.put(\"meanCount\", 5);\r\n            return prop;\r\n        }\r\n\r\n        // check for JSONP\r\n        if (post.containsKey(\"callback\")) {\r\n        \tfinal String jsonp = post.get(\"callback\")+ \"([\";\r\n        \tprop.put(\"jsonp-start\", jsonp);\r\n        \tprop.put(\"jsonp-end\", \"])\");\r\n        } else {\r\n        \tprop.put(\"jsonp-start\", \"\");\r\n        \tprop.put(\"jsonp-end\", \"\");\r\n        }\r\n\r\n        // Adding CORS Access header for yacysearch.rss output\r\n        if (rss) {\r\n            final ResponseHeader outgoingHeader = new ResponseHeader();\r\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\r\n            prop.setOutgoingHeader(outgoingHeader);\r\n        }\r\n\r\n        // collect search attributes\r\n        final boolean newsearch =post.hasValue(\"query\") && post.hasValue(\"former\") && !post.get(\"query\",\"\").equalsIgnoreCase(post.get(\"former\",\"\")); //new search term\r\n\r\n        int itemsPerPage = Math.min((authenticated) ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 100 : 5000) : (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000), post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = (newsearch) ? 0 : post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n\r\n        final int newcount;\r\n        if ( authenticated && (newcount = post.getInt(\"count\", 0)) > 0 ) {\r\n            sb.setConfig(SwitchboardConstants.SEARCH_ITEMS, newcount);\r\n        } // set new default maximumRecords if search with \"more options\"\r\n\r\n        boolean global = post.get(\"resource\", \"local\").equals(\"global\") && sb.peers.sizeConnected() > 0;\r\n        final boolean indexof = (post != null && post.get(\"indexof\",\"\").equals(\"on\"));\r\n\r\n        final String originalUrlMask;\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) { // option search all\r\n            originalUrlMask = \".*\";\r\n        } else if (!newsearch && post.containsKey(\"urlmaskfilter\")) {\r\n            originalUrlMask = post.get(\"urlmaskfilter\", \".*\");\r\n        } else {\r\n            originalUrlMask = \".*\";\r\n        }\r\n\r\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        if (!prefermask.isEmpty() && prefermask.indexOf(\".*\") < 0) {\r\n            prefermask = \".*\" + prefermask + \".*\";\r\n        }\r\n\r\n        Bitfield constraint = (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty()) ? new Bitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new Bitfield(4);\r\n            constraint.set(Condenser.flag_cat_indexof, true);\r\n        }\r\n\r\n        // SEARCH\r\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW, true) ||\r\n                sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_AUTODISABLED, true);\r\n        global = global && indexReceiveGranted; // if the user does not want indexes from remote peers, it cannot be a global search\r\n\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n                (sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\tsb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        if (clustersearch) {\r\n            global = true;\r\n        } // switches search on, but search target is limited to cluster nodes\r\n\r\n        // increase search statistic counter\r\n        if (!global) {\r\n            // we count only searches on the local peer here, because global searches\r\n            // are counted on the target peer to preserve privacy of the searcher\r\n            if (authenticated) {\r\n                // local or authenticated search requests are counted separately\r\n                // because they are not part of a public available peer statistic\r\n                sb.searchQueriesRobinsonFromLocal++;\r\n            } else {\r\n                // robinson-searches from non-authenticated requests are public\r\n                // and may be part of the public available statistic\r\n                sb.searchQueriesRobinsonFromRemote++;\r\n            }\r\n        }\r\n\r\n        // find search domain\r\n        final ContentDomain contentdom = ContentDomain.contentdomParser(post == null ? \"text\" : post.get(\"contentdom\", \"text\"));\r\n\r\n        // patch until better search profiles are available\r\n        if ((contentdom != ContentDomain.TEXT) && (itemsPerPage <= 32)) {\r\n            itemsPerPage = 64;\r\n        }\r\n\r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) {\r\n            trackerHandles = new TreeSet<Long>();\r\n        }\r\n        boolean block = false;\r\n        if (Domains.matchesList(client, sb.networkBlacklist)) {\r\n            global = false;\r\n            if (snippetFetchStrategy != null) {\r\n                snippetFetchStrategy = null;\r\n            }\r\n            block = true;\r\n            Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \" + client + \" gets no permission to search\");\r\n        } else if (Domains.matchesList(client, sb.networkWhitelist)) {\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \" + client + \" gets no search restrictions\");\r\n        } else if (!authenticated && !localhostAccess) {\r\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\r\n            synchronized (trackerHandles) {\r\n                final int accInThreeSeconds = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\r\n                final int accInOneMinute = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\r\n                final int accInTenMinutes = trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\r\n                // protections against too strong YaCy network load, reduces remote search\r\n                if (global) {\r\n                    if (accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1) {\r\n                        global = false;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed global search\");\r\n                    }\r\n                }\r\n                // protection against too many remote server snippet loads (protects traffic on server)\r\n                if (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()) {\r\n                    if (accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1) {\r\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\r\n                        Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed remote snippet loading\");\r\n                    }\r\n                }\r\n                // general load protection\r\n                if (accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60) {\r\n                    block = true;\r\n                    Log.logWarning(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \" + client + \": \" + accInThreeSeconds + \"/3s, \" + accInOneMinute + \"/60s, \" + accInTenMinutes + \"/600s, \" + \" requests, disallowed search\");\r\n                }\r\n            }\r\n        }\r\n\r\n        if ((!block) && (post == null || post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            String urlmask = null;\r\n\r\n            // check available memory and clean up if necessary\r\n            if (!MemoryControl.request(8000000L, false)) {\r\n                indexSegment.urlMetadata().clearCache();\r\n                SearchEventCache.cleanupEvents(true);\r\n            }\r\n\r\n            final RankingProfile ranking = sb.getRanking();\r\n\r\n            if (querystring.indexOf(\"/near\") >= 0) {\r\n            \tquerystring = querystring.replace(\"/near\", \"\");\r\n            \tranking.coeff_worddistance = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/date\") >= 0) {\r\n                querystring = querystring.replace(\"/date\", \"\");\r\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\r\n            }\r\n            if (querystring.indexOf(\"/http\") >= 0) {\r\n                querystring = querystring.replace(\"/http\", \"\");\r\n                urlmask = \"http://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/https\") >= 0) {\r\n                querystring = querystring.replace(\"/https\", \"\");\r\n                urlmask = \"https://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/ftp\") >= 0) {\r\n                querystring = querystring.replace(\"/ftp\", \"\");\r\n                urlmask = \"ftp://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/smb\") >= 0) {\r\n                querystring = querystring.replace(\"/smb\", \"\");\r\n                urlmask = \"smb://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/file\") >= 0) {\r\n                querystring = querystring.replace(\"/file\", \"\");\r\n                urlmask = \"file://.*\";\r\n            }\r\n            if (querystring.indexOf(\"/location\") >= 0) {\r\n                querystring = querystring.replace(\"/location\", \"\");\r\n                if (constraint == null) {\r\n                    constraint = new Bitfield(4);\r\n                }\r\n                constraint.set(Condenser.flag_cat_haslocation, true);\r\n            }\r\n            final int lrp = querystring.indexOf(\"/language/\");\r\n            String lr = \"\";\r\n            if (lrp >= 0) {\r\n                if (querystring.length() >= (lrp + 11)) {\r\n                    lr = querystring.substring(lrp + 9, lrp + 11);\r\n                }\r\n\r\n                querystring = querystring.replace(\"/language/\" + lr, \"\");\r\n                lr = lr.toLowerCase();\r\n            }\r\n            final int inurl = querystring.indexOf(\"inurl:\");\r\n            if (inurl >= 0) {\r\n                int ftb = querystring.indexOf(' ', inurl);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                final String urlstr = querystring.substring(inurl + 6, ftb);\r\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\r\n                if (!urlstr.isEmpty()) {\r\n                    urlmask = \".*\" + urlstr + \".*\";\r\n                }\r\n            }\r\n            final int filetype = querystring.indexOf(\"filetype:\");\r\n            if (filetype >= 0) {\r\n                int ftb = querystring.indexOf(' ', filetype);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String ft = querystring.substring(filetype + 9, ftb);\r\n                querystring = querystring.replace(\"filetype:\" + ft, \"\");\r\n                while (!ft.isEmpty() && ft.charAt(0) == '.') ft = ft.substring(1);\r\n                if (!ft.isEmpty()) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\\\\.\" + ft;\r\n                    } else {\r\n                        urlmask = urlmask + \".*\\\\.\" + ft;\r\n                    }\r\n                }\r\n            }\r\n            String tenant = null;\r\n            if (post.containsKey(\"tenant\")) {\r\n                tenant = post.get(\"tenant\");\r\n                if (tenant != null && tenant.isEmpty()) {\r\n                    tenant = null;\r\n                }\r\n                if (tenant != null) {\r\n                    if (urlmask == null) {\r\n                        urlmask = \".*\" + tenant + \".*\";\r\n                    } else urlmask = \".*\" + tenant + urlmask;\r\n                }\r\n            }\r\n            final int site = querystring.indexOf(\"site:\");\r\n            String sitehash = null;\r\n            String sitehost = null;\r\n            if (site >= 0) {\r\n                int ftb = querystring.indexOf(' ', site);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                sitehost = querystring.substring(site + 5, ftb);\r\n                querystring = querystring.replace(\"site:\" + sitehost, \"\");\r\n                while (sitehost.length() > 0 && sitehost.charAt(0) == '.') {\r\n                    sitehost = sitehost.substring(1);\r\n                }\r\n                while (sitehost.endsWith(\".\")) {\r\n                    sitehost = sitehost.substring(0, sitehost.length() - 1);\r\n                }\r\n                sitehash = DigestURI.hosthash(sitehost);\r\n            }\r\n\r\n            final int heuristicScroogle = querystring.indexOf(\"heuristic:scroogle\");\r\n            if (heuristicScroogle >= 0) {\r\n                querystring = querystring.replace(\"heuristic:scroogle\", \"\");\r\n            }\r\n\r\n            final int heuristicBlekko = querystring.indexOf(\"heuristic:blekko\");\r\n            if (heuristicBlekko >= 0) {\r\n                querystring = querystring.replace(\"heuristic:blekko\", \"\");\r\n            }\r\n\r\n            final int authori = querystring.indexOf(\"author:\");\r\n        \tString authorhash = null;\r\n            if (authori >= 0) {\r\n            \t// check if the author was given with single quotes or without\r\n            \tfinal boolean quotes = (querystring.charAt(authori + 7) == (char) 39);\r\n            \tString author;\r\n            \tif (quotes) {\r\n                    int ftb = querystring.indexOf((char) 39, authori + 8);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length() + 1;\r\n                    }\r\n                    author = querystring.substring(authori + 8, ftb);\r\n                    querystring = querystring.replace(\"author:'\" + author + \"'\", \"\");\r\n            \t} else {\r\n                    int ftb = querystring.indexOf(' ', authori);\r\n                    if (ftb == -1) {\r\n                        ftb = querystring.length();\r\n                    }\r\n                    author = querystring.substring(authori + 7, ftb);\r\n                    querystring = querystring.replace(\"author:\" + author, \"\");\r\n            \t}\r\n            \tauthorhash = ASCII.String(Word.word2hash(author));\r\n            }\r\n            final int tld = querystring.indexOf(\"tld:\");\r\n            if (tld >= 0) {\r\n                int ftb = querystring.indexOf(' ', tld);\r\n                if (ftb == -1) {\r\n                    ftb = querystring.length();\r\n                }\r\n                String domain = querystring.substring(tld + 4, ftb);\r\n                querystring = querystring.replace(\"tld:\" + domain, \"\");\r\n                while (domain.length() > 0 && domain.charAt(0) == '.') {\r\n                    domain = domain.substring(1);\r\n                }\r\n                if (domain.indexOf('.') < 0) {\r\n                    domain = \"\\\\.\" + domain;\r\n                } // is tld\r\n                if (domain.length() > 0) {\r\n                    urlmask = \"[a-zA-Z]*://[^/]*\" + domain + \"/.*\" + ((urlmask != null) ? urlmask : \"\");\r\n                }\r\n            }\r\n            if (urlmask == null || urlmask.isEmpty()) {\r\n                urlmask = originalUrlMask;\r\n            } //if no urlmask was given\r\n\r\n            // read the language from the language-restrict option 'lr'\r\n            // if no one is given, use the user agent or the system language as default\r\n            String language = (post == null) ? lr : post.get(\"lr\", lr);\r\n            if (language.startsWith(\"lang_\")) {\r\n                language = language.substring(5);\r\n            }\r\n            if (!ISO639.exists(language)) {\r\n                // find out language of the user by reading of the user-agent string\r\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\r\n                if (agent == null) {\r\n                    agent = System.getProperty(\"user.language\");\r\n                }\r\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\r\n                if (language == null) {\r\n                    language = \"en\";\r\n                }\r\n            }\r\n\r\n            // navigation\r\n            final String navigation = (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"\");\r\n\r\n            // the query\r\n            final TreeSet<String>[] query = QueryParams.cleanQuery(querystring.trim()); // converts also umlaute\r\n\r\n            final int maxDistance = (querystring.indexOf('\"') >= 0) ? query.length - 1 : Integer.MAX_VALUE;\r\n\r\n            // filter out stopwords\r\n            final SortedSet<String> filtered = SetTools.joinConstructive(query[0], Switchboard.stopwords);\r\n            if (!filtered.isEmpty()) {\r\n                SetTools.excludeDestructive(query[0], Switchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post != null && post.containsKey(\"deleteref\")) {\r\n                try {\r\n                    if (!sb.verifyAuthentication(header, true)) {\r\n                        prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                        return prop;\r\n                    }\r\n\r\n                    // delete the index entry locally\r\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                    indexSegment.termIndex().remove(Word.words2hashesHandles(query[0]), delHash.getBytes());\r\n\r\n                    // make new news message with negative voting\r\n                    if (!sb.isRobinsonMode()) {\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"urlhash\", delHash);\r\n                        map.put(\"vote\", \"negative\");\r\n                        map.put(\"refid\", \"\");\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map);\r\n                    }\r\n                } catch (final IOException e) {\r\n                    Log.logException(e);\r\n                }\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post != null && post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                final URIMetadataRow urlentry = indexSegment.urlMetadata().load(UTF8.getBytes(recommendHash));\r\n                if (urlentry != null) {\r\n                    final URIMetadataRow.Components metadata = urlentry.metadata();\r\n                    Document[] documents = null;\r\n                    try {\r\n                        documents = sb.loader.loadDocuments(sb.loader.request(metadata.url(), true, false), CacheStrategy.IFEXIST, 5000, Integer.MAX_VALUE);\r\n                    } catch (final IOException e) {\r\n                    } catch (final Parser.Failure e) {\r\n                    }\r\n                    if (documents != null) {\r\n                        // create a news message\r\n                        final Map<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", metadata.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", metadata.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\r\n                        map.put(\"author\", documents[0].dc_creator());\r\n                        map.put(\"tags\", documents[0].dc_subject(' '));\r\n                        sb.peers.newsPool.publishMyNews(sb.peers.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_ADD, map);\r\n                        documents[0].close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean globalsearch = (global) && indexReceiveGranted;\r\n\r\n            // do the search\r\n            final HandleSet queryHashes = Word.words2hashesHandles(query[0]);\r\n            final Pattern snippetPattern = QueryParams.stringSearchPattern(originalquerystring);\r\n\r\n            // check filters\r\n            try {\r\n                Pattern.compile(urlmask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal URL mask, not a valid regex: \" + urlmask);\r\n                prop.put(\"urlmaskerror\", 1);\r\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\r\n                urlmask = \".*\";\r\n            }\r\n\r\n            try {\r\n                Pattern.compile(prefermask);\r\n            } catch (final PatternSyntaxException ex) {\r\n                Log.logWarning(\"SEARCH\", \"Illegal prefer mask, not a valid regex: \" + prefermask);\r\n                prop.put(\"prefermaskerror\", 1);\r\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\r\n                prefermask = \"\";\r\n            }\r\n\r\n            final QueryParams theQuery = new QueryParams(\r\n                    originalquerystring,\r\n                    queryHashes,\r\n                    Word.words2hashesHandles(query[1]),\r\n                    Word.words2hashesHandles(query[2]),\r\n                    snippetPattern,\r\n                    tenant,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdom,\r\n                    language,\r\n                    navigation,\r\n                    snippetFetchStrategy,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? QueryParams.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? QueryParams.SEARCHDOM_GLOBALDHT : QueryParams.SEARCHDOM_LOCAL),\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    sitehash,\r\n                    authorhash,\r\n                    DigestURI.TLD_any_zone_filter,\r\n                    client,\r\n                    authenticated,\r\n                    indexSegment,\r\n                    ranking,\r\n                    header.get(RequestHeader.USER_AGENT, \"\"),\r\n                    sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false) && sb.peers.mySeed().getFlagAcceptRemoteIndex());\r\n            EventTracker.delete(EventTracker.EClass.SEARCH);\r\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(theQuery.id(true), SearchEvent.Type.INITIALIZATION, \"\", 0, 0), false);\r\n\r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(3000);\r\n\r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(Switchboard.blueList);\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + QueryParams.hashSet2hashString(theQuery.queryHashes) + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            yacyChannel.channels(yacyChannel.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            final long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (SearchEventCache.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\r\n                offset = 0;\r\n            }\r\n            final SearchEvent theSearch = SearchEventCache.getEvent(\r\n                theQuery, sb.peers, sb.tables, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false, sb.loader,\r\n                (int) sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\r\n                      sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_USER, sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_ROBINSON, 0),\r\n                (int) sb.getConfigLong(SwitchboardConstants.DHT_BURST_MULTIWORD, 0));\r\n\r\n            if (offset == 0) {\r\n                if (sitehost != null && sb.getConfigBool(\"heuristic.site\", false) && authenticated) {\r\n                    sb.heuristicSite(theSearch, sitehost);\r\n                }\r\n                if ((heuristicScroogle >= 0  || sb.getConfigBool(\"heuristic.scroogle\", false)) && authenticated) {\r\n                    sb.heuristicScroogle(theSearch);\r\n                }\r\n                if ((heuristicBlekko >= 0  || sb.getConfigBool(\"heuristic.blekko\", false)) && authenticated) {\r\n                    sb.heuristicRSS(\"http://blekko.com/ws/$+/rss\", theSearch, \"blekko\");\r\n                }\r\n            }\r\n\r\n            // log\r\n            Log.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    \"local-unfiltered(\" + theSearch.getRankingResult().getLocalIndexCount() + \"), \" +\r\n                    \"-local_miss(\" + theSearch.getRankingResult().getMissCount() + \"), \" +\r\n                    \"-local_sortout(\" + theSearch.getRankingResult().getSortOutCount() + \"), \" +\r\n                    \"remote(\" + theSearch.getRankingResult().getRemoteResourceSize() + \") links found, \" +\r\n                    (System.currentTimeMillis() - timestamp) + \" ms\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.result().getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.result().getSnippetComputationTime();\r\n            AccessTracker.add(AccessTracker.Location.local, theQuery);\r\n\r\n            // check suggestions\r\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\r\n\r\n            prop.put(\"meanCount\", meanMax);\r\n            if (meanMax > 0 && !json && !rss) {\r\n                final DidYouMean didYouMean = new DidYouMean(indexSegment.termIndex(), querystring);\r\n            \tfinal Iterator<String> meanIt = didYouMean.getSuggestions(100, 5).iterator();\r\n                int meanCount = 0;\r\n                String suggestion;\r\n                while( meanCount<meanMax && meanIt.hasNext()) {\r\n                    suggestion = meanIt.next();\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_word\", suggestion);\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_url\",\r\n                            QueryParams.navurl(\"html\", 0, theQuery, suggestion, originalUrlMask.toString(), theQuery.navigators).toString()\r\n    \t             );\r\n                    prop.put(\"didYouMean_suggestions_\"+meanCount+\"_sep\",\"|\");\r\n                    meanCount++;\r\n                }\r\n                prop.put(\"didYouMean_suggestions_\"+(meanCount-1)+\"_sep\",\"\");\r\n                prop.put(\"didYouMean\", meanCount>0 ? 1:0);\r\n                prop.put(\"didYouMean_suggestions\", meanCount);\r\n            } else {\r\n                prop.put(\"didYouMean\", 0);\r\n            }\r\n\r\n            // find geographic info\r\n            final SortedSet<Location> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\r\n            if (coordinates == null || coordinates.isEmpty() || offset > 0) {\r\n                prop.put(\"geoinfo\", \"0\");\r\n            } else {\r\n                int i = 0;\r\n                for (final Location c: coordinates) {\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\r\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\r\n                    i++;\r\n                    if (i >= 10) break;\r\n                }\r\n                prop.put(\"geoinfo_loc\", i);\r\n                prop.put(\"geoinfo\", \"1\");\r\n            }\r\n\r\n            // update the search tracker\r\n            try {\r\n                synchronized (trackerHandles) {\r\n                    trackerHandles.add(theQuery.time);\r\n                    while (trackerHandles.size() > 600) {\r\n                        if (!trackerHandles.remove(trackerHandles.first())) break;\r\n                    }\r\n                }\r\n                sb.localSearchTracker.put(client, trackerHandles);\r\n            \tif (sb.localSearchTracker.size() > 100) {\r\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\r\n                }\r\n            \tif (MemoryControl.shortStatus()) sb.localSearchTracker.clear();\r\n            } catch (final Exception e) {\r\n                Log.logException(e);\r\n            }\r\n\r\n            final int indexcount = theSearch.getRankingResult().getLocalIndexCount() - theSearch.getRankingResult().getMissCount() - theSearch.getRankingResult().getSortOutCount() + theSearch.getRankingResult().getRemoteIndexCount();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", Formatter.number(0, true));\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", Formatter.number(indexcount, true));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.getRankingResult().getLocalIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_localMissCount\", Formatter.number(theSearch.getRankingResult().getMissCount(), true));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.getRankingResult().getRemoteResourceSize(), true));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.getRankingResult().getRemoteIndexCount(), true));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.getRankingResult().getRemotePeerCount(), true));\r\n\r\n            // compose page navigation\r\n            final StringBuilder resnav = new StringBuilder();\r\n            final int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n            } else {\r\n            \tresnav.append(\"<a id=\\\"prevpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage - 1, theQuery, null, originalUrlMask, navigation).toString());\r\n            \tresnav.append(\"\\\"><img src=\\\"env/grafics/navdl.gif\\\" alt=\\\"arrowleft\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n            }\r\n            final int numberofpages = Math.min(10, 1 + ((indexcount - 1) / theQuery.displayResults()));\r\n\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<img src=\\\"env/grafics/navs\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" />&nbsp;\");\r\n                } else {\r\n                    resnav.append(\"<a href=\\\"\");\r\n                    resnav.append(QueryParams.navurl(\"html\", i, theQuery, null, originalUrlMask, navigation).toString());\r\n                    resnav.append(\"\\\"><img src=\\\"env/grafics/navd\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\".gif\\\" alt=\\\"page\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) {\r\n            \tresnav.append(\"<img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" />\");\r\n            } else {\r\n                resnav.append(\"<a id=\\\"nextpage\\\" href=\\\"\");\r\n                resnav.append(QueryParams.navurl(\"html\", thispage + 1, theQuery, null, originalUrlMask, navigation).toString());\r\n                resnav.append(\"\\\"><img src=\\\"env/grafics/navdr.gif\\\" alt=\\\"arrowright\\\" width=\\\"16\\\" height=\\\"16\\\" /><\/a>\");\r\n            }\r\n            final String resnavs = resnav.toString();\r\n            prop.put(\"num-results_resnav\", resnavs);\r\n            prop.put(\"pageNavBottom\", (indexcount - offset > 6) ? 1 : 0); // if there are more results than may fit on the page we add a navigation at the bottom\r\n            prop.put(\"pageNavBottom_resnav\", resnavs);\r\n\r\n            // generate the search result lines; the content will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n\r\n            // process result of search\r\n            if (!filtered.isEmpty()) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.isEmpty()) {\r\n                if (post.get(\"query\", post.get(\"search\", \"\")).length() < 2) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"cat\", \"href\");\r\n            prop.put(\"depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(':') == -1) {\r\n                hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8090\"));\r\n            }\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n\r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.putHTML(\"former\", originalquerystring);\r\n        prop.put(\"count\", itemsPerPage);\r\n        prop.put(\"offset\", offset);\r\n        prop.put(\"resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"urlmaskfilter\", originalUrlMask);\r\n        prop.putHTML(\"prefermaskfilter\", prefermask);\r\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\r\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\r\n        prop.put(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\r\n        prop.put(\"searchdomswitches\", sb.getConfigBool(\"search.text\", true) || sb.getConfigBool(\"search.audio\", true) || sb.getConfigBool(\"search.video\", true) || sb.getConfigBool(\"search.image\", true) || sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext\", sb.getConfigBool(\"search.text\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchaudio\", sb.getConfigBool(\"search.audio\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchvideo\", sb.getConfigBool(\"search.video\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchimage\", sb.getConfigBool(\"search.image\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchapp\", sb.getConfigBool(\"search.app\", true) ? 1 : 0);\r\n        prop.put(\"searchdomswitches_searchtext_check\", (contentdom == ContentDomain.TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchaudio_check\", (contentdom == ContentDomain.AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchvideo_check\", (contentdom == ContentDomain.VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchimage_check\", (contentdom == ContentDomain.IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"searchdomswitches_searchapp_check\", (contentdom == ContentDomain.APP) ? \"1\" : \"0\");\r\n\r\n        // copy properties for \"more options\" link\r\n        prop.put(\"searchdomswitches_count\", prop.get(\"count\"));\r\n        prop.put(\"searchdomswitches_urlmaskfilter\", prop.get(\"urlmaskfilter\"));\r\n        prop.put(\"searchdomswitches_prefermaskfilter\", prop.get(\"prefermaskfilter\"));\r\n        prop.put(\"searchdomswitches_cat\", prop.get(\"cat\"));\r\n        prop.put(\"searchdomswitches_constraint\", prop.get(\"constraint\"));\r\n        prop.put(\"searchdomswitches_contentdom\", prop.get(\"contentdom\"));\r\n        prop.put(\"searchdomswitches_former\", prop.get(\"former\"));\r\n        prop.put(\"searchdomswitches_meanCount\", prop.get(\"meanCount\"));\r\n\r\n        // for RSS: don't HTML encode some elements\r\n        prop.putXML(\"rss_query\", originalquerystring);\r\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n\r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"594d8f546afdfdc1dd947c4e23dc4deba597eb69","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tboolean needsGeneration = true;\n\t\t// If the browser has requested this image, then it will send this header\n\t\tif (ctx.getHeaders().containsKey(\"if-modified-since\")) {\n\t\t\ttry {\n\t\t\t\t// If the received date is equal to the last modification of this class, then it doesn't need regeneration\n\t\t\t\tif (ToadletContextImpl.parseHTTPDate(ctx.getHeaders().get(\"if-modified-since\")).compareTo(LAST_MODIFIED) == 0) {\n\t\t\t\t\t// So we just send the NOT_MODIFIED response, and skip the generation\n\t\t\t\t\tctx.sendReplyHeaders(304, \"Not Modified\", null, \"image/png\", 0, LAST_MODIFIED);\n\t\t\t\t\tneedsGeneration = false;\n\t\t\t\t}\n\t\t\t} catch (ParseException pe) {\n\t\t\t\t// If something goes wrong, we regenerate\n\t\t\t}\n\t\t}\n\t\tif (needsGeneration) {\n\t\t\t// The text that will be drawn\n\t\t\tString text = req.getParam(\"text\");\n\t\t\t// If width or height is specified, we use it, if not, then we use the default\n\t\t\tint requiredWidth = req.getParam(\"width\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"width\")) : DEFAULT_WIDTH;\n\t\t\tint requiredHeight = req.getParam(\"height\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"height\")) : DEFAULT_HEIGHT;\n\t\t\t// This is the image we are making\n\t\t\tBufferedImage buffer = new BufferedImage(requiredWidth, requiredHeight, BufferedImage.TYPE_INT_RGB);\n\t\t\tGraphics2D g2 = buffer.createGraphics();\n\t\t\tg2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\t\t\tFontRenderContext fc = g2.getFontRenderContext();\n\t\t\t// We then specify the maximum font size that fits in the image\n\t\t\t// For this, we start at 1, and increase it, until it overflows. This-1 will be the font size\n\t\t\tfloat size = 1;\n\t\t\tg2.setFont(g2.getFont().deriveFont(size));\n\t\t\tint width = 0;\n\t\t\tint height = 0;\n\t\t\twhile (width < requiredWidth && height < requiredHeight) {\n\t\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\n\t\t\t\t// calculate the size of the text\n\t\t\t\twidth = (int) bounds.getWidth();\n\t\t\t\theight = (int) bounds.getHeight();\n\t\t\t\tg2.setFont(g2.getFont().deriveFont(++size));\n\t\t\t}\n\t\t\tg2.setFont(g2.getFont().deriveFont(size - 1));\n\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\t\t\t// actually do the drawing\n\t\t\tg2.setColor(new Color(0, 0, 0));\n\t\t\tg2.fillRect(0, 0, width, height);\n\t\t\tg2.setColor(new Color(255, 255, 255));\n\t\t\t// We position it to the center. Note that this is not the upper left corner\n\t\t\tg2.drawString(text, (int) (requiredWidth / 2 - bounds.getWidth() / 2), (int) (requiredHeight / 2 + bounds.getHeight() / 4));\n\n\t\t\t// Write the data, and send the modification data to let the client cache it\n\t\t\tBucket data = ctx.getBucketFactory().makeBucket(-1);\n\t\t\tImageIO.write(buffer, \"png\", data.getOutputStream());\n\t\t\tctx.sendReplyHeaders(200, \"OK\", null, \"image/png\", data.size(), LAST_MODIFIED);\n\t\t\tctx.writeData(data);\n\t\t}\n\t}","id":71148,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tboolean needsGeneration = true;\n\t\t// If the browser has requested this image, then it will send this header\n\t\tif (ctx.getHeaders().containsKey(\"if-modified-since\")) {\n\t\t\ttry {\n\t\t\t\t// If the received date is equal to the last modification of this class, then it doesn't need regeneration\n\t\t\t\tif (ToadletContextImpl.parseHTTPDate(ctx.getHeaders().get(\"if-modified-since\")).compareTo(LAST_MODIFIED) == 0) {\n\t\t\t\t\t// So we just send the NOT_MODIFIED response, and skip the generation\n\t\t\t\t\tctx.sendReplyHeaders(304, \"Not Modified\", null, \"image/png\", 0, LAST_MODIFIED);\n\t\t\t\t\tneedsGeneration = false;\n\t\t\t\t}\n\t\t\t} catch (ParseException pe) {\n\t\t\t\t// If something goes wrong, we regenerate\n\t\t\t}\n\t\t}\n\t\tif (needsGeneration) {\n\t\t\t// The text that will be drawn\n\t\t\tString text = req.getParam(\"text\");\n\t\t\t// If width or height is specified, we use it, if not, then we use the default\n\t\t\tint requiredWidth = req.getParam(\"width\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"width\")) : DEFAULT_WIDTH;\n\t\t\tint requiredHeight = req.getParam(\"height\").compareTo(\"\") != 0 ? Integer.parseInt(req.getParam(\"height\")) : DEFAULT_HEIGHT;\n\t\t\t// This is the image we are making\n\t\t\tBufferedImage buffer = new BufferedImage(requiredWidth, requiredHeight, BufferedImage.TYPE_INT_RGB);\n\t\t\tGraphics2D g2 = buffer.createGraphics();\n\t\t\tg2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n\t\t\tFontRenderContext fc = g2.getFontRenderContext();\n\t\t\t// We then specify the maximum font size that fits in the image\n\t\t\t// For this, we start at 1, and increase it, until it overflows. This-1 will be the font size\n\t\t\tfloat size = 1;\n\t\t\tg2.setFont(g2.getFont().deriveFont(size));\n\t\t\tint width = 0;\n\t\t\tint height = 0;\n\t\t\twhile (width < requiredWidth && height < requiredHeight) {\n\t\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\n\t\t\t\t// calculate the size of the text\n\t\t\t\twidth = (int) bounds.getWidth();\n\t\t\t\theight = (int) bounds.getHeight();\n\t\t\t\tg2.setFont(g2.getFont().deriveFont(++size));\n\t\t\t}\n\t\t\tg2.setFont(g2.getFont().deriveFont(size - 1));\n\t\t\tRectangle2D bounds = g2.getFont().getStringBounds(text, fc);\n\t\t\t// actually do the drawing\n\t\t\tg2.setColor(new Color(0, 0, 0));\n\t\t\tg2.fillRect(0, 0, width, height);\n\t\t\tg2.setColor(new Color(255, 255, 255));\n\t\t\t// We position it to the center. Note that this is not the upper left corner\n\t\t\tg2.drawString(text, (int) (requiredWidth / 2 - bounds.getWidth() / 2), (int) (requiredHeight / 2 + bounds.getHeight() / 4));\n\n\t\t\t// Write the data, and send the modification data to let the client cache it\n\t\t\tBucket data = ctx.getBucketFactory().makeBucket(-1);\n\t\t\tImageIO.write(buffer, \"png\", data.getOutputStream());\n\t\t\tMultiValueTable<String, String> headers=new MultiValueTable<String, String>();\n\t\t\theaders.put(\"Cache-Control\", \"no-store\");\n\t\t\tctx.sendReplyHeaders(200, \"OK\", headers, \"image/png\", data.size(), LAST_MODIFIED);\n\t\t\tctx.writeData(data);\n\t\t}\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"Updating ImageElement for url:\" + key);\n\t\t}\n\t\tchildren.clear();\n\t\tHTMLNode whenJsEnabled = new HTMLNode(\"span\", \"class\", \"jsonly ImageElement\");\n\t\taddChild(whenJsEnabled);\n\t\tFProxyFetchResult fr = null;\n\t\tFProxyFetchWaiter waiter = null;\n\t\ttry {\n\t\t\ttry {\n\t\t\t\twaiter = tracker.makeFetcher(key, maxSize);\n\t\t\t\tfr = waiter.getResultFast();\n\t\t\t} catch (FetchException fe) {\n\t\t\t\twhenJsEnabled.addChild(\"div\", \"error\");\n\t\t\t}\n\t\t\tif (fr == null) {\n\t\t\t\twhenJsEnabled.addChild(\"div\", \"No fetcher found\");\n\t\t\t} else {\n\n\t\t\t\tif (fr.isFinished() && fr.hasData()) {\n\t\t\t\t\tif (logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"ImageElement is completed\");\n\t\t\t\t\t}\n\t\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(originalImg));\n\t\t\t\t} else if (fr.failed != null) {\n\t\t\t\t\tif (logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"ImageElement is errorous\");\n\t\t\t\t\t}\n\t\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(originalImg));\n\t\t\t\t} else {\n\t\t\t\t\tif (logMINOR) {\n\t\t\t\t\t\tLogger.minor(this, \"ImageElement is still in progress\");\n\t\t\t\t\t}\n\t\t\t\t\tint total = fr.requiredBlocks;\n\t\t\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\t\t\tMap<String, String> attr = originalImg.getAttributesAsMap();\n\t\t\t\t\tString sizePart = new String();\n\t\t\t\t\tif (attr.containsKey(\"width\") && attr.containsKey(\"height\")) {\n\t\t\t\t\t\tsizePart = \"&width=\" + attr.get(\"width\") + \"&height=\" + attr.get(\"height\");\n\t\t\t\t\t}\n\t\t\t\t\tattr.put(\"src\", \"/imagecreator/?text=\" + fetchedPercent + \"%25\" + sizePart);\n\t\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(new ParsedTag(originalImg, attr)));\n\t\t\t\t\twhenJsEnabled.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"fetchedBlocks\", String.valueOf(fr.fetchedBlocks) });\n\t\t\t\t\twhenJsEnabled.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"requiredBlocks\", String.valueOf(fr.requiredBlocks) });\n\t\t\t\t}\n\t\t\t}\n\t\t\t// When js disabled\n\t\t\taddChild(\"noscript\").addChild(makeHtmlNodeForParsedTag(originalImg));\n\t\t} finally {\n\t\t\tif (waiter != null) {\n\t\t\t\ttracker.getFetchInProgress(key, maxSize).close(waiter);\n\t\t\t}\n\t\t\tif (fr != null) {\n\t\t\t\ttracker.getFetchInProgress(key, maxSize).close(fr);\n\t\t\t}\n\t\t}\n\t}","id":71149,"modified_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"Updating ImageElement for url:\" + key);\n\t\t}\n\t\tchildren.clear();\n\t\tHTMLNode whenJsEnabled = new HTMLNode(\"span\", \"class\", \"jsonly ImageElement\");\n\t\taddChild(whenJsEnabled);\n\t\t// When js disabled\n\t\taddChild(\"noscript\").addChild(makeHtmlNodeForParsedTag(originalImg));\n\t\tif (initial) {\n\t\t\tif (wasError) {\n\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(originalImg));\n\t\t\t} else {\n\t\t\t\tMap<String, String> attr = originalImg.getAttributesAsMap();\n\t\t\t\tString sizePart = new String();\n\t\t\t\tif (attr.containsKey(\"width\") && attr.containsKey(\"height\")) {\n\t\t\t\t\tsizePart = \"&width=\" + attr.get(\"width\") + \"&height=\" + attr.get(\"height\");\n\t\t\t\t}\n\t\t\t\tattr.put(\"src\", \"/imagecreator/?text=+\"+FProxyToadlet.l10n(\"imageinitializing\")+\"+\" + sizePart);\n\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(new ParsedTag(originalImg, attr)));\n\t\t\t\twhenJsEnabled.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"fetchedBlocks\", String.valueOf(0) });\n\t\t\t\twhenJsEnabled.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"requiredBlocks\", String.valueOf(1) });\n\n\t\t\t}\n\t\t} else {\n\t\t\tFProxyFetchResult fr = null;\n\t\t\tFProxyFetchWaiter waiter = null;\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\twaiter = tracker.makeFetcher(key, maxSize);\n\t\t\t\t\tfr = waiter.getResultFast();\n\t\t\t\t} catch (FetchException fe) {\n\t\t\t\t\twhenJsEnabled.addChild(\"div\", \"error\");\n\t\t\t\t}\n\t\t\t\tif (fr == null) {\n\t\t\t\t\twhenJsEnabled.addChild(\"div\", \"No fetcher found\");\n\t\t\t\t} else {\n\n\t\t\t\t\tif (fr.isFinished() && fr.hasData()) {\n\t\t\t\t\t\tif (logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"ImageElement is completed\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(originalImg));\n\t\t\t\t\t} else if (fr.failed != null) {\n\t\t\t\t\t\tif (logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"ImageElement is errorous\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(originalImg));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (logMINOR) {\n\t\t\t\t\t\t\tLogger.minor(this, \"ImageElement is still in progress\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tint total = fr.requiredBlocks;\n\t\t\t\t\t\tint fetchedPercent = (int) (fr.fetchedBlocks / (double) total * 100);\n\t\t\t\t\t\tMap<String, String> attr = originalImg.getAttributesAsMap();\n\t\t\t\t\t\tString sizePart = new String();\n\t\t\t\t\t\tif (attr.containsKey(\"width\") && attr.containsKey(\"height\")) {\n\t\t\t\t\t\t\tsizePart = \"&width=\" + attr.get(\"width\") + \"&height=\" + attr.get(\"height\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tattr.put(\"src\", \"/imagecreator/?text=\" + fetchedPercent + \"%25\" + sizePart);\n\t\t\t\t\t\twhenJsEnabled.addChild(makeHtmlNodeForParsedTag(new ParsedTag(originalImg, attr)));\n\t\t\t\t\t\twhenJsEnabled.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"fetchedBlocks\", String.valueOf(fr.fetchedBlocks) });\n\t\t\t\t\t\twhenJsEnabled.addChild(\"input\", new String[] { \"type\", \"name\", \"value\" }, new String[] { \"hidden\", \"requiredBlocks\", String.valueOf(fr.requiredBlocks) });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (waiter != null) {\n\t\t\t\t\ttracker.getFetchInProgress(key, maxSize).close(waiter);\n\t\t\t\t}\n\t\t\t\tif (fr != null) {\n\t\t\t\t\ttracker.getFetchInProgress(key, maxSize).close(fr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"public ImageElement(FProxyFetchTracker tracker, FreenetURI key, long maxSize, ToadletContext ctx, ParsedTag originalImg) throws FetchException {\n\t\tsuper(\"span\", ctx);\n\t\tlong now = System.currentTimeMillis();\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"ImageElement creating for uri:\" + key);\n\t\t}\n\t\tthis.originalImg = originalImg;\n\t\tthis.tracker = tracker;\n\t\tthis.key = key;\n\t\tthis.maxSize = maxSize;\n\t\tinit();\n\t\t// Creates and registers the FetchListener\n\t\tfetchListener = new NotifierFetchListener(((SimpleToadletServer) ctx.getContainer()).pushDataManager, this);\n\t\tFProxyFetchWaiter waiter = tracker.makeFetcher(key, maxSize);\n\t\ttracker.getFetchInProgress(key, maxSize).addListener(fetchListener);\n\t\ttracker.getFetchInProgress(key, maxSize).close(waiter);\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"ImageElement creating finished in:\" + (System.currentTimeMillis() - now) + \" ms\");\n\t\t}\n\t}","id":71150,"modified_method":"public ImageElement(FProxyFetchTracker tracker, FreenetURI key, long maxSize, ToadletContext ctx, ParsedTag originalImg) {\n\t\tsuper(\"span\", ctx);\n\t\tlong now = System.currentTimeMillis();\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"ImageElement creating for uri:\" + key);\n\t\t}\n\t\tthis.originalImg = originalImg;\n\t\tthis.tracker = tracker;\n\t\tthis.key = key;\n\t\tthis.maxSize = maxSize;\n\t\tinit();\n\t\t// Creates and registers the FetchListener\n\t\tfetchListener = new NotifierFetchListener(((SimpleToadletServer) ctx.getContainer()).pushDataManager, this);\n\t\t((SimpleToadletServer) ctx.getContainer()).getTicker().queueTimedJob(new Runnable() {\n\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tFProxyFetchWaiter waiter = ImageElement.this.tracker.makeFetcher(ImageElement.this.key, ImageElement.this.maxSize);\n\t\t\t\t\tImageElement.this.tracker.getFetchInProgress(ImageElement.this.key, ImageElement.this.maxSize).addListener(fetchListener);\n\t\t\t\t\tImageElement.this.tracker.getFetchInProgress(ImageElement.this.key, ImageElement.this.maxSize).close(waiter);\n\t\t\t\t} catch (FetchException fe) {\n\t\t\t\t\tif (fe.newURI != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tImageElement.this.key = fe.newURI;\n\t\t\t\t\t\t\tFProxyFetchWaiter waiter = ImageElement.this.tracker.makeFetcher(ImageElement.this.key, ImageElement.this.maxSize);\n\t\t\t\t\t\t\tImageElement.this.tracker.getFetchInProgress(ImageElement.this.key, ImageElement.this.maxSize).addListener(fetchListener);\n\t\t\t\t\t\t\tImageElement.this.tracker.getFetchInProgress(ImageElement.this.key, ImageElement.this.maxSize).close(waiter);\n\t\t\t\t\t\t} catch (FetchException fe2) {\n\t\t\t\t\t\t\twasError = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfetchListener.onEvent();\n\t\t\t}\n\t\t}, 0);\n\n\t\tif (logMINOR) {\n\t\t\tLogger.minor(this, \"ImageElement creating finished in:\" + (System.currentTimeMillis() - now) + \" ms\");\n\t\t}\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"/** Schedules the next request. It waits more and more as more requests fails, but will try forever. */\n\tprivate void scheduleNextRequest() {\n\t\tnew Timer() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// When run, send a request\n\t\t\t\tsendRequest();\n\t\t\t}\n\t\t}.schedule(Math.min((int) Math.pow(2, (numOfFailedRequests++)), 10000));// Waits more if requests failing, but a max at 10sec\n\t\tFreenetJs.log(\"Next request scheduled\");\n\t}","id":71151,"modified_method":"/** Schedules the next request. It waits more and more as more requests fails, but will try forever. */\n\tprivate void scheduleNextRequest() {\n\t\tnew Timer() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\t// When run, send a request\n\t\t\t\tsendRequest();\n\t\t\t}\n\t\t}.schedule(Math.max(Math.min((int) Math.pow(2, (numOfFailedRequests++)), 10000),50));// Waits more if requests failing, but a max at 10sec\n\t\tFreenetJs.log(\"Next request scheduled\");\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tPageNode pageNode = ctx.getPageMaker().getPageNode(\"Push tester\", false, ctx);\n\t\tfor (int i = 0; i < 3; i++) {\n\t\t\tpageNode.content.addChild(new TesterElement(ctx, String.valueOf(i), i * 2));\n\t\t}\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.outer.generate());\n\t}","id":71152,"modified_method":"@Override\n\tpublic void handleGet(URI uri, HTTPRequest req, ToadletContext ctx) throws ToadletContextClosedException, IOException, RedirectException {\n\t\tPageNode pageNode = ctx.getPageMaker().getPageNode(\"Push tester\", false, ctx);\n\t\tpageNode.content.addChild(new XmlAlertElement(ctx));\n\t\tfor (int i = 0; i < 600; i++) {\n\t\t\tpageNode.content.addChild(new TesterElement(ctx, String.valueOf(i), 100));\n\t\t}\n\t\twriteHTMLReply(ctx, 200, \"OK\", pageNode.outer.generate());\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"public String processTag(ParsedTag pt, URIProcessor uriProcessor) {\n\t\t// If javascript is disabled, then it won't need pushing\n\t\tif (ctx.getContainer().isFProxyJavascriptEnabled()) {\n\t\t\tif (pt.element.compareTo(\"img\") == 0) {\n\t\t\t\t// Img's needs to be replaced with pushed ImageElement's\n\t\t\t\tfor (int i = 0; i < pt.unparsedAttrs.length; i++) {\n\t\t\t\t\tString attr = pt.unparsedAttrs[i];\n\t\t\t\t\tString name = attr.substring(0, attr.indexOf(\"=\"));\n\t\t\t\t\tString value = attr.substring(attr.indexOf(\"=\") + 2, attr.length() - 1);\n\t\t\t\t\tif (name.compareTo(\"src\") == 0) {\n\t\t\t\t\t\tString src;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// We need absolute URI\n\t\t\t\t\t\t\tsrc = uriProcessor.makeURIAbsolute(uriProcessor.processURI(value, null, false, false));\n\t\t\t\t\t\t} catch (CommentException ce) {\n\t\t\t\t\t\t\tsrc = value;\n\t\t\t\t\t\t} catch (URISyntaxException use) {\n\t\t\t\t\t\t\tsrc = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (src.startsWith(\"/\")) {\n\t\t\t\t\t\t\tsrc = src.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Create the ImageElement\n\t\t\t\t\t\t\treturn new ImageElement(tracker, new FreenetURI(src), maxSize, ctx, pt).generate();\n\t\t\t\t\t\t} catch (FetchException fe) {\n\t\t\t\t\t\t\tif(fe.newURI!=null){\n\t\t\t\t\t\t\t\ttry{\n\t\t\t\t\t\t\t\t\treturn new ImageElement(tracker, fe.newURI, maxSize, ctx, pt).generate();\n\t\t\t\t\t\t\t\t}catch(FetchException fe2){\n\t\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (pt.element.compareTo(\"body\") == 0) {\n\t\t\t\t// After the <body>, we need to insert the requestId and the l10n script\n\t\t\t\treturn \"<body>\".concat(new XmlAlertElement(ctx).generate().concat(\"<input id=\\\"requestId\\\" type=\\\"hidden\\\" value=\\\"\" + ctx.getUniqueId() + \"\\\" name=\\\"requestId\\\"/>\")).concat(\"<script type=\\\"text/javascript\\\" language=\\\"javascript\\\">\".concat(getClientSideLocalizationScript()).concat(\"<\/script>\"));\n\t\t\t} else if (pt.element.compareTo(\"head\") == 0) {\n\t\t\t\t// After the <head>, we need to add GWT support\n\t\t\t\treturn \"<head><script type=\\\"text/javascript\\\" language=\\\"javascript\\\" src=\\\"/static/freenetjs/freenetjs.nocache.js\\\"><\/script><noscript><style> .jsonly {display:none;}<\/style><\/noscript>\";\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","id":71153,"modified_method":"public String processTag(ParsedTag pt, URIProcessor uriProcessor) {\n\t\t// If javascript is disabled, then it won't need pushing\n\t\tif (ctx.getContainer().isFProxyJavascriptEnabled()) {\n\t\t\tif (pt.element.compareTo(\"img\") == 0) {\n\t\t\t\t// Img's needs to be replaced with pushed ImageElement's\n\t\t\t\tfor (int i = 0; i < pt.unparsedAttrs.length; i++) {\n\t\t\t\t\tString attr = pt.unparsedAttrs[i];\n\t\t\t\t\tString name = attr.substring(0, attr.indexOf(\"=\"));\n\t\t\t\t\tString value = attr.substring(attr.indexOf(\"=\") + 2, attr.length() - 1);\n\t\t\t\t\tif (name.compareTo(\"src\") == 0) {\n\t\t\t\t\t\tString src;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// We need absolute URI\n\t\t\t\t\t\t\tsrc = uriProcessor.makeURIAbsolute(uriProcessor.processURI(value, null, false, false));\n\t\t\t\t\t\t} catch (CommentException ce) {\n\t\t\t\t\t\t\tsrc = value;\n\t\t\t\t\t\t} catch (URISyntaxException use) {\n\t\t\t\t\t\t\tsrc = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (src.startsWith(\"/\")) {\n\t\t\t\t\t\t\tsrc = src.substring(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// Create the ImageElement\n\t\t\t\t\t\t\treturn new ImageElement(tracker, new FreenetURI(src), maxSize, ctx, pt).generate();\n\t\t\t\t\t\t} catch (MalformedURLException mue) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (pt.element.compareTo(\"body\") == 0) {\n\t\t\t\t// After the <body>, we need to insert the requestId and the l10n script\n\t\t\t\treturn \"<body>\".concat(new XmlAlertElement(ctx).generate().concat(\"<input id=\\\"requestId\\\" type=\\\"hidden\\\" value=\\\"\" + ctx.getUniqueId() + \"\\\" name=\\\"requestId\\\"/>\")).concat(\"<script type=\\\"text/javascript\\\" language=\\\"javascript\\\">\".concat(getClientSideLocalizationScript()).concat(\"<\/script>\"));\n\t\t\t} else if (pt.element.compareTo(\"head\") == 0) {\n\t\t\t\t// After the <head>, we need to add GWT support\n\t\t\t\treturn \"<head><script type=\\\"text/javascript\\\" language=\\\"javascript\\\" src=\\\"/static/freenetjs/freenetjs.nocache.js\\\"><\/script><noscript><style> .jsonly {display:none;}<\/style><\/noscript>\";\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tchildren.clear();\n\t\taddChild(new HTMLNode(\"div\", \"\" + status));\n\t}","id":71154,"modified_method":"@Override\n\tpublic void updateState(boolean initial) {\n\t\tchildren.clear();\n\t\taddChild(new HTMLNode(\"img\", \"src\",\"/imagecreator/?text=\"+status+\"&width=\"+Math.min(status+30,300)+\"&height=\"+Math.min(status+30,300)));\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"public TesterElement(ToadletContext ctx, String id, int max) {\n\t\tsuper(\"div\", ctx);\n\t\tthis.id = id;\n\t\tthis.ctx = ctx;\n\t\tthis.maxStatus = max;\n\t\tinit();\n\t\tt = new Timer(true);\n\t\tt.scheduleAtFixedRate(new TimerTask() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t}, 0, 1000);\n\t}","id":71155,"modified_method":"public TesterElement(ToadletContext ctx, String id, int max) {\n\t\tsuper(\"div\",\"style\",\"float:left;\", ctx);\n\t\tthis.id = id;\n\t\tthis.ctx = ctx;\n\t\tthis.maxStatus = max;\n\t\tinit();\n\t\tt = new Timer(true);\n\t\tt.scheduleAtFixedRate(new TimerTask() {\n\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t}, 0, 1000);\n\t}","commit_id":"28607422a9b5d13aa0922524219c45c673c78a01","url":"https://github.com/freenet/fred"},{"original_method":"private void doWrapLongLinesIfNecessary(@NotNull Editor editor, @NotNull Document document, int startOffset, int endOffset) {\n    LineWrapPositionStrategy strategy = LanguageLineWrapPositionStrategy.INSTANCE.forEditor(editor);\n    CharSequence text = document.getCharsSequence();\n    int startLine = document.getLineNumber(startOffset);\n    int endLine = document.getLineNumber(Math.min(document.getTextLength(), endOffset) - 1);\n    int maxLine = Math.min(document.getLineCount(), endLine + 1);\n    int tabSize = EditorUtil.getTabSize(editor);\n    if (tabSize <= 0) {\n      tabSize = 1;\n    }\n    int spaceSize = EditorUtil.getSpaceWidth(Font.PLAIN, editor);\n\n    for (int line = startLine; line < maxLine; line++) {\n      int startLineOffset = document.getLineStartOffset(line);\n      int endLineOffset = document.getLineEndOffset(line);\n\n      boolean hasTabs = false;\n      boolean canOptimize = true;\n      boolean hasNonSpaceSymbols = false;\n      loop:\n      for (int i = startLineOffset; i < Math.min(endLineOffset, endOffset); i++) {\n        char c = text.charAt(i);\n        switch (c) {\n          case '\\t': {\n            hasTabs = true;\n            if (hasNonSpaceSymbols) {\n              canOptimize = false;\n              break loop;\n            }\n          }\n          case ' ': break;\n          default: hasNonSpaceSymbols = true;\n        }\n      }\n\n      int preferredWrapPosition = Integer.MAX_VALUE;\n      if (!hasTabs) {\n        if (Math.min(endLineOffset, endOffset) >= mySettings.RIGHT_MARGIN) {\n          preferredWrapPosition = startLineOffset + mySettings.RIGHT_MARGIN - FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS;\n        }\n      }\n      else if (canOptimize) {\n        int width = 0;\n        int symbolWidth;\n        for (int i = startLineOffset; i < Math.min(endLineOffset, endOffset); i++) {\n          char c = text.charAt(i);\n          switch (c) {\n            case '\\t': symbolWidth = tabSize - (width % tabSize); break;\n            default: symbolWidth = 1;\n          }\n          if (width + symbolWidth + FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS >= mySettings.RIGHT_MARGIN\n              && (Math.min(endLineOffset, endOffset) - i) >= FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS)\n          {\n            preferredWrapPosition = i - 1;\n            break;\n          }\n          width += symbolWidth;\n        }\n      }\n      else {\n        int width = 0;\n        int x = 0;\n        int newX;\n        int symbolWidth;\n        for (int i = startLineOffset; i < Math.min(endLineOffset, endOffset); i++) {\n          char c = text.charAt(i);\n          switch (c) {\n            case '\\t':\n              newX = EditorUtil.nextTabStop(x, editor);\n              int diffInPixels = newX - x;\n              symbolWidth = diffInPixels / spaceSize;\n              if (diffInPixels % spaceSize > 0) {\n                symbolWidth++;\n              }\n              break;\n            default: newX = x + EditorUtil.charWidth(c, Font.PLAIN, editor); symbolWidth = 1;\n          }\n          if (width + symbolWidth + FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS >= mySettings.RIGHT_MARGIN\n              && (Math.min(endLineOffset, endOffset) - i) >= FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS)\n          {\n            preferredWrapPosition = i - 1;\n            break;\n          }\n          x = newX;\n          width += symbolWidth;\n        }\n      }\n      if (preferredWrapPosition >= endLineOffset) {\n        continue;\n      }\n      if (preferredWrapPosition >= endOffset) {\n        return;\n      }\n\n      // We know that current line exceeds right margin if control flow reaches this place, so, wrap it.\n      int wrapOffset = strategy.calculateWrapPosition(\n        text, Math.max(startLineOffset, startOffset), Math.min(endLineOffset, endOffset), preferredWrapPosition, false\n      );\n      editor.getCaretModel().moveToOffset(wrapOffset);\n      DataContext dataContext = DataManager.getInstance().getDataContext(editor.getComponent());\n\n      SelectionModel selectionModel = editor.getSelectionModel();\n      boolean restoreSelection;\n      int startSelectionOffset = 0;\n      int endSelectionOffset = 0;\n      if (restoreSelection = selectionModel.hasSelection()) {\n        startSelectionOffset = selectionModel.getSelectionStart();\n        endSelectionOffset = selectionModel.getSelectionEnd();\n        selectionModel.removeSelection();\n      }\n      int textLengthBeforeWrap = document.getTextLength();\n      EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_ENTER).execute(editor, dataContext);\n      if (restoreSelection) {\n        int symbolsDiff = document.getTextLength() - textLengthBeforeWrap;\n        int newSelectionStart = startSelectionOffset;\n        int newSelectionEnd = endSelectionOffset;\n        if (startSelectionOffset >= wrapOffset) {\n          newSelectionStart += symbolsDiff;\n        }\n        if (endSelectionOffset >= wrapOffset) {\n          newSelectionEnd += symbolsDiff;\n        }\n        selectionModel.setSelection(newSelectionStart, newSelectionEnd);\n      }\n\n\n      // There is a possible case that particular line is so long, that its part that exceeds right margin and is wrapped\n      // still exceeds right margin. Hence, we recursively call 'wrap long lines' sub-routine in order to handle that.\n\n      doWrapLongLinesIfNecessary(editor, document, document.getLineStartOffset(line + 1), endOffset);\n      return;\n    }\n  }","id":71156,"modified_method":"private void doWrapLongLinesIfNecessary(@NotNull Editor editor, @NotNull Document document, int startOffset, int endOffset) {\n    // Normalization.\n    int startOffsetToUse = Math.max(0, startOffset);\n    int endOffsetToUse = Math.min(document.getTextLength(), endOffset);\n\n    LineWrapPositionStrategy strategy = LanguageLineWrapPositionStrategy.INSTANCE.forEditor(editor);\n    CharSequence text = document.getCharsSequence();\n    int startLine = document.getLineNumber(startOffsetToUse);\n    int endLine = document.getLineNumber(Math.max(0, endOffsetToUse - 1));\n    int maxLine = Math.min(document.getLineCount(), endLine + 1);\n    int tabSize = EditorUtil.getTabSize(editor);\n    if (tabSize <= 0) {\n      tabSize = 1;\n    }\n    int spaceSize = EditorUtil.getSpaceWidth(Font.PLAIN, editor);\n\n    for (int line = startLine; line < maxLine; line++) {\n      int startLineOffset = document.getLineStartOffset(line);\n      int endLineOffset = document.getLineEndOffset(line);\n\n      boolean hasTabs = false;\n      boolean canOptimize = true;\n      boolean hasNonSpaceSymbols = false;\n      loop:\n      for (int i = startLineOffset; i < Math.min(endLineOffset, endOffsetToUse); i++) {\n        char c = text.charAt(i);\n        switch (c) {\n          case '\\t': {\n            hasTabs = true;\n            if (hasNonSpaceSymbols) {\n              canOptimize = false;\n              break loop;\n            }\n          }\n          case ' ': break;\n          default: hasNonSpaceSymbols = true;\n        }\n      }\n\n      int preferredWrapPosition = Integer.MAX_VALUE;\n      if (!hasTabs) {\n        if (Math.min(endLineOffset, endOffsetToUse) >= mySettings.RIGHT_MARGIN) {\n          preferredWrapPosition = startLineOffset + mySettings.RIGHT_MARGIN - FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS;\n        }\n      }\n      else if (canOptimize) {\n        int width = 0;\n        int symbolWidth;\n        for (int i = startLineOffset; i < Math.min(endLineOffset, endOffsetToUse); i++) {\n          char c = text.charAt(i);\n          switch (c) {\n            case '\\t': symbolWidth = tabSize - (width % tabSize); break;\n            default: symbolWidth = 1;\n          }\n          if (width + symbolWidth + FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS >= mySettings.RIGHT_MARGIN\n              && (Math.min(endLineOffset, endOffsetToUse) - i) >= FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS)\n          {\n            preferredWrapPosition = i - 1;\n            break;\n          }\n          width += symbolWidth;\n        }\n      }\n      else {\n        int width = 0;\n        int x = 0;\n        int newX;\n        int symbolWidth;\n        for (int i = startLineOffset; i < Math.min(endLineOffset, endOffsetToUse); i++) {\n          char c = text.charAt(i);\n          switch (c) {\n            case '\\t':\n              newX = EditorUtil.nextTabStop(x, editor);\n              int diffInPixels = newX - x;\n              symbolWidth = diffInPixels / spaceSize;\n              if (diffInPixels % spaceSize > 0) {\n                symbolWidth++;\n              }\n              break;\n            default: newX = x + EditorUtil.charWidth(c, Font.PLAIN, editor); symbolWidth = 1;\n          }\n          if (width + symbolWidth + FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS >= mySettings.RIGHT_MARGIN\n              && (Math.min(endLineOffset, endOffsetToUse) - i) >= FormatConstants.RESERVED_LINE_WRAP_WIDTH_IN_COLUMNS)\n          {\n            preferredWrapPosition = i - 1;\n            break;\n          }\n          x = newX;\n          width += symbolWidth;\n        }\n      }\n      if (preferredWrapPosition >= endLineOffset) {\n        continue;\n      }\n      if (preferredWrapPosition >= endOffsetToUse) {\n        return;\n      }\n\n      // We know that current line exceeds right margin if control flow reaches this place, so, wrap it.\n      int wrapOffset = strategy.calculateWrapPosition(\n        text, Math.max(startLineOffset, startOffsetToUse), Math.min(endLineOffset, endOffsetToUse), preferredWrapPosition, false\n      );\n      editor.getCaretModel().moveToOffset(wrapOffset);\n      DataContext dataContext = DataManager.getInstance().getDataContext(editor.getComponent());\n\n      SelectionModel selectionModel = editor.getSelectionModel();\n      boolean restoreSelection;\n      int startSelectionOffset = 0;\n      int endSelectionOffset = 0;\n      if (restoreSelection = selectionModel.hasSelection()) {\n        startSelectionOffset = selectionModel.getSelectionStart();\n        endSelectionOffset = selectionModel.getSelectionEnd();\n        selectionModel.removeSelection();\n      }\n      int textLengthBeforeWrap = document.getTextLength();\n      EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_ENTER).execute(editor, dataContext);\n      if (restoreSelection) {\n        int symbolsDiff = document.getTextLength() - textLengthBeforeWrap;\n        int newSelectionStart = startSelectionOffset;\n        int newSelectionEnd = endSelectionOffset;\n        if (startSelectionOffset >= wrapOffset) {\n          newSelectionStart += symbolsDiff;\n        }\n        if (endSelectionOffset >= wrapOffset) {\n          newSelectionEnd += symbolsDiff;\n        }\n        selectionModel.setSelection(newSelectionStart, newSelectionEnd);\n      }\n\n\n      // There is a possible case that particular line is so long, that its part that exceeds right margin and is wrapped\n      // still exceeds right margin. Hence, we recursively call 'wrap long lines' sub-routine in order to handle that.\n\n      doWrapLongLinesIfNecessary(editor, document, document.getLineStartOffset(line + 1), endOffsetToUse);\n      return;\n    }\n  }","commit_id":"2f3a88f7fcf92e4d0d191471ddc428421463ff4c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getLayoutsJSON(\n\t\t\tHttpServletRequest request, long groupId, boolean privateLayout,\n\t\t\tlong parentLayoutId, long[] expandedLayoutIds)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tint start = ParamUtil.getInteger(request, \"start\");\n\t\tint end = start + PropsValues.LAYOUT_MANAGE_PAGES_INITIAL_CHILDREN;\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tList<Layout> layoutAncestors = null;\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tgroupId, privateLayout, parentLayoutId);\n\n\t\tlong selPlid = ParamUtil.getLong(request, \"selPlid\");\n\n\t\tif (selPlid != 0) {\n\t\t\tLayout selLayout = LayoutLocalServiceUtil.getLayout(selPlid);\n\n\t\t\tlayoutAncestors = selLayout.getAncestors();\n\n\t\t\tlayoutAncestors.add(selLayout);\n\n\t\t\tfor (Layout layoutAncestor : layoutAncestors) {\n\t\t\t\tint index = layouts.indexOf(layoutAncestor);\n\n\t\t\t\tif (index >= end) {\n\t\t\t\t\tend = index + 1;\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart = Math.min(start, layouts.size());\n\t\tend = Math.min(end, layouts.size());\n\n\t\tfor (Layout layout : layouts.subList(start, end)) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tif ((layoutAncestors != null) && layoutAncestors.contains(layout) ||\n\t\t\t\tArrayUtil.contains(expandedLayoutIds, layout.getLayoutId())) {\n\n\t\t\t\tString childrenJSON = StringPool.BLANK;\n\n\t\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, virtualLayout.getSourceGroupId(),\n\t\t\t\t\t\tvirtualLayout.getPrivateLayout(),\n\t\t\t\t\t\tvirtualLayout.getLayoutId(), expandedLayoutIds);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, groupId, layout.getPrivateLayout(),\n\t\t\t\t\t\tlayout.getLayoutId(), expandedLayoutIds);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"children\", JSONFactoryUtil.createJSONObject(childrenJSON));\n\t\t\t}\n\n\t\t\tjsonObject.put(\"contentDisplayPage\", layout.isContentDisplayPage());\n\t\t\tjsonObject.put(\"friendlyURL\", layout.getFriendlyURL());\n\n\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\tjsonObject.put(\"groupId\", virtualLayout.getSourceGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjsonObject.put(\"groupId\", layout.getGroupId());\n\t\t\t}\n\n\t\t\tjsonObject.put(\"hasChildren\", layout.hasChildren());\n\t\t\tjsonObject.put(\"layoutId\", layout.getLayoutId());\n\t\t\tjsonObject.put(\"name\", layout.getName(themeDisplay.getLocale()));\n\t\t\tjsonObject.put(\"parentLayoutId\", layout.getParentLayoutId());\n\t\t\tjsonObject.put(\"plid\", layout.getPlid());\n\t\t\tjsonObject.put(\"priority\", layout.getPriority());\n\t\t\tjsonObject.put(\"privateLayout\", layout.isPrivateLayout());\n\t\t\tjsonObject.put(\"type\", layout.getType());\n\t\t\tjsonObject.put(\"updateable\", SitesUtil.isLayoutUpdateable(layout));\n\t\t\tjsonObject.put(\"uuid\", layout.getUuid());\n\n\t\t\tLayoutRevision layoutRevision = LayoutStagingUtil.getLayoutRevision(\n\t\t\t\tlayout);\n\n\t\t\tif (layoutRevision != null) {\n\t\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\t\tlong recentLayoutSetBranchId =\n\t\t\t\t\tStagingUtil.getRecentLayoutSetBranchId(\n\t\t\t\t\t\tuser, layout.getLayoutSet().getLayoutSetId());\n\n\t\t\t\tif (StagingUtil.isIncomplete(layout, recentLayoutSetBranchId)) {\n\t\t\t\t\tjsonObject.put(\"incomplete\", true);\n\t\t\t\t}\n\n\t\t\t\tlong layoutSetBranchId = layoutRevision.getLayoutSetBranchId();\n\n\t\t\t\tLayoutSetBranch layoutSetBranch =\n\t\t\t\t\tLayoutSetBranchLocalServiceUtil.getLayoutSetBranch(\n\t\t\t\t\t\tlayoutSetBranchId);\n\n\t\t\t\tLayoutBranch layoutBranch = layoutRevision.getLayoutBranch();\n\n\t\t\t\tif (!layoutBranch.isMaster()) {\n\t\t\t\t\tjsonObject.put(\n\t\t\t\t\t\t\"layoutBranchId\", layoutBranch.getLayoutBranchId());\n\t\t\t\t\tjsonObject.put(\"layoutBranchName\", layoutBranch.getName());\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutRevisionId\", layoutRevision.getLayoutRevisionId());\n\t\t\t\tjsonObject.put(\"layoutSetBranchId\", layoutSetBranchId);\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutSetBranchName\", layoutSetBranch.getName());\n\t\t\t}\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tJSONObject responseJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tresponseJSONObject.put(\"layouts\", jsonArray);\n\t\tresponseJSONObject.put(\"total\", layouts.size());\n\n\t\treturn responseJSONObject.toString();\n\t}","id":71157,"modified_method":"public static String getLayoutsJSON(\n\t\t\tHttpServletRequest request, long groupId, boolean privateLayout,\n\t\t\tlong parentLayoutId, long[] expandedLayoutIds)\n\t\tthrows Exception {\n\n\t\tHttpSession session = request.getSession();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tint start = ParamUtil.getInteger(request, \"start\");\n\t\tint end = ParamUtil.getInteger(\n\t\t\trequest, \"end\",\n\t\t\tstart + PropsValues.LAYOUT_MANAGE_PAGES_INITIAL_CHILDREN);\n\n\t\tJSONArray jsonArray = JSONFactoryUtil.createJSONArray();\n\n\t\tList<Layout> layoutAncestors = null;\n\n\t\tList<Layout> layouts = LayoutLocalServiceUtil.getLayouts(\n\t\t\tgroupId, privateLayout, parentLayoutId);\n\n\t\tlong selPlid = ParamUtil.getLong(request, \"selPlid\");\n\n\t\tif (selPlid != 0) {\n\t\t\tLayout selLayout = LayoutLocalServiceUtil.getLayout(selPlid);\n\n\t\t\tlayoutAncestors = selLayout.getAncestors();\n\n\t\t\tlayoutAncestors.add(selLayout);\n\n\t\t\tString treeId = getScopedPaginationTreeId(request);\n\n\t\t\tString paginationJSON = SessionClicks.get(\n\t\t\t\tsession, treeId, StringPool.BLANK);\n\n\t\t\tif (Validator.isNotNull(paginationJSON) && (end >= 0)) {\n\t\t\t\tJSONObject paginationJSONObject =\n\t\t\t\t\tJSONFactoryUtil.createJSONObject(paginationJSON);\n\n\t\t\t\tString key = String.valueOf(parentLayoutId);\n\n\t\t\t\tif (paginationJSONObject.has(key)) {\n\t\t\t\t\tint paginationEnd = paginationJSONObject.getInt(key);\n\n\t\t\t\t\tif (paginationEnd > end) {\n\t\t\t\t\t\tend = paginationEnd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tstart = Math.max(0, Math.min(start, layouts.size()));\n\t\tend = Math.min(end, layouts.size());\n\n\t\tif (end < 0) {\n\t\t\tend = layouts.size();\n\t\t}\n\n\t\tfor (Layout layout : layouts.subList(start, end)) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tif ((layoutAncestors != null) && layoutAncestors.contains(layout) ||\n\t\t\t\tArrayUtil.contains(expandedLayoutIds, layout.getLayoutId())) {\n\n\t\t\t\tString childrenJSON = StringPool.BLANK;\n\n\t\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, virtualLayout.getSourceGroupId(),\n\t\t\t\t\t\tvirtualLayout.getPrivateLayout(),\n\t\t\t\t\t\tvirtualLayout.getLayoutId(), expandedLayoutIds);\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchildrenJSON = getLayoutsJSON(\n\t\t\t\t\t\trequest, groupId, layout.getPrivateLayout(),\n\t\t\t\t\t\tlayout.getLayoutId(), expandedLayoutIds);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"children\", JSONFactoryUtil.createJSONObject(childrenJSON));\n\t\t\t}\n\n\t\t\tjsonObject.put(\"contentDisplayPage\", layout.isContentDisplayPage());\n\t\t\tjsonObject.put(\"friendlyURL\", layout.getFriendlyURL());\n\n\t\t\tif (layout instanceof VirtualLayout) {\n\t\t\t\tVirtualLayout virtualLayout = (VirtualLayout)layout;\n\n\t\t\t\tjsonObject.put(\"groupId\", virtualLayout.getSourceGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjsonObject.put(\"groupId\", layout.getGroupId());\n\t\t\t}\n\n\t\t\tjsonObject.put(\"hasChildren\", layout.hasChildren());\n\t\t\tjsonObject.put(\"layoutId\", layout.getLayoutId());\n\t\t\tjsonObject.put(\"name\", layout.getName(themeDisplay.getLocale()));\n\t\t\tjsonObject.put(\"parentLayoutId\", layout.getParentLayoutId());\n\t\t\tjsonObject.put(\"plid\", layout.getPlid());\n\t\t\tjsonObject.put(\"priority\", layout.getPriority());\n\t\t\tjsonObject.put(\"privateLayout\", layout.isPrivateLayout());\n\t\t\tjsonObject.put(\"type\", layout.getType());\n\t\t\tjsonObject.put(\"updateable\", SitesUtil.isLayoutUpdateable(layout));\n\t\t\tjsonObject.put(\"uuid\", layout.getUuid());\n\n\t\t\tLayoutRevision layoutRevision = LayoutStagingUtil.getLayoutRevision(\n\t\t\t\tlayout);\n\n\t\t\tif (layoutRevision != null) {\n\t\t\t\tUser user = themeDisplay.getUser();\n\n\t\t\t\tlong recentLayoutSetBranchId =\n\t\t\t\t\tStagingUtil.getRecentLayoutSetBranchId(\n\t\t\t\t\t\tuser, layout.getLayoutSet().getLayoutSetId());\n\n\t\t\t\tif (StagingUtil.isIncomplete(layout, recentLayoutSetBranchId)) {\n\t\t\t\t\tjsonObject.put(\"incomplete\", true);\n\t\t\t\t}\n\n\t\t\t\tlong layoutSetBranchId = layoutRevision.getLayoutSetBranchId();\n\n\t\t\t\tLayoutSetBranch layoutSetBranch =\n\t\t\t\t\tLayoutSetBranchLocalServiceUtil.getLayoutSetBranch(\n\t\t\t\t\t\tlayoutSetBranchId);\n\n\t\t\t\tLayoutBranch layoutBranch = layoutRevision.getLayoutBranch();\n\n\t\t\t\tif (!layoutBranch.isMaster()) {\n\t\t\t\t\tjsonObject.put(\n\t\t\t\t\t\t\"layoutBranchId\", layoutBranch.getLayoutBranchId());\n\t\t\t\t\tjsonObject.put(\"layoutBranchName\", layoutBranch.getName());\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutRevisionId\", layoutRevision.getLayoutRevisionId());\n\t\t\t\tjsonObject.put(\"layoutSetBranchId\", layoutSetBranchId);\n\t\t\t\tjsonObject.put(\n\t\t\t\t\t\"layoutSetBranchName\", layoutSetBranch.getName());\n\t\t\t}\n\n\t\t\tjsonArray.put(jsonObject);\n\t\t}\n\n\t\tJSONObject responseJSONObject = JSONFactoryUtil.createJSONObject();\n\n\t\tresponseJSONObject.put(\"layouts\", jsonArray);\n\t\tresponseJSONObject.put(\"total\", layouts.size());\n\n\t\treturn responseJSONObject.toString();\n\t}","commit_id":"4c15fe3d64507fb84e9c96b8cc6329bdacf9acdf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getValue(HttpServletRequest request) {\n\t\tString cmd = ParamUtil.getString(request, \"cmd\");\n\n\t\tif (cmd.equals(\"get\")) {\n\t\t\tString key = ParamUtil.getString(request, \"key\");\n\n\t\t\treturn SessionClicks.get(request, key, cmd);\n\t\t}\n\t\telse if (cmd.equals(\"getAll\")) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tString[] keys = request.getParameterValues(\"key\");\n\n\t\t\tfor (String key : keys) {\n\t\t\t\tString value = SessionClicks.get(request, key, cmd);\n\n\t\t\t\tjsonObject.put(key, value);\n\t\t\t}\n\n\t\t\treturn jsonObject.toString();\n\t\t}\n\n\t\treturn null;\n\t}","id":71158,"modified_method":"protected String getValue(HttpServletRequest request) {\n\t\tHttpSession session = request.getSession();\n\n\t\tString cmd = ParamUtil.getString(request, \"cmd\");\n\t\tboolean useHttpSession = ParamUtil.getBoolean(\n\t\t\trequest, \"useHttpSession\");\n\n\t\tif (cmd.equals(\"get\")) {\n\t\t\tString key = ParamUtil.getString(request, \"key\");\n\t\t\tString value = StringPool.BLANK;\n\n\t\t\tif (useHttpSession) {\n\t\t\t\tvalue = SessionClicks.get(session, key, cmd);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = SessionClicks.get(request, key, cmd);\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\telse if (cmd.equals(\"getAll\")) {\n\t\t\tJSONObject jsonObject = JSONFactoryUtil.createJSONObject();\n\n\t\t\tString[] keys = request.getParameterValues(\"key\");\n\n\t\t\tfor (String key : keys) {\n\t\t\t\tString value = StringPool.BLANK;\n\n\t\t\t\tif (useHttpSession) {\n\t\t\t\t\tvalue = SessionClicks.get(session, key, cmd);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = SessionClicks.get(request, key, cmd);\n\t\t\t\t}\n\n\t\t\t\tjsonObject.put(key, value);\n\t\t\t}\n\n\t\t\treturn jsonObject.toString();\n\t\t}\n\n\t\treturn null;\n\t}","commit_id":"4c15fe3d64507fb84e9c96b8cc6329bdacf9acdf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tEnumeration<String> enu = request.getParameterNames();\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString name = enu.nextElement();\n\n\t\t\t\tif (!name.equals(\"doAsUserId\")) {\n\t\t\t\t\tString value = ParamUtil.getString(request, name);\n\n\t\t\t\t\tSessionClicks.put(request, name, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString value = getValue(request);\n\n\t\t\tif (value != null) {\n\t\t\t\tServletOutputStream servletOutputStream =\n\t\t\t\t\tresponse.getOutputStream();\n\n\t\t\t\tservletOutputStream.print(value);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPortalUtil.sendError(e, request, response);\n\n\t\t\treturn null;\n\t\t}\n\t}","id":71159,"modified_method":"@Override\n\tpublic ActionForward execute(\n\t\t\tActionMapping mapping, ActionForm form, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\ttry {\n\t\t\tHttpSession session = request.getSession();\n\t\t\tEnumeration<String> enu = request.getParameterNames();\n\n\t\t\tboolean useHttpSession = ParamUtil.getBoolean(\n\t\t\t\trequest, \"useHttpSession\");\n\n\t\t\twhile (enu.hasMoreElements()) {\n\t\t\t\tString name = enu.nextElement();\n\n\t\t\t\tif (!name.equals(\"doAsUserId\")) {\n\t\t\t\t\tString value = ParamUtil.getString(request, name);\n\n\t\t\t\t\tif (useHttpSession) {\n\t\t\t\t\t\tSessionClicks.put(session, name, value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSessionClicks.put(request, name, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString value = getValue(request);\n\n\t\t\tif (value != null) {\n\t\t\t\tServletOutputStream servletOutputStream =\n\t\t\t\t\tresponse.getOutputStream();\n\n\t\t\t\tservletOutputStream.print(value);\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tPortalUtil.sendError(e, request, response);\n\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"4c15fe3d64507fb84e9c96b8cc6329bdacf9acdf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public LightweightHint show(final Editor editor, Point p, boolean alignToRight, TooltipGroup group, HintHint intInfo) {\n    LightweightHint hint;\n\n    final JComponent editorComponent = editor.getComponent();\n\n    TextRange range = myDocumentFragment.getTextRange();\n    int startOffset = range.getStartOffset();\n    int endOffset = range.getEndOffset();\n    Document doc = myDocumentFragment.getDocument();\n    int endLine = doc.getLineNumber(endOffset);\n    int startLine = doc.getLineNumber(startOffset);\n\n    JLayeredPane layeredPane = editorComponent.getRootPane().getLayeredPane();\n\n    // There is a possible case that collapsed folding region is soft wrapped, hence, we need to anchor\n    // not logical but visual line start.\n    VisualPosition visual = editor.offsetToVisualPosition(startOffset);\n    p = editor.visualPositionToXY(visual);\n    p = SwingUtilities.convertPoint(\n      ((EditorEx)editor).getGutterComponentEx(),\n      p,\n      layeredPane\n    );\n\n    p.x -= 3;\n    p.y += editor.getLineHeight();\n\n    Point screen = new Point(p);\n    SwingUtilities.convertPointToScreen(screen, layeredPane);\n    int maxLineCount = (Toolkit.getDefaultToolkit().getScreenSize().height - screen.y) / editor.getLineHeight();\n\n    if (endLine - startLine > maxLineCount) {\n      endOffset = doc.getLineEndOffset(Math.min(startLine + maxLineCount, doc.getLineCount() - 1));\n    }\n\n    FoldingModelEx foldingModel = (FoldingModelEx)editor.getFoldingModel();\n    foldingModel.setFoldingEnabled(false);\n    TextRange textRange = new TextRange(startOffset, endOffset);\n    hint = EditorFragmentComponent.showEditorFragmentHintAt(editor, textRange, p.x, p.y, false, false, true);\n    foldingModel.setFoldingEnabled(true);\n    return hint;\n  }","id":71160,"modified_method":"public LightweightHint show(final Editor editor, Point p, boolean alignToRight, TooltipGroup group, HintHint intInfo) {\n    LightweightHint hint;\n\n    final JComponent editorComponent = editor.getComponent();\n\n    TextRange range = myDocumentFragment.getTextRange();\n    int startOffset = range.getStartOffset();\n    int endOffset = range.getEndOffset();\n    Document doc = myDocumentFragment.getDocument();\n    int endLine = doc.getLineNumber(endOffset);\n    int startLine = doc.getLineNumber(startOffset);\n\n    JLayeredPane layeredPane = editorComponent.getRootPane().getLayeredPane();\n\n    // There is a possible case that collapsed folding region is soft wrapped, hence, we need to anchor\n    // not logical but visual line start.\n    VisualPosition visual = editor.offsetToVisualPosition(startOffset);\n    p = editor.visualPositionToXY(visual);\n    p = SwingUtilities.convertPoint(\n      ((EditorEx)editor).getGutterComponentEx(),\n      p,\n      layeredPane\n    );\n\n    p.x -= 3;\n    p.y += editor.getLineHeight();\n\n    Point screen = new Point(p);\n    SwingUtilities.convertPointToScreen(screen, layeredPane);\n    int maxLineCount = (Toolkit.getDefaultToolkit().getScreenSize().height - screen.y) / editor.getLineHeight();\n\n    if (endLine - startLine > maxLineCount) {\n      endOffset = doc.getLineEndOffset(Math.max(0, Math.min(startLine + maxLineCount, doc.getLineCount() - 1)));\n    }\n\n    FoldingModelEx foldingModel = (FoldingModelEx)editor.getFoldingModel();\n    foldingModel.setFoldingEnabled(false);\n    TextRange textRange = new TextRange(startOffset, endOffset);\n    hint = EditorFragmentComponent.showEditorFragmentHintAt(editor, textRange, p.x, p.y, false, false, true);\n    foldingModel.setFoldingEnabled(true);\n    return hint;\n  }","commit_id":"bfef1f265e90aba76fef715c6f20e561c6c52b5d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static int rankBugPatternWithPriorityAdustment(BugPattern bugPattern, int priority, BugRanker... rankers) {\n    \tint rankBugPattern = rankBugPattern(bugPattern, rankers);\n\t\tint priorityAdjustment = priorityAdjustment(priority);\n\t\tif (rankBugPattern > 20)\n\t\t\treturn rankBugPattern + priorityAdjustment;\n\t\treturn Math.min(rankBugPattern + priorityAdjustment, 20);\n    }","id":71161,"modified_method":"private static int rankBugPatternWithPriorityAdustment(BugPattern bugPattern, int priority, BugRanker... rankers) {\n    \tint rankBugPattern = rankBugPattern(bugPattern, rankers);\n\t\tint priorityAdjustment = priorityAdjustment(priority);\n\t\tif (rankBugPattern > 20)\n\t\t\treturn rankBugPattern + priorityAdjustment;\n\t\treturn Math.max(1,Math.min(rankBugPattern + priorityAdjustment, 20));\n    }","commit_id":"061f9cafe8cffb2067f5a1ec13c900070d0b86a8","url":"https://github.com/findbugsproject/findbugs"},{"original_method":"/**\n     * Compute the actual train_samples_per_iteration size from the user-given parameter\n     * @param mp Model parameter (DeepLearning object)\n     * @param numRows number of training rows\n     * @param model DL model\n     * @return The total number of training rows to be processed per iteration (summed over on all nodes)\n     */\n    private long computeTrainSamplesPerIteration(final DeepLearningParameters mp, final long numRows, final DeepLearningModel model) {\n      long tspi = mp._train_samples_per_iteration;\n      assert(tspi == 0 || tspi == -1 || tspi == -2 || tspi >= 1);\n      if (tspi == 0 || (!mp._replicate_training_data && tspi == -1) ) {\n        tspi = numRows;\n        if (!mp._quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp._train_samples_per_iteration + \") to one epoch: #rows (\" + tspi + \").\");\n      }\n      else if (tspi == -1) {\n        tspi = (mp._single_node_mode ? 1 : H2O.CLOUD.size()) * numRows;\n        if (!mp._quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp._train_samples_per_iteration + \") to #nodes x #rows (\" + tspi + \").\");\n      } else if (tspi == -2) {\n        // automatic tuning based on CPU speed, network speed and model size\n\n      // measure cpu speed\n      double total_gflops = 0;\n      for (H2ONode h2o : H2O.CLOUD._memary) {\n        HeartBeat hb = h2o._heartbeat;\n        total_gflops += hb._gflops;\n      }\n      if (mp._single_node_mode) total_gflops /= H2O.CLOUD.size();\n      if (total_gflops == 0) {\n        total_gflops = Linpack.run(H2O.SELF._heartbeat._cpus_allowed) * (mp._single_node_mode ? 1 : H2O.CLOUD.size());\n      }\n\n      final long model_size = model.model_info().size();\n      int[] msg_sizes = new int[]{ (int)(model_size*4) == (model_size*4) ? (int)(model_size*4) : Integer.MAX_VALUE };\n      double[] microseconds_collective = new double[msg_sizes.length];\n      NetworkTest.NetworkTester nt = new NetworkTest.NetworkTester(msg_sizes,null,microseconds_collective,model_size>1e6 ? 1 : 5 /*repeats*/,false,true /*only collectives*/);\n      nt.compute2();\n\n      //length of the network traffic queue based on log-tree rollup (2 log(nodes))\n      int network_queue_length = mp._single_node_mode || H2O.CLOUD.size() == 1? 1 : 2*(int)Math.floor(Math.log(H2O.CLOUD.size())/Math.log(2));\n\n      // heuristics\n      double flops_overhead_per_row = 30;\n      if (mp._activation == DeepLearningParameters.Activation.Maxout || mp._activation == DeepLearningParameters.Activation.MaxoutWithDropout) {\n        flops_overhead_per_row *= 8;\n      } else if (mp._activation == DeepLearningParameters.Activation.Tanh || mp._activation == DeepLearningParameters.Activation.TanhWithDropout) {\n        flops_overhead_per_row *= 5;\n      }\n\n      // target fraction of comm vs cpu time: 5%\n      double fraction = mp._single_node_mode || H2O.CLOUD.size() == 1 ? 1e-3 : 0.05; //one single node mode, there's no model averaging effect, so less need to shorten the M/R iteration\n\n      // estimate the time for communication (network) and training (compute)\n      model.time_for_communication_us = (H2O.CLOUD.size() == 1 ? 1e4 /* add 10ms for single-node */ : 0) + network_queue_length * microseconds_collective[0];\n      double time_per_row_us  = flops_overhead_per_row * model_size / (total_gflops * 1e9) / H2O.SELF._heartbeat._cpus_allowed * 1e6;\n\n      // compute the optimal number of training rows per iteration\n      // fraction := time_comm_us / (time_comm_us + tspi * time_per_row_us)  ==>  tspi = (time_comm_us/fraction - time_comm_us)/time_per_row_us\n      tspi = (long)((model.time_for_communication_us / fraction - model.time_for_communication_us)/ time_per_row_us);\n\n      tspi = Math.min(tspi, (mp._single_node_mode ? 1 : H2O.CLOUD.size()) * numRows * 10); //not more than 10x of what train_samples_per_iteration=-1 would do\n\n      // If the number is close to a multiple of epochs, use that -> prettier scoring\n      if (tspi > numRows && Math.abs(tspi % numRows)/(double)numRows < 0.2)  tspi = tspi - tspi % numRows;\n      tspi = Math.min(tspi, (long)(mp._epochs * numRows / 10)); //limit to number of epochs desired, but at least 10 iterations total\n      tspi = Math.max(1, tspi); //at least 1 point\n\n      if (!mp._quiet_mode) {\n        Log.info(\"Auto-tuning parameter 'train_samples_per_iteration':\");\n        Log.info(\"Estimated compute power : \" + (int)total_gflops + \" GFlops\");\n        Log.info(\"Estimated time for comm : \" + PrettyPrint.usecs((long) model.time_for_communication_us));\n        Log.info(\"Estimated time per row  : \" + ((long)time_per_row_us > 0 ? PrettyPrint.usecs((long) time_per_row_us) : time_per_row_us + \" usecs\"));\n        Log.info(\"Estimated training speed: \" + (int)(1e6/time_per_row_us) + \" rows/sec\");\n        Log.info(\"Setting train_samples_per_iteration (\" + mp._train_samples_per_iteration + \") to auto-tuned value: \" + tspi);\n      }\n\n      } else {\n        // limit user-given value to number of epochs desired\n        tspi = Math.min(tspi, (long)(mp._epochs * numRows));\n      }\n      assert(tspi != 0 && tspi != -1 && tspi != -2 && tspi >= 1);\n      return tspi;\n    }","id":71162,"modified_method":"/**\n     * Compute the actual train_samples_per_iteration size from the user-given parameter\n     * @param mp Model parameter (DeepLearning object)\n     * @param numRows number of training rows\n     * @param model DL model\n     * @return The total number of training rows to be processed per iteration (summed over on all nodes)\n     */\n    private long computeTrainSamplesPerIteration(final DeepLearningParameters mp, final long numRows, final DeepLearningModel model) {\n      long tspi = mp._train_samples_per_iteration;\n      assert(tspi == 0 || tspi == -1 || tspi == -2 || tspi >= 1);\n      if (tspi == 0 || (!mp._replicate_training_data && tspi == -1) ) {\n        tspi = numRows;\n        if (!mp._quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp._train_samples_per_iteration + \") to one epoch: #rows (\" + tspi + \").\");\n      }\n      else if (tspi == -1) {\n        tspi = (mp._single_node_mode ? 1 : H2O.CLOUD.size()) * numRows;\n        if (!mp._quiet_mode) Log.info(\"Setting train_samples_per_iteration (\" + mp._train_samples_per_iteration + \") to #nodes x #rows (\" + tspi + \").\");\n      } else if (tspi == -2) {\n        // automatic tuning based on CPU speed, network speed and model size\n\n        // measure cpu speed\n        double total_gflops = 0;\n        for (H2ONode h2o : H2O.CLOUD._memary) {\n          HeartBeat hb = h2o._heartbeat;\n          total_gflops += hb._gflops;\n        }\n        if (mp._single_node_mode) total_gflops /= H2O.CLOUD.size();\n        if (total_gflops == 0) {\n          total_gflops = Linpack.run(H2O.SELF._heartbeat._cpus_allowed) * (mp._single_node_mode ? 1 : H2O.CLOUD.size());\n        }\n\n        final long model_size = model.model_info().size();\n        int[] msg_sizes = new int[]{ (int)(model_size*4) == (model_size*4) ? (int)(model_size*4) : Integer.MAX_VALUE };\n        double[] microseconds_collective = new double[msg_sizes.length];\n        NetworkTest.NetworkTester nt = new NetworkTest.NetworkTester(msg_sizes,null,microseconds_collective,model_size>1e6 ? 1 : 5 /*repeats*/,false,true /*only collectives*/);\n        nt.compute2();\n\n        //length of the network traffic queue based on log-tree rollup (2 log(nodes))\n        int network_queue_length = mp._single_node_mode || H2O.CLOUD.size() == 1? 1 : 2*(int)Math.floor(Math.log(H2O.CLOUD.size())/Math.log(2));\n\n        // heuristics\n        double flops_overhead_per_row = 30;\n        if (mp._activation == DeepLearningParameters.Activation.Maxout || mp._activation == DeepLearningParameters.Activation.MaxoutWithDropout) {\n          flops_overhead_per_row *= 8;\n        } else if (mp._activation == DeepLearningParameters.Activation.Tanh || mp._activation == DeepLearningParameters.Activation.TanhWithDropout) {\n          flops_overhead_per_row *= 5;\n        }\n\n        // target fraction of comm vs cpu time: 5%\n        double fraction = mp._single_node_mode || H2O.CLOUD.size() == 1 ? 1e-3 : 0.05; //one single node mode, there's no model averaging effect, so less need to shorten the M/R iteration\n\n        // estimate the time for communication (network) and training (compute)\n        model.time_for_communication_us = (H2O.CLOUD.size() == 1 ? 1e4 /* add 10ms for single-node */ : 0) + network_queue_length * microseconds_collective[0];\n        double time_per_row_us  = flops_overhead_per_row * model_size / (total_gflops * 1e9) / H2O.SELF._heartbeat._cpus_allowed * 1e6;\n\n        // compute the optimal number of training rows per iteration\n        // fraction := time_comm_us / (time_comm_us + tspi * time_per_row_us)  ==>  tspi = (time_comm_us/fraction - time_comm_us)/time_per_row_us\n        tspi = (long)((model.time_for_communication_us / fraction - model.time_for_communication_us)/ time_per_row_us);\n\n        tspi = Math.min(tspi, (mp._single_node_mode ? 1 : H2O.CLOUD.size()) * numRows * 10); //not more than 10x of what train_samples_per_iteration=-1 would do\n\n        // If the number is close to a multiple of epochs, use that -> prettier scoring\n        if (tspi > numRows && Math.abs(tspi % numRows)/(double)numRows < 0.2)  tspi = tspi - tspi % numRows;\n        tspi = Math.min(tspi, (long)(mp._epochs * numRows / 10)); //limit to number of epochs desired, but at least 10 iterations total\n        tspi = Math.max(1, tspi); //at least 1 point\n\n        if (!mp._quiet_mode) {\n          Log.info(\"Auto-tuning parameter 'train_samples_per_iteration':\");\n          Log.info(\"Estimated compute power : \" + (int)total_gflops + \" GFlops\");\n          Log.info(\"Estimated time for comm : \" + PrettyPrint.usecs((long) model.time_for_communication_us));\n          Log.info(\"Estimated time per row  : \" + ((long)time_per_row_us > 0 ? PrettyPrint.usecs((long) time_per_row_us) : time_per_row_us + \" usecs\"));\n          Log.info(\"Estimated training speed: \" + (int)(1e6/time_per_row_us) + \" rows/sec\");\n          Log.info(\"Setting train_samples_per_iteration (\" + mp._train_samples_per_iteration + \") to auto-tuned value: \" + tspi);\n        }\n\n      } else {\n        // limit user-given value to number of epochs desired\n        tspi = Math.max(1, Math.min(tspi, (long)(mp._epochs * numRows)));\n      }\n      assert(tspi != 0 && tspi != -1 && tspi != -2 && tspi >= 1);\n      return tspi;\n    }","commit_id":"73a89b4952c0a762f11fc1068854987cb9d52baa","url":"https://github.com/h2oai/h2o-3"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal SmartWriter wh = new SmartWriter(out);\n\t\tfinal Window self = (Window)comp;\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"\\\" z.type=\\\"zul.wnd.Wnd\\\" z.autoz=\\\"true\\\"\");\n\t\twh.write(self.getOuterAttrs()).write(self.getInnerAttrs()).write(\">\");\n\n\t\tfinal Caption caption = self.getCaption();\n\t\tfinal String title = self.getTitle(), titlesc = self.getTitleSclass();\n\t\tif (caption == null && title.length() == 0) {\n\t\t\tif (exec.isExplorer() && !exec.isExplorer7()) { /* Bug 1579515: to clickable, a child with 100% width is required for DIV */\n\t\t\t\twh.writeln(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\")\n\t\t\t\t\t.write(\"<tr height=\\\"1px\\\"><td><\/td><\/tr>\\n<\/table>\");\n\t\t\t}\n\t\t} else {\n\t\t\twh.writeln(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\tif (caption == null) {\n\t\t\t\twh.write(\"<tr id=\\\"\").write(uuid).write(\"!caption\\\" class=\\\"title\\\">\")\n\t\t\t\t  .write(\"<td class=\\\"l\").write(titlesc).writeln(\"\\\"><\/td>\")\n\t\t\t\t  .write(\"<td class=\\\"m\").write(titlesc).write(\"\\\">\");\n\t\t\t\tnew Out(title).render(out);\n\t\t\t\twh.writeln(\"<\/td>\");\n\n\t\t\t\tif (self.isClosable()) {\n\t\t\t\t\twh.write(\"<td width=\\\"16\\\" class=\\\"m\").write(titlesc).write(\"\\\"><img id=\\\"\")\n\t\t\t\t\t\t.write(uuid).write(\"!close\\\" src=\\\"\")\n\t\t\t\t\t\t.write(exec.encodeURL(\"~./zul/img/close-off.gif\")).writeln(\"\\\"/><\/td>\");\n\t\t\t\t}\n\n\t\t\t\twh.write(\"<td class=\\\"r\").write(titlesc).writeln(\"\\\"><\/td><\/tr>\");\n\t\t\t} else {\n\t\t\t\twh.write(\"<tr id=\\\"\").write(uuid).write(\"!caption\\\"><td class=\\\"l\")\n\t\t\t\t\t.write(titlesc).write(\"\\\"><\/td>\\n<td class=\\\"m\").write(titlesc).write(\"\\\">\")\n\t\t\t\t\t.write(caption)\n\t\t\t\t\t.write(\"<\/td>\\n<td class=\\\"r\").write(titlesc).writeln(\"\\\"><\/td><\/tr>\");\n\t\t\t}\n\t\t\twh.write(\"<\/table>\");\n\t\t}\n\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!cave\\\" class=\\\"\");\n\t\twh.write(self.getContentSclass()).write(\"\\\"\").writeAttr(\"style\", self.getContentStyle());\n\t\twh.write(\">\");\n\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component)it.next();\n\t\t\tif (child != caption)\n\t\t\t\twh.write(child);\n\t\t}\n\t\twh.write(\"<\/div><\/div>\"); /* we don't generate shadow here since it looks odd when on top of modal mask */\n\t}","id":71163,"modified_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal SmartWriter wh = new SmartWriter(out);\n\t\tfinal Window self = (Window)comp;\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"\\\" z.type=\\\"zul.wnd.Wnd\\\" z.autoz=\\\"true\\\"\");\n\t\twh.write(self.getOuterAttrs()).write(self.getInnerAttrs()).write(\">\");\n\n\t\tfinal Caption caption = self.getCaption();\n\t\tfinal String title = self.getTitle(), titlesc = self.getTitleSclass();\n\t\tString wcExtStyle;\n\t\tif (caption == null && title.length() == 0) {\n\t\t\twcExtStyle = \"\";\n\t\t\tif (exec.isExplorer() && !exec.isExplorer7()) { /* Bug 1579515: to clickable, a child with 100% width is required for DIV */\n\t\t\t\twh.writeln(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\")\n\t\t\t\t\t.write(\"<tr height=\\\"1px\\\"><td><\/td><\/tr>\\n<\/table>\");\n\t\t\t}\n\t\t} else {\n\t\t\twcExtStyle = \"border-top:0;\";\n\t\t\twh.writeln(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\tif (caption == null) {\n\t\t\t\twh.write(\"<tr id=\\\"\").write(uuid).write(\"!caption\\\" class=\\\"title\\\">\")\n\t\t\t\t  .write(\"<td class=\\\"l\").write(titlesc).writeln(\"\\\"><\/td>\")\n\t\t\t\t  .write(\"<td class=\\\"m\").write(titlesc).write(\"\\\">\");\n\t\t\t\tnew Out(title).render(out);\n\t\t\t\twh.writeln(\"<\/td>\");\n\n\t\t\t\tif (self.isClosable()) {\n\t\t\t\t\twh.write(\"<td width=\\\"16\\\" class=\\\"m\").write(titlesc).write(\"\\\"><img id=\\\"\")\n\t\t\t\t\t\t.write(uuid).write(\"!close\\\" src=\\\"\")\n\t\t\t\t\t\t.write(exec.encodeURL(\"~./zul/img/close-off.gif\")).writeln(\"\\\"/><\/td>\");\n\t\t\t\t}\n\n\t\t\t\twh.write(\"<td class=\\\"r\").write(titlesc).writeln(\"\\\"><\/td><\/tr>\");\n\t\t\t} else {\n\t\t\t\twh.write(\"<tr id=\\\"\").write(uuid).write(\"!caption\\\"><td class=\\\"l\")\n\t\t\t\t\t.write(titlesc).write(\"\\\"><\/td>\\n<td class=\\\"m\").write(titlesc).write(\"\\\">\")\n\t\t\t\t\t.write(caption)\n\t\t\t\t\t.write(\"<\/td>\\n<td class=\\\"r\").write(titlesc).writeln(\"\\\"><\/td><\/tr>\");\n\t\t\t}\n\t\t\twh.write(\"<\/table>\");\n\t\t}\n\n\t\tfinal String cs = self.getContentStyle();\n\t\tif(cs != null){\n\t\t\twcExtStyle += cs;\n\t\t}\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!cave\\\" class=\\\"\");\n\t\twh.write(self.getContentSclass()).write(\"\\\"\").writeAttr(\"style\", wcExtStyle);\n\t\twh.write(\">\");\n\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component)it.next();\n\t\t\tif (child != caption)\n\t\t\t\twh.write(child);\n\t\t}\n\t\twh.write(\"<\/div><\/div>\"); /* we don't generate shadow here since it looks odd when on top of modal mask */\n\t}","commit_id":"67ced29ecce67ae991230766fe4943c63fa50b13","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Window self = (Window)comp;\r\n\t\tfinal String uuid = self.getUuid();\r\n\t\t\r\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"\\\" z.type=\\\"zul.wnd2.Wnd2\\\" z.autoz=\\\"true\\\"\");\r\n\t\twh.write(self.getOuterAttrs()).write(self.getInnerAttrs()).write(\">\");\r\n\t\tfinal Caption caption = self.getCaption();\r\n\t\tfinal String title = self.getTitle(), titlesc = self.getTitleSclass();\r\n\t\tfinal boolean isEmbedded = self.inEmbedded();\r\n\t\tString wcExtStyle = \"\";\r\n\t\tif (caption != null || title.length() > 0) {\r\n\t\t\twh.write(\"<div class=\\\"l\").write(titlesc).write(\"\\\"><div class=\\\"r\")\r\n\t\t\t\t.write(titlesc).write(\"\\\"><div class=\\\"m\").write(titlesc).write(\"\\\"><div id=\\\"\")\r\n\t\t\t\t.write(uuid).write(\"!caption\\\" class=\\\"\").write(titlesc).write(\" title\\\">\");\r\n\t\t\tif (caption == null) {\r\n\t\t\t\tif (self.isClosable())\r\n\t\t\t\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!close\\\" class=\\\"z-window-tool z-window-close\\\"><\/div>\");\r\n\t\t\t\tif (self.isMaximizable()) {\r\n\t\t\t\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!maximize\\\" class=\\\"z-window-tool z-window-maximize\");\r\n\t\t\t\t\tif (self.isMaximized())\r\n\t\t\t\t\t\t\twh.write(\" z-window-maximized\");\r\n\t\t\t\t\twh.write(\"\\\"><\/div>\");\r\n\t\t\t\t}\r\n\t\t\t\tif (self.isMinimizable())\r\n\t\t\t\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!minimize\\\" class=\\\"z-window-tool z-window-minimize\\\"><\/div>\");\r\n\t\t\t\tnew Out(title).render(out);\r\n\t\t\t} else {\r\n\t\t\t\twh.write(caption);\r\n\t\t\t}\r\n\t\t\twh.write(\"<\/div><\/div><\/div><\/div>\");\r\n\t\t\twcExtStyle = \"border-top:0;\";\r\n\t\t} else if (!isEmbedded) {\r\n\t\t\twh.write(\"<div class=\\\"l\").write(titlesc).write(\"\\\"><div class=\\\"r\")\r\n\t\t\t\t.write(titlesc).write(\"\\\"><div class=\\\"m\").write(titlesc)\r\n\t\t\t\t.write(\"-notitle\\\"><\/div><\/div><\/div>\");\r\n\t\t}\r\n\t\tfinal String ccls = self.getContentSclass();\r\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!bwrap\\\" class=\\\"wc-bwrap\\\">\");\r\n\t\tif (!isEmbedded)\r\n\t\t\twh.write(\"<div class=\\\"l\").write(ccls).write(\"\\\"><div class=\\\"r\").write(ccls)\r\n\t\t\t\t.write(\"\\\"><div class=\\\"m\").write(ccls).write(\"\\\">\");\r\n\t\twcExtStyle += self.getContentStyle();\r\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!cave\\\" class=\\\"\");\r\n\t\twh.write(ccls).write(\"\\\"\").writeAttr(\"style\", wcExtStyle);\r\n\t\twh.write(\">\");\r\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\r\n\t\t\tfinal Component child = (Component)it.next();\r\n\t\t\tif (child != caption)\r\n\t\t\t\twh.write(child);\r\n\t\t}\r\n\t\twh.write(\"<\/div>\");\r\n\t\tfinal String mode = self.getMode();\r\n\t\tif (!isEmbedded)\r\n\t\t\twh.write(\"<\/div><\/div><\/div><div class=\\\"lwb-\").write(mode)\r\n\t\t\t\t.write(\"\\\"><div class=\\\"rwb-\").write(mode).write(\"\\\"><div class=\\\"mwb-\")\r\n\t\t\t\t.write(mode).write(\"\\\"><\/div><\/div><\/div>\");\r\n\t\twh.write(\"<\/div><\/div>\");\t\r\n\t}","id":71164,"modified_method":"public void render(Component comp, Writer out) throws IOException {\r\n\t\tfinal SmartWriter wh = new SmartWriter(out);\r\n\t\tfinal Window self = (Window)comp;\r\n\t\tfinal String uuid = self.getUuid();\r\n\t\t\r\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"\\\" z.type=\\\"zul.wnd2.Wnd2\\\" z.autoz=\\\"true\\\"\");\r\n\t\twh.write(self.getOuterAttrs()).write(self.getInnerAttrs()).write(\">\");\r\n\t\tfinal Caption caption = self.getCaption();\r\n\t\tfinal String title = self.getTitle(), titlesc = self.getTitleSclass();\r\n\t\tfinal boolean isEmbedded = self.inEmbedded();\r\n\t\tString wcExtStyle = \"\";\r\n\t\tif (caption != null || title.length() > 0) {\r\n\t\t\twh.write(\"<div class=\\\"l\").write(titlesc).write(\"\\\"><div class=\\\"r\")\r\n\t\t\t\t.write(titlesc).write(\"\\\"><div class=\\\"m\").write(titlesc).write(\"\\\"><div id=\\\"\")\r\n\t\t\t\t.write(uuid).write(\"!caption\\\" class=\\\"\").write(titlesc).write(\" title\\\">\");\r\n\t\t\tif (caption == null) {\r\n\t\t\t\tif (self.isClosable())\r\n\t\t\t\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!close\\\" class=\\\"z-window-tool z-window-close\\\"><\/div>\");\r\n\t\t\t\tif (self.isMaximizable()) {\r\n\t\t\t\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!maximize\\\" class=\\\"z-window-tool z-window-maximize\");\r\n\t\t\t\t\tif (self.isMaximized())\r\n\t\t\t\t\t\t\twh.write(\" z-window-maximized\");\r\n\t\t\t\t\twh.write(\"\\\"><\/div>\");\r\n\t\t\t\t}\r\n\t\t\t\tif (self.isMinimizable())\r\n\t\t\t\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!minimize\\\" class=\\\"z-window-tool z-window-minimize\\\"><\/div>\");\r\n\t\t\t\tnew Out(title).render(out);\r\n\t\t\t} else {\r\n\t\t\t\twh.write(caption);\r\n\t\t\t}\r\n\t\t\twh.write(\"<\/div><\/div><\/div><\/div>\");\r\n\t\t\twcExtStyle = \"border-top:0;\";\r\n\t\t} else if (!isEmbedded) {\r\n\t\t\twh.write(\"<div class=\\\"l\").write(titlesc).write(\"\\\"><div class=\\\"r\")\r\n\t\t\t\t.write(titlesc).write(\"\\\"><div class=\\\"m\").write(titlesc)\r\n\t\t\t\t.write(\"-notitle\\\"><\/div><\/div><\/div>\");\r\n\t\t}\r\n\t\tfinal String ccls = self.getContentSclass();\r\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!bwrap\\\" class=\\\"wc-bwrap\\\">\");\r\n\t\tif (!isEmbedded)\r\n\t\t\twh.write(\"<div class=\\\"l\").write(ccls).write(\"\\\"><div class=\\\"r\").write(ccls)\r\n\t\t\t\t.write(\"\\\"><div class=\\\"m\").write(ccls).write(\"\\\">\");\r\n\t\tfinal String cs = self.getContentStyle();\r\n\t\tif(cs != null){\r\n\t\t\twcExtStyle += cs;\r\n\t\t}\r\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!cave\\\" class=\\\"\");\r\n\t\twh.write(ccls).write(\"\\\"\").writeAttr(\"style\", wcExtStyle);\r\n\t\twh.write(\">\");\r\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\r\n\t\t\tfinal Component child = (Component)it.next();\r\n\t\t\tif (child != caption)\r\n\t\t\t\twh.write(child);\r\n\t\t}\r\n\t\twh.write(\"<\/div>\");\r\n\t\tfinal String mode = self.getMode();\r\n\t\tif (!isEmbedded)\r\n\t\t\twh.write(\"<\/div><\/div><\/div><div class=\\\"lwb-\").write(mode)\r\n\t\t\t\t.write(\"\\\"><div class=\\\"rwb-\").write(mode).write(\"\\\"><div class=\\\"mwb-\")\r\n\t\t\t\t.write(mode).write(\"\\\"><\/div><\/div><\/div>\");\r\n\t\twh.write(\"<\/div><\/div>\");\t\r\n\t}","commit_id":"ab4753fe40a5494e10f3565e7b1df46a3d6ce222","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal WriterHelper wh = new WriterHelper(out);\n\t\tfinal Caption self = (Caption)comp;\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\t\tfinal String imgTag = self.getImgTag();\n\t\t\n\t\tif(self.isLegend()){\n\t\t\tfinal String label = self.getLabel();\n\t\t\t\n\t\t\twh.write(\"<legend>\").write(imgTag).write(XMLs.escapeXML(label));\n\t\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\t\tfinal Component child = (Component)it.next();\n\t\t\t\tchild.redraw(out);\n\t\t\t}\n\t\t\twh.write(\"<\/legend>\");\n\t\t}else{\n\t\t\tfinal String clabel = self.getCompoundLabel();\n\t\t\t\n\t\t\twh.write(\"<table id=\\\"\").write(uuid).write(\"\\\" \");\n\t\t\twh.write(\"z.type=\\\"zul.widget.Capt\\\"\").write(self.getOuterAttrs()).write(self.getInnerAttrs());\n\t\t\twh.write(\" width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\twh.write(\"<tr valign=\\\"middle\\\">\");\n\t\t\twh.write(\"<td align=\\\"left\\\" class=\\\"caption\\\">\").write(imgTag);\n\t\t\t\n\t\t\tif(clabel==null || clabel.trim().length()==0){\n\t\t\t\twh.write(\"&nbsp;\");//<%-- bug 1688261: nbsp is required --%>\n\t\t\t}else{\n\t\t\t\twh.write(XMLs.escapeXML(clabel));\n\t\t\t}\n\t\t\twh.write(\"<\/td>\");\n\t\t\t\n\t\t\twh.write(\"<td align=\\\"right\\\" class=\\\"caption\\\" id=\\\"\").write(uuid).write(\"!cave\\\">\");\n\t\t\t\n\t\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\t\tfinal Component child = (Component)it.next();\n\t\t\t\tchild.redraw(out);\n\t\t\t}\n\t\t\tif(self.isClosableVisible()){\n\t\t\t\twh.write(\"<td width=\\\"16\\\"><img id=\\\"\").write(self.getParent().getUuid()).write(\"!close\\\" src=\\\"\");\n\t\t\t\twh.write(exec.encodeURL(\"~./zul/img/close-off.gif\")).write(\"\\\"/><\/td>\");\n\t\t\t}\n\t\t\t\n\t\t\twh.writeln(\"<\/tr><\/table>\");\n\t\t}\n\t}","id":71165,"modified_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal WriterHelper wh = new WriterHelper(out);\n\t\tfinal Caption self = (Caption)comp;\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\t\tfinal String imgTag = self.getImgTag();\n\t\t\n\t\tif(self.isLegend()){\n\t\t\tfinal String label = self.getLabel();\n\t\t\t\n\t\t\twh.write(\"<legend>\").write(imgTag).write(XMLs.escapeXML(label));\n\t\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\t\tfinal Component child = (Component)it.next();\n\t\t\t\tchild.redraw(out);\n\t\t\t}\n\t\t\twh.write(\"<\/legend>\");\n\t\t}else{\n\t\t\tfinal String clabel = self.getCompoundLabel();\n\t\t\t\n\t\t\twh.write(\"<table id=\\\"\").write(uuid).write(\"\\\" \");\n\t\t\twh.write(\"z.type=\\\"zul.widget.Capt\\\"\").write(self.getOuterAttrs()).write(self.getInnerAttrs());\n\t\t\twh.write(\" width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\twh.write(\"<tr valign=\\\"middle\\\">\");\n\t\t\twh.write(\"<td align=\\\"left\\\" class=\\\"caption\\\">\").write(imgTag);\n\t\t\t\n\t\t\tif(clabel==null || clabel.trim().length()==0){\n\t\t\t\twh.write(\"&nbsp;\");//<%-- bug 1688261: nbsp is required --%>\n\t\t\t}else{\n\t\t\t\twh.write(XMLs.escapeXML(clabel));\n\t\t\t}\n\t\t\twh.write(\"<\/td>\");\n\t\t\t\n\t\t\twh.write(\"<td align=\\\"right\\\" class=\\\"caption\\\" id=\\\"\").write(uuid).write(\"!cave\\\">\");\n\t\t\t\n\t\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\t\tfinal Component child = (Component)it.next();\n\t\t\t\tchild.redraw(out);\n\t\t\t}\n\t\t\twh.write(\"<\/td>\");\n\t\t\tif(self.isClosableVisible()){\n\t\t\t\twh.write(\"<td width=\\\"16\\\"><img id=\\\"\").write(self.getParent().getUuid()).write(\"!close\\\" src=\\\"\");\n\t\t\t\twh.write(exec.encodeURL(\"~./zul/img/close-off.gif\")).write(\"\\\"/><\/td>\");\n\t\t\t}\n\t\t\t\n\t\t\twh.writeln(\"<\/tr><\/table>\");\n\t\t}\n\t}","commit_id":"bce0126ce6fb6afe8cce0d922628f45eaec65c88","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal Groupbox self = (Groupbox)comp;\n\t\tfinal Caption caption = self.getCaption();\n\t\t\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\t\tout.write(\"<table id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"\\\" z.type=\\\"zul.widget.Grbox\\\"\");\n\t\tout.write(self.getOuterAttrs());\n\t\tout.write(self.getInnerAttrs());\n\t\tout.write(\"><tr valign=\\\"top\\\"><td>\");\n\t\t\n\t\tif(caption!=null){\n\t\t\tout.write(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\tout.write(\"<tr><td class=\\\"groupbox-3d-tl\\\"><\/td>\");\n\t\t\tout.write(\"<td colspan=\\\"3\\\" class=\\\"groupbox-3d-tm\\\"><\/td>\");\n\t\t\tout.write(\"<td class=\\\"groupbox-3d-tr\\\"><\/td><\/tr>\");\n\t\t\t\n\t\t\tout.write(\"<tr height=\\\"22\\\"><td class=\\\"groupbox-3d-ml\\\"><\/td>\");\n\t\t\tout.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\tout.write(\"<td class=\\\"groupbox-3d-mm\\\">\");\n\t\t\tcaption.redraw(out);\n\t\t\tout.write(\"<\/td>\");\n\t\t\tout.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\tout.write(\"<td class=\\\"groupbox-3d-mr\\\"><\/td><\/tr>\");\n\t\t\tout.write(\"<tr><td colspan=\\\"5\\\" class=\\\"groupbox-3d-b\\\"><\/td><\/tr>\");\n\t\t\tout.write(\"<\/table>\");\n\t\t}\n\t\t\n\t\tString gcExtStyle = \"\";\n\t\tif(caption!=null){\n\t\t\tgcExtStyle += \"border-top:0;\";\n\t\t}\n\t\tgcExtStyle+=self.getContentStyle();\n\t\t\n\t\tout.write(\"<div id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"!slide\\\" \");\n\t\tif(self.isOpen()){\n\t\t}else{\n\t\t\tout.write(\"style=\\\"display:none\\\" \");\n\t\t}\n\t\tout.write(\">\");\n\t\t\n\t\tout.write(\"<div id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"!cave\\\" \");\n\t\tout.write(\"class=\\\"\");\n\t\tout.write(self.getContentSclass());\n\t\tout.write(\"\\\"\");\n\t\tif (gcExtStyle.length() > 0) {\n\t\t\tout.write(\" style=\\\"\");\n\t\t\tout.write(gcExtStyle);\n\t\t\tout.write('\"');\n\t\t}\n\t\tout.write(\">\");\n\t\t\n\t\t\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component)it.next();\n\t\t\tif (child != caption)\n\t\t\t\tchild.redraw(out);\n\t\t}\n\t\t\n\t\tout.write(\"<\/div><\/div>\");\n\t\t\n\t\t//shadow\n\t\tout.write(\"<table id=\\\"\");\n\t\tout.write(self.getUuid());\n\t\tout.write(\"!sdw\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" width=\\\"100%\\\">\");\n\t\tout.write(\"<tr><td class=\\\"groupbox-3d-shdl\\\"><\/td>\");\n\t\tout.write(\"<td class=\\\"groupbox-3d-shdm\\\">\");\n\t\tout.write(\"<img width=\\\"1\\\" height=\\\"1\\\" src=\\\"\");\n\t\tout.write(exec.encodeURL(\"~./img/spacer.gif\"));\n\t\tout.write(\"\\\"/><\/td> \");\n\t\tout.write(\"<td class=\\\"groupbox-3d-shdr\\\"><\/td>\");\n\t\tout.write(\"<\/tr><\/table>\");\n\t\t\n\t\t\n\t\tout.write(\"<\/td><\/tr><\/table>\\n\");\n\n\t}","id":71166,"modified_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal Groupbox self = (Groupbox)comp;\n\t\tfinal Caption caption = self.getCaption();\n\t\t\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\t\tout.write(\"<table id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"\\\" z.type=\\\"zul.widget.Grbox\\\"\");\n\t\tout.write(self.getOuterAttrs());\n\t\tout.write(self.getInnerAttrs());\n\t\tout.write(\"><tr valign=\\\"top\\\"><td>\");\n\t\t\n\t\tif(caption!=null){\n\t\t\tout.write(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\tout.write(\"<tr><td class=\\\"groupbox-3d-tl\\\"><\/td>\");\n\t\t\tout.write(\"<td colspan=\\\"3\\\" class=\\\"groupbox-3d-tm\\\"><\/td>\");\n\t\t\tout.write(\"<td class=\\\"groupbox-3d-tr\\\"><\/td><\/tr>\");\n\t\t\t\n\t\t\tout.write(\"<tr height=\\\"22\\\"><td class=\\\"groupbox-3d-ml\\\"><\/td>\");\n\t\t\tout.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\tout.write(\"<td class=\\\"groupbox-3d-mm\\\">\");\n\t\t\tcaption.redraw(out);\n\t\t\tout.write(\"<\/td>\");\n\t\t\tout.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\tout.write(\"<td class=\\\"groupbox-3d-mr\\\"><\/td><\/tr>\");\n\t\t\tout.write(\"<tr><td colspan=\\\"5\\\" class=\\\"groupbox-3d-b\\\"><\/td><\/tr>\");\n\t\t\tout.write(\"<\/table>\");\n\t\t}\n\t\t\n\t\tString gcExtStyle = \"\";\n\t\tif(caption!=null){\n\t\t\tgcExtStyle += \"border-top:0;\";\n\t\t}\n\t\tfinal String cs = self.getContentStyle();\n\t\tif(cs!=null){\n\t\t\tgcExtStyle+=cs;\n\t\t}\n\t\t\n\t\tout.write(\"<div id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"!slide\\\" \");\n\t\tif(self.isOpen()){\n\t\t}else{\n\t\t\tout.write(\"style=\\\"display:none\\\" \");\n\t\t}\n\t\tout.write(\">\");\n\t\t\n\t\tout.write(\"<div id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"!cave\\\" \");\n\t\tout.write(\"class=\\\"\");\n\t\tout.write(self.getContentSclass());\n\t\tout.write(\"\\\"\");\n\t\tif (gcExtStyle.length() > 0) {\n\t\t\tout.write(\" style=\\\"\");\n\t\t\tout.write(gcExtStyle);\n\t\t\tout.write('\"');\n\t\t}\n\t\tout.write(\">\");\n\t\t\n\t\t\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component)it.next();\n\t\t\tif (child != caption)\n\t\t\t\tchild.redraw(out);\n\t\t}\n\t\t\n\t\tout.write(\"<\/div><\/div>\");\n\t\t\n\t\t//shadow\n\t\tout.write(\"<table id=\\\"\");\n\t\tout.write(self.getUuid());\n\t\tout.write(\"!sdw\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" width=\\\"100%\\\">\");\n\t\tout.write(\"<tr><td class=\\\"groupbox-3d-shdl\\\"><\/td>\");\n\t\tout.write(\"<td class=\\\"groupbox-3d-shdm\\\">\");\n\t\tout.write(\"<img width=\\\"1\\\" height=\\\"1\\\" src=\\\"\");\n\t\tout.write(exec.encodeURL(\"~./img/spacer.gif\"));\n\t\tout.write(\"\\\"/><\/td> \");\n\t\tout.write(\"<td class=\\\"groupbox-3d-shdr\\\"><\/td>\");\n\t\tout.write(\"<\/tr><\/table>\");\n\t\t\n\t\t\n\t\tout.write(\"<\/td><\/tr><\/table>\\n\");\n\n\t}","commit_id":"bce0126ce6fb6afe8cce0d922628f45eaec65c88","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal Label self = (Label)comp;\n\t\tfinal boolean idRequired = self.isIdRequired();\n\t\tif (idRequired) {\n\t\t\tout.write(\"<span id=\\\"\");\n\t\t\tout.write(self.getUuid());\n\t\t\tout.write(\"\\\"\");\n\t\t\tout.write(self.getOuterAttrs());\n\t\t\tout.write(self.getInnerAttrs());\n\t\t\tout.write('>');\n\t\t}\n\n\t\tout.write(self.getEncodedText());\n\n\t\tif (idRequired)\n\t\t\tout.write(\"<\/span>\");\n\t}","id":71167,"modified_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal WriterHelper wh = new WriterHelper(out);\n\t\tfinal Label self = (Label)comp;\n\t\tfinal boolean idRequired = self.isIdRequired();\n\t\tif (idRequired) {\n\t\t\twh.write(\"<span id=\\\"\").write(self.getUuid()).write(\"\\\"\");\n\t\t\twh.write(self.getOuterAttrs()).write(self.getInnerAttrs());\n\t\t\twh.write(\">\");\n\t\t}\n\n\t\twh.writeln(self.getEncodedText());\n\n\t\tif (idRequired)\n\t\t\twh.writeln(\"<\/span>\");\n\t}","commit_id":"bce0126ce6fb6afe8cce0d922628f45eaec65c88","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal Textbox self = (Textbox)comp;\n\t\tfinal boolean isMultiline = self.isMultiline();\n\t\tif(isMultiline){\n\t\t\tout.write(\"<textarea id=\\\"\");\n\t\t\tout.write(self.getUuid());\n\t\t\tout.write(\"\\\" z.type=\\\"zul.widget.Txbox\\\"\");\n\t\t\tout.write(self.getOuterAttrs());\n\t\t\tout.write(self.getOuterAttrs());\n\t\t\tout.write(self.getInnerAttrs());\n\t\t\tout.write(\">\");\n\t\t\tout.write(self.getAreaText());\n\t\t\tout.write(\"<\/textarea>\\n\");\n\t\t}else{\n\t\t\tout.write(\"<input id=\\\"\");\n\t\t\tout.write(self.getUuid());\n\t\t\tout.write(\"\\\" z.type=\\\"zul.widget.Txbox\\\"\");\n\t\t\tout.write(self.getOuterAttrs());\n\t\t\tout.write(self.getInnerAttrs());\n\t\t\tout.write(\"/>\\n\");\n\t\t}\n\t}","id":71168,"modified_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal WriterHelper wh = new WriterHelper(out);\n\t\tfinal Textbox self = (Textbox)comp;\n\t\tfinal boolean isMultiline = self.isMultiline();\n\t\tif(isMultiline){\n\t\t\twh.write(\"<textarea id=\\\"\").write(self.getUuid()).write(\"\\\" z.type=\\\"zul.widget.Txbox\\\"\");\n\t\t\twh.write(self.getOuterAttrs()).write(self.getInnerAttrs()).write(\">\");\n\t\t\twh.write(self.getAreaText());\n\t\t\twh.writeln(\"<\/textarea>\");\n\t\t}else{\n\t\t\twh.write(\"<input id=\\\"\").write(self.getUuid()).write(\"\\\" z.type=\\\"zul.widget.Txbox\\\"\");\n\t\t\twh.write(self.getOuterAttrs()).write(self.getInnerAttrs());\n\t\t\twh.writeln(\"/>\");\n\t\t}\n\t}","commit_id":"bce0126ce6fb6afe8cce0d922628f45eaec65c88","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal Window self = (Window)comp;\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\n\t\tout.write(\"<div id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"\\\" z.type=\\\"zul.wnd.Wnd\\\" z.autoz=\\\"true\\\"\");\n\t\tout.write(self.getOuterAttrs());\n\t\tout.write(self.getInnerAttrs());\n\t\tout.write(\">\\n\");\n\n\t\tfinal Caption caption = self.getCaption();\n\t\tfinal String title = self.getTitle(), titlesc = self.getTitleSclass();\n\t\tString wcExtStyle = \"\";\n\t\tif (caption == null && title.length() == 0) {\n\t\t\tif (exec.isExplorer() && !exec.isExplorer7()) {\n\t\t\t\tout.write(\n\t\t\t\t\t\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\"\n\t\t\t\t\t+\"<tr height=\\\"1px\\\"><td><\/td><\/tr><\/table>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\tout.write(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\\n\");\n\t\t\tif (caption == null) {\n\t\t\t\tout.write(\"<tr id=\\\"\");\n\t\t\t\tout.write(uuid);\n\t\t\t\tout.write(\"!caption\\\" class=\\\"title\\\">\\n\");\n\t\t\t\tout.write(\"<td class=\\\"l\");\n\t\t\t\tout.write(titlesc);\n\t\t\t\tout.write(\"\\\"><\/td>\\n\");\n\t\t\t\tout.write(\"<td class=\\\"m\");\n\t\t\t\tout.write(titlesc);\n\t\t\t\tout.write(\"\\\">\");\n\t\t\t\tout.write(XMLs.escapeXML(title));\n\t\t\t\tout.write(\"<\/td>\");\n\t\t\t\tif (self.isClosable()) {\n\t\t\t\t\tout.write(\"<td width=\\\"16\\\" class=\\\"m\");\n\t\t\t\t\tout.write(titlesc);\n\t\t\t\t\tout.write(\"\\\"><img id=\\\"\");\n\t\t\t\t\tout.write(uuid);\n\t\t\t\t\tout.write(\"!close\\\" src=\\\"\");\n\t\t\t\t\tout.write(exec.encodeURL(\"~./zul/img/close-off.gif\"));\n\t\t\t\t\tout.write(\"\\\"/><\/td>\");\n\t\t\t\t}\n\t\t\t\tout.write(\"<td class=\\\"r\");\n\t\t\t\tout.write(titlesc);\n\t\t\t\tout.write(\"\\\"><\/td><\/tr>\\n\");\n\t\t\t} else {\n\t\t\t\tout.write(\"<tr id=\\\"\");\n\t\t\t\tout.write(uuid);\n\t\t\t\tout.write(\"!caption\\\"><td class=\\\"l\");\n\t\t\t\tout.write(titlesc);\n\t\t\t\tout.write(\"\\\"><\/td><td class=\\\"m\");\n\t\t\t\tout.write(titlesc);\n\t\t\t\tout.write(\"\\\">\");\n\t\t\t\tcaption.redraw(out);\n\t\t\t\tout.write(\"<\/td><td class=\\\"r\");\n\t\t\t\tout.write(titlesc);\n\t\t\t\tout.write(\"\\\"><\/td><\/tr>\\n\");\n\t\t\t}\n\t\t\tout.write(\"<\/table>\\n\");\n\t\t\twcExtStyle = \"border-top:0;\";\n\t\t}\n\n\t\twcExtStyle += self.getContentStyle();\n\t\tout.write(\"<div id=\\\"\");\n\t\tout.write(uuid);\n\t\tout.write(\"!cave\\\" class=\\\"\");\n\t\tout.write(self.getContentSclass());\n\t\tout.write(\"\\\"\");\n\t\tif (wcExtStyle.length() > 0) {\n\t\t\tout.write(\" style=\\\"\");\n\t\t\tout.write(wcExtStyle);\n\t\t\tout.write('\"');\n\t\t}\n\t\tout.write(\">\");\n\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component)it.next();\n\t\t\tif (child != caption)\n\t\t\t\tchild.redraw(out);\n\t\t}\n\t\tout.write(\"<\/div><\/div>\\n\");\n\t}","id":71169,"modified_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal WriterHelper wh = new WriterHelper(out);\n\t\tfinal Window self = (Window)comp;\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\n\t\twh.write(\"<div id=\\\"\");\n\t\twh.write(uuid);\n\t\twh.write(\"\\\" z.type=\\\"zul.wnd.Wnd\\\" z.autoz=\\\"true\\\"\");\n\t\twh.write(self.getOuterAttrs());\n\t\twh.write(self.getInnerAttrs());\n\t\twh.write(\">\\n\");\n\n\t\tfinal Caption caption = self.getCaption();\n\t\tfinal String title = self.getTitle(), titlesc = self.getTitleSclass();\n\t\tString wcExtStyle = \"\";\n\t\tif (caption == null && title.length() == 0) {\n\t\t\tif (exec.isExplorer() && !exec.isExplorer7()) {\n\t\t\t\twh.write(\n\t\t\t\t\t\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\"\n\t\t\t\t\t+\"<tr height=\\\"1px\\\"><td><\/td><\/tr><\/table>\\n\");\n\t\t\t}\n\t\t} else {\n\t\t\twh.write(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\\n\");\n\t\t\tif (caption == null) {\n\t\t\t\twh.write(\"<tr id=\\\"\");\n\t\t\t\twh.write(uuid);\n\t\t\t\twh.write(\"!caption\\\" class=\\\"title\\\">\\n\");\n\t\t\t\twh.write(\"<td class=\\\"l\");\n\t\t\t\twh.write(titlesc);\n\t\t\t\twh.write(\"\\\"><\/td>\\n\");\n\t\t\t\twh.write(\"<td class=\\\"m\");\n\t\t\t\twh.write(titlesc);\n\t\t\t\twh.write(\"\\\">\");\n\t\t\t\twh.write(XMLs.escapeXML(title));\n\t\t\t\twh.write(\"<\/td>\");\n\t\t\t\tif (self.isClosable()) {\n\t\t\t\t\twh.write(\"<td width=\\\"16\\\" class=\\\"m\");\n\t\t\t\t\twh.write(titlesc);\n\t\t\t\t\twh.write(\"\\\"><img id=\\\"\");\n\t\t\t\t\twh.write(uuid);\n\t\t\t\t\twh.write(\"!close\\\" src=\\\"\");\n\t\t\t\t\twh.write(exec.encodeURL(\"~./zul/img/close-off.gif\"));\n\t\t\t\t\twh.write(\"\\\"/><\/td>\");\n\t\t\t\t}\n\t\t\t\twh.write(\"<td class=\\\"r\");\n\t\t\t\twh.write(titlesc);\n\t\t\t\twh.write(\"\\\"><\/td><\/tr>\\n\");\n\t\t\t} else {\n\t\t\t\twh.write(\"<tr id=\\\"\");\n\t\t\t\twh.write(uuid);\n\t\t\t\twh.write(\"!caption\\\"><td class=\\\"l\");\n\t\t\t\twh.write(titlesc);\n\t\t\t\twh.write(\"\\\"><\/td><td class=\\\"m\");\n\t\t\t\twh.write(titlesc);\n\t\t\t\twh.write(\"\\\">\");\n\t\t\t\tcaption.redraw(out);\n\t\t\t\twh.write(\"<\/td><td class=\\\"r\");\n\t\t\t\twh.write(titlesc);\n\t\t\t\twh.write(\"\\\"><\/td><\/tr>\\n\");\n\t\t\t}\n\t\t\twh.write(\"<\/table>\\n\");\n\t\t\twcExtStyle = \"border-top:0;\";\n\t\t}\n\n\t\tfinal String cs = self.getContentStyle();\n\t\tif(cs!=null){\n\t\t\twcExtStyle += cs;\n\t\t}\n\t\twh.write(\"<div id=\\\"\");\n\t\twh.write(uuid);\n\t\twh.write(\"!cave\\\" class=\\\"\");\n\t\twh.write(self.getContentSclass());\n\t\twh.write(\"\\\"\");\n\t\tif (wcExtStyle.length() > 0) {\n\t\t\twh.write(\" style=\\\"\");\n\t\t\twh.write(wcExtStyle);\n\t\t\twh.write(\"\\\"\");\n\t\t}\n\t\twh.write(\">\");\n\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component)it.next();\n\t\t\tif (child != caption)\n\t\t\t\tchild.redraw(out);\n\t\t}\n\t\twh.write(\"<\/div><\/div>\\n\");\n\t}","commit_id":"bce0126ce6fb6afe8cce0d922628f45eaec65c88","url":"https://github.com/zkoss/zk"},{"original_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal WriterHelper wh = new WriterHelper(out);\n\t\tfinal Groupbox self = (Groupbox) comp;\n\t\tfinal Caption caption = self.getCaption();\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\n\t\twh.write(\"<table id=\\\"\");\n\t\twh.write(uuid);\n\t\twh.write(\"\\\" z.type=\\\"zul.widget.Grbox\\\"\");\n\t\twh.write(self.getOuterAttrs());\n\t\twh.write(self.getInnerAttrs());\n\t\twh.write(\"><tr valign=\\\"top\\\"><td>\");\n\n\t\tif (caption != null) {\n\t\t\twh.write(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\twh.write(\"<tr><td class=\\\"groupbox-3d-tl\\\"><\/td>\");\n\t\t\twh.write(\"<td colspan=\\\"3\\\" class=\\\"groupbox-3d-tm\\\"><\/td>\");\n\t\t\twh.write(\"<td class=\\\"groupbox-3d-tr\\\"><\/td><\/tr>\");\n\n\t\t\twh.write(\"<tr height=\\\"22\\\"><td class=\\\"groupbox-3d-ml\\\"><\/td>\");\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\twh.write(\"<td class=\\\"groupbox-3d-mm\\\">\");\n\t\t\tif (caption != null) {\n\t\t\t\tcaption.redraw(out);\n\t\t\t}\n\t\t\twh.write(\"<\/td>\");\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\twh.write(\"<td class=\\\"groupbox-3d-mr\\\"><\/td><\/tr>\");\n\t\t\twh.write(\"<tr><td colspan=\\\"5\\\" class=\\\"groupbox-3d-b\\\"><\/td><\/tr>\");\n\t\t\twh.write(\"<\/table>\");\n\t\t}\n\n\t\tString gcExtStyle = StringFns.cat(caption == null ? \"\"\n\t\t\t\t: \"border-top:0;\", self.getContentStyle());\n\t\twh.write(\"<div id=\\\"\");\n\t\twh.write(uuid);\n\t\twh.write(\"!slide\\\"\");\n\t\tif (!self.isOpen()) {\n\t\t\twh.write(\" style=\\\"display:none\\\" \");\n\t\t}\n\n\t\twh.write(\">\");\n\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!cave\\\" class=\\\"\")\n\t\t\t.write(self.getContentSclass()).write(\"\\\"\")\n\t\t\t.writeAttr(\"style\", gcExtStyle).write(\">\");\n\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component) it.next();\n\t\t\tif (caption != child)\n\t\t\t\tchild.redraw(out);\n\t\t}\n\n\t\twh.write(\"<\/div><\/div>\");\n\n\t\t// shadow\n\t\twh.write(\"<table id=\\\"\");\n\t\twh.write(self.getUuid());\n\t\twh.write(\"!sdw\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" width=\\\"100%\\\">\");\n\t\twh.write(\"<tr><td class=\\\"groupbox-3d-shdl\\\"><\/td>\");\n\t\twh.write(\"<td class=\\\"groupbox-3d-shdm\\\">\");\n\t\twh.write(\"<img width=\\\"1\\\" height=\\\"1\\\" src=\\\"\");\n\t\twh.write(exec.encodeURL(\"~./img/spacer.gif\"));\n\t\twh.write(\"\\\"/><\/td> \");\n\t\twh.write(\"<td class=\\\"groupbox-3d-shdr\\\"><\/td>\");\n\t\twh.write(\"<\/tr><\/table>\");\n\n\t\twh.write(\"<\/td><\/tr><\/table>\");\n\t\twh.writeln();\n\t}","id":71170,"modified_method":"public void render(Component comp, Writer out) throws IOException {\n\t\tfinal WriterHelper wh = new WriterHelper(out);\n\t\tfinal Groupbox self = (Groupbox) comp;\n\t\tfinal Caption caption = self.getCaption();\n\t\tfinal String uuid = self.getUuid();\n\t\tfinal Execution exec = Executions.getCurrent();\n\n\t\twh.write(\"<table id=\\\"\");\n\t\twh.write(uuid);\n\t\twh.write(\"\\\" z.type=\\\"zul.widget.Grbox\\\"\");\n\t\twh.write(self.getOuterAttrs());\n\t\twh.write(self.getInnerAttrs());\n\t\twh.write(\"><tr valign=\\\"top\\\"><td>\");\n\t\tString gcExtStyle = \"\";\n\t\tif (caption != null) {\n\t\t\twh.write(\"<table width=\\\"100%\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\">\");\n\t\t\twh.write(\"<tr><td class=\\\"groupbox-3d-tl\\\"><\/td>\");\n\t\t\twh.write(\"<td colspan=\\\"3\\\" class=\\\"groupbox-3d-tm\\\"><\/td>\");\n\t\t\twh.write(\"<td class=\\\"groupbox-3d-tr\\\"><\/td><\/tr>\");\n\n\t\t\twh.write(\"<tr height=\\\"22\\\"><td class=\\\"groupbox-3d-ml\\\"><\/td>\");\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\twh.write(\"<td class=\\\"groupbox-3d-mm\\\">\");\n\t\t\tif (caption != null) {\n\t\t\t\tcaption.redraw(out);\n\t\t\t}\n\t\t\twh.write(\"<\/td>\");\n\t\t\twh.write(\"<td width=\\\"3\\\" class=\\\"groupbox-3d-mm\\\"><\/td>\");\n\t\t\twh.write(\"<td class=\\\"groupbox-3d-mr\\\"><\/td><\/tr>\");\n\t\t\twh.write(\"<tr><td colspan=\\\"5\\\" class=\\\"groupbox-3d-b\\\"><\/td><\/tr>\");\n\t\t\twh.write(\"<\/table>\");\n\t\t\tgcExtStyle =  \"border-top:0;\";\n\t\t}\n\t\t\n\t\tString cs = self.getContentStyle();\n\t\tif (cs != null) {\n\t\t\tgcExtStyle += cs;\n\t\t}\n\t\t\n\t\twh.write(\"<div id=\\\"\");\n\t\twh.write(uuid);\n\t\twh.write(\"!slide\\\"\");\n\t\tif (!self.isOpen()) {\n\t\t\twh.write(\" style=\\\"display:none\\\" \");\n\t\t}\n\n\t\twh.write(\">\");\n\n\t\twh.write(\"<div id=\\\"\").write(uuid).write(\"!cave\\\" class=\\\"\")\n\t\t\t.write(self.getContentSclass()).write(\"\\\"\")\n\t\t\t.writeAttr(\"style\", gcExtStyle).write(\">\");\n\n\t\tfor (Iterator it = self.getChildren().iterator(); it.hasNext();) {\n\t\t\tfinal Component child = (Component) it.next();\n\t\t\tif (caption != child)\n\t\t\t\tchild.redraw(out);\n\t\t}\n\n\t\twh.write(\"<\/div><\/div>\");\n\n\t\t// shadow\n\t\twh.write(\"<table id=\\\"\");\n\t\twh.write(self.getUuid());\n\t\twh.write(\"!sdw\\\" border=\\\"0\\\" cellpadding=\\\"0\\\" cellspacing=\\\"0\\\" width=\\\"100%\\\">\");\n\t\twh.write(\"<tr><td class=\\\"groupbox-3d-shdl\\\"><\/td>\");\n\t\twh.write(\"<td class=\\\"groupbox-3d-shdm\\\">\");\n\t\twh.write(\"<img width=\\\"1\\\" height=\\\"1\\\" src=\\\"\");\n\t\twh.write(exec.encodeURL(\"~./img/spacer.gif\"));\n\t\twh.write(\"\\\"/><\/td> \");\n\t\twh.write(\"<td class=\\\"groupbox-3d-shdr\\\"><\/td>\");\n\t\twh.write(\"<\/tr><\/table>\");\n\n\t\twh.write(\"<\/td><\/tr><\/table>\");\n\t\twh.writeln();\n\t}","commit_id":"6b15e32491e3b045db76f99ab06ed52091044197","url":"https://github.com/zkoss/zk"},{"original_method":"@NotNull\n  protected <T> T findNotNullChildByClass(Class<T> aClass) {\n    final T child = findChildByClass(aClass);\n    if (child == null) {\n      LOG.error(getText() + \"\\n parent=\" + getParent().getText());\n    }\n    return child;\n  }","id":71171,"modified_method":"@NotNull\n  protected <T> T findNotNullChildByClass(Class<T> aClass) {\n    return notNullChild(findChildByClass(aClass));\n  }","commit_id":"14515d04bdd896c53d81790ce970fb80f141be18","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ResolveResult[] multiResolveImpl() {\n    String name = getReferenceName();\n    GrDocReferenceElement holder = getReferenceHolder();\n    PsiElement resolved;\n    if (holder != null) {\n      GrCodeReferenceElement referenceElement = holder.getReferenceElement();\n      resolved = referenceElement.resolve();\n    } else {\n      resolved = getEnclosingClassOrFile(this);\n    }\n    if (resolved != null) {\n      PropertyResolverProcessor processor = new PropertyResolverProcessor(name, this, false);\n      resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, resolved, this);\n      return processor.getCandidates();\n    }\n    return new ResolveResult[0];\n  }","id":71172,"modified_method":"protected ResolveResult[] multiResolveImpl() {\n    String name = getReferenceName();\n    GrDocReferenceElement holder = getReferenceHolder();\n    PsiElement resolved;\n    if (holder != null) {\n      GrCodeReferenceElement referenceElement = holder.getReferenceElement();\n      resolved = referenceElement != null ? referenceElement.resolve() : null;\n    } else {\n      resolved = getEnclosingClassOrFile(this);\n    }\n    if (resolved != null) {\n      PropertyResolverProcessor processor = new PropertyResolverProcessor(name, this, false);\n      resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, resolved, this);\n      return processor.getCandidates();\n    }\n    return new ResolveResult[0];\n  }","commit_id":"54517ec31bc84c0f71d981433911617717f3c9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object[] getVariants() {\n    ArrayList<ResolveResult> candidates = new ArrayList<ResolveResult>();\n    GrDocReferenceElement holder = getReferenceHolder();\n    PsiElement resolved;\n    if (holder != null) {\n      GrCodeReferenceElement referenceElement = holder.getReferenceElement();\n      resolved = referenceElement.resolve();\n    } else {\n      resolved = getEnclosingClassOrFile(this);\n    }\n    if (resolved != null) {\n      PropertyResolverProcessor processor = new PropertyResolverProcessor(null, this, true);\n      resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, resolved, this);\n      candidates.addAll(Arrays.asList(processor.getCandidates()));\n    }\n    if (holder != null && resolved != null) {\n      MethodResolverProcessor processor = new MethodResolverProcessor(null, this, true, true, null, PsiType.EMPTY_ARRAY);\n      resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, resolved, this);\n      candidates.addAll(Arrays.asList(processor.getCandidates()));\n    }\n\n    ArrayList<PsiElement> variants = new ArrayList<PsiElement>();\n    for (ResolveResult candidate : candidates) {\n      variants.add(candidate.getElement());\n    }\n\n    return variants.toArray(new PsiElement[variants.size()]);\n\n  }","id":71173,"modified_method":"public Object[] getVariants() {\n    ArrayList<ResolveResult> candidates = getCandidates();\n    return filterCandidates(candidates);\n  }","commit_id":"54517ec31bc84c0f71d981433911617717f3c9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ResolveResult[] multiResolveImpl() {\n    String name = getReferenceName();\n    GrDocReferenceElement holder = getReferenceHolder();\n    if (holder == null) return new ResolveResult[0];\n\n    GrCodeReferenceElement referenceElement = holder.getReferenceElement();\n    PsiElement resolved = referenceElement.resolve();\n    if (resolved != null) {\n      PsiType[] parameterTypes = getParameterList().getParameterTypes();\n      MethodResolverProcessor processor = new MethodResolverProcessor(name, this, false, false, parameterTypes, PsiType.EMPTY_ARRAY);\n      resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, resolved, this);\n      return processor.getCandidates();\n    }\n    return new ResolveResult[0];\n  }","id":71174,"modified_method":"protected ResolveResult[] multiResolveImpl() {\n    String name = getReferenceName();\n    GrDocReferenceElement holder = getReferenceHolder();\n    if (holder == null) return new ResolveResult[0];\n\n    GrCodeReferenceElement referenceElement = holder.getReferenceElement();\n    if (referenceElement == null) return new ResolveResult[0];\n    PsiElement resolved = referenceElement.resolve();\n    if (resolved != null) {\n      PsiType[] parameterTypes = getParameterList().getParameterTypes();\n      MethodResolverProcessor processor = new MethodResolverProcessor(name, this, false, false, parameterTypes, PsiType.EMPTY_ARRAY);\n      resolved.processDeclarations(processor, PsiSubstitutor.EMPTY, resolved, this);\n      return processor.getCandidates();\n    }\n    return new ResolveResult[0];\n  }","commit_id":"54517ec31bc84c0f71d981433911617717f3c9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public GrCodeReferenceElement getReferenceElement() {\n    GrCodeReferenceElement element = findChildByClass(GrCodeReferenceElement.class);\n    assert element != null;\n    return element;\n  }","id":71175,"modified_method":"@Nullable\n  public GrCodeReferenceElement getReferenceElement() {\n    return findChildByClass(GrCodeReferenceElement.class);\n  }","commit_id":"54517ec31bc84c0f71d981433911617717f3c9eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean processDeclarations(@NotNull PsiScopeProcessor processor, @NotNull PsiSubstitutor substitutor, PsiElement lastParent, @NotNull PsiElement place) {\n    for (final GrParameter parameter : getParameters()) {\n      if (!ResolveUtil.processElement(processor, parameter)) return false;\n    }\n\n    return true;\n  }","id":71176,"modified_method":"public boolean processDeclarations(@NotNull PsiScopeProcessor processor, @NotNull PsiSubstitutor substitutor, PsiElement lastParent, @NotNull PsiElement place) {\n    if (!super.processDeclarations(processor, substitutor, lastParent, place)) return false;\n\n    for (final GrParameter parameter : getParameters()) {\n      if (!ResolveUtil.processElement(processor, parameter)) return false;\n    }\n\n    return true;\n  }","commit_id":"5024f3733a80d9736577b25e70d45caae6591de9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public GrModifierList getModifierList() {\n    GrModifierList modifierList = findChildByClass(GrModifierList.class);\n    assert modifierList != null;\n    return modifierList;\n  }","id":71177,"modified_method":"public GrModifierList getModifierList() {\n    return findChildByClass(GrModifierList.class);\n  }","commit_id":"5024f3733a80d9736577b25e70d45caae6591de9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void setUp() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n\n        BrokerPool pool = BrokerPool.getInstance();\n        DBBroker broker = null;\n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            TransactionManager transact = pool.getTransactionManager();\n\n            Txn transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n\n            Collection test = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n            broker.saveCollection(transaction, test);\n\n            IndexInfo info = test.validateXMLResource(transaction, broker, XmldbURI.create(\"test_string.xml\"), \n            \t\tTEST_XML);\n            //TODO : unlock the collection here ?\n            assertNotNull(info);\n\n            test.store(transaction, broker, info, TEST_XML, false);\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n        } catch (Exception e) {\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","id":71178,"modified_method":"protected void setUp() throws Exception {\n        String home, file = \"conf.xml\";\n        home = System.getProperty(\"exist.home\");\n        if (home == null)\n            home = System.getProperty(\"user.dir\");\n        try {\n            Configuration config = new Configuration(file, home);\n            BrokerPool.configure(1, 5, config);\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n\n        BrokerPool pool = BrokerPool.getInstance();\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;       \n        try {\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\n            transact = pool.getTransactionManager();\n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n\n            Collection test = broker.getOrCreateCollection(transaction, TEST_COLLECTION);\n            broker.saveCollection(transaction, test);\n\n            IndexInfo info = test.validateXMLResource(transaction, broker, XmldbURI.create(\"test_string.xml\"), \n            \t\tTEST_XML);\n            //TODO : unlock the collection here ?\n            assertNotNull(info);\n\n            test.store(transaction, broker, info, TEST_XML, false);\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n        } catch (Exception e) {\n        \ttransact.abort(transaction);\n            fail(e.getMessage());\n        } finally {\n            pool.release(broker);\n        }\n    }","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"@AfterClass\r\n    public static void closeDB() {\r\n        BrokerPool pool = null;\r\n        DBBroker broker = null;\r\n        try {\r\n            pool = BrokerPool.getInstance();\r\n            assertNotNull(pool);\r\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            assertNotNull(broker);\r\n            TransactionManager transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            Txn transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);\r\n            System.out.println(\"Transaction started ...\");\r\n\r\n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\r\n            assertNotNull(root);\r\n            broker.removeCollection(transaction, root);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null) pool.release(broker);\r\n        }\r\n        BrokerPool.stopAll(false);\r\n    }","id":71179,"modified_method":"@AfterClass\r\n    public static void closeDB() {\r\n        BrokerPool pool = null;\r\n        DBBroker broker = null;\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n            pool = BrokerPool.getInstance();\r\n            assertNotNull(pool);\r\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            assertNotNull(broker);\r\n            transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);\r\n            System.out.println(\"Transaction started ...\");\r\n\r\n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\r\n            assertNotNull(root);\r\n            broker.removeCollection(transaction, root);\r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n        \ttransact.abort(transaction);\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null) pool.release(broker);\r\n        }\r\n        BrokerPool.stopAll(false);\r\n    }","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"private void configureAndStore(String config) throws Exception {\r\n        DBBroker broker = null;\r\n        try {\r\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            assertNotNull(broker);\r\n            TransactionManager transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            Txn transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);\r\n\r\n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\r\n            assertNotNull(root);\r\n            CollectionConfigurationManager mgr = pool.getConfigurationManager();\r\n            mgr.addConfiguration(transaction, broker, root, config);\r\n\r\n            IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"test_matches.xml\"), XML);\r\n            assertNotNull(info);\r\n            root.store(transaction, broker, info, XML, false);\r\n            \r\n            transact.commit(transaction);\r\n        } finally {\r\n            pool.release(broker);\r\n        }\r\n    }","id":71180,"modified_method":"private void configureAndStore(String config) {\r\n        DBBroker broker = null;\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            assertNotNull(broker);\r\n            transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);\r\n\r\n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\r\n            assertNotNull(root);\r\n            CollectionConfigurationManager mgr = pool.getConfigurationManager();\r\n            mgr.addConfiguration(transaction, broker, root, config);\r\n\r\n            IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"test_matches.xml\"), XML);\r\n            assertNotNull(info);\r\n            root.store(transaction, broker, info, XML, false);\r\n            \r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n        \ttransact.abort(transaction);\r\n        \te.printStackTrace();\r\n        \tfail(e.getMessage());\r\n        } finally {\r\n            pool.release(broker);\r\n        }\r\n    }","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"@BeforeClass\r\n    public static void startDB() {\r\n        DBBroker broker = null;\r\n        try {\r\n            Configuration config = new Configuration();\r\n            BrokerPool.configure(1, 5, config);\r\n            pool = BrokerPool.getInstance();\r\n        \tassertNotNull(pool);\r\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            assertNotNull(broker);\r\n            TransactionManager transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            Txn transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);\r\n            System.out.println(\"Transaction started ...\");\r\n\r\n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\r\n            assertNotNull(root);\r\n            broker.saveCollection(transaction, root);\r\n\r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null)\r\n                pool.release(broker);\r\n        }\r\n    }","id":71181,"modified_method":"@BeforeClass\r\n    public static void startDB() {\r\n        DBBroker broker = null;\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n            Configuration config = new Configuration();\r\n            BrokerPool.configure(1, 5, config);\r\n            pool = BrokerPool.getInstance();\r\n        \tassertNotNull(pool);\r\n            broker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            assertNotNull(broker);\r\n            transact = pool.getTransactionManager();\r\n            assertNotNull(transact);\r\n            transaction = transact.beginTransaction();\r\n            assertNotNull(transaction);\r\n            System.out.println(\"Transaction started ...\");\r\n\r\n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\r\n            assertNotNull(root);\r\n            broker.saveCollection(transaction, root);\r\n\r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n        \ttransact.abort(transaction);\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null)\r\n                pool.release(broker);\r\n        }\r\n    }","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setUp() throws Exception {        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"NodeTest#setUp ...\");\n            \n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"test.xml\"), XML);\n            //TODO : unlock the collection here ?\n            assertNotNull(info);\n            root.store(transaction, broker, info, XML, false);\n            \n            transact.commit(transaction);\n            System.out.println(\"NodeTest#setUp finished.\");\n        } catch (Exception e) {            \n\t        fail(e.getMessage()); \t        \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n\t}","id":71182,"modified_method":"protected void setUp() throws Exception {        \n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"NodeTest#setUp ...\");\n            \n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            IndexInfo info = root.validateXMLResource(transaction, broker, XmldbURI.create(\"test.xml\"), XML);\n            //TODO : unlock the collection here ?\n            assertNotNull(info);\n            root.store(transaction, broker, info, XML, false);\n            \n            transact.commit(transaction);\n            System.out.println(\"NodeTest#setUp finished.\");\n        } catch (Exception e) {\n        \ttransact.abort(transaction);\n\t        fail(e.getMessage()); \t        \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n\t}","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void tearDown() {\n        DBBroker broker = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"BasicNodeSetTest#tearDown >>>\");\n            \n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\n            assertNotNull(root);\n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n        BrokerPool.stopAll(false);\n        root = null;\n        pool = null;\n    }","id":71183,"modified_method":"protected void tearDown() {\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"BasicNodeSetTest#tearDown >>>\");\n            \n            root = broker.getOrCreateCollection(transaction, XmldbURI.create(DBBroker.ROOT_COLLECTION + \"/test\"));\n            assertNotNull(root);\n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n        } catch (Exception e) {\n        \ttransact.abort(transaction);\n            e.printStackTrace();\n        } finally {\n            if (pool != null) pool.release(broker);\n        }\n        BrokerPool.stopAll(false);\n        root = null;\n        pool = null;\n    }","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI2);\n            broker.saveCollection(transaction, test2);\n            \n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            File f;\n            IndexInfo info;\n            \n            BinaryDocument doc = test2.addBinaryResource(transaction, broker, TestConstants.TEST_BINARY_URI, \"Some text data\".getBytes(), null);\n            assertNotNull(doc);\n            \n            // store some documents. Will be replaced below\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test2.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n//                \tTODO : why pass invalid couments ?\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            // replace some documents\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test2.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n//                \tTODO : why pass invalid couments ?\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n    \n            info = test2.validateXMLResource(transaction, broker, XmldbURI.create(\"test_string.xml\"), TEST_XML);\n            assertNotNull(info);\n            //TODO : unlock the collection here ?\n            \n            test2.store(transaction, broker, info, TEST_XML, false);            \n            // remove last document\n            test2.removeXMLResource(transaction, broker, XmldbURI.create(files[files.length - 1].getName()));            \n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            // the following transaction will not be committed. It will thus be rolled back by recovery\n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            test2.removeXMLResource(transaction, broker, XmldbURI.create(files[0].getName()));            \n            test2.removeBinaryResource(transaction, broker, doc);\n            \n//          Don't commit...            \n            transact.getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage()); \t        \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","id":71184,"modified_method":"public void testStore() {\n        BrokerPool.FORCE_CORRUPTION = true;\n        BrokerPool pool = null;        \n        DBBroker broker = null;\n        try {\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);            \n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI2);\n            broker.saveCollection(transaction, test2);\n            \n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            File f;\n            IndexInfo info;\n            \n            BinaryDocument doc = test2.addBinaryResource(transaction, broker, TestConstants.TEST_BINARY_URI, \"Some text data\".getBytes(), null);\n            assertNotNull(doc);\n            \n            // store some documents. Will be replaced below\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test2.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n//                \tTODO : why pass invalid couments ?\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            // replace some documents\n            for (int i = 0; i < files.length; i++) {\n                f = files[i];\n                try {\n                    info = test2.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n//                \tTODO : why pass invalid couments ?\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n    \n            info = test2.validateXMLResource(transaction, broker, XmldbURI.create(\"test_string.xml\"), TEST_XML);\n            assertNotNull(info);\n            //TODO : unlock the collection here ?\n            \n            test2.store(transaction, broker, info, TEST_XML, false);            \n            // remove last document\n            test2.removeXMLResource(transaction, broker, XmldbURI.create(files[files.length - 1].getName()));            \n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            // the following transaction will not be committed. It will thus be rolled back by recovery\n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            test2.removeXMLResource(transaction, broker, XmldbURI.create(files[0].getName()));            \n            test2.removeBinaryResource(transaction, broker, doc);\n            \n//          Don't commit...            \n            transact.getJournal().flushToLog(true);\n            System.out.println(\"Transaction interrupted ...\");\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());\n\t        e.printStackTrace();\n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;           \n        \n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/hamlet.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/test_string.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);            \n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            doc = broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(files[files.length - 1].getName()), Lock.READ_LOCK);\n            assertNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/'\" + files[files.length - 1].getName() + \" should not exist anymore\", doc);\n            \n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//SPEECH[LINE &= 'king']\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            System.out.println(\"Found: \" + seq.getItemCount());\n            for (SequenceIterator i = seq.iterate(); i.hasNext(); ) {\n                Item next = i.nextItem();\n                System.out.println(serializer.serialize((NodeValue) next));\n            }\n            \n            BinaryDocument binDoc = (BinaryDocument) broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(TestConstants.TEST_BINARY_URI), Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            data = new String(broker.getBinaryResource(binDoc));\n            assertNotNull(data);\n            System.out.println(data);\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());             \n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","id":71185,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;           \n        \n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/hamlet.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/test_string.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);            \n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            doc = broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(files[files.length - 1].getName()), Lock.READ_LOCK);\n            assertNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/'\" + files[files.length - 1].getName() + \" should not exist anymore\", doc);\n            \n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//SPEECH[LINE &= 'king']\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            System.out.println(\"Found: \" + seq.getItemCount());\n            for (SequenceIterator i = seq.iterate(); i.hasNext(); ) {\n                Item next = i.nextItem();\n                System.out.println(serializer.serialize((NodeValue) next));\n            }\n            \n            BinaryDocument binDoc = (BinaryDocument) broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(TestConstants.TEST_BINARY_URI), Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            data = new String(broker.getBinaryResource(binDoc));\n            assertNotNull(data);\n            System.out.println(data);\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());\n\t        e.printStackTrace();\n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"4dff18a56e53b3de2243a1d74ad9b6011aea7921","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setUp() {\n        try {\n            // initialize driver\n            Class cl = Class.forName(DRIVER);\n            Database database = (Database) cl.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n            Collection root = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION, \"admin\", null);\n            CollectionManagementService service = (CollectionManagementService) root\n                    .getService(\"CollectionManagementService\", \"1.0\");\n            testCollection = service.createCollection(TEST_COLLECTION.toString());\n            assertNotNull(testCollection);\n\n            Collection configColl = DatabaseManager.getCollection(URI + CONF_COLL_URI.toString(), \"admin\", null);\n         \tif(configColl == null) {\n           \t  System.out.println(\"creating collection '\" + CONF_COLL_URI + \"'\");\n           \t  CollectionManagementService cms = (CollectionManagementService)testCollection.getService(\"CollectionManagementService\", \"1.0\");\n           \t  configColl = cms.createCollection(CONF_COLL_URI.toString());\n         \t}\n         \tif(configColl == null) {\n         \t\tfail(\"Could not create config collection: \"+CONF_COLL_URI);\n         \t}\n        } catch (Exception e) {\n            fail(e.getMessage());\n        }\n    }","id":71186,"modified_method":"protected void setUp() {\n        try {\n            // initialize driver\n            Class cl = Class.forName(DRIVER);\n            Database database = (Database) cl.newInstance();\n            database.setProperty(\"create-database\", \"true\");\n            DatabaseManager.registerDatabase(database);\n            Collection root = DatabaseManager.getCollection(URI + DBBroker.ROOT_COLLECTION, \"admin\", null);\n            CollectionManagementService service = (CollectionManagementService) root\n                    .getService(\"CollectionManagementService\", \"1.0\");\n            testCollection = service.createCollection(TEST_COLLECTION.toString());\n            assertNotNull(testCollection);\n\n            Collection configColl = DatabaseManager.getCollection(URI + CONF_COLL_URI.toString(), \"admin\", null);\n         \tif(configColl == null) {\n           \t  System.out.println(\"creating collection '\" + CONF_COLL_URI + \"'\");\n           \t  CollectionManagementService cms = (CollectionManagementService)testCollection.getService(\"CollectionManagementService\", \"1.0\");\n           \t  configColl = cms.createCollection(CONF_COLL_URI.toString());\n         \t}\n         \tif(configColl == null) {\n         \t\tfail(\"Could not create config collection: \"+CONF_COLL_URI);\n         \t}\n        } catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","commit_id":"0cfe444a309746327f7da111cb0f6604ce84192e","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\r\n     * Remove nodes from different levels of the tree and check if the index is\r\n     * correctly updated.\r\n     */\r\n    public void testXUpdateRemove() {\r\n        DBBroker broker = null;\r\n        try {\r\n        \tbroker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            TransactionManager transact = pool.getTransactionManager();\r\n            Txn transaction = transact.beginTransaction();\r\n            \r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            checkIndex(broker, docs, \"le8\", 1);\r\n\r\n            XQuery xquery = broker.getXQueryService();\r\n            assertNotNull(xquery);\r\n            Sequence seq = xquery.execute(\"//item[ngram:contains(., 'cha')]\", null, AccessContext.TEST);\r\n            assertNotNull(seq);\r\n            assertEquals(1, seq.getItemCount());\r\n\r\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs, AccessContext.TEST);\r\n            assertNotNull(proc);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            String xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='2']/price\\\"/>\" +\r\n                    XUPDATE_END;\r\n            Modification[] modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"892\", 0);\r\n            checkIndex(broker, docs, \"tab\", 1);\r\n            checkIndex(broker, docs, \"le8\", 0);\r\n\r\n            checkIndex(broker, docs, \"cab\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='3']/description/text()\\\"/>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"cab\", 0);\r\n\r\n            checkIndex(broker, docs, \"att\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='1']/@attr\\\"/>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"att\", 0);\r\n\r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='1']\\\"/>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"cha\", 0);\r\n            \r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null) {\r\n                pool.release(broker);\r\n            }\r\n        }\r\n    }","id":71187,"modified_method":"/**\r\n     * Remove nodes from different levels of the tree and check if the index is\r\n     * correctly updated.\r\n     */\r\n    public void testXUpdateRemove() {\r\n        DBBroker broker = null;\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n        \tbroker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            transact = pool.getTransactionManager();\r\n            transaction = transact.beginTransaction();\r\n            \r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            checkIndex(broker, docs, \"le8\", 1);\r\n\r\n            XQuery xquery = broker.getXQueryService();\r\n            assertNotNull(xquery);\r\n            Sequence seq = xquery.execute(\"//item[ngram:contains(., 'cha')]\", null, AccessContext.TEST);\r\n            assertNotNull(seq);\r\n            assertEquals(1, seq.getItemCount());\r\n\r\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs, AccessContext.TEST);\r\n            assertNotNull(proc);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            String xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='2']/price\\\"/>\" +\r\n                    XUPDATE_END;\r\n            Modification[] modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"892\", 0);\r\n            checkIndex(broker, docs, \"tab\", 1);\r\n            checkIndex(broker, docs, \"le8\", 0);\r\n\r\n            checkIndex(broker, docs, \"cab\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='3']/description/text()\\\"/>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"cab\", 0);\r\n\r\n            checkIndex(broker, docs, \"att\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='1']/@attr\\\"/>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"att\", 0);\r\n\r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:remove select=\\\"//item[@id='1']\\\"/>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"cha\", 0);\r\n            \r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n            transact.abort(transaction);\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null) {\r\n                pool.release(broker);\r\n            }\r\n        }\r\n    }","commit_id":"0cfe444a309746327f7da111cb0f6604ce84192e","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testXUpdateInsert() {\r\n        DBBroker broker = null;\r\n        try {\r\n        \tbroker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            TransactionManager transact = pool.getTransactionManager();\r\n            Txn transaction = transact.beginTransaction();\r\n\r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            checkIndex(broker, docs, \"le8\", 1);\r\n\r\n            XQuery xquery = broker.getXQueryService();\r\n            assertNotNull(xquery);\r\n            Sequence seq = xquery.execute(\"//item[ngram:contains(., 'cha')]\", null, AccessContext.TEST);\r\n            assertNotNull(seq);\r\n            assertEquals(1, seq.getItemCount());\r\n\r\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs, AccessContext.TEST);\r\n            assertNotNull(proc);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            String xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:append select=\\\"/test\\\">\" +\r\n                    \"       <item id='4'><description>Armchair<\/description><price>340<\/price><\/item>\" +\r\n                    \"   <\/xu:append>\" +\r\n                    XUPDATE_END;\r\n            Modification[] modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"arm\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-before select=\\\"//item[@id = '1']\\\">\" +\r\n                    \"           <item id='0'><description>Wheelchair<\/description><price>1230<\/price><\/item>\" +\r\n                    \"       <\/xu:insert-before>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"hee\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-after select=\\\"//item[@id = '1']\\\">\" +\r\n                    \"           <item id='1.1'><description>refrigerator<\/description><price>777<\/price><\/item>\" +\r\n                    \"       <\/xu:insert-after>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"ref\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-after select=\\\"//item[@id = '1']/description\\\">\" +\r\n                    \"           <price>999<\/price>\" +\r\n                    \"       <\/xu:insert-after>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"999\", 1);\r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            checkIndex(broker, docs, \"ir9\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-before select=\\\"//item[@id = '1']/description\\\">\" +\r\n                    \"           <price>888<\/price>\" +\r\n                    \"       <\/xu:insert-before>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"999\", 1);\r\n            checkIndex(broker, docs, \"888\", 1);\r\n            checkIndex(broker, docs, \"88c\", 1);\r\n\r\n            checkIndex(broker, docs, \"att\", 1);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:append select=\\\"//item[@id = '1']\\\">\" +\r\n                    \"           <xu:attribute name=\\\"attr\\\">abc<\/xu:attribute>\" +\r\n                    \"       <\/xu:append>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n            checkIndex(broker, docs, \"att\", 0);\r\n            checkIndex(broker, docs, \"abc\", 1);\r\n\r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null) {\r\n                pool.release(broker);\r\n            }\r\n        }\r\n    }","id":71188,"modified_method":"public void testXUpdateInsert() {\r\n        DBBroker broker = null;\r\n        TransactionManager transact = null;\r\n        Txn transaction = null;\r\n        try {\r\n        \tbroker = pool.get(org.exist.security.SecurityManager.SYSTEM_USER);\r\n            transact = pool.getTransactionManager();\r\n            transaction = transact.beginTransaction();\r\n\r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            checkIndex(broker, docs, \"le8\", 1);\r\n\r\n            XQuery xquery = broker.getXQueryService();\r\n            assertNotNull(xquery);\r\n            Sequence seq = xquery.execute(\"//item[ngram:contains(., 'cha')]\", null, AccessContext.TEST);\r\n            assertNotNull(seq);\r\n            assertEquals(1, seq.getItemCount());\r\n\r\n            XUpdateProcessor proc = new XUpdateProcessor(broker, docs, AccessContext.TEST);\r\n            assertNotNull(proc);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            String xupdate =\r\n                    XUPDATE_START +\r\n                    \"   <xu:append select=\\\"/test\\\">\" +\r\n                    \"       <item id='4'><description>Armchair<\/description><price>340<\/price><\/item>\" +\r\n                    \"   <\/xu:append>\" +\r\n                    XUPDATE_END;\r\n            Modification[] modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"arm\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-before select=\\\"//item[@id = '1']\\\">\" +\r\n                    \"           <item id='0'><description>Wheelchair<\/description><price>1230<\/price><\/item>\" +\r\n                    \"       <\/xu:insert-before>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"hee\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-after select=\\\"//item[@id = '1']\\\">\" +\r\n                    \"           <item id='1.1'><description>refrigerator<\/description><price>777<\/price><\/item>\" +\r\n                    \"       <\/xu:insert-after>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"ref\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-after select=\\\"//item[@id = '1']/description\\\">\" +\r\n                    \"           <price>999<\/price>\" +\r\n                    \"       <\/xu:insert-after>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"999\", 1);\r\n            checkIndex(broker, docs, \"cha\", 1);\r\n            checkIndex(broker, docs, \"ir9\", 1);\r\n\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:insert-before select=\\\"//item[@id = '1']/description\\\">\" +\r\n                    \"           <price>888<\/price>\" +\r\n                    \"       <\/xu:insert-before>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n\r\n            checkIndex(broker, docs, \"999\", 1);\r\n            checkIndex(broker, docs, \"888\", 1);\r\n            checkIndex(broker, docs, \"88c\", 1);\r\n\r\n            checkIndex(broker, docs, \"att\", 1);\r\n            proc.setBroker(broker);\r\n            proc.setDocumentSet(docs);\r\n            xupdate =\r\n                    XUPDATE_START +\r\n                    \"       <xu:append select=\\\"//item[@id = '1']\\\">\" +\r\n                    \"           <xu:attribute name=\\\"attr\\\">abc<\/xu:attribute>\" +\r\n                    \"       <\/xu:append>\" +\r\n                    XUPDATE_END;\r\n            modifications = proc.parse(new InputSource(new StringReader(xupdate)));\r\n            assertNotNull(modifications);\r\n            modifications[0].process(transaction);\r\n            proc.reset();\r\n            checkIndex(broker, docs, \"att\", 0);\r\n            checkIndex(broker, docs, \"abc\", 1);\r\n\r\n            transact.commit(transaction);\r\n        } catch (Exception e) {\r\n            transact.abort(transaction);\r\n            e.printStackTrace();\r\n            fail(e.getMessage());\r\n        } finally {\r\n            if (pool != null) {\r\n                pool.release(broker);\r\n            }\r\n        }\r\n    }","commit_id":"0cfe444a309746327f7da111cb0f6604ce84192e","url":"https://github.com/eXist-db/exist"},{"original_method":"@AfterClass\r\n    public static void shutdownDB() {\r\n        try {\r\n            CollectionManagementService service =\r\n                    (CollectionManagementService) testCollection.getService(\"CollectionManagementService\", \"1.0\");\r\n            service.removeCollection(\".\");\r\n\r\n            Collection system = DatabaseManager.getCollection(\"xmldb:exist:///db/system/config/db\", \"admin\", null);\r\n            service = (CollectionManagementService) system.getService(\"CollectionManagementService\", \"1.0\");\r\n            service.removeCollection(\".\");\r\n\r\n            DatabaseInstanceManager dim =\r\n                (DatabaseInstanceManager) testCollection.getService(\r\n                    \"DatabaseInstanceManager\", \"1.0\");\r\n            dim.shutdown();\r\n        } catch (XMLDBException e) {\r\n            e.printStackTrace();\r\n            Assert.fail(e.getMessage());\r\n        }\r\n        testCollection = null;\r\n\r\n\t\tSystem.out.println(\"tearDown PASSED\");\r\n\t}","id":71189,"modified_method":"@AfterClass\r\n    public static void shutdownDB() {\r\n        try {\r\n            TestUtils.cleanupDB();\r\n            DatabaseInstanceManager dim =\r\n                (DatabaseInstanceManager) testCollection.getService(\r\n                    \"DatabaseInstanceManager\", \"1.0\");\r\n            dim.shutdown();\r\n        } catch (XMLDBException e) {\r\n            e.printStackTrace();\r\n            Assert.fail(e.getMessage());\r\n        }\r\n        testCollection = null;\r\n\r\n\t\tSystem.out.println(\"tearDown PASSED\");\r\n\t}","commit_id":"0cfe444a309746327f7da111cb0f6604ce84192e","url":"https://github.com/eXist-db/exist"},{"original_method":"protected void setUp() {\n\t\ttry {\n\t\t\t// initialize driver\n\t\t\tClass cl = Class.forName(DRIVER);\n\t\t\tDatabase database = (Database) cl.newInstance();\n\t\t\tdatabase.setProperty(\"create-database\", \"true\");\n\t\t\tDatabaseManager.registerDatabase(database);\n            Collection root = DatabaseManager.getCollection(URI);\n            CollectionManagementService service =\n                (CollectionManagementService) root.getService(\n                    \"CollectionManagementService\",\n                    \"1.0\");\n            assertNotNull(service);\n            Collection testCollection = service.createCollection(\"test\");\n            assertNotNull(testCollection);\n            \n            String directory = \"samples/shakespeare\";\n            String existHome = System.getProperty(\"exist.home\");\n            File existDir = existHome==null ? new File(\".\") : new File(existHome);\n            File dir = new File(existDir,directory);\n            File files[] = dir.listFiles(new XMLFilenameFilter());\n\n            for (int i = 0; i < files.length; i++) {\n                XMLResource res = (XMLResource) testCollection.createResource(files[i].getName(), \"XMLResource\");\n                res.setContent(files[i]);\n                testCollection.storeResource(res);\n            }\n\t\t} catch (Exception e) {\n\t\t\tfail(e.getMessage());\n\t\t}\n\t}","id":71190,"modified_method":"protected void setUp() {\n\t\ttry {\n\t\t\t// initialize driver\n\t\t\tClass cl = Class.forName(DRIVER);\n\t\t\tDatabase database = (Database) cl.newInstance();\n\t\t\tdatabase.setProperty(\"create-database\", \"true\");\n\t\t\tDatabaseManager.registerDatabase(database);\n            Collection root = DatabaseManager.getCollection(URI);\n            CollectionManagementService service =\n                (CollectionManagementService) root.getService(\n                    \"CollectionManagementService\",\n                    \"1.0\");\n            assertNotNull(service);\n            Collection testCollection = service.createCollection(\"test\");\n            assertNotNull(testCollection);\n            \n            String directory = \"samples/shakespeare\";\n            String existHome = System.getProperty(\"exist.home\");\n            File existDir = existHome==null ? new File(\".\") : new File(existHome);\n            File dir = new File(existDir,directory);\n            File files[] = dir.listFiles(new XMLFilenameFilter());\n\n            for (int i = 0; i < files.length; i++) {\n                XMLResource res = (XMLResource) testCollection.createResource(files[i].getName(), \"XMLResource\");\n                res.setContent(files[i]);\n                testCollection.storeResource(res);\n            }\n\t\t} catch (Exception e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n\t\t}\n\t}","commit_id":"0cfe444a309746327f7da111cb0f6604ce84192e","url":"https://github.com/eXist-db/exist"},{"original_method":"@AfterClass\n    public static void closeDB() {\n        try {\n            Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", null);\n            CollectionManagementService cmgr = (CollectionManagementService) root.getService(\"CollectionManagementService\", \"1.0\");\n            cmgr.removeCollection(\"triggers\");\n\n            Collection configRoot = DatabaseManager.getCollection(\"xmldb:exist://\" + CollectionConfigurationManager.CONFIG_COLLECTION,\n                    \"admin\", null);\n            cmgr = (CollectionManagementService) configRoot.getService(\"CollectionManagementService\", \"1.0\");\n            cmgr.removeCollection(\"db\");\n            DatabaseInstanceManager mgr = (DatabaseInstanceManager) root.getService(\"DatabaseInstanceManager\", \"1.0\");\n            mgr.shutdown();\n        } catch (XMLDBException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","id":71191,"modified_method":"@AfterClass\n    public static void closeDB() {\n        TestUtils.cleanupDB();\n        try {\n            Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", null);\n            DatabaseInstanceManager mgr = (DatabaseInstanceManager) root.getService(\"DatabaseInstanceManager\", \"1.0\");\n            mgr.shutdown();\n        } catch (XMLDBException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","commit_id":"0cfe444a309746327f7da111cb0f6604ce84192e","url":"https://github.com/eXist-db/exist"},{"original_method":"@AfterClass\n    public static void shutdownDB() {\n        try {\n            Collection root = DatabaseManager.getCollection(URI, \"admin\", null);\n            CollectionManagementService service = (CollectionManagementService)\n                    root.getService(\"CollectionManagementService\", \"1.0\");\n            service.removeCollection(TEST_COLLECTION);\n            testCollection = null;\n        } catch (XMLDBException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n    }","id":71192,"modified_method":"@AfterClass\n    public static void shutdownDB() {\n        TestUtils.cleanupDB();\n        try {\n            Collection root = DatabaseManager.getCollection(\"xmldb:exist://\" + DBBroker.ROOT_COLLECTION, \"admin\", null);\n            DatabaseInstanceManager mgr = (DatabaseInstanceManager) root.getService(\"DatabaseInstanceManager\", \"1.0\");\n            mgr.shutdown();\n        } catch (XMLDBException e) {\n            e.printStackTrace();\n            fail(e.getMessage());\n        }\n        testCollection = null;\n    }","commit_id":"0cfe444a309746327f7da111cb0f6604ce84192e","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testReadAborted() {\n\t    BrokerPool.FORCE_CORRUPTION = false;\n\t    BrokerPool pool = null;\n\t    DBBroker broker = null;\n\t    try {\n\t    \tSystem.out.println(\"testRead() ...\\n\");\n\t    \tpool = startDB();\n\t    \tassertNotNull(pool);\n\t        broker = pool.get(SecurityManager.SYSTEM_USER);\n\t        assertNotNull(broker);\n\t        Serializer serializer = broker.getSerializer();\n\t        serializer.reset();\n\n\t        DocumentImpl doc = broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(\"new_test2.xml\"), Lock.READ_LOCK);\n\t        assertNotNull(\"Document should not be null\", doc);\n\t        String data = serializer.serialize(doc);\n\t        assertNotNull(data);\n//\t        System.out.println(data);\n\t        doc.getUpdateLock().release(Lock.READ_LOCK);\n\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);\n            broker.removeCollection(transaction, root);\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {\n            e.printStackTrace();\n\t        fail(e.getMessage());\n\t    } finally {\n\t        pool.release(broker);\n\t    }\n\t}","id":71193,"modified_method":"public void testReadAborted() {\n\t    BrokerPool.FORCE_CORRUPTION = false;\n\t    BrokerPool pool = null;\n\t    DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n\t    try {\n\t    \tSystem.out.println(\"testRead() ...\\n\");\n\t    \tpool = startDB();\n\t    \tassertNotNull(pool);\n\t        broker = pool.get(SecurityManager.SYSTEM_USER);\n\t        assertNotNull(broker);\n\t        Serializer serializer = broker.getSerializer();\n\t        serializer.reset();\n\n\t        DocumentImpl doc = broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(\"new_test2.xml\"), Lock.READ_LOCK);\n\t        assertNotNull(\"Document should not be null\", doc);\n\t        String data = serializer.serialize(doc);\n\t        assertNotNull(data);\n//\t        System.out.println(data);\n\t        doc.getUpdateLock().release(Lock.READ_LOCK);\n\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);\n            broker.removeCollection(transaction, root);\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n\t        fail(e.getMessage());\n\t    } finally {\n\t        pool.release(broker);\n\t    }\n\t}","commit_id":"c9ad221a3a5f898d12df33a1b19166ba900d8076","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() {\n\t    BrokerPool.FORCE_CORRUPTION = false;\n\t    BrokerPool pool = null;\n\t    DBBroker broker = null;\n\t    try {\n\t    \tSystem.out.println(\"testRead() ...\\n\");\n\t    \tpool = startDB();\n\t    \tassertNotNull(pool);\n\t        broker = pool.get(SecurityManager.SYSTEM_USER);\n\t        assertNotNull(broker);\n\t        Serializer serializer = broker.getSerializer();\n\t        serializer.reset();\n\n\t        DocumentImpl doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/new_test.xml\"), Lock.READ_LOCK);\n\t        assertNotNull(\"Document should not be null\", doc);\n\t        String data = serializer.serialize(doc);\n\t        assertNotNull(data);\n//\t        System.out.println(data);\n\t        doc.getUpdateLock().release(Lock.READ_LOCK);\n\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);\n            broker.removeCollection(transaction, root);\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {\n            e.printStackTrace();\n\t        fail(e.getMessage());\n\t    } finally {\n\t        pool.release(broker);\n\t    }\n\t}","id":71194,"modified_method":"public void testRead() {\n\t    BrokerPool.FORCE_CORRUPTION = false;\n\t    BrokerPool pool = null;\n\t    DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n\t    try {\n\t    \tSystem.out.println(\"testRead() ...\\n\");\n\t    \tpool = startDB();\n\t    \tassertNotNull(pool);\n\t        broker = pool.get(SecurityManager.SYSTEM_USER);\n\t        assertNotNull(broker);\n\t        Serializer serializer = broker.getSerializer();\n\t        serializer.reset();\n\n\t        DocumentImpl doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/new_test.xml\"), Lock.READ_LOCK);\n\t        assertNotNull(\"Document should not be null\", doc);\n\t        String data = serializer.serialize(doc);\n\t        assertNotNull(data);\n//\t        System.out.println(data);\n\t        doc.getUpdateLock().release(Lock.READ_LOCK);\n\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n\n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);\n            broker.removeCollection(transaction, root);\n\n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n\t        fail(e.getMessage());\n\t    } finally {\n\t        pool.release(broker);\n\t    }\n\t}","commit_id":"c9ad221a3a5f898d12df33a1b19166ba900d8076","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;           \n        \n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/hamlet.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/test_string.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);            \n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            doc = broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(files[files.length - 1].getName()), Lock.READ_LOCK);\n            assertNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/'\" + files[files.length - 1].getName() + \" should not exist anymore\", doc);\n            \n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//SPEECH[LINE &= 'king']\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            System.out.println(\"Found: \" + seq.getItemCount());\n            for (SequenceIterator i = seq.iterate(); i.hasNext(); ) {\n                Item next = i.nextItem();\n                System.out.println(serializer.serialize((NodeValue) next));\n            }\n            \n            BinaryDocument binDoc = (BinaryDocument) broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(TestConstants.TEST_BINARY_URI), Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            data = new String(broker.getBinaryResource(binDoc));\n            assertNotNull(data);\n            System.out.println(data);\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t        fail(e.getMessage());\n\t        e.printStackTrace();\n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","id":71195,"modified_method":"public void testRead() {\n        BrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;           \n        TransactionManager transact = null;\n        Txn transaction = null;\n        \n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            Serializer serializer = broker.getSerializer();\n            serializer.reset();\n            \n            DocumentImpl doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/hamlet.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/hamlet.xml' should not be null\", doc);\n            String data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);\n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            doc = broker.getXMLResource(XmldbURI.ROOT_COLLECTION_URI.append(\"test/test2/test_string.xml\"), Lock.READ_LOCK);\n            assertNotNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/test_string.xml' should not be null\", doc);\n            data = serializer.serialize(doc);\n            assertNotNull(data);\n            System.out.println(data);            \n            doc.getUpdateLock().release(Lock.READ_LOCK);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            doc = broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(files[files.length - 1].getName()), Lock.READ_LOCK);\n            assertNull(\"Document '\" + DBBroker.ROOT_COLLECTION + \"/test/test2/'\" + files[files.length - 1].getName() + \" should not exist anymore\", doc);\n            \n            XQuery xquery = broker.getXQueryService();\n            assertNotNull(xquery);\n            Sequence seq = xquery.execute(\"//SPEECH[LINE &= 'king']\", null, AccessContext.TEST);\n            assertNotNull(seq);\n            System.out.println(\"Found: \" + seq.getItemCount());\n            for (SequenceIterator i = seq.iterate(); i.hasNext(); ) {\n                Item next = i.nextItem();\n                System.out.println(serializer.serialize((NodeValue) next));\n            }\n            \n            BinaryDocument binDoc = (BinaryDocument) broker.getXMLResource(TestConstants.TEST_COLLECTION_URI2.append(TestConstants.TEST_BINARY_URI), Lock.READ_LOCK);\n            assertNotNull(\"Binary document is null\", binDoc);\n            data = new String(broker.getBinaryResource(binDoc));\n            assertNotNull(data);\n            System.out.println(data);\n            \n            DOMFile domDb = ((NativeBroker)broker).getDOMFile();\n            assertNotNull(domDb);\n            Writer writer = new StringWriter();\n            domDb.dump(writer);\n            System.out.println(writer.toString());\n            \n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {            \n\t    \ttransact.abort(transaction);\n\t        fail(e.getMessage());\n\t        e.printStackTrace();\n        } finally {\n        \tif (pool != null) pool.release(broker);\n        }\n    }","commit_id":"c9ad221a3a5f898d12df33a1b19166ba900d8076","url":"https://github.com/eXist-db/exist"},{"original_method":"public void testRead() {\n    \tBrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            \n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            \n            BrokerPool.FORCE_CORRUPTION = true;\n            TransactionManager transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            Txn transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);   \n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI2);\n            assertNotNull(test2);\n            broker.saveCollection(transaction, test2);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length && i < RESOURCE_COUNT; i++) {\n                f = files[i];\n                assertNotNull(f);\n                try {\n                    info = test2.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {\n            e.printStackTrace();\n\t        fail(e.getMessage());              \n        } finally {\n            if (pool != null)\n                pool.release(broker);\n        }\n    }","id":71196,"modified_method":"public void testRead() {\n    \tBrokerPool.FORCE_CORRUPTION = false;\n        BrokerPool pool = null;\n        DBBroker broker = null;\n        TransactionManager transact = null;\n        Txn transaction = null;\n        try {\n        \tSystem.out.println(\"testRead() ...\\n\");\n        \tpool = startDB();\n        \tassertNotNull(pool);\n            \n            broker = pool.get(SecurityManager.SYSTEM_USER);\n            assertNotNull(broker);\n            \n            BrokerPool.FORCE_CORRUPTION = true;\n            transact = pool.getTransactionManager();\n            assertNotNull(transact);\n            transaction = transact.beginTransaction();\n            assertNotNull(transaction);\n            System.out.println(\"Transaction started ...\");\n            \n            Collection root = broker.openCollection(TestConstants.TEST_COLLECTION_URI, Lock.WRITE_LOCK);\n            assertNotNull(root);\n            transaction.registerLock(root.getLock(), Lock.WRITE_LOCK);            \n            broker.removeCollection(transaction, root);   \n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n            \n            transaction = transact.beginTransaction();\n            System.out.println(\"Transaction started ...\");\n            \n            root = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI);\n            assertNotNull(root);\n            broker.saveCollection(transaction, root);\n            \n            Collection test2 = broker.getOrCreateCollection(transaction, TestConstants.TEST_COLLECTION_URI2);\n            assertNotNull(test2);\n            broker.saveCollection(transaction, test2);\n            \n            File files[] = dir.listFiles();\n            assertNotNull(files);\n            \n            File f;\n            IndexInfo info;\n            \n            // store some documents.\n            for (int i = 0; i < files.length && i < RESOURCE_COUNT; i++) {\n                f = files[i];\n                assertNotNull(f);\n                try {\n                    info = test2.validateXMLResource(transaction, broker, XmldbURI.create(f.getName()), new InputSource(f.toURI().toASCIIString()));\n                    assertNotNull(info);\n                    test2.store(transaction, broker, info, new InputSource(f.toURI().toASCIIString()), false);\n                } catch (SAXException e) {\n                    System.err.println(\"Error found while parsing document: \" + f.getName() + \": \" + e.getMessage());\n                }\n            }\n            \n            transact.commit(transaction);\n            System.out.println(\"Transaction commited ...\");\n\t    } catch (Exception e) {\n            transact.abort(transaction);\n            e.printStackTrace();\n\t        fail(e.getMessage());              \n        } finally {\n            if (pool != null)\n                pool.release(broker);\n        }\n    }","commit_id":"c9ad221a3a5f898d12df33a1b19166ba900d8076","url":"https://github.com/eXist-db/exist"},{"original_method":"private void completeVariable(EditorTextField editorTextField, PsiType type) {\n    Editor editor = editorTextField.getEditor();\n    String prefix = editorTextField.getText();\n    if (prefix == null) prefix = \"\";\n    Set<LookupItem> set = new LinkedHashSet<LookupItem>();\n    JavaCompletionUtil.completeVariableNameForRefactoring(myProject, set, prefix, type, VariableKind.PARAMETER);\n\n    LookupItem[] lookupItems = set.toArray(new LookupItem[set.size()]);\n    editor.getCaretModel().moveToOffset(prefix.length());\n    editor.getSelectionModel().removeSelection();\n    LookupManager.getInstance(myProject).showLookup(editor, lookupItems, prefix, null, new CharFilter() {\n      public int accept(char c, final String prefix) {\n        if (Character.isJavaIdentifierPart(c)) return ADD_TO_PREFIX;\n        return SELECT_ITEM_AND_FINISH_LOOKUP;\n      }\n    });\n  }","id":71197,"modified_method":"private void completeVariable(EditorTextField editorTextField, PsiType type) {\n    Editor editor = editorTextField.getEditor();\n    String prefix = editorTextField.getText();\n    if (prefix == null) prefix = \"\";\n    Set<LookupItem> set = new LinkedHashSet<LookupItem>();\n    JavaCompletionUtil.completeVariableNameForRefactoring(myProject, set, prefix, type, VariableKind.PARAMETER);\n\n    LookupItem[] lookupItems = set.toArray(new LookupItem[set.size()]);\n    editor.getCaretModel().moveToOffset(prefix.length());\n    editor.getSelectionModel().removeSelection();\n    LookupManager.getInstance(myProject).showLookup(editor, lookupItems, prefix, null, IdentifierCharFilter.INSTANCE);\n  }","commit_id":"6fbef35de5b25ae4325efbdaba483ca1208e2285","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(final Project project, final Editor editor, PsiFile file) {\n    if (!file.isWritable()) return;\n    EditorUtil.fillVirtualSpaceUntil(editor, editor.getCaretModel().getLogicalPosition().column, editor.getCaretModel().getLogicalPosition().line);\n\n    PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n    int offset = editor.getCaretModel().getOffset();\n    String prefix = getPrefix(editor.getDocument(), offset);\n    TemplateContextType contextType = TemplateManager.getInstance(project).getContextType(file, offset);\n\n    TemplateImpl[] templates = TemplateSettings.getInstance().getTemplates();\n    ArrayList<LookupItem> array = new ArrayList<LookupItem>();\n    for (TemplateImpl template : templates) {\n      if (template.isDeactivated() || template.isSelectionTemplate()) continue;\n      String key = template.getKey();\n      if (key.startsWith(prefix) && contextType.isEnabled(template.getTemplateContext())) {\n        LookupItem item = new LookupItem(template, key);\n        array.add(item);\n      }\n    }\n    LookupItem[] items = array.toArray(new LookupItem[array.size()]);\n\n    if (items.length == 0){\n      String text = prefix.length() == 0\n        ? CodeInsightBundle.message(\"templates.no.defined\")\n        : CodeInsightBundle.message(\"templates.no.defined.with.prefix\", prefix);\n      HintManager.getInstance().showErrorHint(editor, text);\n      return;\n    }\n\n    Lookup lookup = LookupManager.getInstance(project).showLookup(editor, items, prefix, null, new CharFilter() {\n      public int accept(char c, final String prefix) {\n        if (isInPrefix(c)) return CharFilter.ADD_TO_PREFIX;\n        return CharFilter.SELECT_ITEM_AND_FINISH_LOOKUP;\n      }\n    });\n    lookup.addLookupListener(\n      new LookupAdapter() {\n        public void itemSelected(LookupEvent event) {\n          TemplateManager.getInstance(project).startTemplate(editor, '\\0');\n        }\n      }\n    );\n  }","id":71198,"modified_method":"public void invoke(final Project project, final Editor editor, PsiFile file) {\n    if (!file.isWritable()) return;\n    EditorUtil.fillVirtualSpaceUntil(editor, editor.getCaretModel().getLogicalPosition().column, editor.getCaretModel().getLogicalPosition().line);\n\n    PsiDocumentManager.getInstance(project).commitDocument(editor.getDocument());\n    int offset = editor.getCaretModel().getOffset();\n    String prefix = getPrefix(editor.getDocument(), offset);\n    TemplateContextType contextType = TemplateManager.getInstance(project).getContextType(file, offset);\n\n    TemplateImpl[] templates = TemplateSettings.getInstance().getTemplates();\n    ArrayList<LookupItem> array = new ArrayList<LookupItem>();\n    for (TemplateImpl template : templates) {\n      if (template.isDeactivated() || template.isSelectionTemplate()) continue;\n      String key = template.getKey();\n      if (key.startsWith(prefix) && contextType.isEnabled(template.getTemplateContext())) {\n        LookupItem item = new LookupItem(template, key);\n        array.add(item);\n      }\n    }\n    LookupItem[] items = array.toArray(new LookupItem[array.size()]);\n\n    if (items.length == 0){\n      String text = prefix.length() == 0\n        ? CodeInsightBundle.message(\"templates.no.defined\")\n        : CodeInsightBundle.message(\"templates.no.defined.with.prefix\", prefix);\n      HintManager.getInstance().showErrorHint(editor, text);\n      return;\n    }\n\n    Lookup lookup = LookupManager.getInstance(project).showLookup(editor, items, prefix, null, IdentifierCharFilter.INSTANCE);\n    lookup.addLookupListener(\n      new LookupAdapter() {\n        public void itemSelected(LookupEvent event) {\n          TemplateManager.getInstance(project).startTemplate(editor, '\\0');\n        }\n      }\n    );\n  }","commit_id":"6fbef35de5b25ae4325efbdaba483ca1208e2285","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void completeVariable(Editor editor) {\n    String prefix = myNameField.getEnteredName();\n    Pair<LookupItemPreferencePolicy, Set<LookupItem>> pair = myGenerator.completeVariableName(prefix, myTypeSelector.getSelectedType());\n    LookupItem[] lookupItems = pair.second.toArray(new LookupItem[pair.second.size()]);\n    editor.getCaretModel().moveToOffset(prefix.length());\n    editor.getSelectionModel().removeSelection();\n    LookupItemPreferencePolicy first = pair.first;\n    LookupManager.getInstance(myProject).showLookup(editor, lookupItems, prefix, first, new CharFilter() {\n      public int accept(char c, final String prefix) {\n        if (Character.isJavaIdentifierPart(c)) return CharFilter.ADD_TO_PREFIX;\n        return CharFilter.SELECT_ITEM_AND_FINISH_LOOKUP;\n      }\n    });\n  }","id":71199,"modified_method":"private void completeVariable(Editor editor) {\n    String prefix = myNameField.getEnteredName();\n    Pair<LookupItemPreferencePolicy, Set<LookupItem>> pair = myGenerator.completeVariableName(prefix, myTypeSelector.getSelectedType());\n    LookupItem[] lookupItems = pair.second.toArray(new LookupItem[pair.second.size()]);\n    editor.getCaretModel().moveToOffset(prefix.length());\n    editor.getSelectionModel().removeSelection();\n    LookupItemPreferencePolicy first = pair.first;\n    LookupManager.getInstance(myProject).showLookup(editor, lookupItems, prefix, first, IdentifierCharFilter.INSTANCE);\n  }","commit_id":"6fbef35de5b25ae4325efbdaba483ca1208e2285","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void completeVariable(Editor editor) {\n    String prefix = myNameSuggestionsField.getEnteredName();\n    Collection<LookupItem> items = null;\n    for(NameSuggestionProvider provider: Extensions.getExtensions(NameSuggestionProvider.EP_NAME)) {\n      items = provider.completeName(myPsiElement, myNameSuggestionContext, prefix);\n      if (items != null) break;\n    }\n\n    if (items != null) {\n      LookupItem[] lookupItems = items.toArray(new LookupItem[items.size()]);\n      editor.getCaretModel().moveToOffset(prefix.length());\n      editor.getSelectionModel().removeSelection();\n      LookupManager.getInstance(myProject).showLookup(editor, lookupItems, prefix, null, new CharFilter() {\n        public int accept(char c, final String prefix) {\n          if (Character.isJavaIdentifierPart(c)) return CharFilter.ADD_TO_PREFIX;\n          return CharFilter.SELECT_ITEM_AND_FINISH_LOOKUP;\n        }\n      });\n    }\n  }","id":71200,"modified_method":"private void completeVariable(Editor editor) {\n    String prefix = myNameSuggestionsField.getEnteredName();\n    Collection<LookupItem> items = null;\n    for(NameSuggestionProvider provider: Extensions.getExtensions(NameSuggestionProvider.EP_NAME)) {\n      items = provider.completeName(myPsiElement, myNameSuggestionContext, prefix);\n      if (items != null) break;\n    }\n\n    if (items != null) {\n      LookupItem[] lookupItems = items.toArray(new LookupItem[items.size()]);\n      editor.getCaretModel().moveToOffset(prefix.length());\n      editor.getSelectionModel().removeSelection();\n      LookupManager.getInstance(myProject).showLookup(editor, lookupItems, prefix, null, IdentifierCharFilter.INSTANCE);\n    }\n  }","commit_id":"6fbef35de5b25ae4325efbdaba483ca1208e2285","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void completeVariable(final Editor editor) {\n    String prefix = myNameSuggestionsField.getEnteredName();\n\n    Set<LookupItem> set = new LinkedHashSet<LookupItem>();\n    final PsiReference reference = myTag.getReference();\n    if (reference != null) {\n      final Object[] variants = reference.getVariants();\n      for (Object variant : variants) {\n        LookupItemUtil.addLookupItem(set, variant);\n      }\n\n      LookupItem[] lookupItems = set.toArray(new LookupItem[set.size()]);\n      editor.getCaretModel().moveToOffset(prefix.length());\n      editor.getSelectionModel().removeSelection();\n      LookupManager.getInstance(getProject()).showLookup(editor, lookupItems, prefix, null, new CharFilter() {\n        public int accept(char c, final String prefix) {\n          if (Character.isJavaIdentifierPart(c)) return CharFilter.ADD_TO_PREFIX;\n          return CharFilter.SELECT_ITEM_AND_FINISH_LOOKUP;\n        }\n      });\n    }\n  }","id":71201,"modified_method":"private void completeVariable(final Editor editor) {\n    String prefix = myNameSuggestionsField.getEnteredName();\n\n    Set<LookupItem> set = new LinkedHashSet<LookupItem>();\n    final PsiReference reference = myTag.getReference();\n    if (reference != null) {\n      final Object[] variants = reference.getVariants();\n      for (Object variant : variants) {\n        LookupItemUtil.addLookupItem(set, variant);\n      }\n\n      LookupItem[] lookupItems = set.toArray(new LookupItem[set.size()]);\n      editor.getCaretModel().moveToOffset(prefix.length());\n      editor.getSelectionModel().removeSelection();\n      LookupManager.getInstance(getProject()).showLookup(editor, lookupItems, prefix, null, IdentifierCharFilter.INSTANCE);\n    }\n  }","commit_id":"6fbef35de5b25ae4325efbdaba483ca1208e2285","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void wireBus(BeanDefinitionBuilder bean, String busId) {\n        bean.addPropertyReference(\"bus\", busId);\n    }","id":71202,"modified_method":"protected void addBusWiringAttribute(BeanDefinitionBuilder bean, BusWiringType type) {\n        LOG.fine(\"Adding \" + WIRE_BUS_ATTRIBUTE + \" attribute \" + type + \" to bean \" + bean);\n        bean.getRawBeanDefinition().setAttribute(WIRE_BUS_ATTRIBUTE, type);\n    }","commit_id":"3600012d1cdac52e56f87ccdabc5488553cad14c","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        boolean setBus = parseAttributes(element, ctx, bean);        \n        if (!setBus && ctx.getRegistry().containsBeanDefinition(\"cxf\") && hasBusProperty()) {\n            wireBus(bean, \"cxf\");\n        }\n        parseChildElements(element, ctx, bean);\n    }","id":71203,"modified_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        boolean setBus = parseAttributes(element, ctx, bean);        \n        if (!setBus && hasBusProperty()) {\n            addBusWiringAttribute(bean, BusWiringType.PROPERTY);\n        }\n        parseChildElements(element, ctx, bean);\n    }","commit_id":"3600012d1cdac52e56f87ccdabc5488553cad14c","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        BeanDefinitionBuilder factoryBean = BeanDefinitionBuilder.rootBeanDefinition(getFactoryClass());\n\n        NamedNodeMap atts = element.getAttributes();        \n        boolean createdFromAPI = false;\n        boolean setBus = false;\n        for (int i = 0; i < atts.getLength(); i++) {\n            Attr node = (Attr) atts.item(i);\n            String val = node.getValue();\n            String pre = node.getPrefix();\n            String name = node.getLocalName();\n            \n            if (\"createdFromAPI\".equals(name)) {\n                factoryBean.setAbstract(true);\n                bean.setAbstract(true);\n                createdFromAPI = true;\n            } else if (\"abstract\".equals(name)) {\n                factoryBean.setAbstract(true);\n                bean.setAbstract(true);\n            } else if (!\"id\".equals(name) && !\"name\".equals(name) && isAttribute(pre, name)) {\n                if (\"bus\".equals(name)) {\n                    setBus = true;\n                }\n                mapAttribute(factoryBean, element, name, val);\n            } \n        }\n        \n        if (!setBus && ctx.getRegistry().containsBeanDefinition(\"cxf\")) {\n            wireBus(factoryBean, \"cxf\");\n        }\n        \n        NodeList children = element.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node n = children.item(i);\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String name = n.getLocalName();\n               \n                mapElement(ctx, factoryBean, (Element) n, name);\n            }\n        }\n        \n        String id = getIdOrName(element);\n        if (createdFromAPI) {\n            id = id + getSuffix();\n        }\n        \n        String factoryId = id + getFactoryIdSuffix();\n        \n        ctx.getRegistry().registerBeanDefinition(factoryId, factoryBean.getBeanDefinition());\n        bean.getBeanDefinition().setAttribute(\"id\", id);\n        bean.setFactoryBean(factoryId, \"create\");\n    }","id":71204,"modified_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        BeanDefinitionBuilder factoryBean = BeanDefinitionBuilder.rootBeanDefinition(getFactoryClass());\n\n        NamedNodeMap atts = element.getAttributes();        \n        boolean createdFromAPI = false;\n        boolean setBus = false;\n        for (int i = 0; i < atts.getLength(); i++) {\n            Attr node = (Attr) atts.item(i);\n            String val = node.getValue();\n            String pre = node.getPrefix();\n            String name = node.getLocalName();\n            \n            if (\"createdFromAPI\".equals(name)) {\n                factoryBean.setAbstract(true);\n                bean.setAbstract(true);\n                createdFromAPI = true;\n            } else if (\"abstract\".equals(name)) {\n                factoryBean.setAbstract(true);\n                bean.setAbstract(true);\n            } else if (!\"id\".equals(name) && !\"name\".equals(name) && isAttribute(pre, name)) {\n                if (\"bus\".equals(name)) {\n                    setBus = true;\n                }\n                mapAttribute(factoryBean, element, name, val);\n            } \n        }\n        \n        if (!setBus) {\n            addBusWiringAttribute(factoryBean, BusWiringType.PROPERTY);\n        }\n        \n        NodeList children = element.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node n = children.item(i);\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String name = n.getLocalName();\n               \n                mapElement(ctx, factoryBean, (Element) n, name);\n            }\n        }\n        \n        String id = getIdOrName(element);\n        if (createdFromAPI) {\n            id = id + getSuffix();\n        }\n        \n        String factoryId = id + getFactoryIdSuffix();\n        \n        ctx.getRegistry().registerBeanDefinition(factoryId, factoryBean.getBeanDefinition());\n        bean.getBeanDefinition().setAttribute(\"id\", id);\n        bean.setFactoryBean(factoryId, \"create\");\n    }","commit_id":"3600012d1cdac52e56f87ccdabc5488553cad14c","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        boolean isAbstract = false;\n        NamedNodeMap atts = element.getAttributes();\n        String bus = element.getAttribute(\"bus\");\n        if (StringUtils.isEmpty(bus)) {\n            if (ctx.getRegistry().containsBeanDefinition(Bus.DEFAULT_BUS_ID)) {\n                bean.addConstructorArgReference(Bus.DEFAULT_BUS_ID);\n            }\n        } else {\n            if (ctx.getRegistry().containsBeanDefinition(bus)) {\n                bean.addConstructorArgReference(bus);\n            }\n        }\n        for (int i = 0; i < atts.getLength(); i++) {\n            Attr node = (Attr) atts.item(i);\n            String val = node.getValue();\n            String pre = node.getPrefix();\n            String name = node.getLocalName();\n\n            if (\"createdFromAPI\".equals(name)) {\n                bean.setAbstract(true);\n                isAbstract = true;\n            } else if (isAttribute(pre, name) && !\"publish\".equals(name) && !\"bus\".equals(name)) {\n                if (\"endpointName\".equals(name) || \"serviceName\".equals(name)) {\n                    QName q = parseQName(element, val);\n                    bean.addPropertyValue(name, q);\n                } else if (\"depends-on\".equals(name)) {\n                    bean.addDependsOn(val);\n                } else if (IMPLEMENTOR.equals(name)) {\n                    loadImplementor(bean, val);\n                } else if (!\"name\".equals(name)) {\n                    mapToProperty(bean, name, val);\n                }\n            } else if (\"abstract\".equals(name)) {\n                bean.setAbstract(true);\n                isAbstract = true;\n            }\n        }\n        \n        NodeList children = element.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node n = children.item(i);\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String name = n.getLocalName();\n                if (\"properties\".equals(name)) {\n                    Map map = ctx.getDelegate().parseMapElement((Element) n, bean.getBeanDefinition());\n                    bean.addPropertyValue(\"properties\", map);\n                } else if (\"binding\".equals(name)) {\n                    setFirstChildAsProperty((Element) n, ctx, bean, \"bindingConfig\");\n                } else if (\"inInterceptors\".equals(name) || \"inFaultInterceptors\".equals(name)\n                    || \"outInterceptors\".equals(name) || \"outFaultInterceptors\".equals(name)\n                    || \"features\".equals(name) || \"schemaLocations\".equals(name)\n                    || \"handlers\".equals(name)) {\n                    List list = ctx.getDelegate().parseListElement((Element) n, bean.getBeanDefinition());\n                    bean.addPropertyValue(name, list);\n                } else if (IMPLEMENTOR.equals(name)) {\n                    ctx.getDelegate()\n                        .parseConstructorArgElement((Element)n, bean.getBeanDefinition());\n                } else {\n                    setFirstChildAsProperty((Element) n, ctx, bean, name);\n                }\n            }\n        }\n        if (!isAbstract) {\n            bean.setInitMethodName(\"publish\");\n            bean.setDestroyMethodName(\"stop\");\n        }\n        // We don't want to delay the registration of our Server\n        bean.setLazyInit(false);\n    }","id":71205,"modified_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        boolean isAbstract = false;\n        NamedNodeMap atts = element.getAttributes();\n        String bus = element.getAttribute(\"bus\");\n        if (StringUtils.isEmpty(bus)) {\n            addBusWiringAttribute(bean, BusWiringType.CONSTRUCTOR);\n        } else {\n            bean.addConstructorArgReference(bus);\n        }\n        for (int i = 0; i < atts.getLength(); i++) {\n            Attr node = (Attr) atts.item(i);\n            String val = node.getValue();\n            String pre = node.getPrefix();\n            String name = node.getLocalName();\n\n            if (\"createdFromAPI\".equals(name)) {\n                bean.setAbstract(true);\n                isAbstract = true;\n            } else if (isAttribute(pre, name) && !\"publish\".equals(name) && !\"bus\".equals(name)) {\n                if (\"endpointName\".equals(name) || \"serviceName\".equals(name)) {\n                    QName q = parseQName(element, val);\n                    bean.addPropertyValue(name, q);\n                } else if (\"depends-on\".equals(name)) {\n                    bean.addDependsOn(val);\n                } else if (IMPLEMENTOR.equals(name)) {\n                    loadImplementor(bean, val);\n                } else if (!\"name\".equals(name)) {\n                    mapToProperty(bean, name, val);\n                }\n            } else if (\"abstract\".equals(name)) {\n                bean.setAbstract(true);\n                isAbstract = true;\n            }\n        }\n        \n        NodeList children = element.getChildNodes();\n        for (int i = 0; i < children.getLength(); i++) {\n            Node n = children.item(i);\n            if (n.getNodeType() == Node.ELEMENT_NODE) {\n                String name = n.getLocalName();\n                if (\"properties\".equals(name)) {\n                    Map map = ctx.getDelegate().parseMapElement((Element) n, bean.getBeanDefinition());\n                    bean.addPropertyValue(\"properties\", map);\n                } else if (\"binding\".equals(name)) {\n                    setFirstChildAsProperty((Element) n, ctx, bean, \"bindingConfig\");\n                } else if (\"inInterceptors\".equals(name) || \"inFaultInterceptors\".equals(name)\n                    || \"outInterceptors\".equals(name) || \"outFaultInterceptors\".equals(name)\n                    || \"features\".equals(name) || \"schemaLocations\".equals(name)\n                    || \"handlers\".equals(name)) {\n                    List list = ctx.getDelegate().parseListElement((Element) n, bean.getBeanDefinition());\n                    bean.addPropertyValue(name, list);\n                } else if (IMPLEMENTOR.equals(name)) {\n                    ctx.getDelegate()\n                        .parseConstructorArgElement((Element)n, bean.getBeanDefinition());\n                } else {\n                    setFirstChildAsProperty((Element) n, ctx, bean, name);\n                }\n            }\n        }\n        if (!isAbstract) {\n            bean.setInitMethodName(\"publish\");\n            bean.setDestroyMethodName(\"stop\");\n        }\n        // We don't want to delay the registration of our Server\n        bean.setLazyInit(false);\n    }","commit_id":"3600012d1cdac52e56f87ccdabc5488553cad14c","url":"https://github.com/apache/cxf"},{"original_method":"public void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        \n        String portStr = element.getAttribute(\"port\");\n        int port = Integer.valueOf(portStr);\n        bean.addPropertyValue(\"port\", port);\n               \n        MutablePropertyValues engineFactoryProperties = ctx.getContainingBeanDefinition().getPropertyValues();\n        PropertyValue busValue = engineFactoryProperties.getPropertyValue(\"bus\");\n              \n        // get the property value from paranets\n        try {\n            \n            NodeList children = element.getChildNodes();\n            for (int i = 0; i < children.getLength(); i++) {\n                Node n = children.item(i);\n                if (n.getNodeType() == Node.ELEMENT_NODE) {\n                    String name = n.getLocalName();\n                    if (\"tlsServerParameters\".equals(name)) {\n                        \n                        TLSServerParametersType parametersType = \n                            JAXBHelper.parseElement((Element)n, bean, TLSServerParametersType.class);\n                        \n                        TLSServerParametersConfig param = \n                            new TLSServerParametersConfig(parametersType);\n                        \n                        bean.addPropertyValue(\"tlsServerParameters\", param);\n                        \n                    } else if (\"tlsServerParametersRef\".equals(name)) {\n                        \n                        TLSServerParametersIdentifiedType parameterTypeRef = \n                            JAXBHelper.parseElement((Element)n, bean, \n                                                    TLSServerParametersIdentifiedType.class);\n                        \n                        TLSServerParameters param = \n                            getTlsServerParameters(engineFactoryProperties, parameterTypeRef.getId()); \n                        bean.addPropertyValue(\"tlsServerParameters\", param);\n                        \n                    } else if (\"threadingParameters\".equals(name)) {\n                        ThreadingParametersType parametersType = \n                            JAXBHelper.parseElement((Element)n, bean, ThreadingParametersType.class);\n                        \n                        ThreadingParameters param = toThreadingParameters(parametersType);\n                        bean.addPropertyValue(\"threadingParameters\", param);  \n                        \n                    } else if (\"threadingParametersRef\".equals(name)) {\n                        ThreadingParametersIdentifiedType parametersTypeRef =\n                            JAXBHelper.parseElement((Element)n, bean, \n                                                    ThreadingParametersIdentifiedType.class);\n                        ThreadingParameters param = \n                            getThreadingParameters(engineFactoryProperties, parametersTypeRef.getId());\n                        bean.addPropertyValue(\"threadingParameters\", param);\n                        \n                    } else if (\"connector\".equals(name)) { \n                        // only deal with the one connector here\n                        List list = \n                            ctx.getDelegate().parseListElement((Element) n, bean.getBeanDefinition());\n                        bean.addPropertyValue(\"connector\", list.get(0));\n                    } else if (\"handlers\".equals(name)) {\n                        List handlers = \n                            ctx.getDelegate().parseListElement((Element) n, bean.getBeanDefinition());\n                        bean.addPropertyValue(\"handlers\", handlers);\n                    } else if (\"sessionSupport\".equals(name) || \"reuseAddress\".equals(name)) {\n                        String text = n.getTextContent();                        \n                        bean.addPropertyValue(name, Boolean.valueOf(text));\n                    }                         \n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not process configuration.\", e);\n        }\n        \n        bean.addPropertyValue(\"bus\", busValue.getValue());        \n        \n        bean.setLazyInit(false);\n        \n    }","id":71206,"modified_method":"public void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        \n        String portStr = element.getAttribute(\"port\");\n        int port = Integer.valueOf(portStr);\n        bean.addPropertyValue(\"port\", port);\n               \n        MutablePropertyValues engineFactoryProperties = ctx.getContainingBeanDefinition().getPropertyValues();\n        PropertyValue busValue = engineFactoryProperties.getPropertyValue(\"bus\");\n              \n        // get the property value from paranets\n        try {\n            \n            NodeList children = element.getChildNodes();\n            for (int i = 0; i < children.getLength(); i++) {\n                Node n = children.item(i);\n                if (n.getNodeType() == Node.ELEMENT_NODE) {\n                    String name = n.getLocalName();\n                    if (\"tlsServerParameters\".equals(name)) {\n                        \n                        TLSServerParametersType parametersType = \n                            JAXBHelper.parseElement((Element)n, bean, TLSServerParametersType.class);\n                        \n                        TLSServerParametersConfig param = \n                            new TLSServerParametersConfig(parametersType);\n                        \n                        bean.addPropertyValue(\"tlsServerParameters\", param);\n                        \n                    } else if (\"tlsServerParametersRef\".equals(name)) {\n                        \n                        TLSServerParametersIdentifiedType parameterTypeRef = \n                            JAXBHelper.parseElement((Element)n, bean, \n                                                    TLSServerParametersIdentifiedType.class);\n                        \n                        TLSServerParameters param = \n                            getTlsServerParameters(engineFactoryProperties, parameterTypeRef.getId()); \n                        bean.addPropertyValue(\"tlsServerParameters\", param);\n                        \n                    } else if (\"threadingParameters\".equals(name)) {\n                        ThreadingParametersType parametersType = \n                            JAXBHelper.parseElement((Element)n, bean, ThreadingParametersType.class);\n                        \n                        ThreadingParameters param = toThreadingParameters(parametersType);\n                        bean.addPropertyValue(\"threadingParameters\", param);  \n                        \n                    } else if (\"threadingParametersRef\".equals(name)) {\n                        ThreadingParametersIdentifiedType parametersTypeRef =\n                            JAXBHelper.parseElement((Element)n, bean, \n                                                    ThreadingParametersIdentifiedType.class);\n                        ThreadingParameters param = \n                            getThreadingParameters(engineFactoryProperties, parametersTypeRef.getId());\n                        bean.addPropertyValue(\"threadingParameters\", param);\n                        \n                    } else if (\"connector\".equals(name)) { \n                        // only deal with the one connector here\n                        List list = \n                            ctx.getDelegate().parseListElement((Element) n, bean.getBeanDefinition());\n                        bean.addPropertyValue(\"connector\", list.get(0));\n                    } else if (\"handlers\".equals(name)) {\n                        List handlers = \n                            ctx.getDelegate().parseListElement((Element) n, bean.getBeanDefinition());\n                        bean.addPropertyValue(\"handlers\", handlers);\n                    } else if (\"sessionSupport\".equals(name) || \"reuseAddress\".equals(name)) {\n                        String text = n.getTextContent();                        \n                        bean.addPropertyValue(name, Boolean.valueOf(text));\n                    }                         \n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not process configuration.\", e);\n        }\n        \n        // if the containing bean is having the bus wired up by the post processor then we should too\n        if (ctx.getContainingBeanDefinition().getAttribute(WIRE_BUS_ATTRIBUTE) == BusWiringType.PROPERTY) {\n            addBusWiringAttribute(bean, BusWiringType.PROPERTY);\n        } else {\n            bean.addPropertyValue(\"bus\", busValue.getValue());\n        }\n        \n        bean.setLazyInit(false);\n        \n    }","commit_id":"3600012d1cdac52e56f87ccdabc5488553cad14c","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    public void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        //bean.setAbstract(true);        \n        String bus = element.getAttribute(\"bus\");\n         \n        try {\n            List <ThreadingParametersIdentifiedType> threadingParametersIdentifiedTypes = \n                JAXBHelper.parseListElement(element, bean, \n                                            new QName(HTTP_JETTY_NS, \"identifiedThreadingParameters\"), \n                                            ThreadingParametersIdentifiedType.class);\n            Map<String, ThreadingParameters> threadingParametersMap =\n                toThreadingParameters(threadingParametersIdentifiedTypes);\n            List <TLSServerParametersIdentifiedType> tlsServerParameters =\n                JAXBHelper.parseListElement(element, bean, \n                                            new QName(HTTP_JETTY_NS, \"identifiedTLSServerParameters\"),\n                                            TLSServerParametersIdentifiedType.class);\n            Map<String, TLSServerParameters> tlsServerParametersMap =\n                toTLSServerParamenters(tlsServerParameters);\n                                    \n            bean.addPropertyValue(\"threadingParametersMap\", threadingParametersMap);\n            bean.addPropertyValue(\"tlsServerParametersMap\", tlsServerParametersMap);\n            \n            \n            if (StringUtils.isEmpty(bus)) {\n                if (ctx.getRegistry().containsBeanDefinition(\"cxf\")) {\n                    bean.addPropertyReference(\"bus\", \"cxf\");\n                }\n            } else {\n                bean.addPropertyReference(\"bus\", bus);\n            }\n            \n            // parser the engine list\n            List list = \n                getRequiredElementsList(element, ctx, new QName(HTTP_JETTY_NS, \"engine\"), bean);\n            if (list.size() > 0) {\n                bean.addPropertyValue(\"enginesList\", list);\n            }\n            \n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not process configuration.\", e);\n        }\n    }","id":71207,"modified_method":"@Override\n    public void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        //bean.setAbstract(true);        \n        String bus = element.getAttribute(\"bus\");\n         \n        try {\n            List <ThreadingParametersIdentifiedType> threadingParametersIdentifiedTypes = \n                JAXBHelper.parseListElement(element, bean, \n                                            new QName(HTTP_JETTY_NS, \"identifiedThreadingParameters\"), \n                                            ThreadingParametersIdentifiedType.class);\n            Map<String, ThreadingParameters> threadingParametersMap =\n                toThreadingParameters(threadingParametersIdentifiedTypes);\n            List <TLSServerParametersIdentifiedType> tlsServerParameters =\n                JAXBHelper.parseListElement(element, bean, \n                                            new QName(HTTP_JETTY_NS, \"identifiedTLSServerParameters\"),\n                                            TLSServerParametersIdentifiedType.class);\n            Map<String, TLSServerParameters> tlsServerParametersMap =\n                toTLSServerParamenters(tlsServerParameters);\n                                    \n            bean.addPropertyValue(\"threadingParametersMap\", threadingParametersMap);\n            bean.addPropertyValue(\"tlsServerParametersMap\", tlsServerParametersMap);\n            \n            \n            if (StringUtils.isEmpty(bus)) {\n                addBusWiringAttribute(bean, BusWiringType.PROPERTY);\n            } else {\n                bean.addPropertyReference(\"bus\", bus);\n            }\n            \n            // parser the engine list\n            List list = \n                getRequiredElementsList(element, ctx, new QName(HTTP_JETTY_NS, \"engine\"), bean);\n            if (list.size() > 0) {\n                bean.addPropertyValue(\"enginesList\", list);\n            }\n            \n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not process configuration.\", e);\n        }\n    }","commit_id":"3600012d1cdac52e56f87ccdabc5488553cad14c","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        mapElementToJaxbProperty(element, bean, \n                new QName(RM_NS, \"deliveryAssurance\"), \"deliveryAssurance\");\n        mapElementToJaxbProperty(element, bean, \n                new QName(RM_NS, \"sourcePolicy\"), \"sourcePolicy\");\n        mapElementToJaxbProperty(element, bean, \n                new QName(RM_NS, \"destinationPolicy\"), \"destinationPolicy\");\n        mapElementToJaxbProperty(element, bean, \n                new QName(\"http://schemas.xmlsoap.org/ws/2005/02/rm/policy\", \"RMAssertion\"), \n                \"RMAssertion\",\n                RMAssertion.class);\n        \n        ctx.getDelegate().parsePropertyElements(element, bean.getBeanDefinition());\n        \n        String bus = element.getAttribute(\"bus\");\n        if (bus == null || \"\".equals(bus) && ctx.getRegistry().containsBeanDefinition(\"cxf\")) {\n            bean.addPropertyReference(\"bus\", \"cxf\");\n        } else {\n            bean.addPropertyReference(\"bus\", bus);\n        }\n        \n        super.parseChildElements(element, ctx, bean);\n    }","id":71208,"modified_method":"@Override\n    protected void doParse(Element element, ParserContext ctx, BeanDefinitionBuilder bean) {\n        mapElementToJaxbProperty(element, bean, \n                new QName(RM_NS, \"deliveryAssurance\"), \"deliveryAssurance\");\n        mapElementToJaxbProperty(element, bean, \n                new QName(RM_NS, \"sourcePolicy\"), \"sourcePolicy\");\n        mapElementToJaxbProperty(element, bean, \n                new QName(RM_NS, \"destinationPolicy\"), \"destinationPolicy\");\n        mapElementToJaxbProperty(element, bean, \n                new QName(\"http://schemas.xmlsoap.org/ws/2005/02/rm/policy\", \"RMAssertion\"), \n                \"RMAssertion\",\n                RMAssertion.class);\n        \n        ctx.getDelegate().parsePropertyElements(element, bean.getBeanDefinition());\n        \n        String bus = element.getAttribute(\"bus\");\n        if (bus == null || \"\".equals(bus)) {\n            addBusWiringAttribute(bean, BusWiringType.PROPERTY);\n        } else {\n            bean.addPropertyReference(\"bus\", bus);\n        }\n        \n        super.parseChildElements(element, ctx, bean);\n    }","commit_id":"3600012d1cdac52e56f87ccdabc5488553cad14c","url":"https://github.com/apache/cxf"},{"original_method":"protected String generateChildBeanName(Element e)\n    {\n        String parentId = ((Element) e.getParentNode()).getAttribute(\"id\");\n        //String parentBean = e.getLocalName() + \":\" + ((Element) e.getParentNode()).getAttribute(\"id\");\n        String id = e.getAttribute(\"id\");\n        if (StringUtils.isBlank(id))\n        {\n            id = e.getLocalName();\n            return \".\" + parentId + \":\" + id;\n        }\n        else\n        {\n            return id;\n        }\n\n    }","id":71209,"modified_method":"protected String generateChildBeanName(Element e)\n    {\n        String parentId = ((Element) e.getParentNode()).getAttribute(\"id\");\n        //String parentBean = e.getLocalName() + \":\" + ((Element) e.getParentNode()).getAttribute(\"id\");\n        String id = e.getAttribute(\"id\");\n        if (StringUtils.isBlank(id))\n        {\n            String idref = e.getAttribute(\"idref\");\n            if(StringUtils.isBlank(idref))\n            {\n                id = e.getLocalName();\n            }\n            else\n            {\n                id = \"ref:\" + idref;\n            }\n\n            if(!parentId.startsWith(\".\"))\n            {\n                parentId = \".\" + parentId;\n            }\n            return parentId + \":\" + id;\n        }\n        else\n        {\n            return id;\n        }\n\n    }","commit_id":"6fbdc68594ce2443a5788333de2455385343cc71","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void postProcess(BeanDefinitionBuilder builder, Element element)\n    {\n        String parentBean = ((Element) element.getParentNode()).getAttribute(ATTRIBUTE_ID);\n        if (StringUtils.isBlank(parentBean))\n        {\n            logger.info(\"Bean: \" + element.getNodeName() + \" has no parent\");\n            return;\n        }\n\n        String name = generateChildBeanName(element);\n        element.setAttribute(ATTRIBUTE_ID, name);\n        BeanDefinition parent = registry.getBeanDefinition(parentBean);\n\n        String propertyName = getPropertyName(element);\n\n        PropertyValue pv;\n        pv = parent.getPropertyValues().getPropertyValue(propertyName);\n//        if (pv == null)\n//        {\n//            pv = parent.getPropertyValues().getPropertyValue(propertyName += \"s\");\n//        }\n        //If the property has already been registered under the same name, we assume we're dealing with a list property\n        if (pv == null && isCollection(element))\n        {\n//            if (!(pv.getValue() instanceof List))\n//            {\n                //Object o = pv.getValue();\n                ManagedList l = new ManagedList();\n               // l.add(o);\n                //parent.getPropertyValues().removePropertyValue(propertyName);\n                pv = new PropertyValue(propertyName + \"s\", l);\n                parent.getPropertyValues().addPropertyValue(pv);\n          //  }\n            ((List) pv.getValue()).add(builder.getBeanDefinition());\n        }\n        else\n        {\n            pv = new PropertyValue(propertyName, builder.getBeanDefinition());\n        }\n        parent.getPropertyValues().addPropertyValue(pv);\n    }","id":71210,"modified_method":"protected void postProcess(BeanDefinitionBuilder builder, Element element)\n    {\n        String parentBean = ((Element) element.getParentNode()).getAttribute(ATTRIBUTE_ID);\n        if (StringUtils.isBlank(parentBean))\n        {\n            logger.info(\"Bean: \" + element.getNodeName() + \" has no parent\");\n            return;\n        }\n\n        String name = generateChildBeanName(element);\n        element.setAttribute(ATTRIBUTE_ID, name);\n        BeanDefinition parent = registry.getBeanDefinition(parentBean);\n\n        String propertyName = getPropertyName(element);\n\n        PropertyValue pv;\n        pv = parent.getPropertyValues().getPropertyValue(propertyName);\n\n        if (isMap(element))\n        {\n            if(pv==null)\n            {\n                 ManagedMap m = new ManagedMap();\n                pv = new PropertyValue(propertyName, m);\n                parent.getPropertyValues().addPropertyValue(pv);\n            }\n            MapEntryDefinitionParser.KeyValuePair pair = (MapEntryDefinitionParser.KeyValuePair)\n                    builder.getBeanDefinition().getSource();\n            ((Map) pv.getValue()).put(pair.getKey(), pair.getValue());\n\n        }\n        else if (isCollection(element))\n        {\n            if(pv==null)\n            {\n                pv = parent.getPropertyValues().getPropertyValue(propertyName + \"s\");\n            }\n            if(pv==null)\n            {\n                ManagedList l = new ManagedList();\n                pv = new PropertyValue(propertyName + \"s\", l);\n                parent.getPropertyValues().addPropertyValue(pv);\n            }\n            ((List) pv.getValue()).add(builder.getBeanDefinition());\n        }\n        else\n        {\n            pv = new PropertyValue(propertyName, builder.getBeanDefinition());\n        }\n        parent.getPropertyValues().addPropertyValue(pv);\n    }","commit_id":"6fbdc68594ce2443a5788333de2455385343cc71","url":"https://github.com/mulesoft/mule"},{"original_method":"protected final void doParse(Element element, BeanDefinitionBuilder builder)\n    {\n        NamedNodeMap attributes = element.getAttributes();\n        for (int x = 0; x < attributes.getLength(); x++)\n        {\n            Attr attribute = (Attr) attributes.item(x);\n            String name = attribute.getLocalName();\n            //If we set an attribute manually, we pick up the name using getName()\n            if (name == null)\n            {\n                name = attribute.getNodeName();\n            }\n\n            if (AbstractBeanDefinitionParser.ID_ATTRIBUTE.equals(name))\n            {\n                continue;\n            }\n            String propertyName = extractPropertyName(name);\n            String propertyValue = extractPropertyValue(name, attribute.getValue());\n            Assert.state(StringUtils.hasText(propertyName),\n                    \"Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty.\");\n            builder.addPropertyValue(propertyName, propertyValue);\n        }\n        postProcess(builder, element);\n    }","id":71211,"modified_method":"protected final void doParse(Element element, BeanDefinitionBuilder builder)\n    {\n        NamedNodeMap attributes = element.getAttributes();\n        for (int x = 0; x < attributes.getLength(); x++)\n        {\n            Attr attribute = (Attr) attributes.item(x);\n            String name = attribute.getLocalName();\n            //If we set an attribute manually, we pick up the name using getName()\n            if (name == null)\n            {\n                name = attribute.getNodeName();\n            }\n\n            if (ATTRIBUTE_ID.equals(name) || ATTRIBUTE_IDREF.equals(name))\n            {\n                continue;\n            }\n            String propertyName = extractPropertyName(name);\n            String propertyValue = extractPropertyValue(name, attribute.getValue());\n            Assert.state(StringUtils.hasText(propertyName),\n                    \"Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty.\");\n            builder.addPropertyValue(propertyName, propertyValue);\n        }\n        postProcess(builder, element);\n    }","commit_id":"6fbdc68594ce2443a5788333de2455385343cc71","url":"https://github.com/mulesoft/mule"},{"original_method":"protected AbstractMuleSingleBeanDefinitionParser()\n    {\n        attributeMappings = new Properties();\n        valueMappings = new HashMap();\n    }","id":71212,"modified_method":"protected AbstractMuleSingleBeanDefinitionParser()\n    {\n        attributeMappings = new Properties();\n        valueMappings = new HashMap();\n        registerAttributeMapping(ATTRIBUTE_ID, \"name\");\n    }","commit_id":"6fbdc68594ce2443a5788333de2455385343cc71","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void parseChild(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)\n    {\n        registry = parserContext.getRegistry();\n        NamedNodeMap attributes = element.getAttributes();\n        for (int x = 0; x < attributes.getLength(); x++)\n        {\n            Attr attribute = (Attr) attributes.item(x);\n            String name = attribute.getName();\n            if (ID_ATTRIBUTE.equals(name))\n            {\n                continue;\n            }\n            else if (ADDRESS_ATTRIBUTE.equals(name))\n            {\n                String address = element.getAttribute(\"address\");\n                try\n                {\n                    builder.addPropertyValue(\"endpointURI\", new MuleEndpointURI(address));\n                }\n                catch (MalformedEndpointException e)\n                {\n                    throw new BeanCreationException(new Message(Messages.ENPOINT_X_IS_MALFORMED, address).getMessage(), e);\n                }\n                continue;\n            }\n\n            String propertyName = extractPropertyName(name);\n            Assert.state(org.springframework.util.StringUtils.hasText(propertyName),\n                    \"Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty.\");\n            builder.addPropertyValue(propertyName, attribute.getValue());\n        }\n        postProcess(builder, element);\n    }","id":71213,"modified_method":"protected void parseChild(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)\n    {\n        registry = parserContext.getRegistry();\n        NamedNodeMap attributes = element.getAttributes();\n        for (int x = 0; x < attributes.getLength(); x++)\n        {\n            Attr attribute = (Attr) attributes.item(x);\n            String name = attribute.getName();\n            if (ATTRIBUTE_IDREF.equals(name))\n            {\n                continue;\n            }\n            else if (ADDRESS_ATTRIBUTE.equals(name))\n            {\n                String address = element.getAttribute(\"address\");\n                try\n                {\n                    builder.addPropertyValue(\"endpointURI\", new MuleEndpointURI(address));\n                }\n                catch (MalformedEndpointException e)\n                {\n                    throw new BeanCreationException(new Message(Messages.ENPOINT_X_IS_MALFORMED, address).getMessage(), e);\n                }\n                continue;\n            }\n\n            String propertyName = extractPropertyName(name);\n            Assert.state(org.springframework.util.StringUtils.hasText(propertyName),\n                    \"Illegal property name returned from 'extractPropertyName(String)': cannot be null or empty.\");\n            builder.addPropertyValue(propertyName, attribute.getValue());\n        }\n        postProcess(builder, element);\n    }","commit_id":"6fbdc68594ce2443a5788333de2455385343cc71","url":"https://github.com/mulesoft/mule"},{"original_method":"protected BeanDefinitionBuilder createBeanDefinitionBuilder(Element element, Class beanClass)\n    {\n        String parent = element.getAttribute(ATTRIBUTE_ENDPOINT_REF);\n        element.removeAttribute(ATTRIBUTE_ENDPOINT_REF);\n        if(parent==null)\n        {\n            throw new IllegalArgumentException(\"Atribute: \" + ATTRIBUTE_ENDPOINT_REF + \" must be specified for element: \" + element.getNodeName());\n        }\n        BeanDefinitionBuilder bdb = BeanDefinitionBuilder.childBeanDefinition(parent);\n        bdb.getBeanDefinition().setBeanClassName(beanClass.getName());\n        return bdb;\n    }","id":71214,"modified_method":"protected BeanDefinitionBuilder createBeanDefinitionBuilder(Element element, Class beanClass)\n    {\n        String parent = element.getAttribute(ATTRIBUTE_ENDPOINT_REF);\n        if(StringUtils.isEmpty(parent))\n        {\n            throw new IllegalArgumentException(\"Atribute: \" + ATTRIBUTE_ENDPOINT_REF + \" must be specified for element: \" + element.getNodeName());\n        }\n        BeanDefinitionBuilder bdb = BeanDefinitionBuilder.childBeanDefinition(parent);\n        bdb.getBeanDefinition().setBeanClassName(beanClass.getName());\n        return bdb;\n    }","commit_id":"6fbdc68594ce2443a5788333de2455385343cc71","url":"https://github.com/mulesoft/mule"},{"original_method":"private void handleSerializers(final Node node, final BeanDefinitionBuilder serializationConfigBuilder) {\n            BeanDefinitionBuilder globalSerializerConfigBuilder = null;\n            String implementation = \"implementation\";\n            String className = \"class-name\";\n            ManagedList typeSerializers = new ManagedList();\n            for (org.w3c.dom.Node child : new IterableNodeList(node, Node.ELEMENT_NODE)) {\n                final String name = cleanNodeName(child);\n                if (\"global-serializer\".equals(name)) {\n                    globalSerializerConfigBuilder = createBeanBuilder(GlobalSerializerConfig.class);\n                    final NamedNodeMap attrs = child.getAttributes();\n                    final Node implRef = attrs.getNamedItem(implementation);\n                    final Node classNode = attrs.getNamedItem(className);\n                    if(implRef != null) {\n                        globalSerializerConfigBuilder.addPropertyReference(xmlToJavaName(implementation), getTextContent(implRef));\n                    }\n                    if(classNode != null) {\n                        globalSerializerConfigBuilder.addPropertyValue(xmlToJavaName(className), getTextContent(classNode));\n                    }\n                }\n                if (\"serializer\".equals(name)) {\n                    BeanDefinitionBuilder serializerConfigBuilder = createBeanBuilder(SerializerConfig.class);\n                    fillAttributeValues(child, serializerConfigBuilder);\n                    final NamedNodeMap attrs = child.getAttributes();\n                    final Node implRef = attrs.getNamedItem(implementation);\n                    final Node classNode = attrs.getNamedItem(className);\n                    if(implRef != null) {\n                        serializerConfigBuilder.addPropertyReference(xmlToJavaName(implementation), getTextContent(implRef));\n                    }\n                    if(classNode != null) {\n                        serializerConfigBuilder.addPropertyValue(xmlToJavaName(className), getTextContent(classNode));\n                    }\n                    typeSerializers.add(serializerConfigBuilder.getBeanDefinition());\n                }\n            }\n            serializationConfigBuilder.addPropertyValue(\"globalSerializerConfig\", globalSerializerConfigBuilder.getBeanDefinition());\n            serializationConfigBuilder.addPropertyValue(\"serializerConfigs\", typeSerializers);\n        }","id":71215,"modified_method":"private void handleSerializers(final Node node, final BeanDefinitionBuilder serializationConfigBuilder) {\n            BeanDefinitionBuilder globalSerializerConfigBuilder = null;\n            String implementation = \"implementation\";\n            String className = \"class-name\";\n            ManagedList serializers = new ManagedList();\n            for (org.w3c.dom.Node child : new IterableNodeList(node, Node.ELEMENT_NODE)) {\n                final String name = cleanNodeName(child);\n                if (\"global-serializer\".equals(name)) {\n                    globalSerializerConfigBuilder = createBeanBuilder(GlobalSerializerConfig.class);\n                    final NamedNodeMap attrs = child.getAttributes();\n                    final Node implRef = attrs.getNamedItem(implementation);\n                    final Node classNode = attrs.getNamedItem(className);\n                    if(implRef != null) {\n                        globalSerializerConfigBuilder.addPropertyReference(xmlToJavaName(implementation), getTextContent(implRef));\n                    }\n                    if(classNode != null) {\n                        globalSerializerConfigBuilder.addPropertyValue(xmlToJavaName(className), getTextContent(classNode));\n                    }\n                }\n                if (\"serializer\".equals(name)) {\n                    BeanDefinitionBuilder serializerConfigBuilder = createBeanBuilder(SerializerConfig.class);\n                    fillAttributeValues(child, serializerConfigBuilder);\n                    final NamedNodeMap attrs = child.getAttributes();\n                    final Node implRef = attrs.getNamedItem(implementation);\n                    final Node classNode = attrs.getNamedItem(className);\n                    if(implRef != null) {\n                        serializerConfigBuilder.addPropertyReference(xmlToJavaName(implementation), getTextContent(implRef));\n                    }\n                    if(classNode != null) {\n                        serializerConfigBuilder.addPropertyValue(xmlToJavaName(className), getTextContent(classNode));\n                    }\n                    serializers.add(serializerConfigBuilder.getBeanDefinition());\n                }\n            }\n            if(globalSerializerConfigBuilder != null) {\n                serializationConfigBuilder.addPropertyValue(\"globalSerializerConfig\", globalSerializerConfigBuilder.getBeanDefinition());\n            }\n            serializationConfigBuilder.addPropertyValue(\"serializerConfigs\", serializers);\n        }","commit_id":"b136c9b98dd15d76984546d9a064104b1875694d","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n  public Element getState() {\n    Element state = new Element(\"state\");\n    for (ConfigurableWebBrowser browser : browsers) {\n      Element entry = new Element(\"browser\");\n      entry.setAttribute(\"id\", browser.getId().toString());\n      entry.setAttribute(\"name\", browser.getName());\n      entry.setAttribute(\"family\", browser.getFamily().name());\n      if (!StringUtil.isEmpty(browser.getPath())) {\n        entry.setAttribute(\"path\", browser.getPath());\n      }\n      if (!browser.isActive()) {\n        entry.setAttribute(\"active\", \"false\");\n      }\n\n      BrowserSpecificSettings specificSettings = browser.getSpecificSettings();\n      if (specificSettings != null) {\n        Element settingsElement = new Element(\"settings\");\n        XmlSerializer.serializeInto(specificSettings, settingsElement, new SkipDefaultValuesSerializationFilters());\n        if (!JDOMUtil.isEmpty(settingsElement)) {\n          entry.addContent(settingsElement);\n        }\n      }\n      state.addContent(entry);\n    }\n    return state;\n  }","id":71216,"modified_method":"@Override\n  public Element getState() {\n    Element state = new Element(\"state\");\n    for (ConfigurableWebBrowser browser : browsers) {\n      Element entry = new Element(\"browser\");\n      entry.setAttribute(\"id\", browser.getId().toString());\n      entry.setAttribute(\"name\", browser.getName());\n      entry.setAttribute(\"family\", browser.getFamily().name());\n\n      String path = browser.getPath();\n      if (path != null && !path.equals(browser.getFamily().getExecutionPath())) {\n        entry.setAttribute(\"path\", path);\n      }\n\n      if (!browser.isActive()) {\n        entry.setAttribute(\"active\", \"false\");\n      }\n\n      BrowserSpecificSettings specificSettings = browser.getSpecificSettings();\n      if (specificSettings != null) {\n        Element settingsElement = new Element(\"settings\");\n        XmlSerializer.serializeInto(specificSettings, settingsElement, new SkipDefaultValuesSerializationFilters());\n        if (!JDOMUtil.isEmpty(settingsElement)) {\n          entry.addContent(settingsElement);\n        }\n      }\n      state.addContent(entry);\n    }\n    return state;\n  }","commit_id":"c80c25da85a1c8e7e45012dfdb1ae13ba58a3235","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void loadState(Element element) {\n    List<ConfigurableWebBrowser> list = new ArrayList<ConfigurableWebBrowser>();\n    for (Element child : element.getChildren(\"browser\")) {\n      BrowserFamily family = readFamily(child.getAttributeValue(\"family\"));\n      if (family == null) {\n        continue;\n      }\n\n      UUID id = readId(child.getAttributeValue(\"id\"), family, list);\n      if (id == null) {\n        continue;\n      }\n\n      Element settingsElement = child.getChild(\"settings\");\n      BrowserSpecificSettings specificSettings = family.createBrowserSpecificSettings();\n      if (specificSettings != null && settingsElement != null) {\n        try {\n          XmlSerializer.deserializeInto(specificSettings, settingsElement);\n        }\n        catch (Exception e) {\n          LOG.warn(e);\n        }\n      }\n\n      String activeValue = child.getAttributeValue(\"active\");\n      list.add(new ConfigurableWebBrowser(id,\n                                          family,\n                                          StringUtil.notNullize(child.getAttributeValue(\"name\"), family.getName()),\n                                          StringUtil.nullize(child.getAttributeValue(\"path\"), true),\n                                          activeValue == null || Boolean.parseBoolean(activeValue),\n                                          specificSettings));\n    }\n\n    setList(list);\n  }","id":71217,"modified_method":"@Override\n  public void loadState(Element element) {\n    List<ConfigurableWebBrowser> list = new ArrayList<ConfigurableWebBrowser>();\n    for (Element child : element.getChildren(\"browser\")) {\n      BrowserFamily family = readFamily(child.getAttributeValue(\"family\"));\n      if (family == null) {\n        continue;\n      }\n\n      UUID id = readId(child.getAttributeValue(\"id\"), family, list);\n      if (id == null) {\n        continue;\n      }\n\n      Element settingsElement = child.getChild(\"settings\");\n      BrowserSpecificSettings specificSettings = family.createBrowserSpecificSettings();\n      if (specificSettings != null && settingsElement != null) {\n        try {\n          XmlSerializer.deserializeInto(specificSettings, settingsElement);\n        }\n        catch (Exception e) {\n          LOG.warn(e);\n        }\n      }\n\n      String activeValue = child.getAttributeValue(\"active\");\n\n      String path = StringUtil.nullize(child.getAttributeValue(\"path\"), true);\n      if (path == null) {\n        path = family.getExecutionPath();\n      }\n\n      list.add(new ConfigurableWebBrowser(id,\n                                          family,\n                                          StringUtil.notNullize(child.getAttributeValue(\"name\"), family.getName()),\n                                          path,\n                                          activeValue == null || Boolean.parseBoolean(activeValue),\n                                          specificSettings));\n    }\n\n    setList(list);\n  }","commit_id":"c80c25da85a1c8e7e45012dfdb1ae13ba58a3235","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GitRepositoryManager() throws IOException {\n    FileRepositoryBuilder repositoryBuilder = new FileRepositoryBuilder();\n    repositoryBuilder.setGitDir(new File(dir, Constants.DOT_GIT));\n    Repository repository = repositoryBuilder.build();\n    if (!dir.exists()) {\n      repository.create();\n    }\n\n    git = new Git(repository);\n  }","id":71218,"modified_method":"public GitRepositoryManager() throws IOException {\n    FileRepositoryBuilder repositoryBuilder = new FileRepositoryBuilder();\n    repositoryBuilder.setGitDir(new File(dir, Constants.DOT_GIT));\n    Repository repository = repositoryBuilder.build();\n    if (!dir.exists()) {\n      repository.create(false);\n    }\n    git = Git.wrap(repository);\n  }","commit_id":"b97bc1d8a9b41fa78b051a5ac6ede04a718b9916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void saveRemoteRepositoryUrl() {\n    IcsManager.getInstance().getRepositoryManager().setRemoteRepositoryUrl(StringUtil.nullize(urlTextField.getText()));\n  }","id":71219,"modified_method":"private void saveRemoteRepositoryUrl() {\n    String url = StringUtil.nullize(urlTextField.getText());\n    if (url != null) {\n      boolean isFile;\n      if (url.startsWith(StandardFileSystems.FILE_PROTOCOL_PREFIX)) {\n        url = url.substring(StandardFileSystems.FILE_PROTOCOL_PREFIX.length());\n        isFile = true;\n      }\n      else {\n        isFile = !URLUtil.containsScheme(url);\n      }\n\n      if (isFile) {\n        File file = new File(url);\n        if (file.exists()) {\n          if (!file.isDirectory()) {\n            // todo error\n            return;\n          }\n        }\n        else {\n          if (Messages.showYesNoDialog(getContentPane(), \"Path not exists, would you like to init repository here?\", \"Init repository\", Messages.getQuestionIcon()) == 1) {\n            try {\n              IcsManager.getInstance().getRepositoryManager().initRepository(file);\n            }\n            catch (IOException e) {\n              Messages.showErrorDialog(getContentPane(), IcsBundle.message(\"init.failed.message\", e.getMessage()), IcsBundle.message(\"init.failed.title\"));\n            }\n          }\n          else {\n            // todo return false\n            return;\n          }\n        }\n      }\n    }\n    IcsManager.getInstance().getRepositoryManager().setRemoteRepositoryUrl(url);\n  }","commit_id":"b97bc1d8a9b41fa78b051a5ac6ede04a718b9916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateSyncButtonState() {\n    syncButton.setEnabled(!StringUtil.isEmptyOrSpaces(urlTextField.getText()));\n  }","id":71220,"modified_method":"private void updateSyncButtonState() {\n    String url = urlTextField.getText();\n    syncButton.setEnabled(!StringUtil.isEmptyOrSpaces(url) && url.length() > 1);\n  }","commit_id":"b97bc1d8a9b41fa78b051a5ac6ede04a718b9916","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setUrl(@Nullable String value) {\n    myUrl = StringUtil.nullize(value);\n  }","id":71221,"modified_method":"public void setUrl(@Nullable String value) {\n    String normalized = StringUtil.nullize(value, true);\n    if (normalized != null) {\n      normalized = CharMatcher.WHITESPACE.trimFrom(normalized);\n    }\n    myUrl = normalized;\n  }","commit_id":"83a342e178032727373dfe920212650df10e56eb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void run() {\n    for (SNode child : SNodeOperations.getDescendants(node, \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{})) {\n      if (!(hasErrorOrWarningCheckOperationTag(child))) {\n        TestsErrorsChecker checker = new TestsErrorsChecker(child);\n        final List<IErrorReporter> reporters = checker.getErrorReporters();\n        for (IErrorReporter reporter : reporters) {\n          final String messageString = getErrorString(reporter, child);\n          checkWarnings(reporter, messageString);\n          checkErrors(reporter, messageString);\n        }\n\n      }\n    }\n  }","id":71222,"modified_method":"@Override\n  public void run() {\n    TestsErrorsChecker checker = new TestsErrorsChecker(SNodeOperations.getContainingRoot(node));\n    List<SNode> descendants = SNodeOperations.getDescendants(node, \"jetbrains.mps.lang.core.structure.BaseConcept\", false, new String[]{});\n    final Iterable<IErrorReporter> reporters = checker.getAllErrors();\n    for (IErrorReporter reporter : reporters) {\n      SNode child = reporter.getSNode();\n      assert child != null;\n      if (!(ListSequence.fromList(descendants).contains(child))) {\n        continue;\n      }\n      if (hasErrorOrWarningCheckOperationTag(child)) {\n        continue;\n      }\n      final String messageString = getErrorString(reporter, child);\n      checkWarnings(reporter, messageString);\n      checkErrors(reporter, messageString);\n    }\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public static boolean callSuper_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, String callerConceptFqName, List<IErrorReporter> errorReporters) {\n    return BehaviorManager.getInstance().invokeSuper(Boolean.TYPE, SNodeOperations.cast(thisNode, \"jetbrains.mps.lang.test.structure.IChecksRules\"), callerConceptFqName, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Class[]{SNode.class, List.class}, new Object[]{errorReporters});\n  }","id":71223,"modified_method":"@Deprecated\n  public static boolean callSuper_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, String callerConceptFqName, Iterable<IErrorReporter> errorReporters) {\n    return BehaviorManager.getInstance().invokeSuper(Boolean.TYPE, SNodeOperations.cast(thisNode, \"jetbrains.mps.lang.test.structure.IChecksRules\"), callerConceptFqName, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Class[]{SNode.class, ISequence.class}, new Object[]{errorReporters});\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Deprecated\n  public static boolean call_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, List<IErrorReporter> errorReporters) {\n    return BehaviorReflection.invokeVirtual(Boolean.TYPE, thisNode, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Object[]{errorReporters});\n  }","id":71224,"modified_method":"@Deprecated\n  public static boolean call_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, Iterable<IErrorReporter> errorReporters) {\n    return BehaviorReflection.invokeVirtual(Boolean.TYPE, thisNode, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Object[]{errorReporters});\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, List<IErrorReporter> errorReporters) {\n    if (ListSequence.fromList(errorReporters).isEmpty()) {\n      return false;\n    }\n    SNode referencedRuleNode = IReferenceAttachable_Behavior.call_getReferencedRuleNode_2893471348147987869(thisNode);\n    if ((referencedRuleNode == null)) {\n      return true;\n    }\n    for (IErrorReporter errorReport : errorReporters) {\n      SNode ruleNode = NodeCheckerUtil.getRuleNodeFromReporter(errorReport);\n      if (ruleNode == referencedRuleNode) {\n        return true;\n      }\n    }\n    return false;\n  }","id":71225,"modified_method":"public static boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, Iterable<IErrorReporter> errorReporters) {\n    if (Sequence.fromIterable(errorReporters).isEmpty()) {\n      return false;\n    }\n    SNode referencedRuleNode = IReferenceAttachable_Behavior.call_getReferencedRuleNode_2893471348147987869(thisNode);\n    if ((referencedRuleNode == null)) {\n      return true;\n    }\n    for (IErrorReporter errorReport : errorReporters) {\n      SNode ruleNode = NodeCheckerUtil.getRuleNodeFromReporter(errorReport);\n      if (ruleNode == referencedRuleNode) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, List<IErrorReporter> errorReporters) {\n    return NodeRuleCheckOperation_Behavior.virtual_hasExpectedRuleMessage_5348336190814877000(thisNode, errorReporters);\n  }","id":71226,"modified_method":"public boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, Iterable<IErrorReporter> errorReporters) {\n    return NodeRuleCheckOperation_Behavior.virtual_hasExpectedRuleMessage_5348336190814877000(thisNode, errorReporters);\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, List<IErrorReporter> errorReporters) {\n    for (IErrorReporter errorReport : errorReporters) {\n      SNode ruleNode = NodeCheckerUtil.getRuleNodeFromReporter(errorReport);\n      if (new NodeRuleReference(ruleNode).getType() == RuleType.TYPESYSTEM) {\n        return true;\n      }\n    }\n    return false;\n  }","id":71227,"modified_method":"public static boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, Iterable<IErrorReporter> errorReporters) {\n    for (IErrorReporter errorReport : errorReporters) {\n      SNode ruleNode = NodeCheckerUtil.getRuleNodeFromReporter(errorReport);\n      if (new NodeRuleReference(ruleNode).getType() == RuleType.TYPESYSTEM) {\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, List<IErrorReporter> errorReporters) {\n    return NodeTypeSystemRuleCheckOperation_Behavior.virtual_hasExpectedRuleMessage_5348336190814877000(thisNode, errorReporters);\n  }","id":71228,"modified_method":"public boolean virtual_hasExpectedRuleMessage_5348336190814877000(SNode thisNode, Iterable<IErrorReporter> errorReporters) {\n    return NodeTypeSystemRuleCheckOperation_Behavior.virtual_hasExpectedRuleMessage_5348336190814877000(thisNode, errorReporters);\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void checkNodeHasError(SNode operation) {\n    final SNode nodeToCheck = NodeCheckOperation_Behavior.call_getAnnotatedNode_2912288420882528229(operation);\n    TestsErrorsChecker checker = new TestsErrorsChecker(nodeToCheck);\n    final List<IErrorReporter> errorReporters = checker.getErrorReportersSpecificType(MessageStatus.ERROR);\n\n    final String errorString = \"node <\" + NodeCheckerUtil.nodeWithIdToString(nodeToCheck) + \"> does not have expected error message\";\n\n    Assert.assertTrue(errorString, BehaviorReflection.invokeVirtual(Boolean.TYPE, operation, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Object[]{errorReporters}));\n  }","id":71229,"modified_method":"public static void checkNodeHasError(SNode operation) {\n    final SNode nodeToCheck = NodeCheckOperation_Behavior.call_getAnnotatedNode_2912288420882528229(operation);\n    TestsErrorsChecker checker = new TestsErrorsChecker(SNodeOperations.getContainingRoot(nodeToCheck));\n    final Iterable<IErrorReporter> errorReporters = checker.getErrorsSpecificType(nodeToCheck, MessageStatus.ERROR);\n\n    final String errorString = \"node <\" + NodeCheckerUtil.nodeWithIdToString(nodeToCheck) + \"> does not have expected error message\";\n\n    Assert.assertTrue(errorString, BehaviorReflection.invokeVirtual(Boolean.TYPE, operation, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Object[]{errorReporters}));\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void checkNodeHasWarning(SNode operation) {\n    final SNode nodeToCheck = NodeCheckOperation_Behavior.call_getAnnotatedNode_2912288420882528229(operation);\n    TestsErrorsChecker checker = new TestsErrorsChecker(nodeToCheck);\n    final List<IErrorReporter> errorReporters = checker.getErrorReportersSpecificType(MessageStatus.WARNING);\n\n    final String errorString = \"node <\" + NodeCheckerUtil.nodeWithIdToString(nodeToCheck) + \"> does not have expected warning message\";\n\n    Assert.assertTrue(errorString, BehaviorReflection.invokeVirtual(Boolean.TYPE, operation, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Object[]{errorReporters}));\n  }","id":71230,"modified_method":"public static void checkNodeHasWarning(SNode operation) {\n    final SNode nodeToCheck = NodeCheckOperation_Behavior.call_getAnnotatedNode_2912288420882528229(operation);\n    TestsErrorsChecker checker = new TestsErrorsChecker(SNodeOperations.getContainingRoot(nodeToCheck));\n    final Iterable<IErrorReporter> errorReporters = checker.getErrorsSpecificType(nodeToCheck, MessageStatus.WARNING);\n\n    final String errorString = \"node <\" + NodeCheckerUtil.nodeWithIdToString(nodeToCheck) + \"> does not have expected warning message\";\n\n    Assert.assertTrue(errorString, BehaviorReflection.invokeVirtual(Boolean.TYPE, operation, \"virtual_hasExpectedRuleMessage_5348336190814877000\", new Object[]{errorReporters}));\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {\n    return ListSequence.fromList(SpecifyUtil.getErrorReporters(node)).isNotEmpty();\n  }","id":71231,"modified_method":"private boolean isApplicableToNode(final SNode node, final EditorContext editorContext) {\n    return Sequence.fromIterable(SpecifyUtil.getErrorReporters(node)).isNotEmpty();\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void fillContainerWithRuleMessages(SNode node) {\n    SNode operationsContainer = SpecifyUtil.getOperationsContainer(node);\n    assert (operationsContainer != null);\n    NodeOperationsContainer_Behavior.call_detachAllErrorOperations_5587533744543326483(operationsContainer);\n    List<IErrorReporter> reporters = SpecifyUtil.getErrorReporters(node);\n    for (IErrorReporter reporter : reporters) {\n      SNode ruleNode = NodeCheckerUtil.getRuleNodeFromReporter(reporter);\n      NodeOperationsContainer_Behavior.call_createNodeAndAttachReference_428590876657265140(operationsContainer, ruleNode, reporter);\n      SpecifyUtil.addModelImports(operationsContainer, ruleNode);\n    }\n    MissingDependenciesFixer.fixDependencies(SNodeOperations.getModel(operationsContainer), true);\n  }","id":71232,"modified_method":"public static void fillContainerWithRuleMessages(SNode node) {\n    SNode operationsContainer = SpecifyUtil.getOperationsContainer(node);\n    assert (operationsContainer != null);\n    NodeOperationsContainer_Behavior.call_detachAllErrorOperations_5587533744543326483(operationsContainer);\n    Iterable<IErrorReporter> reporters = SpecifyUtil.getErrorReporters(node);\n    for (IErrorReporter reporter : reporters) {\n      SNode ruleNode = NodeCheckerUtil.getRuleNodeFromReporter(reporter);\n      NodeOperationsContainer_Behavior.call_createNodeAndAttachReference_428590876657265140(operationsContainer, ruleNode, reporter);\n      SpecifyUtil.addModelImports(operationsContainer, ruleNode);\n    }\n    MissingDependenciesFixer.fixDependencies(SNodeOperations.getModel(operationsContainer), true);\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static List<IErrorReporter> getErrorReporters(SNode node) {\n    TestsErrorsChecker checker = new TestsErrorsChecker(node);\n    return checker.getErrorReporters();\n  }","id":71233,"modified_method":"public static Iterable<IErrorReporter> getErrorReporters(SNode node) {\n    TestsErrorsChecker checker = new TestsErrorsChecker(SNodeOperations.getContainingRoot(node));\n    return checker.getErrors(node);\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<IErrorReporter> getErrorReportersSpecificType(final MessageStatus errorType) {\n    List<IErrorReporter> result = ListSequence.fromList(new ArrayList<IErrorReporter>());\n    ListSequence.fromList(result).addSequence(ListSequence.fromList(getErrorReporters()).where(new IWhereFilter<IErrorReporter>() {\n      public boolean accept(IErrorReporter it) {\n        return it.getMessageStatus() == errorType;\n      }\n    }));\n    return result;\n  }","id":71234,"modified_method":"public Iterable<IErrorReporter> getErrorsSpecificType(SNode node, final MessageStatus errorType) {\n    Set<IErrorReporter> result = SetSequence.fromSet(new HashSet<IErrorReporter>());\n    SetSequence.fromSet(result).addSequence(Sequence.fromIterable(getErrors(node)).where(new IWhereFilter<IErrorReporter>() {\n      public boolean accept(IErrorReporter it) {\n        return it.getMessageStatus() == errorType;\n      }\n    }));\n    return result;\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<IErrorReporter> getConstraintsErrorReporters() {\n    INodeChecker checker = new LanguageChecker();\n    final Set<IErrorReporter> errors = checker.getErrors(myNode, SNodeOperations.getModel(myNode).getRepository());\n    return filterReportersByNode(errors, myNode);\n  }","id":71235,"modified_method":"private Iterable<IErrorReporter> getConstraintsErrors() {\n    INodeChecker checker = new LanguageChecker();\n    return checker.getErrors(myRoot, null);\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<IErrorReporter> getTypeSystemErrorReporters() {\n    INodeChecker checker = new TypesystemChecker();\n    final Set<IErrorReporter> errors = checker.getErrors(SNodeOperations.getContainingRoot(myNode), SNodeOperations.getModel(myNode).getRepository());\n    return filterReportersByNode(errors, myNode);\n  }","id":71236,"modified_method":"private Iterable<IErrorReporter> getTypeSystemErrors() {\n    INodeChecker checker = new TypesystemChecker();\n    return checker.getErrors(myRoot, null);\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public TestsErrorsChecker(SNode node) {\n    this.myNode = node;\n  }","id":71237,"modified_method":"public TestsErrorsChecker(SNode root) {\n    this.myRoot = root;\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"private List<IErrorReporter> filterReportersByNode(final Set<IErrorReporter> errors, final SNode node) {\n    return SetSequence.fromSet(errors).where(new IWhereFilter<IErrorReporter>() {\n      public boolean accept(IErrorReporter it) {\n        return it.getSNode().equals(node);\n      }\n    }).toListSequence();\n  }","id":71238,"modified_method":"private Iterable<IErrorReporter> filterReportersByNode(final Iterable<IErrorReporter> errors, @NotNull final SNode nodeToCheck) {\n    return Sequence.fromIterable(errors).where(new IWhereFilter<IErrorReporter>() {\n      public boolean accept(IErrorReporter it) {\n        assert it.getSNode() != null;\n        return it.getSNode().getNodeId() == nodeToCheck.getNodeId();\n      }\n    });\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<IErrorReporter> getErrorReporters() {\n    List<IErrorReporter> result = ListSequence.fromList(new ArrayList<IErrorReporter>());\n    ListSequence.fromList(result).addSequence(ListSequence.fromList(getTypeSystemErrorReporters()));\n    ListSequence.fromList(result).addSequence(ListSequence.fromList(getConstraintsErrorReporters()));\n    return result;\n  }","id":71239,"modified_method":"public Iterable<IErrorReporter> getAllErrors() {\n    ModelAccess.assertLegalRead();\n    return getModelErrors();\n  }","commit_id":"54f5ccc83f2dd7cf51b193e85e34992b3a0374f0","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode commandClosureLiteral, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    for (SNode rs : SNodeOperations.getDescendants(commandClosureLiteral, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\", false, new String[]{})) {\n      if ((SLinkOperations.getTarget(rs, \"expression\", true) != null)) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(rs, \"not allowed here\", \"r:aad06b20-0a6a-42d7-81b8-671529c6126a(jetbrains.mps.lang.access.typesystem)\", \"8974276187400348235\", null, errorTarget);\n        }\n      }\n    }\n  }","id":71240,"modified_method":"public void applyRule(final SNode commandClosureLiteral, final TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    for (SNode rs : ListSequence.fromList(SNodeOperations.getDescendants(commandClosureLiteral, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\", false, new String[]{})).subtract(ListSequence.fromList(SNodeOperations.getDescendants(commandClosureLiteral, \"jetbrains.mps.baseLanguage.structure.IMethodLike\", false, new String[]{})).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return SNodeOperations.getDescendants(it, \"jetbrains.mps.baseLanguage.structure.ReturnStatement\", false, new String[]{});\n      }\n    }))) {\n      if ((SLinkOperations.getTarget(rs, \"expression\", true) != null)) {\n        {\n          MessageTarget errorTarget = new NodeMessageTarget();\n          IErrorReporter _reporter_2309309498 = typeCheckingContext.reportTypeError(rs, \"return statement not allowed here\", \"r:aad06b20-0a6a-42d7-81b8-671529c6126a(jetbrains.mps.lang.access.typesystem)\", \"5842059399448775938\", null, errorTarget);\n        }\n      }\n    }\n  }","commit_id":"b8dc7eff59902e2f42861bda7297fe54717eac18","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void call_collectUncaughtMethodThrowables_5412515780383112967(SAbstractConcept thisConcept, Set<SNode> throwables, SNode arg) {\n    for (SNode methodCall : SNodeOperations.getDescendants(arg, \"jetbrains.mps.baseLanguage.structure.IMethodCall\", false, new String[]{})) {\n      for (SNode throwable : SLinkOperations.getTargets(SLinkOperations.getTarget(methodCall, \"baseMethodDeclaration\", false), \"throwsItem\", true)) {\n        if (SNodeOperations.isInstanceOf(throwable, \"jetbrains.mps.baseLanguage.structure.ClassifierType\")) {\n          SetSequence.fromSet(throwables).addElement(SLinkOperations.getTarget(SNodeOperations.cast(throwable, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false));\n        }\n      }\n    }\n  }","id":71241,"modified_method":"public static void call_collectUncaughtMethodThrowables_5412515780383112967(SAbstractConcept thisConcept, final Set<SNode> throwables, SNode arg) {\n    ListSequence.fromList(SNodeOperations.getDescendants(arg, \"jetbrains.mps.baseLanguage.structure.IMethodCall\", false, new String[]{})).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return SLinkOperations.getTargets(SLinkOperations.getTarget(it, \"baseMethodDeclaration\", false), \"throwsItem\", true);\n      }\n    }).union(ListSequence.fromList(SNodeOperations.getDescendants(arg, \"jetbrains.mps.baseLanguage.classifiers.structure.DefaultClassifierMethodCallOperation\", false, new String[]{})).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return SLinkOperations.getTargets(SLinkOperations.getTarget(it, \"member\", false), \"throwsItem\", true);\n      }\n    })).where(new IWhereFilter<SNode>() {\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n      }\n    }).visitAll(new IVisitor<SNode>() {\n      public void visit(SNode throwable) {\n        SetSequence.fromSet(throwables).addElement(SLinkOperations.getTarget(SNodeOperations.cast(throwable, \"jetbrains.mps.baseLanguage.structure.ClassifierType\"), \"classifier\", false));\n      }\n    });\n  }","commit_id":"74390e5470468b41f736e9eb587e8ba4573d37cf","url":"https://github.com/JetBrains/MPS"},{"original_method":"public List<SNode> getSubOrSuperTypes(SNode clt, TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> supertypes = ListSequence.fromList(new ArrayList<SNode>());\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = SNodeOperations.cast(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        ListSequence.fromList(supertypes).addElement(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true)));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = SNodeOperations.cast(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\");\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true)));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Annotation\")) {\n      ListSequence.fromList(supertypes).addElement(new subtyping_classifier_SubtypingRule.QuotationClass_pgdy8e_a0a0a0f0a().createNode(typeCheckingContext));\n    }\n    if (ListSequence.fromList(supertypes).isEmpty()) {\n      ListSequence.fromList(result).addElement(new subtyping_classifier_SubtypingRule.QuotationClass_pgdy8e_a0a0a0g0a().createNode(typeCheckingContext));\n    }\n    for (SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.cast(SNodeOperations.copyNode(supertype), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n      for (SNode typeParam : SLinkOperations.getTargets(supertypeCopy, \"parameter\", true)) {\n        for (SNode typeVar : SNodeOperations.getDescendants(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true, new String[]{})) {\n          int i = ListSequence.fromList(SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false));\n          if (!(i < 0 || i >= ListSequence.fromList(SLinkOperations.getTargets(clt, \"parameter\", true)).count())) {\n            // substitute the typevar ref with the existing type from the original CT \n            SNode newNode = SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(clt, \"parameter\", true)).getElement(i));\n            SNodeOperations.replaceWithAnother(typeVar, newNode);\n          }\n        }\n      }\n      ListSequence.fromList(result).addElement(supertypeCopy);\n    }\n    ListSequence.fromList(supertypes).addElement(clt);\n    for (SNode supertype : supertypes) {\n      if (ListSequence.fromList(SLinkOperations.getTargets((SNodeOperations.cast(supertype, \"jetbrains.mps.baseLanguage.structure.ClassifierType\")), \"parameter\", true)).count() > 0) {\n        SNode erasure = SNodeOperations.cast(SNodeOperations.copyNode(supertype), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n        for (SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        ListSequence.fromList(result).addElement(erasure);\n      }\n    }\n    return result;\n  }","id":71242,"modified_method":"public List<SNode> getSubOrSuperTypes(SNode clt, TypeCheckingContext typeCheckingContext, IsApplicableStatus status) {\n    SNode classifier = SLinkOperations.getTarget(clt, \"classifier\", false);\n    List<SNode> result = ListSequence.fromList(new ArrayList<SNode>());\n    List<SNode> supertypes = ListSequence.fromList(new ArrayList<SNode>());\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")) {\n      SNode classConcept = SNodeOperations.cast(classifier, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n      if (!((SLinkOperations.getTarget(classConcept, \"superclass\", true) == null))) {\n        ListSequence.fromList(supertypes).addElement(SLinkOperations.getTarget(classConcept, \"superclass\", true));\n      }\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(classConcept, \"implementedInterface\", true)));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\")) {\n      SNode interfaceConcept = SNodeOperations.cast(classifier, \"jetbrains.mps.baseLanguage.structure.Interface\");\n      ListSequence.fromList(supertypes).addSequence(ListSequence.fromList(SLinkOperations.getTargets(interfaceConcept, \"extendedInterface\", true)));\n    }\n    if (SNodeOperations.isInstanceOf(classifier, \"jetbrains.mps.baseLanguage.structure.Annotation\")) {\n      ListSequence.fromList(supertypes).addElement(new subtyping_classifier_SubtypingRule.QuotationClass_pgdy8e_a0a0a0f0a().createNode(typeCheckingContext));\n    }\n    if (ListSequence.fromList(supertypes).isEmpty()) {\n      ListSequence.fromList(result).addElement(new subtyping_classifier_SubtypingRule.QuotationClass_pgdy8e_a0a0a0g0a().createNode(typeCheckingContext));\n    }\n    for (SNode supertype : supertypes) {\n      SNode supertypeCopy = SNodeOperations.cast(SNodeOperations.copyNode(supertype), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n      for (SNode typeParam : SLinkOperations.getTargets(supertypeCopy, \"parameter\", true)) {\n        List<SNode> descendants = ListSequence.fromList(SNodeOperations.getDescendants(typeParam, \"jetbrains.mps.baseLanguage.structure.TypeVariableReference\", true, new String[]{})).toListSequence();\n        for (SNode typeVar : descendants) {\n          int i = ListSequence.fromList(SLinkOperations.getTargets(classifier, \"typeVariableDeclaration\", true)).indexOf(SLinkOperations.getTarget(typeVar, \"typeVariableDeclaration\", false));\n          if (0 <= i && i < ListSequence.fromList(SLinkOperations.getTargets(clt, \"parameter\", true)).count()) {\n            // substitute the typevar ref with the existing type from the original CT \n            SNodeOperations.replaceWithAnother(typeVar, SNodeOperations.copyNode(ListSequence.fromList(SLinkOperations.getTargets(clt, \"parameter\", true)).getElement(i)));\n          } else if (0 <= i) {\n            // this is a (partially) raw class \n            ((SNode) supertypeCopy).removeChild(typeParam);\n          }\n        }\n      }\n      ListSequence.fromList(result).addElement(supertypeCopy);\n    }\n    ListSequence.fromList(supertypes).addElement(clt);\n    for (SNode supertype : supertypes) {\n      if (ListSequence.fromList(SLinkOperations.getTargets((SNodeOperations.cast(supertype, \"jetbrains.mps.baseLanguage.structure.ClassifierType\")), \"parameter\", true)).count() > 0) {\n        SNode erasure = SNodeOperations.cast(SNodeOperations.copyNode(supertype), \"jetbrains.mps.baseLanguage.structure.ClassifierType\");\n        for (SNode parameter : SLinkOperations.getTargets(erasure, \"parameter\", true)) {\n          SNodeOperations.deleteNode(parameter);\n        }\n        ListSequence.fromList(result).addElement(erasure);\n      }\n    }\n    return result;\n  }","commit_id":"e1a0885ce98419faf0868e3cc4a938cfec485a8d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void test2Parameterized() throws Exception {\n    final Description root = Description.createSuiteDescription(\"root\");\n    for (String className : new String[]{\"a.TestA\", \"a.TestB\"}) {\n      final Description aTestClass = Description.createSuiteDescription(className);\n      root.addChild(aTestClass);\n      attachParameterizedTests(className, aTestClass);\n    }\n    doTest(root, \"##teamcity[suiteTreeStarted name='TestA' locationHint='java:suite://a.TestA']\\n\" +\n                 \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://a.TestA.|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://a.TestA.testName|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://a.TestA.|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://a.TestA.testName|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='TestA']\\n\" +\n                 \"##teamcity[suiteTreeStarted name='TestB' locationHint='java:suite://a.TestB']\\n\" +\n                 \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://a.TestB.|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://a.TestB.testName|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://a.TestB.|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://a.TestB.testName|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='TestB']\\n\");\n  }","id":71243,"modified_method":"@Test\n  public void test2Parameterized() throws Exception {\n    final Description root = Description.createSuiteDescription(\"root\");\n    final ArrayList<Description> tests = new ArrayList<Description>();\n    for (String className : new String[]{\"a.TestA\", \"a.TestB\"}) {\n      final Description aTestClass = Description.createSuiteDescription(className);\n      root.addChild(aTestClass);\n      attachParameterizedTests(className, aTestClass, tests);\n    }\n    doTest(root, tests,\n           \"##teamcity[suiteTreeStarted name='TestA' locationHint='java:suite://a.TestA']\\n\" +\n           \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://a.TestA.|[0|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://a.TestA.testName|[0|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n           \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://a.TestA.|[1|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://a.TestA.testName|[1|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[1|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='TestA']\\n\" +\n           \"##teamcity[suiteTreeStarted name='TestB' locationHint='java:suite://a.TestB']\\n\" +\n           \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://a.TestB.|[0|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://a.TestB.testName|[0|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n           \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://a.TestB.|[1|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://a.TestB.testName|[1|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[1|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='TestB']\\n\",\n\n\n           \"##teamcity[enteredTheMatrix]\\n\" +\n           \"\\n\" +\n           \"##teamcity[rootName name = 'root']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteFinished name='root']\\n\" +\n           \"##teamcity[testSuiteStarted name ='TestA']\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[0|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[0|]' locationHint='java:test://a.TestA.testName|[0|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[0|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[0|]']\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[1|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[1|]' locationHint='java:test://a.TestA.testName|[1|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[1|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[1|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='TestA']\\n\" +\n           \"##teamcity[testSuiteStarted name ='TestB']\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[0|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[0|]' locationHint='java:test://a.TestB.testName|[0|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[0|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[0|]']\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[1|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[1|]' locationHint='java:test://a.TestB.testName|[1|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[1|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[1|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteFinished name='TestB']\\n\" +\n           \"\\n\");\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testProcessEmptyTestCase() throws Exception {\n    final Description description = Description.createSuiteDescription(\"TestA\");\n    final Description emptyDescription = Description.createTestDescription(SMTestSender.EMPTY_SUITE_NAME, SMTestSender.EMPTY_SUITE_WARNING);\n    description.addChild(emptyDescription);\n\n    final StringBuffer buf = new StringBuffer();\n    final PrintStream printStream = new PrintStream(new OutputStream() {\n      @Override\n      public void write(int b) throws IOException {\n        buf.append(new String(new byte[]{(byte)b}));\n      }\n    });\n\n    final SMTestSender sender = new SMTestSender(printStream);\n    \n    sender.sendTree(description);\n\n    sender.testRunStarted(description);\n    sender.testStarted(emptyDescription);\n    sender.testFinished(emptyDescription);\n    sender.testRunFinished(new Result());\n\n    Assert.assertEquals(\"output: \" + buf, \"##teamcity[suiteTreeNode name='warning' locationHint='java:test://junit.framework.TestSuite$1.warning']\\n\" +\n                                          \"##teamcity[enteredTheMatrix]\\n\" +\n                                          \"\\n\" +\n                                          \"##teamcity[rootName name = 'TestA']\\n\" +\n                                          \"\\n\" +\n                                          \"##teamcity[testStarted name='warning' locationHint='java:test://junit.framework.TestSuite$1.warning']\\n\" +\n                                          \"\\n\" +\n                                          \"##teamcity[testFinished name='warning']\\n\" +\n                                          \"##teamcity[testSuiteFinished name='TestA']\\n\" +\n                                          \"\\n\", StringUtil.convertLineSeparators(buf.toString()));\n  }","id":71244,"modified_method":"@Test\n  public void testProcessEmptyTestCase() throws Exception {\n    final Description description = Description.createSuiteDescription(\"TestA\");\n    final Description emptyDescription = Description.createTestDescription(SMTestSender.EMPTY_SUITE_NAME, SMTestSender.EMPTY_SUITE_WARNING);\n    description.addChild(emptyDescription);\n    doTest(description, Collections.singletonList(emptyDescription),\n           \"##teamcity[suiteTreeNode name='warning' locationHint='java:test://TestA.warning']\\n\",\n\n\n           \"##teamcity[enteredTheMatrix]\\n\" +\n           \"\\n\" +\n           \"##teamcity[rootName name = 'TestA']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testStarted name='warning' locationHint='java:test://junit.framework.TestSuite$1.warning']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='warning']\\n\" +\n           \"##teamcity[testSuiteFinished name='TestA']\\n\" +\n           \"\\n\");\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void attachParameterizedTests(String className, Description aTestClass) {\n    for (String paramName : new String[]{\"[0]\", \"[1]\"}) {\n      final Description param1 = Description.createSuiteDescription(paramName);\n      aTestClass.addChild(param1);\n      param1.addChild(Description.createTestDescription(className, \"testName\" + paramName));\n    }\n  }","id":71245,"modified_method":"private static void attachParameterizedTests(String className, Description aTestClass, List<Description> tests) {\n    for (String paramName : new String[]{\"[0]\", \"[1]\"}) {\n      final Description param1 = Description.createSuiteDescription(paramName);\n      aTestClass.addChild(param1);\n      final Description testDescription = Description.createTestDescription(className, \"testName\" + paramName);\n      tests.add(testDescription);\n      param1.addChild(testDescription);\n    }\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testSuiteAndParameterizedTestsInOnePackage() throws Exception {\n    final Description root = Description.createSuiteDescription(\"root\");\n    final Description aTestClass = Description.createSuiteDescription(\"ATest\");\n    root.addChild(aTestClass);\n    attachParameterizedTests(\"ATest\", aTestClass);\n    final Description suiteDescription = Description.createSuiteDescription(\"suite\");\n    root.addChild(suiteDescription);\n    final Description aTestClassWithJUnit3Test = Description.createSuiteDescription(\"ATest\");\n    suiteDescription.addChild(aTestClassWithJUnit3Test);\n    aTestClassWithJUnit3Test.addChild(Description.createTestDescription(\"ATest\", \"test\"));\n    doTest(root, \"##teamcity[suiteTreeStarted name='ATest' locationHint='java:suite://ATest']\\n\" +\n                 \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://ATest.|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://ATest.testName|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n                 \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://ATest.|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://ATest.testName|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='|[1|]']\\n\" +\n                 \"##teamcity[suiteTreeNode name='test' locationHint='java:test://ATest.test']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='ATest']\\n\");\n  }","id":71246,"modified_method":"@Test\n  public void testSuiteAndParameterizedTestsInOnePackage() throws Exception {\n    final Description root = Description.createSuiteDescription(\"root\");\n    final Description aTestClass = Description.createSuiteDescription(\"ATest\");\n    root.addChild(aTestClass);\n    final ArrayList<Description> tests = new ArrayList<Description>();\n    attachParameterizedTests(\"ATest\", aTestClass, tests);\n    final Description suiteDescription = Description.createSuiteDescription(\"suite\");\n    root.addChild(suiteDescription);\n    final Description aTestClassWithJUnit3Test = Description.createSuiteDescription(\"ATest\");\n    suiteDescription.addChild(aTestClassWithJUnit3Test);\n    final Description testDescription = Description.createTestDescription(\"ATest\", \"test\");\n    aTestClassWithJUnit3Test.addChild(testDescription);\n    tests.add(testDescription);\n    doTest(root, tests,\n           \"##teamcity[suiteTreeStarted name='ATest' locationHint='java:suite://ATest']\\n\" +\n           \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://ATest.|[0|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://ATest.testName|[0|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n           \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://ATest.|[1|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://ATest.testName|[1|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[1|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='ATest']\\n\" +\n           \"##teamcity[suiteTreeStarted name='suite' locationHint='java:suite://suite']\\n\" +\n           \"##teamcity[suiteTreeStarted name='ATest' locationHint='java:suite://ATest']\\n\" +\n           \"##teamcity[suiteTreeNode name='test' locationHint='java:test://ATest.test']\\n\" +\n           \"##teamcity[suiteTreeEnded name='ATest']\\n\" +\n           \"##teamcity[suiteTreeEnded name='suite']\\n\",\n\n           //start\n           \"##teamcity[enteredTheMatrix]\\n\" +\n           \"\\n\" +\n           \"##teamcity[rootName name = 'root']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteFinished name='root']\\n\" +\n           \"##teamcity[testSuiteStarted name ='ATest']\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[0|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[0|]' locationHint='java:test://ATest.testName|[0|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[0|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[0|]']\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[1|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[1|]' locationHint='java:test://ATest.testName|[1|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[1|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[1|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='ATest']\\n\" +\n           \"##teamcity[testSuiteStarted name ='suite']\\n\" +\n           \"##teamcity[testSuiteStarted name ='ATest']\\n\" +\n           \"##teamcity[testStarted name='test' locationHint='java:test://ATest.test']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='test']\\n\" +\n           \"##teamcity[testSuiteFinished name='ATest']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteFinished name='suite']\\n\" +\n           \"\\n\");\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void testSingleParameterizedClass() throws Exception {\n    final String className = \"a.TestA\";\n    final Description aTestClassDescription = Description.createSuiteDescription(className);\n    attachParameterizedTests(className, aTestClassDescription);\n    doTest(aTestClassDescription, \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://a.TestA.|[0|]']\\n\" +\n                                  \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://a.TestA.testName|[0|]']\\n\" +\n                                  \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n                                  \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://a.TestA.|[1|]']\\n\" +\n                                  \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://a.TestA.testName|[1|]']\\n\" +\n                                  \"##teamcity[suiteTreeEnded name='|[1|]']\\n\");\n  }","id":71247,"modified_method":"@Test\n  public void testSingleParameterizedClass() throws Exception {\n    final String className = \"a.TestA\";\n    final Description aTestClassDescription = Description.createSuiteDescription(className);\n    final ArrayList<Description> tests = new ArrayList<Description>();\n    attachParameterizedTests(className, aTestClassDescription, tests);\n    doTest(aTestClassDescription, tests,\n           //tree\n           \"##teamcity[suiteTreeStarted name='|[0|]' locationHint='java:suite://a.TestA.|[0|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[0|]' locationHint='java:test://a.TestA.testName|[0|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[0|]']\\n\" +\n           \"##teamcity[suiteTreeStarted name='|[1|]' locationHint='java:suite://a.TestA.|[1|]']\\n\" +\n           \"##teamcity[suiteTreeNode name='testName|[1|]' locationHint='java:test://a.TestA.testName|[1|]']\\n\" +\n           \"##teamcity[suiteTreeEnded name='|[1|]']\\n\",\n           //start\n           \"##teamcity[enteredTheMatrix]\\n\" +\n           \"\\n\" +\n           \"##teamcity[rootName name = 'TestA' comment = 'a']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[0|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[0|]' locationHint='java:test://a.TestA.testName|[0|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[0|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[0|]']\\n\" +\n           \"##teamcity[testSuiteStarted name ='|[1|]']\\n\" +\n           \"##teamcity[testStarted name='testName|[1|]' locationHint='java:test://a.TestA.testName|[1|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='testName|[1|]']\\n\" +\n           \"##teamcity[testSuiteFinished name='|[1|]']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteFinished name='TestA']\\n\" +\n           \"\\n\");\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n  public void test2SuitesWithTheSameTest() throws Exception {\n    final Description root = Description.createSuiteDescription(\"root\");\n    final String className = \"ATest\";\n    final String methodName = \"test1\";\n    for( String suiteName : new String[] {\"ASuite1\", \"ASuite2\"}) {\n      final Description aSuite = Description.createSuiteDescription(suiteName);\n      root.addChild(aSuite);\n      final Description aTest = Description.createSuiteDescription(className);\n      aSuite.addChild(aTest);\n      aTest.addChild(Description.createTestDescription(className, methodName));\n    }\n    \n    doTest(root, \"##teamcity[suiteTreeStarted name='ATest' locationHint='java:suite://ATest']\\n\" +\n                 \"##teamcity[suiteTreeNode name='test1' locationHint='java:test://ATest.test1']\\n\" +\n                 \"##teamcity[suiteTreeEnded name='ATest']\\n\");\n  }","id":71248,"modified_method":"@Test\n  public void test2SuitesWithTheSameTest() throws Exception {\n    final Description root = Description.createSuiteDescription(\"root\");\n    final String className = \"ATest\";\n    final String methodName = \"test1\";\n    final List<Description> tests = new ArrayList<Description>();\n    for( String suiteName : new String[] {\"ASuite1\", \"ASuite2\"}) {\n      final Description aSuite = Description.createSuiteDescription(suiteName);\n      root.addChild(aSuite);\n      final Description aTest = Description.createSuiteDescription(className);\n      aSuite.addChild(aTest);\n      final Description testDescription = Description.createTestDescription(className, methodName);\n      tests.add(testDescription);\n      aTest.addChild(testDescription);\n    }\n\n    doTest(root, tests,\n           //expected tree\n           \"##teamcity[suiteTreeStarted name='ASuite1' locationHint='java:suite://ASuite1']\\n\" +\n           \"##teamcity[suiteTreeStarted name='ATest' locationHint='java:suite://ATest']\\n\" +\n           \"##teamcity[suiteTreeNode name='test1' locationHint='java:test://ATest.test1']\\n\" +\n           \"##teamcity[suiteTreeEnded name='ATest']\\n\" +\n           \"##teamcity[suiteTreeEnded name='ASuite1']\\n\" +\n           \"##teamcity[suiteTreeStarted name='ASuite2' locationHint='java:suite://ASuite2']\\n\" +\n           \"##teamcity[suiteTreeStarted name='ATest' locationHint='java:suite://ATest']\\n\" +\n           \"##teamcity[suiteTreeNode name='test1' locationHint='java:test://ATest.test1']\\n\" +\n           \"##teamcity[suiteTreeEnded name='ATest']\\n\" +\n           \"##teamcity[suiteTreeEnded name='ASuite2']\\n\",\n\n           //started\n           \"##teamcity[enteredTheMatrix]\\n\" +\n           \"\\n\" +\n           \"##teamcity[rootName name = 'root']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteFinished name='root']\\n\" +\n           \"##teamcity[testSuiteStarted name ='ASuite1']\\n\" +\n           \"##teamcity[testSuiteStarted name ='ATest']\\n\" +\n           \"##teamcity[testStarted name='test1' locationHint='java:test://ATest.test1']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='test1']\\n\" +\n           \"##teamcity[testSuiteFinished name='ATest']\\n\" +\n           \"##teamcity[testSuiteFinished name='ASuite1']\\n\" +\n           \"##teamcity[testSuiteStarted name ='ASuite2']\\n\" +\n           \"##teamcity[testSuiteStarted name ='ATest']\\n\" +\n           \"##teamcity[testStarted name='test1' locationHint='java:test://ATest.test1']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testFinished name='test1']\\n\" +\n           \"##teamcity[testSuiteFinished name='ATest']\\n\" +\n           \"\\n\" +\n           \"##teamcity[testSuiteFinished name='ASuite2']\\n\" +\n           \"\\n\");\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void sendTree(Description description, Map groups, Description parent) {\n    final String className = JUnit4ReflectionUtil.getClassName(description);\n    if (description.getChildren().isEmpty()) {\n      final String methodName = JUnit4ReflectionUtil.getMethodName((Description)description);\n      if (methodName != null) {\n        myPrintStream.println(\"##teamcity[suiteTreeNode name=\\'\" + escapeName(methodName) + \"\\' \" + getTestMethodLocation(methodName, className) + \"]\");\n        if (isWarning(methodName, className)) {\n          myEmptyTests.add(getShortName(JUnit4ReflectionUtil.getClassName(parent)));\n        }\n      }\n      return;\n    }\n    List tests = (List)groups.get(description);\n    if (isParameter(description)) {\n      tests = description.getChildren();\n    }\n    if (tests == null) {\n      return;\n    }\n    boolean pass = false;\n    for (Iterator iterator = tests.iterator(); iterator.hasNext(); ) {\n      final Object next = iterator.next();\n      final List childTests = ((Description)next).getChildren();\n      final Description nextDescription = (Description)next;\n      if (((myCurrentClassName == null || !myCurrentClassName.equals(className)) && (childTests.isEmpty() && JUnit4ReflectionUtil.getMethodName(nextDescription) != null || isParameter(nextDescription))) && !pass) {\n        pass = true;\n        String locationHint = className;\n        if (isParameter((Description)description)) {\n          final String displayName = nextDescription.getDisplayName();\n          final int paramIdx = displayName.indexOf(locationHint);\n          if (paramIdx > -1) {\n            locationHint = displayName.substring(paramIdx + locationHint.length());\n            if (locationHint.startsWith(\"(\") && locationHint.endsWith(\")\")) {\n              locationHint = locationHint.substring(1, locationHint.length() - 1) + \".\" + className; \n            }\n          }\n        }\n        myPrintStream.println(\"##teamcity[suiteTreeStarted name=\\'\" + escapeName(getShortName(className)) +\n                       \"\\' locationHint=\\'java:suite://\" + escapeName(locationHint) + \"\\']\");\n      }\n      sendTree(nextDescription, groups, description);\n    }\n    if (pass) {\n      myPrintStream.println(\"##teamcity[suiteTreeEnded name=\\'\" + escapeName(getShortName(JUnit4ReflectionUtil.getClassName((Description)description))) + \"\\']\");\n      groups.remove(description);\n    }\n  }","id":71249,"modified_method":"private void sendTree(Description description, Description parent, Description suiteParent) {\n    String className = JUnit4ReflectionUtil.getClassName(description);\n    if (description.getChildren().isEmpty()) {\n      final String methodName = JUnit4ReflectionUtil.getMethodName((Description)description);\n      if (methodName != null) {\n        if (isWarning(methodName, className)) {\n          className = JUnit4ReflectionUtil.getClassName(parent);\n          myEmptyTests.add(getShortName(className));\n        }\n        myPrintStream.println(\"##teamcity[suiteTreeNode name=\\'\" + escapeName(methodName) + \"\\' \" + getTestMethodLocation(methodName, className) + \"]\");\n      }\n\n      if (suiteParent != null ) {\n        final String parentFQName = JUnit4ReflectionUtil.getClassName(suiteParent);\n        if (!myCurrentClassName.equals(parentFQName)) {\n          List parents = (List)myParents.get(description);\n          if (parents == null) {\n            parents = new ArrayList();\n            myParents.put(description, parents);\n          }\n          if (!parents.contains(parentFQName)) {\n            parents.add(parentFQName);\n          }\n\n          List descriptors = (List)mySuites.get(parentFQName);\n          if (descriptors == null) {\n            descriptors = new ArrayList();\n            mySuites.put(parentFQName, descriptors);\n          }\n          descriptors.add(description);\n        }\n      }\n\n      return;\n    }\n   \n    List tests = description.getChildren();\n    boolean pass = false;\n    for (Iterator iterator = tests.iterator(); iterator.hasNext(); ) {\n      final Object next = iterator.next();\n      final Description nextDescription = (Description)next;\n      final List childTests = nextDescription.getChildren();\n      if ((myCurrentClassName == null || !myCurrentClassName.equals(className)) && !pass) {\n        pass = true;\n        String locationHint = className;\n        if (isParameter((Description)description)) {\n          final String displayName = nextDescription.getDisplayName();\n          final int paramIdx = displayName.indexOf(locationHint);\n          if (paramIdx > -1) {\n            locationHint = displayName.substring(paramIdx + locationHint.length());\n            if (locationHint.startsWith(\"(\") && locationHint.endsWith(\")\")) {\n              locationHint = locationHint.substring(1, locationHint.length() - 1) + \".\" + className; \n            }\n          }\n        }\n        myPrintStream.println(\"##teamcity[suiteTreeStarted name=\\'\" + escapeName(getShortName(className)) + \"\\' locationHint=\\'java:suite://\" + escapeName(locationHint) + \"\\']\");\n      }\n      sendTree(nextDescription, description, isParameter(description) ? null : childTests.isEmpty() && parent != null ? parent : description);\n    }\n    if (pass) {\n      myPrintStream.println(\"##teamcity[suiteTreeEnded name=\\'\" + escapeName(getShortName(JUnit4ReflectionUtil.getClassName((Description)description))) + \"\\']\");\n    }\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void sendTree(Description description) {\n    myCurrentClassName = JUnit4ReflectionUtil.getClassName((Description)description);\n    final HashMap group = new HashMap();\n    groupTests(description, group);\n    sendTree(description, group, null);\n  }","id":71250,"modified_method":"public void sendTree(Description description) {\n    myCurrentClassName = JUnit4ReflectionUtil.getClassName((Description)description);\n    sendTree(description, null, null);\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testRunFinished(Result result) throws Exception {\n    if (myParamName != null) {\n      myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myParamName) + \"\\']\\n\");\n    }\n    if (myCurrentClassName != null) {\n      myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myCurrentClassName) + \"\\']\\n\");\n    }\n  }","id":71251,"modified_method":"public void testRunFinished(Result result) throws Exception {\n    if (myParamName != null) {\n      myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myParamName) + \"\\']\\n\");\n    }\n    if (myCurrentClassName != null) {\n      myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myCurrentClassName) + \"\\']\\n\");\n    }\n    if (myCurrentSuiteName != null) {\n      myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(getShortName(myCurrentSuiteName)) + \"\\']\\n\");\n    }\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testStarted(Description description) throws Exception {\n    final String methodName = JUnit4ReflectionUtil.getMethodName(description);\n    final String classFQN = JUnit4ReflectionUtil.getClassName(description);\n    final int paramStart = methodName.indexOf('[');\n    if (myParamName != null){\n      myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myParamName) + \"\\']\");\n      myParamName = null;\n    }\n    String className = getShortName(classFQN);\n    if (!myEmptyTests.isEmpty() && isWarning(methodName, classFQN)) {\n      className = (String)myEmptyTests.remove(0);\n    }\n    if (!className.equals(myCurrentClassName)) {\n      if (myCurrentClassName != null) {\n        myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myCurrentClassName) + \"\\']\");\n      }\n      myCurrentClassName = className;\n      myPrintStream.println(\"##teamcity[testSuiteStarted name =\\'\" + escapeName(myCurrentClassName) + \"\\']\");\n    }\n    if (paramStart > -1) {\n      final String paramName = methodName.substring(paramStart, methodName.length());\n      if (!paramName.equals(myParamName)) {\n        myParamName = paramName;\n        myPrintStream.println(\"##teamcity[testSuiteStarted name =\\'\" + escapeName(myParamName) + \"\\']\");\n      }\n    }\n    myPrintStream.println(\"##teamcity[testStarted name=\\'\" + escapeName(methodName) + \"\\' \" + \n                          getTestMethodLocation(methodName, classFQN) + \"]\");\n  }","id":71252,"modified_method":"public void testStarted(Description description) throws Exception {\n    final String methodName = JUnit4ReflectionUtil.getMethodName(description);\n    final String classFQN = JUnit4ReflectionUtil.getClassName(description);\n    final int paramStart = methodName.indexOf('[');\n    if (myParamName != null){\n      myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myParamName) + \"\\']\");\n      myParamName = null;\n    }\n\n    final List suites = (List)myParents.get(description);\n    if (suites != null && !suites.isEmpty()) {\n      String currentSuite = (String)suites.get(0);\n      List descriptors = (List)mySuites.get(currentSuite);\n\n      if (descriptors.isEmpty()) {\n        currentSuite = (String)suites.get(1);\n        descriptors = (List)mySuites.get(currentSuite);\n      }\n\n      if (!currentSuite.equals(myCurrentSuiteName)) {\n        finishCurrentSuite();\n        myCurrentSuiteName = currentSuite;\n        myPrintStream.println(\"##teamcity[testSuiteStarted name =\\'\" + escapeName(getShortName(myCurrentSuiteName)) + \"\\']\");\n      }\n\n      descriptors.remove(description);\n    }\n    else if (myCurrentSuiteName != null){\n      finishCurrentSuite();\n      myCurrentSuiteName = null;\n    }\n\n    String className = getShortName(classFQN);\n    if (!myEmptyTests.isEmpty() && isWarning(methodName, classFQN)) {\n      className = (String)myEmptyTests.remove(0);\n    }\n\n    if (!className.equals(myCurrentClassName)) {\n      if (myCurrentClassName != null) {\n        myPrintStream.println(\"##teamcity[testSuiteFinished name=\\'\" + escapeName(myCurrentClassName) + \"\\']\");\n      }\n      myCurrentClassName = className;\n      myPrintStream.println(\"##teamcity[testSuiteStarted name =\\'\" + escapeName(myCurrentClassName) + \"\\']\");\n    }\n    if (paramStart > -1) {\n      final String paramName = methodName.substring(paramStart, methodName.length());\n      if (!paramName.equals(myParamName)) {\n        myParamName = paramName;\n        myPrintStream.println(\"##teamcity[testSuiteStarted name =\\'\" + escapeName(myParamName) + \"\\']\");\n      }\n    }\n    myPrintStream.println(\"##teamcity[testStarted name=\\'\" + escapeName(methodName) + \"\\' \" + \n                          getTestMethodLocation(methodName, classFQN) + \"]\");\n  }","commit_id":"2b2985c28f82bb54e04a91ce2199916a19e87d0c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean setupRunConfiguration(final @NotNull DartTestRunnerParameters runnerParams, final @NotNull PsiElement psiElement) {\n    if (psiElement instanceof DartCallExpression) {\n      final String testName = TestUtil.findTestName((DartCallExpression)psiElement);\n      final List<VirtualFile> virtualFiles = DartResolveUtil.findLibrary(psiElement.getContainingFile());\n      if (testName == null || virtualFiles.isEmpty()) {\n        return false;\n      }\n\n      runnerParams.setTestName(testName);\n      runnerParams.setScope(TestUtil.isTest((DartCallExpression)psiElement) ? Scope.METHOD : Scope.GROUP);\n      final VirtualFile dartFile = virtualFiles.iterator().next();\n      final String dartFilePath = dartFile.getPath();\n      runnerParams.setFilePath(dartFilePath);\n      runnerParams.setWorkingDirectory(DartProjectTemplate.getWorkingDirForDartScript(psiElement.getProject(), dartFile));\n      return true;\n    }\n    else {\n      final PsiFile psiFile = psiElement.getContainingFile();\n      if (psiFile instanceof DartFile) {\n        final VirtualFile virtualFile = DartResolveUtil.getRealVirtualFile((DartFile)psiElement);\n        if (virtualFile == null || !DartResolveUtil.isLibraryRoot((DartFile)psiElement)) {\n          return false;\n        }\n\n        runnerParams.setTestName(DartResolveUtil.getLibraryName((DartFile)psiElement));\n        runnerParams.setScope(Scope.FILE);\n        final String dartFilePath = FileUtil.toSystemIndependentName(virtualFile.getPath());\n        runnerParams.setFilePath(dartFilePath);\n        runnerParams.setWorkingDirectory(DartProjectTemplate.getWorkingDirForDartScript(psiElement.getProject(), virtualFile));\n        return true;\n      }\n    }\n    return false;\n  }","id":71253,"modified_method":"private static boolean setupRunnerParametersForFile(@NotNull final DartTestRunnerParameters runnerParams,\n                                                      @NotNull final PsiElement psiElement) {\n    if (psiElement instanceof DartCallExpression) {\n      final String testName = TestUtil.findTestName((DartCallExpression)psiElement);\n      final List<VirtualFile> virtualFiles = DartResolveUtil.findLibrary(psiElement.getContainingFile());\n      if (testName == null || virtualFiles.isEmpty()) {\n        return false;\n      }\n\n      runnerParams.setTestName(testName);\n      runnerParams.setScope(TestUtil.isTest((DartCallExpression)psiElement) ? Scope.METHOD : Scope.GROUP);\n      final VirtualFile dartFile = virtualFiles.iterator().next();\n      final String dartFilePath = dartFile.getPath();\n      runnerParams.setFilePath(dartFilePath);\n      runnerParams.setWorkingDirectory(DartProjectTemplate.getWorkingDirForDartScript(psiElement.getProject(), dartFile));\n      return true;\n    }\n    else {\n      final PsiFile psiFile = psiElement.getContainingFile();\n      if (psiFile instanceof DartFile) {\n        final VirtualFile virtualFile = DartResolveUtil.getRealVirtualFile((DartFile)psiElement);\n        if (virtualFile == null || !DartResolveUtil.isLibraryRoot((DartFile)psiElement)) {\n          return false;\n        }\n\n        runnerParams.setTestName(DartResolveUtil.getLibraryName((DartFile)psiElement));\n        runnerParams.setScope(Scope.FILE);\n        final String dartFilePath = FileUtil.toSystemIndependentName(virtualFile.getPath());\n        runnerParams.setFilePath(dartFilePath);\n        runnerParams.setWorkingDirectory(DartProjectTemplate.getWorkingDirForDartScript(psiElement.getProject(), virtualFile));\n        return true;\n      }\n    }\n    return false;\n  }","commit_id":"4122100d80f8ef0f0c6d6250eb8b786da2c87d8b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public boolean isConfigurationFromContext(final @NotNull DartTestRunConfiguration configuration,\n                                            final @NotNull ConfigurationContext context) {\n    final PsiElement testElement = TestUtil.findTestElement(context.getPsiLocation());\n    if (testElement == null) return false;\n\n    final DartTestRunnerParameters paramsFromContext = new DartTestRunnerParameters();\n    if (!setupRunConfiguration(paramsFromContext, testElement)) return false;\n\n    final DartTestRunnerParameters existingParams = configuration.getRunnerParameters();\n\n    return Comparing.equal(existingParams.getFilePath(), paramsFromContext.getFilePath()) &&\n           Comparing.equal(existingParams.getScope(), paramsFromContext.getScope()) &&\n           (!existingParams.getScope().expectsTestName() || Comparing.equal(existingParams.getTestName(), paramsFromContext.getTestName()));\n  }","id":71254,"modified_method":"@Override\n  public boolean isConfigurationFromContext(@NotNull final DartTestRunConfiguration configuration,\n                                            @NotNull final ConfigurationContext context) {\n    final DartTestRunnerParameters existingParams = configuration.getRunnerParameters();\n    final DartTestRunnerParameters paramsFromContext = new DartTestRunnerParameters();\n\n    final PsiElement location = context.getPsiLocation();\n    if (location instanceof PsiDirectory) {\n      if (!setupRunnerParametersForFolder(paramsFromContext, ((PsiDirectory)location).getVirtualFile())) return false;\n    }\n    else {\n      final PsiElement testElement = TestUtil.findTestElement(location);\n      if (testElement == null || !setupRunnerParametersForFile(paramsFromContext, testElement)) return false;\n    }\n\n    return Comparing.equal(existingParams.getFilePath(), paramsFromContext.getFilePath()) &&\n           Comparing.equal(existingParams.getScope(), paramsFromContext.getScope()) &&\n           (!existingParams.getScope().expectsTestName() || Comparing.equal(existingParams.getTestName(), paramsFromContext.getTestName()));\n  }","commit_id":"4122100d80f8ef0f0c6d6250eb8b786da2c87d8b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected boolean setupConfigurationFromContext(final @NotNull DartTestRunConfiguration configuration,\n                                                  final @NotNull ConfigurationContext context,\n                                                  final @NotNull Ref<PsiElement> sourceElement) {\n    final VirtualFile dartFile = DartCommandLineRuntimeConfigurationProducer.getRunnableDartFileFromContext(context);\n    if (dartFile == null) return false;\n\n    final DartUrlResolver urlResolver = DartUrlResolver.getInstance(context.getProject(), dartFile);\n    final VirtualFile dartUnitLib = urlResolver.findFileByDartUrl(\"package:test/test.dart\");\n    if (dartUnitLib == null) return false;\n\n    final VirtualFile yamlFile = urlResolver.getPubspecYamlFile();\n    if (yamlFile != null) {\n      final VirtualFile parent = yamlFile.getParent();\n      final VirtualFile testFolder = parent == null ? null : parent.findChild(\"test\");\n      if (testFolder == null || !testFolder.isDirectory() || !VfsUtilCore.isAncestor(testFolder, dartFile, true)) {\n        return false;\n      }\n    }\n\n    final PsiElement testElement = TestUtil.findTestElement(context.getPsiLocation());\n    if (testElement == null || !setupRunConfiguration(configuration.getRunnerParameters(), testElement)) {\n      return false;\n    }\n\n    configuration.setGeneratedName();\n\n    sourceElement.set(testElement);\n    return true;\n  }","id":71255,"modified_method":"@Override\n  protected boolean setupConfigurationFromContext(final @NotNull DartTestRunConfiguration configuration,\n                                                  final @NotNull ConfigurationContext context,\n                                                  final @NotNull Ref<PsiElement> sourceElement) {\n    final boolean ok;\n    final PsiElement location = context.getPsiLocation();\n    if (location instanceof PsiDirectory) {\n      ok = setupRunnerParametersForFolderIfApplicable(configuration.getProject(), configuration.getRunnerParameters(),\n                                                      ((PsiDirectory)location).getVirtualFile());\n    }\n    else {\n      ok = setupRunnerParametersForFileIfApplicable(configuration.getRunnerParameters(), context, sourceElement);\n    }\n\n    if (ok) {\n      configuration.setGeneratedName();\n    }\n\n    return ok;\n  }","commit_id":"4122100d80f8ef0f0c6d6250eb8b786da2c87d8b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public static String suggestedName(String path, Scope scope, String testName) {\n    if (path != null) {\n      final String fileName = PathUtil.getFileName(path);\n      switch (scope) {\n        case METHOD:\n          return DartBundle.message(\"test.0.in.1\", testName, fileName);\n        case GROUP:\n          return DartBundle.message(\"test.group.0.in.1\", testName, fileName);\n        case FILE:\n          return DartBundle.message(\"all.tests.in.0\", fileName);\n        case FOLDER:\n          return DartBundle.message(\"all.tests.in.0\", PathUtil.getFileName(path));\n      }\n    }\n    return null;\n  }","id":71256,"modified_method":"public static String suggestedName(@Nullable final String path, @NotNull final Scope scope, @Nullable final String testName) {\n    if (path != null) {\n      final String fileOrDirName = PathUtil.getFileName(path);\n      switch (scope) {\n        case METHOD:\n          return DartBundle.message(\"test.0.in.1\", testName, fileOrDirName);\n        case GROUP:\n          return DartBundle.message(\"test.group.0.in.1\", testName, fileOrDirName);\n        case FILE:\n          return DartBundle.message(\"all.tests.in.0\", fileOrDirName);\n        case FOLDER:\n          final String dirName;\n          if (\"test\".equals(fileOrDirName)) {\n            final String parentPath = PathUtil.getParentPath(path);\n            final String parentDirName = PathUtil.getFileName(parentPath);\n            dirName = parentDirName.isEmpty() ? fileOrDirName : parentDirName + \"/\" + fileOrDirName;\n          }\n          else {\n            dirName = fileOrDirName;\n          }\n          return DartBundle.message(\"all.tests.in.0\", dirName);\n      }\n    }\n    return null;\n  }","commit_id":"4122100d80f8ef0f0c6d6250eb8b786da2c87d8b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  protected boolean setupConfigurationFromContext(DartUnitRunConfiguration configuration,\n                                                  ConfigurationContext context,\n                                                  Ref<PsiElement> sourceElement) {\n    final PsiElement element = findTestElement(context.getPsiLocation());\n    if (element == null || !setupRunConfiguration(configuration, element)) {\n      return false;\n    }\n\n    configuration.setName(\"Test: \" + configuration.getRunnerParameters().getTestName());\n    return true;\n  }","id":71257,"modified_method":"@Override\n  protected boolean setupConfigurationFromContext(DartUnitRunConfiguration configuration,\n                                                  ConfigurationContext context,\n                                                  Ref<PsiElement> sourceElement) {\n    final PsiElement contextElement = context.getPsiLocation();\n    final VirtualFile file = contextElement == null ? null : contextElement.getContainingFile().getVirtualFile();\n    final VirtualFile packagesFolder = file == null ? null : DartResolveUtil.getDartPackagesFolder(context.getProject(), file);\n    if (packagesFolder == null || packagesFolder.findChild(\"unittest\") == null) return false;\n\n    final PsiElement element = findTestElement(contextElement);\n    if (element == null || !setupRunConfiguration(configuration, element)) {\n      return false;\n    }\n\n    configuration.setName(\"Test: \" + configuration.getRunnerParameters().getTestName());\n    return true;\n  }","commit_id":"5e7ed83b8c216a7db432cc1f5d4d00b4b00add0b","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@Override\n  public void navigateInPreviewEditor(PreviewEditorState editorState) {\n    myEditorState = editorState;\n\n    final VirtualFile file = editorState.getFile();\n    final LogicalPosition positionToNavigate = editorState.getNavigate();\n    final TextAttributes lineAttributes = editorState.getAttributes();\n    Document document = FileDocumentManager.getInstance().getDocument(file);\n    Project project = myProject;\n\n    clearEditor();\n    remove(myLabel);\n    if (document != null) {\n      if (getEditor() == null || getEditor().getDocument() != document) {\n        setEditor(EditorFactory.getInstance().createViewer(document, project));\n\n        final EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n\n        EditorHighlighter highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(file, scheme, project);\n\n        ((EditorEx)getEditor()).setFile(file);\n        ((EditorEx)getEditor()).setHighlighter(highlighter);\n\n        getEditor().getSettings().setAnimatedScrolling(false);\n        getEditor().getSettings().setRefrainFromScrolling(false);\n        getEditor().getSettings().setLineNumbersShown(true);\n        getEditor().getSettings().setFoldingOutlineShown(false);\n\n        add(getEditor().getComponent(), BorderLayout.CENTER);\n      }\n\n      getEditor().getCaretModel().moveToLogicalPosition(positionToNavigate);\n      validate();\n      getEditor().getScrollingModel().scrollToCaret(ScrollType.CENTER);\n\n      getEditor().setBorder(IdeBorderFactory.createBorder(SideBorder.TOP));\n\n      clearHightlighting();\n      if (lineAttributes != null) {\n        myHighlighter = getEditor().getMarkupModel().addLineHighlighter(positionToNavigate.line, HighlighterLayer.SELECTION - 1,\n                                                                        lineAttributes);\n      }\n    }\n    else {\n      myLabel.setText(\"Navigate to selected \" + (file.isDirectory() ? \"directory \" : \"file \") + \"in Project View\");\n      add(myLabel, BorderLayout.CENTER);\n      validate();\n    }\n  }","id":71258,"modified_method":"@Override\n  public void navigateInPreviewEditor(PreviewEditorState editorState) {\n    myEditorState = editorState;\n\n    final VirtualFile file = editorState.getFile();\n    final LogicalPosition positionToNavigate = editorState.getNavigate();\n    final TextAttributes lineAttributes = editorState.getAttributes();\n    Document document = FileDocumentManager.getInstance().getDocument(file);\n    Project project = myProject;\n\n    clearEditor();\n    remove(myLabel);\n    if (document != null) {\n      if (getEditor() == null || getEditor().getDocument() != document) {\n        setEditor(EditorFactory.getInstance().createViewer(document, project));\n\n        final EditorColorsScheme scheme = EditorColorsManager.getInstance().getGlobalScheme();\n\n        EditorHighlighter highlighter = EditorHighlighterFactory.getInstance().createEditorHighlighter(file, scheme, project);\n\n        ((EditorEx)getEditor()).setFile(file);\n        ((EditorEx)getEditor()).setHighlighter(highlighter);\n\n        getEditor().getSettings().setAnimatedScrolling(false);\n        getEditor().getSettings().setRefrainFromScrolling(false);\n        getEditor().getSettings().setLineNumbersShown(true);\n        getEditor().getSettings().setFoldingOutlineShown(false);\n\n        add(getEditor().getComponent(), BorderLayout.CENTER);\n      }\n\n      if (positionToNavigate != null) {\n        getEditor().getCaretModel().moveToLogicalPosition(positionToNavigate);\n        validate();\n        getEditor().getScrollingModel().scrollToCaret(ScrollType.CENTER);\n      }\n\n      getEditor().setBorder(IdeBorderFactory.createBorder(SideBorder.TOP));\n\n      clearHightlighting();\n      if (lineAttributes != null && positionToNavigate != null) {\n        myHighlighter = getEditor().getMarkupModel().addLineHighlighter(positionToNavigate.line, HighlighterLayer.SELECTION - 1,\n                                                                        lineAttributes);\n      }\n    }\n    else {\n      myLabel.setText(\"Navigate to selected \" + (file.isDirectory() ? \"directory \" : \"file \") + \"in Project View\");\n      add(myLabel, BorderLayout.CENTER);\n      validate();\n    }\n  }","commit_id":"32a0e7c560ae22f3d8028ce875bf84da20ed290e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static Couple<Map<VcsRevisionNumber, Color>> computeBgColors(@NotNull FileAnnotation fileAnnotation, @NotNull Editor editor) {\n    Map<VcsRevisionNumber, Color> commitOrderColors = new HashMap<>();\n    Map<VcsRevisionNumber, Color> commitAuthorColors = new HashMap<>();\n\n    EditorColorsScheme colorScheme = editor.getColorsScheme();\n    AnnotationsSettings settings = AnnotationsSettings.getInstance();\n    List<Color> authorsColorPalette = settings.getAuthorsColors(colorScheme);\n    List<Color> orderedColorPalette = settings.getOrderedColors(colorScheme);\n\n    FileAnnotation.AuthorsMappingProvider authorsMappingProvider = fileAnnotation.getAuthorsMappingProvider();\n    if (authorsMappingProvider != null) {\n      Map<VcsRevisionNumber, String> authorsMap = authorsMappingProvider.getAuthors();\n\n      Map<String, Color> authorColors = new HashMap<>();\n      for (String author : ContainerUtil.newTreeSet(authorsMap.values())) {\n        int index = authorColors.size();\n        Color color = authorsColorPalette.get(index % authorsColorPalette.size());\n        authorColors.put(author, color);\n      }\n\n      for (Map.Entry<VcsRevisionNumber, String> entry : authorsMap.entrySet()) {\n        VcsRevisionNumber revision = entry.getKey();\n        String author = entry.getValue();\n        Color color = authorColors.get(author);\n        commitAuthorColors.put(revision, color);\n      }\n    }\n\n    FileAnnotation.RevisionsOrderProvider revisionsOrderProvider = fileAnnotation.getRevisionsOrderProvider();\n    if (revisionsOrderProvider != null) {\n      List<List<VcsRevisionNumber>> orderedRevisions = revisionsOrderProvider.getOrderedRevisions();\n\n      int revisionsCount = orderedRevisions.size();\n      for (int index = 0; index < revisionsCount; index++) {\n        Color color = orderedColorPalette.get(orderedColorPalette.size() * index / revisionsCount);\n\n        for (VcsRevisionNumber number : orderedRevisions.get(index)) {\n          commitOrderColors.put(number, color);\n        }\n      }\n    }\n\n    return Couple.of(commitOrderColors.size() > 1 ? commitOrderColors : null,\n                     commitAuthorColors.size() > 1 ? commitAuthorColors : null);\n  }","id":71259,"modified_method":"@Nullable\n  private static Couple<Map<VcsRevisionNumber, Color>> computeBgColors(@NotNull FileAnnotation fileAnnotation, @NotNull Editor editor) {\n    Map<VcsRevisionNumber, Color> commitOrderColors = new HashMap<>();\n    Map<VcsRevisionNumber, Color> commitAuthorColors = new HashMap<>();\n\n    EditorColorsScheme colorScheme = editor.getColorsScheme();\n    AnnotationsSettings settings = AnnotationsSettings.getInstance();\n    List<Color> authorsColorPalette = settings.getAuthorsColors(colorScheme);\n    List<Color> orderedColorPalette = settings.getOrderedColors(colorScheme);\n\n    FileAnnotation.AuthorsMappingProvider authorsMappingProvider = fileAnnotation.getAuthorsMappingProvider();\n    if (authorsMappingProvider != null) {\n      Map<VcsRevisionNumber, String> authorsMap = authorsMappingProvider.getAuthors();\n\n      Map<String, Color> authorColors = new HashMap<>();\n      for (String author : ContainerUtil.sorted(authorsMap.values(), Comparing::compare)) {\n        int index = authorColors.size();\n        Color color = authorsColorPalette.get(index % authorsColorPalette.size());\n        authorColors.put(author, color);\n      }\n\n      for (Map.Entry<VcsRevisionNumber, String> entry : authorsMap.entrySet()) {\n        VcsRevisionNumber revision = entry.getKey();\n        String author = entry.getValue();\n        Color color = authorColors.get(author);\n        commitAuthorColors.put(revision, color);\n      }\n    }\n\n    FileAnnotation.RevisionsOrderProvider revisionsOrderProvider = fileAnnotation.getRevisionsOrderProvider();\n    if (revisionsOrderProvider != null) {\n      List<List<VcsRevisionNumber>> orderedRevisions = revisionsOrderProvider.getOrderedRevisions();\n\n      int revisionsCount = orderedRevisions.size();\n      for (int index = 0; index < revisionsCount; index++) {\n        Color color = orderedColorPalette.get(orderedColorPalette.size() * index / revisionsCount);\n\n        for (VcsRevisionNumber number : orderedRevisions.get(index)) {\n          commitOrderColors.put(number, color);\n        }\n      }\n    }\n\n    return Couple.of(commitOrderColors.size() > 1 ? commitOrderColors : null,\n                     commitAuthorColors.size() > 1 ? commitAuthorColors : null);\n  }","commit_id":"3755a6b963f4a57837669301aa9f068977ad0394","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static AuthorsMappingProvider createDefaultAuthorsMappingProvider(@NotNull FileAnnotation annotation) {\n    List<VcsFileRevision> revisions = annotation.getRevisions();\n    if (revisions == null) return null;\n\n    Map<VcsRevisionNumber, String> authorsMapping = new HashMap<>();\n    for (VcsFileRevision revision : revisions) {\n      authorsMapping.put(revision.getRevisionNumber(), revision.getAuthor());\n    }\n\n    return () -> authorsMapping;\n  }","id":71260,"modified_method":"@Nullable\n  private static AuthorsMappingProvider createDefaultAuthorsMappingProvider(@NotNull FileAnnotation annotation) {\n    List<VcsFileRevision> revisions = annotation.getRevisions();\n    if (revisions == null) return null;\n\n    Map<VcsRevisionNumber, String> authorsMapping = new HashMap<>();\n    for (VcsFileRevision revision : revisions) {\n      String author = revision.getAuthor();\n      if (author != null) authorsMapping.put(revision.getRevisionNumber(), author);\n    }\n\n    return () -> authorsMapping;\n  }","commit_id":"3755a6b963f4a57837669301aa9f068977ad0394","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void persistSource(ComputeFileSourceData.Data fileSourceData, String componentUuid,\n      @Nullable BatchReport.Changesets.Changeset latestChange) {\n      DbFileSources.Data fileData = fileSourceData.getFileSourceData();\n\n      byte[] data = FileSourceDto.encodeSourceData(fileData);\n      String dataHash = DigestUtils.md5Hex(data);\n      String srcHash = fileSourceData.getSrcHash();\n      String lineHashes = fileSourceData.getLineHashes();\n      FileSourceDto previousDto = previousFileSourcesByUuid.get(componentUuid);\n\n      if (previousDto == null) {\n        FileSourceDto dto = new FileSourceDto()\n          .setProjectUuid(projectUuid)\n          .setFileUuid(componentUuid)\n          .setDataType(Type.SOURCE)\n          .setBinaryData(data)\n          .setSrcHash(srcHash)\n          .setDataHash(dataHash)\n          .setLineHashes(lineHashes)\n          .setCreatedAt(system2.now())\n          .setUpdatedAt(system2.now())\n          .setRevision(computeRevision(latestChange));\n        dbClient.fileSourceDao().insert(session, dto);\n        session.commit();\n      } else {\n        // Update only if data_hash has changed or if src_hash is missing (progressive migration)\n        boolean binaryDataUpdated = !dataHash.equals(previousDto.getDataHash());\n        boolean srcHashUpdated = !srcHash.equals(previousDto.getSrcHash());\n        if (binaryDataUpdated || srcHashUpdated) {\n          previousDto\n            .setBinaryData(data)\n            .setDataHash(dataHash)\n            .setSrcHash(srcHash)\n            .setLineHashes(lineHashes)\n            .setRevision(computeRevision(previousDto, latestChange))\n            .setUpdatedAt(system2.now());\n          dbClient.fileSourceDao().update(previousDto);\n          session.commit();\n        }\n      }\n    }","id":71261,"modified_method":"private void persistSource(ComputeFileSourceData.Data fileSourceData, String componentUuid,\n      @Nullable Changeset latestChange) {\n      DbFileSources.Data fileData = fileSourceData.getFileSourceData();\n\n      byte[] data = FileSourceDto.encodeSourceData(fileData);\n      String dataHash = DigestUtils.md5Hex(data);\n      String srcHash = fileSourceData.getSrcHash();\n      String lineHashes = fileSourceData.getLineHashes();\n      FileSourceDto previousDto = previousFileSourcesByUuid.get(componentUuid);\n\n      if (previousDto == null) {\n        FileSourceDto dto = new FileSourceDto()\n          .setProjectUuid(projectUuid)\n          .setFileUuid(componentUuid)\n          .setDataType(Type.SOURCE)\n          .setBinaryData(data)\n          .setSrcHash(srcHash)\n          .setDataHash(dataHash)\n          .setLineHashes(lineHashes)\n          .setCreatedAt(system2.now())\n          .setUpdatedAt(system2.now())\n          .setRevision(computeRevision(latestChange));\n        dbClient.fileSourceDao().insert(session, dto);\n        session.commit();\n      } else {\n        // Update only if data_hash has changed or if src_hash is missing (progressive migration)\n        boolean binaryDataUpdated = !dataHash.equals(previousDto.getDataHash());\n        boolean srcHashUpdated = !srcHash.equals(previousDto.getSrcHash());\n        if (binaryDataUpdated || srcHashUpdated) {\n          previousDto\n            .setBinaryData(data)\n            .setDataHash(dataHash)\n            .setSrcHash(srcHash)\n            .setLineHashes(lineHashes)\n            .setRevision(computeRevision(previousDto, latestChange))\n            .setUpdatedAt(system2.now());\n          dbClient.fileSourceDao().update(previousDto);\n          session.commit();\n        }\n      }\n    }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  private static String computeRevision(FileSourceDto previousDto, @Nullable BatchReport.Changesets.Changeset latestChange) {\n    if (latestChange == null) {\n      return previousDto.getRevision();\n    }\n    return latestChange.getRevision();\n  }","id":71262,"modified_method":"@CheckForNull\n  private static String computeRevision(FileSourceDto previousDto, @Nullable Changeset latestChange) {\n    if (latestChange == null) {\n      return previousDto.getRevision();\n    }\n    return latestChange.getRevision();\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public PersistFileSourcesStep(DbClient dbClient, System2 system2, TreeRootHolder treeRootHolder, BatchReportReader reportReader, SourceLinesRepository sourceLinesRepository) {\n    this.dbClient = dbClient;\n    this.system2 = system2;\n    this.treeRootHolder = treeRootHolder;\n    this.reportReader = reportReader;\n    this.sourceLinesRepository = sourceLinesRepository;\n  }","id":71263,"modified_method":"public PersistFileSourcesStep(DbClient dbClient, System2 system2, TreeRootHolder treeRootHolder, BatchReportReader reportReader, SourceLinesRepository sourceLinesRepository,\n    ScmInfoRepository scmInfoRepository) {\n    this.dbClient = dbClient;\n    this.system2 = system2;\n    this.treeRootHolder = treeRootHolder;\n    this.reportReader = reportReader;\n    this.sourceLinesRepository = sourceLinesRepository;\n    this.scmInfoRepository = scmInfoRepository;\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void visitFile(Component file) {\n      int fileRef = file.getReportAttributes().getRef();\n      BatchReport.Component component = reportReader.readComponent(fileRef);\n      CloseableIterator<String> linesIterator = sourceLinesRepository.readLines(file);\n      LineReaders lineReaders = new LineReaders(reportReader, fileRef);\n      try {\n        ComputeFileSourceData computeFileSourceData = new ComputeFileSourceData(linesIterator, lineReaders.readers(), component.getLines());\n        ComputeFileSourceData.Data fileSourceData = computeFileSourceData.compute();\n        persistSource(fileSourceData, file.getUuid(), lineReaders.getLatestChange());\n      } catch (Exception e) {\n        throw new IllegalStateException(String.format(\"Cannot persist sources of %s\", file.getKey()), e);\n      } finally {\n        linesIterator.close();\n        lineReaders.close();\n      }\n    }","id":71264,"modified_method":"@Override\n    public void visitFile(Component file) {\n      int fileRef = file.getReportAttributes().getRef();\n      BatchReport.Component component = reportReader.readComponent(fileRef);\n      CloseableIterator<String> linesIterator = sourceLinesRepository.readLines(file);\n      LineReaders lineReaders = new LineReaders(reportReader, scmInfoRepository, file);\n      try {\n        ComputeFileSourceData computeFileSourceData = new ComputeFileSourceData(linesIterator, lineReaders.readers(), component.getLines());\n        ComputeFileSourceData.Data fileSourceData = computeFileSourceData.compute();\n        persistSource(fileSourceData, file.getUuid(), lineReaders.getLatestChange());\n      } catch (Exception e) {\n        throw new IllegalStateException(String.format(\"Cannot persist sources of %s\", file.getKey()), e);\n      } finally {\n        linesIterator.close();\n        lineReaders.close();\n      }\n    }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  private static String computeRevision(@Nullable BatchReport.Changesets.Changeset latestChange) {\n    if (latestChange == null) {\n      return null;\n    }\n    return latestChange.getRevision();\n  }","id":71265,"modified_method":"@CheckForNull\n  private static String computeRevision(@Nullable Changeset latestChange) {\n    if (latestChange == null) {\n      return null;\n    }\n    return latestChange.getRevision();\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"LineReaders(BatchReportReader reportReader, int componentRef) {\n      CloseableIterator<BatchReport.Coverage> coverageIt = reportReader.readComponentCoverage(componentRef);\n      closeables.add(coverageIt);\n      readers.add(new CoverageLineReader(coverageIt));\n\n      BatchReport.Changesets scmReport = reportReader.readChangesets(componentRef);\n      if (scmReport != null) {\n        this.scmLineReader = new ScmLineReader(scmReport);\n        readers.add(scmLineReader);\n      } else {\n        this.scmLineReader = null;\n      }\n\n      CloseableIterator<BatchReport.SyntaxHighlighting> highlightingIt = reportReader.readComponentSyntaxHighlighting(componentRef);\n      closeables.add(highlightingIt);\n      readers.add(new HighlightingLineReader(highlightingIt));\n\n      CloseableIterator<BatchReport.Symbol> symbolsIt = reportReader.readComponentSymbols(componentRef);\n      closeables.add(symbolsIt);\n      readers.add(new SymbolsLineReader(symbolsIt));\n\n      CloseableIterator<BatchReport.Duplication> duplicationsIt = reportReader.readComponentDuplications(componentRef);\n      closeables.add(duplicationsIt);\n      readers.add(new DuplicationLineReader(duplicationsIt));\n    }","id":71266,"modified_method":"LineReaders(BatchReportReader reportReader, ScmInfoRepository scmInfoRepository, Component component) {\n      int componentRef = component.getReportAttributes().getRef();\n      CloseableIterator<BatchReport.Coverage> coverageIt = reportReader.readComponentCoverage(componentRef);\n      closeables.add(coverageIt);\n      readers.add(new CoverageLineReader(coverageIt));\n\n      Optional<ScmInfo> scmInfoOptional = scmInfoRepository.getScmInfo(component);\n      if (scmInfoOptional.isPresent()) {\n        this.scmLineReader = new ScmLineReader(scmInfoOptional.get());\n        readers.add(scmLineReader);\n      } else {\n        this.scmLineReader = null;\n      }\n\n      CloseableIterator<BatchReport.SyntaxHighlighting> highlightingIt = reportReader.readComponentSyntaxHighlighting(componentRef);\n      closeables.add(highlightingIt);\n      readers.add(new HighlightingLineReader(highlightingIt));\n\n      CloseableIterator<BatchReport.Symbol> symbolsIt = reportReader.readComponentSymbols(componentRef);\n      closeables.add(symbolsIt);\n      readers.add(new SymbolsLineReader(symbolsIt));\n\n      CloseableIterator<BatchReport.Duplication> duplicationsIt = reportReader.readComponentDuplications(componentRef);\n      closeables.add(duplicationsIt);\n      readers.add(new DuplicationLineReader(duplicationsIt));\n    }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void persistFileSources(File reportDir) {\n    LOGGER.info(\"Persist file sources\");\n    DbClient dbClient = dbTester.getDbClient();\n\n    long start = System.currentTimeMillis();\n\n    BatchReportDirectoryHolderImpl batchReportDirectoryHolder = new BatchReportDirectoryHolderImpl();\n    batchReportDirectoryHolder.setDirectory(reportDir);\n    org.sonar.server.computation.batch.BatchReportReader batchReportReader = new BatchReportReaderImpl(batchReportDirectoryHolder);\n    PersistFileSourcesStep step = new PersistFileSourcesStep(dbClient, System2.INSTANCE, treeRootHolder, batchReportReader, new SourceLinesRepositoryImpl(batchReportReader));\n    step.execute();\n\n    long end = System.currentTimeMillis();\n    long duration = end - start;\n\n    assertThat(dbTester.countRowsOfTable(\"file_sources\")).isEqualTo(NUMBER_OF_FILES);\n    LOGGER.info(String.format(\"File sources has been persisted in %d ms\", duration));\n\n    benchmark.expectAround(\"Duration to persist FILE_SOURCES\", duration, 125000, Benchmark.DEFAULT_ERROR_MARGIN_PERCENTS);\n  }","id":71267,"modified_method":"private void persistFileSources(File reportDir) {\n    LOGGER.info(\"Persist file sources\");\n    DbClient dbClient = dbTester.getDbClient();\n\n    long start = System.currentTimeMillis();\n\n    BatchReportDirectoryHolderImpl batchReportDirectoryHolder = new BatchReportDirectoryHolderImpl();\n    batchReportDirectoryHolder.setDirectory(reportDir);\n    org.sonar.server.computation.batch.BatchReportReader batchReportReader = new BatchReportReaderImpl(batchReportDirectoryHolder);\n    SourceService sourceService = new SourceService(dbClient, null);\n    ScmInfoRepositoryImpl scmInfoRepository = new ScmInfoRepositoryImpl(batchReportReader, dbClient, sourceService);\n    PersistFileSourcesStep step = new PersistFileSourcesStep(dbClient, System2.INSTANCE, treeRootHolder, batchReportReader,\n      new SourceLinesRepositoryImpl(batchReportReader), scmInfoRepository);\n    step.execute();\n\n    long end = System.currentTimeMillis();\n    long duration = end - start;\n\n    assertThat(dbTester.countRowsOfTable(\"file_sources\")).isEqualTo(NUMBER_OF_FILES);\n    LOGGER.info(String.format(\"File sources has been persisted in %d ms\", duration));\n\n    benchmark.expectAround(\"Duration to persist FILE_SOURCES\", duration, 125000, Benchmark.DEFAULT_ERROR_MARGIN_PERCENTS);\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setup() {\n    dbTester.truncateTables();\n    when(system2.now()).thenReturn(now);\n    underTest = new PersistFileSourcesStep(dbClient, system2, treeRootHolder, reportReader, fileSourceRepository);\n  }","id":71268,"modified_method":"@Before\n  public void setup() {\n    dbTester.truncateTables();\n    when(system2.now()).thenReturn(now);\n    underTest = new PersistFileSourcesStep(dbClient, system2, treeRootHolder, reportReader, fileSourceRepository, scmInfoRepository);\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void persist_scm() {\n    initBasicReport(1);\n\n    reportReader.putChangesets(BatchReport.Changesets.newBuilder()\n      .setComponentRef(FILE_REF)\n      .addChangeset(BatchReport.Changesets.Changeset.newBuilder()\n        .setAuthor(\"john\")\n        .setDate(123456789L)\n        .setRevision(\"rev-1\")\n        .build())\n      .addChangesetIndexByLine(0)\n      .build());\n\n    underTest.execute();\n\n    assertThat(dbTester.countRowsOfTable(\"file_sources\")).isEqualTo(1);\n    FileSourceDto fileSourceDto = dbClient.fileSourceDao().selectSourceByFileUuid(session, FILE_UUID);\n\n    assertThat(fileSourceDto.getRevision()).isEqualTo(\"rev-1\");\n\n    DbFileSources.Data data = FileSourceDto.decodeSourceData(fileSourceDto.getBinaryData());\n\n    assertThat(data.getLinesList()).hasSize(1);\n\n    assertThat(data.getLines(0).getScmAuthor()).isEqualTo(\"john\");\n    assertThat(data.getLines(0).getScmDate()).isEqualTo(123456789L);\n    assertThat(data.getLines(0).getScmRevision()).isEqualTo(\"rev-1\");\n  }","id":71269,"modified_method":"@Test\n  public void persist_scm() {\n    initBasicReport(1);\n    scmInfoRepository.setScmInfo(FILE_REF, Changeset.newChangesetBuilder()\n      .setAuthor(\"john\")\n      .setDate(123456789L)\n      .setRevision(\"rev-1\")\n      .build());\n\n    underTest.execute();\n\n    assertThat(dbTester.countRowsOfTable(\"file_sources\")).isEqualTo(1);\n    FileSourceDto fileSourceDto = dbClient.fileSourceDao().selectSourceByFileUuid(session, FILE_UUID);\n\n    assertThat(fileSourceDto.getRevision()).isEqualTo(\"rev-1\");\n\n    DbFileSources.Data data = FileSourceDto.decodeSourceData(fileSourceDto.getBinaryData());\n\n    assertThat(data.getLinesList()).hasSize(1);\n\n    assertThat(data.getLines(0).getScmAuthor()).isEqualTo(\"john\");\n    assertThat(data.getLines(0).getScmDate()).isEqualTo(123456789L);\n    assertThat(data.getLines(0).getScmRevision()).isEqualTo(\"rev-1\");\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void update_sources_when_source_updated() {\n    // Existing sources\n    long past = 150000L;\n    dbClient.fileSourceDao().insert(dbTester.getSession(), new FileSourceDto()\n      .setProjectUuid(PROJECT_UUID)\n      .setFileUuid(FILE_UUID)\n      .setDataType(Type.SOURCE)\n      .setSrcHash(\"5b4bd9815cdb17b8ceae19eb1810c34c\")\n      .setLineHashes(\"6438c669e0d0de98e6929c2cc0fac474\\n\")\n      .setDataHash(\"6cad150e3d065976c230cddc5a09efaa\")\n      .setSourceData(DbFileSources.Data.newBuilder()\n        .addLines(DbFileSources.Line.newBuilder()\n          .setLine(1)\n          .setSource(\"old line\")\n          .build())\n        .build())\n      .setCreatedAt(past)\n      .setUpdatedAt(past)\n      .setRevision(\"rev-0\"));\n    dbTester.getSession().commit();\n\n    initBasicReport(1);\n\n    reportReader.putChangesets(BatchReport.Changesets.newBuilder()\n        .setComponentRef(FILE_REF)\n        .addChangeset(BatchReport.Changesets.Changeset.newBuilder()\n            .setAuthor(\"john\")\n            .setDate(123456789L)\n            .setRevision(\"rev-1\")\n            .build())\n        .addChangesetIndexByLine(0)\n        .build());\n\n    underTest.execute();\n\n    assertThat(dbTester.countRowsOfTable(\"file_sources\")).isEqualTo(1);\n    FileSourceDto fileSourceDto = dbClient.fileSourceDao().selectSourceByFileUuid(session, FILE_UUID);\n    assertThat(fileSourceDto.getCreatedAt()).isEqualTo(past);\n    assertThat(fileSourceDto.getUpdatedAt()).isEqualTo(now);\n    assertThat(fileSourceDto.getRevision()).isEqualTo(\"rev-1\");\n  }","id":71270,"modified_method":"@Test\n  public void update_sources_when_source_updated() {\n    // Existing sources\n    long past = 150000L;\n    dbClient.fileSourceDao().insert(dbTester.getSession(), new FileSourceDto()\n      .setProjectUuid(PROJECT_UUID)\n      .setFileUuid(FILE_UUID)\n      .setDataType(Type.SOURCE)\n      .setSrcHash(\"5b4bd9815cdb17b8ceae19eb1810c34c\")\n      .setLineHashes(\"6438c669e0d0de98e6929c2cc0fac474\\n\")\n      .setDataHash(\"6cad150e3d065976c230cddc5a09efaa\")\n      .setSourceData(DbFileSources.Data.newBuilder()\n        .addLines(DbFileSources.Line.newBuilder()\n          .setLine(1)\n          .setSource(\"old line\")\n          .build())\n        .build())\n      .setCreatedAt(past)\n      .setUpdatedAt(past)\n      .setRevision(\"rev-0\"));\n    dbTester.getSession().commit();\n\n    initBasicReport(1);\n\n    scmInfoRepository.setScmInfo(FILE_REF, Changeset.newChangesetBuilder()\n      .setAuthor(\"john\")\n      .setDate(123456789L)\n      .setRevision(\"rev-1\")\n      .build());\n\n\n    underTest.execute();\n\n    assertThat(dbTester.countRowsOfTable(\"file_sources\")).isEqualTo(1);\n    FileSourceDto fileSourceDto = dbClient.fileSourceDao().selectSourceByFileUuid(session, FILE_UUID);\n    assertThat(fileSourceDto.getCreatedAt()).isEqualTo(past);\n    assertThat(fileSourceDto.getUpdatedAt()).isEqualTo(now);\n    assertThat(fileSourceDto.getRevision()).isEqualTo(\"rev-1\");\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void updateLatestChange(BatchReport.Changesets.Changeset newChangeSet) {\n    if (this.latestChange == null) {\n      this.latestChange = newChangeSet;\n    } else if (newChangeSet.hasDate() && this.latestChange.hasDate()\n      && newChangeSet.getDate() > this.latestChange.getDate()) {\n      this.latestChange = newChangeSet;\n    }\n  }","id":71271,"modified_method":"private void updateLatestChange(Changeset newChangeSet) {\n    if (latestChange == null) {\n      latestChange = newChangeSet;\n    } else {\n      long newChangesetDate = newChangeSet.getDate();\n      long latestChangeDate = latestChange.getDate();\n      if (newChangesetDate > latestChangeDate) {\n        latestChange = newChangeSet;\n      }\n    }\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void read(DbFileSources.Line.Builder lineBuilder) {\n    int changeSetIndex = scmReport.getChangesetIndexByLine(lineBuilder.getLine() - 1);\n    BatchReport.Changesets.Changeset changeset = scmReport.getChangeset(changeSetIndex);\n    boolean hasAuthor = changeset.hasAuthor();\n    if (hasAuthor) {\n      lineBuilder.setScmAuthor(changeset.getAuthor());\n    }\n    boolean hasRevision = changeset.hasRevision();\n    if (hasRevision) {\n      lineBuilder.setScmRevision(changeset.getRevision());\n    }\n    boolean hasDate = changeset.hasDate();\n    if (hasDate) {\n      lineBuilder.setScmDate(changeset.getDate());\n    }\n\n    checkArgument(\n      hasAuthor || hasRevision || hasDate,\n      \"A changeset must contain at least one of : author, revision or date\");\n    updateLatestChange(changeset);\n  }","id":71272,"modified_method":"@Override\n  public void read(DbFileSources.Line.Builder lineBuilder) {\n    Changeset changeset = scmReport.getChangesetForLine(lineBuilder.getLine());\n    String author = changeset.getAuthor();\n    if (author != null) {\n      lineBuilder.setScmAuthor(author);\n    }\n    lineBuilder.setScmRevision(changeset.getRevision());\n    lineBuilder.setScmDate(changeset.getDate());\n    updateLatestChange(changeset);\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void set_scm() {\n    BatchReport.Changesets scmReport = BatchReport.Changesets.newBuilder()\n      .addChangeset(newChangeSetBuilder()\n        .setAuthor(\"john\")\n        .setDate(123456789L)\n        .setRevision(\"rev-1\")\n        .build())\n      .addChangesetIndexByLine(0)\n      .build();\n\n    ScmLineReader lineScm = new ScmLineReader(scmReport);\n\n    DbFileSources.Line.Builder lineBuilder = DbFileSources.Data.newBuilder().addLinesBuilder().setLine(1);\n    lineScm.read(lineBuilder);\n\n    assertThat(lineBuilder.getScmAuthor()).isEqualTo(\"john\");\n    assertThat(lineBuilder.getScmDate()).isEqualTo(123456789L);\n    assertThat(lineBuilder.getScmRevision()).isEqualTo(\"rev-1\");\n  }","id":71273,"modified_method":"@Test\n  public void set_scm() {\n    ScmInfo scmInfo = new ScmInfoImpl(newArrayList(\n      Changeset.newChangesetBuilder()\n        .setAuthor(\"john\")\n        .setDate(123456789L)\n        .setRevision(\"rev-1\")\n        .build()\n      ));\n\n    ScmLineReader lineScm = new ScmLineReader(scmInfo);\n\n    DbFileSources.Line.Builder lineBuilder = DbFileSources.Data.newBuilder().addLinesBuilder().setLine(1);\n    lineScm.read(lineBuilder);\n\n    assertThat(lineBuilder.getScmAuthor()).isEqualTo(\"john\");\n    assertThat(lineBuilder.getScmDate()).isEqualTo(123456789L);\n    assertThat(lineBuilder.getScmRevision()).isEqualTo(\"rev-1\");\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void getLatestChange_returns_changeset_with_highest_date_of_read_lines() {\n    long refDate = 123456789L;\n    BatchReport.Changesets.Changeset changeset0 = newChangeSetBuilder().setDate(refDate - 636).build();\n    BatchReport.Changesets.Changeset changeset1 = newChangeSetBuilder().setDate(refDate + 1).build();\n    BatchReport.Changesets.Changeset changeset2 = newChangeSetBuilder().setDate(refDate + 2).build();\n    BatchReport.Changesets scmReport = setup8LinesChangeset(changeset0, changeset1, changeset2);\n\n    ScmLineReader lineScm = new ScmLineReader(scmReport);\n\n    // before any line is read, the latest change is null\n    assertThat(lineScm.getLatestChange()).isNull();\n\n    // read line 1, only one changeset => 0\n    readLineAndAssertLatestChangeDate(lineScm, 1, changeset0);\n\n    // read line 2, latest changeset is 1\n    readLineAndAssertLatestChangeDate(lineScm, 2, changeset1);\n\n    // read line 3, latest changeset is still 1\n    readLineAndAssertLatestChangeDate(lineScm, 3, changeset1);\n\n    // read line 4, latest changeset is now 2\n    readLineAndAssertLatestChangeDate(lineScm, 4, changeset2);\n\n    // read line 5 to 8, there will never be any changeset more recent than 2\n    readLineAndAssertLatestChangeDate(lineScm, 5, changeset2);\n    readLineAndAssertLatestChangeDate(lineScm, 6, changeset2);\n    readLineAndAssertLatestChangeDate(lineScm, 7, changeset2);\n    readLineAndAssertLatestChangeDate(lineScm, 8, changeset2);\n  }","id":71274,"modified_method":"@Test\n  public void getLatestChange_returns_changeset_with_highest_date_of_read_lines() {\n    long refDate = 123456789L;\n    Changeset changeset0 = Changeset.newChangesetBuilder().setDate(refDate - 636).setRevision(\"rev-1\").build();\n    Changeset changeset1 = Changeset.newChangesetBuilder().setDate(refDate + 1).setRevision(\"rev-2\").build();\n    Changeset changeset2 = Changeset.newChangesetBuilder().setDate(refDate + 2).setRevision(\"rev-3\").build();\n    ScmInfo scmInfo = new ScmInfoImpl(setup8LinesChangeset(changeset0, changeset1, changeset2));\n\n    ScmLineReader lineScm = new ScmLineReader(scmInfo);\n\n    // before any line is read, the latest change is null\n    assertThat(lineScm.getLatestChange()).isNull();\n\n    // read line 1, only one changeset => 0\n    readLineAndAssertLatestChangeDate(lineScm, 1, changeset0);\n\n    // read line 2, latest changeset is 1\n    readLineAndAssertLatestChangeDate(lineScm, 2, changeset1);\n\n    // read line 3, latest changeset is still 1\n    readLineAndAssertLatestChangeDate(lineScm, 3, changeset1);\n\n    // read line 4, latest changeset is now 2\n    readLineAndAssertLatestChangeDate(lineScm, 4, changeset2);\n\n    // read line 5 to 8, there will never be any changeset more recent than 2\n    readLineAndAssertLatestChangeDate(lineScm, 5, changeset2);\n    readLineAndAssertLatestChangeDate(lineScm, 6, changeset2);\n    readLineAndAssertLatestChangeDate(lineScm, 7, changeset2);\n    readLineAndAssertLatestChangeDate(lineScm, 8, changeset2);\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void readLineAndAssertLatestChangeDate(ScmLineReader lineScm, int line, BatchReport.Changesets.Changeset expectedChangeset) {\n    DbFileSources.Line.Builder lineBuilder = DbFileSources.Data.newBuilder().addLinesBuilder().setLine(line);\n    lineScm.read(lineBuilder);\n    assertThat(lineScm.getLatestChange()).isSameAs(expectedChangeset);\n  }","id":71275,"modified_method":"private void readLineAndAssertLatestChangeDate(ScmLineReader lineScm, int line, Changeset expectedChangeset) {\n    DbFileSources.Line.Builder lineBuilder = DbFileSources.Data.newBuilder().addLinesBuilder().setLine(line);\n    lineScm.read(lineBuilder);\n    assertThat(lineScm.getLatestChange()).isSameAs(expectedChangeset);\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static BatchReport.Changesets setup8LinesChangeset(BatchReport.Changesets.Changeset changeset0,\n    BatchReport.Changesets.Changeset changeset1,\n    BatchReport.Changesets.Changeset changeset2) {\n    return BatchReport.Changesets.newBuilder()\n      .addChangeset(changeset0)\n      .addChangeset(changeset1)\n      .addChangeset(changeset2)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(1)\n      .addChangesetIndexByLine(1)\n      .addChangesetIndexByLine(2)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(1)\n      .addChangesetIndexByLine(0)\n      .addChangesetIndexByLine(0)\n      .build();\n  }","id":71276,"modified_method":"private static List<Changeset> setup8LinesChangeset(Changeset changeset0, Changeset changeset1, Changeset changeset2) {\n    return ImmutableList.of(changeset0, changeset1, changeset1, changeset2, changeset0, changeset1, changeset0, changeset0);\n  }","commit_id":"29eab470eb9886f3474d724a0c2f7dcdc7c2d5d1","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void addRange(Range range)\n    {\n        NativeRangeWrapper wrapper = (NativeRangeWrapper) range;\n        if (wrapper.getNativeRange() == null) {\n            Document doc = (Document) range.getStartContainer().getOwnerDocument();\n            wrapper.setNativeRange(NativeRange.newInstance(doc));\n        }\n        NativeRange nativeRange = wrapper.getNativeRange().cast();\n        nativeRange.setStart(range.getStartContainer(), range.getStartOffset());\n        nativeRange.setEnd(range.getEndContainer(), range.getEndOffset());\n        getNativeSelection().addRange(nativeRange);\n        DOMUtils.getInstance().scrollIntoView(range);\n    }","id":71277,"modified_method":"@Override\n    public void addRange(Range range)\n    {\n        NativeSelection selection = getNativeSelection();\n        if (selection != null) {\n            NativeRangeWrapper wrapper = (NativeRangeWrapper) range;\n            if (wrapper.getNativeRange() == null) {\n                Document doc = (Document) range.getStartContainer().getOwnerDocument();\n                wrapper.setNativeRange(NativeRange.newInstance(doc));\n            }\n            NativeRange nativeRange = wrapper.getNativeRange().cast();\n            nativeRange.setStart(range.getStartContainer(), range.getStartOffset());\n            nativeRange.setEnd(range.getEndContainer(), range.getEndOffset());\n            selection.addRange(nativeRange);\n            DOMUtils.getInstance().scrollIntoView(range);\n        }\n    }","commit_id":"9b97c6d3d8c033423bd369229e64d6abad68bb3e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void removeRange(Range range)\n    {\n        NativeRangeWrapper wrapper = (NativeRangeWrapper) range;\n        getNativeSelection().removeRange((NativeRange) wrapper.getNativeRange());\n    }","id":71278,"modified_method":"@Override\n    public void removeRange(Range range)\n    {\n        NativeSelection selection = getNativeSelection();\n        if (selection != null) {\n            NativeRangeWrapper wrapper = (NativeRangeWrapper) range;\n            selection.removeRange((NativeRange) wrapper.getNativeRange());\n        }\n    }","commit_id":"9b97c6d3d8c033423bd369229e64d6abad68bb3e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public void removeAllRanges()\n    {\n        getNativeSelection().removeAllRanges();\n    }","id":71279,"modified_method":"@Override\n    public void removeAllRanges()\n    {\n        NativeSelection selection = getNativeSelection();\n        if (selection != null) {\n            selection.removeAllRanges();\n        }\n    }","commit_id":"9b97c6d3d8c033423bd369229e64d6abad68bb3e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n    public int getRangeCount()\n    {\n        return getNativeSelection().getRangeCount();\n    }","id":71280,"modified_method":"@Override\n    public int getRangeCount()\n    {\n        NativeSelection selection = getNativeSelection();\n        return selection == null ? 0 : selection.getRangeCount();\n    }","commit_id":"9b97c6d3d8c033423bd369229e64d6abad68bb3e","url":"https://github.com/xwiki/xwiki-platform"},{"original_method":"@Override\n  public void setAnchor(@Nullable final JComponent anchor) {\n    super.setAnchor(anchor);\n    myRepoAuthorLabel.setAnchor(anchor);\n    myRepoLabel.setAnchor(anchor);\n    myTokenLabel.setAnchor(anchor);\n  }","id":71281,"modified_method":"@Override\n  public void setAnchor(@Nullable final JComponent anchor) {\n    super.setAnchor(anchor);\n    myHostLabel.setAnchor(anchor);\n    myRepositoryLabel.setAnchor(anchor);\n    myTokenLabel.setAnchor(anchor);\n  }","commit_id":"f27aee3e4ac834e94391609d554f0ad0d39e836b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GithubRepositoryEditor(final Project project, final GithubRepository repository, Consumer<GithubRepository> changeListener) {\n    super(project, repository, changeListener);\n    myUserNameText.setVisible(false);\n    myUsernameLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n    myUseHttpAuthenticationCheckBox.setVisible(false);\n\n    myToken.setText(repository.getToken());\n    myRepoAuthor.setText(repository.getRepoAuthor());\n    myRepoName.setText(repository.getRepoName());\n\n    DocumentListener buttonUpdater = new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateTokenButton();\n      }\n    };\n\n    myRepoAuthor.getDocument().addDocumentListener(buttonUpdater);\n    myRepoName.getDocument().addDocumentListener(buttonUpdater);\n    myURLText.getDocument().addDocumentListener(buttonUpdater);\n\n    setAnchor(myRepoAuthorLabel);\n  }","id":71282,"modified_method":"public GithubRepositoryEditor(final Project project, final GithubRepository repository, Consumer<GithubRepository> changeListener) {\n    super(project, repository, changeListener);\n    myUrlLabel.setVisible(false);\n    myURLText.setVisible(false);\n    myUsernameLabel.setVisible(false);\n    myUserNameText.setVisible(false);\n    myPasswordLabel.setVisible(false);\n    myPasswordText.setVisible(false);\n    myUseHttpAuthenticationCheckBox.setVisible(false);\n\n    myHost.setText(repository.getUrl());\n    myRepoAuthor.setText(repository.getRepoAuthor());\n    myRepoName.setText(repository.getRepoName());\n    myToken.setText(repository.getToken());\n\n    DocumentListener buttonUpdater = new DocumentAdapter() {\n      @Override\n      protected void textChanged(DocumentEvent e) {\n        updateTokenButton();\n      }\n    };\n\n    myHost.getDocument().addDocumentListener(buttonUpdater);\n    myRepoAuthor.getDocument().addDocumentListener(buttonUpdater);\n    myRepoName.getDocument().addDocumentListener(buttonUpdater);\n    myURLText.getDocument().addDocumentListener(buttonUpdater);\n  }","commit_id":"f27aee3e4ac834e94391609d554f0ad0d39e836b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  protected JComponent createCustomPanel() {\n    myUrlLabel.setText(\"Host:\");\n\n    myRepoAuthorLabel = new JBLabel(\"Repository Owner:\", SwingConstants.RIGHT);\n    myRepoAuthor = new JTextField();\n    installListener(myRepoAuthor);\n\n    myRepoLabel = new JBLabel(\"Repository:\", SwingConstants.RIGHT);\n    myRepoName = new JTextField();\n    installListener(myRepoName);\n\n    myTokenLabel = new JBLabel(\"API Token:\", SwingConstants.RIGHT);\n    myToken = new JTextField();\n    installListener(myToken);\n    myTokenButton = new JButton(\"Create API token\");\n    myTokenButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        generateToken();\n        doApply();\n      }\n    });\n\n    JPanel myTokenPanel = new JPanel();\n    myTokenPanel.setLayout(new BorderLayout(5, 5));\n    myTokenPanel.add(myToken, BorderLayout.CENTER);\n    myTokenPanel.add(myTokenButton, BorderLayout.EAST);\n\n    return FormBuilder.createFormBuilder().setAlignLabelOnRight(true).addLabeledComponent(myRepoAuthorLabel, myRepoAuthor)\n      .addLabeledComponent(myRepoLabel, myRepoName).addLabeledComponent(myTokenLabel, myTokenPanel).getPanel();\n  }","id":71283,"modified_method":"@Nullable\n  @Override\n  protected JComponent createCustomPanel() {\n    myHostLabel = new JBLabel(\"Host:\", SwingConstants.RIGHT);\n    myHost = new MyTextField(\"Github host\");\n\n    myRepositoryLabel = new JBLabel(\"Repository:\", SwingConstants.RIGHT);\n    myRepoAuthor = new MyTextField(\"Repository Owner\");\n    myRepoName = new MyTextField(\"Repository Name\");\n    myRepoAuthor.setPreferredSize(\"SomelongNickname\");\n    myRepoName.setPreferredSize(\"SomelongReponame-with-suffixes\");\n\n    JPanel myRepoPanel = new JPanel(new GridBagLayout());\n    GridBag bag = new GridBag().setDefaultWeightX(1).setDefaultFill(GridBagConstraints.HORIZONTAL);\n    myRepoPanel.add(myRepoAuthor, bag.nextLine().next());\n    myRepoPanel.add(new JLabel(\"/\"), bag.next().fillCellNone().insets(0, 5, 0, 5).weightx(0));\n    myRepoPanel.add(myRepoName, bag.next());\n\n    myTokenLabel = new JBLabel(\"API Token:\", SwingConstants.RIGHT);\n    myToken = new MyTextField(\"OAuth2 token\");\n    myTokenButton = new JButton(\"Create API token\");\n    myTokenButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        generateToken();\n        doApply();\n      }\n    });\n\n    JPanel myTokenPanel = new JPanel();\n    myTokenPanel.setLayout(new BorderLayout(5, 5));\n    myTokenPanel.add(myToken, BorderLayout.CENTER);\n    myTokenPanel.add(myTokenButton, BorderLayout.EAST);\n\n    installListener(myHost);\n    installListener(myRepoAuthor);\n    installListener(myRepoName);\n    installListener(myToken);\n\n    return FormBuilder.createFormBuilder().setAlignLabelOnRight(true).addLabeledComponent(myHostLabel, myHost)\n      .addLabeledComponent(myRepositoryLabel, myRepoPanel).addLabeledComponent(myTokenLabel, myTokenPanel).getPanel();\n  }","commit_id":"f27aee3e4ac834e94391609d554f0ad0d39e836b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private String getHost() {\n    return myURLText.getText().trim();\n  }","id":71284,"modified_method":"@NotNull\n  private String getHost() {\n    return myHost.getText().trim();\n  }","commit_id":"f27aee3e4ac834e94391609d554f0ad0d39e836b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Object getProperty(Object o, String name) {\n        String getter = \"get\" + capitalize(name);\n        String isGetter = \"is\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method getPropertyMethod = null;\n\n            // First, the ideal case - a getFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (getter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n                if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n\n                if (\"getProperty\".equals(methods[i].getName())) {\n                    getPropertyMethod = methods[i];\n                }\n            }\n\n            // Ok, no setXXX found, try a getProperty(\"name\")\n            if (getPropertyMethod != null) {\n                Object params[] = new Object[1];\n                params[0] = name;\n                return getPropertyMethod.invoke(o, params);\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name, ex2);\n        } catch (SecurityException ex1) {\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: SecurityException for \" +\n                        o.getClass() + \" \" + name + \")\", ex1);\n        } catch (IllegalAccessException iae) {\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: IllegalAccessException for \" +\n                        o.getClass() + \" \" + name + \")\", iae);\n        } catch (InvocationTargetException ie) {\n            ExceptionUtils.handleThrowable(ie.getCause());\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: InvocationTargetException for \" +\n                        o.getClass() + \" \" + name + \")\");\n        }\n        return null;\n    }","id":71285,"modified_method":"public static Object getProperty(Object o, String name) {\n        String getter = \"get\" + capitalize(name);\n        String isGetter = \"is\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method getPropertyMethod = null;\n\n            // First, the ideal case - a getFoo() method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (getter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n                if (isGetter.equals(methods[i].getName()) && paramT.length == 0) {\n                    return methods[i].invoke(o, (Object[]) null);\n                }\n\n                if (\"getProperty\".equals(methods[i].getName())) {\n                    getPropertyMethod = methods[i];\n                }\n            }\n\n            // Ok, no setXXX found, try a getProperty(\"name\")\n            if (getPropertyMethod != null) {\n                Object params[] = new Object[1];\n                params[0] = name;\n                return getPropertyMethod.invoke(o, params);\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name, ex2);\n        } catch (SecurityException ex1) {\n            log.warn(\"IntrospectionUtils: SecurityException for \" +\n                    o.getClass() + \" \" + name + \")\", ex1);\n        } catch (IllegalAccessException iae) {\n            log.warn(\"IntrospectionUtils: IllegalAccessException for \" +\n                    o.getClass() + \" \" + name + \")\", iae);\n        } catch (InvocationTargetException ie) {\n            ExceptionUtils.handleThrowable(ie.getCause());\n            log.warn(\"IntrospectionUtils: InvocationTargetException for \" +\n                    o.getClass() + \" \" + name + \")\");\n        }\n        return null;\n    }","commit_id":"912dff966281f0c8922ec4a1a36f9ca6ccc8db2d","url":"https://github.com/apache/tomcat"},{"original_method":"@SuppressWarnings(\"null\") // setPropertyMethodVoid is not null when used\n    public static boolean setProperty(Object o, String name, String value,\n            boolean invokeSetProperty) {\n        if (log.isDebugEnabled())\n            log.debug(\"IntrospectionUtils: setProperty(\" +\n                    o.getClass() + \" \" + name + \"=\" + value + \")\");\n\n        String setter = \"set\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method setPropertyMethodVoid = null;\n            Method setPropertyMethodBool = null;\n\n            // First, the ideal case - a setFoo( String ) method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 1\n                        && \"java.lang.String\".equals(paramT[0].getName())) {\n\n                    methods[i].invoke(o, new Object[] { value });\n                    return true;\n                }\n            }\n\n            // Try a setFoo ( int ) or ( boolean )\n            for (int i = 0; i < methods.length; i++) {\n                boolean ok = true;\n                if (setter.equals(methods[i].getName())\n                        && methods[i].getParameterTypes().length == 1) {\n\n                    // match - find the type and invoke it\n                    Class<?> paramType = methods[i].getParameterTypes()[0];\n                    Object params[] = new Object[1];\n\n                    // Try a setFoo ( int )\n                    if (\"java.lang.Integer\".equals(paramType.getName())\n                            || \"int\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Integer(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n                    // Try a setFoo ( long )\n                    }else if (\"java.lang.Long\".equals(paramType.getName())\n                                || \"long\".equals(paramType.getName())) {\n                            try {\n                                params[0] = new Long(value);\n                            } catch (NumberFormatException ex) {\n                                ok = false;\n                            }\n\n                        // Try a setFoo ( boolean )\n                    } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                            || \"boolean\".equals(paramType.getName())) {\n                        params[0] = Boolean.valueOf(value);\n\n                        // Try a setFoo ( InetAddress )\n                    } else if (\"java.net.InetAddress\".equals(paramType\n                            .getName())) {\n                        try {\n                            params[0] = InetAddress.getByName(value);\n                        } catch (UnknownHostException exc) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"IntrospectionUtils: Unable to resolve host name:\" + value);\n                            ok = false;\n                        }\n\n                        // Unknown type\n                    } else {\n                        if (log.isDebugEnabled())\n                            log.debug(\"IntrospectionUtils: Unknown type \" +\n                                    paramType.getName());\n                    }\n\n                    if (ok) {\n                        methods[i].invoke(o, params);\n                        return true;\n                    }\n                }\n\n                // save \"setProperty\" for later\n                if (\"setProperty\".equals(methods[i].getName())) {\n                    if (methods[i].getReturnType()==Boolean.TYPE){\n                        setPropertyMethodBool = methods[i];\n                    }else {\n                        setPropertyMethodVoid = methods[i];\n                    }\n\n                }\n            }\n\n            // Ok, no setXXX found, try a setProperty(\"name\", \"value\")\n            if (invokeSetProperty && (setPropertyMethodBool != null ||\n                    setPropertyMethodVoid != null)) {\n                Object params[] = new Object[2];\n                params[0] = name;\n                params[1] = value;\n                if (setPropertyMethodBool != null) {\n                    try {\n                        return ((Boolean) setPropertyMethodBool.invoke(o,\n                                params)).booleanValue();\n                    }catch (IllegalArgumentException biae) {\n                        //the boolean method had the wrong\n                        //parameter types. lets try the other\n                        if (setPropertyMethodVoid!=null) {\n                            setPropertyMethodVoid.invoke(o, params);\n                            return true;\n                        }else {\n                            throw biae;\n                        }\n                    }\n                } else {\n                    setPropertyMethodVoid.invoke(o, params);\n                    return true;\n                }\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name + \" \" + value, ex2);\n        } catch (SecurityException ex1) {\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: SecurityException for \" +\n                        o.getClass() + \" \" + name + \"=\" + value + \")\", ex1);\n        } catch (IllegalAccessException iae) {\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: IllegalAccessException for \" +\n                        o.getClass() + \" \" + name + \"=\" + value + \")\", iae);\n        } catch (InvocationTargetException ie) {\n            ExceptionUtils.handleThrowable(ie.getCause());\n            if (log.isDebugEnabled())\n                log.debug(\"IntrospectionUtils: InvocationTargetException for \" +\n                        o.getClass() + \" \" + name + \"=\" + value + \")\", ie);\n        }\n        return false;\n    }","id":71286,"modified_method":"@SuppressWarnings(\"null\") // setPropertyMethodVoid is not null when used\n    public static boolean setProperty(Object o, String name, String value,\n            boolean invokeSetProperty) {\n        if (log.isDebugEnabled())\n            log.debug(\"IntrospectionUtils: setProperty(\" +\n                    o.getClass() + \" \" + name + \"=\" + value + \")\");\n\n        String setter = \"set\" + capitalize(name);\n\n        try {\n            Method methods[] = findMethods(o.getClass());\n            Method setPropertyMethodVoid = null;\n            Method setPropertyMethodBool = null;\n\n            // First, the ideal case - a setFoo( String ) method\n            for (int i = 0; i < methods.length; i++) {\n                Class<?> paramT[] = methods[i].getParameterTypes();\n                if (setter.equals(methods[i].getName()) && paramT.length == 1\n                        && \"java.lang.String\".equals(paramT[0].getName())) {\n\n                    methods[i].invoke(o, new Object[] { value });\n                    return true;\n                }\n            }\n\n            // Try a setFoo ( int ) or ( boolean )\n            for (int i = 0; i < methods.length; i++) {\n                boolean ok = true;\n                if (setter.equals(methods[i].getName())\n                        && methods[i].getParameterTypes().length == 1) {\n\n                    // match - find the type and invoke it\n                    Class<?> paramType = methods[i].getParameterTypes()[0];\n                    Object params[] = new Object[1];\n\n                    // Try a setFoo ( int )\n                    if (\"java.lang.Integer\".equals(paramType.getName())\n                            || \"int\".equals(paramType.getName())) {\n                        try {\n                            params[0] = new Integer(value);\n                        } catch (NumberFormatException ex) {\n                            ok = false;\n                        }\n                    // Try a setFoo ( long )\n                    }else if (\"java.lang.Long\".equals(paramType.getName())\n                                || \"long\".equals(paramType.getName())) {\n                            try {\n                                params[0] = new Long(value);\n                            } catch (NumberFormatException ex) {\n                                ok = false;\n                            }\n\n                        // Try a setFoo ( boolean )\n                    } else if (\"java.lang.Boolean\".equals(paramType.getName())\n                            || \"boolean\".equals(paramType.getName())) {\n                        params[0] = Boolean.valueOf(value);\n\n                        // Try a setFoo ( InetAddress )\n                    } else if (\"java.net.InetAddress\".equals(paramType\n                            .getName())) {\n                        try {\n                            params[0] = InetAddress.getByName(value);\n                        } catch (UnknownHostException exc) {\n                            if (log.isDebugEnabled())\n                                log.debug(\"IntrospectionUtils: Unable to resolve host name:\" + value);\n                            ok = false;\n                        }\n\n                        // Unknown type\n                    } else {\n                        if (log.isDebugEnabled())\n                            log.debug(\"IntrospectionUtils: Unknown type \" +\n                                    paramType.getName());\n                    }\n\n                    if (ok) {\n                        methods[i].invoke(o, params);\n                        return true;\n                    }\n                }\n\n                // save \"setProperty\" for later\n                if (\"setProperty\".equals(methods[i].getName())) {\n                    if (methods[i].getReturnType()==Boolean.TYPE){\n                        setPropertyMethodBool = methods[i];\n                    }else {\n                        setPropertyMethodVoid = methods[i];\n                    }\n\n                }\n            }\n\n            // Ok, no setXXX found, try a setProperty(\"name\", \"value\")\n            if (invokeSetProperty && (setPropertyMethodBool != null ||\n                    setPropertyMethodVoid != null)) {\n                Object params[] = new Object[2];\n                params[0] = name;\n                params[1] = value;\n                if (setPropertyMethodBool != null) {\n                    try {\n                        return ((Boolean) setPropertyMethodBool.invoke(o,\n                                params)).booleanValue();\n                    }catch (IllegalArgumentException biae) {\n                        //the boolean method had the wrong\n                        //parameter types. lets try the other\n                        if (setPropertyMethodVoid!=null) {\n                            setPropertyMethodVoid.invoke(o, params);\n                            return true;\n                        }else {\n                            throw biae;\n                        }\n                    }\n                } else {\n                    setPropertyMethodVoid.invoke(o, params);\n                    return true;\n                }\n            }\n\n        } catch (IllegalArgumentException ex2) {\n            log.warn(\"IAE \" + o + \" \" + name + \" \" + value, ex2);\n        } catch (SecurityException ex1) {\n            log.warn(\"IntrospectionUtils: SecurityException for \" +\n                    o.getClass() + \" \" + name + \"=\" + value + \")\", ex1);\n        } catch (IllegalAccessException iae) {\n            log.warn(\"IntrospectionUtils: IllegalAccessException for \" +\n                    o.getClass() + \" \" + name + \"=\" + value + \")\", iae);\n        } catch (InvocationTargetException ie) {\n            ExceptionUtils.handleThrowable(ie.getCause());\n            log.warn(\"IntrospectionUtils: InvocationTargetException for \" +\n                    o.getClass() + \" \" + name + \"=\" + value + \")\", ie);\n        }\n        return false;\n    }","commit_id":"912dff966281f0c8922ec4a1a36f9ca6ccc8db2d","url":"https://github.com/apache/tomcat"},{"original_method":"public boolean populateItemBean(ItemAuthorBean itemauthorbean, String itemId) {\n      FacesContext context = FacesContext.getCurrentInstance();\n      String nextpage= null;\n      ItemBean bean = new ItemBean();\n      AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\n      boolean isEditPendingAssessmentFlow = author.getIsEditPendingAssessmentFlow();\n      log.debug(\"**** isEditPendingAssessmentFlow : \" + isEditPendingAssessmentFlow);\n      ItemService delegate = null;\n      AssessmentService assessdelegate= null;\n      if (isEditPendingAssessmentFlow) {\n    \t  delegate = new ItemService();\n    \t  assessdelegate = new AssessmentService();\n      }\n      else {\n    \t  delegate = new PublishedItemService();\n    \t  assessdelegate = new PublishedAssessmentService();\n      }\n\n    try {\n      ItemFacade itemfacade = delegate.getItem(itemId);\n\n      // Check permissions: if sequence is null, the item is *not* in a pool then the poolId would be null\n      if (itemauthorbean.getQpoolId() == null) {\n        AuthorizationBean authzBean = (AuthorizationBean) ContextUtil.lookupBean(\"authorization\");\n        // the way to get assessment ID is completely different for published and core\n        // you'd think a slight variant of the published would work for core, but it generates an error\n        Long assessmentId = null;\n        String createdBy = null;\n        if (isEditPendingAssessmentFlow) {\n          Long sectionId = itemfacade.getSection().getSectionId();\n          AssessmentFacade af = assessdelegate.getBasicInfoOfAnAssessmentFromSectionId(sectionId);\n          assessmentId = af.getAssessmentBaseId();\n          createdBy = af.getCreatedBy();\n        }\n        else {\n          PublishedAssessmentIfc assessment = (PublishedAssessmentIfc)itemfacade.getSection().getAssessment();\n          assessmentId = assessment.getPublishedAssessmentId();\n          createdBy = assessment.getCreatedBy();\n        }\n        if (!authzBean.isUserAllowedToEditAssessment(assessmentId.toString(), createdBy, !isEditPendingAssessmentFlow)) {\n          String err=(String)ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\", \"denied_edit_assessment_error\");\n          context.addMessage(null,new FacesMessage(err));\n          itemauthorbean.setOutcome(\"author\");\n          if (log.isDebugEnabled()) {\n            log.debug(\"itemID \" + itemId + \" for assignment \" + assessmentId.toString() + \" is being returned null from populateItemBean because it fails isUSerAllowedToEditAssessment for \" + createdBy);\n          }\n          return false;\n        }\n      }\n      else {\n          // This item is in a question pool\n          UserDirectoryService userDirectoryService = ComponentManager.get(UserDirectoryService.class);\n          String currentUserId = userDirectoryService.getCurrentUser().getId();\n          QuestionPoolService qpdelegate = new QuestionPoolService();\n          List<Long> poolIds = qpdelegate.getPoolIdsByItem(itemId);\n          boolean authorized = false;\n          poolloop:\n          for (Long poolId: poolIds) {\n              List agents = qpdelegate.getAgentsWithAccess(poolId);\n              for (Object agent: agents) {\n                  if (currentUserId.equals(((AgentDataIfc)agent).getIdString())) {\n                      authorized = true;\n                      break poolloop;\n                  }\n              }\n          }\n          if (!authorized) {\n              String err=(String)ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\", \"denied_edit_assessment_error\");\n              context.addMessage(null,new FacesMessage(err));\n              itemauthorbean.setOutcome(\"author\");\n              if (log.isDebugEnabled()) {\n                  log.debug(\"itemID \" + itemId + \" in pool is being returned null from populateItemBean because it fails isUSerAllowedToEditAssessment for user \" + currentUserId);\n              }\n              return false;\n          }\n      }\n\n      bean.setItemId(itemfacade.getItemId().toString());\n      bean.setItemType(itemfacade.getTypeId().toString());\n      itemauthorbean.setItemType(itemfacade.getTypeId().toString());\n\n      // if the item only exists in pool, sequence = null\n      if (itemfacade.getSequence()!=null) {\n        itemauthorbean.setItemNo(String.valueOf(itemfacade.getSequence().intValue() ));\n      }\n\n      Double score = itemfacade.getScore();\n      if (score == null)\n       {\n         // cover modifying an imported XML assessment that has no score yet\n         score = 0.0d;\n       }\n      bean.setItemScore(score);\n      bean.setItemScoreDisplayFlag(itemfacade.getScoreDisplayFlag() ? \"true\" : \"false\");\n \n      bean.setItemMinScore(itemfacade.getMinScore());\n\n      Double discount = itemfacade.getDiscount();\n      if (discount == null)\n      {\n        // cover modifying an imported XML assessment that has no score yet\n    \t  discount = 0.0d;\n      }\n      bean.setItemDiscount(discount);\n\n      // partical credit flag\n      String partialCreditFlag= \"FALSE\";\n      Boolean hasPartialCredit = itemfacade.getPartialCreditFlag();\n      if (hasPartialCredit != null) {\n    \t  partialCreditFlag = hasPartialCredit.toString();\n      } \n      bean.setPartialCreditFlag(partialCreditFlag);\n           \n      if (itemfacade.getHasRationale() !=null) {\n        bean.setRationale(itemfacade.getHasRationale().toString());\n      }\n      if (itemfacade.getInstruction() !=null) {\n        bean.setInstruction(itemfacade.getInstruction());\n      }\n\n      if (itemfacade.getDuration() !=null) {\n        bean.setTimeAllowed(itemfacade.getDuration().toString());\n      }\n\n      if (itemfacade.getTriesAllowed() !=null) {\n        bean.setNumAttempts(itemfacade.getTriesAllowed().toString());\n      }\n\n      bean.setCorrFeedback(itemfacade.getCorrectItemFeedback());\n      bean.setIncorrFeedback(itemfacade.getInCorrectItemFeedback());\n      bean.setGeneralFeedback(itemfacade.getGeneralItemFeedback());\n      populateMetaData(itemauthorbean, itemfacade, bean);\n\n      if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.MATCHING)) {\n    \t  populateItemTextForMatching(itemauthorbean, itemfacade, bean);\n      }\n      else if (Long.valueOf(itemauthorbean.getItemType()).equals(TypeFacade.EXTENDED_MATCHING_ITEMS)) {\n    \t  populateItemTextForEMI(itemauthorbean, itemfacade, bean);\n      }\n      else if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.CALCULATED_QUESTION)) {\n          populateItemTextForCalculatedQuestion(itemauthorbean, itemfacade, bean);          \n      }\n      else if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.IMAGEMAP_QUESTION)) {\n    \t  populateItemTextForImageMapQuestion(itemauthorbean, itemfacade, bean);          \n      }\n      else if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.MATRIX_CHOICES_SURVEY)){\n    \t  populateItemTextForMatrix(itemauthorbean, itemfacade, bean);\n      }\n      else {\n    \t  populateItemText(itemauthorbean, itemfacade, bean);\n      }\n\n      // attach item attachemnt to itemAuthorBean\n      List attachmentList = itemfacade.getData().getItemAttachmentList(); \n      itemauthorbean.setAttachmentList(attachmentList);\n      itemauthorbean.setResourceHash(null);\n      \n      int itype=0; // default to true/false\n      if (itemauthorbean.getItemType()!=null) {\n                itype = new Integer(itemauthorbean.getItemType()).intValue();\n      }\n      switch (itype) {\n                case 1:\n                        itemauthorbean.setItemTypeString(\"Multiple Choice\");\n                        nextpage = \"multipleChoiceItem\";\n                        break;\n                case 2:\n                        itemauthorbean.setItemTypeString(\"Multiple Choice\");\n                        nextpage = \"multipleChoiceItem\";\n                        break;\n                case 12:\n                    \titemauthorbean.setItemTypeString(\"Multiple Choice\");\n                    \tnextpage = \"multipleChoiceItem\";\n                    \tbreak;\n                case 3:\n                        itemauthorbean.setItemTypeString(\"Survey\");  // need to get it from properties file\n                        nextpage = \"surveyItem\";\n                        break;\n                case 4:\n                        itemauthorbean.setItemTypeString(\"True or False\");  //  need to get it from properties file\n                        nextpage = \"trueFalseItem\";\n                        break;\n                case 5:\n                        itemauthorbean.setItemTypeString(\"Short Answers/Essay\");  //  need to get it from properties file\n                        nextpage = \"shortAnswerItem\";\n                        break;\n                case 6:\n                        itemauthorbean.setItemTypeString(\"File Upload\");  //  need to get it from properties file\n                        nextpage = \"fileUploadItem\";\n                        break;\n                case 7:\n                        itemauthorbean.setItemTypeString(\"Audio Recording\");  //  need to get it from properties file\n                        nextpage = \"audioRecItem\";\n                        break;\n                case 8:\n                        itemauthorbean.setItemTypeString(\"Fill In the Blank\");  //  need to get it from properties file\n                        nextpage = \"fillInBlackItem\";\n                        break;\n                case 11:\n                    itemauthorbean.setItemTypeString(\"Fill In Numeric\");  //  need to get it from properties file\n                    nextpage = \"fillInNumericItem\";\n                    break;                    \n                case 9:\n                        itemauthorbean.setItemTypeString(\"Matching\");  //  need to get it from properties file\n                        MatchItemBean matchitem = new MatchItemBean();\n                        bean.setCurrentMatchPair(matchitem);\n                        nextpage = \"matchingItem\";\n                        break;\n                case 10:\n                        itemauthorbean.setItemTypeString(\"Importing from Question Pool\");\n                        // need to get it from properties file\n                        nextpage = \"poolList\";\n                        break;\n                case 13:\n                \t    itemauthorbean.setItemTypeString(\"Matrix Choices Survey\");  //  need to get it from properties file\n                \t    nextpage = \"matrixChoicesSurveyItem\";\n                \t    break;\n                case 14:\n                \titemauthorbean.setItemTypeString(\"Extended Matching Items\");  //  need to get it from properties file\n                \tnextpage = \"emiItem\";\n                \tbreak;\n                case 15: // CALCULATED_QUESTION\n                    itemauthorbean.setItemTypeString(\"Calculated Question\");  //  need to get it from properties file\n                    MatchItemBean variableItem = new MatchItemBean();\n                    bean.setCurrentMatchPair(variableItem);\n                    nextpage = \"calculatedQuestionVariableItem\";\n                    break;\n                case 16: // IMAGEMAP_QUESTION\n                    itemauthorbean.setItemTypeString(\"Image Map Question\");  //  need to get it from properties file\n                    ImageMapItemBean variableItemImag = new ImageMapItemBean();\n                    //bean.setCurrentImageMapPair(variableItemImag);\n                    nextpage = \"imageMapItem\";\n                    break;\n        }\n    }\n    catch(RuntimeException e)\n    {\n        log.error(\"Could not populate ItemBean\", e);\n      return false;\n    }\n\n    if (\"assessment\".equals(itemauthorbean.getTarget())) {\n// check for metadata settings\n      AssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\"assessmentBean\");\n      AssessmentIfc assessment = assessdelegate.getAssessment(Long.valueOf(assessmentBean.getAssessmentId()));\n      itemauthorbean.setShowMetadata(assessment.getHasMetaDataForQuestions());\n    }\n    else {\n     // for question pool , always show metadata as default\n      itemauthorbean.setShowMetadata(\"true\");\n    }\n\n\n      // set current ItemBean in ItemAuthorBean\n      itemauthorbean.setCurrentItem(bean);\n\n\t// set outcome for action\n\titemauthorbean.setOutcome(nextpage);\n\treturn true;\n  }","id":71287,"modified_method":"public boolean populateItemBean(ItemAuthorBean itemauthorbean, String itemId) {\n      FacesContext context = FacesContext.getCurrentInstance();\n      String nextpage= null;\n      ItemBean bean = new ItemBean();\n      AuthorBean author = (AuthorBean) ContextUtil.lookupBean(\"author\");\n      boolean isEditPendingAssessmentFlow = author.getIsEditPendingAssessmentFlow();\n      log.debug(\"**** isEditPendingAssessmentFlow : \" + isEditPendingAssessmentFlow);\n      ItemService delegate = null;\n      AssessmentService assessdelegate= null;\n      if (isEditPendingAssessmentFlow) {\n    \t  delegate = new ItemService();\n    \t  assessdelegate = new AssessmentService();\n      }\n      else {\n    \t  delegate = new PublishedItemService();\n    \t  assessdelegate = new PublishedAssessmentService();\n      }\n\n    try {\n      ItemFacade itemfacade = delegate.getItem(itemId);\n\n      // Check permissions: if sequence is null, the item is *not* in a pool then the poolId would be null\n      if (isEditPendingAssessmentFlow || itemauthorbean.getQpoolId() == null) {\n        AuthorizationBean authzBean = (AuthorizationBean) ContextUtil.lookupBean(\"authorization\");\n        // the way to get assessment ID is completely different for published and core\n        // you'd think a slight variant of the published would work for core, but it generates an error\n        Long assessmentId = null;\n        String createdBy = null;\n        if (isEditPendingAssessmentFlow) {\n          Long sectionId = itemfacade.getSection().getSectionId();\n          AssessmentFacade af = assessdelegate.getBasicInfoOfAnAssessmentFromSectionId(sectionId);\n          assessmentId = af.getAssessmentBaseId();\n          createdBy = af.getCreatedBy();\n        }\n        else {\n          PublishedAssessmentIfc assessment = (PublishedAssessmentIfc)itemfacade.getSection().getAssessment();\n          assessmentId = assessment.getPublishedAssessmentId();\n          createdBy = assessment.getCreatedBy();\n        }\n        if (!authzBean.isUserAllowedToEditAssessment(assessmentId.toString(), createdBy, !isEditPendingAssessmentFlow)) {\n          String err=(String)ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\", \"denied_edit_assessment_error\");\n          context.addMessage(null,new FacesMessage(err));\n          itemauthorbean.setOutcome(\"author\");\n          log.warn(\"itemID \" + itemId + \" for assignment \" + assessmentId.toString() + \" is being returned null from populateItemBean because it fails isUserAllowedToEditAssessment for \" + createdBy);\n          return false;\n        }\n      }\n      else {\n          // This item is in a question pool\n          UserDirectoryService userDirectoryService = ComponentManager.get(UserDirectoryService.class);\n          String currentUserId = userDirectoryService.getCurrentUser().getId();\n          QuestionPoolService qpdelegate = new QuestionPoolService();\n          List<Long> poolIds = qpdelegate.getPoolIdsByItem(itemId);\n          boolean authorized = false;\n          poolloop:\n          for (Long poolId: poolIds) {\n              List agents = qpdelegate.getAgentsWithAccess(poolId);\n              for (Object agent: agents) {\n                  if (currentUserId.equals(((AgentDataIfc)agent).getIdString())) {\n                      authorized = true;\n                      break poolloop;\n                  }\n              }\n          }\n          if (!authorized) {\n              String err=(String)ContextUtil.getLocalizedString(\"org.sakaiproject.tool.assessment.bundle.AuthorMessages\", \"denied_edit_assessment_error\");\n              context.addMessage(null,new FacesMessage(err));\n              itemauthorbean.setOutcome(\"author\");\n              log.warn(\"itemID \" + itemId + \" in pool is being returned null from populateItemBean because it fails isUserAllowedToEditAssessment for user \" + currentUserId);\n              return false;\n          }\n      }\n\n      bean.setItemId(itemfacade.getItemId().toString());\n      bean.setItemType(itemfacade.getTypeId().toString());\n      itemauthorbean.setItemType(itemfacade.getTypeId().toString());\n\n      // if the item only exists in pool, sequence = null\n      if (itemfacade.getSequence()!=null) {\n        itemauthorbean.setItemNo(String.valueOf(itemfacade.getSequence().intValue() ));\n      }\n\n      Double score = itemfacade.getScore();\n      if (score == null)\n       {\n         // cover modifying an imported XML assessment that has no score yet\n         score = 0.0d;\n       }\n      bean.setItemScore(score);\n      bean.setItemScoreDisplayFlag(itemfacade.getScoreDisplayFlag() ? \"true\" : \"false\");\n \n      bean.setItemMinScore(itemfacade.getMinScore());\n\n      Double discount = itemfacade.getDiscount();\n      if (discount == null)\n      {\n        // cover modifying an imported XML assessment that has no score yet\n    \t  discount = 0.0d;\n      }\n      bean.setItemDiscount(discount);\n\n      // partical credit flag\n      String partialCreditFlag= \"FALSE\";\n      Boolean hasPartialCredit = itemfacade.getPartialCreditFlag();\n      if (hasPartialCredit != null) {\n    \t  partialCreditFlag = hasPartialCredit.toString();\n      } \n      bean.setPartialCreditFlag(partialCreditFlag);\n           \n      if (itemfacade.getHasRationale() !=null) {\n        bean.setRationale(itemfacade.getHasRationale().toString());\n      }\n      if (itemfacade.getInstruction() !=null) {\n        bean.setInstruction(itemfacade.getInstruction());\n      }\n\n      if (itemfacade.getDuration() !=null) {\n        bean.setTimeAllowed(itemfacade.getDuration().toString());\n      }\n\n      if (itemfacade.getTriesAllowed() !=null) {\n        bean.setNumAttempts(itemfacade.getTriesAllowed().toString());\n      }\n\n      bean.setCorrFeedback(itemfacade.getCorrectItemFeedback());\n      bean.setIncorrFeedback(itemfacade.getInCorrectItemFeedback());\n      bean.setGeneralFeedback(itemfacade.getGeneralItemFeedback());\n      populateMetaData(itemauthorbean, itemfacade, bean);\n\n      if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.MATCHING)) {\n    \t  populateItemTextForMatching(itemauthorbean, itemfacade, bean);\n      }\n      else if (Long.valueOf(itemauthorbean.getItemType()).equals(TypeFacade.EXTENDED_MATCHING_ITEMS)) {\n    \t  populateItemTextForEMI(itemauthorbean, itemfacade, bean);\n      }\n      else if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.CALCULATED_QUESTION)) {\n          populateItemTextForCalculatedQuestion(itemauthorbean, itemfacade, bean);          \n      }\n      else if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.IMAGEMAP_QUESTION)) {\n    \t  populateItemTextForImageMapQuestion(itemauthorbean, itemfacade, bean);          \n      }\n      else if (new Long(itemauthorbean.getItemType()).equals(TypeFacade.MATRIX_CHOICES_SURVEY)){\n    \t  populateItemTextForMatrix(itemauthorbean, itemfacade, bean);\n      }\n      else {\n    \t  populateItemText(itemauthorbean, itemfacade, bean);\n      }\n\n      // attach item attachemnt to itemAuthorBean\n      List attachmentList = itemfacade.getData().getItemAttachmentList(); \n      itemauthorbean.setAttachmentList(attachmentList);\n      itemauthorbean.setResourceHash(null);\n      \n      int itype=0; // default to true/false\n      if (itemauthorbean.getItemType()!=null) {\n                itype = new Integer(itemauthorbean.getItemType()).intValue();\n      }\n      switch (itype) {\n                case 1:\n                        itemauthorbean.setItemTypeString(\"Multiple Choice\");\n                        nextpage = \"multipleChoiceItem\";\n                        break;\n                case 2:\n                        itemauthorbean.setItemTypeString(\"Multiple Choice\");\n                        nextpage = \"multipleChoiceItem\";\n                        break;\n                case 12:\n                    \titemauthorbean.setItemTypeString(\"Multiple Choice\");\n                    \tnextpage = \"multipleChoiceItem\";\n                    \tbreak;\n                case 3:\n                        itemauthorbean.setItemTypeString(\"Survey\");  // need to get it from properties file\n                        nextpage = \"surveyItem\";\n                        break;\n                case 4:\n                        itemauthorbean.setItemTypeString(\"True or False\");  //  need to get it from properties file\n                        nextpage = \"trueFalseItem\";\n                        break;\n                case 5:\n                        itemauthorbean.setItemTypeString(\"Short Answers/Essay\");  //  need to get it from properties file\n                        nextpage = \"shortAnswerItem\";\n                        break;\n                case 6:\n                        itemauthorbean.setItemTypeString(\"File Upload\");  //  need to get it from properties file\n                        nextpage = \"fileUploadItem\";\n                        break;\n                case 7:\n                        itemauthorbean.setItemTypeString(\"Audio Recording\");  //  need to get it from properties file\n                        nextpage = \"audioRecItem\";\n                        break;\n                case 8:\n                        itemauthorbean.setItemTypeString(\"Fill In the Blank\");  //  need to get it from properties file\n                        nextpage = \"fillInBlackItem\";\n                        break;\n                case 11:\n                    itemauthorbean.setItemTypeString(\"Fill In Numeric\");  //  need to get it from properties file\n                    nextpage = \"fillInNumericItem\";\n                    break;                    \n                case 9:\n                        itemauthorbean.setItemTypeString(\"Matching\");  //  need to get it from properties file\n                        MatchItemBean matchitem = new MatchItemBean();\n                        bean.setCurrentMatchPair(matchitem);\n                        nextpage = \"matchingItem\";\n                        break;\n                case 10:\n                        itemauthorbean.setItemTypeString(\"Importing from Question Pool\");\n                        // need to get it from properties file\n                        nextpage = \"poolList\";\n                        break;\n                case 13:\n                \t    itemauthorbean.setItemTypeString(\"Matrix Choices Survey\");  //  need to get it from properties file\n                \t    nextpage = \"matrixChoicesSurveyItem\";\n                \t    break;\n                case 14:\n                \titemauthorbean.setItemTypeString(\"Extended Matching Items\");  //  need to get it from properties file\n                \tnextpage = \"emiItem\";\n                \tbreak;\n                case 15: // CALCULATED_QUESTION\n                    itemauthorbean.setItemTypeString(\"Calculated Question\");  //  need to get it from properties file\n                    MatchItemBean variableItem = new MatchItemBean();\n                    bean.setCurrentMatchPair(variableItem);\n                    nextpage = \"calculatedQuestionVariableItem\";\n                    break;\n                case 16: // IMAGEMAP_QUESTION\n                    itemauthorbean.setItemTypeString(\"Image Map Question\");  //  need to get it from properties file\n                    ImageMapItemBean variableItemImag = new ImageMapItemBean();\n                    //bean.setCurrentImageMapPair(variableItemImag);\n                    nextpage = \"imageMapItem\";\n                    break;\n        }\n    }\n    catch(RuntimeException e)\n    {\n        log.error(\"Could not populate ItemBean\", e);\n      return false;\n    }\n\n    if (\"assessment\".equals(itemauthorbean.getTarget())) {\n// check for metadata settings\n      AssessmentBean assessmentBean = (AssessmentBean) ContextUtil.lookupBean(\"assessmentBean\");\n      AssessmentIfc assessment = assessdelegate.getAssessment(Long.valueOf(assessmentBean.getAssessmentId()));\n      itemauthorbean.setShowMetadata(assessment.getHasMetaDataForQuestions());\n    }\n    else {\n     // for question pool , always show metadata as default\n      itemauthorbean.setShowMetadata(\"true\");\n    }\n\n\n      // set current ItemBean in ItemAuthorBean\n      itemauthorbean.setCurrentItem(bean);\n\n\t// set outcome for action\n\titemauthorbean.setOutcome(nextpage);\n\treturn true;\n  }","commit_id":"494b36ca9574a7f412885a8cc483cd0bf4e29432","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        if (provider == null) {\n            log.warn(\"No security provider available: disallowing web access to brooklyn\");\n            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        if (authenticate(httpRequest)) {\n            String user = Strings.toString(httpRequest.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE));\n            if (handleLogout(httpRequest)) {\n                log.debug(\"REST logging out \" + user + \" of session \" + httpRequest.getSession());\n                // do nothing here, fall through to below\n            } else {\n                WebEntitlementContext entitlementContext = null;\n                String uri = httpRequest.getRequestURI();\n                try {\n                    String uid = Identifiers.makeRandomId(6);\n                    entitlementContext = new WebEntitlementContext(user, httpRequest.getRemoteAddr(), uri, uid);\n                    if (originalRequest.get() == null) {\n                        // initial filter application\n                        originalRequest.set(uri);\n                    } else {\n                        // this filter is being applied *again*, probably due to forwarding (e.g. from '/' to '/index.html')\n                        log.debug(\"REST request {} being forwarded from {} to {}\", new Object[]{uid, originalRequest.get(), uri});\n                        // clear the entitlement context before setting to avoid warnings\n                        Entitlements.clearEntitlementContext();\n                    }\n                    Entitlements.setEntitlementContext(entitlementContext);\n\n                    log.debug(\"REST req {} starting processing request {} with {}\", new Object[]{uid, uri, entitlementContext});\n                    chain.doFilter(request, response);\n\n                    // This logging must NOT happen before chain.doFilter, or FormMapProvider will not work as expected.\n                    // Getting the parameter map consumes the request body and only resource methods using @FormParam\n                    // will work as expected.\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"REST req {} complete, responding {} for request {} with {}\",\n                                new Object[]{uid, ((HttpServletResponse) response).getStatus(), uri, entitlementContext});\n                        if (!httpRequest.getParameterMap().isEmpty()) {\n                            log.debug(\"     parameters were: {}\", httpRequest.getParameterMap());\n                        }\n                        if (httpRequest.getContentLength() > 0) {\n                            int len = httpRequest.getContentLength();\n                            log.debug(\"     upload content type was {}, length={}\", httpRequest.getContentType(), len);\n                        }\n                    }\n                    return;\n                } catch (Throwable e) {\n                    // NB errors are typically already caught at this point\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"REST failed processing request \" + uri + \" with \" + entitlementContext + \": \" + e, e);\n                    }\n                    throw Exceptions.propagate(e);\n                } finally {\n                    originalRequest.remove();\n                    Entitlements.clearEntitlementContext();\n                }\n            }\n        }\n        ((HttpServletResponse) response).setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"brooklyn\\\"\");\n        ((HttpServletResponse) response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n    }","id":71288,"modified_method":"@Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        if (provider == null) {\n            log.warn(\"No security provider available: disallowing web access to brooklyn\");\n            ((HttpServletResponse) response).sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\n            return;\n        }\n\n        HttpServletRequest httpRequest = (HttpServletRequest) request;\n        if (authenticate(httpRequest)) {\n            String user = Strings.toString(httpRequest.getSession().getAttribute(AUTHENTICATED_USER_SESSION_ATTRIBUTE));\n            if (handleLogout(httpRequest)) {\n                log.debug(\"REST logging out \" + user + \" of session \" + httpRequest.getSession());\n                // do nothing here, fall through to below\n            } else {\n                WebEntitlementContext entitlementContext = null;\n                String uri = httpRequest.getRequestURI();\n                try {\n                    String uid = Identifiers.makeRandomId(6);\n                    entitlementContext = new WebEntitlementContext(user, httpRequest.getRemoteAddr(), uri, uid);\n                    if (originalRequest.get() == null) {\n                        // initial filter application\n                        originalRequest.set(uri);\n                    } else {\n                        // this filter is being applied *again*, probably due to forwarding (e.g. from '/' to '/index.html')\n                        log.debug(\"REST request {} being forwarded from {} to {}\", new Object[]{uid, originalRequest.get(), uri});\n                        // clear the entitlement context before setting to avoid warnings\n                        Entitlements.clearEntitlementContext();\n                    }\n                    Entitlements.setEntitlementContext(entitlementContext);\n\n                    log.debug(\"REST req {} starting processing request {} with {}\", new Object[]{uid, uri, entitlementContext});\n                    chain.doFilter(request, response);\n\n                    // This logging must NOT happen before chain.doFilter, or FormMapProvider will not work as expected.\n                    // Getting the parameter map consumes the request body and only resource methods using @FormParam\n                    // will work as expected.\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"REST req {} complete, responding {} for request {} with {}\",\n                                new Object[]{uid, ((HttpServletResponse) response).getStatus(), uri, entitlementContext});\n                        if (!httpRequest.getParameterMap().isEmpty()) {\n                            log.debug(\"     parameters were: {}\", httpRequest.getParameterMap());\n                        }\n                        if (httpRequest.getContentLength() > 0) {\n                            int len = httpRequest.getContentLength();\n                            log.debug(\"     upload content type was {}, length={}\", httpRequest.getContentType(), len);\n                        }\n                    }\n                    return;\n                } catch (Throwable e) {\n                    // errors are typically already caught at this point, except for serialization errors\n                    log.warn(\"REST failed processing request \" + uri + \" with \" + entitlementContext + \": \" + e, e);\n                    ((HttpServletResponse) response).sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n                    return;\n                } finally {\n                    originalRequest.remove();\n                    Entitlements.clearEntitlementContext();\n                }\n            }\n        }\n        ((HttpServletResponse) response).setHeader(\"WWW-Authenticate\", \"Basic realm=\\\"brooklyn\\\"\");\n        ((HttpServletResponse) response).sendError(HttpServletResponse.SC_UNAUTHORIZED);\n    }","commit_id":"05a39488dca27887f563c20ad1110ed3916c25f5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static EffectorSummary effectorSummaryForCatalog(Effector<?> effector) {\n        Set<EffectorSummary.ParameterSummary<?>> parameters = ImmutableSet.copyOf(Iterables.transform(effector.getParameters(),\n                new Function<ParameterType<?>, EffectorSummary.ParameterSummary<?>>() {\n                    @Override\n                    public EffectorSummary.ParameterSummary<?> apply(ParameterType<?> parameterType) {\n                        return parameterSummary(parameterType);\n                    }\n                }));\n        return new EffectorSummary(effector.getName(),\n                effector.getReturnTypeName(), parameters, effector.getDescription(), null);\n    }","id":71289,"modified_method":"public static EffectorSummary effectorSummaryForCatalog(Effector<?> effector) {\n        Set<EffectorSummary.ParameterSummary<?>> parameters = ImmutableSet.copyOf(Iterables.transform(effector.getParameters(),\n                new Function<ParameterType<?>, EffectorSummary.ParameterSummary<?>>() {\n                    @Override\n                    public EffectorSummary.ParameterSummary<?> apply(ParameterType<?> parameterType) {\n                        return parameterSummary(null, parameterType);\n                    }\n                }));\n        return new EffectorSummary(effector.getName(),\n                effector.getReturnTypeName(), parameters, effector.getDescription(), null);\n    }","commit_id":"05a39488dca27887f563c20ad1110ed3916c25f5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static EffectorSummary effectorSummary(EntityLocal entity, Effector<?> effector) {\n        String applicationUri = \"/v1/applications/\" + entity.getApplicationId();\n        String entityUri = applicationUri + \"/entities/\" + entity.getId();\n        return new EffectorSummary(effector.getName(), effector.getReturnTypeName(),\n                 ImmutableSet.copyOf(Iterables.transform(effector.getParameters(),\n                new Function<ParameterType<?>, EffectorSummary.ParameterSummary<?>>() {\n                    @Override\n                    public EffectorSummary.ParameterSummary<?> apply(@Nullable ParameterType<?> parameterType) {\n                        return parameterSummary(parameterType);\n                    }\n                })), effector.getDescription(), ImmutableMap.of(\n                \"self\", URI.create(entityUri + \"/effectors/\" + effector.getName()),\n                \"entity\", URI.create(entityUri),\n                \"application\", URI.create(applicationUri)\n        ));\n    }","id":71290,"modified_method":"public static EffectorSummary effectorSummary(final EntityLocal entity, Effector<?> effector) {\n        String applicationUri = \"/v1/applications/\" + entity.getApplicationId();\n        String entityUri = applicationUri + \"/entities/\" + entity.getId();\n        return new EffectorSummary(effector.getName(), effector.getReturnTypeName(),\n                 ImmutableSet.copyOf(Iterables.transform(effector.getParameters(),\n                new Function<ParameterType<?>, EffectorSummary.ParameterSummary<?>>() {\n                    @Override\n                    public EffectorSummary.ParameterSummary<?> apply(@Nullable ParameterType<?> parameterType) {\n                        return parameterSummary(entity, parameterType);\n                    }\n                })), effector.getDescription(), ImmutableMap.of(\n                \"self\", URI.create(entityUri + \"/effectors/\" + effector.getName()),\n                \"entity\", URI.create(entityUri),\n                \"application\", URI.create(applicationUri)\n        ));\n    }","commit_id":"05a39488dca27887f563c20ad1110ed3916c25f5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    protected static EffectorSummary.ParameterSummary<?> parameterSummary(ParameterType<?> parameterType) {\n        return new ParameterSummary(parameterType.getName(), parameterType.getParameterClassName(), \n                parameterType.getDescription(), parameterType.getDefaultValue());\n    }","id":71291,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    protected static EffectorSummary.ParameterSummary<?> parameterSummary(Entity entity, ParameterType<?> parameterType) {\n        try {\n            Maybe<?> defaultValue = Tasks.resolving(parameterType.getDefaultValue()).as(parameterType.getParameterClass())\n                .context(entity!=null ? ((EntityInternal)entity).getExecutionContext() : null).timeout(Duration.millis(50)).getMaybe();\n            return new ParameterSummary(parameterType.getName(), parameterType.getParameterClassName(), \n                parameterType.getDescription(), \n                WebResourceUtils.getValueForDisplay(defaultValue.orNull(), true, false));\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n    }","commit_id":"05a39488dca27887f563c20ad1110ed3916c25f5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** attempt to resolve the given value as the given type, waiting on futures, submitting if necessary,\n     * and coercing as allowed by TypeCoercions;\n     * contextMessage (optional) will be displayed in status reports while it waits (e.g. the name of the config key being looked up) */\n    public static <T> T resolveValue(Object v, Class<T> type, ExecutionContext exec, String contextMessage) throws ExecutionException, InterruptedException {\n        return resolveValue(v, type, exec, contextMessage, false);\n    }","id":71292,"modified_method":"/** attempt to resolve the given value as the given type, waiting on futures, submitting if necessary,\n     * and coercing as allowed by TypeCoercions;\n     * contextMessage (optional) will be displayed in status reports while it waits (e.g. the name of the config key being looked up).\n     * if no execution context supplied (null) this method will throw an exception if the object is an unsubmitted task */\n    public static <T> T resolveValue(Object v, Class<T> type, @Nullable ExecutionContext exec, String contextMessage) throws ExecutionException, InterruptedException {\n        return new ValueResolver<T>(v, type).context(exec).description(contextMessage).get();\n    }","commit_id":"05a39488dca27887f563c20ad1110ed3916c25f5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/** @see #resolveValue(Object, Class, ExecutionContext, String) */\n    public static <T> T resolveValue(Object v, Class<T> type, ExecutionContext exec) throws ExecutionException, InterruptedException {\n        return resolveValue(v, type, exec, null);\n    }","id":71293,"modified_method":"/** @see #resolveValue(Object, Class, ExecutionContext, String) */\n    public static <T> T resolveValue(Object v, Class<T> type, @Nullable ExecutionContext exec) throws ExecutionException, InterruptedException {\n        return new ValueResolver<T>(v, type).context(exec).get();\n    }","commit_id":"05a39488dca27887f563c20ad1110ed3916c25f5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Resolves the given object, blocking on futures and coercing it to the given type. If the object is a \n     * map or iterable (or a list of map of maps, etc, etc) then walks these maps/iterables to convert all of \n     * their values to the given type. For example, the following will return a list containing a map with \"1\"=\"true\":\n     * \n     *   {@code Object result = resolveDeepValue(ImmutableList.of(ImmutableMap.of(1, true)), String.class, exec)} \n     * \n     * This differs from {@link #resolveValue(Object, Class, ExecutionContext, String)} mainly in its \n     * use of generics and its return type. Even though the {@link #resolveValue(Object, Class, ExecutionContext, String)}\n     * method does \"deep\" conversion of futures contained within iterables/maps, the return type implies\n     * that it is the top-level object that should be coerced. For example, the following will try to return a String, \n     * when in fact it is a map, giving a {@link ClassCastException}.\n     * \n     *   {@code String result = resolveValue(ImmutableList.of(ImmutableMap.of(1, true)), String.class, exec)}\n     *   \n     * The one other difference of note is that this forces the resolution to go deep when the type is vague,\n     * e.g. if the requested type is an Object, {@link #resolveValue(Object, Class, ExecutionContext, String)}\n     * will decide that it matches a Map and not recurse on it, whereas this will recurse on it.\n     */\n    public static Object resolveDeepValue(Object v, Class<?> type, ExecutionContext exec, String contextMessage) throws ExecutionException, InterruptedException {\n        return resolveValue(v, type, exec, contextMessage, true);\n    }","id":71294,"modified_method":"/**\n     * Resolves the given object, blocking on futures and coercing it to the given type. If the object is a \n     * map or iterable (or a list of map of maps, etc, etc) then walks these maps/iterables to convert all of \n     * their values to the given type. For example, the following will return a list containing a map with \"1\"=\"true\":\n     * \n     *   {@code Object result = resolveDeepValue(ImmutableList.of(ImmutableMap.of(1, true)), String.class, exec)} \n     * \n     * This differs from {@link #resolveValue(Object, Class, ExecutionContext, String)} mainly in its \n     * use of generics and its return type. Even though the {@link #resolveValue(Object, Class, ExecutionContext, String)}\n     * method does \"deep\" conversion of futures contained within iterables/maps, the return type implies\n     * that it is the top-level object that should be coerced. For example, the following will try to return a String, \n     * when in fact it is a map, giving a {@link ClassCastException}.\n     * \n     *   {@code String result = resolveValue(ImmutableList.of(ImmutableMap.of(1, true)), String.class, exec)}\n     *   \n     * The one other difference of note is that this forces the resolution to go deep when the type is vague,\n     * e.g. if the requested type is an Object, {@link #resolveValue(Object, Class, ExecutionContext, String)}\n     * will decide that it matches a Map and not recurse on it, whereas this will recurse on it.\n     */\n    public static <T> T resolveDeepValue(Object v, Class<T> type, ExecutionContext exec, String contextMessage) throws ExecutionException, InterruptedException {\n        return new ValueResolver<T>(v, type).context(exec).deep(true).description(contextMessage).get();\n    }","commit_id":"05a39488dca27887f563c20ad1110ed3916c25f5","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n   * Grab the open-file info from namenode\n   */\n  synchronized void openInfo() throws IOException, UnresolvedLinkException {\n    LocatedBlocks newInfo = DFSClient.callGetBlockLocations(dfsClient.namenode, src, 0, prefetchSize);\n    if (DFSClient.LOG.isDebugEnabled()) {\n      DFSClient.LOG.debug(\"newInfo = \" + newInfo);\n    }\n    if (newInfo == null) {\n      throw new IOException(\"Cannot open filename \" + src);\n    }\n\n    if (locatedBlocks != null) {\n      Iterator<LocatedBlock> oldIter = locatedBlocks.getLocatedBlocks().iterator();\n      Iterator<LocatedBlock> newIter = newInfo.getLocatedBlocks().iterator();\n      while (oldIter.hasNext() && newIter.hasNext()) {\n        if (! oldIter.next().getBlock().equals(newIter.next().getBlock())) {\n          throw new IOException(\"Blocklist for \" + src + \" has changed!\");\n        }\n      }\n    }\n    locatedBlocks = newInfo;\n    lastBlockBeingWrittenLength = 0;\n    if (!locatedBlocks.isLastBlockComplete()) {\n      final LocatedBlock last = locatedBlocks.getLastLocatedBlock();\n      if (last != null) {\n        final long len = readBlockLength(last);\n        last.getBlock().setNumBytes(len);\n        lastBlockBeingWrittenLength = len; \n      }\n    }\n\n    currentNode = null;\n  }","id":71295,"modified_method":"/**\n   * Grab the open-file info from namenode\n   */\n  synchronized void openInfo() throws IOException, UnresolvedLinkException {\n    lastBlockBeingWrittenLength = fetchLocatedBlocksAndGetLastBlockLength();\n    int retriesForLastBlockLength = 3;\n    while (retriesForLastBlockLength > 0) {\n      // Getting last block length as -1 is a special case. When cluster\n      // restarts, DNs may not report immediately. At this time partial block\n      // locations will not be available with NN for getting the length. Lets\n      // retry for 3 times to get the length.\n      if (lastBlockBeingWrittenLength == -1) {\n        DFSClient.LOG.warn(\"Last block locations not available. \"\n            + \"Datanodes might not have reported blocks completely.\"\n            + \" Will retry for \" + retriesForLastBlockLength + \" times\");\n        waitFor(4000);\n        lastBlockBeingWrittenLength = fetchLocatedBlocksAndGetLastBlockLength();\n      } else {\n        break;\n      }\n      retriesForLastBlockLength--;\n    }\n    if (retriesForLastBlockLength == 0) {\n      throw new IOException(\"Could not obtain the last block locations.\");\n    }\n  }","commit_id":"d28b98242854ff7f9d615e1c9d6a5b7584ce2498","url":"https://github.com/apache/hadoop"},{"original_method":"/** Read the block length from one of the datanodes. */\n  private long readBlockLength(LocatedBlock locatedblock) throws IOException {\n    if (locatedblock == null || locatedblock.getLocations().length == 0) {\n      return 0;\n    }\n    int replicaNotFoundCount = locatedblock.getLocations().length;\n    \n    for(DatanodeInfo datanode : locatedblock.getLocations()) {\n      ClientDatanodeProtocol cdp = null;\n      \n      try {\n        cdp = DFSUtil.createClientDatanodeProtocolProxy(\n        datanode, dfsClient.conf, dfsClient.getConf().socketTimeout, locatedblock);\n        \n        final long n = cdp.getReplicaVisibleLength(locatedblock.getBlock());\n        \n        if (n >= 0) {\n          return n;\n        }\n      }\n      catch(IOException ioe) {\n        if (ioe instanceof RemoteException &&\n          (((RemoteException) ioe).unwrapRemoteException() instanceof\n            ReplicaNotFoundException)) {\n          // special case : replica might not be on the DN, treat as 0 length\n          replicaNotFoundCount--;\n        }\n        \n        if (DFSClient.LOG.isDebugEnabled()) {\n          DFSClient.LOG.debug(\"Failed to getReplicaVisibleLength from datanode \"\n              + datanode + \" for block \" + locatedblock.getBlock(), ioe);\n        }\n      } finally {\n        if (cdp != null) {\n          RPC.stopProxy(cdp);\n        }\n      }\n    }\n\n    // Namenode told us about these locations, but none know about the replica\n    // means that we hit the race between pipeline creation start and end.\n    // we require all 3 because some other exception could have happened\n    // on a DN that has it.  we want to report that error\n    if (replicaNotFoundCount == 0) {\n      return 0;\n    }\n\n    throw new IOException(\"Cannot obtain block length for \" + locatedblock);\n  }","id":71296,"modified_method":"/** Read the block length from one of the datanodes. */\n  private long readBlockLength(LocatedBlock locatedblock) throws IOException {\n    assert locatedblock != null : \"LocatedBlock cannot be null\";\n    int replicaNotFoundCount = locatedblock.getLocations().length;\n    \n    for(DatanodeInfo datanode : locatedblock.getLocations()) {\n      ClientDatanodeProtocol cdp = null;\n      \n      try {\n        cdp = DFSUtil.createClientDatanodeProtocolProxy(\n        datanode, dfsClient.conf, dfsClient.getConf().socketTimeout, locatedblock);\n        \n        final long n = cdp.getReplicaVisibleLength(locatedblock.getBlock());\n        \n        if (n >= 0) {\n          return n;\n        }\n      }\n      catch(IOException ioe) {\n        if (ioe instanceof RemoteException &&\n          (((RemoteException) ioe).unwrapRemoteException() instanceof\n            ReplicaNotFoundException)) {\n          // special case : replica might not be on the DN, treat as 0 length\n          replicaNotFoundCount--;\n        }\n        \n        if (DFSClient.LOG.isDebugEnabled()) {\n          DFSClient.LOG.debug(\"Failed to getReplicaVisibleLength from datanode \"\n              + datanode + \" for block \" + locatedblock.getBlock(), ioe);\n        }\n      } finally {\n        if (cdp != null) {\n          RPC.stopProxy(cdp);\n        }\n      }\n    }\n\n    // Namenode told us about these locations, but none know about the replica\n    // means that we hit the race between pipeline creation start and end.\n    // we require all 3 because some other exception could have happened\n    // on a DN that has it.  we want to report that error\n    if (replicaNotFoundCount == 0) {\n      return 0;\n    }\n\n    throw new IOException(\"Cannot obtain block length for \" + locatedblock);\n  }","commit_id":"d28b98242854ff7f9d615e1c9d6a5b7584ce2498","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * Entry point for saving an editing context in a tolerant\n     * manner. The two flags for this methad are <code>writeAnyWay<\/code>\n     * and <code>merge<\/code>. The writeAnyWay flag controls if a second\n     * save should be performed if the first operation fails due to a general\n     * adaptor operation. Note that even if this option is specified as\n     * false the object will be refetched and optionally have the new changes\n     * merged into. This means that the objects that failed saving to the\n     * database will be ready to be saved if writeAnyWay is false. The second\n     * option is to merge the previous changes if a failure occurs. If this\n     * is set to true then when a locking failure occurs the object is refetched\n     * and then the previous changes are re-applied to the object.\n     * @param ec editing context to be saved\n     * @param writeAnyWay boolean flag to determine if an editing context should\n     *\t\tbe saved again after a failure.\n     * @param merge boolean flag that determines if changes should be re-applied\n     *\t\tif a locking failure occurs when the first save happens\n     * @return string indicating the exception that happened, null if everything\n     *\t\twent smooth. This should be changed in the future.\n     */\n    // FIXME: returning those strings for error conditions is not very good\n    // we should probably return ints for status and re-throw the original exception\n    // in some cases\n    public static String _save(EOEditingContext ec, boolean writeAnyWay, boolean merge) {\n        if (log.isDebugEnabled()) log.debug(\"TolerantSaver: save...\");\n        try {\n            //if (log.isDebugEnabled()) log.debug(\"about to save changes...\");\n            ec.saveChanges();\n        } catch(NSValidation.ValidationException eov) {\n            log.info(\"TolerantSaver: Caught EOValidationException: \" + eov.getMessage());\n        } catch(EOGeneralAdaptorException e) {\n            EOEnterpriseObject failedEO;\n            NSDictionary userInfo = (NSDictionary)e.userInfo();\n            //if (log.isDebugEnabled()) log.debug(\"TolerantSaver: Exception occurred name: \"+ eName);\n            //if (log.isDebugEnabled()) log.debug(\"Exception occurred e: -------------------------\");\n            //if (log.isDebugEnabled()) log.debug(\"Exception occurred e: \"+e);\n            //if (log.isDebugEnabled()) log.debug(\"Exception occurred userInfo: \"+ userInfo);\n            //if (log.isDebugEnabled()) log.debug(\"Exception occurred e: ^^^^^^^^^^^^^^^^^^^^^^^^^\");\n            if(!(userInfo == null)) {\n                String eType = (String)userInfo.objectForKey(\"EOAdaptorFailureKey\");\n                if (!(eType == null)) {\n                    if (eType.equals(\"EOAdaptorOptimisticLockingFailure\")) {\n                        //if (log.isDebugEnabled()) log.debug(\"about to get EOFailedAdaptorOperationKey\");\n                        EOAdaptorOperation op = (EOAdaptorOperation) userInfo.objectForKey(\"EOFailedAdaptorOperationKey\");\n                        EODatabaseOperation dbop = (EODatabaseOperation) userInfo.objectForKey(\"EOFailedDatabaseOperationKey\");\n                        //if (log.isDebugEnabled()) log.debug(\"about to get _changedValues\");\n                        if (op != null && dbop != null) {\n                            NSDictionary changedValues =  op.changedValues();\n                            //if (log.isDebugEnabled()) log.debug(\"about to get _entity: _changedValues\"+ changedValues);\n                            NSDictionary snapshot = dbop.dbSnapshot();\n                            if (log.isDebugEnabled()) log.debug(\"snapshot\"+ snapshot);\n                            EOEntity ent = op.entity();\n                            String entName = ent.name();\n                            if (log.isDebugEnabled()) log.debug(\"entName\"+ entName);\n                            NSArray pkAttribs = ent.primaryKeyAttributes();\n                            EOQualifier qual = ERXTolerantSaver.qualifierWithSnapshotAndPks(pkAttribs, snapshot);\n                            EOFetchSpecification fs = new EOFetchSpecification(entName, qual, null);\n                            fs.setRefreshesRefetchedObjects(true);\n                            NSArray objs = ec.objectsWithFetchSpecification(fs);\n                            if (objs.count() > 0) {\n                                failedEO = (EOEnterpriseObject) objs.objectAtIndex(0);\n                                if (log.isDebugEnabled()) log.debug(\"failedEO\"+ failedEO);\n                                if (merge) {\n                                    //EODatabaseContext dbcontext = ChangeCatcher.databaseContextForEntityNamed (entName, ec);\n                                    //EODatabase db = dbcontext.database();\n                                    //EOGlobalID gid = ec.globalIDForObject(failedEO);\n                                    //NSMutableDictionary ss = new NSMutableDictionary(snapshot);\n                                    //ss. addEntriesFromDictionary(changedValues);\n                                    //db.forgetSnapshotForGlobalID(gid);\n                                    //db.recordSnapshotForGlobalID(ss, gid);\n                                    applyChangesToEO(changedValues, failedEO, ent);\n                                }\n                            } else {\n                                if (log.isDebugEnabled()) log.debug(\"TolerantSaver: EO was NOT there anymore!\");\n                                failedEO = null;\n                            }\n                            if (writeAnyWay) {\n                                if (log.isDebugEnabled()) log.debug(\"TolerantSaver: about to save changes again\");\n                                save(ec, writeAnyWay, merge);                                    \n                            }\n                            return \"EOAdaptorOptimisticLockingFailure\";\n                        } else {\n                            log.error(\"Missing EOFailedAdaptorOperationKey or EOFailedDatabaseOperationKey. \"+e+\"\\n\\n\"+e.userInfo());\n                        }\n                    }                    \n                } else {\n//                    log.error(\"TolerantSaver: No EOAdaptorFailureKey Exception:\" + e);\n                    String error = \"Error: No EOAdaptorFailureKey, reason \";\n                    error += errorFromException(e);\n                    log.error(\"TolerantSaver: UserInfo = \"+userInfo+\", exception: \", e);\n                    return error;\n                }\n            } else {\n                log.error(\"TolerantSaver: No UserInfo: \", e);\n                return \"Error: No UserInfo\";\n            }\n        }\n        if (log.isDebugEnabled()) log.debug(\"TolerantSaver: save... done\");\n        return null;\n    }","id":71297,"modified_method":"/**\n     * Entry point for saving an editing context in a tolerant\n     * manner. The two flags for this methad are <code>writeAnyWay<\/code>\n     * and <code>merge<\/code>. The writeAnyWay flag controls if a second\n     * save should be performed if the first operation fails due to a general\n     * adaptor operation. Note that even if this option is specified as\n     * false the object will be refetched and optionally have the new changes\n     * merged into. This means that the objects that failed saving to the\n     * database will be ready to be saved if writeAnyWay is false. The second\n     * option is to merge the previous changes if a failure occurs. If this\n     * is set to true then when a locking failure occurs the object is refetched\n     * and then the previous changes are re-applied to the object.\n     * @param ec editing context to be saved\n     * @param writeAnyWay boolean flag to determine if an editing context should\n     *\t\tbe saved again after a failure.\n     * @param merge boolean flag that determines if changes should be re-applied\n     *\t\tif a locking failure occurs when the first save happens\n     * @return string indicating the exception that happened, null if everything\n     *\t\twent smooth. This should be changed in the future.\n     */\n    // FIXME: returning those strings for error conditions is not very good\n    // we should probably return ints for status and re-throw the original exception\n    // in some cases\n    public static String _save(EOEditingContext ec, boolean writeAnyWay, boolean merge) {\n        if (log.isDebugEnabled()) log.debug(\"TolerantSaver: save...\");\n        try {\n            //if (log.isDebugEnabled()) log.debug(\"about to save changes...\");\n            ec.saveChanges();\n        } catch(NSValidation.ValidationException eov) {\n            log.info(\"TolerantSaver: Caught EOValidationException: \" + eov.getMessage());\n        } catch(EOGeneralAdaptorException e) {\n            EOEnterpriseObject failedEO;\n            NSDictionary userInfo = (NSDictionary)e.userInfo();\n            log.warn(\"TolerantSaver: Exception occurred: \"+ e);\n            log.warn(\"Exception occurred e: -------------------------\");\n//            if (log.isDebugEnabled()) log.debug(\"Exception occurred e: \"+e);\n            log.warn(\"Exception occurred userInfo: \"+ userInfo);\n            log.warn(\"Exception occurred e: ^^^^^^^^^^^^^^^^^^^^^^^^^\");\n            if(!(userInfo == null)) {\n                String eType = (String)userInfo.objectForKey(\"EOAdaptorFailureKey\");\n                if (!(eType == null)) {\n                    if (eType.equals(\"EOAdaptorOptimisticLockingFailure\")) {\n                        //if (log.isDebugEnabled()) log.debug(\"about to get EOFailedAdaptorOperationKey\");\n                        EOAdaptorOperation op = (EOAdaptorOperation) userInfo.objectForKey(\"EOFailedAdaptorOperationKey\");\n                        EODatabaseOperation dbop = (EODatabaseOperation) userInfo.objectForKey(\"EOFailedDatabaseOperationKey\");\n                        //if (log.isDebugEnabled()) log.debug(\"about to get _changedValues\");\n                        if (op != null && dbop != null) {\n                            NSDictionary changedValues =  op.changedValues();\n                            //if (log.isDebugEnabled()) log.debug(\"about to get _entity: _changedValues\"+ changedValues);\n                            NSDictionary snapshot = dbop.dbSnapshot();\n                            if (log.isDebugEnabled()) log.debug(\"snapshot\"+ snapshot);\n                            EOEntity ent = op.entity();\n                            String entName = ent.name();\n                            if (log.isDebugEnabled()) log.debug(\"entName\"+ entName);\n                            NSArray pkAttribs = ent.primaryKeyAttributes();\n                            EOQualifier qual = ERXTolerantSaver.qualifierWithSnapshotAndPks(pkAttribs, snapshot);\n                            EOFetchSpecification fs = new EOFetchSpecification(entName, qual, null);\n                            fs.setRefreshesRefetchedObjects(true);\n                            NSArray objs = ec.objectsWithFetchSpecification(fs);\n                            if (objs.count() > 0) {\n                                failedEO = (EOEnterpriseObject) objs.objectAtIndex(0);\n                                if (log.isDebugEnabled()) log.debug(\"failedEO\"+ failedEO);\n                                if (merge) {\n                                    //EODatabaseContext dbcontext = ChangeCatcher.databaseContextForEntityNamed (entName, ec);\n                                    //EODatabase db = dbcontext.database();\n                                    //EOGlobalID gid = ec.globalIDForObject(failedEO);\n                                    //NSMutableDictionary ss = new NSMutableDictionary(snapshot);\n                                    //ss. addEntriesFromDictionary(changedValues);\n                                    //db.forgetSnapshotForGlobalID(gid);\n                                    //db.recordSnapshotForGlobalID(ss, gid);\n                                    applyChangesToEO(changedValues, failedEO, ent);\n                                }\n                            } else {\n                                if (log.isDebugEnabled()) log.debug(\"TolerantSaver: EO was NOT there anymore!\");\n                                failedEO = null;\n                            }\n                            if (writeAnyWay) {\n                                log.warn(\"TolerantSaver: about to save changes again\");\n                                save(ec, writeAnyWay, merge);                                    \n                            }\n                            return \"EOAdaptorOptimisticLockingFailure\";\n                        } else {\n                            log.error(\"Missing EOFailedAdaptorOperationKey or EOFailedDatabaseOperationKey. \"+e+\"\\n\\n\"+e.userInfo());\n                        }\n                    }                    \n                } else {\n//                    log.error(\"TolerantSaver: No EOAdaptorFailureKey Exception:\" + e);\n                    String error = \"Error: No EOAdaptorFailureKey, reason \";\n                    error += errorFromException(e);\n                    log.error(\"TolerantSaver: UserInfo = \"+userInfo+\", exception: \", e);\n                    return error;\n                }\n            } else {\n                log.error(\"TolerantSaver: No UserInfo: \", e);\n                return \"Error: No UserInfo\";\n            }\n        }\n        if (log.isDebugEnabled()) log.debug(\"TolerantSaver: save... done\");\n        return null;\n    }","commit_id":"5ea6946cec72d335e8e720b9fe7aab3806fbe38d","url":"https://github.com/wocommunity/wonder"},{"original_method":"protected <T> org.eclipse.xtext.common.types.JvmConstructor createConstructor(Constructor<T> constructor) {\n\t\tJvmConstructor result = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tClass<T> declaringClass = constructor.getDeclaringClass();\n\t\tint offset = 0;\n\t\tif (declaringClass.isEnum()) {\n\t\t\toffset = 2;\n\t\t} else if (declaringClass.isMemberClass() && !Modifier.isStatic(declaringClass.getModifiers())) {\n\t\t\toffset = 1;\n\t\t}\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = constructor.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t}\n\t\tif (offset != 0) {\n\t\t\t/*\n\t\t\t * #getGenericParameterTypes may return a different number of parameters\n\t\t\t * for inner classes then #getParameterTypes does. This happens for\n\t\t\t * signatures that are parameterized, e.g.\n\t\t\t * \n\t\t\t * <pre>\n\t\t\t * \n\t\t\t * class WrappedCollection<V> .. {\n\t\t\t *   class WrappedIterator implements Iterator<V> {\n\t\t\t *     WrappedIterator(Iterator<V> iterator) { .. }\n\t\t\t *   }\n\t\t\t * }\n\t\t\t * \n\t\t\t * <\/pre>\n\t\t\t * \n\t\t\t * Therefore we adjust the offset here\n\t\t\t */\n\t\t\tif (constructor.getParameterTypes().length != genericParameterTypes.length) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tenhanceGenericDeclaration(result, constructor);\n\t\tenhanceExecutable(result, constructor, constructor.getDeclaringClass().getSimpleName(),\n\t\t\t\tgenericParameterTypes, constructor.getParameterAnnotations(), offset);\n\t\tresult.setVarArgs(constructor.isVarArgs());\n\t\tfor (Type parameterType : constructor.getGenericExceptionTypes()) {\n\t\t\tresult.getExceptions().add(createTypeReference(parameterType));\n\t\t}\n\t\tcreateAnnotationValues(constructor, result);\n\t\treturn result;\n\t}","id":71298,"modified_method":"protected <T> org.eclipse.xtext.common.types.JvmConstructor createConstructor(Constructor<T> constructor) {\n\t\tJvmConstructor result = TypesFactory.eINSTANCE.createJvmConstructor();\n\t\tClass<T> declaringClass = constructor.getDeclaringClass();\n\t\tint offset = 0;\n\t\tif (declaringClass.isEnum()) {\n\t\t\toffset = 2;\n\t\t} else if (declaringClass.isMemberClass() && !Modifier.isStatic(declaringClass.getModifiers())) {\n\t\t\toffset = 1;\n\t\t}\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = constructor.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + constructor.getDeclaringClass().getCanonicalName(), error);\n\t\t\tgenericParameterTypes = constructor.getParameterTypes();\n\t\t}\n\t\tif (offset != 0) {\n\t\t\t/*\n\t\t\t * #getGenericParameterTypes may return a different number of parameters\n\t\t\t * for inner classes then #getParameterTypes does. This happens for\n\t\t\t * signatures that are parameterized, e.g.\n\t\t\t * \n\t\t\t * <pre>\n\t\t\t * \n\t\t\t * class WrappedCollection<V> .. {\n\t\t\t *   class WrappedIterator implements Iterator<V> {\n\t\t\t *     WrappedIterator(Iterator<V> iterator) { .. }\n\t\t\t *   }\n\t\t\t * }\n\t\t\t * \n\t\t\t * <\/pre>\n\t\t\t * \n\t\t\t * Therefore we adjust the offset here\n\t\t\t */\n\t\t\tif (constructor.getParameterTypes().length != genericParameterTypes.length) {\n\t\t\t\toffset = 0;\n\t\t\t}\n\t\t}\n\t\tenhanceGenericDeclaration(result, constructor);\n\t\tenhanceExecutable(result, constructor, constructor.getDeclaringClass().getSimpleName(),\n\t\t\t\tgenericParameterTypes, constructor.getParameterAnnotations(), offset);\n\t\tresult.setVarArgs(constructor.isVarArgs());\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = constructor.getGenericExceptionTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + constructor.getDeclaringClass().getCanonicalName(), error);\n\t\t\texceptionTypes = constructor.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(constructor, result);\n\t\treturn result;\n\t}","commit_id":"72eed91add2990479bbcabc4b7694eb2778c7a93","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmField createField(Field field) {\n\t\tJvmField result;\n\t\tif (!field.isEnumConstant())\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmField();\n\t\telse\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmEnumerationLiteral();\n\t\tresult.internalSetIdentifier(field.getDeclaringClass().getName() + \".\" + field.getName());\n\t\tresult.setSimpleName(field.getName());\n\t\tresult.setFinal(Modifier.isFinal(field.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(field.getModifiers()));\n\t\tsetVisibility(result, field.getModifiers());\n\t\tresult.setType(createTypeReference(field.getGenericType()));\n\t\tcreateAnnotationValues(field, result);\n\t\treturn result;\n\t}","id":71299,"modified_method":"protected JvmField createField(Field field) {\n\t\tJvmField result;\n\t\tif (!field.isEnumConstant())\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmField();\n\t\telse\n\t\t\tresult = TypesFactory.eINSTANCE.createJvmEnumerationLiteral();\n\t\tresult.internalSetIdentifier(field.getDeclaringClass().getName() + \".\" + field.getName());\n\t\tresult.setSimpleName(field.getName());\n\t\tresult.setFinal(Modifier.isFinal(field.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(field.getModifiers()));\n\t\tsetVisibility(result, field.getModifiers());\n\t\tType fieldType = null;\n\t\ttry {\n\t\t\tfieldType = field.getGenericType();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + field.getDeclaringClass().getCanonicalName(), error);\n\t\t\tfieldType = field.getType();\n\t\t}\n\t\tresult.setType(createTypeReference(fieldType));\n\t\tcreateAnnotationValues(field, result);\n\t\treturn result;\n\t}","commit_id":"72eed91add2990479bbcabc4b7694eb2778c7a93","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void setSuperTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\ttry {\n\t\t\tif (clazz.getGenericSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getGenericSuperclass()));\n\t\t\t}\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getSuperclass()));\n\t\t\t}\n\t\t}\n\t\tType[] interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = clazz.getGenericInterfaces();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t}\n\t\tfor (Type type : interfaces) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(type));\n\t\t}\n\t\tif (result.getSuperTypes().isEmpty() && !Object.class.equals(clazz)) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(Object.class));\n\t\t}\n\t}","id":71300,"modified_method":"protected void setSuperTypes(Class<?> clazz, JvmDeclaredType result) {\n\t\ttry {\n\t\t\tif (clazz.getGenericSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getGenericSuperclass()));\n\t\t\t}\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + clazz.getCanonicalName(), error);\n\t\t\tif (clazz.getSuperclass() != null) {\n\t\t\t\tresult.getSuperTypes().add(createTypeReference(clazz.getSuperclass()));\n\t\t\t}\n\t\t}\n\t\tType[] interfaces = null;\n\t\ttry {\n\t\t\tinterfaces = clazz.getGenericInterfaces();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + clazz.getCanonicalName(), error);\n\t\t\tinterfaces = clazz.getInterfaces();\n\t\t}\n\t\tfor (Type type : interfaces) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(type));\n\t\t}\n\t\tif (result.getSuperTypes().isEmpty() && !Object.class.equals(clazz)) {\n\t\t\tresult.getSuperTypes().add(createTypeReference(Object.class));\n\t\t}\n\t}","commit_id":"72eed91add2990479bbcabc4b7694eb2778c7a93","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Creates a new {@link JvmDeclaredType type} from the given class.\n\t * @noreference This method is not intended to be referenced by clients.\n\t */\n\tpublic JvmDeclaredType createType(final Class<?> clazz) {\n\t\ttry {\n\t\t\tcreateTypeTask.start();\n\t\t\tif (clazz.isAnonymousClass() || clazz.isSynthetic())\n\t\t\t\tthrow new IllegalStateException(\"Cannot create type for anonymous or synthetic classes\");\n\t\t\tif (clazz.isAnnotation())\n\t\t\t\treturn createAnnotationType(clazz);\n\t\t\tif (clazz.isEnum())\n\t\t\t\treturn createEnumerationType(clazz);\n\t\n\t\t\tfinal JvmGenericType result = TypesFactory.eINSTANCE.createJvmGenericType();\n\t\t\tresult.setInterface(clazz.isInterface());\n\t\t\tsetTypeModifiers(clazz, result);\n\t\t\tsetVisibility(clazz, result);\n\t\t\tresult.internalSetIdentifier(clazz.getName());\n\t\t\tresult.setSimpleName(clazz.getSimpleName());\n\t\t\tif (clazz.getDeclaringClass() == null && clazz.getPackage() != null)\n\t\t\t\tresult.setPackageName(clazz.getPackage().getName());\n\t\t\t\n\t\t\tcreateNestedTypes(clazz, result);\n\t\t\tcreateMethods(clazz, result);\n\t\t\tcreateConstructors(clazz, result);\n\t\t\tcreateFields(clazz, result);\n\t\t\t\n\t\t\tsetSuperTypes(clazz, result);\n\t\t\ttry {\n\t\t\t\tfor (TypeVariable<?> variable : clazz.getTypeParameters()) {\n\t\t\t\t\tresult.getTypeParameters().add(createTypeParameter(variable, result));\n\t\t\t\t}\n\t\t\t} catch(GenericSignatureFormatError error) {\n\t\t\t\tif (log.isDebugEnabled())\n\t\t\t\t\tlog.debug(\"Invalid class file for: \" + result.getIdentifier(), error);\n\t\t\t}\n\t\t\tcreateAnnotationValues(clazz, result);\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tcreateTypeTask.stop();\n\t\t}\n\t}","id":71301,"modified_method":"/**\n\t * Creates a new {@link JvmDeclaredType type} from the given class.\n\t * @noreference This method is not intended to be referenced by clients.\n\t */\n\tpublic JvmDeclaredType createType(final Class<?> clazz) {\n\t\ttry {\n\t\t\tcreateTypeTask.start();\n\t\t\tif (clazz.isAnonymousClass() || clazz.isSynthetic())\n\t\t\t\tthrow new IllegalStateException(\"Cannot create type for anonymous or synthetic classes\");\n\t\t\tif (clazz.isAnnotation())\n\t\t\t\treturn createAnnotationType(clazz);\n\t\t\tif (clazz.isEnum())\n\t\t\t\treturn createEnumerationType(clazz);\n\t\n\t\t\tfinal JvmGenericType result = TypesFactory.eINSTANCE.createJvmGenericType();\n\t\t\tresult.setInterface(clazz.isInterface());\n\t\t\tsetTypeModifiers(clazz, result);\n\t\t\tsetVisibility(clazz, result);\n\t\t\tresult.internalSetIdentifier(clazz.getName());\n\t\t\tresult.setSimpleName(clazz.getSimpleName());\n\t\t\tif (clazz.getDeclaringClass() == null && clazz.getPackage() != null)\n\t\t\t\tresult.setPackageName(clazz.getPackage().getName());\n\t\t\t\n\t\t\tcreateNestedTypes(clazz, result);\n\t\t\tcreateMethods(clazz, result);\n\t\t\tcreateConstructors(clazz, result);\n\t\t\tcreateFields(clazz, result);\n\t\t\t\n\t\t\tsetSuperTypes(clazz, result);\n\t\t\ttry {\n\t\t\t\tfor (TypeVariable<?> variable : clazz.getTypeParameters()) {\n\t\t\t\t\tresult.getTypeParameters().add(createTypeParameter(variable, result));\n\t\t\t\t}\n\t\t\t} catch(GenericSignatureFormatError error) {\n\t\t\t\tlog.warn(\"Invalid class file for: \" + result.getIdentifier(), error);\n\t\t\t}\n\t\t\tcreateAnnotationValues(clazz, result);\n\t\t\treturn result;\n\t\t} finally {\n\t\t\tcreateTypeTask.stop();\n\t\t}\n\t}","commit_id":"72eed91add2990479bbcabc4b7694eb2778c7a93","url":"https://github.com/eclipse/xtext"},{"original_method":"protected JvmOperation createOperation(Method method) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = method.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t}\n\t\tenhanceGenericDeclaration(result, method);\n\t\tenhanceExecutable(result, method, method.getName(), genericParameterTypes, method.getParameterAnnotations(), 0);\n\t\tresult.setVarArgs(method.isVarArgs());\n\t\tresult.setAbstract(Modifier.isAbstract(method.getModifiers()));\n\t\tresult.setFinal(Modifier.isFinal(method.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(method.getModifiers()));\n\t\tType returnType = null;\n\t\ttry {\n\t\t\treturnType = method.getGenericReturnType();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\treturnType = method.getReturnType();\n\t\t}\n\t\tresult.setReturnType(createTypeReference(returnType));\n\t\tfor (Type parameterType : method.getGenericExceptionTypes()) {\n\t\t\tresult.getExceptions().add(createTypeReference(parameterType));\n\t\t}\n\t\tcreateAnnotationValues(method, result);\n\t\treturn result;\n\t}","id":71302,"modified_method":"protected JvmOperation createOperation(Method method) {\n\t\tJvmOperation result = TypesFactory.eINSTANCE.createJvmOperation();\n\t\tType[] genericParameterTypes = null;\n\t\ttry {\n\t\t\tgenericParameterTypes = method.getGenericParameterTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + method.getDeclaringClass().getCanonicalName(), error);\n\t\t\tgenericParameterTypes = method.getParameterTypes();\n\t\t}\n\t\tenhanceGenericDeclaration(result, method);\n\t\tenhanceExecutable(result, method, method.getName(), genericParameterTypes, method.getParameterAnnotations(), 0);\n\t\tresult.setVarArgs(method.isVarArgs());\n\t\tresult.setAbstract(Modifier.isAbstract(method.getModifiers()));\n\t\tresult.setFinal(Modifier.isFinal(method.getModifiers()));\n\t\tresult.setStatic(Modifier.isStatic(method.getModifiers()));\n\t\tType returnType = null;\n\t\ttry {\n\t\t\treturnType = method.getGenericReturnType();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + method.getDeclaringClass().getCanonicalName(), error);\n\t\t\treturnType = method.getReturnType();\n\t\t}\n\t\tresult.setReturnType(createTypeReference(returnType));\n\t\tType[] exceptionTypes;\n\t\ttry {\n\t\t\texceptionTypes = method.getGenericExceptionTypes();\n\t\t} catch(GenericSignatureFormatError error) {\n\t\t\tlog.warn(\"Invalid class file for: \" + method.getDeclaringClass().getCanonicalName(), error);\n\t\t\texceptionTypes = method.getExceptionTypes();\n\t\t}\n\t\tfor (Type exceptionType : exceptionTypes) {\n\t\t\tresult.getExceptions().add(createTypeReference(exceptionType));\n\t\t}\n\t\tcreateAnnotationValues(method, result);\n\t\treturn result;\n\t}","commit_id":"72eed91add2990479bbcabc4b7694eb2778c7a93","url":"https://github.com/eclipse/xtext"},{"original_method":"protected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString className = activity.getClassName();\n\t\tlong classPK = activity.getClassPK();\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tif ((trashHandler != null) &&\n\t\t\t(trashHandler.isInTrash(classPK) ||\n\t\t\t trashHandler.isInTrashContainer(classPK))) {\n\n\t\t\tPortletURL portletURL = TrashUtil.getViewContentURL(\n\t\t\t\tserviceContext.getRequest(), className, classPK);\n\n\t\t\tif (portletURL == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\n\t\tString path = getPath(activity, serviceContext);\n\n\t\tif (Validator.isNull(path)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpath = addNoSuchEntryRedirect(path, className, classPK, serviceContext);\n\n\t\tif (!path.startsWith(StringPool.SLASH)) {\n\t\t\treturn path;\n\t\t}\n\n\t\treturn serviceContext.getPortalURL() + serviceContext.getPathMain() +\n\t\t\tpath;\n\t}","id":71303,"modified_method":"protected String getLink(\n\t\t\tSocialActivity activity, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tString className = activity.getClassName();\n\t\tlong classPK = activity.getClassPK();\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tif ((trashHandler != null) && trashHandler.isInTrash(classPK)) {\n\t\t\tPortletURL portletURL = TrashUtil.getViewContentURL(\n\t\t\t\tserviceContext.getRequest(), className, classPK);\n\n\t\t\tif (portletURL == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn portletURL.toString();\n\t\t}\n\n\t\tString path = getPath(activity, serviceContext);\n\n\t\tif (Validator.isNull(path)) {\n\t\t\treturn null;\n\t\t}\n\n\t\tpath = addNoSuchEntryRedirect(path, className, classPK, serviceContext);\n\n\t\tif (!path.startsWith(StringPool.SLASH)) {\n\t\t\treturn path;\n\t\t}\n\n\t\treturn serviceContext.getPortalURL() + serviceContext.getPathMain() +\n\t\t\tpath;\n\t}","commit_id":"3864a8a79aad158cc0bbf99f29e1ebcb25d669c4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void validateExport(\n\t\t\tPortletDataContext portletDataContext, T stagedModel)\n\t\tthrows PortletDataException {\n\n\t\tif (stagedModel instanceof WorkflowedModel) {\n\t\t\tWorkflowedModel workflowedModel = (WorkflowedModel)stagedModel;\n\n\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\tgetExportableStatuses(), workflowedModel.getStatus())) {\n\n\t\t\t\tthrow new PortletDataException(\n\t\t\t\t\tPortletDataException.STATUS_UNAVAILABLE);\n\t\t\t}\n\t\t}\n\n\t\tStagedModelType stagedModelType = stagedModel.getStagedModelType();\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tstagedModelType.getClassName());\n\n\t\tif (trashHandler != null) {\n\t\t\ttry {\n\t\t\t\tlong classPK = (Long)stagedModel.getPrimaryKeyObj();\n\n\t\t\t\tif (trashHandler.isInTrash(classPK) ||\n\t\t\t\t\ttrashHandler.isInTrashContainer(classPK)) {\n\n\t\t\t\t\tthrow new PortletDataException(\n\t\t\t\t\t\tPortletDataException.STATUS_IN_TRASH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (PortletDataException pde) {\n\t\t\t\tthrow pde;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to check trash status for \" +\n\t\t\t\t\t\t\tstagedModel.getModelClassName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":71304,"modified_method":"protected void validateExport(\n\t\t\tPortletDataContext portletDataContext, T stagedModel)\n\t\tthrows PortletDataException {\n\n\t\tif (stagedModel instanceof WorkflowedModel) {\n\t\t\tWorkflowedModel workflowedModel = (WorkflowedModel)stagedModel;\n\n\t\t\tif (!ArrayUtil.contains(\n\t\t\t\t\tgetExportableStatuses(), workflowedModel.getStatus())) {\n\n\t\t\t\tthrow new PortletDataException(\n\t\t\t\t\tPortletDataException.STATUS_UNAVAILABLE);\n\t\t\t}\n\t\t}\n\n\t\tStagedModelType stagedModelType = stagedModel.getStagedModelType();\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tstagedModelType.getClassName());\n\n\t\tif (trashHandler != null) {\n\t\t\ttry {\n\t\t\t\tlong classPK = (Long)stagedModel.getPrimaryKeyObj();\n\n\t\t\t\tif (trashHandler.isInTrash(classPK)) {\n\t\t\t\t\tthrow new PortletDataException(\n\t\t\t\t\t\tPortletDataException.STATUS_IN_TRASH);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (PortletDataException pde) {\n\t\t\t\tthrow pde;\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Unable to check trash status for \" +\n\t\t\t\t\t\t\tstagedModel.getModelClassName());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"3864a8a79aad158cc0bbf99f29e1ebcb25d669c4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic boolean isInTrash(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tif (trashHandler == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (trashHandler.isInTrash(classPK) ||\n\t\t\ttrashHandler.isInTrashContainer(classPK)) {\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}","id":71305,"modified_method":"@Override\n\tpublic boolean isInTrash(String className, long classPK)\n\t\tthrows PortalException, SystemException {\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tif (trashHandler == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn trashHandler.isInTrash(classPK);\n\t}","commit_id":"3864a8a79aad158cc0bbf99f29e1ebcb25d669c4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addBreadcrumbEntries(\n\t\t\tHttpServletRequest request, String className, long classPK,\n\t\t\tString paramName, PortletURL containerModelURL)\n\t\tthrows PortalException, SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tList<ContainerModel> containerModels =\n\t\t\ttrashHandler.getParentContainerModels(classPK);\n\n\t\tCollections.reverse(containerModels);\n\n\t\tcontainerModelURL.setParameter(\"struts_action\", \"/trash/view\");\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, LanguageUtil.get(themeDisplay.getLocale(), \"recycle-bin\"),\n\t\t\tcontainerModelURL.toString());\n\n\t\tfor (ContainerModel containerModel : containerModels) {\n\t\t\tTrashHandler containerModelTrashHandler =\n\t\t\t\tTrashHandlerRegistryUtil.getTrashHandler(\n\t\t\t\t\tcontainerModel.getModelClassName());\n\n\t\t\tif (!containerModelTrashHandler.isInTrash(\n\t\t\t\t\tcontainerModel.getContainerModelId()) &&\n\t\t\t\t!containerModelTrashHandler.isInTrashContainer(\n\t\t\t\t\tcontainerModel.getContainerModelId())) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontainerModelURL.setParameter(\n\t\t\t\t\"struts_action\", \"/trash/view_content\");\n\n\t\t\tcontainerModelURL.setParameter(\n\t\t\t\tparamName,\n\t\t\t\tString.valueOf(containerModel.getContainerModelId()));\n\n\t\t\tString name = containerModel.getContainerModelName();\n\n\t\t\tif (containerModelTrashHandler.isInTrash(\n\t\t\t\t\tcontainerModel.getContainerModelId())) {\n\n\t\t\t\tname = TrashUtil.getOriginalTitle(name);\n\t\t\t}\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, name, containerModelURL.toString());\n\t\t}\n\n\t\tTrashRenderer trashRenderer = trashHandler.getTrashRenderer(classPK);\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, trashRenderer.getTitle(themeDisplay.getLocale()), null);\n\t}","id":71306,"modified_method":"protected void addBreadcrumbEntries(\n\t\t\tHttpServletRequest request, String className, long classPK,\n\t\t\tString paramName, PortletURL containerModelURL)\n\t\tthrows PortalException, SystemException {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tTrashHandler trashHandler = TrashHandlerRegistryUtil.getTrashHandler(\n\t\t\tclassName);\n\n\t\tList<ContainerModel> containerModels =\n\t\t\ttrashHandler.getParentContainerModels(classPK);\n\n\t\tCollections.reverse(containerModels);\n\n\t\tcontainerModelURL.setParameter(\"struts_action\", \"/trash/view\");\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, LanguageUtil.get(themeDisplay.getLocale(), \"recycle-bin\"),\n\t\t\tcontainerModelURL.toString());\n\n\t\tfor (ContainerModel containerModel : containerModels) {\n\t\t\tTrashHandler containerModelTrashHandler =\n\t\t\t\tTrashHandlerRegistryUtil.getTrashHandler(\n\t\t\t\t\tcontainerModel.getModelClassName());\n\n\t\t\tif (!containerModelTrashHandler.isInTrash(\n\t\t\t\t\tcontainerModel.getContainerModelId())) {\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcontainerModelURL.setParameter(\n\t\t\t\t\"struts_action\", \"/trash/view_content\");\n\n\t\t\tcontainerModelURL.setParameter(\n\t\t\t\tparamName,\n\t\t\t\tString.valueOf(containerModel.getContainerModelId()));\n\n\t\t\tString name = containerModel.getContainerModelName();\n\n\t\t\tif (containerModelTrashHandler.isInTrash(\n\t\t\t\t\tcontainerModel.getContainerModelId())) {\n\n\t\t\t\tname = TrashUtil.getOriginalTitle(name);\n\t\t\t}\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, name, containerModelURL.toString());\n\t\t}\n\n\t\tTrashRenderer trashRenderer = trashHandler.getTrashRenderer(classPK);\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, trashRenderer.getTitle(themeDisplay.getLocale()), null);\n\t}","commit_id":"3864a8a79aad158cc0bbf99f29e1ebcb25d669c4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected static FileEntry getPortletFileEntry(\n\t\t\tHttpServletRequest request, String[] pathArray)\n\t\tthrows Exception {\n\n\t\tlong groupId = GetterUtil.getLong(pathArray[1]);\n\t\tString uuid = pathArray[3];\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\tuuid, groupId);\n\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)fileEntry.getModel();\n\n\t\tint status = ParamUtil.getInteger(\n\t\t\trequest, \"status\", WorkflowConstants.STATUS_APPROVED);\n\n\t\tif ((status != WorkflowConstants.STATUS_IN_TRASH) &&\n\t\t\t(dlFileEntry.isInTrash() || dlFileEntry.isInTrashContainer())) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn fileEntry;\n\t}","id":71307,"modified_method":"protected static FileEntry getPortletFileEntry(\n\t\t\tHttpServletRequest request, String[] pathArray)\n\t\tthrows Exception {\n\n\t\tlong groupId = GetterUtil.getLong(pathArray[1]);\n\t\tString uuid = pathArray[3];\n\n\t\tFileEntry fileEntry = PortletFileRepositoryUtil.getPortletFileEntry(\n\t\t\tuuid, groupId);\n\n\t\tDLFileEntry dlFileEntry = (DLFileEntry)fileEntry.getModel();\n\n\t\tint status = ParamUtil.getInteger(\n\t\t\trequest, \"status\", WorkflowConstants.STATUS_APPROVED);\n\n\t\tif ((status != WorkflowConstants.STATUS_IN_TRASH) &&\n\t\t\tdlFileEntry.isInTrash()) {\n\n\t\t\treturn null;\n\t\t}\n\n\t\treturn fileEntry;\n\t}","commit_id":"3864a8a79aad158cc0bbf99f29e1ebcb25d669c4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response, User user,\n\t\t\tString[] pathArray)\n\t\tthrows Exception {\n\n\t\t// Retrieve file details\n\n\t\tFileEntry fileEntry = getFileEntry(pathArray);\n\n\t\tif (fileEntry == null) {\n\t\t\tthrow new NoSuchFileEntryException();\n\t\t}\n\n\t\tString version = ParamUtil.getString(request, \"version\");\n\n\t\tif (Validator.isNull(version)) {\n\t\t\tif (Validator.isNotNull(fileEntry.getVersion())) {\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t}\n\n\t\tString tempFileId = DLUtil.getTempFileId(\n\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\tif (fileEntry.getModel() instanceof DLFileEntry) {\n\t\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\t\tif (liferayFileEntry.isInTrash() ||\n\t\t\t\tliferayFileEntry.isInTrashContainer()) {\n\n\t\t\t\tint status = ParamUtil.getInteger(\n\t\t\t\t\trequest, \"status\", WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tif (status != WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\t\t\tthrow new NoSuchFileEntryException();\n\t\t\t\t}\n\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\t\tif (!PortletPermissionUtil.hasControlPanelAccessPermission(\n\t\t\t\t\t\tpermissionChecker, fileEntry.getGroupId(),\n\t\t\t\t\t\tPortletKeys.TRASH)) {\n\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion(version);\n\n\t\tif ((ParamUtil.getInteger(request, \"height\") > 0) ||\n\t\t\t(ParamUtil.getInteger(request, \"width\") > 0)) {\n\n\t\t\tInputStream inputStream = fileVersion.getContentStream(true);\n\n\t\t\tImage image = ImageToolUtil.getImage(inputStream);\n\n\t\t\twriteImage(image, request, response);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString fileName = fileVersion.getTitle();\n\n\t\tString extension = fileVersion.getExtension();\n\n\t\tif (Validator.isNotNull(extension) &&\n\t\t\t!fileName.endsWith(StringPool.PERIOD + extension)) {\n\n\t\t\tfileName += StringPool.PERIOD + extension;\n\t\t}\n\n\t\t// Handle requested conversion\n\n\t\tboolean converted = false;\n\n\t\tString targetExtension = ParamUtil.getString(\n\t\t\trequest, \"targetExtension\");\n\t\tint imageThumbnail = ParamUtil.getInteger(request, \"imageThumbnail\");\n\t\tint documentThumbnail = ParamUtil.getInteger(\n\t\t\trequest, \"documentThumbnail\");\n\t\tint previewFileIndex = ParamUtil.getInteger(\n\t\t\trequest, \"previewFileIndex\");\n\t\tboolean audioPreview = ParamUtil.getBoolean(request, \"audioPreview\");\n\t\tboolean imagePreview = ParamUtil.getBoolean(request, \"imagePreview\");\n\t\tboolean videoPreview = ParamUtil.getBoolean(request, \"videoPreview\");\n\t\tint videoThumbnail = ParamUtil.getInteger(request, \"videoThumbnail\");\n\n\t\tInputStream inputStream = null;\n\t\tlong contentLength = 0;\n\n\t\tif ((imageThumbnail > 0) && (imageThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(\n\t\t\t\t\tImageProcessorUtil.getThumbnailType(fileVersion));\n\n\t\t\tint thumbnailIndex = imageThumbnail - 1;\n\n\t\t\tinputStream = ImageProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = ImageProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((documentThumbnail > 0) && (documentThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessor.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = documentThumbnail - 1;\n\n\t\t\tinputStream = PDFProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (previewFileIndex > 0) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessor.PREVIEW_TYPE);\n\t\t\tinputStream = PDFProcessorUtil.getPreviewAsStream(\n\t\t\t\tfileVersion, previewFileIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getPreviewFileSize(\n\t\t\t\tfileVersion, previewFileIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (audioPreview || videoPreview) {\n\t\t\tString type = ParamUtil.getString(request, \"type\");\n\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(type);\n\n\t\t\tif (audioPreview) {\n\t\t\t\tinputStream = AudioProcessorUtil.getPreviewAsStream(\n\t\t\t\t\tfileVersion, type);\n\t\t\t\tcontentLength = AudioProcessorUtil.getPreviewFileSize(\n\t\t\t\t\tfileVersion, type);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinputStream = VideoProcessorUtil.getPreviewAsStream(\n\t\t\t\t\tfileVersion, type);\n\t\t\t\tcontentLength = VideoProcessorUtil.getPreviewFileSize(\n\t\t\t\t\tfileVersion, type);\n\t\t\t}\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (imagePreview) {\n\t\t\tString type = ImageProcessorUtil.getPreviewType(fileVersion);\n\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(type);\n\n\t\t\tinputStream = ImageProcessorUtil.getPreviewAsStream(fileVersion);\n\n\t\t\tcontentLength = ImageProcessorUtil.getPreviewFileSize(fileVersion);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((videoThumbnail > 0) && (videoThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(VideoProcessor.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = videoThumbnail - 1;\n\n\t\t\tinputStream = VideoProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = VideoProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse {\n\t\t\tinputStream = fileVersion.getContentStream(true);\n\t\t\tcontentLength = fileVersion.getSize();\n\n\t\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\t\tFile convertedFile = DocumentConversionUtil.convert(\n\t\t\t\t\ttempFileId, inputStream, extension, targetExtension);\n\n\t\t\t\tif (convertedFile != null) {\n\t\t\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\t\t\tStringPool.PERIOD).concat(targetExtension);\n\t\t\t\t\tinputStream = new FileInputStream(convertedFile);\n\t\t\t\t\tcontentLength = convertedFile.length();\n\n\t\t\t\t\tconverted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Determine proper content type\n\n\t\tString contentType = null;\n\n\t\tif (converted) {\n\t\t\tcontentType = MimeTypesUtil.getContentType(fileName);\n\t\t}\n\t\telse {\n\t\t\tcontentType = fileVersion.getMimeType();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Content type set to \" + contentType);\n\t\t}\n\n\t\t// Send file\n\n\t\tif (isSupportsRangeHeader(contentType)) {\n\t\t\tsendFileWithRangeHeader(\n\t\t\t\trequest, response, fileName, inputStream, contentLength,\n\t\t\t\tcontentType);\n\t\t}\n\t\telse {\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, inputStream, contentLength,\n\t\t\t\tcontentType);\n\t\t}\n\t}","id":71308,"modified_method":"protected void sendFile(\n\t\t\tHttpServletRequest request, HttpServletResponse response, User user,\n\t\t\tString[] pathArray)\n\t\tthrows Exception {\n\n\t\t// Retrieve file details\n\n\t\tFileEntry fileEntry = getFileEntry(pathArray);\n\n\t\tif (fileEntry == null) {\n\t\t\tthrow new NoSuchFileEntryException();\n\t\t}\n\n\t\tString version = ParamUtil.getString(request, \"version\");\n\n\t\tif (Validator.isNull(version)) {\n\t\t\tif (Validator.isNotNull(fileEntry.getVersion())) {\n\t\t\t\tversion = fileEntry.getVersion();\n\t\t\t}\n\t\t}\n\n\t\tString tempFileId = DLUtil.getTempFileId(\n\t\t\tfileEntry.getFileEntryId(), version);\n\n\t\tif (fileEntry.getModel() instanceof DLFileEntry) {\n\t\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\t\tif (liferayFileEntry.isInTrash()) {\n\t\t\t\tint status = ParamUtil.getInteger(\n\t\t\t\t\trequest, \"status\", WorkflowConstants.STATUS_APPROVED);\n\n\t\t\t\tif (status != WorkflowConstants.STATUS_IN_TRASH) {\n\t\t\t\t\tthrow new NoSuchFileEntryException();\n\t\t\t\t}\n\n\t\t\t\tPermissionChecker permissionChecker =\n\t\t\t\t\tPermissionThreadLocal.getPermissionChecker();\n\n\t\t\t\tif (!PortletPermissionUtil.hasControlPanelAccessPermission(\n\t\t\t\t\t\tpermissionChecker, fileEntry.getGroupId(),\n\t\t\t\t\t\tPortletKeys.TRASH)) {\n\n\t\t\t\t\tthrow new PrincipalException();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tFileVersion fileVersion = fileEntry.getFileVersion(version);\n\n\t\tif ((ParamUtil.getInteger(request, \"height\") > 0) ||\n\t\t\t(ParamUtil.getInteger(request, \"width\") > 0)) {\n\n\t\t\tInputStream inputStream = fileVersion.getContentStream(true);\n\n\t\t\tImage image = ImageToolUtil.getImage(inputStream);\n\n\t\t\twriteImage(image, request, response);\n\n\t\t\treturn;\n\t\t}\n\n\t\tString fileName = fileVersion.getTitle();\n\n\t\tString extension = fileVersion.getExtension();\n\n\t\tif (Validator.isNotNull(extension) &&\n\t\t\t!fileName.endsWith(StringPool.PERIOD + extension)) {\n\n\t\t\tfileName += StringPool.PERIOD + extension;\n\t\t}\n\n\t\t// Handle requested conversion\n\n\t\tboolean converted = false;\n\n\t\tString targetExtension = ParamUtil.getString(\n\t\t\trequest, \"targetExtension\");\n\t\tint imageThumbnail = ParamUtil.getInteger(request, \"imageThumbnail\");\n\t\tint documentThumbnail = ParamUtil.getInteger(\n\t\t\trequest, \"documentThumbnail\");\n\t\tint previewFileIndex = ParamUtil.getInteger(\n\t\t\trequest, \"previewFileIndex\");\n\t\tboolean audioPreview = ParamUtil.getBoolean(request, \"audioPreview\");\n\t\tboolean imagePreview = ParamUtil.getBoolean(request, \"imagePreview\");\n\t\tboolean videoPreview = ParamUtil.getBoolean(request, \"videoPreview\");\n\t\tint videoThumbnail = ParamUtil.getInteger(request, \"videoThumbnail\");\n\n\t\tInputStream inputStream = null;\n\t\tlong contentLength = 0;\n\n\t\tif ((imageThumbnail > 0) && (imageThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(\n\t\t\t\t\tImageProcessorUtil.getThumbnailType(fileVersion));\n\n\t\t\tint thumbnailIndex = imageThumbnail - 1;\n\n\t\t\tinputStream = ImageProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = ImageProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((documentThumbnail > 0) && (documentThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessor.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = documentThumbnail - 1;\n\n\t\t\tinputStream = PDFProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (previewFileIndex > 0) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(PDFProcessor.PREVIEW_TYPE);\n\t\t\tinputStream = PDFProcessorUtil.getPreviewAsStream(\n\t\t\t\tfileVersion, previewFileIndex);\n\t\t\tcontentLength = PDFProcessorUtil.getPreviewFileSize(\n\t\t\t\tfileVersion, previewFileIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (audioPreview || videoPreview) {\n\t\t\tString type = ParamUtil.getString(request, \"type\");\n\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(type);\n\n\t\t\tif (audioPreview) {\n\t\t\t\tinputStream = AudioProcessorUtil.getPreviewAsStream(\n\t\t\t\t\tfileVersion, type);\n\t\t\t\tcontentLength = AudioProcessorUtil.getPreviewFileSize(\n\t\t\t\t\tfileVersion, type);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinputStream = VideoProcessorUtil.getPreviewAsStream(\n\t\t\t\t\tfileVersion, type);\n\t\t\t\tcontentLength = VideoProcessorUtil.getPreviewFileSize(\n\t\t\t\t\tfileVersion, type);\n\t\t\t}\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if (imagePreview) {\n\t\t\tString type = ImageProcessorUtil.getPreviewType(fileVersion);\n\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(type);\n\n\t\t\tinputStream = ImageProcessorUtil.getPreviewAsStream(fileVersion);\n\n\t\t\tcontentLength = ImageProcessorUtil.getPreviewFileSize(fileVersion);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse if ((videoThumbnail > 0) && (videoThumbnail <= 3)) {\n\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\tStringPool.PERIOD).concat(VideoProcessor.THUMBNAIL_TYPE);\n\n\t\t\tint thumbnailIndex = videoThumbnail - 1;\n\n\t\t\tinputStream = VideoProcessorUtil.getThumbnailAsStream(\n\t\t\t\tfileVersion, thumbnailIndex);\n\t\t\tcontentLength = VideoProcessorUtil.getThumbnailFileSize(\n\t\t\t\tfileVersion, thumbnailIndex);\n\n\t\t\tconverted = true;\n\t\t}\n\t\telse {\n\t\t\tinputStream = fileVersion.getContentStream(true);\n\t\t\tcontentLength = fileVersion.getSize();\n\n\t\t\tif (Validator.isNotNull(targetExtension)) {\n\t\t\t\tFile convertedFile = DocumentConversionUtil.convert(\n\t\t\t\t\ttempFileId, inputStream, extension, targetExtension);\n\n\t\t\t\tif (convertedFile != null) {\n\t\t\t\t\tfileName = FileUtil.stripExtension(fileName).concat(\n\t\t\t\t\t\tStringPool.PERIOD).concat(targetExtension);\n\t\t\t\t\tinputStream = new FileInputStream(convertedFile);\n\t\t\t\t\tcontentLength = convertedFile.length();\n\n\t\t\t\t\tconverted = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Determine proper content type\n\n\t\tString contentType = null;\n\n\t\tif (converted) {\n\t\t\tcontentType = MimeTypesUtil.getContentType(fileName);\n\t\t}\n\t\telse {\n\t\t\tcontentType = fileVersion.getMimeType();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Content type set to \" + contentType);\n\t\t}\n\n\t\t// Send file\n\n\t\tif (isSupportsRangeHeader(contentType)) {\n\t\t\tsendFileWithRangeHeader(\n\t\t\t\trequest, response, fileName, inputStream, contentLength,\n\t\t\t\tcontentType);\n\t\t}\n\t\telse {\n\t\t\tServletResponseUtil.sendFile(\n\t\t\t\trequest, response, fileName, inputStream, contentLength,\n\t\t\t\tcontentType);\n\t\t}\n\t}","commit_id":"3864a8a79aad158cc0bbf99f29e1ebcb25d669c4","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns <code>true<\/code> if the portlet ID contains a user ID.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return <code>true<\/code> if the portlet ID contains a user ID;\n\t *         <code>false<\/code> otherwise\n\t */\n\tpublic static boolean hasUserId(String portletId) {\n\t\tPortletInstance portletInstance = new PortletInstance(portletId);\n\n\t\treturn portletInstance.hasUserId();\n\t}","id":71309,"modified_method":"/**\n\t * Returns <code>true<\/code> if the portlet ID contains a user ID.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return <code>true<\/code> if the portlet ID contains a user ID;\n\t *         <code>false<\/code> otherwise\n\t */\n\tpublic static boolean hasUserId(String portletId) {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletId);\n\n\t\treturn portletInstance.hasUserId();\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns the instance ID of the portlet.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return the instance ID of the portlet\n\t */\n\t@Deprecated\n\tpublic static String getInstanceId(String portletId) {\n\t\tPortletInstance portletInstance = new PortletInstance(portletId);\n\n\t\treturn portletInstance.getInstanceId();\n\t}","id":71310,"modified_method":"/**\n\t * Returns the instance ID of the portlet.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return the instance ID of the portlet\n\t */\n\t@Deprecated\n\tpublic static String getInstanceId(String portletId) {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletId);\n\n\t\treturn portletInstance.getInstanceId();\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns the user ID of the portlet. This only applies when the portlet is\n\t * added by a user to a page in customizable mode.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return the user ID of the portlet\n\t */\n\t@Deprecated\n\tpublic static long getUserId(String portletId) {\n\t\tPortletInstance portletInstance = new PortletInstance(portletId);\n\n\t\treturn portletInstance.getUserId();\n\t}","id":71311,"modified_method":"/**\n\t * Returns the user ID of the portlet. This only applies when the portlet is\n\t * added by a user to a page in customizable mode.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return the user ID of the portlet\n\t */\n\t@Deprecated\n\tpublic static long getUserId(String portletId) {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletId);\n\n\t\treturn portletInstance.getUserId();\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static boolean hasIdenticalRootPortletId(\n\t\tString portletId1, String portletId2) {\n\n\t\tPortletInstance portletInstance1 = new PortletInstance(portletId1);\n\t\tPortletInstance portletInstance2 = new PortletInstance(portletId2);\n\n\t\treturn portletInstance1.hasIdenticalPortletName(portletInstance2);\n\t}","id":71312,"modified_method":"public static boolean hasIdenticalRootPortletId(\n\t\tString portletId1, String portletId2) {\n\n\t\tPortletInstance portletInstance1 =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletId1);\n\t\tPortletInstance portletInstance2 =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletId2);\n\n\t\treturn portletInstance1.hasIdenticalPortletName(portletInstance2);\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns the root portlet ID of the portlet.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return the root portlet ID of the portlet\n\t */\n\tpublic static String getRootPortletId(String portletId) {\n\t\tPortletInstance portletInstance = new PortletInstance(portletId);\n\n\t\treturn portletInstance.getPortletName();\n\t}","id":71313,"modified_method":"/**\n\t * Returns the root portlet ID of the portlet.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return the root portlet ID of the portlet\n\t */\n\tpublic static String getRootPortletId(String portletId) {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletId);\n\n\t\treturn portletInstance.getPortletName();\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * Returns <code>true<\/code> if the portlet ID contains an instance ID.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return <code>true<\/code> if the portlet ID contains an instance ID;\n\t *         <code>false<\/code> otherwise\n\t */\n\tpublic static boolean hasInstanceId(String portletId) {\n\t\tPortletInstance portletInstance = new PortletInstance(portletId);\n\n\t\treturn portletInstance.hasInstanceId();\n\t}","id":71314,"modified_method":"/**\n\t * Returns <code>true<\/code> if the portlet ID contains an instance ID.\n\t *\n\t * @param  portletId the portlet ID\n\t * @return <code>true<\/code> if the portlet ID contains an instance ID;\n\t *         <code>false<\/code> otherwise\n\t */\n\tpublic static boolean hasInstanceId(String portletId) {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletId);\n\n\t\treturn portletInstance.hasInstanceId();\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId8() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","id":71315,"modified_method":"@Test\n\tpublic void testRootPortletId8() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId1() {\n\t\tPortletInstance portletInstance = new PortletInstance(PortletKeys.TEST);\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","id":71316,"modified_method":"@Test\n\tpublic void testRootPortletId1() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(PortletKeys.TEST);\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId2() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","id":71317,"modified_method":"@Test\n\tpublic void testRootPortletId2() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId2() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertEquals(\"1234\", portletInstance.getInstanceId());\n\t}","id":71318,"modified_method":"@Test\n\tpublic void testInstanceId2() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertEquals(\"1234\", portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId6() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","id":71319,"modified_method":"@Test\n\tpublic void testRootPortletId6() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId7() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","id":71320,"modified_method":"@Test\n\tpublic void testUserId7() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId7() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","id":71321,"modified_method":"@Test\n\tpublic void testInstanceId7() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId8() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertEquals(\"5678\", portletInstance.getInstanceId());\n\t}","id":71322,"modified_method":"@Test\n\tpublic void testInstanceId8() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertEquals(\"5678\", portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId4() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","id":71323,"modified_method":"@Test\n\tpublic void testUserId4() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test(expected = InvalidParameterException.class)\n\tpublic void testInvalidPortletName() {\n\t\tnew PortletInstance(getId(\"1234_INSTANCE_asdf\", 1234, \"5678\"));\n\t}","id":71324,"modified_method":"@Test(expected = InvalidParameterException.class)\n\tpublic void testInvalidPortletName() {\n\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\tgetId(\"1234_INSTANCE_asdf\", 1234, \"5678\"));\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId10() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","id":71325,"modified_method":"@Test\n\tpublic void testInstanceId10() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId11() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","id":71326,"modified_method":"@Test\n\tpublic void testInstanceId11() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId12() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","id":71327,"modified_method":"@Test\n\tpublic void testInstanceId12() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId16() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","id":71328,"modified_method":"@Test\n\tpublic void testInstanceId16() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId12() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","id":71329,"modified_method":"@Test\n\tpublic void testUserId12() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId1() {\n\t\tPortletInstance portletInstance = new PortletInstance(PortletKeys.TEST);\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","id":71330,"modified_method":"@Test\n\tpublic void testUserId1() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(PortletKeys.TEST);\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId5() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetWarPortletId());\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","id":71331,"modified_method":"@Test\n\tpublic void testInstanceId5() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(getWarPortletId());\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId5() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetWarPortletId());\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","id":71332,"modified_method":"@Test\n\tpublic void testUserId5() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(getWarPortletId());\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId3() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","id":71333,"modified_method":"@Test\n\tpublic void testRootPortletId3() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId11() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","id":71334,"modified_method":"@Test\n\tpublic void testUserId11() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId6() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertEquals(\"1234\", portletInstance.getInstanceId());\n\t}","id":71335,"modified_method":"@Test\n\tpublic void testInstanceId6() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertEquals(\"1234\", portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId15() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","id":71336,"modified_method":"@Test\n\tpublic void testUserId15() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId1() {\n\t\tPortletInstance portletInstance = new PortletInstance(PortletKeys.TEST);\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","id":71337,"modified_method":"@Test\n\tpublic void testInstanceId1() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(PortletKeys.TEST);\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId3() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","id":71338,"modified_method":"@Test\n\tpublic void testUserId3() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId3() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","id":71339,"modified_method":"@Test\n\tpublic void testInstanceId3() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234));\n\n\t\tAssert.assertNull(portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId13() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetWarPortletId());\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","id":71340,"modified_method":"@Test\n\tpublic void testUserId13() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(getWarPortletId());\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId4() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","id":71341,"modified_method":"@Test\n\tpublic void testRootPortletId4() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertEquals(PortletKeys.TEST, portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId8() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","id":71342,"modified_method":"@Test\n\tpublic void testUserId8() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertEquals(1234, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId6() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","id":71343,"modified_method":"@Test\n\tpublic void testUserId6() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId4() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertEquals(\"5678\", portletInstance.getInstanceId());\n\t}","id":71344,"modified_method":"@Test\n\tpublic void testInstanceId4() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, 1234, \"5678\"));\n\n\t\tAssert.assertEquals(\"5678\", portletInstance.getInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId13() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetWarPortletId());\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","id":71345,"modified_method":"@Test\n\tpublic void testInstanceId13() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(getWarPortletId());\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId14() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","id":71346,"modified_method":"@Test\n\tpublic void testInstanceId14() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertTrue(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId14() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","id":71347,"modified_method":"@Test\n\tpublic void testUserId14() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), \"1234\"));\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId9() {\n\t\tPortletInstance portletInstance = new PortletInstance(PortletKeys.TEST);\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","id":71348,"modified_method":"@Test\n\tpublic void testUserId9() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(PortletKeys.TEST);\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId16() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","id":71349,"modified_method":"@Test\n\tpublic void testUserId16() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234, \"5678\"));\n\n\t\tAssert.assertTrue(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId2() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","id":71350,"modified_method":"@Test\n\tpublic void testUserId2() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertEquals(0, portletInstance.getUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testUserId10() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","id":71351,"modified_method":"@Test\n\tpublic void testUserId10() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(PortletKeys.TEST, \"1234\"));\n\n\t\tAssert.assertFalse(portletInstance.hasUserId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId5() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetWarPortletId());\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","id":71352,"modified_method":"@Test\n\tpublic void testRootPortletId5() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(getWarPortletId());\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId15() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","id":71353,"modified_method":"@Test\n\tpublic void testInstanceId15() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testInstanceId9() {\n\t\tPortletInstance portletInstance = new PortletInstance(PortletKeys.TEST);\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","id":71354,"modified_method":"@Test\n\tpublic void testInstanceId9() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(PortletKeys.TEST);\n\n\t\tAssert.assertFalse(portletInstance.hasInstanceId());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testRootPortletId7() {\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","id":71355,"modified_method":"@Test\n\tpublic void testRootPortletId7() {\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(\n\t\t\t\tgetId(getWarPortletId(), 1234));\n\n\t\tAssert.assertEquals(\n\t\t\tgetWarPortletId(), portletInstance.getPortletName());\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected boolean isInstanceOf(\n\t\tString portletPreferencesPortletId, String portletId) {\n\n\t\tportletPreferencesPortletId = GetterUtil.getString(\n\t\t\tportletPreferencesPortletId);\n\t\tportletId = GetterUtil.getString(portletId);\n\n\t\tif (portletPreferencesPortletId.equals(portletId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPortletInstance portletInstance = new PortletInstance(\n\t\t\tportletPreferencesPortletId);\n\n\t\treturn portletInstance.hasIdenticalPortletName(portletId);\n\t}","id":71356,"modified_method":"protected boolean isInstanceOf(\n\t\tString portletPreferencesPortletId, String portletId) {\n\n\t\tportletPreferencesPortletId = GetterUtil.getString(\n\t\t\tportletPreferencesPortletId);\n\t\tportletId = GetterUtil.getString(portletId);\n\n\t\tif (portletPreferencesPortletId.equals(portletId)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tPortletInstance portletInstance =\n\t\t\tPortletInstance.fromPortletInstanceKey(portletPreferencesPortletId);\n\n\t\treturn portletInstance.hasIdenticalPortletName(portletId);\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\n\t\t// Rename instanceable portlet IDs. We expect the root form of the\n\t\t// portlet ID because we will rename all instances of the portlet ID.\n\n\t\tString[][] renamePortletIdsArray = getRenamePortletIdsArray();\n\n\t\tfor (String[] renamePortletIds : renamePortletIdsArray) {\n\t\t\tString oldRootPortletId = renamePortletIds[0];\n\t\t\tString newRootPortletId = renamePortletIds[1];\n\n\t\t\tupdatePortlet(oldRootPortletId, newRootPortletId);\n\t\t\tupdateLayouts(oldRootPortletId, newRootPortletId, false);\n\t\t}\n\n\t\t// Rename uninstanceable portlet IDs to instanceable portlet IDs\n\n\t\tString[] uninstanceablePortletIds = getUninstanceablePortletIds();\n\n\t\tfor (String portletId : uninstanceablePortletIds) {\n\t\t\tPortletInstance portletInstance = new PortletInstance(portletId);\n\n\t\t\tif (portletInstance.hasInstanceId()) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Portlet \" + portletId + \" is already instanceable\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPortletInstance newPortletInstance = PortletInstance.newInstanceFor(\n\t\t\t\tportletId);\n\n\t\t\tString newPortletInstanceKey =\n\t\t\t\tnewPortletInstance.getPortletInstanceKey();\n\n\t\t\tupdateResourcePermission(portletId, newPortletInstanceKey, false);\n\t\t\tupdateInstanceablePortletPreferences(\n\t\t\t\tportletId, newPortletInstanceKey);\n\t\t\tupdateLayouts(portletId, newPortletInstanceKey, true);\n\t\t}\n\t}","id":71357,"modified_method":"@Override\n\tprotected void doUpgrade() throws Exception {\n\n\t\t// Rename instanceable portlet IDs. We expect the root form of the\n\t\t// portlet ID because we will rename all instances of the portlet ID.\n\n\t\tString[][] renamePortletIdsArray = getRenamePortletIdsArray();\n\n\t\tfor (String[] renamePortletIds : renamePortletIdsArray) {\n\t\t\tString oldRootPortletId = renamePortletIds[0];\n\t\t\tString newRootPortletId = renamePortletIds[1];\n\n\t\t\tupdatePortlet(oldRootPortletId, newRootPortletId);\n\t\t\tupdateLayouts(oldRootPortletId, newRootPortletId, false);\n\t\t}\n\n\t\t// Rename uninstanceable portlet IDs to instanceable portlet IDs\n\n\t\tString[] uninstanceablePortletIds = getUninstanceablePortletIds();\n\n\t\tfor (String portletId : uninstanceablePortletIds) {\n\t\t\tPortletInstance portletInstance =\n\t\t\t\tPortletInstance.fromPortletInstanceKey(portletId);\n\n\t\t\tif (portletInstance.hasInstanceId()) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Portlet \" + portletId + \" is already instanceable\");\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tPortletInstance newPortletInstance = PortletInstance.newInstanceFor(\n\t\t\t\tportletId);\n\n\t\t\tString newPortletInstanceKey =\n\t\t\t\tnewPortletInstance.getPortletInstanceKey();\n\n\t\t\tupdateResourcePermission(portletId, newPortletInstanceKey, false);\n\t\t\tupdateInstanceablePortletPreferences(\n\t\t\t\tportletId, newPortletInstanceKey);\n\t\t\tupdateLayouts(portletId, newPortletInstanceKey, true);\n\t\t}\n\t}","commit_id":"9055d07d57880d0784151b5b27a1183937659cad","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache affinity example started.\");\n\n            GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n            // Clean up caches on all nodes before run.\n            cache.globalClearAll(0);\n\n            for (int i = 0; i < KEY_CNT; i++)\n                cache.putx(i, Integer.toString(i));\n\n            // Co-locates jobs with data using GridCompute.affinityRun(...) method.\n            visitUsingAffinityRun();\n\n            // Co-locates jobs with data using Grid.mapKeysToNodes(...) method.\n            visitUsingMapKeysToNodes();\n        }\n    }","id":71358,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache affinity example started.\");\n\n            IgniteCache<Integer, String> cache = g.jcache(CACHE_NAME);\n\n            // Clean up caches on all nodes before run.\n            cache.clear();\n\n            for (int i = 0; i < KEY_CNT; i++)\n                cache.put(i, Integer.toString(i));\n\n            // Co-locates jobs with data using GridCompute.affinityRun(...) method.\n            visitUsingAffinityRun();\n\n            // Co-locates jobs with data using Grid.mapKeysToNodes(...) method.\n            visitUsingMapKeysToNodes();\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Collocates jobs with keys they need to work on using {@link org.apache.ignite.IgniteCluster#mapKeysToNodes(String, Collection)}\n     * method. The difference from {@code affinityRun(...)} method is that here we process multiple keys\n     * in a single job.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void visitUsingMapKeysToNodes() throws IgniteCheckedException {\n        final Ignite g = Ignition.ignite();\n\n        Collection<Integer> keys = new ArrayList<>(KEY_CNT);\n\n        for (int i = 0; i < KEY_CNT; i++)\n            keys.add(i);\n\n        // Map all keys to nodes.\n        Map<ClusterNode, Collection<Integer>> mappings = g.cluster().mapKeysToNodes(CACHE_NAME, keys);\n\n        for (Map.Entry<ClusterNode, Collection<Integer>> mapping : mappings.entrySet()) {\n            ClusterNode node = mapping.getKey();\n\n            final Collection<Integer> mappedKeys = mapping.getValue();\n\n            if (node != null) {\n                // Bring computations to the nodes where the data resides (i.e. collocation).\n                g.compute(g.cluster().forNode(node)).run(new IgniteRunnable() {\n                    @Override public void run() {\n                        GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n                        // Peek is a local memory lookup, however, value should never be 'null'\n                        // as we are co-located with node that has a given key.\n                        for (Integer key : mappedKeys)\n                            System.out.println(\"Co-located using mapKeysToNodes [key= \" + key +\n                                \", value=\" + cache.peek(key) + ']');\n                    }\n                });\n            }\n        }\n    }","id":71359,"modified_method":"/**\n     * Collocates jobs with keys they need to work on using {@link org.apache.ignite.IgniteCluster#mapKeysToNodes(String, Collection)}\n     * method. The difference from {@code affinityRun(...)} method is that here we process multiple keys\n     * in a single job.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void visitUsingMapKeysToNodes() throws IgniteCheckedException {\n        final Ignite g = Ignition.ignite();\n\n        Collection<Integer> keys = new ArrayList<>(KEY_CNT);\n\n        for (int i = 0; i < KEY_CNT; i++)\n            keys.add(i);\n\n        // Map all keys to nodes.\n        Map<ClusterNode, Collection<Integer>> mappings = g.cluster().mapKeysToNodes(CACHE_NAME, keys);\n\n        for (Map.Entry<ClusterNode, Collection<Integer>> mapping : mappings.entrySet()) {\n            ClusterNode node = mapping.getKey();\n\n            final Collection<Integer> mappedKeys = mapping.getValue();\n\n            if (node != null) {\n                // Bring computations to the nodes where the data resides (i.e. collocation).\n                g.compute(g.cluster().forNode(node)).run(new IgniteRunnable() {\n                    @Override public void run() {\n                        IgniteCache<Integer, String> cache = g.jcache(CACHE_NAME);\n\n                        // Peek is a local memory lookup, however, value should never be 'null'\n                        // as we are co-located with node that has a given key.\n                        for (Integer key : mappedKeys)\n                            System.out.println(\"Co-located using mapKeysToNodes [key= \" + key +\n                                \", value=\" + cache.localPeek(key) + ']');\n                    }\n                });\n            }\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Collocates jobs with keys they need to work on using {@link org.apache.ignite.IgniteCompute#affinityRun(String, Object, Runnable)}\n     * method.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void visitUsingAffinityRun() throws IgniteCheckedException {\n        Ignite g = Ignition.ignite();\n\n        final GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n        for (int i = 0; i < KEY_CNT; i++) {\n            final int key = i;\n\n            // This runnable will execute on the remote node where\n            // data with the given key is located. Since it will be co-located\n            // we can use local 'peek' operation safely.\n            g.compute().affinityRun(CACHE_NAME, key, new IgniteRunnable() {\n                @Override public void run() {\n                    // Peek is a local memory lookup, however, value should never be 'null'\n                    // as we are co-located with node that has a given key.\n                    System.out.println(\"Co-located using affinityRun [key= \" + key + \", value=\" + cache.peek(key) + ']');\n                }\n            });\n        }\n    }","id":71360,"modified_method":"/**\n     * Collocates jobs with keys they need to work on using {@link org.apache.ignite.IgniteCompute#affinityRun(String, Object, Runnable)}\n     * method.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void visitUsingAffinityRun() throws IgniteCheckedException {\n        Ignite g = Ignition.ignite();\n\n        final IgniteCache<Integer, String> cache = g.jcache(CACHE_NAME);\n\n        for (int i = 0; i < KEY_CNT; i++) {\n            final int key = i;\n\n            // This runnable will execute on the remote node where\n            // data with the given key is located. Since it will be co-located\n            // we can use local 'peek' operation safely.\n            g.compute().affinityRun(CACHE_NAME, key, new IgniteRunnable() {\n                @Override public void run() {\n                    // Peek is a local memory lookup, however, value should never be 'null'\n                    // as we are co-located with node that has a given key.\n                    System.out.println(\"Co-located using affinityRun [key= \" + key + \", value=\" + cache.localPeek(key) + ']');\n                }\n            });\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache API example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.cache(CACHE_NAME).globalClearAll(0);\n\n            // Demonstrate atomic map operations.\n            atomicMapOperations();\n\n            // Demonstrate various ways to iterate over locally cached values.\n            localIterators();\n        }\n    }","id":71361,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache API example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.jcache(CACHE_NAME).clear();\n\n            // Demonstrate atomic map operations.\n            atomicMapOperations();\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache data loader example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.cache(CACHE_NAME).globalClearAll(0);\n\n            System.out.println();\n            System.out.println(\">>> Cache clear finished.\");\n\n            long start = System.currentTimeMillis();\n\n            try (IgniteDataLoader<Integer, String> ldr = g.dataLoader(CACHE_NAME)) {\n                // Configure loader.\n                ldr.perNodeBufferSize(1024);\n                ldr.perNodeParallelLoadOperations(8);\n                ldr.isolated(true);\n\n                for (int i = 0; i < ENTRY_COUNT; i++) {\n                    ldr.addData(i, Integer.toString(i));\n\n                    // Print out progress while loading cache.\n                    if (i > 0 && i % 10000 == 0)\n                        System.out.println(\"Loaded \" + i + \" keys.\");\n                }\n            }\n\n            long end = System.currentTimeMillis();\n\n            System.out.println(\">>> Loaded \" + ENTRY_COUNT + \" keys in \" + (end - start) + \"ms.\");\n        }\n    }","id":71362,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache data loader example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.jcache(CACHE_NAME).clear();\n\n            System.out.println();\n            System.out.println(\">>> Cache clear finished.\");\n\n            long start = System.currentTimeMillis();\n\n            try (IgniteDataLoader<Integer, String> ldr = g.dataLoader(CACHE_NAME)) {\n                // Configure loader.\n                ldr.perNodeBufferSize(1024);\n                ldr.perNodeParallelLoadOperations(8);\n                ldr.isolated(true);\n\n                for (int i = 0; i < ENTRY_COUNT; i++) {\n                    ldr.addData(i, Integer.toString(i));\n\n                    // Print out progress while loading cache.\n                    if (i > 0 && i % 10000 == 0)\n                        System.out.println(\"Loaded \" + i + \" keys.\");\n                }\n            }\n\n            long end = System.currentTimeMillis();\n\n            System.out.println(\">>> Loaded \" + ENTRY_COUNT + \" keys in \" + (end - start) + \"ms.\");\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/** {@inheritDoc} */\n    @Override public void loadCache(IgniteBiInClosure<Long, Person> clo, Object... args) {\n        int cnt = (Integer)args[0];\n\n        System.out.println(\">>> Store loadCache for entry count: \" + cnt);\n\n        GridCache<Long, Person> cache = ignite.cache(cacheName);\n\n        for (int i = 0; i < cnt; i++) {\n            // Generate dummy person on the fly.\n            Person p = new Person(i, \"first-\" + i, \"last-\" + 1);\n\n            // GridGain will automatically discard entries that don't belong on this node,\n            // but we check if local node is primary or backup anyway just to demonstrate that we can.\n            // Ideally, partition ID of a key would be stored  in the database and only keys\n            // for partitions that belong on this node would be loaded from database.\n            if (cache.affinity().isPrimaryOrBackup(ignite.cluster().localNode(), p.getId())) {\n                // Update dummy database.\n                // In real life data would be loaded from database.\n                dummyDB.put(p.getId(), p);\n\n                // Pass data to cache.\n                clo.apply(p.getId(), p);\n            }\n        }\n    }","id":71363,"modified_method":"/** {@inheritDoc} */\n    @Override public void loadCache(IgniteBiInClosure<Long, Person> clo, Object... args) {\n        int cnt = (Integer)args[0];\n\n        System.out.println(\">>> Store loadCache for entry count: \" + cnt);\n\n        for (int i = 0; i < cnt; i++) {\n            // Generate dummy person on the fly.\n            Person p = new Person(i, \"first-\" + i, \"last-\" + 1);\n\n            // GridGain will automatically discard entries that don't belong on this node,\n            // but we check if local node is primary or backup anyway just to demonstrate that we can.\n            // Ideally, partition ID of a key would be stored  in the database and only keys\n            // for partitions that belong on this node would be loaded from database.\n            if (ignite.affinity(cacheName).isPrimaryOrBackup(ignite.cluster().localNode(), p.getId())) {\n                // Update dummy database.\n                // In real life data would be loaded from database.\n                dummyDB.put(p.getId(), p);\n\n                // Pass data to cache.\n                clo.apply(p.getId(), p);\n            }\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException, InterruptedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache events example started.\");\n\n            final GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n            // Clean up caches on all nodes before run.\n            cache.globalClearAll(0);\n\n            // This optional local callback is called for each event notification\n            // that passed remote predicate listener.\n            IgniteBiPredicate<UUID, IgniteCacheEvent> locLsnr = new IgniteBiPredicate<UUID, IgniteCacheEvent>() {\n                @Override public boolean apply(UUID uuid, IgniteCacheEvent evt) {\n                    System.out.println(\"Received event [evt=\" + evt.name() + \", key=\" + evt.key() +\n                        \", oldVal=\" + evt.oldValue() + \", newVal=\" + evt.newValue());\n\n                    return true; // Continue listening.\n                }\n            };\n\n            // Remote listener which only accepts events for keys that are\n            // greater or equal than 10 and if event node is primary for this key.\n            IgnitePredicate<IgniteCacheEvent> rmtLsnr = new IgnitePredicate<IgniteCacheEvent>() {\n                @Override public boolean apply(IgniteCacheEvent evt) {\n                    System.out.println(\"Cache event [name=\" + evt.name() + \", key=\" + evt.key() + ']');\n\n                    int key = evt.key();\n\n                    return key >= 10 && cache.affinity().isPrimary(g.cluster().localNode(), key);\n                }\n            };\n\n            // Subscribe to specified cache events on all nodes that have cache running.\n            // Cache events are explicitly enabled in examples/config/example-cache.xml file.\n            g.events(g.cluster().forCache(CACHE_NAME)).remoteListen(locLsnr, rmtLsnr,\n                EVT_CACHE_OBJECT_PUT, EVT_CACHE_OBJECT_READ, EVT_CACHE_OBJECT_REMOVED);\n\n            // Generate cache events.\n            for (int i = 0; i < 20; i++)\n                cache.putx(i, Integer.toString(i));\n\n            // Wait for a while while callback is notified about remaining puts.\n            Thread.sleep(2000);\n        }\n    }","id":71364,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException, InterruptedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache events example started.\");\n\n            final IgniteCache<Integer, String> cache = g.jcache(CACHE_NAME);\n\n            // Clean up caches on all nodes before run.\n            cache.clear();\n\n            // This optional local callback is called for each event notification\n            // that passed remote predicate listener.\n            IgniteBiPredicate<UUID, IgniteCacheEvent> locLsnr = new IgniteBiPredicate<UUID, IgniteCacheEvent>() {\n                @Override public boolean apply(UUID uuid, IgniteCacheEvent evt) {\n                    System.out.println(\"Received event [evt=\" + evt.name() + \", key=\" + evt.key() +\n                        \", oldVal=\" + evt.oldValue() + \", newVal=\" + evt.newValue());\n\n                    return true; // Continue listening.\n                }\n            };\n\n            // Remote listener which only accepts events for keys that are\n            // greater or equal than 10 and if event node is primary for this key.\n            IgnitePredicate<IgniteCacheEvent> rmtLsnr = new IgnitePredicate<IgniteCacheEvent>() {\n                @Override public boolean apply(IgniteCacheEvent evt) {\n                    System.out.println(\"Cache event [name=\" + evt.name() + \", key=\" + evt.key() + ']');\n\n                    int key = evt.key();\n\n                    return key >= 10 && g.affinity(CACHE_NAME).isPrimary(g.cluster().localNode(), key);\n                }\n            };\n\n            // Subscribe to specified cache events on all nodes that have cache running.\n            // Cache events are explicitly enabled in examples/config/example-cache.xml file.\n            g.events(g.cluster().forCache(CACHE_NAME)).remoteListen(locLsnr, rmtLsnr,\n                EVT_CACHE_OBJECT_PUT, EVT_CACHE_OBJECT_READ, EVT_CACHE_OBJECT_REMOVED);\n\n            // Generate cache events.\n            for (int i = 0; i < 20; i++)\n                cache.put(i, Integer.toString(i));\n\n            // Wait for a while while callback is notified about remaining puts.\n            Thread.sleep(2000);\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        Timer popularNumbersQryTimer = new Timer(\"numbers-query-worker\");\n\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache popular numbers example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.cache(CACHE_NAME).globalClearAll(0);\n\n            ClusterGroup prj = g.cluster().forCache(CACHE_NAME);\n\n            if (prj.nodes().isEmpty()) {\n                System.out.println(\"Grid does not have cache configured: \" + CACHE_NAME);\n\n                return;\n            }\n\n            TimerTask task = scheduleQuery(g, popularNumbersQryTimer, POPULAR_NUMBERS_CNT);\n\n            streamData(g);\n\n            // Force one more run to get final counts.\n            task.run();\n\n            popularNumbersQryTimer.cancel();\n        }\n    }","id":71365,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        Timer popularNumbersQryTimer = new Timer(\"numbers-query-worker\");\n\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache popular numbers example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.jcache(CACHE_NAME).clear();\n\n            ClusterGroup prj = g.cluster().forCache(CACHE_NAME);\n\n            if (prj.nodes().isEmpty()) {\n                System.out.println(\"Grid does not have cache configured: \" + CACHE_NAME);\n\n                return;\n            }\n\n            TimerTask task = scheduleQuery(g, popularNumbersQryTimer, POPULAR_NUMBERS_CNT);\n\n            streamData(g);\n\n            // Force one more run to get final counts.\n            task.run();\n\n            popularNumbersQryTimer.cancel();\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Execute individual puts and gets.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void putGet() throws IgniteCheckedException {\n        System.out.println();\n        System.out.println(\">>> Cache put-get example started.\");\n\n        Ignite g = Ignition.ignite();\n\n        final GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n        final int keyCnt = 20;\n\n        // Store keys in cache.\n        for (int i = 0; i < keyCnt; i++)\n            cache.putx(i, Integer.toString(i));\n\n        System.out.println(\">>> Stored values in cache.\");\n\n        for (int i = 0; i < keyCnt; i++)\n            System.out.println(\"Got [key=\" + i + \", val=\" + cache.get(i) + ']');\n    }","id":71366,"modified_method":"/**\n     * Execute individual puts and gets.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void putGet() throws IgniteCheckedException {\n        System.out.println();\n        System.out.println(\">>> Cache put-get example started.\");\n\n        Ignite g = Ignition.ignite();\n\n        final IgniteCache<Integer, String> cache = g.jcache(CACHE_NAME);\n\n        final int keyCnt = 20;\n\n        // Store keys in cache.\n        for (int i = 0; i < keyCnt; i++)\n            cache.put(i, Integer.toString(i));\n\n        System.out.println(\">>> Stored values in cache.\");\n\n        for (int i = 0; i < keyCnt; i++)\n            System.out.println(\"Got [key=\" + i + \", val=\" + cache.get(i) + ']');\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Execute bulk {@code putAll(...)} and {@code getAll(...)} operations.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void putAllGetAll() throws IgniteCheckedException {\n        System.out.println();\n        System.out.println(\">>> Starting putAll-getAll example.\");\n\n        Ignite g = Ignition.ignite();\n\n        final GridCache<Integer, String> cache = g.cache(CACHE_NAME);\n\n        final int keyCnt = 20;\n\n        // Create batch.\n        Map<Integer, String> batch = new HashMap<>();\n\n        for (int i = 0; i < keyCnt; i++)\n            batch.put(i, \"bulk-\" + Integer.toString(i));\n\n        // Bulk-store entries in cache.\n        cache.putAll(batch);\n\n        System.out.println(\">>> Bulk-stored values in cache.\");\n\n        // Bulk-get values from cache.\n        Map<Integer, String> vals = cache.getAll(batch.keySet());\n\n        for (Map.Entry<Integer, String> e : vals.entrySet())\n            System.out.println(\"Got entry [key=\" + e.getKey() + \", val=\" + e.getValue() + ']');\n    }","id":71367,"modified_method":"/**\n     * Execute bulk {@code putAll(...)} and {@code getAll(...)} operations.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void putAllGetAll() throws IgniteCheckedException {\n        System.out.println();\n        System.out.println(\">>> Starting putAll-getAll example.\");\n\n        Ignite g = Ignition.ignite();\n\n        final IgniteCache<Integer, String> cache = g.jcache(CACHE_NAME);\n\n        final int keyCnt = 20;\n\n        // Create batch.\n        Map<Integer, String> batch = new HashMap<>();\n\n        for (int i = 0; i < keyCnt; i++)\n            batch.put(i, \"bulk-\" + Integer.toString(i));\n\n        // Bulk-store entries in cache.\n        cache.putAll(batch);\n\n        System.out.println(\">>> Bulk-stored values in cache.\");\n\n        // Bulk-get values from cache.\n        Map<Integer, String> vals = cache.getAll(batch.keySet());\n\n        for (Map.Entry<Integer, String> e : vals.entrySet())\n            System.out.println(\"Got entry [key=\" + e.getKey() + \", val=\" + e.getValue() + ']');\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            // Clean up caches on all nodes before run.\n            g.cache(CACHE_NAME).globalClearAll(0);\n\n            // Individual puts and gets.\n            putGet();\n\n            // Bulk puts and gets.\n            putAllGetAll();\n        }\n    }","id":71368,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            // Clean up caches on all nodes before run.\n            g.jcache(CACHE_NAME).clear();\n\n            // Individual puts and gets.\n            putGet();\n\n            // Bulk puts and gets.\n            putAllGetAll();\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache query example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.cache(CACHE_NAME).globalClearAll(0);\n\n            // Populate cache.\n            initialize();\n\n            // Example for SQL-based querying employees based on salary ranges.\n            sqlQuery();\n\n            // Example for SQL-based querying employees for a given organization (includes SQL join).\n            sqlQueryWithJoin();\n\n            // Example for TEXT-based querying for a given string in peoples resumes.\n            textQuery();\n\n            // Example for SQL-based querying with custom remote and local reducers\n            // to calculate average salary among all employees within a company.\n            sqlQueryWithReducers();\n\n            // Example for SQL-based querying with custom remote transformer to make sure\n            // that only required data without any overhead is returned to caller.\n            sqlQueryWithTransformer();\n\n            // Example for SQL-based fields queries that return only required\n            // fields instead of whole key-value pairs.\n            sqlFieldsQuery();\n\n            // Example for SQL-based fields queries that uses joins.\n            sqlFieldsQueryWithJoin();\n\n            print(\"Cache query example finished.\");\n        }\n    }","id":71369,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache query example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.jcache(CACHE_NAME).clear();\n\n            // Populate cache.\n            initialize();\n\n            // Example for SQL-based querying employees based on salary ranges.\n            sqlQuery();\n\n            // Example for SQL-based querying employees for a given organization (includes SQL join).\n            sqlQueryWithJoin();\n\n            // Example for TEXT-based querying for a given string in peoples resumes.\n            textQuery();\n\n            // Example for SQL-based querying with custom remote and local reducers\n            // to calculate average salary among all employees within a company.\n            sqlQueryWithReducers();\n\n            // Example for SQL-based querying with custom remote transformer to make sure\n            // that only required data without any overhead is returned to caller.\n            sqlQueryWithTransformer();\n\n            // Example for SQL-based fields queries that return only required\n            // fields instead of whole key-value pairs.\n            sqlFieldsQuery();\n\n            // Example for SQL-based fields queries that uses joins.\n            sqlFieldsQueryWithJoin();\n\n            print(\"Cache query example finished.\");\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Populate cache with {@code 'dimensions'} which in our case are\n     * {@link DimStore} and {@link DimProduct} instances.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void populateDimensions() throws IgniteCheckedException {\n        GridCache<Integer, Object> cache = Ignition.ignite().cache(REPLICATED_CACHE_NAME);\n\n        DimStore store1 = new DimStore(idGen++, \"Store1\", \"12345\", \"321 Chilly Dr, NY\");\n        DimStore store2 = new DimStore(idGen++, \"Store2\", \"54321\", \"123 Windy Dr, San Francisco\");\n\n        // Populate stores.\n        cache.put(store1.getId(), store1);\n        cache.put(store2.getId(), store2);\n\n        // Populate products\n        for (int i = 0; i < 20; i++) {\n            int id = idGen++;\n\n            cache.put(id, new DimProduct(id, \"Product\" + i, i + 1, (i + 1) * 10));\n        }\n    }","id":71370,"modified_method":"/**\n     * Populate cache with {@code 'dimensions'} which in our case are\n     * {@link DimStore} and {@link DimProduct} instances.\n     *\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void populateDimensions() throws IgniteCheckedException {\n        IgniteCache<Integer, Object> cache = Ignition.ignite().jcache(REPLICATED_CACHE_NAME);\n\n        DimStore store1 = new DimStore(idGen++, \"Store1\", \"12345\", \"321 Chilly Dr, NY\");\n        DimStore store2 = new DimStore(idGen++, \"Store2\", \"54321\", \"123 Windy Dr, San Francisco\");\n\n        // Populate stores.\n        cache.put(store1.getId(), store1);\n        cache.put(store2.getId(), store2);\n\n        // Populate products\n        for (int i = 0; i < 20; i++) {\n            int id = idGen++;\n\n            cache.put(id, new DimProduct(id, \"Product\" + i, i + 1, (i + 1) * 10));\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        Ignite g = Ignition.start(\"examples/config/example-cache.xml\");\n\n        System.out.println();\n        System.out.println(\">>> Cache star schema example started.\");\n\n        // Clean up caches on all nodes before run.\n        g.cache(PARTITIONED_CACHE_NAME).globalClearAll(0);\n        g.cache(REPLICATED_CACHE_NAME).globalClearAll(0);\n\n        try {\n            populateDimensions();\n            populateFacts();\n\n            queryStorePurchases();\n            queryProductPurchases();\n        }\n        finally {\n            Ignition.stop(false);\n        }\n    }","id":71371,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        Ignite g = Ignition.start(\"examples/config/example-cache.xml\");\n\n        System.out.println();\n        System.out.println(\">>> Cache star schema example started.\");\n\n        // Clean up caches on all nodes before run.\n        g.jcache(PARTITIONED_CACHE_NAME).clear();\n        g.jcache(REPLICATED_CACHE_NAME).clear();\n\n        try {\n            populateDimensions();\n            populateFacts();\n\n            queryStorePurchases();\n            queryProductPurchases();\n        }\n        finally {\n            Ignition.stop(false);\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        IgniteConfiguration cfg = CacheNodeWithStoreStartup.configure();\n\n        // To start grid with desired configuration uncomment the appropriate line.\n        try (Ignite g = Ignition.start(cfg)) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            GridCache<Long, Person> cache = g.cache(null);\n\n            // Clean up caches on all nodes before run.\n            cache.globalClearAll(0);\n\n            try (IgniteTx tx = cache.txStart()) {\n                Person val = cache.get(id);\n\n                System.out.println(\"Read value: \" + val);\n\n                val = cache.put(id, person(id, \"Isaac\", \"Newton\"));\n\n                System.out.println(\"Overwrote old value: \" + val);\n\n                val = cache.get(id);\n\n                System.out.println(\"Read value: \" + val);\n\n                tx.commit();\n            }\n\n            System.out.println(\"Read value after commit: \" + cache.get(id));\n        }\n    }","id":71372,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        IgniteConfiguration cfg = CacheNodeWithStoreStartup.configure();\n\n        // To start grid with desired configuration uncomment the appropriate line.\n        try (Ignite g = Ignition.start(cfg)) {\n            System.out.println();\n            System.out.println(\">>> Cache store example started.\");\n\n            IgniteCache<Long, Person> cache = g.jcache(null);\n\n            // Clean up caches on all nodes before run.\n            cache.clear();\n\n            try (IgniteTx tx = g.transactions().txStart()) {\n                Person val = cache.get(id);\n\n                System.out.println(\"Read value: \" + val);\n\n                cache.put(id, person(id, \"Isaac\", \"Newton\"));\n\n                val = cache.get(id);\n\n                System.out.println(\"Read value: \" + val);\n\n                tx.commit();\n            }\n\n            System.out.println(\"Read value after commit: \" + cache.get(id));\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        try (Ignite g = Ignition.start(CacheNodeWithStoreStartup.configure())) {\n            System.out.println();\n            System.out.println(\">>> Cache store load data example started.\");\n\n            final GridCache<String, Integer> cache = g.cache(null);\n\n            // Clean up caches on all nodes before run.\n            cache.globalClearAll(0);\n\n            long start = System.currentTimeMillis();\n\n            // Start loading cache on all caching nodes.\n            g.compute(g.cluster().forCache(null)).broadcast(new IgniteCallable<Object>() {\n                @Override public Object call() throws Exception {\n                    // Load cache from persistent store.\n                    cache.loadCache(null, 0, ENTRY_COUNT);\n\n                    return null;\n                }\n            });\n\n            long end = System.currentTimeMillis();\n\n            System.out.println(\">>> Loaded \" + ENTRY_COUNT + \" keys with backups in \" + (end - start) + \"ms.\");\n        }\n    }","id":71373,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws Exception {\n        ExamplesUtils.checkMinMemory(MIN_MEMORY);\n\n        try (Ignite g = Ignition.start(CacheNodeWithStoreStartup.configure())) {\n            System.out.println();\n            System.out.println(\">>> Cache store load data example started.\");\n\n            final IgniteCache<String, Integer> cache = g.jcache(null);\n\n            // Clean up caches on all nodes before run.\n            cache.clear();\n\n            long start = System.currentTimeMillis();\n\n            // Start loading cache on all caching nodes.\n            g.compute(g.cluster().forCache(null)).broadcast(new IgniteCallable<Object>() {\n                @Override public Object call() throws Exception {\n                    // Load cache from persistent store.\n                    cache.loadCache(null, 0, ENTRY_COUNT);\n\n                    return null;\n                }\n            });\n\n            long end = System.currentTimeMillis();\n\n            System.out.println(\">>> Loaded \" + ENTRY_COUNT + \" keys with backups in \" + (end - start) + \"ms.\");\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Make deposit into specified account.\n     *\n     * @param acctId Account ID.\n     * @param amount Amount to deposit.\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void deposit(int acctId, double amount) throws IgniteCheckedException {\n        // Clone every object we get from cache, so we can freely update it.\n        CacheProjection<Integer, Account> cache = Ignition.ignite().<Integer, Account>cache(CACHE_NAME).flagsOn(CLONE);\n\n        try (IgniteTx tx = cache.txStart(PESSIMISTIC, REPEATABLE_READ)) {\n            Account acct = cache.get(acctId);\n\n            assert acct != null;\n\n            // Deposit into account.\n            acct.update(amount);\n\n            // Store updated account in cache.\n            cache.putx(acctId, acct);\n\n            tx.commit();\n        }\n\n        System.out.println();\n        System.out.println(\">>> Transferred amount: $\" + amount);\n    }","id":71374,"modified_method":"/**\n     * Make deposit into specified account.\n     *\n     * @param acctId Account ID.\n     * @param amount Amount to deposit.\n     * @throws IgniteCheckedException If failed.\n     */\n    private static void deposit(int acctId, double amount) throws IgniteCheckedException {\n        // Clone every object we get from cache, so we can freely update it.\n        IgniteCache<Integer, Account> cache = Ignition.ignite().jcache(CACHE_NAME);\n\n        try (IgniteTx tx = Ignition.ignite().transactions().txStart(PESSIMISTIC, REPEATABLE_READ)) {\n            assert cache.get(acctId) != null;\n\n            Account acct = new Account(cache.get(acctId).id, cache.get(acctId).balance);\n\n            // Deposit into account.\n            acct.update(amount);\n\n            // Store updated account in cache.\n            cache.put(acctId, acct);\n\n            tx.commit();\n        }\n\n        System.out.println();\n        System.out.println(\">>> Transferred amount: $\" + amount);\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache transaction example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.cache(CACHE_NAME).globalClearAll(0);\n\n            GridCache<Integer, Account> cache = g.cache(CACHE_NAME);\n\n            // Initialize.\n            cache.putx(1, new Account(1, 100));\n            cache.putx(2, new Account(1, 200));\n\n            System.out.println();\n            System.out.println(\">>> Accounts before deposit: \");\n            System.out.println(\">>> \" + cache.get(1));\n            System.out.println(\">>> \" + cache.get(2));\n\n            // Make transactional deposits.\n            deposit(1, 100);\n            deposit(2, 200);\n\n            System.out.println();\n            System.out.println(\">>> Accounts after transfer: \");\n            System.out.println(\">>> \" + cache.get(1));\n            System.out.println(\">>> \" + cache.get(2));\n\n            System.out.println(\">>> Cache transaction example finished.\");\n        }\n    }","id":71375,"modified_method":"/**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteCheckedException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteCheckedException {\n        try (Ignite g = Ignition.start(\"examples/config/example-cache.xml\")) {\n            System.out.println();\n            System.out.println(\">>> Cache transaction example started.\");\n\n            // Clean up caches on all nodes before run.\n            g.jcache(CACHE_NAME).clear();\n\n            IgniteCache<Integer, Account> cache = g.jcache(CACHE_NAME);\n\n            // Initialize.\n            cache.put(1, new Account(1, 100));\n            cache.put(2, new Account(1, 200));\n\n            System.out.println();\n            System.out.println(\">>> Accounts before deposit: \");\n            System.out.println(\">>> \" + cache.get(1));\n            System.out.println(\">>> \" + cache.get(2));\n\n            // Make transactional deposits.\n            deposit(1, 100);\n            deposit(2, 200);\n\n            System.out.println();\n            System.out.println(\">>> Accounts after transfer: \");\n            System.out.println(\">>> \" + cache.get(1));\n            System.out.println(\">>> \" + cache.get(2));\n\n            System.out.println(\">>> Cache transaction example finished.\");\n        }\n    }","commit_id":"72b94af4b78f3cbfadc05e069a235f4c2497d026","url":"https://github.com/apache/ignite"},{"original_method":"@Override\n  public Collection<SNode> applyRule(TemplateCreateRootRule rule, TemplateExecutionEnvironment environment) throws GenerationException {\n    try {\n      tracer.push(taskName(\"create root rule\", rule.getRuleNode().resolve(MPSModuleRepository.getInstance())), true);\n      return wrapped.applyRule(rule, environment);\n    } finally {\n      tracer.pop();\n    }\n  }","id":71376,"modified_method":"@Override\n  public Collection<SNode> applyRule(TemplateCreateRootRule rule, TemplateExecutionEnvironment environment) throws GenerationException {\n    try {\n      tracer.push(taskName(\"create root rule\", rule.getRuleNode()), true);\n      return wrapped.applyRule(rule, environment);\n    } finally {\n      tracer.pop();\n    }\n  }","commit_id":"41c28825072fdd124cfed6052f4e3e299b46a583","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void executeScript(TemplateMappingScript mappingScript, SModel model) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(String.format(\"mapping script (%s)\", mappingScript.getLongName()), mappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance())), true);\n      wrapped.executeScript(mappingScript, model);\n    } finally {\n      tracer.pop();\n    }\n  }","id":71377,"modified_method":"@Override\n  public void executeScript(TemplateMappingScript mappingScript, SModel model) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(String.format(\"mapping script (%s)\", mappingScript.getLongName()), mappingScript.getScriptNode()), true);\n      wrapped.executeScript(mappingScript, model);\n    } finally {\n      tracer.pop();\n    }\n  }","commit_id":"41c28825072fdd124cfed6052f4e3e299b46a583","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Nullable\n  @Override\n  public Object evaluate(@NotNull PropertyValueQuery query, @NotNull PropertyMacroContext context) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(String.format(\"property macro(name: %s)\", query.getPropertyName()), null), true);\n      return wrapped.evaluate(query, context);\n    } finally {\n      tracer.pop();\n    }\n  }","id":71378,"modified_method":"@Nullable\n  @Override\n  public Object evaluate(@NotNull PropertyValueQuery query, @NotNull PropertyMacroContext context) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(String.format(\"property macro(name: %s)\", query.getPropertyName()), (SNodeReference) null), true);\n      return wrapped.evaluate(query, context);\n    } finally {\n      tracer.pop();\n    }\n  }","commit_id":"41c28825072fdd124cfed6052f4e3e299b46a583","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<SNode> tryToApply(TemplateReductionRule rule, TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    try {\n      SNode ruleNode = rule.getRuleNode().resolve(MPSModuleRepository.getInstance());\n      String taskName = taskName(String.format(\"trying to apply rule(%s)\", rule.getApplicableConcept()), ruleNode);\n      tracer.push(taskName, true);\n      return wrapped.tryToApply(rule, environment, context);\n    } finally {\n      tracer.pop();\n    }\n  }","id":71379,"modified_method":"@Override\n  public Collection<SNode> tryToApply(TemplateReductionRule rule, TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    try {\n      String taskName = taskName(String.format(\"trying to apply rule(%s)\", rule.getApplicableConcept()), rule.getRuleNode());\n      tracer.push(taskName, true);\n      return wrapped.tryToApply(rule, environment, context);\n    } finally {\n      tracer.pop();\n    }\n  }","commit_id":"41c28825072fdd124cfed6052f4e3e299b46a583","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean isApplicable(@NotNull TemplateRuleWithCondition rule, @NotNull TemplateContext context) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(\"check condition\", rule.getRuleNode().resolve(MPSModuleRepository.getInstance())), true);\n      return wrapped.isApplicable(rule, context);\n    } finally {\n      tracer.pop();\n    }\n  }","id":71380,"modified_method":"@Override\n  public boolean isApplicable(@NotNull TemplateRuleWithCondition rule, @NotNull TemplateContext context) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(\"check condition\", rule.getRuleNode()), true);\n      return wrapped.isApplicable(rule, context);\n    } finally {\n      tracer.pop();\n    }\n  }","commit_id":"41c28825072fdd124cfed6052f4e3e299b46a583","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public SNode getContextNode(TemplateWeavingRule rule, TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(\"context for weaving\", rule.getRuleNode().resolve(MPSModuleRepository.getInstance())), true);\n      return wrapped.getContextNode(rule, environment, context);\n    } finally {\n      tracer.pop();\n    }\n  }","id":71381,"modified_method":"@Override\n  public SNode getContextNode(TemplateWeavingRule rule, TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationFailureException {\n    try {\n      tracer.push(taskName(\"context for weaving\", rule.getRuleNode()), true);\n      return wrapped.getContextNode(rule, environment, context);\n    } finally {\n      tracer.pop();\n    }\n  }","commit_id":"41c28825072fdd124cfed6052f4e3e299b46a583","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Collection<SNode> applyRule(TemplateRootMappingRule rule, TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    try {\n      tracer.push(taskName(String.format(\"root mapping rule(%s)\", rule.getApplicableConcept()), rule.getRuleNode().resolve(MPSModuleRepository.getInstance())), true);\n      return wrapped.applyRule(rule, environment,context);\n    } finally {\n      tracer.pop();\n    }\n  }","id":71382,"modified_method":"@Override\n  public Collection<SNode> applyRule(TemplateRootMappingRule rule, TemplateExecutionEnvironment environment, TemplateContext context) throws GenerationException {\n    try {\n      tracer.push(taskName(String.format(\"root mapping rule(%s)\", rule.getApplicableConcept()), rule.getRuleNode()), true);\n      return wrapped.applyRule(rule, environment,context);\n    } finally {\n      tracer.pop();\n    }\n  }","commit_id":"41c28825072fdd124cfed6052f4e3e299b46a583","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FlattenIterable() {\n    this(new ArrayList<Iterable<T>>());\n  }","id":71383,"modified_method":"public FlattenIterable() {\n    myContent = new ArrayList<Iterable<T>>();\n  }","commit_id":"8a0b1d47772ee8dcde757313afb3e516343def7d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public FlattenIterable(Collection<Iterable<T>> content) {\n    myContent = content;\n  }","id":71384,"modified_method":"public FlattenIterable(Collection<? extends Iterable<T>> content) {\n    myContent = new ArrayList<Iterable<T>>(content);\n  }","commit_id":"8a0b1d47772ee8dcde757313afb3e516343def7d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public RuleManager(GenerationPlan plan, List<TemplateMappingConfiguration> configurations, IGeneratorLogger logger) {\n    myMappings = configurations;\n    myTemplateSwitchGraph = plan.getTemplateSwitchGraph();\n    if (myTemplateSwitchGraph == null) throw new IllegalStateException(\"switch graph is not initialized\");\n    initialize(myMappings, logger);\n    myRuleFinder = initRules(myMappings);\n\n    myModelMap = new HashMap<SModelReference, TemplateModel>();\n    for(TemplateModel m : plan.getTemplateModels()) {\n      myModelMap.put(m.getSModelReference(), m);\n    }\n  }","id":71385,"modified_method":"public RuleManager(GenerationPlan plan, List<TemplateMappingConfiguration> configurations, IGeneratorLogger logger) {\n    myTemplateSwitchGraph = plan.getTemplateSwitchGraph();\n    if (myTemplateSwitchGraph == null) throw new IllegalStateException(\"switch graph is not initialized\");\n    initialize(configurations, logger);\n    myRuleFinder = initRules(configurations);\n\n    myModelMap = new HashMap<SModelReference, TemplateModel>();\n    for(TemplateModel m : plan.getTemplateModels()) {\n      myModelMap.put(m.getSModelReference(), m);\n    }\n  }","commit_id":"8a0b1d47772ee8dcde757313afb3e516343def7d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void initialize(List<TemplateMappingConfiguration> list, IGeneratorLogger logger) {\n    myCreateRootRules = new FlattenIterable(new ArrayList<List<TemplateCreateRootRule>>(list.size()));\n    myRoot_MappingRules = new FlattenIterable(new ArrayList<List<TemplateRootMappingRule>>(list.size()));\n    myWeaving_MappingRules = new FlattenIterable(new ArrayList<List<TemplateWeavingRule>>(list.size()));\n    myDropRootRules = new FlattenIterable(new ArrayList<List<TemplateDropRootRule>>(list.size()));\n\n    for (TemplateMappingConfiguration mappingConfig : list) {\n      myCreateRootRules.add(mappingConfig.getCreateRules());\n      myRoot_MappingRules.add(mappingConfig.getRootRules());\n      myWeaving_MappingRules.add(mappingConfig.getWeavingRules());\n      myDropRootRules.add(mappingConfig.getDropRules());\n    }\n\n    LinkedList<TemplateMappingScript> postScripts = new LinkedList<TemplateMappingScript>();\n    LinkedList<TemplateMappingScript> preScripts = new LinkedList<TemplateMappingScript>();\n    String warnMsg = \"skip script %s - wrong script kind\";\n    for (TemplateMappingConfiguration mappingConfigs : list) {\n      for (TemplateMappingScript postMappingScript : mappingConfigs.getPostScripts()) {\n        if (postMappingScript.getKind() != TemplateMappingScript.POSTPROCESS) {\n          logger.warning(postMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()), String.format(warnMsg, postMappingScript.getLongName()));\n          continue;\n        }\n        postScripts.add(postMappingScript);\n      }\n      for (TemplateMappingScript preMappingScript :mappingConfigs.getPreScripts()) {\n        if (preMappingScript.getKind() != TemplateMappingScript.PREPROCESS) {\n          logger.warning(preMappingScript.getScriptNode().resolve(MPSModuleRepository.getInstance()), String.format(warnMsg, preMappingScript.getLongName()));\n          continue;\n        }\n        preScripts.add(preMappingScript);\n      }\n    }\n    myScripts = new ScriptManager(new ArrayList<TemplateMappingScript>(preScripts), new ArrayList<TemplateMappingScript>(postScripts));\n  }","id":71386,"modified_method":"private void initialize(List<TemplateMappingConfiguration> list, IGeneratorLogger logger) {\n    myCreateRootRules = new FlattenIterable<TemplateCreateRootRule>(list.size());\n    myRoot_MappingRules = new FlattenIterable<TemplateRootMappingRule>(list.size());\n    myWeaving_MappingRules = new FlattenIterable<TemplateWeavingRule>(list.size());\n    myDropRootRules = new FlattenIterable<TemplateDropRootRule>(list.size());\n\n    for (TemplateMappingConfiguration mappingConfig : list) {\n      myCreateRootRules.add(mappingConfig.getCreateRules());\n      myRoot_MappingRules.add(mappingConfig.getRootRules());\n      myWeaving_MappingRules.add(mappingConfig.getWeavingRules());\n      myDropRootRules.add(mappingConfig.getDropRules());\n    }\n\n    LinkedList<TemplateMappingScript> postScripts = new LinkedList<TemplateMappingScript>();\n    LinkedList<TemplateMappingScript> preScripts = new LinkedList<TemplateMappingScript>();\n    String warnMsg = \"skip script %s - wrong script kind\";\n    for (TemplateMappingConfiguration mappingConfigs : list) {\n      for (TemplateMappingScript postMappingScript : mappingConfigs.getPostScripts()) {\n        if (postMappingScript.getKind() != TemplateMappingScript.POSTPROCESS) {\n          logger.warning(postMappingScript.getScriptNode(), String.format(warnMsg, postMappingScript.getLongName()));\n          continue;\n        }\n        postScripts.add(postMappingScript);\n      }\n      for (TemplateMappingScript preMappingScript :mappingConfigs.getPreScripts()) {\n        if (preMappingScript.getKind() != TemplateMappingScript.PREPROCESS) {\n          logger.warning(preMappingScript.getScriptNode(), String.format(warnMsg, preMappingScript.getLongName()));\n          continue;\n        }\n        preScripts.add(preMappingScript);\n      }\n    }\n    myScripts = new ScriptManager(new ArrayList<TemplateMappingScript>(preScripts), new ArrayList<TemplateMappingScript>(postScripts));\n  }","commit_id":"8a0b1d47772ee8dcde757313afb3e516343def7d","url":"https://github.com/JetBrains/MPS"},{"original_method":"private FastRuleFinder initRules(List<TemplateMappingConfiguration> configuration) {\n    FlattenIterable<TemplateReductionRule> rules = new FlattenIterable<TemplateReductionRule>(new ArrayList<Iterable<TemplateReductionRule>>());\n    for (TemplateMappingConfiguration c : configuration) {\n      rules.add(c.getReductionRules());\n    }\n\n    return new FastRuleFinder(rules);\n  }","id":71387,"modified_method":"private FastRuleFinder initRules(List<TemplateMappingConfiguration> configuration) {\n    FlattenIterable<TemplateReductionRule> rules = new FlattenIterable<TemplateReductionRule>();\n    for (TemplateMappingConfiguration c : configuration) {\n      rules.add(c.getReductionRules());\n    }\n\n    return new FastRuleFinder(rules);\n  }","commit_id":"8a0b1d47772ee8dcde757313afb3e516343def7d","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\r\n\t * Dumps the instance as string.\r\n\t */\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\tcheckForFields();\r\n\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\r\n\t\tbuffer.append(_clazz == null ? \"<unknown>\" : _clazz.getName());\r\n\r\n\t\tif (_recordId != null) {\r\n\t\t\tbuffer.append(\"@\");\r\n\t\t\tif (_recordId != null && _recordId.isValid())\r\n\t\t\t\tbuffer.append(_recordId);\r\n\t\t}\r\n\r\n\t\tboolean first = true;\r\n\t\tfor (Entry<String, Object> f : _fieldValues.entrySet()) {\r\n\t\t\tbuffer.append(first ? \"{\" : \",\");\r\n\t\t\tbuffer.append(f.getKey());\r\n\t\t\tbuffer.append(\":\");\r\n\t\t\tif (f.getValue() instanceof Collection<?>) {\r\n\t\t\t\tbuffer.append(\"[\");\r\n\t\t\t\tbuffer.append(((Collection<?>) f.getValue()).size());\r\n\t\t\t\tbuffer.append(\"]\");\r\n\t\t\t} else if (f.getValue() instanceof ORecord<?>) {\r\n\t\t\t\tbuffer.append(\"#\");\r\n\t\t\t\tbuffer.append(((ORecord<?>) f.getValue()).getIdentity());\r\n\t\t\t} else\r\n\t\t\t\tbuffer.append(f.getValue());\r\n\r\n\t\t\tif (first)\r\n\t\t\t\tfirst = false;\r\n\t\t}\r\n\t\tif (!first)\r\n\t\t\tbuffer.append(\"}\");\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":71388,"modified_method":"/**\r\n\t * Dumps the instance as string.\r\n\t */\r\n\t@Override\r\n\tpublic String toString() {\r\n\t\tcheckForFields();\r\n\r\n\t\tStringBuilder buffer = new StringBuilder();\r\n\r\n\t\tif (_clazz != null)\r\n\t\t\tbuffer.append(_clazz.getName());\r\n\r\n\t\tif (_recordId != null) {\r\n\t\t\tif (buffer.length() > 0)\r\n\t\t\t\tbuffer.append(\"@\");\r\n\t\t\tif (_recordId != null && _recordId.isValid())\r\n\t\t\t\tbuffer.append(_recordId);\r\n\t\t}\r\n\r\n\t\tboolean first = true;\r\n\t\tfor (Entry<String, Object> f : _fieldValues.entrySet()) {\r\n\t\t\tbuffer.append(first ? \"{\" : \",\");\r\n\t\t\tbuffer.append(f.getKey());\r\n\t\t\tbuffer.append(\":\");\r\n\t\t\tif (f.getValue() instanceof Collection<?>) {\r\n\t\t\t\tbuffer.append(\"[\");\r\n\t\t\t\tbuffer.append(((Collection<?>) f.getValue()).size());\r\n\t\t\t\tbuffer.append(\"]\");\r\n\t\t\t} else if (f.getValue() instanceof ORecord<?>) {\r\n\t\t\t\tbuffer.append(\"#\");\r\n\t\t\t\tbuffer.append(((ORecord<?>) f.getValue()).getIdentity());\r\n\t\t\t} else\r\n\t\t\t\tbuffer.append(f.getValue());\r\n\r\n\t\t\tif (first)\r\n\t\t\t\tfirst = false;\r\n\t\t}\r\n\t\tif (!first)\r\n\t\t\tbuffer.append(\"}\");\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Remove the current event listener.\r\n\t * \r\n\t * @see ORecordListener\r\n\t */\r\n\tpublic void removeListener() {\r\n\t\tlistener = null;\r\n\t}","id":71389,"modified_method":"/**\r\n\t * Remove the current event listener.\r\n\t * \r\n\t * @see ORecordListener\r\n\t */\r\n\tpublic void removeListener() {\r\n\t\t_listener = null;\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void invokeListenerEvent(final ORecordListener.EVENT iEvent) {\r\n\t\tif (listener != null)\r\n\t\t\tlistener.onEvent(this, iEvent);\r\n\t}","id":71390,"modified_method":"protected void invokeListenerEvent(final ORecordListener.EVENT iEvent) {\r\n\t\tif (_listener != null)\r\n\t\t\t_listener.onEvent(this, iEvent);\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public ORecordAbstract<T> copyTo(final ORecordAbstract<T> cloned) {\r\n\t\tcloned._database = _database;\r\n\t\tcloned._recordId = _recordId.copy();\r\n\t\tcloned._version = _version;\r\n\t\tcloned._source = null;\r\n\t\tcloned._recordFormat = _recordFormat;\r\n\t\tcloned._pinned = _pinned;\r\n\t\tcloned._dirty = _dirty;\r\n\t\tcloned._status = _status;\r\n\t\tcloned.listener = listener;\r\n\t\treturn cloned;\r\n\t}","id":71391,"modified_method":"public ORecordAbstract<T> copyTo(final ORecordAbstract<T> cloned) {\r\n\t\tcloned._database = _database;\r\n\t\tcloned._recordId = _recordId.copy();\r\n\t\tcloned._version = _version;\r\n\t\tcloned._source = null;\r\n\t\tcloned._recordFormat = _recordFormat;\r\n\t\tcloned._pinned = _pinned;\r\n\t\tcloned._dirty = _dirty;\r\n\t\tcloned._status = _status;\r\n\t\tcloned._listener = _listener;\r\n\t\treturn cloned;\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n\t * Add a listener to the current document to catch all the supported events.\r\n\t * \r\n\t * @see ORecordListener\r\n\t * \r\n\t * @param iListener\r\n\t *          ODocumentListener implementation\r\n\t */\r\n\tpublic void setListener(final ORecordListener iListener) {\r\n\t\tlistener = iListener;\r\n\t}","id":71392,"modified_method":"/**\r\n\t * Add a listener to the current document to catch all the supported events.\r\n\t * \r\n\t * @see ORecordListener\r\n\t * \r\n\t * @param iListener\r\n\t *          ODocumentListener implementation\r\n\t */\r\n\tpublic void setListener(final ORecordListener iListener) {\r\n\t\t_listener = iListener;\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object embeddedCollectionFromStream(final ODatabaseRecord<?> iDatabase, final OType iType, OClass iLinkedClass,\r\n\t\t\tOType iLinkedType, final String iValue) {\r\n\t\tif (iValue.length() == 0)\r\n\t\t\treturn null;\r\n\r\n\t\t// REMOVE BEGIN & END COLLECTIONS CHARACTERS IF IT'S A COLLECTION\r\n\t\tfinal String value = iValue.startsWith(\"[\") ? iValue.substring(1, iValue.length() - 1) : iValue;\r\n\r\n\t\tfinal Collection<Object> coll = iType == OType.EMBEDDEDLIST ? new ArrayList<Object>() : new HashSet<Object>();\r\n\r\n\t\tif (value.length() == 0)\r\n\t\t\treturn coll;\r\n\r\n\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\tfor (String item : items) {\r\n\t\t\tif (iLinkedClass != null) {\r\n\t\t\t\t// EMBEDDED RECORD\r\n\t\t\t\tif (item.length() > 2) {\r\n\t\t\t\t\titem = item.substring(1, item.length() - 1);\r\n\t\t\t\t\tcoll.add(fromString(iDatabase, item, new ODocument(iDatabase, iLinkedClass.getName())));\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if (item.length() > 0 && item.charAt(0) == OStringSerializerHelper.EMBEDDED) {\r\n\t\t\t\t// EMBEDDED OBJECT\r\n\t\t\t\tcoll.add(OStringSerializerHelper.fieldTypeFromStream(iLinkedType, item.substring(1, item.length() - 1)));\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// EMBEDDED LITERAL\r\n\t\t\t\tif (iLinkedType == null)\r\n\t\t\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\t\t\"Linked type can't be null. Probably the serialized type has not stored the type along with data\");\r\n\t\t\t\tcoll.add(OStringSerializerHelper.fieldTypeFromStream(iLinkedType, item));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn coll;\r\n\t}","id":71393,"modified_method":"public Object embeddedCollectionFromStream(final ODocument iDocument, final OType iType, OClass iLinkedClass, OType iLinkedType,\r\n\t\t\tfinal String iValue) {\r\n\t\tif (iValue.length() == 0)\r\n\t\t\treturn null;\r\n\r\n\t\t// REMOVE BEGIN & END COLLECTIONS CHARACTERS IF IT'S A COLLECTION\r\n\t\tfinal String value = iValue.startsWith(\"[\") ? iValue.substring(1, iValue.length() - 1) : iValue;\r\n\r\n\t\tfinal Collection<Object> coll = iType == OType.EMBEDDEDLIST ? new ORecordTrackedList(iDocument) : new ORecordTrackedSet(\r\n\t\t\t\tiDocument);\r\n\r\n\t\tif (value.length() == 0)\r\n\t\t\treturn coll;\r\n\r\n\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\tObject objectToAdd;\r\n\t\tfor (String item : items) {\r\n\t\t\tobjectToAdd = null;\r\n\r\n\t\t\tif (iLinkedClass != null) {\r\n\t\t\t\t// EMBEDDED RECORD\r\n\t\t\t\tif (item.length() > 2) {\r\n\t\t\t\t\titem = item.substring(1, item.length() - 1);\r\n\t\t\t\t\tobjectToAdd = fromString(iDocument.getDatabase(), item, new ODocument(iDocument.getDatabase(), iLinkedClass.getName()));\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if (item.length() > 0 && item.charAt(0) == OStringSerializerHelper.EMBEDDED) {\r\n\t\t\t\t// EMBEDDED OBJECT\r\n\t\t\t\tobjectToAdd = OStringSerializerHelper.fieldTypeFromStream(iLinkedType, item.substring(1, item.length() - 1));\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// EMBEDDED LITERAL\r\n\t\t\t\tif (iLinkedType == null)\r\n\t\t\t\t\tthrow new IllegalArgumentException(\r\n\t\t\t\t\t\t\t\"Linked type can't be null. Probably the serialized type has not stored the type along with data\");\r\n\t\t\t\tobjectToAdd = OStringSerializerHelper.fieldTypeFromStream(iLinkedType, item);\r\n\t\t\t}\r\n\r\n\t\t\tif (objectToAdd != null) {\r\n\t\t\t\tif (objectToAdd instanceof ODocument)\r\n\t\t\t\t\t((ODocument) objectToAdd).setOwner(iDocument);\r\n\t\t\t\tcoll.add(objectToAdd);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn coll;\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Map<String, Object> embeddedMapFromStream(final ORecord<?> iSourceRecord, OType iLinkedType, final String iValue) {\r\n\t\tif (iValue.length() == 0)\r\n\t\t\treturn null;\r\n\r\n\t\t// REMOVE BEGIN & END MAP CHARACTERS\r\n\t\tString value = iValue.substring(1, iValue.length() - 1);\r\n\r\n\t\t@SuppressWarnings(\"rawtypes\")\r\n\t\tfinal Map map = new OLazyRecordMap(iSourceRecord, ODocument.RECORD_TYPE);\r\n\r\n\t\tif (value.length() == 0)\r\n\t\t\treturn map;\r\n\r\n\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t// EMBEDDED LITERALS\r\n\t\tList<String> entry;\r\n\t\tString mapValue;\r\n\t\tfor (String item : items) {\r\n\t\t\tif (item != null && item.length() > 0) {\r\n\t\t\t\tentry = OStringSerializerHelper.smartSplit(item, OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\t\t\t\tif (entry.size() > 0) {\r\n\t\t\t\t\tmapValue = entry.get(1);\r\n\r\n\t\t\t\t\tif (iLinkedType == null) {\r\n\t\t\t\t\t\tif (mapValue.length() > 0) {\r\n\t\t\t\t\t\t\tif (mapValue.charAt(0) == OStringSerializerHelper.EMBEDDED) {\r\n\t\t\t\t\t\t\t\tiLinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t\t\tmapValue = mapValue.substring(1, mapValue.length() - 1);\r\n\t\t\t\t\t\t\t} else if (Character.isDigit(mapValue.charAt(0)) || mapValue.charAt(0) == '+' || mapValue.charAt(0) == '-') {\r\n\t\t\t\t\t\t\t\tiLinkedType = getNumber(mapValue);\r\n\t\t\t\t\t\t\t} else if (mapValue.charAt(0) == '\\'' || mapValue.charAt(0) == '\"')\r\n\t\t\t\t\t\t\t\tiLinkedType = OType.STRING;\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tiLinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmap.put((String) OStringSerializerHelper.fieldTypeFromStream(OType.STRING, entry.get(0)),\r\n\t\t\t\t\t\t\tOStringSerializerHelper.fieldTypeFromStream(iLinkedType, mapValue));\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t}","id":71394,"modified_method":"public Map<String, Object> embeddedMapFromStream(final ODocument iSourceDocument, OType iLinkedType, final String iValue) {\r\n\t\tif (iValue.length() == 0)\r\n\t\t\treturn null;\r\n\r\n\t\t// REMOVE BEGIN & END MAP CHARACTERS\r\n\t\tString value = iValue.substring(1, iValue.length() - 1);\r\n\r\n\t\t@SuppressWarnings(\"rawtypes\")\r\n\t\tfinal Map map = new OLazyRecordMap(iSourceDocument, ODocument.RECORD_TYPE);\r\n\r\n\t\tif (value.length() == 0)\r\n\t\t\treturn map;\r\n\r\n\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t// EMBEDDED LITERALS\r\n\t\tList<String> entry;\r\n\t\tString mapValue;\r\n\t\tObject mapValueObject;\r\n\r\n\t\tfor (String item : items) {\r\n\t\t\tif (item != null && item.length() > 0) {\r\n\t\t\t\tentry = OStringSerializerHelper.smartSplit(item, OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\t\t\t\tif (entry.size() > 0) {\r\n\t\t\t\t\tmapValue = entry.get(1);\r\n\r\n\t\t\t\t\tif (iLinkedType == null) {\r\n\t\t\t\t\t\tif (mapValue.length() > 0) {\r\n\t\t\t\t\t\t\tif (mapValue.charAt(0) == OStringSerializerHelper.EMBEDDED) {\r\n\t\t\t\t\t\t\t\tiLinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t\t\tmapValue = mapValue.substring(1, mapValue.length() - 1);\r\n\t\t\t\t\t\t\t} else if (Character.isDigit(mapValue.charAt(0)) || mapValue.charAt(0) == '+' || mapValue.charAt(0) == '-') {\r\n\t\t\t\t\t\t\t\tiLinkedType = getNumber(mapValue);\r\n\t\t\t\t\t\t\t} else if (mapValue.charAt(0) == '\\'' || mapValue.charAt(0) == '\"')\r\n\t\t\t\t\t\t\t\tiLinkedType = OType.STRING;\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tiLinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tmapValueObject = OStringSerializerHelper.fieldTypeFromStream(iLinkedType, mapValue);\r\n\r\n\t\t\t\t\tif (mapValueObject != null && mapValueObject instanceof ODocument)\r\n\t\t\t\t\t\t((ODocument) mapValueObject).setOwner(iSourceDocument);\r\n\r\n\t\t\t\t\tmap.put((String) OStringSerializerHelper.fieldTypeFromStream(OType.STRING, entry.get(0)), mapValueObject);\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Object fieldFromStream(final ORecord<?> iSourceRecord, final OType iType, OClass iLinkedClass, OType iLinkedType,\r\n\t\t\tfinal String iName, final String iValue) {\r\n\r\n\t\tif (iValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tswitch (iType) {\r\n\t\tcase EMBEDDEDLIST:\r\n\t\tcase EMBEDDEDSET:\r\n\t\t\treturn embeddedCollectionFromStream(iSourceRecord.getDatabase(), iType, iLinkedClass, iLinkedType, iValue);\r\n\r\n\t\tcase LINKLIST:\r\n\t\tcase LINKSET: {\r\n\t\t\tif (iValue.length() == 0)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t// REMOVE BEGIN & END COLLECTIONS CHARACTERS IF IT'S A COLLECTION\r\n\t\t\tString value = iValue.startsWith(\"[\") ? iValue.substring(1, iValue.length() - 1) : iValue;\r\n\r\n\t\t\tCollection<Object> coll = iType == OType.LINKLIST ? new OLazyRecordList(iSourceRecord, ODocument.RECORD_TYPE)\r\n\t\t\t\t\t: new OLazyRecordSet(iSourceRecord, ODocument.RECORD_TYPE);\r\n\r\n\t\t\tif (value.length() == 0)\r\n\t\t\t\treturn coll;\r\n\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\t// GET THE CLASS NAME IF ANY\r\n\t\t\t\tint classSeparatorPos = value.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (classSeparatorPos > -1) {\r\n\t\t\t\t\tString className = value.substring(1, classSeparatorPos);\r\n\t\t\t\t\tif (className != null) {\r\n\t\t\t\t\t\tiLinkedClass = iSourceRecord.getDatabase().getMetadata().getSchema().getClass(className);\r\n\t\t\t\t\t\titem = item.substring(classSeparatorPos + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\titem = item.substring(1);\r\n\r\n\t\t\t\tif (item.length() == 0)\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tcoll.add(new ORecordId(item));\r\n\t\t\t\t// coll.add(new ODocument(iDatabase, iLinkedClass != null ? iLinkedClass.getName() : null, new ORecordId(item)));\r\n\t\t\t}\r\n\r\n\t\t\treturn coll;\r\n\t\t}\r\n\r\n\t\tcase LINKMAP: {\r\n\t\t\tif (iValue.length() == 0)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t// REMOVE BEGIN & END MAP CHARACTERS\r\n\t\t\tString value = iValue.substring(1, iValue.length() - 1);\r\n\r\n\t\t\t@SuppressWarnings(\"rawtypes\")\r\n\t\t\tfinal Map map = new OLazyRecordMap(iSourceRecord, ODocument.RECORD_TYPE);\r\n\r\n\t\t\tif (value.length() == 0)\r\n\t\t\t\treturn map;\r\n\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t// EMBEDDED LITERALS\r\n\t\t\tList<String> entry;\r\n\t\t\tString mapValue;\r\n\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\tif (item != null && item.length() > 0) {\r\n\t\t\t\t\tentry = OStringSerializerHelper.smartSplit(item, OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\t\t\t\t\tif (entry.size() > 0) {\r\n\t\t\t\t\t\tmapValue = getLinkedRecord(iSourceRecord.getDatabase(), value, entry.get(1));\r\n\t\t\t\t\t\tmap.put((String) OStringSerializerHelper.fieldTypeFromStream(OType.STRING, entry.get(0)), new ORecordId(mapValue));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn map;\r\n\t\t}\r\n\r\n\t\tcase EMBEDDEDMAP:\r\n\t\t\treturn embeddedMapFromStream(iSourceRecord, iLinkedType, iValue);\r\n\r\n\t\tcase LINK:\r\n\t\t\tif (iValue.length() > 1) {\r\n\t\t\t\tint pos = iValue.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (pos > -1)\r\n\t\t\t\t\tiLinkedClass = iSourceRecord.getDatabase().getMetadata().getSchema().getClass(iValue.substring(1, pos));\r\n\t\t\t\telse\r\n\t\t\t\t\tpos = 0;\r\n\r\n\t\t\t\treturn new ORecordId(iValue.substring(pos + 1));\r\n\t\t\t} else\r\n\t\t\t\treturn null;\r\n\r\n\t\tdefault:\r\n\t\t\treturn OStringSerializerHelper.fieldTypeFromStream(iType, iValue);\r\n\t\t}\r\n\t}","id":71395,"modified_method":"public Object fieldFromStream(final ORecord<?> iSourceRecord, final OType iType, OClass iLinkedClass, OType iLinkedType,\r\n\t\t\tfinal String iName, final String iValue) {\r\n\r\n\t\tif (iValue == null)\r\n\t\t\treturn null;\r\n\r\n\t\tswitch (iType) {\r\n\t\tcase EMBEDDEDLIST:\r\n\t\tcase EMBEDDEDSET:\r\n\t\t\treturn embeddedCollectionFromStream((ODocument) iSourceRecord, iType, iLinkedClass, iLinkedType, iValue);\r\n\r\n\t\tcase LINKLIST:\r\n\t\tcase LINKSET: {\r\n\t\t\tif (iValue.length() == 0)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t// REMOVE BEGIN & END COLLECTIONS CHARACTERS IF IT'S A COLLECTION\r\n\t\t\tString value = iValue.startsWith(\"[\") ? iValue.substring(1, iValue.length() - 1) : iValue;\r\n\r\n\t\t\tCollection<Object> coll = iType == OType.LINKLIST ? new OLazyRecordList(iSourceRecord, ODocument.RECORD_TYPE)\r\n\t\t\t\t\t: new OLazyRecordSet(iSourceRecord, ODocument.RECORD_TYPE);\r\n\r\n\t\t\tif (value.length() == 0)\r\n\t\t\t\treturn coll;\r\n\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\t// GET THE CLASS NAME IF ANY\r\n\t\t\t\tint classSeparatorPos = value.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (classSeparatorPos > -1) {\r\n\t\t\t\t\tString className = value.substring(1, classSeparatorPos);\r\n\t\t\t\t\tif (className != null) {\r\n\t\t\t\t\t\tiLinkedClass = iSourceRecord.getDatabase().getMetadata().getSchema().getClass(className);\r\n\t\t\t\t\t\titem = item.substring(classSeparatorPos + 1);\r\n\t\t\t\t\t}\r\n\t\t\t\t} else\r\n\t\t\t\t\titem = item.substring(1);\r\n\r\n\t\t\t\tif (item.length() == 0)\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\tcoll.add(new ORecordId(item));\r\n\t\t\t\t// coll.add(new ODocument(iDatabase, iLinkedClass != null ? iLinkedClass.getName() : null, new ORecordId(item)));\r\n\t\t\t}\r\n\r\n\t\t\treturn coll;\r\n\t\t}\r\n\r\n\t\tcase LINKMAP: {\r\n\t\t\tif (iValue.length() == 0)\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t// REMOVE BEGIN & END MAP CHARACTERS\r\n\t\t\tString value = iValue.substring(1, iValue.length() - 1);\r\n\r\n\t\t\t@SuppressWarnings(\"rawtypes\")\r\n\t\t\tfinal Map map = new OLazyRecordMap(iSourceRecord, ODocument.RECORD_TYPE);\r\n\r\n\t\t\tif (value.length() == 0)\r\n\t\t\t\treturn map;\r\n\r\n\t\t\tfinal List<String> items = OStringSerializerHelper.smartSplit(value, OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t// EMBEDDED LITERALS\r\n\t\t\tList<String> entry;\r\n\t\t\tString mapValue;\r\n\r\n\t\t\tfor (String item : items) {\r\n\t\t\t\tif (item != null && item.length() > 0) {\r\n\t\t\t\t\tentry = OStringSerializerHelper.smartSplit(item, OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\t\t\t\t\tif (entry.size() > 0) {\r\n\t\t\t\t\t\tmapValue = getLinkedRecord(iSourceRecord.getDatabase(), value, entry.get(1));\r\n\t\t\t\t\t\tmap.put((String) OStringSerializerHelper.fieldTypeFromStream(OType.STRING, entry.get(0)), new ORecordId(mapValue));\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn map;\r\n\t\t}\r\n\r\n\t\tcase EMBEDDEDMAP:\r\n\t\t\treturn embeddedMapFromStream((ODocument) iSourceRecord, iLinkedType, iValue);\r\n\r\n\t\tcase LINK:\r\n\t\t\tif (iValue.length() > 1) {\r\n\t\t\t\tint pos = iValue.indexOf(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t\t\tif (pos > -1)\r\n\t\t\t\t\tiLinkedClass = iSourceRecord.getDatabase().getMetadata().getSchema().getClass(iValue.substring(1, pos));\r\n\t\t\t\telse\r\n\t\t\t\t\tpos = 0;\r\n\r\n\t\t\t\treturn new ORecordId(iValue.substring(pos + 1));\r\n\t\t\t} else\r\n\t\t\t\treturn null;\r\n\r\n\t\tdefault:\r\n\t\t\treturn OStringSerializerHelper.fieldTypeFromStream(iType, iValue);\r\n\t\t}\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\r\n\tprotected String toString(ORecordInternal<?> iRecord, final String iFormat, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal Set<Integer> iMarshalledRecords) {\r\n\t\tif (!(iRecord instanceof ODocument))\r\n\t\t\tthrow new OSerializationException(\"Can't marshall a record of type \" + iRecord.getClass().getSimpleName() + \" to CSV\");\r\n\r\n\t\tfinal ODocument record = (ODocument) iRecord;\r\n\r\n\t\t// CHECK IF THE RECORD IS PENDING TO BE MARSHALLED\r\n\t\tfinal Integer identityRecord = System.identityHashCode(record);\r\n\t\tif (iMarshalledRecords.contains(identityRecord)) {\r\n\t\t\treturn \"\";\r\n\t\t} else\r\n\t\t\tiMarshalledRecords.add(identityRecord);\r\n\r\n\t\tODatabaseRecord<?> database = record.getDatabase();\r\n\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\r\n\t\tif (record.getClassName() != null) {\r\n\t\t\t// MARSHALL THE CLASSNAME\r\n\t\t\tbuffer.append(record.getClassName());\r\n\t\t\tbuffer.append(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t}\r\n\r\n\t\tOProperty prop;\r\n\t\tObject fieldValue;\r\n\t\tOType type;\r\n\t\tOClass linkedClass;\r\n\t\tOType linkedType;\r\n\t\tString fieldClassName;\r\n\t\tint i = 0;\r\n\r\n\t\t// MARSHALL ALL THE CONFIGURED FIELDS\r\n\t\tfor (Entry<String, Object> f : record) {\r\n\t\t\tif (i > 0)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t// SEARCH FOR A CONFIGURED PROPERTY\r\n\t\t\tprop = record.getSchemaClass() != null ? record.getSchemaClass().getProperty(f.getKey()) : null;\r\n\t\t\tfieldValue = f.getValue();\r\n\t\t\tfieldClassName = getClassName(fieldValue);\r\n\r\n\t\t\ttype = record.fieldType(f.getKey());\r\n\t\t\tlinkedClass = null;\r\n\t\t\tlinkedType = null;\r\n\r\n\t\t\tif (prop != null) {\r\n\t\t\t\t// RECOGNIZED PROPERTY\r\n\t\t\t\ttype = prop.getType();\r\n\t\t\t\tlinkedClass = prop.getLinkedClass();\r\n\t\t\t\tlinkedType = prop.getLinkedType();\r\n\r\n\t\t\t} else if (fieldValue != null) {\r\n\r\n\t\t\t\t// NOT FOUND: TRY TO DETERMINE THE TYPE FROM ITS CONTENT\r\n\t\t\t\tif (fieldValue instanceof Collection<?> || fieldValue.getClass().isArray()) {\r\n\t\t\t\t\tfinal Collection<?> coll = fieldValue instanceof Collection<?> ? (Collection<?>) fieldValue : null;\r\n\r\n\t\t\t\t\tint size = coll != null ? coll.size() : Array.getLength(fieldValue);\r\n\r\n\t\t\t\t\tif (size > 0) {\r\n\t\t\t\t\t\tObject firstValue = coll != null ? coll.iterator().next() : Array.get(fieldValue, 0);\r\n\r\n\t\t\t\t\t\tif (database != null\r\n\t\t\t\t\t\t\t\t&& (firstValue instanceof ORID || firstValue instanceof ORecordSchemaAware<?> || (database.getDatabaseOwner() instanceof ODatabaseObject && ((ODatabaseObject) database\r\n\t\t\t\t\t\t\t\t\t\t.getDatabaseOwner()).getEntityManager().getEntityClass(getClassName(firstValue)) != null))) {\r\n\t\t\t\t\t\t\tlinkedClass = getLinkInfo(database, getClassName(firstValue));\r\n\t\t\t\t\t\t\tif (type == null) {\r\n\t\t\t\t\t\t\t\t// LINK: GET THE CLASS\r\n\t\t\t\t\t\t\t\tlinkedType = OType.LINK;\r\n\r\n\t\t\t\t\t\t\t\tif (coll instanceof Set<?>)\r\n\t\t\t\t\t\t\t\t\ttype = OType.LINKSET;\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\ttype = OType.LINKLIST;\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\tlinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlinkedType = OType.getTypeByAssignability(firstValue.getClass());\r\n\r\n\t\t\t\t\t\t\tif (linkedType != OType.LINK) {\r\n\t\t\t\t\t\t\t\t// EMBEDDED FOR SURE SINCE IT CONTAINS JAVA TYPES\r\n\t\t\t\t\t\t\t\tif (linkedType == null) {\r\n\t\t\t\t\t\t\t\t\tlinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t\t\t\t// linkedClass = new OClass(firstValue.getClass());\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\t\t\t\tif (coll instanceof Set<?>)\r\n\t\t\t\t\t\t\t\t\t\ttype = OType.EMBEDDEDSET;\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\ttype = OType.EMBEDDEDLIST;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (type == null)\r\n\t\t\t\t\t\ttype = OType.EMBEDDEDLIST;\r\n\r\n\t\t\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\ttype = OType.EMBEDDEDMAP;\r\n\r\n\t\t\t\t\tMap<?, ?> map = (Map<?, ?>) fieldValue;\r\n\t\t\t\t\tif (map.size() > 0) {\r\n\t\t\t\t\t\tObject firstValue = map.values().iterator().next();\r\n\r\n\t\t\t\t\t\tif (database != null\r\n\t\t\t\t\t\t\t\t&& (firstValue instanceof ORecordSchemaAware<?> || (database.getDatabaseOwner() instanceof ODatabaseObject && ((ODatabaseObject) database\r\n\t\t\t\t\t\t\t\t\t\t.getDatabaseOwner()).getEntityManager().getEntityClass(getClassName(firstValue)) != null))) {\r\n\t\t\t\t\t\t\t// LINK: GET THE CLASS\r\n\t\t\t\t\t\t\tlinkedType = OType.LINK;\r\n\t\t\t\t\t\t\tlinkedClass = getLinkInfo(database, getClassName(firstValue));\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tlinkedType = OType.getTypeByClass(firstValue.getClass());\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (database != null && fieldValue instanceof ORecordSchemaAware<?>) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\t// DETERMINE THE FIELD TYPE\r\n\t\t\t\t\t\ttype = OType.LINK;\r\n\r\n\t\t\t\t\tlinkedClass = getLinkInfo(database, fieldClassName);\r\n\t\t\t\t} else if (fieldValue instanceof ORID) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\t// DETERMINE THE FIELD TYPE\r\n\t\t\t\t\t\ttype = OType.LINK;\r\n\r\n\t\t\t\t} else if (database != null && database.getDatabaseOwner() instanceof ODatabaseObject\r\n\t\t\t\t\t\t&& ((ODatabaseObject) database.getDatabaseOwner()).getEntityManager().getEntityClass(fieldClassName) != null) {\r\n\t\t\t\t\t// DETERMINE THE FIELD TYPE\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\ttype = OType.LINK;\r\n\t\t\t\t\tlinkedClass = getLinkInfo(database, fieldClassName);\r\n\t\t\t\t} else if (fieldValue instanceof Date) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\ttype = OType.DATE;\r\n\t\t\t\t} else if (fieldValue instanceof String)\r\n\t\t\t\t\ttype = OType.STRING;\r\n\t\t\t}\r\n\r\n\t\t\tif (type == null)\r\n\t\t\t\ttype = OType.EMBEDDED;\r\n\r\n\t\t\tfieldValue = fieldToStream((ODocument) iRecord, iRecord.getDatabase(), iObjHandler, type, linkedClass, linkedType,\r\n\t\t\t\t\tf.getKey(), f.getValue(), iMarshalledRecords);\r\n\r\n\t\t\tbuffer.append(f.getKey());\r\n\t\t\tbuffer.append(FIELD_VALUE_SEPARATOR);\r\n\t\t\tif (fieldValue != null)\r\n\t\t\t\tbuffer.append(fieldValue);\r\n\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\tiMarshalledRecords.remove(identityRecord);\r\n\r\n\t\treturn buffer.toString();\r\n\t}","id":71396,"modified_method":"@Override\r\n\tprotected String toString(ORecordInternal<?> iRecord, final String iFormat, final OUserObject2RecordHandler iObjHandler,\r\n\t\t\tfinal Set<Integer> iMarshalledRecords) {\r\n\t\tif (!(iRecord instanceof ODocument))\r\n\t\t\tthrow new OSerializationException(\"Can't marshall a record of type \" + iRecord.getClass().getSimpleName() + \" to CSV\");\r\n\r\n\t\tfinal ODocument record = (ODocument) iRecord;\r\n\r\n\t\t// CHECK IF THE RECORD IS PENDING TO BE MARSHALLED\r\n\t\tfinal Integer identityRecord = System.identityHashCode(record);\r\n\t\tif (iMarshalledRecords.contains(identityRecord)) {\r\n\t\t\treturn \"\";\r\n\t\t} else\r\n\t\t\tiMarshalledRecords.add(identityRecord);\r\n\r\n\t\tODatabaseRecord<?> database = record.getDatabase();\r\n\r\n\t\tfinal StringBuilder buffer = new StringBuilder();\r\n\r\n\t\tif (record.getClassName() != null) {\r\n\t\t\t// MARSHALL THE CLASSNAME\r\n\t\t\tbuffer.append(record.getClassName());\r\n\t\t\tbuffer.append(OStringSerializerHelper.CLASS_SEPARATOR);\r\n\t\t}\r\n\r\n\t\tOProperty prop;\r\n\t\tObject fieldValue;\r\n\t\tOType type;\r\n\t\tOClass linkedClass;\r\n\t\tOType linkedType;\r\n\t\tString fieldClassName;\r\n\t\tint i = 0;\r\n\r\n\t\t// MARSHALL ALL THE CONFIGURED FIELDS\r\n\t\tfor (Entry<String, Object> f : record) {\r\n\t\t\tif (i > 0)\r\n\t\t\t\tbuffer.append(OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n\t\t\t// SEARCH FOR A CONFIGURED PROPERTY\r\n\t\t\tprop = record.getSchemaClass() != null ? record.getSchemaClass().getProperty(f.getKey()) : null;\r\n\t\t\tfieldValue = f.getValue();\r\n\t\t\tfieldClassName = getClassName(fieldValue);\r\n\r\n\t\t\ttype = record.fieldType(f.getKey());\r\n\t\t\tlinkedClass = null;\r\n\t\t\tlinkedType = null;\r\n\r\n\t\t\tif (prop != null) {\r\n\t\t\t\t// RECOGNIZED PROPERTY\r\n\t\t\t\ttype = prop.getType();\r\n\t\t\t\tlinkedClass = prop.getLinkedClass();\r\n\t\t\t\tlinkedType = prop.getLinkedType();\r\n\r\n\t\t\t} else if (fieldValue != null) {\r\n\r\n\t\t\t\t// NOT FOUND: TRY TO DETERMINE THE TYPE FROM ITS CONTENT\r\n\t\t\t\tif (fieldValue instanceof Collection<?> || fieldValue.getClass().isArray()) {\r\n\t\t\t\t\tfinal Collection<?> coll = fieldValue instanceof Collection<?> ? (Collection<?>) fieldValue : null;\r\n\r\n\t\t\t\t\tint size = coll != null ? coll.size() : Array.getLength(fieldValue);\r\n\r\n\t\t\t\t\tif (size > 0) {\r\n\t\t\t\t\t\tObject firstValue = coll != null ? coll.iterator().next() : Array.get(fieldValue, 0);\r\n\r\n\t\t\t\t\t\tif (database != null\r\n\t\t\t\t\t\t\t\t&& (firstValue instanceof ORID || firstValue instanceof ORecordSchemaAware<?> || (database.getDatabaseOwner() instanceof ODatabaseObject && ((ODatabaseObject) database\r\n\t\t\t\t\t\t\t\t\t\t.getDatabaseOwner()).getEntityManager().getEntityClass(getClassName(firstValue)) != null))) {\r\n\t\t\t\t\t\t\tlinkedClass = getLinkInfo(database, getClassName(firstValue));\r\n\t\t\t\t\t\t\tif (type == null) {\r\n\t\t\t\t\t\t\t\t// LINK: GET THE CLASS\r\n\t\t\t\t\t\t\t\tlinkedType = OType.LINK;\r\n\r\n\t\t\t\t\t\t\t\tif (coll instanceof Set<?>)\r\n\t\t\t\t\t\t\t\t\ttype = OType.LINKSET;\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\ttype = OType.LINKLIST;\r\n\t\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\t\tlinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlinkedType = OType.getTypeByAssignability(firstValue.getClass());\r\n\r\n\t\t\t\t\t\t\tif (linkedType != OType.LINK) {\r\n\t\t\t\t\t\t\t\t// EMBEDDED FOR SURE SINCE IT CONTAINS JAVA TYPES\r\n\t\t\t\t\t\t\t\tif (linkedType == null) {\r\n\t\t\t\t\t\t\t\t\tlinkedType = OType.EMBEDDED;\r\n\t\t\t\t\t\t\t\t\t// linkedClass = new OClass(firstValue.getClass());\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\t\t\t\tif (coll instanceof Set<?>)\r\n\t\t\t\t\t\t\t\t\t\ttype = OType.EMBEDDEDSET;\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\ttype = OType.EMBEDDEDLIST;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (type == null)\r\n\t\t\t\t\t\ttype = OType.EMBEDDEDLIST;\r\n\r\n\t\t\t\t} else if (fieldValue instanceof Map<?, ?>) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\ttype = OType.EMBEDDEDMAP;\r\n\r\n\t\t\t\t\tMap<?, ?> map = (Map<?, ?>) fieldValue;\r\n\t\t\t\t\tif (map.size() > 0) {\r\n\t\t\t\t\t\tObject firstValue = map.values().iterator().next();\r\n\r\n\t\t\t\t\t\tif (database != null\r\n\t\t\t\t\t\t\t\t&& (firstValue instanceof ORecordSchemaAware<?> || (database.getDatabaseOwner() instanceof ODatabaseObject && ((ODatabaseObject) database\r\n\t\t\t\t\t\t\t\t\t\t.getDatabaseOwner()).getEntityManager().getEntityClass(getClassName(firstValue)) != null))) {\r\n\t\t\t\t\t\t\t// LINK: GET THE CLASS\r\n\t\t\t\t\t\t\tlinkedType = OType.LINK;\r\n\t\t\t\t\t\t\tlinkedClass = getLinkInfo(database, getClassName(firstValue));\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tlinkedType = OType.getTypeByClass(firstValue.getClass());\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (database != null && fieldValue instanceof ODocument) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\t// DETERMINE THE FIELD TYPE\r\n\t\t\t\t\t\tif (((ODocument) fieldValue).getOwner() == null)\r\n\t\t\t\t\t\t\ttype = OType.LINK;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\ttype = OType.EMBEDDED;\r\n\r\n\t\t\t\t\tlinkedClass = getLinkInfo(database, fieldClassName);\r\n\t\t\t\t} else if (fieldValue instanceof ORID) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\t// DETERMINE THE FIELD TYPE\r\n\t\t\t\t\t\ttype = OType.LINK;\r\n\r\n\t\t\t\t} else if (database != null && database.getDatabaseOwner() instanceof ODatabaseObject\r\n\t\t\t\t\t\t&& ((ODatabaseObject) database.getDatabaseOwner()).getEntityManager().getEntityClass(fieldClassName) != null) {\r\n\t\t\t\t\t// DETERMINE THE FIELD TYPE\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\ttype = OType.LINK;\r\n\t\t\t\t\tlinkedClass = getLinkInfo(database, fieldClassName);\r\n\t\t\t\t} else if (fieldValue instanceof Date) {\r\n\t\t\t\t\tif (type == null)\r\n\t\t\t\t\t\ttype = OType.DATE;\r\n\t\t\t\t} else if (fieldValue instanceof String)\r\n\t\t\t\t\ttype = OType.STRING;\r\n\t\t\t}\r\n\r\n\t\t\tif (type == null)\r\n\t\t\t\ttype = OType.EMBEDDED;\r\n\r\n\t\t\tfieldValue = fieldToStream((ODocument) iRecord, iRecord.getDatabase(), iObjHandler, type, linkedClass, linkedType,\r\n\t\t\t\t\tf.getKey(), f.getValue(), iMarshalledRecords);\r\n\r\n\t\t\tbuffer.append(f.getKey());\r\n\t\t\tbuffer.append(FIELD_VALUE_SEPARATOR);\r\n\t\t\tif (fieldValue != null)\r\n\t\t\t\tbuffer.append(fieldValue);\r\n\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\tiMarshalledRecords.remove(identityRecord);\r\n\r\n\t\treturn buffer.toString();\r\n\t}","commit_id":"4664517df5d8104777d53352f1f525f88ecec5f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public EquivalenceDescriptor buildDescriptor(@NotNull PsiElement element) {\n    final EquivalenceDescriptorBuilder builder = new EquivalenceDescriptorBuilder();\n\n    if (element instanceof JSClass) {\n      final JSClass c = (JSClass)element;\n      return builder\n        .element(c.getNameIdentifier())\n        .childrenOptionally(c.getAttributeList())\n        .childrenInAnyOrder(c.getExtendsList())\n        .childrenInAnyOrder(c.getImplementsList())\n        .inAnyOrder(c.getFields())\n        .inAnyOrder(c.getFunctions());\n    }\n    else if (element instanceof JSVariable) {\n      final JSVariable v = (JSVariable)element;\n      return builder\n        .element(v.getNameIdentifier())\n        .optionally(v.getTypeElement())\n        .optionallyInPattern(v.getInitializer())\n        .role(v.getNameIdentifier(), ChildRole.VARIABLE_NAME);\n    }\n    else if (element instanceof JSFunction) {\n      final JSFunction f = (JSFunction)element;\n      return builder\n        .constant(f.getKind())\n        .element(f.getNameIdentifier())\n        .childrenOptionally(f.getAttributeList())\n        .children(f.getParameterList())\n        .optionally(f.getReturnTypeElement())\n        .optionallyInPattern(f.getBody())\n        .role(f.getNameIdentifier(), ChildRole.FUNCTION_NAME);\n    }\n    else if (element instanceof JSBlockStatement) {\n      return builder.codeBlock(((JSBlockStatement)element).getStatements());\n    }\n    else if (element instanceof JSParenthesizedExpression) {\n      return builder.element(((JSParenthesizedExpression)element).getInnerExpression());\n    }\n\n    return null;\n  }","id":71397,"modified_method":"@Override\n  public EquivalenceDescriptor buildDescriptor(@NotNull PsiElement element) {\n    final EquivalenceDescriptorBuilder builder = new EquivalenceDescriptorBuilder();\n\n    if (element instanceof JSClass) {\n      final JSClass c = (JSClass)element;\n\n      // todo: make simplier api\n      final JSReferenceList extendsList = c.getExtendsList();\n      final JSReferenceList implementsList = c.getImplementsList();\n\n      return builder\n        .element(c.getNameIdentifier())\n        .childrenOptionally(c.getAttributeList())\n        .inAnyOrder(extendsList != null ? extendsList.getExpressions() : PsiElement.EMPTY_ARRAY)\n        .inAnyOrder(implementsList != null ? implementsList.getExpressions() : PsiElement.EMPTY_ARRAY)\n        .inAnyOrder(c.getFields())\n        .inAnyOrder(c.getFunctions());\n    }\n    else if (element instanceof JSVariable) {\n      final JSVariable v = (JSVariable)element;\n      return builder\n        .element(v.getNameIdentifier())\n        .optionally(v.getTypeElement())\n        .optionallyInPattern(v.getInitializer())\n        .role(v.getNameIdentifier(), ChildRole.VARIABLE_NAME);\n    }\n    else if (element instanceof JSFunction) {\n      final JSFunction f = (JSFunction)element;\n      return builder\n        .constant(f.getKind())\n        .element(f.getNameIdentifier())\n        .childrenOptionally(f.getAttributeList())\n        .children(f.getParameterList())\n        .optionally(f.getReturnTypeElement())\n        .optionallyInPattern(f.getBody())\n        .role(f.getNameIdentifier(), ChildRole.FUNCTION_NAME);\n    }\n    else if (element instanceof JSBlockStatement) {\n      return builder.codeBlock(((JSBlockStatement)element).getStatements());\n    }\n    else if (element instanceof JSParenthesizedExpression) {\n      return builder.element(((JSParenthesizedExpression)element).getInnerExpression());\n    }\n\n    return null;\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public int getNodeHash(PsiElement node) {\n    if (node == null) {\n      return 0;\n    }\n    if (node instanceof PsiWhiteSpace || node instanceof PsiErrorElement) {\n      return 0;\n    }\n    else if (node instanceof LeafElement) {\n      if (!mySettings.DISTINGUISH_LITERALS) {\n        final EquivalenceDescriptorProvider descriptorProvider = EquivalenceDescriptorProvider.getInstance(node);\n        if (descriptorProvider != null) {\n          final IElementType elementType = ((LeafElement)node).getElementType();\n          if (descriptorProvider.getLiterals().contains(elementType)) {\n            return 0;\n          }\n        }\n      }\n      return node.getText().hashCode();\n    }\n    return node.getClass().getName().hashCode();\n  }","id":71398,"modified_method":"@Override\n  public int getNodeHash(PsiElement node) {\n    if (node == null) {\n      return 0;\n    }\n    if (node instanceof PsiWhiteSpace || node instanceof PsiErrorElement) {\n      return 0;\n    }\n    else if (node instanceof LeafElement) {\n      if (!mySettings.DISTINGUISH_LITERALS && isLiteral(node)) {\n        return 0;\n      }\n      return node.getText().hashCode();\n\n    }\n    return node.getClass().getName().hashCode();\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private TreeHashResult computeHash(MultiChildDescriptor childDescriptor,\n                                     PsiFragment parentFragment,\n                                     NodeSpecificHasher nodeSpecificHasher) {\n    final PsiElement[] elements = childDescriptor.getElements();\n\n    if (elements == null) {\n      return new TreeHashResult(0, 0, parentFragment);\n    }\n\n    switch (childDescriptor.getType()) {\n\n      case OPTIONALLY_IN_PATTERN:\n      case DEFAULT:\n        TreeHashResult[] childResults = computeHashes(elements, parentFragment, nodeSpecificHasher);\n        int[] hashes = getHashes(childResults);\n        int[] costs = getCosts(childResults);\n\n        int hash = AbstractTreeHasher.vector(hashes, 31);\n        int cost = AbstractTreeHasher.vector(costs);\n\n        return new TreeHashResult(hash, cost, parentFragment);\n\n      case IN_ANY_ORDER:\n        childResults = computeHashes(elements, parentFragment, nodeSpecificHasher);\n        hashes = getHashes(childResults);\n        costs = getCosts(childResults);\n\n        hash = AbstractTreeHasher.vector(hashes);\n        cost = AbstractTreeHasher.vector(costs);\n\n        return new TreeHashResult(hash, cost, parentFragment);\n\n      default:\n        return new TreeHashResult(0, 0, parentFragment);\n    }\n  }","id":71399,"modified_method":"@NotNull\n  private Pair<Integer, Integer> computeHash(MultiChildDescriptor childDescriptor,\n                                     PsiFragment parentFragment,\n                                     NodeSpecificHasher nodeSpecificHasher) {\n    final PsiElement[] elements = childDescriptor.getElements();\n\n    if (elements == null) {\n      return new Pair<Integer, Integer>(0, 0);\n    }\n\n    switch (childDescriptor.getType()) {\n\n      case OPTIONALLY_IN_PATTERN:\n      case DEFAULT:\n        TreeHashResult[] childResults = computeHashes(elements, parentFragment, nodeSpecificHasher);\n        int[] hashes = getHashes(childResults);\n        int[] costs = getCosts(childResults);\n\n        int hash = AbstractTreeHasher.vector(hashes, 31);\n        int cost = AbstractTreeHasher.vector(costs);\n\n        return new Pair<Integer, Integer>(hash, cost);\n\n      case IN_ANY_ORDER:\n        childResults = computeHashes(elements, parentFragment, nodeSpecificHasher);\n        hashes = getHashes(childResults);\n        costs = getCosts(childResults);\n\n        hash = AbstractTreeHasher.vector(hashes);\n        cost = AbstractTreeHasher.vector(costs);\n\n        return new Pair<Integer, Integer>(hash, cost);\n\n      default:\n        return new Pair<Integer, Integer>(0, 0);\n    }\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected TreeHashResult hash(@NotNull PsiElement root, PsiFragment upper, @NotNull NodeSpecificHasher hasher) {\n    final PsiElement element = SkippingHandler.getOnlyChild(root, SSRNodeSpecificHasher.getNodeFilter());\n    if (element != root) {\n      final TreeHashResult result = hash(element, upper, hasher);\n      final int cost = hasher.getNodeCost(root);\n      return new TreeHashResult(result.getHash(), result.getCost() + cost, upper);\n    }\n\n    final EquivalenceDescriptorProvider descriptorProvider = EquivalenceDescriptorProvider.getInstance(root);\n\n    if (descriptorProvider != null) {\n      final EquivalenceDescriptor descriptor = descriptorProvider.buildDescriptor(root);\n\n      if (descriptor != null) {\n        return computeHash(root, upper, descriptor, hasher);\n      }\n    }\n\n    if (root instanceof PsiFile) {\n      return hashCodeBlock(hasher.getNodeChildren(root), upper, hasher, true);\n    }\n\n    return computeElementHash(element, upper, hasher);\n  }","id":71400,"modified_method":"@Override\n  protected TreeHashResult hash(@NotNull PsiElement root, PsiFragment upper, @NotNull NodeSpecificHasher hasher) {\n    final EquivalenceDescriptorProvider descriptorProvider = EquivalenceDescriptorProvider.getInstance(root);\n\n    if (descriptorProvider != null) {\n      final EquivalenceDescriptor descriptor = descriptorProvider.buildDescriptor(root);\n\n      if (descriptor != null) {\n        return computeHash(root, upper, descriptor, hasher);\n      }\n    }\n\n    if (root instanceof PsiFile) {\n      return hashCodeBlock(hasher.getNodeChildren(root), upper, hasher, true);\n    }\n\n    final PsiElement element = SkippingHandler.getOnlyChild(root, SSRNodeSpecificHasher.getNodeFilter());\n    if (element != root) {\n      final TreeHashResult result = hash(element, upper, hasher);\n      final int cost = hasher.getNodeCost(root);\n      return new TreeHashResult(result.getHash(), result.getCost() + cost, result.getFragment());\n    }\n\n    return computeElementHash(element, upper, hasher);\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private TreeHashResult computeHash(SingleChildDescriptor childDescriptor,\n                                     PsiFragment parentFragment,\n                                     NodeSpecificHasher nodeSpecificHasher) {\n\n    final PsiElement element = childDescriptor.getElement();\n    if (element == null) {\n      return new TreeHashResult(0, 0, parentFragment);\n    }\n    final TreeHashResult result = doComputeHash(childDescriptor, parentFragment, nodeSpecificHasher);\n\n    if (result != null) {\n      final ChildRole role = childDescriptor.getRole();\n      if (role != null) {\n        switch (role) {\n          case VARIABLE_NAME:\n            if (!mySettings.DISTINGUISH_VARIABLES) {\n              return new TreeHashResult(0, result.getCost(), result.getFragment());\n            }\n            break;\n          case FIELD_NAME:\n            if (!mySettings.DISTINGUISH_FIELDS) {\n              return new TreeHashResult(0, result.getCost(), result.getFragment());\n            }\n            break;\n          case FUNCTION_NAME:\n            if (!mySettings.DISTINGUISH_METHODS) {\n              return new TreeHashResult(0, result.getCost(), result.getFragment());\n            }\n            break;\n        }\n      }\n    }\n    return result;\n  }","id":71401,"modified_method":"@NotNull\n  private Pair<Integer, Integer> computeHash(SingleChildDescriptor childDescriptor,\n                                             PsiFragment parentFragment,\n                                             NodeSpecificHasher nodeSpecificHasher) {\n\n    final PsiElement element = childDescriptor.getElement();\n    if (element == null) {\n      return new Pair<Integer, Integer>(0, 0);\n    }\n    final Pair<Integer, Integer> result = doComputeHash(childDescriptor, parentFragment, nodeSpecificHasher);\n\n    if (result != null) {\n      final ChildRole role = childDescriptor.getRole();\n      if (role != null) {\n        switch (role) {\n          case VARIABLE_NAME:\n            if (!mySettings.DISTINGUISH_VARIABLES) {\n              return new Pair<Integer, Integer>(0, result.second);\n            }\n            break;\n          case FIELD_NAME:\n            if (!mySettings.DISTINGUISH_FIELDS) {\n              return new Pair<Integer, Integer>(0, result.second);\n            }\n            break;\n          case FUNCTION_NAME:\n            if (!mySettings.DISTINGUISH_METHODS) {\n              return new Pair<Integer, Integer>(0, result.second);\n            }\n            break;\n        }\n      }\n    }\n    return result;\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TreeHashResult computeHash(PsiElement element,\n                                     PsiFragment parent,\n                                     EquivalenceDescriptor descriptor,\n                                     NodeSpecificHasher nodeSpecificHasher) {\n\n    final PsiElement element2 = SkippingHandler.skipNodeIfNeccessary(element, descriptor, SSRNodeSpecificHasher.getNodeFilter());\n    final boolean canSkip = element2 != element;\n\n    final PsiFragment fragment = new TreePsiFragment(nodeSpecificHasher, element, 0);\n\n    if (parent != null) {\n      fragment.setParent(parent);\n    }\n\n    int hash = canSkip ? 0 : nodeSpecificHasher.getNodeHash(element);\n    int cost = nodeSpecificHasher.getNodeCost(element);\n\n    for (SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) {\n      final TreeHashResult childHashResult = computeHash(childDescriptor, fragment, nodeSpecificHasher);\n      hash = hash * 31 + childHashResult.getHash();\n      cost += childHashResult.getCost();\n    }\n\n    for (MultiChildDescriptor childDescriptor : descriptor.getMultiChildDescriptors()) {\n      final TreeHashResult childHashResult = computeHash(childDescriptor, fragment, nodeSpecificHasher);\n      hash = hash * 31 + childHashResult.getHash();\n      cost += childHashResult.getCost();\n    }\n\n    for (Object constant : descriptor.getConstants()) {\n      final int constantHash = constant != null ? constant.hashCode() : 0;\n      hash = hash * 31 + constantHash;\n    }\n\n    for (PsiElement[] codeBlock : descriptor.getCodeBlocks()) {\n      final TreeHashResult childHashResult = hashCodeBlock(Arrays.asList(codeBlock), fragment, nodeSpecificHasher);\n      hash = hash * 31 + childHashResult.getHash();\n      cost += childHashResult.getCost();\n    }\n\n    if (myCallback != null) {\n      myCallback.add(hash, cost, fragment);\n    }\n    return new TreeHashResult(hash, cost, fragment);\n  }","id":71402,"modified_method":"private TreeHashResult computeHash(PsiElement element,\n                                     PsiFragment parent,\n                                     EquivalenceDescriptor descriptor,\n                                     NodeSpecificHasher nodeSpecificHasher) {\n\n    final PsiElement element2 = SkippingHandler.skipNodeIfNeccessary(element, descriptor, SSRNodeSpecificHasher.getNodeFilter());\n    final boolean canSkip = element2 != element;\n\n    final PsiFragment fragment = new TreePsiFragment(nodeSpecificHasher, element, 0);\n\n    if (parent != null) {\n      fragment.setParent(parent);\n    }\n\n    int hash = canSkip ? 0 : nodeSpecificHasher.getNodeHash(element);\n    int cost = nodeSpecificHasher.getNodeCost(element);\n\n    for (SingleChildDescriptor childDescriptor : descriptor.getSingleChildDescriptors()) {\n      final Pair<Integer, Integer> childHashResult = computeHash(childDescriptor, fragment, nodeSpecificHasher);\n      hash = hash * 31 + childHashResult.first;\n      cost += childHashResult.second;\n    }\n\n    for (MultiChildDescriptor childDescriptor : descriptor.getMultiChildDescriptors()) {\n      final Pair<Integer, Integer> childHashResult = computeHash(childDescriptor, fragment, nodeSpecificHasher);\n      hash = hash * 31 + childHashResult.first;\n      cost += childHashResult.second;\n    }\n\n    for (Object constant : descriptor.getConstants()) {\n      final int constantHash = constant != null ? constant.hashCode() : 0;\n      hash = hash * 31 + constantHash;\n    }\n\n    for (PsiElement[] codeBlock : descriptor.getCodeBlocks()) {\n      final TreeHashResult childHashResult = hashCodeBlock(Arrays.asList(codeBlock), fragment, nodeSpecificHasher);\n      hash = hash * 31 + childHashResult.getHash();\n      cost += childHashResult.getCost();\n    }\n\n    if (myCallback != null) {\n      myCallback.add(hash, cost, fragment);\n    }\n    return new TreeHashResult(hash, cost, fragment);\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TreeHashResult doComputeHash(SingleChildDescriptor childDescriptor,\n                                       PsiFragment parentFragment,\n                                       NodeSpecificHasher nodeSpecificHasher) {\n    final PsiElement element = childDescriptor.getElement();\n\n    switch (childDescriptor.getType()) {\n      case OPTIONALLY_IN_PATTERN:\n      case DEFAULT:\n        return hash(element, parentFragment, nodeSpecificHasher);\n\n      case CHILDREN_OPTIONALLY_IN_PATTERN:\n      case CHILDREN:\n        TreeHashResult[] childResults = computeHashesForChildren(element, parentFragment, nodeSpecificHasher);\n        int[] hashes = getHashes(childResults);\n        int[] costs = getCosts(childResults);\n\n        int hash = AbstractTreeHasher.vector(hashes, 31);\n        int cost = AbstractTreeHasher.vector(costs);\n\n        return new TreeHashResult(hash, cost, parentFragment);\n\n      case CHILDREN_IN_ANY_ORDER:\n        childResults = computeHashesForChildren(element, parentFragment, nodeSpecificHasher);\n        hashes = getHashes(childResults);\n        costs = getCosts(childResults);\n\n        hash = AbstractTreeHasher.vector(hashes);\n        cost = AbstractTreeHasher.vector(costs);\n\n        return new TreeHashResult(hash, cost, parentFragment);\n\n      default:\n        return new TreeHashResult(0, 0, parentFragment);\n    }\n  }","id":71403,"modified_method":"@NotNull\n  private Pair<Integer, Integer> doComputeHash(SingleChildDescriptor childDescriptor,\n                                               PsiFragment parentFragment,\n                                               NodeSpecificHasher nodeSpecificHasher) {\n    final PsiElement element = childDescriptor.getElement();\n\n    switch (childDescriptor.getType()) {\n      case OPTIONALLY_IN_PATTERN:\n      case DEFAULT:\n        final TreeHashResult result = hash(element, parentFragment, nodeSpecificHasher);\n        return new Pair<Integer, Integer>(result.getHash(), result.getCost());\n\n      case CHILDREN_OPTIONALLY_IN_PATTERN:\n      case CHILDREN:\n        TreeHashResult[] childResults = computeHashesForChildren(element, parentFragment, nodeSpecificHasher);\n        int[] hashes = getHashes(childResults);\n        int[] costs = getCosts(childResults);\n\n        int hash = AbstractTreeHasher.vector(hashes, 31);\n        int cost = AbstractTreeHasher.vector(costs);\n\n        return new Pair<Integer, Integer>(hash, cost);\n\n      case CHILDREN_IN_ANY_ORDER:\n        childResults = computeHashesForChildren(element, parentFragment, nodeSpecificHasher);\n        hashes = getHashes(childResults);\n        costs = getCosts(childResults);\n\n        hash = AbstractTreeHasher.vector(hashes);\n        cost = AbstractTreeHasher.vector(costs);\n\n        return new Pair<Integer, Integer>(hash, cost);\n\n      default:\n        return new Pair<Integer, Integer>(0, 0);\n    }\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiElement skipNodeIfNeccessary(PsiElement element, EquivalenceDescriptor descriptor, NodeFilter filter) {\n    if (element == null) {\n      return null;\n    }\n\n    /*if (!canSkip(element) && getOnlyNonWhitespaceChild(element) == null) {\n      return element;\n    }*/\n\n    // todo optimize! (this method is often invokated for the same node)\n\n    final PsiElement onlyChild = getOnlyChildFromDescriptor(element, descriptor);\n    if (onlyChild != null) {\n      return onlyChild;\n    }\n\n    return getOnlyChild(element, null);\n  }","id":71404,"modified_method":"@Nullable\n  public static PsiElement skipNodeIfNeccessary(PsiElement element, EquivalenceDescriptor descriptor, NodeFilter filter) {\n    if (element == null) {\n      return null;\n    }\n\n    /*if (!canSkip(element) && getOnlyNonWhitespaceChild(element) == null) {\n      return element;\n    }*/\n\n    // todo optimize! (this method is often invokated for the same node)\n\n    if (descriptor == null) {\n      final EquivalenceDescriptorProvider provider = EquivalenceDescriptorProvider.getInstance(element);\n      if (provider != null) {\n        descriptor = provider.buildDescriptor(element);\n      }\n    }\n    else {\n      final PsiElement child = getOnlyChildFromDescriptor(descriptor, filter);\n      return child != null ? child : element;\n    }\n\n    if (descriptor != null) {\n      final PsiElement onlyChild = getOnlyChildFromDescriptor(descriptor, filter);\n      if (onlyChild != null) {\n        return onlyChild;\n      }\n    }\n\n    return getOnlyChild(element, filter);\n  }","commit_id":"b2a5287ddcc01f0af6fee855b8ffe5f52356fe62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MakeClassInterfaceFix(PsiClass aClass) {\n    myClass = aClass;\n  }","id":71405,"modified_method":"public MakeClassInterfaceFix(PsiClass aClass, final boolean makeInterface) {\n    myClass = aClass;\n    myMakeInterface = makeInterface;\n  }","commit_id":"4f7f01bd9b649a3619cbf616304e6501feb37662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) {\n    if (!CodeInsightUtil.preparePsiElementForWrite(myClass)) return;\n\n    try {\n      PsiJavaCodeReferenceElement[] referenceElements = myClass.getExtendsList().getReferenceElements();\n      for (PsiJavaCodeReferenceElement referenceElement : referenceElements) {\n        referenceElement.delete();\n      }\n      convertToInterface(myClass);\n      UndoManager.getInstance(file.getProject()).markDocumentForUndo(file);\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":71406,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) {\n    if (!CodeInsightUtil.preparePsiElementForWrite(myClass)) return;\n    try {\n      final PsiReferenceList extendsList = myMakeInterface? myClass.getExtendsList() : myClass.getImplementsList();\n      final PsiReferenceList implementsList = myMakeInterface? myClass.getImplementsList() : myClass.getExtendsList();\n      if (extendsList != null) {\n        for (PsiJavaCodeReferenceElement referenceElement : extendsList.getReferenceElements()) {\n          referenceElement.delete();\n        }\n        if (implementsList != null) {\n          for (PsiJavaCodeReferenceElement referenceElement : implementsList.getReferenceElements()) {\n            extendsList.addAfter(referenceElement, null);\n            referenceElement.delete();\n          }\n        }\n      }\n      convertPsiClass(myClass, myMakeInterface);\n      UndoManager.getInstance(file.getProject()).markDocumentForUndo(file);\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"4f7f01bd9b649a3619cbf616304e6501feb37662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getText() {\n    return QuickFixBundle.message(\"make.class.an.interface.text\", myClass.getName());\n  }","id":71407,"modified_method":"public String getText() {\n    return QuickFixBundle.message(myMakeInterface? \"make.class.an.interface.text\":\"make.interface.an.class.text\", myClass.getName());\n  }","commit_id":"4f7f01bd9b649a3619cbf616304e6501feb37662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IntentionAction createMakeClassInterfaceFix(@NotNull PsiClass aClass) {\n    return new MakeClassInterfaceFix(aClass);\n  }","id":71408,"modified_method":"public IntentionAction createMakeClassInterfaceFix(@NotNull PsiClass aClass) {\n    return new MakeClassInterfaceFix(aClass, true);\n  }","commit_id":"4f7f01bd9b649a3619cbf616304e6501feb37662","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement generateTest(final Project project, final CreateTestDialog d) {\n    return PostprocessReformattingAspect.getInstance(project).postponeFormattingInside(new Computable<PsiElement>() {\n      public PsiElement compute() {\n        return ApplicationManager.getApplication().runWriteAction(new Computable<PsiElement>() {\n          public PsiElement compute() {\n            try {\n              IdeDocumentHistory.getInstance(project).includeCurrentPlaceAsChangePlace();\n\n              PsiClass targetClass = JavaDirectoryService.getInstance().createClass(d.getTargetDirectory(), d.getClassName());\n              addSuperClass(targetClass, project, d.getSuperClassName());\n\n              Editor editor = CodeInsightUtil.positionCursor(project, targetClass.getContainingFile(), targetClass.getLBrace());\n              addTestMethods(editor,\n                             targetClass,\n                             d.getSelectedTestFrameworkDescriptor(),\n                             d.getSelectedMethods(),\n                             d.shouldGeneratedBefore(),\n                             d.shouldGeneratedAfter());\n              return targetClass;\n            }\n            catch (IncorrectOperationException e) {\n              showErrorLater(project, d.getClassName());\n              return null;\n            }\n          }\n        });\n      }\n    });\n  }","id":71409,"modified_method":"public PsiElement generateTest(final Project project, final CreateTestDialog d) {\n    return PostprocessReformattingAspect.getInstance(project).postponeFormattingInside(new Computable<PsiElement>() {\n      public PsiElement compute() {\n        return ApplicationManager.getApplication().runWriteAction(new Computable<PsiElement>() {\n          public PsiElement compute() {\n            try {\n              IdeDocumentHistory.getInstance(project).includeCurrentPlaceAsChangePlace();\n\n              PsiClass targetClass = createTestClass(d);\n              addSuperClass(targetClass, project, d.getSuperClassName());\n\n              Editor editor = CodeInsightUtil.positionCursor(project, targetClass.getContainingFile(), targetClass.getLBrace());\n              addTestMethods(editor,\n                             targetClass,\n                             d.getSelectedTestFrameworkDescriptor(),\n                             d.getSelectedMethods(),\n                             d.shouldGeneratedBefore(),\n                             d.shouldGeneratedAfter());\n              return targetClass;\n            }\n            catch (IncorrectOperationException e) {\n              showErrorLater(project, d.getClassName());\n              return null;\n            }\n          }\n        });\n      }\n    });\n  }","commit_id":"4b3cbd35fe1c2cbe70c443b37ec83af1be6ac9e6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addSuperClass(PsiClass targetClass, Project project, String superClassName) throws IncorrectOperationException {\n    if (superClassName == null) return;\n\n    PsiElementFactory ef = JavaPsiFacade.getInstance(project).getElementFactory();\n    PsiJavaCodeReferenceElement superClassRef;\n\n    PsiClass superClass = findClass(project, superClassName);\n    if (superClass != null) {\n      superClassRef = ef.createClassReferenceElement(superClass);\n    }\n    else {\n      superClassRef = ef.createFQClassNameReferenceElement(superClassName, GlobalSearchScope.allScope(project));\n    }\n    targetClass.getExtendsList().add(superClassRef);\n  }","id":71410,"modified_method":"private static void addSuperClass(PsiClass targetClass, Project project, String superClassName) throws IncorrectOperationException {\n    if (superClassName == null) return;\n    final PsiReferenceList extendsList = targetClass.getExtendsList();\n    if (extendsList == null || extendsList.getReferencedTypes().length > 0) return;\n\n    PsiElementFactory ef = JavaPsiFacade.getInstance(project).getElementFactory();\n    PsiJavaCodeReferenceElement superClassRef;\n\n    PsiClass superClass = findClass(project, superClassName);\n    if (superClass != null) {\n      superClassRef = ef.createClassReferenceElement(superClass);\n    }\n    else {\n      superClassRef = ef.createFQClassNameReferenceElement(superClassName, GlobalSearchScope.allScope(project));\n    }\n    extendsList.add(superClassRef);\n  }","commit_id":"4b3cbd35fe1c2cbe70c443b37ec83af1be6ac9e6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void build(PsiElement current) {\n\n    if (current!=null) {\n      if (MatchUtils.compareWithNoDifferenceToPackage(current.getText(),\"Object\")) {\n        if(objectTaken) return;\n        objectTaken = true;\n      }\n\n      PsiElement element = MatchUtils.getReferencedElement(current);\n      if (!(element instanceof PsiClass)) {\n        remaining.add(element);\n        return;\n      }\n      PsiClass clazz = (PsiClass) element;\n      if (clazz!=null) {\n        remaining.add(clazz);\n        if (clazz instanceof PsiAnonymousClass) {\n          build(((PsiAnonymousClass)clazz).getBaseClassReference());\n          return;\n        }\n\n        if (acceptClasses) {\n          final PsiElement[] extendsList = clazz.getExtendsList().getReferenceElements();\n          if (extendsList!=null) {\n            for(int i=0;i<extendsList.length;++i) {\n              build(extendsList[i]);\n            }\n          } else {\n            /*\n            if (!objectTaken) {\n              remaining.add(\"Object\");\n              objectTaken = true;\n            }*/\n          }\n        }\n\n        if (acceptInterfaces) {\n          final PsiElement[] implementsList = clazz.getImplementsList().getReferenceElements();\n          if (implementsList!=null) {\n            for(int i=0;i<implementsList.length;++i) {\n              build(implementsList[i]);\n            }\n          }\n        }\n      } else {\n        remaining.add(current);\n      }\n    }\n  }","id":71411,"modified_method":"private void build(PsiElement current) {\n\n    if (current!=null) {\n      if (MatchUtils.compareWithNoDifferenceToPackage(current.getText(),\"Object\")) {\n        if(objectTaken) return;\n        objectTaken = true;\n      }\n\n      PsiElement element = MatchUtils.getReferencedElement(current);\n      if (!(element instanceof PsiClass)) {\n        remaining.add(element);\n        return;\n      }\n      PsiClass clazz = (PsiClass) element;\n      if (clazz!=null) {\n        remaining.add(clazz);\n        if (clazz instanceof PsiAnonymousClass) {\n          build(((PsiAnonymousClass)clazz).getBaseClassReference());\n          return;\n        }\n\n        if (acceptClasses) {\n          final PsiReferenceList clazzExtendsList = clazz.getExtendsList();\n          final PsiElement[] extendsList = (clazzExtendsList != null)?clazzExtendsList.getReferenceElements():null;\n          \n          if (extendsList!=null) {\n            for(int i=0;i<extendsList.length;++i) {\n              build(extendsList[i]);\n            }\n          } else {\n            /*\n            if (!objectTaken) {\n              remaining.add(\"Object\");\n              objectTaken = true;\n            }*/\n          }\n        }\n\n        if (acceptInterfaces) {\n          final PsiElement[] implementsList = clazz.getImplementsList().getReferenceElements();\n          if (implementsList!=null) {\n            for(int i=0;i<implementsList.length;++i) {\n              build(implementsList[i]);\n            }\n          }\n        }\n      } else {\n        remaining.add(current);\n      }\n    }\n  }","commit_id":"eee7e9789df7f10caa1f2817ed293fa5b30f1a63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Determine if the supplied {@link Class} meets the criteria for being\n\t * considered a <em>default configuration class<\/em> candidate.\n\t * <p>Specifically, such candidates:\n\t * <ul>\n\t * <li>must not be {@code null}<\/li>\n\t * <li>must not be {@code private}<\/li>\n\t * <li>must not be {@code final}<\/li>\n\t * <li>must be {@code static}<\/li>\n\t * <li>must be annotated with {@code @Configuration}<\/li>\n\t * <\/ul>\n\t * @param clazz the class to check\n\t * @return {@code true} if the supplied class meets the candidate criteria\n\t */\n\tprivate static boolean isDefaultConfigurationClassCandidate(Class<?> clazz) {\n\t\treturn (clazz != null && isStaticNonPrivateAndNonFinal(clazz) && clazz.isAnnotationPresent(Configuration.class));\n\t}","id":71412,"modified_method":"/**\n\t * Determine if the supplied {@link Class} meets the criteria for being\n\t * considered a <em>default configuration class<\/em> candidate.\n\t * <p>Specifically, such candidates:\n\t * <ul>\n\t * <li>must not be {@code null}<\/li>\n\t * <li>must not be {@code private}<\/li>\n\t * <li>must not be {@code final}<\/li>\n\t * <li>must be {@code static}<\/li>\n\t * <li>must be annotated or meta-annotated with {@code @Configuration}<\/li>\n\t * <\/ul>\n\t * @param clazz the class to check\n\t * @return {@code true} if the supplied class meets the candidate criteria\n\t */\n\tprivate static boolean isDefaultConfigurationClassCandidate(Class<?> clazz) {\n\t\treturn (clazz != null && isStaticNonPrivateAndNonFinal(clazz) &&\n\t\t\t\t(AnnotationUtils.findAnnotation(clazz, Configuration.class) != null));\n\t}","commit_id":"2d918380f0553238087ec264688ecba066e49ab5","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * We consider something to be an AspectJ aspect suitable for use by the Spring AOP system\n\t * if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test\n\t * is that aspects written in the code-style (AspectJ language) also have the annotation present\n\t * when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.\n\t */\n\tpublic boolean isAspect(Class<?> clazz) {\n\t\treturn (AjTypeSystem.getAjType(clazz).isAspect() && \n\t\t\t\thasAspectAnnotation(clazz) && !compiledByAjc(clazz));\n\t}","id":71413,"modified_method":"/**\n\t * We consider something to be an AspectJ aspect suitable for use by the Spring AOP system\n\t * if it has the @Aspect annotation, and was not compiled by ajc. The reason for this latter test\n\t * is that aspects written in the code-style (AspectJ language) also have the annotation present\n\t * when compiled by ajc with the -1.5 flag, yet they cannot be consumed by Spring AOP.\n\t */\n\tpublic boolean isAspect(Class<?> clazz) {\n\t\treturn (hasAspectAnnotation(clazz) && !compiledByAjc(clazz));\n\t}","commit_id":"3e63951a57c10f1de4d736531b4cdcc1c184e980","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private boolean hasAspectAnnotation(Class<?> clazz) {\n\t\treturn clazz.isAnnotationPresent(Aspect.class);\n\t}","id":71414,"modified_method":"private boolean hasAspectAnnotation(Class<?> clazz) {\n\t\treturn (AnnotationUtils.findAnnotation(clazz, Aspect.class) != null);\n\t}","commit_id":"3e63951a57c10f1de4d736531b4cdcc1c184e980","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create a new AspectMetadata instance for the given aspect class.\n\t * @param aspectClass the aspect class\n\t * @param aspectName the name of the aspect\n\t */\n\tpublic AspectMetadata(Class aspectClass, String aspectName) {\n\t\tthis.aspectName = aspectName;\n\t\tthis.ajType = AjTypeSystem.getAjType(aspectClass);\n\t\t\n\t\tif (!this.ajType.isAspect()) {\n\t\t\tthrow new IllegalArgumentException(\"Class '\" + aspectClass.getName() + \"' is not an @AspectJ aspect\");\n\t\t}\n\t\tif (this.ajType.getDeclarePrecedence().length > 0) {\n\t\t\tthrow new IllegalArgumentException(\"DeclarePrecendence not presently supported in Spring AOP\");\n\t\t}\n\n\t\tswitch (this.ajType.getPerClause().getKind()) {\n\t\t\tcase SINGLETON :\n\t\t\t\tthis.perClausePointcut = Pointcut.TRUE;\n\t\t\t\treturn;\n\t\t\tcase PERTARGET : case PERTHIS :\n\t\t\t\tAspectJExpressionPointcut ajexp = new AspectJExpressionPointcut();\n\t\t\t\tajexp.setLocation(\"@Aspect annotation on \" + aspectClass.getName());\n\t\t\t\tajexp.setExpression(findPerClause(aspectClass));\n\t\t\t\tthis.perClausePointcut = ajexp;\n\t\t\t\treturn;\n\t\t\tcase PERTYPEWITHIN :\n\t\t\t\t// Works with a type pattern\n\t\t\t\tthis.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)));\n\t\t\t\treturn;\n\t\t\tdefault :\n\t\t\t\tthrow new AopConfigException(\n\t\t\t\t\t\t\"PerClause \" + ajType.getPerClause().getKind() + \" not supported by Spring AOP for \" + aspectClass);\n\t\t}\n\t}","id":71415,"modified_method":"/**\n\t * Create a new AspectMetadata instance for the given aspect class.\n\t * @param aspectClass the aspect class\n\t * @param aspectName the name of the aspect\n\t */\n\tpublic AspectMetadata(Class<?> aspectClass, String aspectName) {\n\t\tthis.aspectName = aspectName;\n\n\t\tClass<?> currClass = aspectClass;\n\t\tAjType ajType = null;\n\t\twhile (!currClass.equals(Object.class)) {\n\t\t\tAjType ajTypeToCheck = AjTypeSystem.getAjType(currClass);\n\t\t\tif (ajTypeToCheck.isAspect()) {\n\t\t\t\tajType = ajTypeToCheck;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrClass = currClass.getSuperclass();\n\t\t}\n\t\tif (ajType == null) {\n\t\t\tthrow new IllegalArgumentException(\"Class '\" + aspectClass.getName() + \"' is not an @AspectJ aspect\");\n\t\t}\n\t\tthis.ajType = ajType;\n\t\tif (this.ajType.getDeclarePrecedence().length > 0) {\n\t\t\tthrow new IllegalArgumentException(\"DeclarePrecendence not presently supported in Spring AOP\");\n\t\t}\n\n\t\tswitch (this.ajType.getPerClause().getKind()) {\n\t\t\tcase SINGLETON :\n\t\t\t\tthis.perClausePointcut = Pointcut.TRUE;\n\t\t\t\treturn;\n\t\t\tcase PERTARGET : case PERTHIS :\n\t\t\t\tAspectJExpressionPointcut ajexp = new AspectJExpressionPointcut();\n\t\t\t\tajexp.setLocation(\"@Aspect annotation on \" + aspectClass.getName());\n\t\t\t\tajexp.setExpression(findPerClause(aspectClass));\n\t\t\t\tthis.perClausePointcut = ajexp;\n\t\t\t\treturn;\n\t\t\tcase PERTYPEWITHIN :\n\t\t\t\t// Works with a type pattern\n\t\t\t\tthis.perClausePointcut = new ComposablePointcut(new TypePatternClassFilter(findPerClause(aspectClass)));\n\t\t\t\treturn;\n\t\t\tdefault :\n\t\t\t\tthrow new AopConfigException(\n\t\t\t\t\t\t\"PerClause \" + ajType.getPerClause().getKind() + \" not supported by Spring AOP for \" + aspectClass);\n\t\t}\n\t}","commit_id":"3e63951a57c10f1de4d736531b4cdcc1c184e980","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Derive URL mappings from the handler's method-level mappings.\n\t * @param handlerType the handler type to introspect\n\t * @return the array of mapped URLs\n\t */\n\tprotected String[] determineUrlsForHandlerMethods(Class<?> handlerType) {\n\t\tfinal Set<String> urls = new LinkedHashSet<String>();\n\t\tReflectionUtils.doWithMethods(handlerType, new ReflectionUtils.MethodCallback() {\n\t\t\tpublic void doWith(Method method) {\n\t\t\t\tRequestMapping mapping = method.getAnnotation(RequestMapping.class);\n\t\t\t\tif (mapping != null) {\n\t\t\t\t\tString[] mappedPaths = mapping.value();\n\t\t\t\t\tfor (String mappedPath : mappedPaths) {\n\t\t\t\t\t\taddUrlsForPath(urls, mappedPath);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn StringUtils.toStringArray(urls);\n\t}","id":71416,"modified_method":"/**\n\t * Derive URL mappings from the handler's method-level mappings.\n\t * @param handlerType the handler type to introspect\n\t * @return the array of mapped URLs\n\t */\n\tprotected String[] determineUrlsForHandlerMethods(Class<?> handlerType) {\n\t\tfinal Set<String> urls = new LinkedHashSet<String>();\n\t\tClass<?>[] handlerTypes =\n\t\t\t\tProxy.isProxyClass(handlerType) ? handlerType.getInterfaces() : new Class<?>[]{handlerType};\n\t\tfor (Class<?> currentHandlerType : handlerTypes) {\n\t\t\tReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {\n\t\t\t\tpublic void doWith(Method method) {\n\t\t\t\t\tRequestMapping mapping = AnnotationUtils.findAnnotation(method, RequestMapping.class);\n\t\t\t\t\tif (mapping != null) {\n\t\t\t\t\t\tString[] mappedPaths = mapping.value();\n\t\t\t\t\t\tfor (String mappedPath : mappedPaths) {\n\t\t\t\t\t\t\taddUrlsForPath(urls, mappedPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn StringUtils.toStringArray(urls);\n\t}","commit_id":"5680cd4a19c9aae40f433210ce38c9e799cb901a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"protected boolean isHandlerMethod(Method method) {\n\t\treturn method.isAnnotationPresent(RequestMapping.class);\n\t}","id":71417,"modified_method":"protected boolean isHandlerMethod(Method method) {\n\t\treturn AnnotationUtils.findAnnotation(method, RequestMapping.class) != null;\n\t}","commit_id":"5680cd4a19c9aae40f433210ce38c9e799cb901a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Initialize a new HandlerMethodResolver for the specified handler type.\n\t * @param handlerType the handler class to introspect\n\t */\n\tpublic void init(final Class<?> handlerType) {\n\t\tReflectionUtils.doWithMethods(handlerType, new ReflectionUtils.MethodCallback() {\n\t\t\tpublic void doWith(Method method) {\n\t\t\t\tif (isHandlerMethod(method)) {\n\t\t\t\t\thandlerMethods.add(ClassUtils.getMostSpecificMethod(method, handlerType));\n\t\t\t\t}\n\t\t\t\telse if (method.isAnnotationPresent(InitBinder.class)) {\n\t\t\t\t\tinitBinderMethods.add(ClassUtils.getMostSpecificMethod(method, handlerType));\n\t\t\t\t}\n\t\t\t\telse if (method.isAnnotationPresent(ModelAttribute.class)) {\n\t\t\t\t\tmodelAttributeMethods.add(ClassUtils.getMostSpecificMethod(method, handlerType));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.typeLevelMapping = handlerType.getAnnotation(RequestMapping.class);\n\t\tSessionAttributes sessionAttributes = handlerType.getAnnotation(SessionAttributes.class);\n\t\tthis.sessionAttributesFound = (sessionAttributes != null);\n\t\tif (this.sessionAttributesFound) {\n\t\t\tthis.sessionAttributeNames.addAll(Arrays.asList(sessionAttributes.value()));\n\t\t\tthis.sessionAttributeTypes.addAll(Arrays.asList(sessionAttributes.types()));\n\t\t}\n\t}","id":71418,"modified_method":"/**\n\t * Initialize a new HandlerMethodResolver for the specified handler type.\n\t * @param handlerType the handler class to introspect\n\t */\n\tpublic void init(Class<?> handlerType) {\n\t\tClass<?>[] handlerTypes =\n\t\t\t\tProxy.isProxyClass(handlerType) ? handlerType.getInterfaces() : new Class<?>[]{handlerType};\n\t\tfor (final Class<?> currentHandlerType : handlerTypes) {\n\t\t\tReflectionUtils.doWithMethods(currentHandlerType, new ReflectionUtils.MethodCallback() {\n\t\t\t\tpublic void doWith(Method method) {\n\t\t\t\t\tif (isHandlerMethod(ClassUtils.getMostSpecificMethod(method, currentHandlerType))) {\n\t\t\t\t\t\thandlerMethods.add(ClassUtils.getMostSpecificMethod(method, currentHandlerType));\n\t\t\t\t\t}\n\t\t\t\t\telse if (method.isAnnotationPresent(InitBinder.class)) {\n\t\t\t\t\t\tinitBinderMethods.add(ClassUtils.getMostSpecificMethod(method, currentHandlerType));\n\t\t\t\t\t}\n\t\t\t\t\telse if (method.isAnnotationPresent(ModelAttribute.class)) {\n\t\t\t\t\t\tmodelAttributeMethods.add(ClassUtils.getMostSpecificMethod(method, currentHandlerType));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis.typeLevelMapping = AnnotationUtils.findAnnotation(handlerType, RequestMapping.class);\n\t\tSessionAttributes sessionAttributes = handlerType.getAnnotation(SessionAttributes.class);\n\t\tthis.sessionAttributesFound = (sessionAttributes != null);\n\t\tif (this.sessionAttributesFound) {\n\t\t\tthis.sessionAttributeNames.addAll(Arrays.asList(sessionAttributes.value()));\n\t\t\tthis.sessionAttributeTypes.addAll(Arrays.asList(sessionAttributes.types()));\n\t\t}\n\t}","commit_id":"5680cd4a19c9aae40f433210ce38c9e799cb901a","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic ModelAndView getModelAndView(Method handlerMethod,\n\t\t\t\tClass handlerType,\n\t\t\t\tObject returnValue,\n\t\t\t\tExtendedModelMap implicitModel,\n\t\t\t\tServletWebRequest webRequest) throws Exception {\n\n\t\t\tif (handlerMethod.isAnnotationPresent(ResponseStatus.class)) {\n\t\t\t\tResponseStatus responseStatus = handlerMethod.getAnnotation(ResponseStatus.class);\n\t\t\t\tHttpServletResponse response = webRequest.getResponse();\n\t\t\t\tresponse.setStatus(responseStatus.value().value());\n\t\t\t\tresponseArgumentUsed = true;\n\t\t\t}\n\n\t\t\t// Invoke custom resolvers if present...\n\t\t\tif (customModelAndViewResolvers != null) {\n\t\t\t\tfor (ModelAndViewResolver mavResolver : customModelAndViewResolvers) {\n\t\t\t\t\tModelAndView mav = mavResolver\n\t\t\t\t\t\t\t.resolveModelAndView(handlerMethod, handlerType, returnValue, implicitModel, webRequest);\n\t\t\t\t\tif (mav != ModelAndViewResolver.UNRESOLVED) {\n\t\t\t\t\t\treturn mav;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (returnValue != null && handlerMethod.isAnnotationPresent(ResponseBody.class)) {\n\t\t\t\thandleRequestBody(returnValue, webRequest);\n\t\t\t}\n\n\t\t\tif (returnValue instanceof ModelAndView) {\n\t\t\t\tModelAndView mav = (ModelAndView) returnValue;\n\t\t\t\tmav.getModelMap().mergeAttributes(implicitModel);\n\t\t\t\treturn mav;\n\t\t\t}\n\t\t\telse if (returnValue instanceof Model) {\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel).addAllObjects(((Model) returnValue).asMap());\n\t\t\t}\n\t\t\telse if (returnValue instanceof View) {\n\t\t\t\treturn new ModelAndView((View) returnValue).addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse if (handlerMethod.isAnnotationPresent(ModelAttribute.class)) {\n\t\t\t\taddReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse if (returnValue instanceof Map) {\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel).addAllObjects((Map) returnValue);\n\t\t\t}\n\t\t\telse if (returnValue instanceof String) {\n\t\t\t\treturn new ModelAndView((String) returnValue).addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse if (returnValue == null) {\n\t\t\t\t// Either returned null or was 'void' return.\n\t\t\t\tif (this.responseArgumentUsed || webRequest.isNotModified()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Assuming view name translation...\n\t\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!BeanUtils.isSimpleProperty(returnValue.getClass())) {\n\t\t\t\t// Assume a single model attribute...\n\t\t\t\taddReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid handler method return value: \" + returnValue);\n\t\t\t}\n\t\t}","id":71419,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tpublic ModelAndView getModelAndView(Method handlerMethod,\n\t\t\t\tClass handlerType,\n\t\t\t\tObject returnValue,\n\t\t\t\tExtendedModelMap implicitModel,\n\t\t\t\tServletWebRequest webRequest) throws Exception {\n\t\t\t\n\t\t\tResponseStatus responseStatus = AnnotationUtils.findAnnotation(handlerMethod, ResponseStatus.class);\n\t\t\tif (responseStatus != null) {\n\t\t\t\tHttpServletResponse response = webRequest.getResponse();\n\t\t\t\tresponse.setStatus(responseStatus.value().value());\n\t\t\t\tresponseArgumentUsed = true;\n\t\t\t}\n\n\t\t\t// Invoke custom resolvers if present...\n\t\t\tif (customModelAndViewResolvers != null) {\n\t\t\t\tfor (ModelAndViewResolver mavResolver : customModelAndViewResolvers) {\n\t\t\t\t\tModelAndView mav = mavResolver\n\t\t\t\t\t\t\t.resolveModelAndView(handlerMethod, handlerType, returnValue, implicitModel, webRequest);\n\t\t\t\t\tif (mav != ModelAndViewResolver.UNRESOLVED) {\n\t\t\t\t\t\treturn mav;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (returnValue != null && AnnotationUtils.findAnnotation(handlerMethod, ResponseBody.class) != null) {\n\t\t\t\thandleResponseBody(returnValue, webRequest);\n\t\t\t}\n\n\t\t\tif (returnValue instanceof ModelAndView) {\n\t\t\t\tModelAndView mav = (ModelAndView) returnValue;\n\t\t\t\tmav.getModelMap().mergeAttributes(implicitModel);\n\t\t\t\treturn mav;\n\t\t\t}\n\t\t\telse if (returnValue instanceof Model) {\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel).addAllObjects(((Model) returnValue).asMap());\n\t\t\t}\n\t\t\telse if (returnValue instanceof View) {\n\t\t\t\treturn new ModelAndView((View) returnValue).addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse if (AnnotationUtils.findAnnotation(handlerMethod, ModelAttribute.class) != null) {\n\t\t\t\taddReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse if (returnValue instanceof Map) {\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel).addAllObjects((Map) returnValue);\n\t\t\t}\n\t\t\telse if (returnValue instanceof String) {\n\t\t\t\treturn new ModelAndView((String) returnValue).addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse if (returnValue == null) {\n\t\t\t\t// Either returned null or was 'void' return.\n\t\t\t\tif (this.responseArgumentUsed || webRequest.isNotModified()) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Assuming view name translation...\n\t\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!BeanUtils.isSimpleProperty(returnValue.getClass())) {\n\t\t\t\t// Assume a single model attribute...\n\t\t\t\taddReturnValueAsModelAttribute(handlerMethod, handlerType, returnValue, implicitModel);\n\t\t\t\treturn new ModelAndView().addAllObjects(implicitModel);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid handler method return value: \" + returnValue);\n\t\t\t}\n\t\t}","commit_id":"04fa5d4b99989d96a478fd788b0e821aba9f32d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\t\tprivate void handleRequestBody(Object returnValue, ServletWebRequest webRequest) throws ServletException, IOException {\n\t\t\tHttpInputMessage inputMessage = new ServletServerHttpRequest(webRequest.getRequest());\n\t\t\tList<MediaType> acceptedMediaTypes = inputMessage.getHeaders().getAccept();\n\t\t\tHttpOutputMessage outputMessage = new ServletServerHttpResponse(webRequest.getResponse());\n\t\t\tClass<?> returnValueType = returnValue.getClass();\n\t\t\tList<MediaType> allSupportedMediaTypes = new ArrayList<MediaType>();\n\t\t\tif (messageConverters != null) {\n\t\t\t\tfor (HttpMessageConverter messageConverter : messageConverters) {\n\t\t\t\t\tallSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n\t\t\t\t\tif (messageConverter.supports(returnValueType)) {\n\t\t\t\t\t\tfor (Object o : messageConverter.getSupportedMediaTypes()) {\n\t\t\t\t\t\t\tMediaType supportedMediaType = (MediaType) o;\n\t\t\t\t\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\t\t\t\t\tif (supportedMediaType.includes(acceptedMediaType)) {\n\t\t\t\t\t\t\t\t\tmessageConverter.write(returnValue, outputMessage);\n\t\t\t\t\t\t\t\t\tresponseArgumentUsed = true;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n\t\t}","id":71420,"modified_method":"@SuppressWarnings(\"unchecked\")\n\t\tprivate void handleResponseBody(Object returnValue, ServletWebRequest webRequest) throws ServletException, IOException {\n\t\t\tHttpInputMessage inputMessage = new ServletServerHttpRequest(webRequest.getRequest());\n\t\t\tList<MediaType> acceptedMediaTypes = inputMessage.getHeaders().getAccept();\n\t\t\tHttpOutputMessage outputMessage = new ServletServerHttpResponse(webRequest.getResponse());\n\t\t\tClass<?> returnValueType = returnValue.getClass();\n\t\t\tList<MediaType> allSupportedMediaTypes = new ArrayList<MediaType>();\n\t\t\tif (messageConverters != null) {\n\t\t\t\tfor (HttpMessageConverter messageConverter : messageConverters) {\n\t\t\t\t\tallSupportedMediaTypes.addAll(messageConverter.getSupportedMediaTypes());\n\t\t\t\t\tif (messageConverter.supports(returnValueType)) {\n\t\t\t\t\t\tfor (Object o : messageConverter.getSupportedMediaTypes()) {\n\t\t\t\t\t\t\tMediaType supportedMediaType = (MediaType) o;\n\t\t\t\t\t\t\tfor (MediaType acceptedMediaType : acceptedMediaTypes) {\n\t\t\t\t\t\t\t\tif (supportedMediaType.includes(acceptedMediaType)) {\n\t\t\t\t\t\t\t\t\tmessageConverter.write(returnValue, outputMessage);\n\t\t\t\t\t\t\t\t\tresponseArgumentUsed = true;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new HttpMediaTypeNotAcceptableException(allSupportedMediaTypes);\n\t\t}","commit_id":"04fa5d4b99989d96a478fd788b0e821aba9f32d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\tif (handler.getClass().getAnnotation(SessionAttributes.class) != null) {\n\t\t\t// Always prevent caching in case of session attribute management.\n\t\t\tcheckAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);\n\t\t\t// Prepare cached set of session attributes names.\n\t\t}\n\t\telse {\n\t\t\t// Uses configured default cacheSeconds setting.\n\t\t\tcheckAndPrepare(request, response, true);\n\t\t}\n\n\t\t// Execute invokeHandlerMethod in synchronized block if required.\n\t\tif (this.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\tsynchronized (mutex) {\n\t\t\t\t\treturn invokeHandlerMethod(request, response, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invokeHandlerMethod(request, response, handler);\n\t}","id":71421,"modified_method":"public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\n\t\tif (AnnotationUtils.findAnnotation(handler.getClass(), SessionAttributes.class) != null) {\n\t\t\t// Always prevent caching in case of session attribute management.\n\t\t\tcheckAndPrepare(request, response, this.cacheSecondsForSessionAttributeHandlers, true);\n\t\t\t// Prepare cached set of session attributes names.\n\t\t}\n\t\telse {\n\t\t\t// Uses configured default cacheSeconds setting.\n\t\t\tcheckAndPrepare(request, response, true);\n\t\t}\n\n\t\t// Execute invokeHandlerMethod in synchronized block if required.\n\t\tif (this.synchronizeOnSession) {\n\t\t\tHttpSession session = request.getSession(false);\n\t\t\tif (session != null) {\n\t\t\t\tObject mutex = WebUtils.getSessionMutex(session);\n\t\t\t\tsynchronized (mutex) {\n\t\t\t\t\treturn invokeHandlerMethod(request, response, handler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn invokeHandlerMethod(request, response, handler);\n\t}","commit_id":"04fa5d4b99989d96a478fd788b0e821aba9f32d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@SuppressWarnings(\"unchecked\")\n\tprivate ModelAndView getModelAndView(Method handlerMethod, Object returnValue, ServletWebRequest webRequest)\n\t\t\tthrows Exception {\n\n\t\tif (handlerMethod.isAnnotationPresent(ResponseStatus.class)) {\n\t\t\tResponseStatus responseStatus = handlerMethod.getAnnotation(ResponseStatus.class);\n\t\t\tHttpServletResponse response = webRequest.getResponse();\n\t\t\tresponse.setStatus(responseStatus.value().value());\n\t\t}\n\t\tif (returnValue instanceof ModelAndView) {\n\t\t\treturn (ModelAndView) returnValue;\n\t\t}\n\t\telse if (returnValue instanceof Model) {\n\t\t\treturn new ModelAndView().addAllObjects(((Model) returnValue).asMap());\n\t\t}\n\t\telse if (returnValue instanceof Map) {\n\t\t\treturn new ModelAndView().addAllObjects((Map) returnValue);\n\t\t}\n\t\telse if (returnValue instanceof View) {\n\t\t\treturn new ModelAndView((View) returnValue);\n\t\t}\n\t\telse if (returnValue instanceof String) {\n\t\t\treturn new ModelAndView((String) returnValue);\n\t\t}\n\t\telse if (returnValue == null) {\n\t\t\treturn new ModelAndView();\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Invalid handler method return value: \" + returnValue);\n\t\t}\n\t}","id":71422,"modified_method":"@SuppressWarnings(\"unchecked\")\n\tprivate ModelAndView getModelAndView(Method handlerMethod, Object returnValue, ServletWebRequest webRequest)\n\t\t\tthrows Exception {\n\n\t\tResponseStatus responseStatus = AnnotationUtils.findAnnotation(handlerMethod, ResponseStatus.class);\n\t\tif (responseStatus != null) {\n\t\t\tHttpServletResponse response = webRequest.getResponse();\n\t\t\tresponse.setStatus(responseStatus.value().value());\n\t\t}\n\t\tif (returnValue instanceof ModelAndView) {\n\t\t\treturn (ModelAndView) returnValue;\n\t\t}\n\t\telse if (returnValue instanceof Model) {\n\t\t\treturn new ModelAndView().addAllObjects(((Model) returnValue).asMap());\n\t\t}\n\t\telse if (returnValue instanceof Map) {\n\t\t\treturn new ModelAndView().addAllObjects((Map) returnValue);\n\t\t}\n\t\telse if (returnValue instanceof View) {\n\t\t\treturn new ModelAndView((View) returnValue);\n\t\t}\n\t\telse if (returnValue instanceof String) {\n\t\t\treturn new ModelAndView((String) returnValue);\n\t\t}\n\t\telse if (returnValue == null) {\n\t\t\treturn new ModelAndView();\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Invalid handler method return value: \" + returnValue);\n\t\t}\n\t}","commit_id":"04fa5d4b99989d96a478fd788b0e821aba9f32d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Finds the handler method that matches the thrown exception best.\n\t *\n\t * @param handler\t\t the handler object\n\t * @param thrownException the exception to be handled\n\t * @return the best matching method; or <code>null<\/code> if none is found\n\t */\n\tprivate Method findBestExceptionHandlerMethod(Object handler, final Exception thrownException) {\n\t\tfinal Class<?> handlerType = handler.getClass();\n\t\tfinal Class<? extends Throwable> thrownExceptionType = thrownException.getClass();\n\n\t\tfinal Map<Class<? extends Throwable>, Method> resolverMethods =\n\t\t\t\tnew LinkedHashMap<Class<? extends Throwable>, Method>();\n\n\t\tReflectionUtils.doWithMethods(handlerType, new ReflectionUtils.MethodCallback() {\n\t\t\tpublic void doWith(Method method) {\n\t\t\t\tmethod = ClassUtils.getMostSpecificMethod(method, handlerType);\n\t\t\t\tList<Class<? extends Throwable>> handledExceptions = getHandledExceptions(method);\n\t\t\t\tfor (Class<? extends Throwable> handledException : handledExceptions) {\n\t\t\t\t\tif (handledException.isAssignableFrom(thrownExceptionType)) {\n\t\t\t\t\t\tif (!resolverMethods.containsKey(handledException)) {\n\t\t\t\t\t\t\tresolverMethods.put(handledException, method);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tMethod oldMappedMethod = resolverMethods.get(handledException);\n\t\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\t\"Ambiguous exception handler mapped for \" + handledException + \"]: {\" +\n\t\t\t\t\t\t\t\t\t\t\toldMappedMethod + \", \" + method + \"}.\");\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn getBestMatchingMethod(thrownException, resolverMethods);\n\t}","id":71423,"modified_method":"/**\n\t * Finds the handler method that matches the thrown exception best.\n\t *\n\t * @param handler the handler object\n\t * @param thrownException the exception to be handled\n\t * @return the best matching method; or <code>null<\/code> if none is found\n\t */\n\tprivate Method findBestExceptionHandlerMethod(Object handler, final Exception thrownException) {\n\t\tfinal Class<?> handlerType = handler.getClass();\n\t\tfinal Class<? extends Throwable> thrownExceptionType = thrownException.getClass();\n\n\t\tfinal Map<Class<? extends Throwable>, Method> resolverMethods =\n\t\t\t\tnew LinkedHashMap<Class<? extends Throwable>, Method>();\n\n\t\tReflectionUtils.doWithMethods(handlerType, new ReflectionUtils.MethodCallback() {\n\t\t\tpublic void doWith(Method method) {\n\t\t\t\tmethod = ClassUtils.getMostSpecificMethod(method, handlerType);\n\t\t\t\tList<Class<? extends Throwable>> handledExceptions = getHandledExceptions(method);\n\t\t\t\tfor (Class<? extends Throwable> handledException : handledExceptions) {\n\t\t\t\t\tif (handledException.isAssignableFrom(thrownExceptionType)) {\n\t\t\t\t\t\tif (!resolverMethods.containsKey(handledException)) {\n\t\t\t\t\t\t\tresolverMethods.put(handledException, method);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tMethod oldMappedMethod = resolverMethods.get(handledException);\n\t\t\t\t\t\t\tif (!oldMappedMethod.equals(method)) {\n\t\t\t\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\t\t\t\"Ambiguous exception handler mapped for \" + handledException + \"]: {\" +\n\t\t\t\t\t\t\t\t\t\t\t\toldMappedMethod + \", \" + method + \"}.\");\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn getBestMatchingMethod(thrownException, resolverMethods);\n\t}","commit_id":"04fa5d4b99989d96a478fd788b0e821aba9f32d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Returns all the exception classes handled by the given method.\n\t * <p>Default implementation looks for exceptions in the {@linkplain ExceptionHandler#value() annotation}, or -\n\t * if that annotation element is empty - any exceptions listed in the method parameters if the method is annotated\n\t * with {@code @ExceptionHandler}.\n\t *\n\t * @param method the method\n\t * @return the handled exceptions\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected List<Class<? extends Throwable>> getHandledExceptions(Method method) {\n\t\tList<Class<? extends Throwable>> result = new ArrayList<Class<? extends Throwable>>();\n\t\tExceptionHandler exceptionHandler = method.getAnnotation(ExceptionHandler.class);\n\t\tif (exceptionHandler != null) {\n\t\t\tif (!ObjectUtils.isEmpty(exceptionHandler.value())) {\n\t\t\t\tresult.addAll(Arrays.asList(exceptionHandler.value()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (Class<?> param : method.getParameterTypes()) {\n\t\t\t\t\tif (Throwable.class.isAssignableFrom(param)) {\n\t\t\t\t\t\tresult.add((Class<? extends Throwable>) param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":71424,"modified_method":"/**\n\t * Returns all the exception classes handled by the given method. <p>Default implementation looks for exceptions in the\n\t * {@linkplain ExceptionHandler#value() annotation}, or - if that annotation element is empty - any exceptions listed\n\t * in the method parameters if the method is annotated with {@code @ExceptionHandler}.\n\t *\n\t * @param method the method\n\t * @return the handled exceptions\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected List<Class<? extends Throwable>> getHandledExceptions(Method method) {\n\t\tList<Class<? extends Throwable>> result = new ArrayList<Class<? extends Throwable>>();\n\t\tExceptionHandler exceptionHandler = AnnotationUtils.findAnnotation(method, ExceptionHandler.class);\n\t\tif (exceptionHandler != null) {\n\t\t\tif (!ObjectUtils.isEmpty(exceptionHandler.value())) {\n\t\t\t\tresult.addAll(Arrays.asList(exceptionHandler.value()));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (Class<?> param : method.getParameterTypes()) {\n\t\t\t\t\tif (Throwable.class.isAssignableFrom(param)) {\n\t\t\t\t\t\tresult.add((Class<? extends Throwable>) param);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"04fa5d4b99989d96a478fd788b0e821aba9f32d6","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public void testConcurrentJoins() throws Exception {\n        start_connecting=new CyclicBarrier(NUM +1);\n        connected=new CyclicBarrier(NUM +1);\n        start_disconnecting=new CyclicBarrier(NUM +1);\n        disconnected=new CyclicBarrier(NUM +1);\n\n        long start, stop;\n\n        //  create main channel - will be coordinator for JOIN requests\n        channel=new JChannel(props);\n        channel.connect(groupname);\n        System.out.println(\"connected the first member: address is \" + channel.getLocalAddress());\n        // at this point we have successfully connected\n\n        assertEquals(channel.getView().getMembers().size(), 1);\n\n        threads=new MyThread[NUM];\n        for(int i=0; i < threads.length; i++) {\n            threads[i]=new MyThread(i);\n            threads[i].start();\n        }\n\n        // signal the threads to start connecting to their channels\n        start_connecting.barrier();\n        start=System.currentTimeMillis();\n\n        try {\n            connected.barrier();\n            stop=System.currentTimeMillis();\n            System.out.println(\"-- took \" + (stop-start) + \" msecs for all \" + NUM + \" threads to connect\");\n\n            int num_members=0;\n            for(int i=0; i < 10; i++) {\n                num_members=channel.getView().getMembers().size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: \" +(NUM+1) + ')');\n                if(num_members >= NUM+1)\n                    break;\n                Util.sleep(500);\n            }\n            assertEquals((NUM+1), num_members);\n        }\n        catch(Exception ex) {\n            fail(ex.toString());\n        }\n    }","id":71425,"modified_method":"public void testConcurrentJoins() throws Exception {\n        start_connecting=new CyclicBarrier(NUM +1);\n        connected=new CyclicBarrier(NUM +1);\n        received_all_views=new CyclicBarrier(NUM +1);\n        start_disconnecting=new CyclicBarrier(NUM +1);\n        disconnected=new CyclicBarrier(NUM +1);\n\n        long start, stop;\n\n        //  create main channel - will be coordinator for JOIN requests\n        channel=new JChannel(props);\n        start=System.currentTimeMillis();\n        channel.connect(groupname);\n        stop=System.currentTimeMillis();\n        log(channel.getLocalAddress() + \" connected in \" + (stop-start) + \" msecs (\" +\n                    channel.getView().getMembers().size() + \" members). VID=\" + channel.getView().getVid());\n        assertEquals(channel.getView().getMembers().size(), 1);\n\n        threads=new MyThread[NUM];\n        for(int i=0; i < threads.length; i++) {\n            threads[i]=new MyThread(i);\n            threads[i].start();\n        }\n\n        // signal the threads to start connecting to their channels\n        start_connecting.barrier();\n        start=System.currentTimeMillis();\n\n        try {\n            connected.barrier();\n            stop=System.currentTimeMillis();\n            System.out.println(\"-- took \" + (stop-start) + \" msecs for all \" + NUM + \" threads to connect\");\n\n            received_all_views.barrier();\n            stop=System.currentTimeMillis();\n            System.out.println(\"-- took \" + (stop-start) + \" msecs for all \" + NUM + \" threads to see all views\");\n\n//            int num_members=0;\n//            for(int i=0; i < 10; i++) {\n//                num_members=channel.getView().getMembers().size();\n//                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: \" +(NUM+1) + ')');\n//                if(num_members >= NUM+1)\n//                    break;\n//                Util.sleep(500);\n//            }\n\n\n            int num_members=channel.getView().getMembers().size();\n            System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: \" +(NUM+1) + ')');\n            assertEquals((NUM+1), num_members);\n            // Util.sleep(5000L);\n        }\n        catch(Exception ex) {\n            fail(ex.toString());\n        }\n    }","commit_id":"578b53c7e503768505189365c7cc0b6851dad273","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            View v=channel.getView();\n            Vector mbrs=v != null? v.getMembers() : null;\n            if(mbrs != null) {\n                num_members=mbrs.size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n                if(num_members == 1)\n                    break;\n            }\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n    }","id":71426,"modified_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            View v=channel.getView();\n            Vector mbrs=v != null? v.getMembers() : null;\n            if(mbrs != null) {\n                num_members=mbrs.size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n                if(num_members <= 1)\n                    break;\n            }\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n        channel.close();\n    }","commit_id":"578b53c7e503768505189365c7cc0b6851dad273","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            JChannel ch=null;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                //Util.sleepRandom(5000);\n                log(\"connecting to channel\");\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                log(ch.getLocalAddress() + \" connected in \" + total_connect_time + \" msecs (\" +\n                    channel.getView().getMembers().size() + \" members).\");\n\n                connected.barrier();\n\n                start_disconnecting.barrier();\n                log(\"disconnecting from channel\");\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(\"disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","id":71427,"modified_method":"public void run() {\n            JChannel ch=null;\n            View view;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                view=ch.getView();\n                my_addr=ch.getLocalAddress();\n                log(my_addr + \" connected in \" + total_connect_time + \" msecs (\" +\n                    view.getMembers().size() + \" members). VID=\" + view.getVid());\n\n                connected.barrier();\n\n                int num_members=0;\n                while((num_members=ch.getView().getMembers().size()) < NUM+1) {\n                    log(\"num_members=\" + num_members);\n                    Util.sleep(2000);\n                }\n                log(\"reached \" + num_members + \" members\");\n                received_all_views.barrier();\n\n                start_disconnecting.barrier();\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(my_addr + \" disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","commit_id":"578b53c7e503768505189365c7cc0b6851dad273","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testConcurrentJoins() throws Exception {\n        start_connecting=new CyclicBarrier(NUM +1);\n        connected=new CyclicBarrier(NUM +1);\n        start_disconnecting=new CyclicBarrier(NUM +1);\n        disconnected=new CyclicBarrier(NUM +1);\n\n        long start, stop;\n\n        //  create main channel - will be coordinator for JOIN requests\n        channel=new JChannel(props);\n        channel.connect(groupname);\n        System.out.println(\"connected the first member: address is \" + channel.getLocalAddress());\n        // at this point we have successfully connected\n\n        assertEquals(channel.getView().getMembers().size(), 1);\n\n        threads=new MyThread[NUM];\n        for(int i=0; i < threads.length; i++) {\n            threads[i]=new MyThread(i);\n            threads[i].start();\n        }\n\n        // signal the threads to start connecting to their channels\n        start_connecting.barrier();\n        start=System.currentTimeMillis();\n\n        try {\n            connected.barrier();\n            stop=System.currentTimeMillis();\n            System.out.println(\"-- took \" + (stop-start) + \" msecs for all \" + NUM + \" threads to connect\");\n\n            int num_members=0;\n            for(int i=0; i < 10; i++) {\n                num_members=channel.getView().getMembers().size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: \" +(NUM+1) + ')');\n                if(num_members >= NUM+1)\n                    break;\n                Util.sleep(500);\n            }\n            assertEquals((NUM+1), num_members);\n        }\n        catch(Exception ex) {\n            fail(ex.toString());\n        }\n    }","id":71428,"modified_method":"public void testConcurrentJoins() throws Exception {\n        start_connecting=new CyclicBarrier(NUM +1);\n        connected=new CyclicBarrier(NUM +1);\n        received_all_views=new CyclicBarrier(NUM +1);\n        start_disconnecting=new CyclicBarrier(NUM +1);\n        disconnected=new CyclicBarrier(NUM +1);\n\n        long start, stop;\n\n        //  create main channel - will be coordinator for JOIN requests\n        channel=new JChannel(props);\n        start=System.currentTimeMillis();\n        channel.connect(groupname);\n        stop=System.currentTimeMillis();\n        log(channel.getLocalAddress() + \" connected in \" + (stop-start) + \" msecs (\" +\n                    channel.getView().getMembers().size() + \" members). VID=\" + channel.getView().getVid());\n        assertEquals(channel.getView().getMembers().size(), 1);\n\n        threads=new MyThread[NUM];\n        for(int i=0; i < threads.length; i++) {\n            threads[i]=new MyThread(i);\n            threads[i].start();\n        }\n\n        // signal the threads to start connecting to their channels\n        start_connecting.barrier();\n        start=System.currentTimeMillis();\n\n        try {\n            connected.barrier();\n            stop=System.currentTimeMillis();\n            System.out.println(\"-- took \" + (stop-start) + \" msecs for all \" + NUM + \" threads to connect\");\n\n            received_all_views.barrier();\n            stop=System.currentTimeMillis();\n            System.out.println(\"-- took \" + (stop-start) + \" msecs for all \" + NUM + \" threads to see all views\");\n\n//            int num_members=0;\n//            for(int i=0; i < 10; i++) {\n//                num_members=channel.getView().getMembers().size();\n//                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: \" +(NUM+1) + ')');\n//                if(num_members >= NUM+1)\n//                    break;\n//                Util.sleep(500);\n//            }\n\n\n            int num_members=channel.getView().getMembers().size();\n            System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: \" +(NUM+1) + ')');\n            assertEquals((NUM+1), num_members);\n            // Util.sleep(5000L);\n        }\n        catch(Exception ex) {\n            fail(ex.toString());\n        }\n    }","commit_id":"c6c1dc09d27df0e38f3d16e2b2584fb2f91f3002","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            JChannel ch=null;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                //Util.sleepRandom(5000);\n                log(\"connecting to channel\");\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                log(ch.getLocalAddress() + \" connected in \" + total_connect_time + \" msecs (\" +\n                    channel.getView().getMembers().size() + \" members).\");\n\n                connected.barrier();\n\n                start_disconnecting.barrier();\n                log(\"disconnecting from channel\");\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(\"disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","id":71429,"modified_method":"public void run() {\n            JChannel ch=null;\n            View view;\n\n            try {\n                ch=new JChannel(props);\n\n                start_connecting.barrier();\n\n                long start=System.currentTimeMillis(), stop;\n                ch.connect(groupname);\n                stop=System.currentTimeMillis();\n                total_connect_time=stop-start;\n                view=ch.getView();\n                my_addr=ch.getLocalAddress();\n                log(my_addr + \" connected in \" + total_connect_time + \" msecs (\" +\n                    view.getMembers().size() + \" members). VID=\" + view.getVid());\n\n                connected.barrier();\n\n                int num_members=0;\n                while((num_members=ch.getView().getMembers().size()) < NUM+1) {\n                    log(\"num_members=\" + num_members);\n                    Util.sleep(2000);\n                }\n                log(\"reached \" + num_members + \" members\");\n                received_all_views.barrier();\n\n                start_disconnecting.barrier();\n                start=System.currentTimeMillis();\n                ch.close();\n                stop=System.currentTimeMillis();\n\n                log(my_addr + \" disconnected in \" + (stop-start) + \" msecs\");\n                disconnected.barrier();\n            }\n            catch(BrokenBarrierException e) {\n                e.printStackTrace();\n            }\n            catch(ChannelException e) {\n                e.printStackTrace();\n            }\n            catch(InterruptedException e) {\n                e.printStackTrace();\n            }\n        }","commit_id":"c6c1dc09d27df0e38f3d16e2b2584fb2f91f3002","url":"https://github.com/belaban/JGroups"},{"original_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            View v=channel.getView();\n            Vector mbrs=v != null? v.getMembers() : null;\n            if(mbrs != null) {\n                num_members=mbrs.size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n                if(num_members == 1)\n                    break;\n            }\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n    }","id":71430,"modified_method":"public void testConcurrentLeaves() throws Exception {\n        start_disconnecting.barrier();\n        long start, stop;\n        start=System.currentTimeMillis();\n\n        disconnected.barrier();\n        stop=System.currentTimeMillis();\n        System.out.println(\"-- took \" + (stop-start) + \" msecs for \" + NUM + \" threads to disconnect\");\n\n        int num_members=0;\n        for(int i=0; i < 10; i++) {\n            View v=channel.getView();\n            Vector mbrs=v != null? v.getMembers() : null;\n            if(mbrs != null) {\n                num_members=mbrs.size();\n                System.out.println(\"*--* number of members connected: \" + num_members + \", (expected: 1)\");\n                if(num_members <= 1)\n                    break;\n            }\n            Util.sleep(500);\n        }\n        assertEquals(1, num_members);\n        channel.close();\n    }","commit_id":"c6c1dc09d27df0e38f3d16e2b2584fb2f91f3002","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Returns the output file to store the report in.\n     */\n    @Optional @OutputFile\n    public File getOutputFile() {\n        return getProject().file(outputFile);\n    }","id":71431,"modified_method":"/**\n     * Returns the output file to store the report in.\n     */\n    @Optional @OutputFile\n    public File getOutputFile() {\n        return outputFile == null ? null : getProject().file(outputFile);\n    }","commit_id":"841344478b155a9dfe470f257546b89921a2e013","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n        public FlushEvent beginFlush( long filePageId, int cachePageId, PageSwapper swapper )\n        {\n            return add( new FlushHEvent( filePageId, cachePageId, swapper, this ) );\n        }","id":71432,"modified_method":"@Override\n        public FlushEvent beginFlush( long filePageId, int cachePageId, PageSwapper swapper )\n        {\n            return add( new FlushHEvent( filePageId, cachePageId, swapper ) );\n        }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void printHistory( PrintStream out )\n    {\n        HEvent events = history.getAndSet( null );\n        if ( events == null )\n        {\n            out.println( \"No events recorded.\" );\n        }\n\n        events = reverse( events );\n        List<HEvent> concurrentIntervals = new LinkedList<>();\n\n        while ( events != end )\n        {\n            String exceptionLinePrefix = exceptionLinePrefix( concurrentIntervals.size() );\n            if ( events.getClass() == EndHEvent.class )\n            {\n                EndHEvent endHEvent = (EndHEvent) events;\n                int idx = concurrentIntervals.indexOf( endHEvent.event );\n                putcs( out, '|', idx );\n                out.print( '-' );\n                int left = concurrentIntervals.size() - idx - 1;\n                putcs( out, '|', left );\n                out.print( \"   \" );\n                endHEvent.print( out, exceptionLinePrefix );\n                concurrentIntervals.remove( idx );\n                if ( left > 0 )\n                {\n                    putcs( out, '|', idx );\n                    putcs( out, '/', left );\n                    out.println();\n                }\n            }\n            else if ( events instanceof IntervalHEven )\n            {\n                putcs( out, '|', concurrentIntervals.size() );\n                out.print( \"+   \" );\n                events.print( out, exceptionLinePrefix );\n                concurrentIntervals.add( events );\n                out.println();\n            }\n            else\n            {\n                putcs( out, '|', concurrentIntervals.size() );\n                out.print( \">   \" );\n                events.print( out, exceptionLinePrefix );\n            }\n            events = events.prev;\n        }\n    }","id":71433,"modified_method":"public synchronized void printHistory( PrintStream outputStream )\n    {\n        bufferOut.setOut( outputStream );\n        HEvent events = history.getAndSet( null );\n        if ( events == null )\n        {\n            out.println( \"No events recorded.\" );\n        }\n\n        events = reverse( events );\n        List<HEvent> concurrentIntervals = new LinkedList<>();\n\n        while ( events != end )\n        {\n            String exceptionLinePrefix = exceptionLinePrefix( concurrentIntervals.size() );\n            if ( events.getClass() == EndHEvent.class )\n            {\n                EndHEvent endHEvent = (EndHEvent) events;\n                int idx = concurrentIntervals.indexOf( endHEvent.event );\n                putcs( out, '|', idx );\n                out.print( '-' );\n                int left = concurrentIntervals.size() - idx - 1;\n                putcs( out, '|', left );\n                out.print( \"   \" );\n                endHEvent.print( out, exceptionLinePrefix );\n                concurrentIntervals.remove( idx );\n                if ( left > 0 )\n                {\n                    out.println();\n                    putcs( out, '|', idx );\n                    putcs( out, '/', left );\n                }\n            }\n            else if ( events instanceof IntervalHEven )\n            {\n                putcs( out, '|', concurrentIntervals.size() );\n                out.print( \"+   \" );\n                events.print( out, exceptionLinePrefix );\n                concurrentIntervals.add( events );\n            }\n            else\n            {\n                putcs( out, '|', concurrentIntervals.size() );\n                out.print( \">   \" );\n                events.print( out, exceptionLinePrefix );\n            }\n            out.println();\n            events = events.prev;\n        }\n        out.flush();\n    }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public FlushHEvent( long filePageId, int cachePageId, PageSwapper swapper, HEvent cause )\n        {\n            this.filePageId = filePageId;\n            this.cachePageId = cachePageId;\n            this.file = swapper.file();\n            this.cause = cause;\n        }","id":71434,"modified_method":"public FlushHEvent( long filePageId, int cachePageId, PageSwapper swapper )\n        {\n            this.filePageId = filePageId;\n            this.cachePageId = cachePageId;\n            this.file = swapper.file();\n        }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public final void print( PrintStream out, String exceptionLinePrefix )\n        {\n            if ( getClass() == EndHEvent.class )\n            {\n                out.append( '-' );\n            }\n            out.print( getClass().getSimpleName() );\n            out.print( '[' );\n            out.print( \"time:\" );\n            out.print( (time - end.time) / 1000 );\n            out.print( \", threadId:\" );\n            out.print( threadId );\n            printBody( out, exceptionLinePrefix );\n            out.print( ']' );\n        }","id":71435,"modified_method":"public final void print( PrintStream out, String exceptionLinePrefix )\n        {\n            if ( getClass() == EndHEvent.class )\n            {\n                out.print( '-' );\n            }\n            out.print( getClass().getSimpleName() );\n            out.print( '[' );\n            out.print( \"time:\" );\n            out.print( (time - end.time) / 1000 );\n            out.print( \", threadId:\" );\n            out.print( threadId );\n            printBody( out, exceptionLinePrefix );\n            out.print( ']' );\n        }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void setSwapper( PageSwapper swapper )\n        {\n            file = swapper.file();\n        }","id":71436,"modified_method":"@Override\n        public void setSwapper( PageSwapper swapper )\n        {\n            file = swapper == null? null : swapper.file();\n        }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        void printBody( PrintStream out, String exceptionLinePrefix )\n        {\n            out.print( \", elapsedMicros:\" );\n            out.print( (time - event.time) / 1000 );\n            out.print( \", endOf:\" );\n            out.print( event.getClass().getSimpleName() );\n        }","id":71437,"modified_method":"@Override\n        void printBody( PrintStream out, String exceptionLinePrefix )\n        {\n            out.print( \", elapsedMicros:\" );\n            out.print( (time - event.time) / 1000 );\n            out.print( \", endOf:\" );\n            Class<? extends IntervalHEven> eventClass = event.getClass();\n            String className = classSimpleNameCache.get( eventClass );\n            if ( className == null )\n            {\n                className = eventClass.getSimpleName();\n                classSimpleNameCache.put( eventClass, className );\n            }\n            out.print( className );\n        }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public FlushEvent beginFlush( long filePageId, int cachePageId, PageSwapper swapper )\n        {\n            return add( new FlushHEvent( filePageId, cachePageId, swapper, this ) );\n        }","id":71438,"modified_method":"@Override\n        public FlushEvent beginFlush( long filePageId, int cachePageId, PageSwapper swapper )\n        {\n            return add( new FlushHEvent( filePageId, cachePageId, swapper ) );\n        }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public PageFaultEvent beginPageFault()\n        {\n            return add( new PageFaultHEvent( this ) );\n        }","id":71439,"modified_method":"@Override\n        public PageFaultEvent beginPageFault()\n        {\n            return add( new PageFaultHEvent() );\n        }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"/**\n     * NOTE: This method MUST be called while holding the page write lock.\n     */\n    public void evict( EvictionEvent evictionEvent ) throws IOException\n    {\n        assert isWriteLocked(): \"Cannot evict page without write-lock\";\n        long filePageId = this.filePageId;\n        evictionEvent.setCachePageId( getCachePageId() );\n        evictionEvent.setFilePageId( filePageId );\n\n        flush( evictionEvent.flushEventOpportunity() );\n        UnsafeUtil.setMemory( pointer, getCachePageSize(), (byte) 0 );\n        this.filePageId = PageCursor.UNBOUND_PAGE_ID;\n\n        PageSwapper swapper = this.swapper;\n        this.swapper = null;\n\n        if ( swapper != null )\n        {\n            // The swapper can be null if the last page fault\n            // that page threw an exception.\n            swapper.evicted( filePageId, this );\n            evictionEvent.setSwapper( swapper );\n        }\n    }","id":71440,"modified_method":"/**\n     * NOTE: This method MUST be called while holding the page write lock.\n     */\n    public void evict( EvictionEvent evictionEvent ) throws IOException\n    {\n        assert isWriteLocked(): \"Cannot evict page without write-lock\";\n        long filePageId = this.filePageId;\n        evictionEvent.setCachePageId( getCachePageId() );\n        evictionEvent.setFilePageId( filePageId );\n        PageSwapper swapper = this.swapper;\n        evictionEvent.setSwapper( swapper );\n\n        flush( evictionEvent.flushEventOpportunity() );\n        UnsafeUtil.setMemory( pointer, getCachePageSize(), (byte) 0 );\n        this.filePageId = PageCursor.UNBOUND_PAGE_ID;\n\n        this.swapper = null;\n        if ( swapper != null )\n        {\n            // The swapper can be null if the last page fault\n            // that page threw an exception.\n            swapper.evicted( filePageId, this );\n        }\n    }","commit_id":"6964aaad55830ad890d5afb85ec0cfcdfc4250d6","url":"https://github.com/neo4j/neo4j"},{"original_method":"public void assertHasFileName(String filename) {\n            assertThat(getError(), containsLine(startsWith(filename)));\n        }","id":71441,"modified_method":"public ExecutionFailure assertHasFileName(String filename) {\n            assertThat(getError(), containsLine(startsWith(filename)));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertHasCause(String description) {\n            assertThatCause(startsWith(description));\n        }","id":71442,"modified_method":"public ExecutionFailure assertHasCause(String description) {\n            assertThatCause(startsWith(description));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertHasLineNumber(int lineNumber) {\n            assertThat(getError(), containsString(String.format(\" line: %d\", lineNumber)));\n        }","id":71443,"modified_method":"public ExecutionFailure assertHasLineNumber(int lineNumber) {\n            assertThat(getError(), containsString(String.format(\" line: %d\", lineNumber)));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertHasDescription(String context) {\n            assertThatDescription(startsWith(context));\n        }","id":71444,"modified_method":"public ExecutionFailure assertHasDescription(String context) {\n            assertThatDescription(startsWith(context));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertThatCause(final Matcher<String> matcher) {\n            assertThat(getError(), containsLine(new BaseMatcher<String>() {\n                public boolean matches(Object o) {\n                    String str = (String) o;\n                    String prefix = \"Cause: \";\n                    return str.startsWith(prefix) && matcher.matches(str.substring(prefix.length()));\n                }\n\n                public void describeTo(Description description) {\n                    matcher.describeTo(description);\n                }\n            }));\n        }","id":71445,"modified_method":"public ExecutionFailure assertThatCause(final Matcher<String> matcher) {\n            assertThat(getError(), containsLine(new BaseMatcher<String>() {\n                public boolean matches(Object o) {\n                    String str = (String) o;\n                    String prefix = \"Cause: \";\n                    return str.startsWith(prefix) && matcher.matches(str.substring(prefix.length()));\n                }\n\n                public void describeTo(Description description) {\n                    matcher.describeTo(description);\n                }\n            }));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertThatDescription(Matcher<String> matcher) {\n            assertThat(getError(), containsLine(matcher));\n        }","id":71446,"modified_method":"public ExecutionFailure assertThatDescription(Matcher<String> matcher) {\n            assertThat(getError(), containsLine(matcher));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertThatDescription(Matcher<String> matcher) {\n            assertThat(failure.getMessage(), containsLine(matcher));\n        }","id":71447,"modified_method":"public ExecutionFailure assertThatDescription(Matcher<String> matcher) {\n            assertThat(failure.getMessage(), containsLine(matcher));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertHasLineNumber(int lineNumber) {\n            assertThat(failure.getMessage(), containsString(String.format(\" line: %d\", lineNumber)));\n        }","id":71448,"modified_method":"public ExecutionFailure assertHasLineNumber(int lineNumber) {\n            assertThat(failure.getMessage(), containsString(String.format(\" line: %d\", lineNumber)));\n            return this;\n\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertThatCause(final Matcher<String> matcher) {\n            if (failure instanceof LocationAwareException) {\n                LocationAwareException exception = (LocationAwareException) failure;\n                assertThat(exception.getReportableCauses(), hasItem(hasMessage(matcher)));\n            } else {\n                assertThat(failure.getCause(), notNullValue());\n                assertThat(failure.getCause().getMessage(), matcher);\n            }\n        }","id":71449,"modified_method":"public ExecutionFailure assertThatCause(final Matcher<String> matcher) {\n            if (failure instanceof LocationAwareException) {\n                LocationAwareException exception = (LocationAwareException) failure;\n                assertThat(exception.getReportableCauses(), hasItem(hasMessage(matcher)));\n            } else {\n                assertThat(failure.getCause(), notNullValue());\n                assertThat(failure.getCause().getMessage(), matcher);\n            }\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertHasFileName(String filename) {\n            assertThat(failure.getMessage(), startsWith(String.format(\"%s\", filename)));\n        }","id":71450,"modified_method":"public ExecutionFailure assertHasFileName(String filename) {\n            assertThat(failure.getMessage(), startsWith(String.format(\"%s\", filename)));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertHasDescription(String context) {\n            assertThatDescription(startsWith(context));\n        }","id":71451,"modified_method":"public ExecutionFailure assertHasDescription(String context) {\n            assertThatDescription(startsWith(context));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public void assertHasCause(String description) {\n            assertThatCause(startsWith(description));\n        }","id":71452,"modified_method":"public ExecutionFailure assertHasCause(String description) {\n            assertThatCause(startsWith(description));\n            return this;\n        }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public Sample(String name) {\n        this.name = name;\n    }","id":71453,"modified_method":"public Sample(String defaultSampleName) {\n        this.defaultSampleName = defaultSampleName;\n    }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n        dist = RuleHelper.getField(target, GradleDistribution.class);\n        sampleDir = dist.getTestDir().file(name);\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                TestFile srcDir = dist.getSamplesDir().file(name).assertIsDir();\n                srcDir.copyTo(sampleDir);\n                base.evaluate();\n            }\n        };\n    }","id":71454,"modified_method":"public Statement apply(final Statement base, FrameworkMethod method, Object target) {\n        dist = RuleHelper.getField(target, GradleDistribution.class);\n        final String sampleName = getSampleName(method);\n        sampleDir = sampleName == null ? null : dist.getTestDir().file(sampleName);\n\n        return new Statement() {\n            @Override\n            public void evaluate() throws Throwable {\n                if (sampleName != null) {\n                    TestFile srcDir = dist.getSamplesDir().file(sampleName).assertIsDir();\n                    logger.debug(\"Copying sample '{}' to test directory.\", sampleName);\n                    srcDir.copyTo(sampleDir);\n                } else {\n                    logger.debug(\"No sample specified for this test, skipping.\");\n                }\n                base.evaluate();\n            }\n        };\n    }","commit_id":"d94aa07be3c301eb3fabdbb9621617405cf9f33e","url":"https://github.com/gradle/gradle"},{"original_method":"/**\n\t * Serialize the user POJO to a ORecordDocument instance.\n\t * \n\t * @param iPojo\n\t *          User pojo to serialize\n\t * @throws IllegalAccessException\n\t * @throws IllegalArgumentException\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected static <T> T toStream(final T iPojo, final Proxy iProxiedPojo, ODatabaseObject db) throws IllegalArgumentException,\n\t\t\tIllegalAccessException {\n\n\t\tfinal ODocument iRecord = getDocument(iProxiedPojo);\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\n\n\t\tfinal Integer identityRecord = System.identityHashCode(iPojo);\n\n\t\tif (OObjectSerializationThreadLocal.INSTANCE.get().containsKey(identityRecord))\n\t\t\treturn (T) OObjectSerializationThreadLocal.INSTANCE.get().get(identityRecord);\n\n\t\tOObjectSerializationThreadLocal.INSTANCE.get().put(identityRecord, iProxiedPojo);\n\n\t\tOProperty schemaProperty;\n\n\t\tfinal Class<?> pojoClass = iPojo.getClass();\n\t\tfinal OClass schemaClass = iRecord.getSchemaClass();\n\n\t\t// CHECK FOR ID BINDING\n\t\tfinal Field idField = getIdField(pojoClass);\n\t\tif (idField != null) {\n\n\t\t\tObject id = getFieldValue(idField, iPojo);\n\t\t\tif (id != null) {\n\t\t\t\t// FOUND\n\t\t\t\tif (id instanceof ORecordId) {\n\t\t\t\t\tiRecord.setIdentity((ORecordId) id);\n\t\t\t\t} else if (id instanceof Number) {\n\t\t\t\t\t// TREATS AS CLUSTER POSITION\n\t\t\t\t\t((ORecordId) iRecord.getIdentity()).clusterId = schemaClass.getDefaultClusterId();\n\t\t\t\t\t((ORecordId) iRecord.getIdentity()).clusterPosition = ((Number) id).longValue();\n\t\t\t\t} else if (id instanceof String)\n\t\t\t\t\t((ORecordId) iRecord.getIdentity()).fromString((String) id);\n\t\t\t\telse if (id.getClass().equals(Object.class))\n\t\t\t\t\tiRecord.setIdentity((ORecordId) id);\n\t\t\t\telse\n\t\t\t\t\tOLogManager.instance().warn(OObjectSerializerHelper.class,\n\t\t\t\t\t\t\t\"@Id field has been declared as %s while the supported are: ORID, Number, String, Object\", id.getClass());\n\t\t\t}\n\t\t}\n\n\t\t// CHECK FOR VERSION BINDING\n\t\tfinal Field vField = getVersionField(pojoClass);\n\t\tboolean versionConfigured = false;\n\t\tif (vField != null) {\n\t\t\tversionConfigured = true;\n\t\t\tObject ver = getFieldValue(vField, iPojo);\n\t\t\tif (ver != null) {\n\t\t\t\t// FOUND\n\t\t\t\tif (ver instanceof Number) {\n\t\t\t\t\t// TREATS AS CLUSTER POSITION\n\t\t\t\t\tiRecord.setVersion(((Number) ver).intValue());\n\t\t\t\t} else if (ver instanceof String)\n\t\t\t\t\tiRecord.setVersion(Integer.parseInt((String) ver));\n\t\t\t\telse if (ver.getClass().equals(Object.class))\n\t\t\t\t\tiRecord.setVersion((Integer) ver);\n\t\t\t\telse\n\t\t\t\t\tOLogManager.instance().warn(OObjectSerializerHelper.class,\n\t\t\t\t\t\t\t\"@Version field has been declared as %s while the supported are: Number, String, Object\", ver.getClass());\n\t\t\t}\n\t\t}\n\n\t\tif (db.isMVCC() && !versionConfigured && db.getTransaction() instanceof OTransactionOptimistic)\n\t\t\tthrow new OTransactionException(\n\t\t\t\t\t\"Cannot involve an object of class '\"\n\t\t\t\t\t\t\t+ pojoClass\n\t\t\t\t\t\t\t+ \"' in an Optimistic Transaction commit because it does not define @Version or @OVersion and therefore cannot handle MVCC\");\n\n\t\tString fieldName;\n\t\tObject fieldValue;\n\n\t\t// CALL BEFORE MARSHALLING\n\t\tinvokeCallback(pojoClass, iPojo, iRecord, OBeforeSerialization.class);\n\n\t\tClass<?> currentClass = pojoClass;\n\n\t\twhile (!currentClass.equals(Object.class) && classes.contains(pojoClass)) {\n\t\t\tfor (Field p : currentClass.getDeclaredFields()) {\n\t\t\t\tif (Modifier.isStatic(p.getModifiers()) || Modifier.isNative(p.getModifiers()) || Modifier.isTransient(p.getModifiers()))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfieldName = p.getName();\n\n\t\t\t\tList<String> classTransientFields = transientFields.get(pojoClass);\n\n\t\t\t\tif ((idField != null && fieldName.equals(idField.getName()) || (vField != null && fieldName.equals(vField.getName())) || (classTransientFields != null && classTransientFields\n\t\t\t\t\t\t.contains(fieldName))))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfieldValue = getFieldValue(p, iPojo);\n\t\t\t\tif (isSerializedType(p))\n\t\t\t\t\tfieldValue = serializeFieldValue(p.getType(), fieldValue);\n\n\t\t\t\tschemaProperty = schemaClass != null ? schemaClass.getProperty(fieldName) : null;\n\n\t\t\t\tif (fieldValue != null) {\n\t\t\t\t\tif (isEmbeddedObject(p)) {\n\t\t\t\t\t\t// AUTO CREATE SCHEMA PROPERTY\n\t\t\t\t\t\tif (iRecord.getSchemaClass() == null) {\n\t\t\t\t\t\t\tdb.getMetadata().getSchema().createClass(iPojo.getClass());\n\t\t\t\t\t\t\tiRecord.setClassNameIfExists(iPojo.getClass().getSimpleName());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (schemaProperty == null) {\n\t\t\t\t\t\t\tOType t = OType.getTypeByClass(fieldValue.getClass());\n\t\t\t\t\t\t\tif (t == null)\n\t\t\t\t\t\t\t\tt = OType.EMBEDDED;\n\t\t\t\t\t\t\tschemaProperty = iRecord.getSchemaClass().createProperty(fieldName, t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfieldValue = typeToStream(fieldValue, schemaProperty != null ? schemaProperty.getType() : null, db, iRecord);\n\n\t\t\t\tiRecord.field(fieldName, fieldValue);\n\t\t\t}\n\n\t\t\tcurrentClass = currentClass.getSuperclass();\n\n\t\t\tif (currentClass == null || currentClass.equals(ODocument.class))\n\t\t\t\t// POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER\n\t\t\t\t// ODOCUMENT FIELDS\n\t\t\t\tcurrentClass = Object.class;\n\n\t\t}\n\n\t\t// CALL AFTER MARSHALLING\n\t\tinvokeCallback(pojoClass, iPojo, iRecord, OAfterSerialization.class);\n\n\t\tOObjectSerializationThreadLocal.INSTANCE.get().remove(identityRecord);\n\n\t\tOProfiler.getInstance().stopChrono(\"Object.toStream\", timer);\n\n\t\treturn (T) iProxiedPojo;\n\t}","id":71455,"modified_method":"/**\n\t * Serialize the user POJO to a ORecordDocument instance.\n\t * \n\t * @param iPojo\n\t *          User pojo to serialize\n\t * @throws IllegalAccessException\n\t * @throws IllegalArgumentException\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tprotected static <T> T toStream(final T iPojo, final Proxy iProxiedPojo, ODatabaseObject db) throws IllegalArgumentException,\n\t\t\tIllegalAccessException {\n\n\t\tfinal ODocument iRecord = getDocument(iProxiedPojo);\n\t\tfinal long timer = OProfiler.getInstance().startChrono();\n\n\t\tfinal Integer identityRecord = System.identityHashCode(iPojo);\n\n\t\tif (OObjectSerializationThreadLocal.INSTANCE.get().containsKey(identityRecord))\n\t\t\treturn (T) OObjectSerializationThreadLocal.INSTANCE.get().get(identityRecord);\n\n\t\tOObjectSerializationThreadLocal.INSTANCE.get().put(identityRecord, iProxiedPojo);\n\n\t\tOProperty schemaProperty;\n\n\t\tfinal Class<?> pojoClass = iPojo.getClass();\n\t\tfinal OClass schemaClass = iRecord.getSchemaClass();\n\n\t\t// CHECK FOR ID BINDING\n\t\tfinal Field idField = getIdField(pojoClass);\n\t\tif (idField != null) {\n\n\t\t\tObject id = getFieldValue(idField, iPojo);\n\t\t\tif (id != null) {\n\t\t\t\t// FOUND\n\t\t\t\tif (id instanceof ORecordId) {\n\t\t\t\t\tiRecord.setIdentity((ORecordId) id);\n\t\t\t\t} else if (id instanceof Number) {\n\t\t\t\t\t// TREATS AS CLUSTER POSITION\n\t\t\t\t\t((ORecordId) iRecord.getIdentity()).clusterId = schemaClass.getDefaultClusterId();\n\t\t\t\t\t((ORecordId) iRecord.getIdentity()).clusterPosition = ((Number) id).longValue();\n\t\t\t\t} else if (id instanceof String)\n\t\t\t\t\t((ORecordId) iRecord.getIdentity()).fromString((String) id);\n\t\t\t\telse if (id.getClass().equals(Object.class))\n\t\t\t\t\tiRecord.setIdentity((ORecordId) id);\n\t\t\t\telse\n\t\t\t\t\tOLogManager.instance().warn(OObjectSerializerHelper.class,\n\t\t\t\t\t\t\t\"@Id field has been declared as %s while the supported are: ORID, Number, String, Object\", id.getClass());\n\t\t\t}\n\t\t}\n\n\t\t// CHECK FOR VERSION BINDING\n\t\tfinal Field vField = getVersionField(pojoClass);\n\t\tboolean versionConfigured = false;\n\t\tif (vField != null) {\n\t\t\tversionConfigured = true;\n\t\t\tObject ver = getFieldValue(vField, iPojo);\n\t\t\tif (ver != null) {\n\t\t\t\t// FOUND\n\t\t\t\tif (ver instanceof Number) {\n\t\t\t\t\t// TREATS AS CLUSTER POSITION\n\t\t\t\t\tiRecord.setVersion(((Number) ver).intValue());\n\t\t\t\t} else if (ver instanceof String)\n\t\t\t\t\tiRecord.setVersion(Integer.parseInt((String) ver));\n\t\t\t\telse if (ver.getClass().equals(Object.class))\n\t\t\t\t\tiRecord.setVersion((Integer) ver);\n\t\t\t\telse\n\t\t\t\t\tOLogManager.instance().warn(OObjectSerializerHelper.class,\n\t\t\t\t\t\t\t\"@Version field has been declared as %s while the supported are: Number, String, Object\", ver.getClass());\n\t\t\t}\n\t\t}\n\n\t\tif (db.isMVCC() && !versionConfigured && db.getTransaction() instanceof OTransactionOptimistic)\n\t\t\tthrow new OTransactionException(\n\t\t\t\t\t\"Cannot involve an object of class '\"\n\t\t\t\t\t\t\t+ pojoClass\n\t\t\t\t\t\t\t+ \"' in an Optimistic Transaction commit because it does not define @Version or @OVersion and therefore cannot handle MVCC\");\n\n\t\tString fieldName;\n\t\tObject fieldValue;\n\n\t\t// CALL BEFORE MARSHALLING\n\t\tinvokeCallback(pojoClass, iPojo, iRecord, OBeforeSerialization.class);\n\n\t\tClass<?> currentClass = pojoClass;\n\n\t\twhile (!currentClass.equals(Object.class) && classes.contains(pojoClass)) {\n\t\t\tfor (Field p : currentClass.getDeclaredFields()) {\n\t\t\t\tif (Modifier.isStatic(p.getModifiers()) || Modifier.isNative(p.getModifiers()) || Modifier.isTransient(p.getModifiers()))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfieldName = p.getName();\n\n\t\t\t\tList<String> classTransientFields = transientFields.get(pojoClass);\n\n\t\t\t\tif ((idField != null && fieldName.equals(idField.getName()) || (vField != null && fieldName.equals(vField.getName())) || (classTransientFields != null && classTransientFields\n\t\t\t\t\t\t.contains(fieldName))))\n\t\t\t\t\tcontinue;\n\n\t\t\t\tfieldValue = getFieldValue(p, iPojo);\n\t\t\t\tif (isSerializedType(p))\n\t\t\t\t\tfieldValue = serializeFieldValue(p.getType(), fieldValue);\n\n\t\t\t\tschemaProperty = schemaClass != null ? schemaClass.getProperty(fieldName) : null;\n\t\t\t\tOType fieldType = schemaProperty != null ? schemaProperty.getType() : getTypeByClass(currentClass, fieldName);\n\n\t\t\t\tif (fieldValue != null) {\n\t\t\t\t\tif (isEmbeddedObject(p)) {\n\t\t\t\t\t\t// AUTO CREATE SCHEMA PROPERTY\n\t\t\t\t\t\tif (iRecord.getSchemaClass() == null) {\n\t\t\t\t\t\t\tdb.getMetadata().getSchema().createClass(iPojo.getClass());\n\t\t\t\t\t\t\tiRecord.setClassNameIfExists(iPojo.getClass().getSimpleName());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (schemaProperty == null) {\n\t\t\t\t\t\t\tOType t = OType.getTypeByClass(fieldValue.getClass());\n\t\t\t\t\t\t\tif (t == null)\n\t\t\t\t\t\t\t\tt = OType.EMBEDDED;\n\t\t\t\t\t\t\tschemaProperty = iRecord.getSchemaClass().createProperty(fieldName, t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfieldValue = typeToStream(fieldValue, fieldType, db, iRecord);\n\n\t\t\t\tiRecord.field(fieldName, fieldValue, fieldType);\n\t\t\t}\n\n\t\t\tcurrentClass = currentClass.getSuperclass();\n\n\t\t\tif (currentClass == null || currentClass.equals(ODocument.class))\n\t\t\t\t// POJO EXTENDS ODOCUMENT: SPECIAL CASE: AVOID TO CONSIDER\n\t\t\t\t// ODOCUMENT FIELDS\n\t\t\t\tcurrentClass = Object.class;\n\n\t\t}\n\n\t\t// CALL AFTER MARSHALLING\n\t\tinvokeCallback(pojoClass, iPojo, iRecord, OAfterSerialization.class);\n\n\t\tOObjectSerializationThreadLocal.INSTANCE.get().remove(identityRecord);\n\n\t\tOProfiler.getInstance().stopChrono(\"Object.toStream\", timer);\n\n\t\treturn (T) iProxiedPojo;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public static Object typeToStream(Object iFieldValue, OType iType, final ODatabaseObject db, final ODocument iRecord) {\n\t\tif (iFieldValue == null)\n\t\t\treturn null;\n\t\tif (iFieldValue instanceof Proxy)\n\t\t\treturn getDocument((Proxy) iFieldValue);\n\n\t\tif (!OType.isSimpleType(iFieldValue) || iFieldValue.getClass().isArray()) {\n\t\t\tClass<?> fieldClass = iFieldValue.getClass();\n\n\t\t\tif (fieldClass.isArray()) {\n\t\t\t\t// ARRAY\n\t\t\t\tfinal int arrayLength = Array.getLength(iFieldValue);\n\t\t\t\tfinal List<Object> arrayList = new ArrayList<Object>();\n\t\t\t\tfor (int i = 0; i < arrayLength; i++)\n\t\t\t\t\tarrayList.add(Array.get(iFieldValue, i));\n\n\t\t\t\tiFieldValue = multiValueToStream(arrayList, iType, db, iRecord);\n\t\t\t} else if (Collection.class.isAssignableFrom(fieldClass)) {\n\t\t\t\t// COLLECTION (LIST OR SET)\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, db, iRecord);\n\t\t\t} else if (Map.class.isAssignableFrom(fieldClass)) {\n\t\t\t\t// MAP\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, db, iRecord);\n\t\t\t} else if (fieldClass.isEnum()) {\n\t\t\t\t// ENUM\n\t\t\t\tiFieldValue = ((Enum<?>) iFieldValue).name();\n\t\t\t} else {\n\t\t\t\t// LINK OR EMBEDDED\n\t\t\t\tfieldClass = db.getEntityManager().getEntityClass(fieldClass.getSimpleName());\n\t\t\t\tif (fieldClass != null) {\n\t\t\t\t\t// RECOGNIZED TYPE, SERIALIZE IT\n\t\t\t\t\tiFieldValue = getDocument((Proxy) serializeObject(iFieldValue, db));\n\n\t\t\t\t} else {\n\t\t\t\t\tfinal Object result = serializeFieldValue(null, iFieldValue);\n\t\t\t\t\tif (iFieldValue == result)\n\t\t\t\t\t\tthrow new OSerializationException(\"Linked type [\" + iFieldValue.getClass() + \":\" + iFieldValue\n\t\t\t\t\t\t\t\t+ \"] cannot be serialized because is not part of registered entities. To fix this error register this class\");\n\n\t\t\t\t\tiFieldValue = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn iFieldValue;\n\t}","id":71456,"modified_method":"public static Object typeToStream(Object iFieldValue, OType iType, final ODatabaseObject db, final ODocument iRecord) {\n\t\tif (iFieldValue == null)\n\t\t\treturn null;\n\t\tif (iFieldValue instanceof Proxy)\n\t\t\treturn getDocument((Proxy) iFieldValue);\n\n\t\tif (!OType.isSimpleType(iFieldValue) || iFieldValue.getClass().isArray()) {\n\t\t\tClass<?> fieldClass = iFieldValue.getClass();\n\n\t\t\tif (fieldClass.isArray()) {\n\t\t\t\tif (iType.equals(OType.BINARY))\n\t\t\t\t\treturn iFieldValue;\n\t\t\t\t// ARRAY\n\t\t\t\tfinal int arrayLength = Array.getLength(iFieldValue);\n\t\t\t\tfinal List<Object> arrayList = new ArrayList<Object>();\n\t\t\t\tfor (int i = 0; i < arrayLength; i++)\n\t\t\t\t\tarrayList.add(Array.get(iFieldValue, i));\n\n\t\t\t\tiFieldValue = multiValueToStream(arrayList, iType, db, iRecord);\n\t\t\t} else if (Collection.class.isAssignableFrom(fieldClass)) {\n\t\t\t\t// COLLECTION (LIST OR SET)\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, db, iRecord);\n\t\t\t} else if (Map.class.isAssignableFrom(fieldClass)) {\n\t\t\t\t// MAP\n\t\t\t\tiFieldValue = multiValueToStream(iFieldValue, iType, db, iRecord);\n\t\t\t} else if (fieldClass.isEnum()) {\n\t\t\t\t// ENUM\n\t\t\t\tiFieldValue = ((Enum<?>) iFieldValue).name();\n\t\t\t} else {\n\t\t\t\t// LINK OR EMBEDDED\n\t\t\t\tfieldClass = db.getEntityManager().getEntityClass(fieldClass.getSimpleName());\n\t\t\t\tif (fieldClass != null) {\n\t\t\t\t\t// RECOGNIZED TYPE, SERIALIZE IT\n\t\t\t\t\tiFieldValue = getDocument((Proxy) serializeObject(iFieldValue, db));\n\n\t\t\t\t} else {\n\t\t\t\t\tfinal Object result = serializeFieldValue(null, iFieldValue);\n\t\t\t\t\tif (iFieldValue == result)\n\t\t\t\t\t\tthrow new OSerializationException(\"Linked type [\" + iFieldValue.getClass() + \":\" + iFieldValue\n\t\t\t\t\t\t\t\t+ \"] cannot be serialized because is not part of registered entities. To fix this error register this class\");\n\n\t\t\t\t\tiFieldValue = result;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn iFieldValue;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n\t * Method that detaches all fields contained in the document to the given object\n\t * \n\t * @param self\n\t *          :- The object containing this handler instance\n\t * @throws InvocationTargetException\n\t * @throws IllegalAccessException\n\t * @throws NoSuchMethodException\n\t */\n\tpublic void detach(Object self) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tfor (String fieldName : doc.fieldNames()) {\n\t\t\tObject value = getValue(self, fieldName, false, null);\n\t\t\tif (value instanceof OLazyObjectMultivalueElement)\n\t\t\t\t((OLazyObjectMultivalueElement) value).detach();\n\t\t\tOObjectEntitySerializer.setFieldValue(getField(fieldName, self.getClass()), self, value);\n\t\t}\n\t\tOObjectEntitySerializer.setIdField(self.getClass(), self, doc.getIdentity());\n\t\tOObjectEntitySerializer.setVersionField(self.getClass(), self, doc.getVersion());\n\t}","id":71457,"modified_method":"/**\n\t * Method that detaches all fields contained in the document to the given object\n\t * \n\t * @param self\n\t *          :- The object containing this handler instance\n\t * @throws InvocationTargetException\n\t * @throws IllegalAccessException\n\t * @throws NoSuchMethodException\n\t */\n\tpublic void detach(Object self) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tfor (String fieldName : doc.fieldNames()) {\n\t\t\tObject value = getValue(self, fieldName, false, null);\n\t\t\tif (value instanceof OLazyObjectMultivalueElement)\n\t\t\t\t((OLazyObjectMultivalueElement) value).detach();\n\t\t\tOObjectEntitySerializer.setFieldValue(OObjectEntitySerializer.getField(fieldName, self.getClass()), self, value);\n\t\t}\n\t\tOObjectEntitySerializer.setIdField(self.getClass(), self, doc.getIdentity());\n\t\tOObjectEntitySerializer.setVersionField(self.getClass(), self, doc.getVersion());\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageEnumCollections(Object self, final String fieldName, final Class<?> enumClass, Object value)\n\t\t\tthrows NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tif (value instanceof Collection<?>) {\n\t\t\tif (value instanceof List) {\n\t\t\t\tList<Object> docList = doc.field(fieldName);\n\t\t\t\tif (docList == null) {\n\t\t\t\t\tdocList = new ArrayList<Object>();\n\t\t\t\t\tdoc.field(fieldName, docList);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectEnumLazyList(enumClass, doc, docList, (List<?>) value);\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tSet<Object> docSet = doc.field(fieldName, OType.LINKSET);\n\t\t\t\tif (docSet == null) {\n\t\t\t\t\tdocSet = new HashSet<Object>();\n\t\t\t\t\tdoc.field(fieldName, docSet);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectEnumLazySet(enumClass, doc, docSet, (Set<?>) value);\n\t\t\t}\n\t\t} else if (value instanceof Map<?, ?>) {\n\t\t\tMap<Object, Object> docMap = doc.field(fieldName);\n\t\t\tif (docMap == null) {\n\t\t\t\tdocMap = new HashMap<Object, Object>();\n\t\t\t\tdoc.field(fieldName, docMap);\n\t\t\t}\n\t\t\tvalue = new OObjectEnumLazyMap(enumClass, doc, docMap, (Map<?, ?>) value);\n\t\t} else if (value.getClass().isArray()) {\n\t\t\tvalue = manageArraySave(fieldName, (Object[]) value);\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(getField(fieldName, self.getClass()), self, value);\n\t\treturn value;\n\t}","id":71458,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageEnumCollections(Object self, final String fieldName, final Class<?> enumClass, Object value)\n\t\t\tthrows NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tif (value instanceof Collection<?>) {\n\t\t\tif (value instanceof List) {\n\t\t\t\tList<Object> docList = doc.field(fieldName, OType.EMBEDDEDLIST);\n\t\t\t\tif (docList == null) {\n\t\t\t\t\tdocList = new ArrayList<Object>();\n\t\t\t\t\tdoc.field(fieldName, docList, OType.EMBEDDEDLIST);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectEnumLazyList(enumClass, doc, docList, (List<?>) value);\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tSet<Object> docSet = doc.field(fieldName, OType.EMBEDDEDSET);\n\t\t\t\tif (docSet == null) {\n\t\t\t\t\tdocSet = new HashSet<Object>();\n\t\t\t\t\tdoc.field(fieldName, docSet, OType.EMBEDDEDSET);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectEnumLazySet(enumClass, doc, docSet, (Set<?>) value);\n\t\t\t}\n\t\t} else if (value instanceof Map<?, ?>) {\n\t\t\tMap<Object, Object> docMap = doc.field(fieldName, OType.EMBEDDEDMAP);\n\t\t\tif (docMap == null) {\n\t\t\t\tdocMap = new HashMap<Object, Object>();\n\t\t\t\tdoc.field(fieldName, docMap, OType.EMBEDDEDMAP);\n\t\t\t}\n\t\t\tvalue = new OObjectEnumLazyMap(enumClass, doc, docMap, (Map<?, ?>) value);\n\t\t} else if (value.getClass().isArray()) {\n\t\t\tvalue = manageArraySave(fieldName, (Object[]) value);\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(OObjectEntitySerializer.getField(fieldName, self.getClass()), self, value);\n\t\treturn value;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected Object manageObjectCollections(Object self, final String fieldName, Object value) throws NoSuchMethodException,\n\t\t\tIllegalAccessException, InvocationTargetException {\n\t\tboolean customSerialization = false;\n\t\tField f = getField(fieldName, self.getClass());\n\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\tcustomSerialization = true;\n\t\t}\n\t\tif (value instanceof Collection<?>) {\n\t\t\tvalue = manageCollectionSave(f, (Collection<?>) value, customSerialization);\n\t\t} else if (value instanceof Map<?, ?>) {\n\t\t\tvalue = manageMapSave(f, (Map<?, ?>) value, customSerialization);\n\t\t} else if (value.getClass().isArray()) {\n\t\t\tvalue = manageArraySave(fieldName, (Object[]) value);\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(getField(fieldName, self.getClass()), self, value);\n\t\treturn value;\n\t}","id":71459,"modified_method":"protected Object manageObjectCollections(Object self, final String fieldName, Object value) throws NoSuchMethodException,\n\t\t\tIllegalAccessException, InvocationTargetException {\n\t\tboolean customSerialization = false;\n\t\tField f = OObjectEntitySerializer.getField(fieldName, self.getClass());\n\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\tcustomSerialization = true;\n\t\t}\n\t\tif (value instanceof Collection<?>) {\n\t\t\tvalue = manageCollectionSave(f, (Collection<?>) value, customSerialization);\n\t\t} else if (value instanceof Map<?, ?>) {\n\t\t\tvalue = manageMapSave(f, (Map<?, ?>) value, customSerialization);\n\t\t} else if (value.getClass().isArray()) {\n\t\t\tvalue = manageArraySave(fieldName, (Object[]) value);\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(OObjectEntitySerializer.getField(fieldName, self.getClass()), self, value);\n\t\treturn value;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageSerializedCollections(Object self, final String fieldName, Object value) throws NoSuchMethodException,\n\t\t\tIllegalAccessException, InvocationTargetException {\n\t\tif (value instanceof Collection<?>) {\n\t\t\tif (value instanceof List) {\n\t\t\t\tList<Object> docList = doc.field(fieldName);\n\t\t\t\tif (docList == null) {\n\t\t\t\t\tdocList = new ArrayList<Object>();\n\t\t\t\t\tdoc.field(fieldName, docList);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectCustomSerializerList(OObjectEntitySerializer.getSerializedType(getField(fieldName, self.getClass())),\n\t\t\t\t\t\tdoc, docList, (List<?>) value);\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tSet<Object> docSet = doc.field(fieldName, OType.LINKSET);\n\t\t\t\tif (docSet == null) {\n\t\t\t\t\tdocSet = new HashSet<Object>();\n\t\t\t\t\tdoc.field(fieldName, docSet);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectCustomSerializerSet(OObjectEntitySerializer.getSerializedType(getField(fieldName, self.getClass())),\n\t\t\t\t\t\tdoc, docSet, (Set<?>) value);\n\t\t\t}\n\t\t} else if (value instanceof Map<?, ?>) {\n\t\t\tMap<Object, Object> docMap = doc.field(fieldName);\n\t\t\tif (docMap == null) {\n\t\t\t\tdocMap = new HashMap<Object, Object>();\n\t\t\t\tdoc.field(fieldName, docMap);\n\t\t\t}\n\t\t\tvalue = new OObjectCustomSerializerMap(OObjectEntitySerializer.getSerializedType(getField(fieldName, self.getClass())), doc,\n\t\t\t\t\tdocMap, (Map<?, ?>) value);\n\t\t} else if (value.getClass().isArray()) {\n\t\t\tvalue = manageArraySave(fieldName, (Object[]) value);\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(getField(fieldName, self.getClass()), self, value);\n\t\treturn value;\n\t}","id":71460,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageSerializedCollections(Object self, final String fieldName, Object value) throws NoSuchMethodException,\n\t\t\tIllegalAccessException, InvocationTargetException {\n\t\tif (value instanceof Collection<?>) {\n\t\t\tif (value instanceof List) {\n\t\t\t\tList<Object> docList = doc.field(fieldName, OType.EMBEDDEDLIST);\n\t\t\t\tif (docList == null) {\n\t\t\t\t\tdocList = new ArrayList<Object>();\n\t\t\t\t\tdoc.field(fieldName, docList, OType.EMBEDDEDLIST);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectCustomSerializerList(OObjectEntitySerializer.getSerializedType(OObjectEntitySerializer.getField(\n\t\t\t\t\t\tfieldName, self.getClass())), doc, docList, (List<?>) value);\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tSet<Object> docSet = doc.field(fieldName, OType.EMBEDDEDSET);\n\t\t\t\tif (docSet == null) {\n\t\t\t\t\tdocSet = new HashSet<Object>();\n\t\t\t\t\tdoc.field(fieldName, docSet, OType.EMBEDDEDSET);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectCustomSerializerSet(OObjectEntitySerializer.getSerializedType(OObjectEntitySerializer.getField(\n\t\t\t\t\t\tfieldName, self.getClass())), doc, docSet, (Set<?>) value);\n\t\t\t}\n\t\t} else if (value instanceof Map<?, ?>) {\n\t\t\tMap<Object, Object> docMap = doc.field(fieldName, OType.EMBEDDEDMAP);\n\t\t\tif (docMap == null) {\n\t\t\t\tdocMap = new HashMap<Object, Object>();\n\t\t\t\tdoc.field(fieldName, docMap, OType.EMBEDDEDMAP);\n\t\t\t}\n\t\t\tvalue = new OObjectCustomSerializerMap(OObjectEntitySerializer.getSerializedType(OObjectEntitySerializer.getField(fieldName,\n\t\t\t\t\tself.getClass())), doc, docMap, (Map<?, ?>) value);\n\t\t} else if (value.getClass().isArray()) {\n\t\t\tvalue = manageArraySave(fieldName, (Object[]) value);\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(OObjectEntitySerializer.getField(fieldName, self.getClass()), self, value);\n\t\treturn value;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageCollectionSave(Field f, Collection<?> value, boolean customSerialization) {\n\t\tfinal Class genericType = OReflectionHelper.getGenericMultivalueType(f);\n\t\tif (customSerialization) {\n\t\t\tif (value instanceof List<?>) {\n\t\t\t\tList<Object> list = new ArrayList<Object>();\n\t\t\t\tdoc.field(f.getName(), list);\n\t\t\t\tvalue = new OObjectCustomSerializerList(OObjectEntitySerializer.getSerializedType(f), doc, new ArrayList<Object>(),\n\t\t\t\t\t\t(List<Object>) value);\n\t\t\t} else {\n\t\t\t\tSet<Object> set = new HashSet<Object>();\n\t\t\t\tdoc.field(f.getName(), set);\n\t\t\t\tvalue = new OObjectCustomSerializerSet(OObjectEntitySerializer.getSerializedType(f), doc, set, (Set<Object>) value);\n\t\t\t}\n\t\t} else if (genericType.isEnum()) {\n\t\t\tif (value instanceof List<?>) {\n\t\t\t\tList<Object> list = new ArrayList<Object>();\n\t\t\t\tdoc.field(f.getName(), list);\n\t\t\t\tvalue = new OObjectEnumLazyList(genericType, doc, list, (List<Object>) value);\n\t\t\t} else {\n\t\t\t\tSet<Object> set = new HashSet<Object>();\n\t\t\t\tdoc.field(f.getName(), set);\n\t\t\t\tvalue = new OObjectEnumLazySet(genericType, doc, set, (Set<Object>) value);\n\t\t\t}\n\t\t} else if (!(value instanceof OLazyObjectMultivalueElement)) {\n\t\t\tif (value instanceof List) {\n\t\t\t\tList<OIdentifiable> docList = doc.field(f.getName());\n\t\t\t\tif (docList == null) {\n\t\t\t\t\tdocList = new ORecordLazyList(doc);\n\t\t\t\t\tdoc.field(f.getName(), docList);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectLazyList(doc, docList, value);\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tSet<OIdentifiable> docSet = doc.field(f.getName(), OType.LINKSET);\n\t\t\t\tif (docSet == null) {\n\t\t\t\t\tdocSet = new ORecordLazySet(doc);\n\t\t\t\t\tdoc.field(f.getName(), docSet);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectLazySet(doc, docSet, (Set<?>) value);\n\t\t\t}\n\t\t}\n\t\tif (!((ODatabaseObject) ODatabaseRecordThreadLocal.INSTANCE.get().getDatabaseOwner()).isLazyLoading())\n\t\t\t((OLazyObjectMultivalueElement) value).detach();\n\t\treturn value;\n\t}","id":71461,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageCollectionSave(Field f, Collection<?> value, boolean customSerialization) {\n\t\tfinal Class genericType = OReflectionHelper.getGenericMultivalueType(f);\n\t\tif (customSerialization) {\n\t\t\tif (value instanceof List<?>) {\n\t\t\t\tList<Object> list = new ArrayList<Object>();\n\t\t\t\tdoc.field(f.getName(), list, OType.EMBEDDEDLIST);\n\t\t\t\tvalue = new OObjectCustomSerializerList(OObjectEntitySerializer.getSerializedType(f), doc, new ArrayList<Object>(),\n\t\t\t\t\t\t(List<Object>) value);\n\t\t\t} else {\n\t\t\t\tSet<Object> set = new HashSet<Object>();\n\t\t\t\tdoc.field(f.getName(), set, OType.EMBEDDEDSET);\n\t\t\t\tvalue = new OObjectCustomSerializerSet(OObjectEntitySerializer.getSerializedType(f), doc, set, (Set<Object>) value);\n\t\t\t}\n\t\t} else if (genericType.isEnum()) {\n\t\t\tif (value instanceof List<?>) {\n\t\t\t\tList<Object> list = new ArrayList<Object>();\n\t\t\t\tdoc.field(f.getName(), list, OType.EMBEDDEDLIST);\n\t\t\t\tvalue = new OObjectEnumLazyList(genericType, doc, list, (List<Object>) value);\n\t\t\t} else {\n\t\t\t\tSet<Object> set = new HashSet<Object>();\n\t\t\t\tdoc.field(f.getName(), set, OType.EMBEDDEDSET);\n\t\t\t\tvalue = new OObjectEnumLazySet(genericType, doc, set, (Set<Object>) value);\n\t\t\t}\n\t\t} else if (!(value instanceof OLazyObjectMultivalueElement)) {\n\t\t\tif (value instanceof List) {\n\t\t\t\tList<OIdentifiable> docList = doc.field(f.getName(), OType.LINKLIST);\n\t\t\t\tif (docList == null) {\n\t\t\t\t\tdocList = new ORecordLazyList(doc);\n\t\t\t\t\tdoc.field(f.getName(), docList, OType.LINKLIST);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectLazyList(doc, docList, value);\n\t\t\t} else if (value instanceof Set) {\n\t\t\t\tSet<OIdentifiable> docSet = doc.field(f.getName(), OType.LINKSET);\n\t\t\t\tif (docSet == null) {\n\t\t\t\t\tdocSet = new ORecordLazySet(doc);\n\t\t\t\t\tdoc.field(f.getName(), docSet, OType.LINKSET);\n\t\t\t\t}\n\t\t\t\tvalue = new OObjectLazySet(doc, docSet, (Set<?>) value);\n\t\t\t}\n\t\t}\n\t\tif (!((ODatabaseObject) ODatabaseRecordThreadLocal.INSTANCE.get().getDatabaseOwner()).isLazyLoading())\n\t\t\t((OLazyObjectMultivalueElement) value).detach();\n\t\treturn value;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprotected Object lazyLoadField(Object self, final String fieldName, Object docValue, Object currentValue)\n\t\t\tthrows NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tboolean customSerialization = false;\n\t\tField f = getField(fieldName, self.getClass());\n\t\tif (f == null)\n\t\t\treturn currentValue;\n\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\tcustomSerialization = true;\n\t\t}\n\t\tif (docValue instanceof OIdentifiable) {\n\t\t\tif (OIdentifiable.class.isAssignableFrom(f.getType())) {\n\t\t\t\tif (ORecordAbstract.class.isAssignableFrom(f.getType())) {\n\t\t\t\t\tORecordAbstract record = ((OIdentifiable) docValue).getRecord();\n\t\t\t\t\tOObjectEntitySerializer.setFieldValue(f, self, record);\n\t\t\t\t\treturn record;\n\t\t\t\t} else {\n\t\t\t\t\tOObjectEntitySerializer.setFieldValue(f, self, docValue);\n\t\t\t\t\treturn docValue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdocValue = convertDocumentToObject((ODocument) ((OIdentifiable) docValue).getRecord());\n\t\t\t}\n\t\t} else if (docValue instanceof Collection<?>) {\n\t\t\tdocValue = manageCollectionLoad(f, self, docValue, customSerialization);\n\t\t} else if (docValue instanceof Map<?, ?>) {\n\t\t\tdocValue = manageMapLoad(f, self, docValue, customSerialization);\n\t\t} else if (docValue.getClass().isArray() && !docValue.getClass().getComponentType().isPrimitive()) {\n\t\t\tdocValue = manageArrayLoad(docValue);\n\t\t} else if (customSerialization) {\n\t\t\tdocValue = OObjectEntitySerializer.deserializeFieldValue(getField(fieldName, self.getClass()).getType(), docValue);\n\t\t} else {\n\t\t\tif (f.getType().isEnum()) {\n\t\t\t\tif (docValue instanceof Number)\n\t\t\t\t\tdocValue = ((Class<Enum>) f.getType()).getEnumConstants()[((Number) docValue).intValue()];\n\t\t\t\telse\n\t\t\t\t\tdocValue = Enum.valueOf((Class<Enum>) f.getType(), docValue.toString());\n\t\t\t}\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(f, self, docValue);\n\t\treturn docValue;\n\t}","id":71462,"modified_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprotected Object lazyLoadField(Object self, final String fieldName, Object docValue, Object currentValue)\n\t\t\tthrows NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tboolean customSerialization = false;\n\t\tField f = OObjectEntitySerializer.getField(fieldName, self.getClass());\n\t\tif (f == null)\n\t\t\treturn currentValue;\n\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\tcustomSerialization = true;\n\t\t}\n\t\tif (docValue instanceof OIdentifiable) {\n\t\t\tif (OIdentifiable.class.isAssignableFrom(f.getType())) {\n\t\t\t\tif (ORecordAbstract.class.isAssignableFrom(f.getType())) {\n\t\t\t\t\tORecordAbstract record = ((OIdentifiable) docValue).getRecord();\n\t\t\t\t\tOObjectEntitySerializer.setFieldValue(f, self, record);\n\t\t\t\t\treturn record;\n\t\t\t\t} else {\n\t\t\t\t\tOObjectEntitySerializer.setFieldValue(f, self, docValue);\n\t\t\t\t\treturn docValue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdocValue = convertDocumentToObject((ODocument) ((OIdentifiable) docValue).getRecord());\n\t\t\t}\n\t\t} else if (docValue instanceof Collection<?>) {\n\t\t\tdocValue = manageCollectionLoad(f, self, docValue, customSerialization);\n\t\t} else if (docValue instanceof Map<?, ?>) {\n\t\t\tdocValue = manageMapLoad(f, self, docValue, customSerialization);\n\t\t} else if (docValue.getClass().isArray() && !docValue.getClass().getComponentType().isPrimitive()) {\n\t\t\tdocValue = manageArrayLoad(docValue);\n\t\t} else if (customSerialization) {\n\t\t\tdocValue = OObjectEntitySerializer.deserializeFieldValue(OObjectEntitySerializer.getField(fieldName, self.getClass())\n\t\t\t\t\t.getType(), docValue);\n\t\t} else {\n\t\t\tif (f.getType().isEnum()) {\n\t\t\t\tif (docValue instanceof Number)\n\t\t\t\t\tdocValue = ((Class<Enum>) f.getType()).getEnumConstants()[((Number) docValue).intValue()];\n\t\t\t\telse\n\t\t\t\t\tdocValue = Enum.valueOf((Class<Enum>) f.getType(), docValue.toString());\n\t\t\t}\n\t\t}\n\t\tOObjectEntitySerializer.setFieldValue(f, self, docValue);\n\t\treturn docValue;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected Object setValue(Object self, final String fieldName, Object valueToSet) {\n\t\tif (valueToSet == null) {\n\t\t\tdoc.field(fieldName, valueToSet);\n\t\t} else if (!valueToSet.getClass().isAnonymousClass()) {\n\t\t\tif (valueToSet instanceof Proxy) {\n\t\t\t\tODocument docToSet = OObjectEntitySerializer.getDocument((Proxy) valueToSet);\n\t\t\t\tif (OObjectEntitySerializer.isEmbeddedField(self.getClass(), fieldName))\n\t\t\t\t\tdocToSet.addOwner(doc);\n\t\t\t\tdoc.field(fieldName, docToSet);\n\t\t\t} else if (valueToSet instanceof OIdentifiable) {\n\t\t\t\tif (valueToSet instanceof ODocument && OObjectEntitySerializer.isEmbeddedField(self.getClass(), fieldName))\n\t\t\t\t\t((ODocument) valueToSet).addOwner(doc);\n\t\t\t\tdoc.field(fieldName, valueToSet);\n\t\t\t} else if (((valueToSet instanceof Collection<?> || valueToSet instanceof Map<?, ?>)) || valueToSet.getClass().isArray()) {\n\t\t\t\tClass<?> genericMultiValueType = OReflectionHelper.getGenericMultivalueType(getField(fieldName, self.getClass()));\n\t\t\t\tif (genericMultiValueType != null && !OReflectionHelper.isJavaType(genericMultiValueType)) {\n\t\t\t\t\tif (!(valueToSet instanceof OLazyObjectMultivalueElement)) {\n\t\t\t\t\t\tif (valueToSet instanceof Collection<?>) {\n\t\t\t\t\t\t\tboolean customSerialization = false;\n\t\t\t\t\t\t\tField f = getField(fieldName, self.getClass());\n\t\t\t\t\t\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\t\t\t\t\t\tcustomSerialization = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalueToSet = manageCollectionSave(f, (Collection<?>) valueToSet, customSerialization);\n\t\t\t\t\t\t} else if (valueToSet instanceof Map<?, ?>) {\n\t\t\t\t\t\t\tboolean customSerialization = false;\n\t\t\t\t\t\t\tField f = getField(fieldName, self.getClass());\n\t\t\t\t\t\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\t\t\t\t\t\tcustomSerialization = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalueToSet = manageMapSave(f, (Map<?, ?>) valueToSet, customSerialization);\n\t\t\t\t\t\t} else if (valueToSet.getClass().isArray()) {\n\t\t\t\t\t\t\tvalueToSet = manageArraySave(fieldName, (Object[]) valueToSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (OObjectEntitySerializer.isToSerialize(valueToSet.getClass())) {\n\t\t\t\t\t\tdoc.field(fieldName,\n\t\t\t\t\t\t\t\tOObjectEntitySerializer.serializeFieldValue(getField(fieldName, self.getClass()).getType(), valueToSet));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (valueToSet.getClass().isArray()) {\n\t\t\t\t\t\t\tOClass schemaClass = doc.getSchemaClass();\n\t\t\t\t\t\t\tOProperty schemaProperty = null;\n\t\t\t\t\t\t\tif (schemaClass != null)\n\t\t\t\t\t\t\t\tschemaProperty = schemaClass.getProperty(fieldName);\n\n\t\t\t\t\t\t\tdoc.field(fieldName, OObjectEntitySerializer.typeToStream(valueToSet,\n\t\t\t\t\t\t\t\t\tschemaProperty != null ? schemaProperty.getType() : null, getDatabase(), doc));\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tdoc.field(fieldName, valueToSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueToSet.getClass().isEnum()) {\n\t\t\t\tdoc.field(fieldName, ((Enum) valueToSet).name());\n\t\t\t} else {\n\t\t\t\tif (OObjectEntitySerializer.isToSerialize(valueToSet.getClass())) {\n\t\t\t\t\tdoc.field(fieldName,\n\t\t\t\t\t\t\tOObjectEntitySerializer.serializeFieldValue(getField(fieldName, self.getClass()).getType(), valueToSet));\n\t\t\t\t} else if (getDatabase().getEntityManager().getEntityClass(valueToSet.getClass().getSimpleName()) != null\n\t\t\t\t\t\t&& !valueToSet.getClass().isEnum()) {\n\t\t\t\t\tvalueToSet = OObjectEntitySerializer.serializeObject(valueToSet, getDatabase());\n\t\t\t\t\tODocument docToSet = OObjectEntitySerializer.getDocument((Proxy) valueToSet);\n\t\t\t\t\tif (OObjectEntitySerializer.isEmbeddedField(self.getClass(), fieldName))\n\t\t\t\t\t\tdocToSet.addOwner(doc);\n\t\t\t\t\tdoc.field(fieldName, docToSet);\n\t\t\t\t} else {\n\t\t\t\t\tdoc.field(fieldName, valueToSet);\n\t\t\t\t}\n\t\t\t}\n\t\t\tloadedFields.put(fieldName, doc.getVersion());\n\t\t} else {\n\t\t\tOLogManager.instance().warn(this,\n\t\t\t\t\t\"Setting property '%s' in proxied class '%s' with an anonymous class '%s'. The document won't have this property.\",\n\t\t\t\t\tfieldName, self.getClass().getName(), valueToSet.getClass().getName());\n\t\t}\n\t\treturn valueToSet;\n\t}","id":71463,"modified_method":"protected Object setValue(Object self, final String fieldName, Object valueToSet) {\n\t\tif (valueToSet == null) {\n\t\t\tdoc.field(fieldName, valueToSet, OObjectEntitySerializer.getTypeByClass(self.getClass(), fieldName));\n\t\t} else if (!valueToSet.getClass().isAnonymousClass()) {\n\t\t\tif (valueToSet instanceof Proxy) {\n\t\t\t\tODocument docToSet = OObjectEntitySerializer.getDocument((Proxy) valueToSet);\n\t\t\t\tif (OObjectEntitySerializer.isEmbeddedField(self.getClass(), fieldName))\n\t\t\t\t\tdocToSet.addOwner(doc);\n\t\t\t\tdoc.field(fieldName, docToSet, OObjectEntitySerializer.getTypeByClass(self.getClass(), fieldName));\n\t\t\t} else if (valueToSet instanceof OIdentifiable) {\n\t\t\t\tif (valueToSet instanceof ODocument && OObjectEntitySerializer.isEmbeddedField(self.getClass(), fieldName))\n\t\t\t\t\t((ODocument) valueToSet).addOwner(doc);\n\t\t\t\tdoc.field(fieldName, valueToSet);\n\t\t\t} else if (((valueToSet instanceof Collection<?> || valueToSet instanceof Map<?, ?>)) || valueToSet.getClass().isArray()) {\n\t\t\t\tClass<?> genericMultiValueType = OReflectionHelper.getGenericMultivalueType(OObjectEntitySerializer.getField(fieldName,\n\t\t\t\t\t\tself.getClass()));\n\t\t\t\tif (genericMultiValueType != null && !OReflectionHelper.isJavaType(genericMultiValueType)) {\n\t\t\t\t\tif (!(valueToSet instanceof OLazyObjectMultivalueElement)) {\n\t\t\t\t\t\tif (valueToSet instanceof Collection<?>) {\n\t\t\t\t\t\t\tboolean customSerialization = false;\n\t\t\t\t\t\t\tField f = OObjectEntitySerializer.getField(fieldName, self.getClass());\n\t\t\t\t\t\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\t\t\t\t\t\tcustomSerialization = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalueToSet = manageCollectionSave(f, (Collection<?>) valueToSet, customSerialization);\n\t\t\t\t\t\t} else if (valueToSet instanceof Map<?, ?>) {\n\t\t\t\t\t\t\tboolean customSerialization = false;\n\t\t\t\t\t\t\tField f = OObjectEntitySerializer.getField(fieldName, self.getClass());\n\t\t\t\t\t\t\tif (OObjectEntitySerializer.isSerializedType(f)) {\n\t\t\t\t\t\t\t\tcustomSerialization = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvalueToSet = manageMapSave(f, (Map<?, ?>) valueToSet, customSerialization);\n\t\t\t\t\t\t} else if (valueToSet.getClass().isArray()) {\n\t\t\t\t\t\t\tvalueToSet = manageArraySave(fieldName, (Object[]) valueToSet);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (OObjectEntitySerializer.isToSerialize(valueToSet.getClass())) {\n\t\t\t\t\t\tdoc.field(fieldName, OObjectEntitySerializer.serializeFieldValue(\n\t\t\t\t\t\t\t\tOObjectEntitySerializer.getField(fieldName, self.getClass()).getType(), valueToSet));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (valueToSet.getClass().isArray()) {\n\t\t\t\t\t\t\tOClass schemaClass = doc.getSchemaClass();\n\t\t\t\t\t\t\tOProperty schemaProperty = null;\n\t\t\t\t\t\t\tif (schemaClass != null)\n\t\t\t\t\t\t\t\tschemaProperty = schemaClass.getProperty(fieldName);\n\n\t\t\t\t\t\t\tdoc.field(fieldName, OObjectEntitySerializer.typeToStream(valueToSet,\n\t\t\t\t\t\t\t\t\tschemaProperty != null ? schemaProperty.getType() : null, getDatabase(), doc));\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tdoc.field(fieldName, valueToSet, OObjectEntitySerializer.getTypeByClass(self.getClass(), fieldName));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (valueToSet.getClass().isEnum()) {\n\t\t\t\tdoc.field(fieldName, ((Enum) valueToSet).name());\n\t\t\t} else {\n\t\t\t\tif (OObjectEntitySerializer.isToSerialize(valueToSet.getClass())) {\n\t\t\t\t\tdoc.field(fieldName, OObjectEntitySerializer.serializeFieldValue(\n\t\t\t\t\t\t\tOObjectEntitySerializer.getField(fieldName, self.getClass()).getType(), valueToSet));\n\t\t\t\t} else if (getDatabase().getEntityManager().getEntityClass(valueToSet.getClass().getSimpleName()) != null\n\t\t\t\t\t\t&& !valueToSet.getClass().isEnum()) {\n\t\t\t\t\tvalueToSet = OObjectEntitySerializer.serializeObject(valueToSet, getDatabase());\n\t\t\t\t\tODocument docToSet = OObjectEntitySerializer.getDocument((Proxy) valueToSet);\n\t\t\t\t\tif (OObjectEntitySerializer.isEmbeddedField(self.getClass(), fieldName))\n\t\t\t\t\t\tdocToSet.addOwner(doc);\n\t\t\t\t\tdoc.field(fieldName, docToSet);\n\t\t\t\t} else {\n\t\t\t\t\tdoc.field(fieldName, valueToSet, OObjectEntitySerializer.getTypeByClass(self.getClass(), fieldName));\n\t\t\t\t}\n\t\t\t}\n\t\t\tloadedFields.put(fieldName, doc.getVersion());\n\t\t} else {\n\t\t\tOLogManager.instance().warn(this,\n\t\t\t\t\t\"Setting property '%s' in proxied class '%s' with an anonymous class '%s'. The document won't have this property.\",\n\t\t\t\t\tfieldName, self.getClass().getName(), valueToSet.getClass().getName());\n\t\t}\n\t\treturn valueToSet;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprotected Object getValue(Object self, final String fieldName, boolean idOrVersionField, Object value)\n\t\t\tthrows NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tif (!idOrVersionField) {\n\t\t\tif (value == null) {\n\t\t\t\tObject docValue = doc.field(fieldName, OType.getTypeByClass(getField(fieldName, self.getClass()).getType()));\n\t\t\t\tif (docValue != null) {\n\t\t\t\t\tvalue = lazyLoadField(self, fieldName, docValue, value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (((value instanceof Collection<?> || value instanceof Map<?, ?>) && !(value instanceof OLazyObjectMultivalueElement))\n\t\t\t\t\t\t|| value.getClass().isArray()) {\n\t\t\t\t\tClass<?> genericMultiValueType = OReflectionHelper.getGenericMultivalueType(getField(fieldName, self.getClass()));\n\t\t\t\t\tif (genericMultiValueType != null && !OReflectionHelper.isJavaType(genericMultiValueType)) {\n\t\t\t\t\t\tField f = getField(fieldName, self.getClass());\n\t\t\t\t\t\tif (OObjectEntitySerializer.isSerializedType(f) && !(value instanceof OLazyObjectCustomSerializer)) {\n\t\t\t\t\t\t\tvalue = manageSerializedCollections(self, fieldName, value);\n\t\t\t\t\t\t} else if (genericMultiValueType.isEnum() && !(value instanceof OLazyObjectEnumSerializer)) {\n\t\t\t\t\t\t\tvalue = manageEnumCollections(self, f.getName(), genericMultiValueType, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = manageObjectCollections(self, fieldName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject docValue = doc.field(fieldName);\n\t\t\t\t\t\tif (docValue == null) {\n\t\t\t\t\t\t\tif (value.getClass().isArray()) {\n\t\t\t\t\t\t\t\tOClass schemaClass = doc.getSchemaClass();\n\t\t\t\t\t\t\t\tOProperty schemaProperty = null;\n\t\t\t\t\t\t\t\tif (schemaClass != null)\n\t\t\t\t\t\t\t\t\tschemaProperty = schemaClass.getProperty(fieldName);\n\n\t\t\t\t\t\t\t\tdoc.field(fieldName, OObjectEntitySerializer.typeToStream(value, schemaProperty != null ? schemaProperty.getType()\n\t\t\t\t\t\t\t\t\t\t: null, getDatabase(), doc));\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tdoc.field(fieldName, value);\n\n\t\t\t\t\t\t} else if (!loadedFields.containsKey(fieldName)) {\n\t\t\t\t\t\t\tvalue = manageArrayFieldObject(getField(fieldName, self.getClass()), self, docValue);\n\t\t\t\t\t\t\tMethod setMethod = getSetMethod(self.getClass().getSuperclass(), getSetterFieldName(fieldName), value);\n\t\t\t\t\t\t\tsetMethod.invoke(self, value);\n\t\t\t\t\t\t} else if ((value instanceof Set || value instanceof Map) && loadedFields.get(fieldName).intValue() < doc.getVersion()) {\n\t\t\t\t\t\t\tif (value instanceof Set)\n\t\t\t\t\t\t\t\tvalue = new OObjectLazySet(doc, (Set<?>) docValue);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tvalue = new OObjectLazyMap(doc, (Map<?, ?>) docValue);\n\t\t\t\t\t\t\tMethod setMethod = getSetMethod(self.getClass().getSuperclass(), getSetterFieldName(fieldName), value);\n\t\t\t\t\t\t\tsetMethod.invoke(self, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!loadedFields.containsKey(fieldName)) {\n\t\t\t\t\tObject docValue = doc.field(fieldName);\n\t\t\t\t\tif (docValue != null && !docValue.equals(value)) {\n\t\t\t\t\t\tvalue = lazyLoadField(self, fieldName, docValue, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}","id":71464,"modified_method":"@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n\tprotected Object getValue(Object self, final String fieldName, boolean idOrVersionField, Object value)\n\t\t\tthrows NoSuchMethodException, IllegalAccessException, InvocationTargetException {\n\t\tif (!idOrVersionField) {\n\t\t\tif (value == null) {\n\t\t\t\tObject docValue = doc.field(fieldName, OObjectEntitySerializer.getTypeByClass(self.getClass(), fieldName));\n\t\t\t\tif (docValue != null) {\n\t\t\t\t\tvalue = lazyLoadField(self, fieldName, docValue, value);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (((value instanceof Collection<?> || value instanceof Map<?, ?>) && !(value instanceof OLazyObjectMultivalueElement))\n\t\t\t\t\t\t|| value.getClass().isArray()) {\n\t\t\t\t\tClass<?> genericMultiValueType = OReflectionHelper.getGenericMultivalueType(OObjectEntitySerializer.getField(fieldName,\n\t\t\t\t\t\t\tself.getClass()));\n\t\t\t\t\tif (genericMultiValueType != null && !OReflectionHelper.isJavaType(genericMultiValueType)) {\n\t\t\t\t\t\tField f = OObjectEntitySerializer.getField(fieldName, self.getClass());\n\t\t\t\t\t\tif (OObjectEntitySerializer.isSerializedType(f) && !(value instanceof OLazyObjectCustomSerializer)) {\n\t\t\t\t\t\t\tvalue = manageSerializedCollections(self, fieldName, value);\n\t\t\t\t\t\t} else if (genericMultiValueType.isEnum() && !(value instanceof OLazyObjectEnumSerializer)) {\n\t\t\t\t\t\t\tvalue = manageEnumCollections(self, f.getName(), genericMultiValueType, value);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvalue = manageObjectCollections(self, fieldName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject docValue = doc.field(fieldName);\n\t\t\t\t\t\tif (docValue == null) {\n\t\t\t\t\t\t\tif (value.getClass().isArray()) {\n\t\t\t\t\t\t\t\tOClass schemaClass = doc.getSchemaClass();\n\t\t\t\t\t\t\t\tOProperty schemaProperty = null;\n\t\t\t\t\t\t\t\tif (schemaClass != null)\n\t\t\t\t\t\t\t\t\tschemaProperty = schemaClass.getProperty(fieldName);\n\n\t\t\t\t\t\t\t\tdoc.field(fieldName, OObjectEntitySerializer.typeToStream(value, schemaProperty != null ? schemaProperty.getType()\n\t\t\t\t\t\t\t\t\t\t: null, getDatabase(), doc));\n\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\tdoc.field(fieldName, value);\n\n\t\t\t\t\t\t} else if (!loadedFields.containsKey(fieldName)) {\n\t\t\t\t\t\t\tvalue = manageArrayFieldObject(OObjectEntitySerializer.getField(fieldName, self.getClass()), self, docValue);\n\t\t\t\t\t\t\tMethod setMethod = getSetMethod(self.getClass().getSuperclass(), getSetterFieldName(fieldName), value);\n\t\t\t\t\t\t\tsetMethod.invoke(self, value);\n\t\t\t\t\t\t} else if ((value instanceof Set || value instanceof Map) && loadedFields.get(fieldName).intValue() < doc.getVersion()) {\n\t\t\t\t\t\t\tif (value instanceof Set)\n\t\t\t\t\t\t\t\tvalue = new OObjectLazySet(doc, (Set<?>) docValue);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tvalue = new OObjectLazyMap(doc, (Map<?, ?>) docValue);\n\t\t\t\t\t\t\tMethod setMethod = getSetMethod(self.getClass().getSuperclass(), getSetterFieldName(fieldName), value);\n\t\t\t\t\t\t\tsetMethod.invoke(self, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (!loadedFields.containsKey(fieldName)) {\n\t\t\t\t\tObject docValue = doc.field(fieldName);\n\t\t\t\t\tif (docValue != null && !docValue.equals(value)) {\n\t\t\t\t\t\tvalue = lazyLoadField(self, fieldName, docValue, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn value;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageMapSave(Field f, Map<?, ?> value, boolean customSerialization) {\n\t\tfinal Class genericType = OReflectionHelper.getGenericMultivalueType(f);\n\t\tif (customSerialization) {\n\t\t\tMap<Object, Object> map = new HashMap<Object, Object>();\n\t\t\tdoc.field(f.getName(), map);\n\t\t\tvalue = new OObjectCustomSerializerMap<TYPE>(OObjectEntitySerializer.getSerializedType(f), doc, map,\n\t\t\t\t\t(Map<Object, Object>) value);\n\t\t} else if (genericType.isEnum()) {\n\t\t\tMap<Object, Object> map = new HashMap<Object, Object>();\n\t\t\tdoc.field(f.getName(), map);\n\t\t\tvalue = new OObjectEnumLazyMap(genericType, doc, map, (Map<Object, Object>) value);\n\t\t} else if (!(value instanceof OLazyObjectMultivalueElement)) {\n\t\t\tMap<Object, OIdentifiable> docMap = doc.field(f.getName());\n\t\t\tif (docMap == null) {\n\t\t\t\tdocMap = new ORecordLazyMap(doc);\n\t\t\t\tdoc.field(f.getName(), docMap);\n\t\t\t}\n\t\t\tvalue = new OObjectLazyMap(doc, docMap, value);\n\t\t}\n\t\treturn value;\n\t}","id":71465,"modified_method":"@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\tprotected Object manageMapSave(Field f, Map<?, ?> value, boolean customSerialization) {\n\t\tfinal Class genericType = OReflectionHelper.getGenericMultivalueType(f);\n\t\tif (customSerialization) {\n\t\t\tMap<Object, Object> map = new HashMap<Object, Object>();\n\t\t\tdoc.field(f.getName(), map, OType.EMBEDDEDMAP);\n\t\t\tvalue = new OObjectCustomSerializerMap<TYPE>(OObjectEntitySerializer.getSerializedType(f), doc, map,\n\t\t\t\t\t(Map<Object, Object>) value);\n\t\t} else if (genericType.isEnum()) {\n\t\t\tMap<Object, Object> map = new HashMap<Object, Object>();\n\t\t\tdoc.field(f.getName(), map, OType.EMBEDDEDMAP);\n\t\t\tvalue = new OObjectEnumLazyMap(genericType, doc, map, (Map<Object, Object>) value);\n\t\t} else if (!(value instanceof OLazyObjectMultivalueElement)) {\n\t\t\tMap<Object, OIdentifiable> docMap = doc.field(f.getName());\n\t\t\tif (docMap == null) {\n\t\t\t\tdocMap = new ORecordLazyMap(doc);\n\t\t\t\tdoc.field(f.getName(), docMap, OType.LINKMAP);\n\t\t\t}\n\t\t\tvalue = new OObjectLazyMap(doc, docMap, value);\n\t\t}\n\t\treturn value;\n\t}","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String getClassName() {\r\n    if (_clazz != null)\r\n      return _clazz.getName();\r\n\r\n    // CLASS NOT FOUND: CHECK IF NEED LOADING AND UNMARSHALLING\r\n    checkForLoading();\r\n    checkForFields();\r\n    return _clazz != null ? _clazz.getName() : null;\r\n  }","id":71466,"modified_method":"public String getClassName() {\r\n    if (_clazz != null)\r\n      return _clazz.getName();\r\n\r\n    // CLASS NOT FOUND: CHECK IF NEED LOADING AND UNMARSHALLING\r\n    checkForLoading();\r\n    checkForFields(\"@class\");\r\n    return _clazz != null ? _clazz.getName() : null;\r\n  }","commit_id":"1738863f7d7dacacc11779bad4b401eab1c030ec","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\tServletRequest req = pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)req.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\treturn get(\n\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getLocale(), key,\n\t\t\tdefaultValue);\n\t}","id":71467,"modified_method":"public String get(\n\t\tPageContext pageContext, String key, String defaultValue) {\n\n\t\tHttpServletRequest req = (HttpServletRequest)pageContext.getRequest();\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)req.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tif (themeDisplay != null) {\n\t\t\treturn get(\n\t\t\t\tthemeDisplay.getCompanyId(), themeDisplay.getLocale(), key,\n\t\t\t\tdefaultValue);\n\t\t}\n\n\t\tif (key == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tString value = null;\n\n\t\ttry {\n\t\t\tvalue = TagUtils.getInstance().message(\n\t\t\t\tpageContext, null, null, key);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e);\n\t\t}\n\n\t\tif (value == null) {\n\n\t\t\t// LEP-2849\n\n\t\t\tPortletConfig portletConfig = (PortletConfig)req.getAttribute(\n\t\t\t\tJavaConstants.JAVAX_PORTLET_CONFIG);\n\n\t\t\tif (portletConfig != null) {\n\t\t\t\tLocale locale = req.getLocale();\n\n\t\t\t\tResourceBundle bundle = portletConfig.getResourceBundle(locale);\n\n\t\t\t\ttry {\n\t\t\t\t\tvalue = bundle.getString(key);\n\t\t\t\t}\n\t\t\t\tcatch (MissingResourceException mre) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (value == null) {\n\t\t\tvalue = defaultValue;\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"2a000535e31bd8f0bfac707ae459f2820568cf0a","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic AuthVerifierResult verify(\n\t\t\tAccessControlContext accessControlContext, Properties properties)\n\t\tthrows AuthException {\n\n\t\ttry {\n\t\t\tAuthVerifierResult authVerifierResult = new AuthVerifierResult();\n\n\t\t\tString[] credentials = getCredentials(\n\t\t\t\taccessControlContext.getRequest(),\n\t\t\t\taccessControlContext.getResponse());\n\n\t\t\tif (credentials != null) {\n\t\t\t\tauthVerifierResult.setPassword(credentials[1]);\n\t\t\t\tauthVerifierResult.setPasswordBasedAuthentication(true);\n\t\t\t\tauthVerifierResult.setState(AuthVerifierResult.State.SUCCESS);\n\t\t\t\tauthVerifierResult.setUserId(\n\t\t\t\t\tGetterUtil.getLong(credentials[0]));\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// SYNC-1463\n\n\t\t\t\tMap<String, Object> settings =\n\t\t\t\t\taccessControlContext.getSettings();\n\n\t\t\t\tsettings.remove(\"basic_auth\");\n\t\t\t}\n\n\t\t\treturn authVerifierResult;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AuthException(e);\n\t\t}\n\t}","id":71468,"modified_method":"@Override\n\tpublic AuthVerifierResult verify(\n\t\t\tAccessControlContext accessControlContext, Properties properties)\n\t\tthrows AuthException {\n\n\t\tAuthVerifierResult authVerifierResult = new AuthVerifierResult();\n\n\t\tHttpServletRequest request = accessControlContext.getRequest();\n\n\t\tString uri = (String)request.getAttribute(WebKeys.INVOKER_FILTER_URI);\n\n\t\tif (uri.startsWith(\"/download/\")) {\n\t\t\tString contextPath = request.getContextPath();\n\n\t\t\tif (!contextPath.equals(\n\t\t\t\t\tStringPool.FORWARD_SLASH +\n\t\t\t\t\t\tClpSerializer.getServletContextName())) {\n\n\t\t\t\treturn authVerifierResult;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tString[] credentials = getCredentials(\n\t\t\t\trequest, accessControlContext.getResponse());\n\n\t\t\tif (credentials != null) {\n\t\t\t\tauthVerifierResult.setPassword(credentials[1]);\n\t\t\t\tauthVerifierResult.setPasswordBasedAuthentication(true);\n\t\t\t\tauthVerifierResult.setState(AuthVerifierResult.State.SUCCESS);\n\t\t\t\tauthVerifierResult.setUserId(\n\t\t\t\t\tGetterUtil.getLong(credentials[0]));\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// SYNC-1463\n\n\t\t\t\tMap<String, Object> settings =\n\t\t\t\t\taccessControlContext.getSettings();\n\n\t\t\t\tsettings.remove(\"basic_auth\");\n\t\t\t}\n\n\t\t\treturn authVerifierResult;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AuthException(e);\n\t\t}\n\t}","commit_id":"fad258a1a6717be9c6d035741ee7f1a5f6954947","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n\tpublic AuthVerifierResult verify(\n\t\t\tAccessControlContext accessControlContext, Properties properties)\n\t\tthrows AuthException {\n\n\t\ttry {\n\t\t\tAuthVerifierResult authVerifierResult = new AuthVerifierResult();\n\n\t\t\tString[] credentials = getCredentials(\n\t\t\t\taccessControlContext.getRequest(),\n\t\t\t\taccessControlContext.getResponse());\n\n\t\t\tif (credentials != null) {\n\t\t\t\tauthVerifierResult.setPassword(credentials[1]);\n\t\t\t\tauthVerifierResult.setState(AuthVerifierResult.State.SUCCESS);\n\t\t\t\tauthVerifierResult.setUserId(\n\t\t\t\t\tGetterUtil.getLong(credentials[0]));\n\n\t\t\t\tServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName(\n\t\t\t\t\tSyncTokenPolicy.POLICY_NAME);\n\t\t\t}\n\n\t\t\treturn authVerifierResult;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AuthException(e);\n\t\t}\n\t}","id":71469,"modified_method":"@Override\n\tpublic AuthVerifierResult verify(\n\t\t\tAccessControlContext accessControlContext, Properties properties)\n\t\tthrows AuthException {\n\n\t\tAuthVerifierResult authVerifierResult = new AuthVerifierResult();\n\n\t\tHttpServletRequest request = accessControlContext.getRequest();\n\n\t\tString uri = (String)request.getAttribute(WebKeys.INVOKER_FILTER_URI);\n\n\t\tif (uri.startsWith(\"/download/\")) {\n\t\t\tString contextPath = request.getContextPath();\n\n\t\t\tif (!contextPath.equals(\"/sync-web\")) {\n\t\t\t\treturn authVerifierResult;\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tString[] credentials = getCredentials(\n\t\t\t\trequest, accessControlContext.getResponse());\n\n\t\t\tif (credentials != null) {\n\t\t\t\tauthVerifierResult.setPassword(credentials[1]);\n\t\t\t\tauthVerifierResult.setState(AuthVerifierResult.State.SUCCESS);\n\t\t\t\tauthVerifierResult.setUserId(\n\t\t\t\t\tGetterUtil.getLong(credentials[0]));\n\n\t\t\t\tServiceAccessPolicyThreadLocal.addActiveServiceAccessPolicyName(\n\t\t\t\t\tSyncTokenPolicy.POLICY_NAME);\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// SYNC-1463\n\n\t\t\t\tMap<String, Object> settings =\n\t\t\t\t\taccessControlContext.getSettings();\n\n\t\t\t\tsettings.remove(\"basic_auth\");\n\t\t\t}\n\n\t\t\treturn authVerifierResult;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new AuthException(e);\n\t\t}\n\t}","commit_id":"1c34f7c74b591aa835e4960a319fb43b5a3473db","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Serializer createSerializerInstance(SerializerConfig serializerConfig, Class serializationType) {\n        Serializer serializer;\n        try {\n            Class<?> clazz = ClassLoaderUtil.loadClass(classLoader, serializerConfig.getClassName());\n            try {\n                Constructor<?> constructor = clazz.getDeclaredConstructor(Class.class);\n                constructor.setAccessible(true);\n                serializer = (Serializer) constructor.newInstance(serializationType);\n            } catch (NoSuchMethodException e) {\n                //fallback to no-arg contructor\n                Constructor<?> constructor = clazz.getDeclaredConstructor();\n                constructor.setAccessible(true);\n                serializer = (Serializer) constructor.newInstance();\n            }\n        } catch (Exception e) {\n            throw new HazelcastSerializationException(e);\n        }\n        return serializer;\n    }","id":71470,"modified_method":"private Serializer createSerializerInstance(SerializerConfig serializerConfig, Class serializationType) {\n        try {\n            String className = serializerConfig.getClassName();\n            if (useDefaultConstructorOnly) {\n                return ClassLoaderUtil.newInstance(classLoader, className);\n            } else {\n                return createSerializerInstanceWithFallback(serializationType, className);\n            }\n        } catch (Exception e) {\n            throw new HazelcastSerializationException(e);\n        }\n    }","commit_id":"3a57203d7115226800d8358dad719fdedf4edc81","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n  public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n    String fqn = getFqn(name, myShortName);\n    String shortName = getShortName(name, myShortName);\n\n    int flags = myAccess | access;\n    boolean isDeprecated = (flags & Opcodes.ACC_DEPRECATED) != 0;\n    boolean isInterface = (flags & Opcodes.ACC_INTERFACE) != 0;\n    boolean isEnum = (flags & Opcodes.ACC_ENUM) != 0;\n    boolean isAnnotationType = (flags & Opcodes.ACC_ANNOTATION) != 0;\n\n    byte stubFlags = PsiClassStubImpl.packFlags(isDeprecated, isInterface, isEnum, false, false, isAnnotationType, false, false);\n    myResult = new PsiClassStubImpl(JavaStubElementTypes.CLASS, myParent, fqn, shortName, null, stubFlags);\n\n    LanguageLevel languageLevel = ClsParsingUtil.getLanguageLevelByVersion(version);\n    ((PsiClassStubImpl)myResult).setLanguageLevel(languageLevel);\n\n    myModList = new PsiModifierListStubImpl(myResult, packClassFlags(flags));\n\n    CharacterIterator signatureIterator = signature != null ? new StringCharacterIterator(signature) : null;\n    if (signatureIterator != null) {\n      try {\n        SignatureParsing.parseTypeParametersDeclaration(signatureIterator, myResult);\n      }\n      catch (ClsFormatException e) {\n        signatureIterator = null;\n      }\n    } else {\n      new PsiTypeParameterListStubImpl(myResult);\n    }\n\n    String convertedSuper;\n    List<String> convertedInterfaces = new ArrayList<String>();\n    if (signatureIterator == null) {\n      convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n    } else {\n      try {\n        convertedSuper = parseClassSignature(signatureIterator, convertedInterfaces);\n      }\n      catch (ClsFormatException e) {\n        new PsiTypeParameterListStubImpl(myResult);\n        convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n      }\n    }\n\n    if (isInterface) {\n      if (isAnnotationType) {\n        convertedInterfaces.remove(JAVA_LANG_ANNOTATION_ANNOTATION);\n      }\n      newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult);\n    }\n    else {\n      if (convertedSuper == null ||\n          JAVA_LANG_OBJECT.equals(convertedSuper) ||\n          isEnum && (JAVA_LANG_ENUM.equals(convertedSuper) || (JAVA_LANG_ENUM + \"<\" + fqn + \">\").equals(convertedSuper))) {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult);\n      }\n      else {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, convertedSuper);\n      }\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n    }\n  }","id":71471,"modified_method":"@Override\n  public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n    String fqn = getFqn(name, myShortName);\n    String shortName = myShortName != null && name.endsWith(myShortName) ? myShortName : PsiNameHelper.getShortClassName(fqn);\n\n    int flags = myAccess | access;\n    boolean isDeprecated = (flags & Opcodes.ACC_DEPRECATED) != 0;\n    boolean isInterface = (flags & Opcodes.ACC_INTERFACE) != 0;\n    boolean isEnum = (flags & Opcodes.ACC_ENUM) != 0;\n    boolean isAnnotationType = (flags & Opcodes.ACC_ANNOTATION) != 0;\n\n    byte stubFlags = PsiClassStubImpl.packFlags(isDeprecated, isInterface, isEnum, false, false, isAnnotationType, false, false);\n    myResult = new PsiClassStubImpl(JavaStubElementTypes.CLASS, myParent, fqn, shortName, null, stubFlags);\n\n    LanguageLevel languageLevel = ClsParsingUtil.getLanguageLevelByVersion(version);\n    ((PsiClassStubImpl)myResult).setLanguageLevel(languageLevel);\n\n    myModList = new PsiModifierListStubImpl(myResult, packClassFlags(flags));\n\n    CharacterIterator signatureIterator = signature != null ? new StringCharacterIterator(signature) : null;\n    if (signatureIterator != null) {\n      try {\n        SignatureParsing.parseTypeParametersDeclaration(signatureIterator, myResult);\n      }\n      catch (ClsFormatException e) {\n        signatureIterator = null;\n      }\n    }\n    else {\n      new PsiTypeParameterListStubImpl(myResult);\n    }\n\n    String convertedSuper;\n    List<String> convertedInterfaces = new ArrayList<String>();\n    if (signatureIterator == null) {\n      convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n    }\n    else {\n      try {\n        convertedSuper = parseClassSignature(signatureIterator, convertedInterfaces);\n      }\n      catch (ClsFormatException e) {\n        new PsiTypeParameterListStubImpl(myResult);\n        convertedSuper = parseClassDescription(superName, interfaces, convertedInterfaces);\n      }\n    }\n\n    if (isInterface) {\n      if (isAnnotationType) {\n        convertedInterfaces.remove(JAVA_LANG_ANNOTATION_ANNOTATION);\n      }\n      newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult);\n    }\n    else {\n      if (convertedSuper == null ||\n          JAVA_LANG_OBJECT.equals(convertedSuper) ||\n          isEnum && (JAVA_LANG_ENUM.equals(convertedSuper) || (JAVA_LANG_ENUM + \"<\" + fqn + \">\").equals(convertedSuper))) {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult);\n      }\n      else {\n        newReferenceList(JavaStubElementTypes.EXTENDS_LIST, myResult, convertedSuper);\n      }\n      newReferenceList(JavaStubElementTypes.IMPLEMENTS_LIST, myResult, ArrayUtil.toStringArray(convertedInterfaces));\n    }\n  }","commit_id":"6e03229865c75e9a7bffcf47a342bbdfdfa9dc07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static String parseMethodViaGenericSignature(@NotNull String signature,\n                                                       @NotNull PsiMethodStubImpl stub,\n                                                       @NotNull List<String> args,\n                                                       @Nullable List<String> throwables) throws ClsFormatException {\n    StringCharacterIterator iterator = new StringCharacterIterator(signature);\n    SignatureParsing.parseTypeParametersDeclaration(iterator, stub);\n\n    if (iterator.current() != '(') {\n      throw new ClsFormatException();\n    }\n    iterator.next();\n\n    while (iterator.current() != ')' && iterator.current() != CharacterIterator.DONE) {\n      args.add(SignatureParsing.parseTypeString(iterator));\n    }\n\n    if (iterator.current() != ')') {\n      throw new ClsFormatException();\n    }\n    iterator.next();\n\n    String returnType = SignatureParsing.parseTypeString(iterator);\n\n    while (iterator.current() == '^') {\n      iterator.next();\n      throwables.add(SignatureParsing.parseTypeString(iterator));\n    }\n\n    return returnType;\n  }","id":71472,"modified_method":"@NotNull\n  public static String parseMethodViaGenericSignature(@NotNull String signature,\n                                                      @NotNull PsiMethodStubImpl stub,\n                                                      @NotNull List<String> args,\n                                                      @Nullable List<String> throwables) throws ClsFormatException {\n    StringCharacterIterator iterator = new StringCharacterIterator(signature);\n    SignatureParsing.parseTypeParametersDeclaration(iterator, stub);\n\n    if (iterator.current() != '(') {\n      throw new ClsFormatException();\n    }\n    iterator.next();\n\n    while (iterator.current() != ')' && iterator.current() != CharacterIterator.DONE) {\n      args.add(SignatureParsing.parseTypeString(iterator));\n    }\n\n    if (iterator.current() != ')') {\n      throw new ClsFormatException();\n    }\n    iterator.next();\n\n    String returnType = SignatureParsing.parseTypeString(iterator);\n\n    while (iterator.current() == '^') {\n      iterator.next();\n      String exType = SignatureParsing.parseTypeString(iterator);\n      if (throwables != null) {\n        throwables.add(exType);\n      }\n    }\n\n    return returnType;\n  }","commit_id":"6e03229865c75e9a7bffcf47a342bbdfdfa9dc07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public MethodVisitor visitMethod(final int access,\n                                   final String name,\n                                   final String desc,\n                                   final String signature,\n                                   final String[] exceptions) {\n    // JLS 13.1 says: Any constructs introduced by the compiler that do not have a corresponding construct in the source code\n    // must be marked as synthetic, except for default constructors and the class initialization method.\n    // However Scala compiler erroneously generates ACC_BRIDGE instead of ACC_SYNTHETIC flag for in-trait implementation delegation.\n    // See IDEA-78649\n    if ((access & Opcodes.ACC_SYNTHETIC) != 0) return null;\n\n    if (SYNTHETIC_CLASS_INIT_METHOD.equals(name)) return null;\n\n    // skip semi-synthetic enum methods\n    boolean isEnum = myResult.isEnum();\n    if (isEnum) {\n      if (\"values\".equals(name) && desc.startsWith(\"()\")) return null;\n      if (\"valueOf\".equals(name) && desc.startsWith(\"(Ljava/lang/String;)\")) return null;\n    }\n\n    boolean isDeprecated = (access & Opcodes.ACC_DEPRECATED) != 0;\n    boolean isConstructor = SYNTHETIC_INIT_METHOD.equals(name);\n    boolean isVarargs = (access & Opcodes.ACC_VARARGS) != 0;\n    boolean isAnnotationMethod = myResult.isAnnotationType();\n\n    if (!isConstructor && !isCorrectName(name)) return null;\n\n    final byte flags = PsiMethodStubImpl.packFlags(isConstructor, isAnnotationMethod, isVarargs, isDeprecated, false);\n\n    String canonicalMethodName = isConstructor ? myResult.getName() : name;\n    List<String> args = new ArrayList<String>();\n    List<String> throwables = exceptions != null ? new ArrayList<String>() : null;\n\n    int modifiersMask = packMethodFlags(access, myResult.isInterface());\n    final PsiMethodStubImpl stub = new PsiMethodStubImpl(myResult, StringRef.fromString(canonicalMethodName), flags, signature, args, throwables, desc, modifiersMask);\n\n    PsiModifierListStub modList = (PsiModifierListStub)stub.findChildStubByType(JavaStubElementTypes.MODIFIER_LIST);\n\n    if (isEnum && isConstructor && signature == null && args.size() >= 2 && JAVA_LANG_STRING.equals(args.get(0)) && \"int\".equals(args.get(1))) {\n      // exclude synthetic enum constructor parameters\n      args = args.subList(2, args.size());\n    }\n\n    final boolean isNonStaticInnerClassConstructor =\n      isConstructor && !(myParent instanceof PsiFileStub) && (myModList.getModifiersMask() & Opcodes.ACC_STATIC) == 0;\n    boolean parsedViaGenericSignature = stub.isParsedViaGenericSignature();\n    final boolean shouldSkipFirstParamForNonStaticInnerClassConstructor = !parsedViaGenericSignature && isNonStaticInnerClassConstructor;\n\n    final PsiParameterListStubImpl parameterList = new PsiParameterListStubImpl(stub);\n    final int paramCount = args.size();\n    final PsiParameterStubImpl[] paramStubs = new PsiParameterStubImpl[paramCount];\n    for (int i = 0; i < paramCount; i++) {\n      if (shouldSkipFirstParamForNonStaticInnerClassConstructor && i == 0) continue;\n\n      String arg = args.get(i);\n      boolean isEllipsisParam = isVarargs && i == paramCount - 1;\n      final TypeInfo typeInfo = TypeInfo.fromString(arg, isEllipsisParam);\n\n      String paramName = i < parameterNames.length ? parameterNames[i] : \"p\" + (i + 1);\n      PsiParameterStubImpl parameterStub = new PsiParameterStubImpl(parameterList, paramName, typeInfo, isEllipsisParam);\n      paramStubs [i] = parameterStub;\n      new PsiModifierListStubImpl(parameterStub, 0);\n    }\n\n    String[] thrownTypes = buildThrowsList(exceptions, throwables, parsedViaGenericSignature);\n    newReferenceList(JavaStubElementTypes.THROWS_LIST, stub, thrownTypes);\n\n    int localVarIgnoreCount = (access & Opcodes.ACC_STATIC) != 0 ? 0 : isConstructor && isEnum ? 3 : 1;\n    int paramIgnoreCount = isConstructor && isEnum ? 2 : isNonStaticInnerClassConstructor ? 1 : 0;\n    return new AnnotationParamCollectingVisitor(stub, modList, localVarIgnoreCount, paramIgnoreCount, paramCount, paramStubs);\n  }","id":71473,"modified_method":"@Override\n  @Nullable\n  public MethodVisitor visitMethod(final int access,\n                                   final String name,\n                                   final String desc,\n                                   final String signature,\n                                   final String[] exceptions) {\n    // JLS 13.1 says: Any constructs introduced by the compiler that do not have a corresponding construct in the source code\n    // must be marked as synthetic, except for default constructors and the class initialization method.\n    // However Scala compiler erroneously generates ACC_BRIDGE instead of ACC_SYNTHETIC flag for in-trait implementation delegation.\n    // See IDEA-78649\n    if ((access & Opcodes.ACC_SYNTHETIC) != 0) return null;\n\n    if (SYNTHETIC_CLASS_INIT_METHOD.equals(name)) return null;\n\n    // skip semi-synthetic enum methods\n    boolean isEnum = myResult.isEnum();\n    if (isEnum) {\n      if (\"values\".equals(name) && desc.startsWith(\"()\")) return null;\n      if (\"valueOf\".equals(name) && desc.startsWith(\"(Ljava/lang/String;)\")) return null;\n    }\n\n    boolean isDeprecated = (access & Opcodes.ACC_DEPRECATED) != 0;\n    boolean isConstructor = SYNTHETIC_INIT_METHOD.equals(name);\n    boolean isVarargs = (access & Opcodes.ACC_VARARGS) != 0;\n    boolean isAnnotationMethod = myResult.isAnnotationType();\n\n    if (!isConstructor && !isCorrectName(name)) return null;\n\n    final byte flags = PsiMethodStubImpl.packFlags(isConstructor, isAnnotationMethod, isVarargs, isDeprecated, false);\n\n    String canonicalMethodName = isConstructor ? myResult.getName() : name;\n    List<String> args = new ArrayList<String>();\n    List<String> throwables = exceptions != null ? new ArrayList<String>() : null;\n\n    StringRef stringRef = StringRef.fromString(canonicalMethodName);\n    int modifiersMask = packMethodFlags(access, myResult.isInterface());\n    PsiMethodStubImpl stub = new PsiMethodStubImpl(myResult, stringRef, flags, signature, args, throwables, desc, modifiersMask);\n\n    PsiModifierListStub modList = (PsiModifierListStub)stub.findChildStubByType(JavaStubElementTypes.MODIFIER_LIST);\n    assert modList != null : stub;\n\n    if (isEnum && isConstructor && signature == null && args.size() >= 2 && JAVA_LANG_STRING.equals(args.get(0)) && \"int\".equals(args.get(1))) {\n      // exclude synthetic enum constructor parameters\n      args = args.subList(2, args.size());\n    }\n\n    final boolean isNonStaticInnerClassConstructor =\n      isConstructor && !(myParent instanceof PsiFileStub) && (myModList.getModifiersMask() & Opcodes.ACC_STATIC) == 0;\n    boolean parsedViaGenericSignature = stub.isParsedViaGenericSignature();\n    final boolean shouldSkipFirstParamForNonStaticInnerClassConstructor = !parsedViaGenericSignature && isNonStaticInnerClassConstructor;\n\n    final PsiParameterListStubImpl parameterList = new PsiParameterListStubImpl(stub);\n    final int paramCount = args.size();\n    final PsiParameterStubImpl[] paramStubs = new PsiParameterStubImpl[paramCount];\n    for (int i = 0; i < paramCount; i++) {\n      if (shouldSkipFirstParamForNonStaticInnerClassConstructor && i == 0) continue;\n\n      String arg = args.get(i);\n      boolean isEllipsisParam = isVarargs && i == paramCount - 1;\n      final TypeInfo typeInfo = TypeInfo.fromString(arg, isEllipsisParam);\n\n      String paramName = i < parameterNames.length ? parameterNames[i] : \"p\" + (i + 1);\n      PsiParameterStubImpl parameterStub = new PsiParameterStubImpl(parameterList, paramName, typeInfo, isEllipsisParam);\n      paramStubs[i] = parameterStub;\n      new PsiModifierListStubImpl(parameterStub, 0);\n    }\n\n    String[] thrownTypes = buildThrowsList(exceptions, throwables, parsedViaGenericSignature);\n    newReferenceList(JavaStubElementTypes.THROWS_LIST, stub, thrownTypes);\n\n    int localVarIgnoreCount = (access & Opcodes.ACC_STATIC) != 0 ? 0 : isConstructor && isEnum ? 3 : 1;\n    int paramIgnoreCount = isConstructor && isEnum ? 2 : isNonStaticInnerClassConstructor ? 1 : 0;\n    return new AnnotationParamCollectingVisitor(stub, modList, localVarIgnoreCount, paramIgnoreCount, paramCount, paramStubs);\n  }","commit_id":"6e03229865c75e9a7bffcf47a342bbdfdfa9dc07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static String getFqn(String internalName, String myShortName) {\n    String fqn;\n    String shortName;\n    if (myShortName != null && internalName.endsWith(myShortName)) {\n      shortName = myShortName;\n      fqn = internalName.length() == shortName.length()\n            ? shortName : getClassName(internalName.substring(0, internalName.length() - shortName.length() - 1)) + \".\" + shortName;\n    }\n    else {\n      fqn = getClassName(internalName);\n      shortName = PsiNameHelper.getShortClassName(fqn);\n    }\n\n    return fqn;\n  }","id":71474,"modified_method":"public static String getFqn(@NotNull String internalName, @Nullable String shortName) {\n    if (shortName == null || !internalName.endsWith(shortName)) {\n      return getClassName(internalName);\n    }\n    else if (internalName.length() == shortName.length()) {\n      return shortName;\n    }\n    else {\n      return getClassName(internalName.substring(0, internalName.length() - shortName.length() - 1)) + \".\" + shortName;\n    }\n  }","commit_id":"6e03229865c75e9a7bffcf47a342bbdfdfa9dc07","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean processSpecialMethods(PsiMethodCallExpression expression) {\n    PsiReferenceExpression methodExpression = expression.getMethodExpression();\n    PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n\n    PsiMethod resolved = expression.resolveMethod();\n    if (resolved != null) {\n      final PsiExpressionList argList = expression.getArgumentList();\n      @NonNls String methodName = resolved.getName();\n\n      PsiExpression[] params = argList.getExpressions();\n      PsiClass owner = resolved.getContainingClass();\n      final int exitPoint = getEndOffset(expression) - 1;\n      if (owner != null) {\n        final String className = owner.getQualifiedName();\n        if (\"java.lang.System\".equals(className)) {\n          if (\"exit\".equals(methodName)) {\n            pushParameters(params, false);\n            addInstruction(new ReturnInstruction());\n            return true;\n          }\n        }\n        else if (\"junit.framework.Assert\".equals(className) || \"org.junit.Assert\".equals(className) || \"org.testng.Assert\".equals(className)) {\n          if (\"fail\".equals(methodName)) {\n            pushParameters(params, false);\n            addInstruction(new ReturnInstruction());\n            return true;\n          }\n          else if (\"assertTrue\".equals(methodName)) {\n            pushParameters(params, true);\n            conditionalExit(exitPoint, false);\n            return true;\n          }\n          else if (\"assertFalse\".equals(methodName)) {\n            pushParameters(params, true);\n            conditionalExit(exitPoint, true);\n            return true;\n          }\n          else if (\"assertNull\".equals(methodName)) {\n            pushParameters(params, true);\n\n            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(), null));\n            addInstruction(new BinopInstruction(\"==\", null, expression.getProject()));\n            conditionalExit(exitPoint, false);\n            return true;\n          }\n          else if (\"assertNotNull\".equals(methodName)) {\n            pushParameters(params, true);\n\n            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(), null));\n            addInstruction(new BinopInstruction(\"==\", null, expression.getProject()));\n            conditionalExit(exitPoint, true);\n            return true;\n          }\n          return false;\n        }\n      }\n\n      // Idea project only.\n      if (qualifierExpression != null) {\n        if (qualifierExpression.textMatches(\"LOG\")) {\n          final PsiType qualifierType = qualifierExpression.getType();\n          if (qualifierType != null && qualifierType.equalsToText(\"com.intellij.openapi.diagnostic.Logger\")) {\n            if (\"error\".equals(methodName)) {\n              for (PsiExpression param : params) {\n                param.accept(this);\n                addInstruction(new PopInstruction());\n              }\n              addInstruction(new ReturnInstruction());\n              return true;\n            }\n            else if (\"assertTrue\".equals(methodName)) {\n              params[0].accept(this);\n              for (int i = 1; i < params.length; i++) {\n                params[i].accept(this);\n                addInstruction(new PopInstruction());\n              }\n              conditionalExit(exitPoint, false);\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }","id":71475,"modified_method":"private boolean processSpecialMethods(PsiMethodCallExpression expression) {\n    PsiReferenceExpression methodExpression = expression.getMethodExpression();\n    PsiExpression qualifierExpression = methodExpression.getQualifierExpression();\n\n    PsiMethod resolved = expression.resolveMethod();\n    if (resolved != null) {\n      final PsiExpressionList argList = expression.getArgumentList();\n      @NonNls String methodName = resolved.getName();\n\n      PsiExpression[] params = argList.getExpressions();\n      PsiClass owner = resolved.getContainingClass();\n      final int exitPoint = getEndOffset(expression) - 1;\n      if (owner != null) {\n        final String className = owner.getQualifiedName();\n        if (\"java.lang.System\".equals(className)) {\n          if (\"exit\".equals(methodName)) {\n            pushParameters(params, false, false);\n            addInstruction(new ReturnInstruction());\n            return true;\n          }\n        }\n        else if (\"junit.framework.Assert\".equals(className) || \"org.junit.Assert\".equals(className) || \"org.testng.Assert\".equals(className)) {\n          boolean testng = \"org.testng.Assert\".equals(className);\n          if (\"fail\".equals(methodName)) {\n            pushParameters(params, false, !testng);\n            addInstruction(new ReturnInstruction());\n            return true;\n          }\n          else if (\"assertTrue\".equals(methodName)) {\n            pushParameters(params, true, !testng);\n            conditionalExit(exitPoint, false);\n            return true;\n          }\n          else if (\"assertFalse\".equals(methodName)) {\n            pushParameters(params, true, !testng);\n            conditionalExit(exitPoint, true);\n            return true;\n          }\n          else if (\"assertNull\".equals(methodName)) {\n            pushParameters(params, true, !testng);\n\n            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(), null));\n            addInstruction(new BinopInstruction(\"==\", null, expression.getProject()));\n            conditionalExit(exitPoint, false);\n            return true;\n          }\n          else if (\"assertNotNull\".equals(methodName)) {\n            pushParameters(params, true, !testng);\n\n            addInstruction(new PushInstruction(myFactory.getConstFactory().getNull(), null));\n            addInstruction(new BinopInstruction(\"==\", null, expression.getProject()));\n            conditionalExit(exitPoint, true);\n            return true;\n          }\n          return false;\n        }\n      }\n\n      // Idea project only.\n      if (qualifierExpression != null) {\n        if (qualifierExpression.textMatches(\"LOG\")) {\n          final PsiType qualifierType = qualifierExpression.getType();\n          if (qualifierType != null && qualifierType.equalsToText(\"com.intellij.openapi.diagnostic.Logger\")) {\n            if (\"error\".equals(methodName)) {\n              for (PsiExpression param : params) {\n                param.accept(this);\n                addInstruction(new PopInstruction());\n              }\n              addInstruction(new ReturnInstruction());\n              return true;\n            }\n            else if (\"assertTrue\".equals(methodName)) {\n              params[0].accept(this);\n              for (int i = 1; i < params.length; i++) {\n                params[i].accept(this);\n                addInstruction(new PopInstruction());\n              }\n              conditionalExit(exitPoint, false);\n              return true;\n            }\n          }\n        }\n      }\n    }\n\n    return false;\n  }","commit_id":"2967a2fb6f02c4c1fe78f435666fa63fde24def1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void pushParameters(final PsiExpression[] params, final boolean leaveLastOnStack) {\n    for (int i = 0; i < params.length; i++) {\n      PsiExpression param = params[i];\n      param.accept(this);\n      if (!leaveLastOnStack || i < params.length - 1) {\n        addInstruction(new PopInstruction());\n      }\n    }\n  }","id":71476,"modified_method":"private void pushParameters(final PsiExpression[] params, final boolean leaveOnStack, boolean lastParameterIsSignificant) {\n    for (int i = 0; i < params.length; i++) {\n      PsiExpression param = params[i];\n      param.accept(this);\n      if (leaveOnStack) {\n        if (lastParameterIsSignificant && i == params.length - 1 || !lastParameterIsSignificant && i == 0) continue;\n      }\n\n      addInstruction(new PopInstruction());\n    }\n  }","commit_id":"2967a2fb6f02c4c1fe78f435666fa63fde24def1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Response load(final Request request, final int retryCount, final int maxFileSize, final boolean checkBlacklist) throws IOException {\r\n\r\n        if (retryCount < 0) {\r\n            this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"retry counter exceeded\", -1);\r\n            throw new IOException(\"retry counter exceeded for URL \" + request.url().toString() + \". Processing aborted.\");\r\n        }\r\n\r\n        DigestURI url = request.url();\r\n\r\n        final String host = url.getHost();\r\n        if (host == null || host.length() < 2) throw new IOException(\"host is not well-formed: '\" + host + \"'\");\r\n        final String path = url.getFile();\r\n        int port = url.getPort();\r\n        final boolean ssl = url.getProtocol().equals(\"https\");\r\n        if (port < 0) port = (ssl) ? 443 : 80;\r\n\r\n        // check if url is in blacklist\r\n        final String hostlow = host.toLowerCase();\r\n        if (checkBlacklist && Switchboard.urlBlacklist.isListed(BlacklistType.CRAWLER, hostlow, path)) {\r\n            this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.FINAL_LOAD_CONTEXT, \"url in blacklist\", -1);\r\n            throw new IOException(\"CRAWLER Rejecting URL '\" + request.url().toString() + \"'. URL is in blacklist.\");\r\n        }\r\n\r\n        // resolve yacy and yacyh domains\r\n        final AlternativeDomainNames yacyResolver = HTTPDemon.getAlternativeResolver();\r\n        if(yacyResolver != null) {\r\n        \tfinal String yAddress = yacyResolver.resolve(host);\r\n        \tif(yAddress != null) {\r\n        \t\turl = new DigestURI(url.getProtocol() + \"://\" + yAddress + path);\r\n        \t}\r\n        }\r\n\r\n        // take a file from the net\r\n        Response response = null;\r\n\r\n        // create a request header\r\n        final RequestHeader requestHeader = new RequestHeader();\r\n        requestHeader.put(HeaderFramework.USER_AGENT, ClientIdentification.getUserAgent());\r\n        DigestURI refererURL = null;\r\n        if (request.referrerhash() != null) refererURL = this.sb.getURL(Segments.Process.LOCALCRAWLING, request.referrerhash());\r\n        if (refererURL != null) requestHeader.put(RequestHeader.REFERER, refererURL.toNormalform(true, true));\r\n        requestHeader.put(HeaderFramework.ACCEPT, this.sb.getConfig(\"crawler.http.accept\", DEFAULT_ACCEPT));\r\n        requestHeader.put(HeaderFramework.ACCEPT_LANGUAGE, this.sb.getConfig(\"crawler.http.acceptLanguage\", DEFAULT_LANGUAGE));\r\n        requestHeader.put(HeaderFramework.ACCEPT_CHARSET, this.sb.getConfig(\"crawler.http.acceptCharset\", DEFAULT_CHARSET));\r\n        requestHeader.put(HeaderFramework.ACCEPT_ENCODING, this.sb.getConfig(\"crawler.http.acceptEncoding\", DEFAULT_ENCODING));\r\n\r\n        // HTTP-Client\r\n        final HTTPClient client = new HTTPClient();\r\n        client.setRedirecting(false); // we want to handle redirection ourselves, so we don't index pages twice\r\n        client.setTimout(this.socketTimeout);\r\n        client.setHeader(requestHeader.entrySet());\r\n\r\n        // send request\r\n    \tfinal byte[] responseBody = client.GETbytes(url, maxFileSize);\r\n        final int code = client.getHttpResponse().getStatusLine().getStatusCode();\r\n    \tfinal ResponseHeader responseHeader = new ResponseHeader(code, client.getHttpResponse().getAllHeaders());\r\n\r\n    \tif (code > 299 && code < 310) {\r\n    \t\t// redirection (content may be empty)\r\n    \t    if (this.sb.getConfigBool(SwitchboardConstants.CRAWLER_FOLLOW_REDIRECTS, true)) {\r\n                if (responseHeader.containsKey(HeaderFramework.LOCATION)) {\r\n                    // getting redirection URL\r\n                \tString redirectionUrlString = responseHeader.get(HeaderFramework.LOCATION);\r\n                    redirectionUrlString = redirectionUrlString.trim();\r\n\r\n                    if (redirectionUrlString.length() == 0) {\r\n                        this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"redirection header empy\", code);\r\n                        throw new IOException(\"CRAWLER Redirection of URL=\" + request.url().toString() + \" aborted. Location header is empty.\");\r\n                    }\r\n\r\n                    // normalizing URL\r\n                    final DigestURI redirectionUrl = new DigestURI(MultiProtocolURI.newURL(request.url(), redirectionUrlString));\r\n\r\n                    // restart crawling with new url\r\n                    this.log.logInfo(\"CRAWLER Redirection detected ('\" + client.getHttpResponse().getStatusLine() + \"') for URL \" + request.url().toString());\r\n                    this.log.logInfo(\"CRAWLER ..Redirecting request to: \" + redirectionUrl);\r\n\r\n                    // if we are already doing a shutdown we don't need to retry crawling\r\n                    if (Thread.currentThread().isInterrupted()) {\r\n                        this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.FINAL_LOAD_CONTEXT, \"server shutdown\", code);\r\n                        throw new IOException(\"CRAWLER Retry of URL=\" + request.url().toString() + \" aborted because of server shutdown.\");\r\n                    }\r\n\r\n                    // check if the url was already indexed\r\n                    final String dbname = this.sb.urlExists(Segments.Process.LOCALCRAWLING, redirectionUrl.hash());\r\n                    if (dbname != null) { //OTTO\r\n                        this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"redirection to double content\", code);\r\n                        throw new IOException(\"CRAWLER Redirection of URL=\" + request.url().toString() + \" ignored. The url appears already in db \" + dbname);\r\n                    }\r\n\r\n                    // retry crawling with new url\r\n                    request.redirectURL(redirectionUrl);\r\n                    return load(request, retryCount - 1, maxFileSize, checkBlacklist);\r\n                } else {\r\n                \t// no redirection url provided\r\n                    this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"no redirection url provided\", code);\r\n                    throw new IOException(\"REJECTED EMTPY REDIRECTION '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + request.url().toString());\r\n                }\r\n    \t    } else {\r\n    \t        // we don't want to follow redirects\r\n                this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.FINAL_PROCESS_CONTEXT, \"redirection not wanted\", code);\r\n                throw new IOException(\"REJECTED UNWANTED REDIRECTION '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + request.url().toString());\r\n    \t    }\r\n        } else if (responseBody == null) {\r\n    \t    // no response, reject file\r\n            this.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"no response body\", code);\r\n            throw new IOException(\"REJECTED EMPTY RESPONSE BODY '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + request.url().toString());\r\n    \t} else if (code == 200 || code == 203) {\r\n            // the transfer is ok\r\n\r\n            // we write the new cache entry to file system directly\r\n            final long contentLength = responseBody.length;\r\n            ByteCount.addAccountCount(ByteCount.CRAWLER, contentLength);\r\n\r\n            // check length again in case it was not possible to get the length before loading\r\n            if (maxFileSize > 0 && contentLength > maxFileSize) {\r\n            \tthis.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.FINAL_PROCESS_CONTEXT, \"file size limit exceeded\", code);\r\n            \tthrow new IOException(\"REJECTED URL \" + request.url() + \" because file size '\" + contentLength + \"' exceeds max filesize limit of \" + maxFileSize + \" bytes. (GET)\");\r\n            }\r\n\r\n            // create a new cache entry\r\n            final CrawlProfile profile = this.sb.crawler.getActive(request.profileHandle().getBytes());\r\n            response = new Response(\r\n                    request,\r\n                    requestHeader,\r\n                    responseHeader,\r\n                    profile,\r\n                    false,\r\n                    responseBody\r\n            );\r\n\r\n            return response;\r\n    \t} else {\r\n            // if the response has not the right response type then reject file\r\n        \tthis.sb.crawlQueues.errorURL.push(request, this.sb.peers.mySeed().hash.getBytes(), new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"wrong http status code\", code);\r\n            throw new IOException(\"REJECTED WRONG STATUS TYPE '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + request.url().toString());\r\n        }\r\n    }","id":71477,"modified_method":"private Response load(final Request request, final int retryCount, final int maxFileSize, final boolean checkBlacklist) throws IOException {\r\n\r\n        byte[] myHash = this.sb.peers.mySeed().hash.getBytes();\r\n\r\n        if (retryCount < 0) {\r\n            this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"retry counter exceeded\", -1);\r\n            throw new IOException(\"retry counter exceeded for URL \" + request.url().toString() + \". Processing aborted.\");\r\n        }\r\n\r\n        DigestURI url = request.url();\r\n\r\n        final String host = url.getHost();\r\n        if (host == null || host.length() < 2) throw new IOException(\"host is not well-formed: '\" + host + \"'\");\r\n        final String path = url.getFile();\r\n        int port = url.getPort();\r\n        final boolean ssl = url.getProtocol().equals(\"https\");\r\n        if (port < 0) port = (ssl) ? 443 : 80;\r\n\r\n        // check if url is in blacklist\r\n        final String hostlow = host.toLowerCase();\r\n        if (checkBlacklist && Switchboard.urlBlacklist.isListed(BlacklistType.CRAWLER, hostlow, path)) {\r\n            this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.FINAL_LOAD_CONTEXT, \"url in blacklist\", -1);\r\n            throw new IOException(\"CRAWLER Rejecting URL '\" + request.url().toString() + \"'. URL is in blacklist.\");\r\n        }\r\n\r\n        // resolve yacy and yacyh domains\r\n        final AlternativeDomainNames yacyResolver = HTTPDemon.getAlternativeResolver();\r\n        if(yacyResolver != null) {\r\n        \tfinal String yAddress = yacyResolver.resolve(host);\r\n        \tif(yAddress != null) {\r\n        \t\turl = new DigestURI(url.getProtocol() + \"://\" + yAddress + path);\r\n        \t}\r\n        }\r\n\r\n        // take a file from the net\r\n        Response response = null;\r\n\r\n        // create a request header\r\n        final RequestHeader requestHeader = new RequestHeader();\r\n        requestHeader.put(HeaderFramework.USER_AGENT, ClientIdentification.getUserAgent());\r\n        DigestURI refererURL = null;\r\n        if (request.referrerhash() != null) refererURL = this.sb.getURL(Segments.Process.LOCALCRAWLING, request.referrerhash());\r\n        if (refererURL != null) requestHeader.put(RequestHeader.REFERER, refererURL.toNormalform(true, true));\r\n        requestHeader.put(HeaderFramework.ACCEPT, this.sb.getConfig(\"crawler.http.accept\", DEFAULT_ACCEPT));\r\n        requestHeader.put(HeaderFramework.ACCEPT_LANGUAGE, this.sb.getConfig(\"crawler.http.acceptLanguage\", DEFAULT_LANGUAGE));\r\n        requestHeader.put(HeaderFramework.ACCEPT_CHARSET, this.sb.getConfig(\"crawler.http.acceptCharset\", DEFAULT_CHARSET));\r\n        requestHeader.put(HeaderFramework.ACCEPT_ENCODING, this.sb.getConfig(\"crawler.http.acceptEncoding\", DEFAULT_ENCODING));\r\n\r\n        // HTTP-Client\r\n        final HTTPClient client = new HTTPClient();\r\n        client.setRedirecting(false); // we want to handle redirection ourselves, so we don't index pages twice\r\n        client.setTimout(this.socketTimeout);\r\n        client.setHeader(requestHeader.entrySet());\r\n\r\n        // send request\r\n    \tfinal byte[] responseBody = client.GETbytes(url, maxFileSize);\r\n        final int statusCode = client.getHttpResponse().getStatusLine().getStatusCode();\r\n    \tfinal ResponseHeader responseHeader = new ResponseHeader(statusCode, client.getHttpResponse().getAllHeaders());\r\n        String requestURLString = request.url().toNormalform(false, false);\r\n\r\n        // check redirection\r\n    \tif (statusCode > 299 && statusCode < 310) {\r\n\r\n    \t    // read redirection URL\r\n            String redirectionUrlString = responseHeader.get(HeaderFramework.LOCATION);\r\n            redirectionUrlString = redirectionUrlString == null ? \"\" : redirectionUrlString.trim();\r\n\r\n            if (redirectionUrlString.length() == 0) {\r\n                this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"no redirection url provided, field '\" + HeaderFramework.LOCATION + \"' is empty\", statusCode);\r\n                throw new IOException(\"REJECTED EMTPY REDIRECTION '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + requestURLString);\r\n            }\r\n\r\n            // normalize URL\r\n            final DigestURI redirectionUrl = new DigestURI(MultiProtocolURI.newURL(request.url(), redirectionUrlString));\r\n\r\n            // restart crawling with new url\r\n            this.log.logInfo(\"CRAWLER Redirection detected ('\" + client.getHttpResponse().getStatusLine() + \"') for URL \" + requestURLString);\r\n            this.log.logInfo(\"CRAWLER ..Redirecting request to: \" + redirectionUrl);\r\n\r\n            if (this.sb.getConfigBool(SwitchboardConstants.CRAWLER_RECORD_REDIRECTS, true)) {\r\n                this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.FINAL_REDIRECT_RULE, \"redirect to \" + redirectionUrlString, statusCode);\r\n            }\r\n\r\n    \t    if (this.sb.getConfigBool(SwitchboardConstants.CRAWLER_FOLLOW_REDIRECTS, true)) {\r\n                    // if we are already doing a shutdown we don't need to retry crawling\r\n                    if (Thread.currentThread().isInterrupted()) {\r\n                        this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.FINAL_LOAD_CONTEXT, \"server shutdown\", statusCode);\r\n                        throw new IOException(\"CRAWLER Retry of URL=\" + requestURLString + \" aborted because of server shutdown.\");\r\n                    }\r\n\r\n                    // check if the url was already indexed\r\n                    final String dbname = this.sb.urlExists(Segments.Process.LOCALCRAWLING, redirectionUrl.hash());\r\n                    if (dbname != null) { // customer request\r\n                        this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"redirection to double content\", statusCode);\r\n                        throw new IOException(\"CRAWLER Redirection of URL=\" + requestURLString + \" ignored. The url appears already in db \" + dbname);\r\n                    }\r\n\r\n                    // retry crawling with new url\r\n                    request.redirectURL(redirectionUrl);\r\n                    return load(request, retryCount - 1, maxFileSize, checkBlacklist);\r\n    \t    } else {\r\n    \t        // we don't want to follow redirects\r\n                this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.FINAL_PROCESS_CONTEXT, \"redirection not wanted\", statusCode);\r\n                throw new IOException(\"REJECTED UNWANTED REDIRECTION '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + requestURLString);\r\n    \t    }\r\n        } else if (responseBody == null) {\r\n    \t    // no response, reject file\r\n            this.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"no response body\", statusCode);\r\n            throw new IOException(\"REJECTED EMPTY RESPONSE BODY '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + requestURLString);\r\n    \t} else if (statusCode == 200 || statusCode == 203) {\r\n            // the transfer is ok\r\n\r\n            // we write the new cache entry to file system directly\r\n            final long contentLength = responseBody.length;\r\n            ByteCount.addAccountCount(ByteCount.CRAWLER, contentLength);\r\n\r\n            // check length again in case it was not possible to get the length before loading\r\n            if (maxFileSize > 0 && contentLength > maxFileSize) {\r\n            \tthis.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.FINAL_PROCESS_CONTEXT, \"file size limit exceeded\", statusCode);\r\n            \tthrow new IOException(\"REJECTED URL \" + request.url() + \" because file size '\" + contentLength + \"' exceeds max filesize limit of \" + maxFileSize + \" bytes. (GET)\");\r\n            }\r\n\r\n            // create a new cache entry\r\n            final CrawlProfile profile = this.sb.crawler.getActive(request.profileHandle().getBytes());\r\n            response = new Response(\r\n                    request,\r\n                    requestHeader,\r\n                    responseHeader,\r\n                    profile,\r\n                    false,\r\n                    responseBody\r\n            );\r\n\r\n            return response;\r\n    \t} else {\r\n            // if the response has not the right response type then reject file\r\n        \tthis.sb.crawlQueues.errorURL.push(request, myHash, new Date(), 1, FailCategory.TEMPORARY_NETWORK_FAILURE, \"wrong http status code\", statusCode);\r\n            throw new IOException(\"REJECTED WRONG STATUS TYPE '\" + client.getHttpResponse().getStatusLine() + \"' for URL \" + requestURLString);\r\n        }\r\n    }","commit_id":"3fd4a012861dfb8b7256f5412063a4ebb76043ee","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void close() {\n        this.statsDump = null;\n        if (this.urlIndexFile != null) {\n            this.urlIndexFile.close();\n            this.urlIndexFile = null;\n        }\n        if (this.remoteSolr != null) this.remoteSolr.close();\n        if (this.localSolr != null) this.localSolr.close();\n    }","id":71478,"modified_method":"public void close() {\n        this.statsDump = null;\n        if (this.urlIndexFile != null) {\n            this.urlIndexFile.close();\n            this.urlIndexFile = null;\n        }\n        if (this.localSolr != null) this.localSolr.close();\n        if (this.remoteSolr != null) this.remoteSolr.close();\n    }","commit_id":"3fd4a012861dfb8b7256f5412063a4ebb76043ee","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean exists(final byte[] urlHash) {\n        if (urlHash == null) return false;\n        try {\n            if (this.remoteSolr != null && this.remoteSolr.exists(ASCII.String(urlHash))) {\n                return true;\n            }\n        } catch (final Throwable e) {\n        }\n        if (this.urlIndexFile == null) return false; // case may happen during shutdown\n        return this.urlIndexFile.has(urlHash);\n    }","id":71479,"modified_method":"public boolean exists(final byte[] urlHash) {\n        if (urlHash == null) return false;\n        if (this.localSolr != null || this.remoteSolr != null) {\n            String urls = ASCII.String(urlHash);\n            try {\n                if (this.localSolr != null && this.localSolr.exists(urls)) {\n                    return true;\n                }\n            } catch (final Throwable e) {\n                Log.logException(e);\n            }\n            try {\n                if (this.remoteSolr != null && this.remoteSolr.exists(urls)) {\n                    return true;\n                }\n            } catch (final Throwable e) {\n                Log.logException(e);\n            }\n        }\n        if (this.urlIndexFile == null) return false; // case may happen during shutdown\n        return this.urlIndexFile.has(urlHash);\n    }","commit_id":"3fd4a012861dfb8b7256f5412063a4ebb76043ee","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public boolean remove(final byte[] urlHashBytes) {\n        if (urlHashBytes == null) return false;\n        try {\n            final Row.Entry r = this.urlIndexFile.remove(urlHashBytes);\n            if (r != null) this.statsDump = null;\n            return r != null;\n        } catch (final IOException e) {\n            return false;\n        }\n    }","id":71480,"modified_method":"public boolean remove(final byte[] urlHash) {\n        if (urlHash == null) return false;\n        if (this.localSolr != null || this.remoteSolr != null) {\n            String urls = ASCII.String(urlHash);\n            if (this.localSolr != null) try {\n                this.localSolr.delete(urls);\n            } catch (final Throwable e) {\n                Log.logException(e);\n            }\n            if (this.remoteSolr != null) try {\n                this.remoteSolr.delete(urls);\n            } catch (final Throwable e) {\n                Log.logException(e);\n            }\n        }\n        try {\n            final Row.Entry r = this.urlIndexFile.remove(urlHash);\n            if (r != null) this.statsDump = null;\n            return r != null;\n        } catch (final IOException e) {\n            return false;\n        }\n    }","commit_id":"3fd4a012861dfb8b7256f5412063a4ebb76043ee","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void push(\n            final Request bentry,\n            final byte[] executor,\n            final Date workdate,\n            final int workcount,\n            final FailCategory failCategory,\n            String anycause,\n            final int httpcode) {\n        // assert executor != null; // null == proxy !\n        if (exists(bentry.url().hash())) return; // don't insert double causes\n        if (anycause == null) anycause = \"unknown\";\n        final String reason = anycause + ((httpcode >= 0) ? \" (http return code = \" + httpcode + \")\" : \"\");\n        final Entry entry = new Entry(bentry, executor, workdate, workcount, reason);\n        put(entry);\n        this.stack.add(entry.hash());\n        Log.logInfo(\"Rejected URL\", bentry.url().toNormalform(false, false) + \" - \" + reason);\n        if (this.solrConnector != null && (failCategory == FailCategory.TEMPORARY_NETWORK_FAILURE || failCategory == FailCategory.FINAL_ROBOTS_RULE)) {\n            // send the error to solr\n            try {\n                SolrDoc errorDoc = this.solrConfiguration.err(bentry.url(), failCategory.name() + \" \" + reason, httpcode);\n                this.solrConnector.add(errorDoc);\n            } catch (final IOException e) {\n                Log.logWarning(\"SOLR\", \"failed to send error \" + bentry.url().toNormalform(true, false) + \" to solr: \" + e.getMessage());\n            }\n        }\n        while (this.stack.size() > maxStackSize) this.stack.poll();\n    }","id":71481,"modified_method":"public void push(\n            final Request bentry,\n            final byte[] executor,\n            final Date workdate,\n            final int workcount,\n            final FailCategory failCategory,\n            String anycause,\n            final int httpcode) {\n        // assert executor != null; // null == proxy !\n        assert failCategory.store || httpcode == -1 : \"failCategory=\" + failCategory.name();\n        if (exists(bentry.url().hash())) return; // don't insert double causes\n        if (anycause == null) anycause = \"unknown\";\n        final String reason = anycause + ((httpcode >= 0) ? \" (http return code = \" + httpcode + \")\" : \"\");\n        final Entry entry = new Entry(bentry, executor, workdate, workcount, reason);\n        put(entry);\n        this.stack.add(entry.hash());\n        Log.logInfo(\"Rejected URL\", bentry.url().toNormalform(false, false) + \" - \" + reason);\n        if (this.solrConnector != null && failCategory.store) {\n            // send the error to solr\n            try {\n                SolrDoc errorDoc = this.solrConfiguration.err(bentry.url(), failCategory.name() + \" \" + reason, httpcode);\n                this.solrConnector.add(errorDoc);\n            } catch (final IOException e) {\n                Log.logWarning(\"SOLR\", \"failed to send error \" + bentry.url().toNormalform(true, false) + \" to solr: \" + e.getMessage());\n            }\n        }\n        while (this.stack.size() > maxStackSize) this.stack.poll();\n    }","commit_id":"3fd4a012861dfb8b7256f5412063a4ebb76043ee","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void putProfileEntry(\r\n    \t\tfinal String CRAWL_PROFILE_PREFIX,\r\n            final serverObjects prop,\r\n            final boolean active,\r\n            final boolean dark,\r\n            final int count,\r\n            final int domlistlength) {\r\n        boolean terminateButton = active && !CrawlSwitchboard.DEFAULT_PROFILES.contains(this.name());\r\n        boolean deleteButton = !active;\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_dark\", dark ? \"1\" : \"0\");\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_name\", this.collectionName());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_status\", terminateButton ? 1 : deleteButton ? 0 : 2);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_terminateButton\", terminateButton);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_terminateButton_handle\", this.handle());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_deleteButton\", deleteButton);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_deleteButton_handle\", this.handle());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_handle\", this.handle());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_depth\", this.depth());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_mustmatch\", this.urlMustMatchPattern().toString());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_mustnotmatch\", this.urlMustNotMatchPattern().toString());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_crawlingIfOlder\", (this.recrawlIfOlder() == 0L) ? \"no re-crawl\" : DateFormat.getDateTimeInstance().format(this.recrawlIfOlder()));\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_crawlingDomFilterDepth\", \"inactive\");\r\n\r\n        int i = 0;\r\n        if (active && this.domMaxPages() > 0\r\n                && this.domMaxPages() != Integer.MAX_VALUE) {\r\n        String item;\r\n        while (i <= domlistlength && !(item = this.domName(true, i)).isEmpty()){\r\n            if (i == domlistlength) {\r\n                item += \" ...\";\r\n            }\r\n            prop.putHTML(CRAWL_PROFILE_PREFIX + count + \"_crawlingDomFilterContent_\" + i + \"_item\", item);\r\n            i++;\r\n        }\r\n        }\r\n\r\n        prop.put(CRAWL_PROFILE_PREFIX+count+\"_crawlingDomFilterContent\", i);\r\n\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_crawlingDomMaxPages\", (this.domMaxPages() == Integer.MAX_VALUE) ? \"unlimited\" : Integer.toString(this.domMaxPages()));\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_withQuery\", (this.crawlingQ()) ? \"1\" : \"0\");\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_storeCache\", (this.storeHTCache()) ? \"1\" : \"0\");\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_indexText\", (this.indexText()) ? \"1\" : \"0\");\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_indexMedia\", (this.indexMedia()) ? \"1\" : \"0\");\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_remoteIndexing\", (this.remoteIndexing()) ? \"1\" : \"0\");\r\n    }","id":71482,"modified_method":"public void putProfileEntry(\r\n    \t\tfinal String CRAWL_PROFILE_PREFIX,\r\n            final serverObjects prop,\r\n            final boolean active,\r\n            final boolean dark,\r\n            final int count,\r\n            final int domlistlength) {\r\n        boolean terminateButton = active && !CrawlSwitchboard.DEFAULT_PROFILES.contains(this.name());\r\n        boolean deleteButton = !active;\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_dark\", dark ? \"1\" : \"0\");\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_handle\", this.handle());\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_name\", this.name());\r\n        //prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_collection\", this.get(COLLECTIONS)); // TODO: remove, replace with 'collections'\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_collections\", this.get(COLLECTIONS));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_agentName\", this.get(AGENT_NAME));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_userAgent\", this.getAgent().userAgent);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_depth\", this.depth());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_directDocByURL\", this.directDocByURL() ? 1 : 0);\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_recrawlIfOlder\", this.recrawlIfOlder() == Long.MAX_VALUE ? \"eternity\" : (new Date(this.recrawlIfOlder()).toString()));\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_domMaxPages\", this.domMaxPages());\r\n        //prop.put(CRAWL_PROFILE_PREFIX + count + \"_crawlingDomMaxPages\", (this.domMaxPages() == Integer.MAX_VALUE) ? \"unlimited\" : Integer.toString(this.domMaxPages())); // TODO: remove, replace with 'domMaxPages'\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_crawlingQ\", this.crawlingQ() ? 1 : 0);\r\n        //prop.put(CRAWL_PROFILE_PREFIX + count + \"_withQuery\", (this.crawlingQ()) ? \"1\" : \"0\"); // TODO: remove, replace with crawlingQ\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_followFrames\", this.followFrames() ? 1 : 0);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_obeyHtmlRobotsNoindex\", this.obeyHtmlRobotsNoindex() ? 1 : 0);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_obeyHtmlRobotsNofollow\", this.obeyHtmlRobotsNofollow() ? 1 : 0);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_indexText\", this.indexText() ? 1 : 0);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_indexMedia\", this.indexMedia() ? 1 : 0);\r\n        //prop.put(CRAWL_PROFILE_PREFIX + count + \"_storeCache\", this.storeHTCache() ? 1 : 0); // TODO: remove, replace with 'storeHTCache'\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_storeHTCache\", this.storeHTCache() ? 1 : 0);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_remoteIndexing\", this.remoteIndexing() ? 1 : 0);\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_cacheStrategy\", this.get(CACHE_STRAGEGY));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_crawlerURLMustMatch\", this.get(CRAWLER_URL_MUSTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_crawlerURLMustNotMatch\", this.get(CRAWLER_URL_MUSTNOTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_crawlerIPMustMatch\", this.get(CRAWLER_IP_MUSTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_crawlerIPMustNotMatch\", this.get(CRAWLER_IP_MUSTNOTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_crawlerCountryMustMatch\", this.get(CRAWLER_COUNTRY_MUSTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_crawlerNoLimitURLMustMatch\", this.get(CRAWLER_URL_NODEPTHLIMITMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_indexURLMustMatch\", this.get(INDEXING_URL_MUSTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_indexURLMustNotMatch\", this.get(INDEXING_URL_MUSTNOTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_indexContentMustMatch\", this.get(INDEXING_CONTENT_MUSTMATCH));\r\n        prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_indexContentMustNotMatch\", this.get(INDEXING_CONTENT_MUSTNOTMATCH));\r\n        //prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_mustmatch\", this.urlMustMatchPattern().toString()); // TODO: remove, replace with crawlerURLMustMatch\r\n        //prop.putXML(CRAWL_PROFILE_PREFIX + count + \"_mustnotmatch\", this.urlMustNotMatchPattern().toString()); // TODO: remove, replace with crawlerURLMustNotMatch\r\n        //prop.put(CRAWL_PROFILE_PREFIX + count + \"_crawlingIfOlder\", (this.recrawlIfOlder() == 0L) ? \"no re-crawl\" : DateFormat.getDateTimeInstance().format(this.recrawlIfOlder())); // TODO: remove, replace with recrawlIfOlder\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_crawlingDomFilterDepth\", \"inactive\");\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_status\", terminateButton ? 1 : deleteButton ? 0 : 2);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_terminateButton\", terminateButton);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_terminateButton_handle\", this.handle());\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_deleteButton\", deleteButton);\r\n        prop.put(CRAWL_PROFILE_PREFIX + count + \"_deleteButton_handle\", this.handle());\r\n        \r\n        int i = 0;\r\n        if (active && this.domMaxPages() > 0 && this.domMaxPages() != Integer.MAX_VALUE) {\r\n            String item;\r\n            while (i <= domlistlength && !(item = this.domName(true, i)).isEmpty()) {\r\n                if (i == domlistlength) item += \" ...\";\r\n                prop.putHTML(CRAWL_PROFILE_PREFIX + count + \"_crawlingDomFilterContent_\" + i + \"_item\", item);\r\n                i++;\r\n            }\r\n        }\r\n        prop.put(CRAWL_PROFILE_PREFIX+count+\"_crawlingDomFilterContent\", i);\r\n\r\n    }","commit_id":"d8beafba3ae1044c87b66b4d339afdfc7323c506","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Like {@link #putHTML(String, String)} but takes an extra argument defining, if the returned\n     * String should be used in normal HTML: <code>false<\/code>.\n     * If forXML is <code>true<\/code>, then only the characters <b>&amp; &quot; &lt; &gt;<\/b> will be\n     * replaced in the returned String.\n     */\n    public void putXML(final String key, final String value) {\n        put(key, CharacterCoding.unicode2xml(value, true));\n    }","id":71483,"modified_method":"/**\n     * Like {@link #putHTML(String, String)} but takes an extra argument defining, if the returned\n     * String should be used in normal HTML: <code>false<\/code>.\n     * If forXML is <code>true<\/code>, then only the characters <b>&amp; &quot; &lt; &gt;<\/b> will be\n     * replaced in the returned String.\n     */\n    public void putXML(final String key, final String value) {\n        put(key, value == null ? \"\" : CharacterCoding.unicode2xml(value, true));\n    }","commit_id":"d8beafba3ae1044c87b66b4d339afdfc7323c506","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * Add a String to the map. The content of the String is escaped to be usable in HTML output.\n     * @param key   key name as String.\n     * @param value a String that will be reencoded for HTML output.\n     * @return      the modified String that was added to the map.\n     * @see CharacterCoding#encodeUnicode2html(String, boolean)\n     */\n    public void putHTML(final String key, final String value) {\n        put(key, CharacterCoding.unicode2html(value, true));\n    }","id":71484,"modified_method":"/**\n     * Add a String to the map. The content of the String is escaped to be usable in HTML output.\n     * @param key   key name as String.\n     * @param value a String that will be reencoded for HTML output.\n     * @return      the modified String that was added to the map.\n     * @see CharacterCoding#encodeUnicode2html(String, boolean)\n     */\n    public void putHTML(final String key, final String value) {\n        put(key, value == null ? \"\" : CharacterCoding.unicode2html(value, true));\n    }","commit_id":"d8beafba3ae1044c87b66b4d339afdfc7323c506","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public void putHTML(final String key, final byte[] value) {\n        putHTML(key, UTF8.String(value));\n    }","id":71485,"modified_method":"public void putHTML(final String key, final byte[] value) {\n        putHTML(key, value == null ? \"\" : UTF8.String(value));\n    }","commit_id":"d8beafba3ae1044c87b66b4d339afdfc7323c506","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * put the key/value pair with a special method according to the given file type\n     * @param fileType\n     * @param key\n     * @param value\n     * @return\n     */\n    public void put(final RequestHeader.FileType fileType, final String key, final String value) {\n        if (fileType == FileType.JSON) putJSON(key, value);\n        else if (fileType == FileType.XML) putXML(key, value);\n        else putHTML(key, value);\n    }","id":71486,"modified_method":"/**\n     * put the key/value pair with a special method according to the given file type\n     * @param fileType\n     * @param key\n     * @param value\n     * @return\n     */\n    public void put(final RequestHeader.FileType fileType, final String key, final String value) {\n        if (fileType == FileType.JSON) putJSON(key, value == null ? \"\" : value);\n        else if (fileType == FileType.XML) putXML(key, value == null ? \"\" : value);\n        else putHTML(key, value == null ? \"\" : value);\n    }","commit_id":"d8beafba3ae1044c87b66b4d339afdfc7323c506","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private RobotsTxtEntry getEntry(final MultiProtocolURI theURL, final Set<String> thisAgents, final boolean fetchOnlineIfNotAvailableOrNotFresh) throws IOException {\r\n            // this method will always return a non-null value\r\n        final String urlHostPort = getHostPort(theURL);\r\n        RobotsTxtEntry robotsTxt4Host = null;\r\n        Map<String, byte[]> record;\r\n        final BEncodedHeap robotsTable = this.tables.getHeap(WorkTables.TABLE_ROBOTS_NAME);\r\n        try {\r\n            record = robotsTable.get(robotsTable.encodedKey(urlHostPort));\r\n        } catch (final RowSpaceExceededException e) {\r\n            log.warn(\"memory exhausted\", e);\r\n            record = null;\r\n        }\r\n        if (record != null) robotsTxt4Host = new RobotsTxtEntry(urlHostPort, record);\r\n\r\n        if (fetchOnlineIfNotAvailableOrNotFresh && (\r\n             robotsTxt4Host == null ||\r\n             robotsTxt4Host.getLoadedDate() == null ||\r\n             System.currentTimeMillis() - robotsTxt4Host.getLoadedDate().getTime() > 7*24*60*60*1000\r\n           )) {\r\n\r\n            // make or get a synchronization object\r\n        \tDomSync syncObj = this.syncObjects.get(urlHostPort);\r\n            if (syncObj == null) {\r\n                syncObj = new DomSync();\r\n                this.syncObjects.put(urlHostPort, syncObj);\r\n            }\r\n\r\n            // we can now synchronize for each host separately\r\n            synchronized (syncObj) {\r\n\r\n                // if we have not found any data or the data is older than 7 days, we need to load it from the remote server\r\n\r\n                // check the robots table again for all threads that come here because they waited for another one\r\n                // to complete a download\r\n                try {\r\n                    record = robotsTable.get(robotsTable.encodedKey(urlHostPort));\r\n                } catch (final RowSpaceExceededException e) {\r\n                    log.warn(\"memory exhausted\", e);\r\n                    record = null;\r\n                }\r\n                if (record != null) robotsTxt4Host = new RobotsTxtEntry(urlHostPort, record);\r\n                if (robotsTxt4Host != null &&\r\n                    robotsTxt4Host.getLoadedDate() != null &&\r\n                    System.currentTimeMillis() - robotsTxt4Host.getLoadedDate().getTime() <= 1*24*60*60*1000) {\r\n                    return robotsTxt4Host;\r\n                }\r\n\r\n                // generating the proper url to download the robots txt\r\n                MultiProtocolURI robotsURL = null;\r\n                try {\r\n                    robotsURL = new MultiProtocolURI(\"http://\" + urlHostPort + \"/robots.txt\");\r\n                } catch (final MalformedURLException e) {\r\n                    log.fatal(\"Unable to generate robots.txt URL for host:port '\" + urlHostPort + \"'.\", e);\r\n                    robotsURL = null;\r\n                }\r\n\r\n                Object[] result = null;\r\n                if (robotsURL != null) {\r\n                    if (log.isDebugEnabled()) log.debug(\"Trying to download the robots.txt file from URL '\" + robotsURL + \"'.\");\r\n                    try {\r\n                        result = downloadRobotsTxt(robotsURL, 3, robotsTxt4Host);\r\n                    } catch (final Exception e) {\r\n                        result = null;\r\n                    }\r\n                }\r\n                /*\r\n                assert !loadedRobots.contains(robotsURL.toNormalform(false, false)) :\r\n                    \"robots-url=\" + robotsURL.toString() +\r\n                    \", robots=\" + ((result == null || result[DOWNLOAD_ROBOTS_TXT] == null) ? \"NULL\" : UTF8.String((byte[]) result[DOWNLOAD_ROBOTS_TXT])) +\r\n                    \", robotsTxt4Host=\" + ((robotsTxt4Host == null) ? \"NULL\" : robotsTxt4Host.getLoadedDate().toString());\r\n                loadedRobots.add(robotsURL.toNormalform(false, false));\r\n                */\r\n\r\n                if (result == null) {\r\n                    // no robots.txt available, make an entry to prevent that the robots loading is done twice\r\n                    if (robotsTxt4Host == null) {\r\n                        // generate artificial entry\r\n                        robotsTxt4Host = new RobotsTxtEntry(\r\n                                robotsURL,\r\n                                new ArrayList<String>(),\r\n                                new ArrayList<String>(),\r\n                                new Date(),\r\n                                new Date(),\r\n                                null,\r\n                                null,\r\n                                Integer.valueOf(0),\r\n                                null);\r\n                    } else {\r\n                        robotsTxt4Host.setLoadedDate(new Date());\r\n                    }\r\n\r\n                    // store the data into the robots DB\r\n                    final int sz = robotsTable.size();\r\n                    addEntry(robotsTxt4Host);\r\n                    if (robotsTable.size() <= sz) {\r\n                    \tlog.fatal(\"new entry in robots.txt table failed, resetting database\");\r\n                    \tclear();\r\n                    \taddEntry(robotsTxt4Host);\r\n                    }\r\n                } else {\r\n                    final byte[] robotsTxt = (byte[]) result[DOWNLOAD_ROBOTS_TXT];\r\n                    Log.logInfo(\"RobotsTxt\", \"robots of \" + robotsURL.toNormalform(true, true) + \":\\n\" + UTF8.String(robotsTxt)); // debug TODO remove\r\n                    final RobotsTxtParser parserResult = new RobotsTxtParser(robotsTxt, thisAgents);\r\n                    ArrayList<String> denyPath = parserResult.denyList();\r\n                    if (((Boolean) result[DOWNLOAD_ACCESS_RESTRICTED]).booleanValue()) {\r\n                        denyPath = new ArrayList<String>();\r\n                        denyPath.add(\"/\");\r\n                    }\r\n\r\n                    // store the data into the robots DB\r\n                    robotsTxt4Host = addEntry(\r\n                            robotsURL,\r\n                            parserResult.allowList(),\r\n                            denyPath,\r\n                            new Date(),\r\n                            (Date) result[DOWNLOAD_MODDATE],\r\n                            (String) result[DOWNLOAD_ETAG],\r\n                            parserResult.sitemap(),\r\n                            parserResult.crawlDelayMillis(),\r\n                            parserResult.agentName());\r\n                }\r\n            }\r\n        }\r\n\r\n        return robotsTxt4Host;\r\n    }","id":71487,"modified_method":"private RobotsTxtEntry getEntry(final MultiProtocolURI theURL, final Set<String> thisAgents, final boolean fetchOnlineIfNotAvailableOrNotFresh) throws IOException {\r\n            // this method will always return a non-null value\r\n        final String urlHostPort = getHostPort(theURL);\r\n        RobotsTxtEntry robotsTxt4Host = null;\r\n        Map<String, byte[]> record;\r\n        final BEncodedHeap robotsTable = this.tables.getHeap(WorkTables.TABLE_ROBOTS_NAME);\r\n        try {\r\n            record = robotsTable.get(robotsTable.encodedKey(urlHostPort));\r\n        } catch (final RowSpaceExceededException e) {\r\n            log.warn(\"memory exhausted\", e);\r\n            record = null;\r\n        }\r\n        if (record != null) robotsTxt4Host = new RobotsTxtEntry(urlHostPort, record);\r\n\r\n        if (fetchOnlineIfNotAvailableOrNotFresh && (\r\n             robotsTxt4Host == null ||\r\n             robotsTxt4Host.getLoadedDate() == null ||\r\n             System.currentTimeMillis() - robotsTxt4Host.getLoadedDate().getTime() > 7*24*60*60*1000\r\n           )) {\r\n\r\n            // make or get a synchronization object\r\n        \tDomSync syncObj = this.syncObjects.get(urlHostPort);\r\n            if (syncObj == null) {\r\n                syncObj = new DomSync();\r\n                this.syncObjects.put(urlHostPort, syncObj);\r\n            }\r\n\r\n            // we can now synchronize for each host separately\r\n            synchronized (syncObj) {\r\n\r\n                // if we have not found any data or the data is older than 7 days, we need to load it from the remote server\r\n\r\n                // check the robots table again for all threads that come here because they waited for another one\r\n                // to complete a download\r\n                try {\r\n                    record = robotsTable.get(robotsTable.encodedKey(urlHostPort));\r\n                } catch (final RowSpaceExceededException e) {\r\n                    log.warn(\"memory exhausted\", e);\r\n                    record = null;\r\n                }\r\n                if (record != null) robotsTxt4Host = new RobotsTxtEntry(urlHostPort, record);\r\n                if (robotsTxt4Host != null &&\r\n                    robotsTxt4Host.getLoadedDate() != null &&\r\n                    System.currentTimeMillis() - robotsTxt4Host.getLoadedDate().getTime() <= 1*24*60*60*1000) {\r\n                    return robotsTxt4Host;\r\n                }\r\n\r\n                // generating the proper url to download the robots txt\r\n                MultiProtocolURI robotsURL = null;\r\n                try {\r\n                    robotsURL = new MultiProtocolURI(\"http://\" + urlHostPort + \"/robots.txt\");\r\n                } catch (final MalformedURLException e) {\r\n                    log.fatal(\"Unable to generate robots.txt URL for host:port '\" + urlHostPort + \"'.\", e);\r\n                    robotsURL = null;\r\n                }\r\n\r\n                Object[] result = null;\r\n                if (robotsURL != null) {\r\n                    if (log.isDebugEnabled()) log.debug(\"Trying to download the robots.txt file from URL '\" + robotsURL + \"'.\");\r\n                    try {\r\n                        result = downloadRobotsTxt(robotsURL, 3, robotsTxt4Host);\r\n                    } catch (final Exception e) {\r\n                        result = null;\r\n                    }\r\n                }\r\n                /*\r\n                assert !loadedRobots.contains(robotsURL.toNormalform(false, false)) :\r\n                    \"robots-url=\" + robotsURL.toString() +\r\n                    \", robots=\" + ((result == null || result[DOWNLOAD_ROBOTS_TXT] == null) ? \"NULL\" : UTF8.String((byte[]) result[DOWNLOAD_ROBOTS_TXT])) +\r\n                    \", robotsTxt4Host=\" + ((robotsTxt4Host == null) ? \"NULL\" : robotsTxt4Host.getLoadedDate().toString());\r\n                loadedRobots.add(robotsURL.toNormalform(false, false));\r\n                */\r\n\r\n                if (result == null) {\r\n                    // no robots.txt available, make an entry to prevent that the robots loading is done twice\r\n                    if (robotsTxt4Host == null) {\r\n                        // generate artificial entry\r\n                        robotsTxt4Host = new RobotsTxtEntry(\r\n                                robotsURL,\r\n                                new ArrayList<String>(),\r\n                                new ArrayList<String>(),\r\n                                new Date(),\r\n                                new Date(),\r\n                                null,\r\n                                null,\r\n                                Integer.valueOf(0),\r\n                                null);\r\n                    } else {\r\n                        robotsTxt4Host.setLoadedDate(new Date());\r\n                    }\r\n\r\n                    // store the data into the robots DB\r\n                    final int sz = robotsTable.size();\r\n                    addEntry(robotsTxt4Host);\r\n                    if (robotsTable.size() <= sz) {\r\n                    \tlog.fatal(\"new entry in robots.txt table failed, resetting database\");\r\n                    \tclear();\r\n                    \taddEntry(robotsTxt4Host);\r\n                    }\r\n                } else {\r\n                    final byte[] robotsTxt = (byte[]) result[DOWNLOAD_ROBOTS_TXT];\r\n                    Log.logInfo(\"RobotsTxt\", \"robots of \" + robotsURL.toNormalform(true, true) + \":\\n\" + ((robotsTxt == null) ? \"null\" : UTF8.String(robotsTxt))); // debug TODO remove\r\n                    RobotsTxtParser parserResult;\r\n                    ArrayList<String> denyPath;\r\n                    if (((Boolean) result[DOWNLOAD_ACCESS_RESTRICTED]).booleanValue()) {\r\n                        parserResult = new RobotsTxtParser(thisAgents);\r\n                        // create virtual deny path\r\n                        denyPath = new ArrayList<String>();\r\n                        denyPath.add(\"/\");\r\n                    } else {\r\n                        parserResult = new RobotsTxtParser(thisAgents, robotsTxt);\r\n                        denyPath = parserResult.denyList();\r\n                    }\r\n\r\n                    // store the data into the robots DB\r\n                    robotsTxt4Host = addEntry(\r\n                            robotsURL,\r\n                            parserResult.allowList(),\r\n                            denyPath,\r\n                            new Date(),\r\n                            (Date) result[DOWNLOAD_MODDATE],\r\n                            (String) result[DOWNLOAD_ETAG],\r\n                            parserResult.sitemap(),\r\n                            parserResult.crawlDelayMillis(),\r\n                            parserResult.agentName());\r\n                }\r\n            }\r\n        }\r\n\r\n        return robotsTxt4Host;\r\n    }","commit_id":"458c20ff729bce4bb34bac2b93491b43baf91c65","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private StringBuilder corePropList() {\r\n        // generate a parseable string; this is a simple property-list\r\n        final Components metadata = metadata();\r\n        final StringBuilder s = new StringBuilder(300);\r\n        if (metadata == null) return null;\r\n        //System.out.println(\"author=\" + comp.author());\r\n\r\n        // create new formatters to make concurrency possible\r\n        final GenericFormatter formatter = new GenericFormatter(GenericFormatter.FORMAT_SHORT_DAY, GenericFormatter.time_minute);\r\n\r\n        try {\r\n            s.append(\"hash=\").append(ASCII.String(hash()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",url=\").append(crypt.simpleEncode(metadata.url().toNormalform(false, true)));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",descr=\").append(crypt.simpleEncode(metadata.dc_title()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",author=\").append(crypt.simpleEncode(metadata.dc_creator()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",tags=\").append(crypt.simpleEncode(metadata.dc_subject()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",publisher=\").append(crypt.simpleEncode(metadata.dc_publisher()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lat=\").append(metadata.lat());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lon=\").append(metadata.lon());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",mod=\").append(formatter.format(moddate()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",load=\").append(formatter.format(loaddate()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",fresh=\").append(formatter.format(freshdate()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",referrer=\").append(referrerHash() == null ? \"\" : ASCII.String(referrerHash()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",md5=\").append(md5());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",size=\").append(size());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",wc=\").append(wordCount());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",dt=\").append(doctype());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",flags=\").append(flags().exportB64());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lang=\").append(UTF8.String(language()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",llocal=\").append(llocal());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lother=\").append(lother());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",limage=\").append(limage());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",laudio=\").append(laudio());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lvideo=\").append(lvideo());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lapp=\").append(lapp());\r\n            assert (s.toString().indexOf(0) < 0);\r\n\r\n            if (this.word != null) {\r\n                // append also word properties\r\n                final String wprop = this.word.toPropertyForm();\r\n                s.append(\",wi=\").append(Base64Order.enhancedCoder.encodeString(wprop));\r\n            }\r\n            assert (s.toString().indexOf(0) < 0);\r\n            return s;\r\n\r\n        } catch (final Throwable e) {\r\n            //          serverLog.logFailure(\"plasmaLURL.corePropList\", e.getMessage());\r\n            //          if (moddate == null) serverLog.logFailure(\"plasmaLURL.corePropList\", \"moddate=null\");\r\n            //          if (loaddate == null) serverLog.logFailure(\"plasmaLURL.corePropList\", \"loaddate=null\");\r\n            Log.logException(e);\r\n            return null;\r\n        }\r\n    }","id":71488,"modified_method":"private StringBuilder corePropList() {\r\n        // generate a parseable string; this is a simple property-list\r\n        final Components metadata = metadata();\r\n        final StringBuilder s = new StringBuilder(300);\r\n        if (metadata == null) return null;\r\n        //System.out.println(\"author=\" + comp.author());\r\n\r\n        // create new formatters to make concurrency possible\r\n        final GenericFormatter formatter = new GenericFormatter(GenericFormatter.FORMAT_SHORT_DAY, GenericFormatter.time_minute);\r\n\r\n        try {\r\n            s.append(\"hash=\").append(ASCII.String(hash()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",url=\").append(crypt.simpleEncode(metadata.url().toNormalform(false, true)));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",descr=\").append(crypt.simpleEncode(metadata.dc_title()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",author=\").append(crypt.simpleEncode(metadata.dc_creator()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",tags=\").append(crypt.simpleEncode(metadata.dc_subject()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",publisher=\").append(crypt.simpleEncode(metadata.dc_publisher()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lat=\").append(metadata.lat());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lon=\").append(metadata.lon());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",mod=\").append(formatter.format(moddate()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",load=\").append(formatter.format(loaddate()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",fresh=\").append(formatter.format(freshdate()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",referrer=\").append(referrerHash() == null ? \"\" : ASCII.String(referrerHash()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",md5=\").append(md5());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",size=\").append(size());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",wc=\").append(wordCount());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",dt=\").append(doctype());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",flags=\").append(flags().exportB64());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lang=\").append(language() == null ? \"EN\" : UTF8.String(language()));\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",llocal=\").append(llocal());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lother=\").append(lother());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",limage=\").append(limage());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",laudio=\").append(laudio());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lvideo=\").append(lvideo());\r\n            assert (s.toString().indexOf(0) < 0);\r\n            s.append(\",lapp=\").append(lapp());\r\n            assert (s.toString().indexOf(0) < 0);\r\n\r\n            if (this.word != null) {\r\n                // append also word properties\r\n                final String wprop = this.word.toPropertyForm();\r\n                s.append(\",wi=\").append(Base64Order.enhancedCoder.encodeString(wprop));\r\n            }\r\n            assert (s.toString().indexOf(0) < 0);\r\n            return s;\r\n\r\n        } catch (final Throwable e) {\r\n            //          serverLog.logFailure(\"plasmaLURL.corePropList\", e.getMessage());\r\n            //          if (moddate == null) serverLog.logFailure(\"plasmaLURL.corePropList\", \"moddate=null\");\r\n            //          if (loaddate == null) serverLog.logFailure(\"plasmaLURL.corePropList\", \"loaddate=null\");\r\n            Log.logException(e);\r\n            return null;\r\n        }\r\n    }","commit_id":"709013385a7208e0ea6e72089d3d774a5664735a","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public ClientGetMessage(SimpleFieldSet fs) throws MessageInvalidException {\n\t\tshort defaultPriority;\n\t\tif(fs.get(\"IgnoreDS\").equalsIgnoreCase(\"true\")){\n\t\t\tignoreDS=true;\n\t\t}else{\n\t\t\tignoreDS=false;\n\t\t}\n\t\tif(fs.get(\"DSOnly\").equalsIgnoreCase(\"true\")){\n\t\t\tdsOnly=true;\n\t\t}else{\n\t\t\tdsOnly=false;\n\t\t}\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null)\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No Identifier\", null);\n\t\ttry {\n\t\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.URI_PARSE_ERROR, e.getMessage(), identifier);\n\t\t}\n\t\tString verbosityString = fs.get(\"Verbosity\");\n\t\tif(verbosityString == null)\n\t\t\tverbosity = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tverbosity = Integer.parseInt(verbosityString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Verbosity field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString returnTypeString = fs.get(\"ReturnType\");\n\t\tif(returnTypeString == null || returnTypeString.equalsIgnoreCase(\"direct\")) {\n\t\t\treturnType = RETURN_TYPE_DIRECT;\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\t// default just below fproxy\n\t\t\tdefaultPriority = RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS;\n\t\t} else if(returnTypeString.equalsIgnoreCase(\"none\")) {\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\treturnType = RETURN_TYPE_NONE;\n\t\t\tdefaultPriority = RequestStarter.PREFETCH_PRIORITY_CLASS;\n\t\t} else if(returnTypeString.equalsIgnoreCase(\"disk\")) {\n\t\t\tdefaultPriority = RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS;\n\t\t\treturnType = RETURN_TYPE_DISK;\n\t\t\tString filename = fs.get(\"Filename\");\n\t\t\tif(filename == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Missing Filename\", identifier);\n\t\t\tdiskFile = new File(filename);\n\t\t\tString tempFilename = fs.get(\"TempFilename\");\n\t\t\tif(tempFilename == null)\n\t\t\t\ttempFilename = filename + \".freenet-tmp\";\n\t\t\ttempFile = new File(tempFilename);\n\t\t\tif(!diskFile.getParentFile().equals(tempFile.getParentFile()))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.FILENAME_AND_TEMP_FILENAME_MUST_BE_IN_SAME_DIR, null, identifier);\n\t\t\tif(diskFile.exists())\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.DISK_TARGET_EXISTS, null, identifier);\n\t\t\ttry {\n\t\t\t\tif(!tempFile.createNewFile())\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, null, identifier);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, e.getMessage(), identifier);\n\t\t\t}\n\t\t} else\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MESSAGE_PARSE_ERROR, \"Unknown return-type\", identifier);\n\t\tString maxSizeString = fs.get(\"MaxSize\");\n\t\tif(maxSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxSize = Long.parseLong(maxSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxTempSizeString = fs.get(\"MaxTempSize\");\n\t\tif(maxTempSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxTempSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxTempSize = Long.parseLong(maxTempSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxRetriesString = fs.get(\"MaxRetries\");\n\t\tif(maxRetriesString == null)\n\t\t\t// default to 0\n\t\t\tmaxRetries = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxRetries = Integer.parseInt(maxRetriesString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString priorityString = fs.get(\"PriorityClass\");\n\t\tif(priorityString == null) {\n\t\t\t// defaults to the one just below fproxy\n\t\t\tpriorityClass = defaultPriority;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tpriorityClass = Short.parseShort(priorityString, 10);\n\t\t\t\tif(priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS || priorityClass > RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_FIELD, \"Valid priorities are from \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" to \"+RequestStarter.MINIMUM_PRIORITY_CLASS, identifier);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing PriorityClass field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t}","id":71489,"modified_method":"public ClientGetMessage(SimpleFieldSet fs) throws MessageInvalidException {\n\t\tshort defaultPriority;\n\t\tignoreDS = Fields.stringToBool(fs.get(\"IgnoreDS\"), false);\n\t\tdsOnly = Fields.stringToBool(fs.get(\"DSOnly\"), false);\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null)\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No Identifier\", null);\n\t\ttry {\n\t\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.URI_PARSE_ERROR, e.getMessage(), identifier);\n\t\t}\n\t\tString verbosityString = fs.get(\"Verbosity\");\n\t\tif(verbosityString == null)\n\t\t\tverbosity = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tverbosity = Integer.parseInt(verbosityString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Verbosity field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString returnTypeString = fs.get(\"ReturnType\");\n\t\tif(returnTypeString == null || returnTypeString.equalsIgnoreCase(\"direct\")) {\n\t\t\treturnType = RETURN_TYPE_DIRECT;\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\t// default just below fproxy\n\t\t\tdefaultPriority = RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS;\n\t\t} else if(returnTypeString.equalsIgnoreCase(\"none\")) {\n\t\t\tdiskFile = null;\n\t\t\ttempFile = null;\n\t\t\treturnType = RETURN_TYPE_NONE;\n\t\t\tdefaultPriority = RequestStarter.PREFETCH_PRIORITY_CLASS;\n\t\t} else if(returnTypeString.equalsIgnoreCase(\"disk\")) {\n\t\t\tdefaultPriority = RequestStarter.BULK_SPLITFILE_PRIORITY_CLASS;\n\t\t\treturnType = RETURN_TYPE_DISK;\n\t\t\tString filename = fs.get(\"Filename\");\n\t\t\tif(filename == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Missing Filename\", identifier);\n\t\t\tdiskFile = new File(filename);\n\t\t\tString tempFilename = fs.get(\"TempFilename\");\n\t\t\tif(tempFilename == null)\n\t\t\t\ttempFilename = filename + \".freenet-tmp\";\n\t\t\ttempFile = new File(tempFilename);\n\t\t\tif(!diskFile.getParentFile().equals(tempFile.getParentFile()))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.FILENAME_AND_TEMP_FILENAME_MUST_BE_IN_SAME_DIR, null, identifier);\n\t\t\tif(diskFile.exists())\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.DISK_TARGET_EXISTS, null, identifier);\n\t\t\ttry {\n\t\t\t\tif(!tempFile.createNewFile())\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, null, identifier);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.COULD_NOT_CREATE_FILE, e.getMessage(), identifier);\n\t\t\t}\n\t\t} else\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MESSAGE_PARSE_ERROR, \"Unknown return-type\", identifier);\n\t\tString maxSizeString = fs.get(\"MaxSize\");\n\t\tif(maxSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxSize = Long.parseLong(maxSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxTempSizeString = fs.get(\"MaxTempSize\");\n\t\tif(maxTempSizeString == null)\n\t\t\t// default to unlimited\n\t\t\tmaxTempSize = Long.MAX_VALUE;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxTempSize = Long.parseLong(maxTempSizeString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString maxRetriesString = fs.get(\"MaxRetries\");\n\t\tif(maxRetriesString == null)\n\t\t\t// default to 0\n\t\t\tmaxRetries = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxRetries = Integer.parseInt(maxRetriesString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString priorityString = fs.get(\"PriorityClass\");\n\t\tif(priorityString == null) {\n\t\t\t// defaults to the one just below fproxy\n\t\t\tpriorityClass = defaultPriority;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tpriorityClass = Short.parseShort(priorityString, 10);\n\t\t\t\tif(priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS || priorityClass > RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_FIELD, \"Valid priorities are from \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" to \"+RequestStarter.MINIMUM_PRIORITY_CLASS, identifier);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing PriorityClass field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t}","commit_id":"c76e66320637c9e8c51b294047e6cecb45bc9066","url":"https://github.com/freenet/fred"},{"original_method":"public ClientPutMessage(SimpleFieldSet fs) throws MessageInvalidException {\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null)\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No Identifier\", null);\n\t\ttry {\n\t\t\tString u = fs.get(\"URI\");\n\t\t\tif(u == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No URI\", identifier);\n\t\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.URI_PARSE_ERROR, e.getMessage(), identifier);\n\t\t}\n\t\tString verbosityString = fs.get(\"Verbosity\");\n\t\tif(verbosityString == null)\n\t\t\tverbosity = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tverbosity = Integer.parseInt(verbosityString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Verbosity field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tcontentType = fs.get(\"Metadata.ContentType\");\n\t\tString maxRetriesString = fs.get(\"MaxRetries\");\n\t\tif(maxRetriesString == null)\n\t\t\t// default to 0\n\t\t\tmaxRetries = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxRetries = Integer.parseInt(maxRetriesString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tif(fs.get(\"GetCHKOnly\").equalsIgnoreCase(\"true\")){\n\t\t\tgetCHKOnly=true;\n\t\t}else{\n\t\t\tgetCHKOnly=false;\n\t\t}\n\t\tString priorityString = fs.get(\"PriorityClass\");\n\t\tif(priorityString == null) {\n\t\t\t// defaults to the one just below fproxy\n\t\t\tpriorityClass = RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tpriorityClass = Short.parseShort(priorityString, 10);\n\t\t\t\tif(priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS || priorityClass > RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_FIELD, \"Valid priorities are from \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" to \"+RequestStarter.MINIMUM_PRIORITY_CLASS, identifier);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing PriorityClass field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString uploadFrom = fs.get(\"UploadFrom\");\n\t\tif(uploadFrom != null && uploadFrom.equalsIgnoreCase(\"disk\")) {\n\t\t\tfromDisk = true;\n\t\t\tString filename = fs.get(\"Filename\");\n\t\t\tif(filename == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Missing field Filename\", identifier);\n\t\t\tFile f = new File(filename);\n\t\t\tif(!(f.exists() && f.isFile() && f.canRead()))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.FILE_NOT_FOUND, null, identifier);\n\t\t\tdataLength = f.length();\n\t\t\tFileBucket fileBucket = new FileBucket(f, true, false, false);\n\t\t\tthis.bucket = fileBucket;\n\t\t} else {\n\t\t\tfromDisk = false;\n\t\t\tString dataLengthString = fs.get(\"DataLength\");\n\t\t\tif(dataLengthString == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Need DataLength on a ClientPut\", identifier);\n\t\t\ttry {\n\t\t\t\tdataLength = Long.parseLong(dataLengthString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing DataLength field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tif(fs.get(\"DontCompress\").equalsIgnoreCase(\"true\")){\n\t\t\tdontCompress=true;\n\t\t}else{\n\t\t\tdontCompress=false;\n\t\t}\n\t}","id":71490,"modified_method":"public ClientPutMessage(SimpleFieldSet fs) throws MessageInvalidException {\n\t\tidentifier = fs.get(\"Identifier\");\n\t\tif(identifier == null)\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No Identifier\", null);\n\t\ttry {\n\t\t\tString u = fs.get(\"URI\");\n\t\t\tif(u == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"No URI\", identifier);\n\t\t\turi = new FreenetURI(fs.get(\"URI\"));\n\t\t} catch (MalformedURLException e) {\n\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.URI_PARSE_ERROR, e.getMessage(), identifier);\n\t\t}\n\t\tString verbosityString = fs.get(\"Verbosity\");\n\t\tif(verbosityString == null)\n\t\t\tverbosity = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tverbosity = Integer.parseInt(verbosityString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing Verbosity field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tcontentType = fs.get(\"Metadata.ContentType\");\n\t\tString maxRetriesString = fs.get(\"MaxRetries\");\n\t\tif(maxRetriesString == null)\n\t\t\t// default to 0\n\t\t\tmaxRetries = 0;\n\t\telse {\n\t\t\ttry {\n\t\t\t\tmaxRetries = Integer.parseInt(maxRetriesString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing MaxSize field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tgetCHKOnly = Fields.stringToBool(fs.get(\"GetCHKOnly\"), false);\n\t\tString priorityString = fs.get(\"PriorityClass\");\n\t\tif(priorityString == null) {\n\t\t\t// defaults to the one just below fproxy\n\t\t\tpriorityClass = RequestStarter.IMMEDIATE_SPLITFILE_PRIORITY_CLASS;\n\t\t} else {\n\t\t\ttry {\n\t\t\t\tpriorityClass = Short.parseShort(priorityString, 10);\n\t\t\t\tif(priorityClass < RequestStarter.MAXIMUM_PRIORITY_CLASS || priorityClass > RequestStarter.MINIMUM_PRIORITY_CLASS)\n\t\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.INVALID_FIELD, \"Valid priorities are from \"+RequestStarter.MAXIMUM_PRIORITY_CLASS+\" to \"+RequestStarter.MINIMUM_PRIORITY_CLASS, identifier);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing PriorityClass field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tString uploadFrom = fs.get(\"UploadFrom\");\n\t\tif(uploadFrom != null && uploadFrom.equalsIgnoreCase(\"disk\")) {\n\t\t\tfromDisk = true;\n\t\t\tString filename = fs.get(\"Filename\");\n\t\t\tif(filename == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Missing field Filename\", identifier);\n\t\t\tFile f = new File(filename);\n\t\t\tif(!(f.exists() && f.isFile() && f.canRead()))\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.FILE_NOT_FOUND, null, identifier);\n\t\t\tdataLength = f.length();\n\t\t\tFileBucket fileBucket = new FileBucket(f, true, false, false);\n\t\t\tthis.bucket = fileBucket;\n\t\t} else {\n\t\t\tfromDisk = false;\n\t\t\tString dataLengthString = fs.get(\"DataLength\");\n\t\t\tif(dataLengthString == null)\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.MISSING_FIELD, \"Need DataLength on a ClientPut\", identifier);\n\t\t\ttry {\n\t\t\t\tdataLength = Long.parseLong(dataLengthString, 10);\n\t\t\t} catch (NumberFormatException e) {\n\t\t\t\tthrow new MessageInvalidException(ProtocolErrorMessage.ERROR_PARSING_NUMBER, \"Error parsing DataLength field: \"+e.getMessage(), identifier);\n\t\t\t}\n\t\t}\n\t\tdontCompress = Fields.stringToBool(fs.get(\"DontCompress\"), false);\n\t}","commit_id":"c76e66320637c9e8c51b294047e6cecb45bc9066","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Finds the boolean value of the field, by doing a caseless match with the\n\t * strings \"true\" and \"false\".\n\t * \n\t * @param s\n\t *            The string\n\t * @param def\n\t *            The default value if the string can't be parsed. If the\n\t *            default is true, it checks that the string is not \"false\"; if\n\t *            it is false, it checks whether the string is \"true\".\n\t * @return the boolean field value or the default value if the field value\n\t *         couldn't be parsed.\n\t */\n\t/* wooo, rocket science! (this is purely abstraction people) */\n\tpublic static final boolean stringToBool(String s, boolean def) {\n\t\treturn (\n\t\t\tdef ? !s.equalsIgnoreCase(\"false\") : s.equalsIgnoreCase(\"true\"));\n\t}","id":71491,"modified_method":"/**\n\t * Finds the boolean value of the field, by doing a caseless match with the\n\t * strings \"true\" and \"false\".\n\t * \n\t * @param s\n\t *            The string\n\t * @param def\n\t *            The default value if the string can't be parsed. If the\n\t *            default is true, it checks that the string is not \"false\"; if\n\t *            it is false, it checks whether the string is \"true\".\n\t * @return the boolean field value or the default value if the field value\n\t *         couldn't be parsed.\n\t */\n\t/* wooo, rocket science! (this is purely abstraction people) */\n\tpublic static final boolean stringToBool(String s, boolean def) {\n\t\tif(s == null) return def;\n\t\treturn (def ? !s.equalsIgnoreCase(\"false\") : s.equalsIgnoreCase(\"true\"));\n\t}","commit_id":"c76e66320637c9e8c51b294047e6cecb45bc9066","url":"https://github.com/freenet/fred"},{"original_method":"private boolean hasTriggerChanged(Trigger oldTrigger, Trigger newTrigger) {\n        if (oldTrigger instanceof CronTrigger && oldTrigger.equals(newTrigger)) {\n            CronTrigger oldCron = (CronTrigger) oldTrigger;\n            CronTrigger newCron = (CronTrigger) newTrigger;\n            return !oldCron.getCronExpression().equals(newCron.getCronExpression());\n        } else {\n            return !newTrigger.equals(oldTrigger);\n        }\n    }","id":71492,"modified_method":"private static boolean hasTriggerChanged(Trigger oldTrigger, Trigger newTrigger) {\n        if (newTrigger instanceof CronTrigger && oldTrigger instanceof CronTrigger) {\n            CronTrigger newCron = (CronTrigger) newTrigger;\n            CronTrigger oldCron = (CronTrigger) oldTrigger;\n            return !newCron.getCronExpression().equals(oldCron.getCronExpression());\n        } else if (newTrigger instanceof SimpleTrigger && oldTrigger instanceof SimpleTrigger) {\n            SimpleTrigger newSimple = (SimpleTrigger) newTrigger;\n            SimpleTrigger oldSimple = (SimpleTrigger) oldTrigger;\n            return newSimple.getRepeatInterval() != oldSimple.getRepeatInterval()\n                    || newSimple.getRepeatCount() != oldSimple.getRepeatCount();\n        } else {\n            return !newTrigger.getClass().equals(oldTrigger.getClass()) || !newTrigger.equals(oldTrigger);\n        }\n    }","commit_id":"a73465be206913a4d96549c2ec50d173d09f0a5b","url":"https://github.com/apache/camel"},{"original_method":"private void addJobInScheduler() throws Exception {\n        // Add or use existing trigger to/from scheduler\n        Scheduler scheduler = getComponent().getScheduler();\n        JobDetail jobDetail;\n        Trigger trigger = scheduler.getTrigger(triggerKey);\n        if (trigger == null) {\n            jobDetail = createJobDetail();\n            trigger = createTrigger(jobDetail);\n\n            QuartzHelper.updateJobDataMap(getCamelContext(), jobDetail, getEndpointUri());\n\n            // Schedule it now. Remember that scheduler might not be started it, but we can schedule now.\n            Date nextFireDate = scheduler.scheduleJob(jobDetail, trigger);\n            if (LOG.isInfoEnabled()) {\n                LOG.info(\"Job {} (triggerType={}, jobClass={}) is scheduled. Next fire date is {}\",\n                         new Object[] {trigger.getKey(), trigger.getClass().getSimpleName(),\n                                       jobDetail.getJobClass().getSimpleName(), nextFireDate});\n            }\n        } else {\n            ensureNoDupTriggerKey();\n        }\n\n        // Increase camel job count for this endpoint\n        AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT);\n        if (number != null) {\n            number.incrementAndGet();\n        }\n\n        jobAdded.set(true);\n    }","id":71493,"modified_method":"private void addJobInScheduler() throws Exception {\n        // Add or use existing trigger to/from scheduler\n        Scheduler scheduler = getComponent().getScheduler();\n        JobDetail jobDetail;\n        Trigger oldTrigger = scheduler.getTrigger(triggerKey);\n        boolean triggerExisted = oldTrigger != null;\n        if (triggerExisted) {\n            ensureNoDupTriggerKey();\n        }\n\n        jobDetail = createJobDetail();\n        Trigger trigger = createTrigger(jobDetail);\n\n        QuartzHelper.updateJobDataMap(getCamelContext(), jobDetail, getEndpointUri());\n\n        if (triggerExisted) {\n            // Reschedule job if trigger settings were changed\n            if (hasTriggerChanged(oldTrigger, trigger)) {\n                scheduler.rescheduleJob(triggerKey, trigger);\n            }\n        } else {\n            // Schedule it now. Remember that scheduler might not be started it, but we can schedule now.\n            scheduler.scheduleJob(jobDetail, trigger);\n        }\n\n        if (LOG.isInfoEnabled()) {\n            LOG.info(\"Job {} (triggerType={}, jobClass={}) is scheduled. Next fire date is {}\",\n                    new Object[] {trigger.getKey(), trigger.getClass().getSimpleName(),\n                            jobDetail.getJobClass().getSimpleName(), trigger.getNextFireTime()});\n        }\n\n        // Increase camel job count for this endpoint\n        AtomicInteger number = (AtomicInteger) scheduler.getContext().get(QuartzConstants.QUARTZ_CAMEL_JOBS_COUNT);\n        if (number != null) {\n            number.incrementAndGet();\n        }\n\n        jobAdded.set(true);\n    }","commit_id":"a73465be206913a4d96549c2ec50d173d09f0a5b","url":"https://github.com/apache/camel"},{"original_method":"public void apply(Editor editor, SmartEnterProcessor processor, PsiElement psiElement) throws IncorrectOperationException {\n    PsiExpressionList args = null;\n    if (psiElement instanceof PsiMethodCallExpression) {\n      args = ((PsiMethodCallExpression) psiElement).getArgumentList();\n    } else if (psiElement instanceof PsiNewExpression) {\n      args = ((PsiNewExpression) psiElement).getArgumentList();\n    }\n\n    if (args == null) return;\n\n    PsiElement parenth = args.getLastChild();\n\n    if (parenth == null || !\")\".equals(parenth.getText())) {\n      int endOffset = args.getTextRange().getEndOffset();\n      final PsiExpression[] params = args.getExpressions();\n      if (params.length > 0 && startLine(editor, args) != startLine(editor, params[0])) {\n        endOffset = args.getTextRange().getStartOffset() + 1;\n      }\n      endOffset = CharArrayUtil.shiftBackward(editor.getDocument().getCharsSequence(), endOffset - 1, \" \\t\\n\") + 1;\n      editor.getDocument().insertString(endOffset, \")\");\n    }\n  }","id":71494,"modified_method":"public void apply(Editor editor, SmartEnterProcessor processor, PsiElement psiElement) throws IncorrectOperationException {\n    PsiExpressionList args = null;\n    if (psiElement instanceof PsiMethodCallExpression) {\n      args = ((PsiMethodCallExpression) psiElement).getArgumentList();\n    } else if (psiElement instanceof PsiNewExpression) {\n      args = ((PsiNewExpression) psiElement).getArgumentList();\n    }\n\n    if (args == null) return;\n\n    PsiElement parenth = args.getLastChild();\n\n    if (parenth == null || !\")\".equals(parenth.getText())) {\n      int endOffset = -1;\n      PsiElement child = args.getFirstChild();\n      while (child != null) {\n        if (child instanceof PsiErrorElement) {\n          final PsiErrorElement errorElement = (PsiErrorElement)child;\n          if (errorElement.getErrorDescription().indexOf(\"')'\") >= 0) {\n            endOffset = errorElement.getTextRange().getStartOffset();\n            break;\n          }\n        }\n        child = child.getNextSibling();\n      }\n\n      if (endOffset == -1) {\n        endOffset = args.getTextRange().getEndOffset();\n      }\n\n      final PsiExpression[] params = args.getExpressions();\n      if (params.length > 0 && startLine(editor, args) != startLine(editor, params[0])) {\n        endOffset = args.getTextRange().getStartOffset() + 1;\n      }\n\n      endOffset = CharArrayUtil.shiftBackward(editor.getDocument().getCharsSequence(), endOffset - 1, \" \\t\\n\") + 1;\n      editor.getDocument().insertString(endOffset, \")\");\n    }\n  }","commit_id":"f7008208b87fa3b54d26b237698a2ac81b879f1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void executeWriteAction(Editor editor, DataContext dataContext) {\n      final Document doc = editor.getDocument();\n      Project project = (Project) dataContext.getData(DataConstants.PROJECT);\n      if (project == null || doc.getLineCount() < 2) {\n        plainEnter(editor, dataContext);\n        return;\n      }\n      final int caretOffset = editor.getCaretModel().getOffset();\n      if (isInPreceedingBlanks(editor)) {\n        final int caretLine = doc.getLineNumber(caretOffset);\n        if (caretLine > 0) {\n          int prevLineEnd = doc.getLineEndOffset(caretLine - 1);\n          editor.getCaretModel().moveToOffset(prevLineEnd);\n        }\n        EditorActionHandler enterHandler = EditorActionManager.getInstance().getActionHandler(\n            IdeActions.ACTION_EDITOR_ENTER);\n        enterHandler.execute(editor, dataContext);\n        return;\n      }\n\n      PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(doc);\n\n      if (EnterHandler.isAfterUnmatchedLBrace(editor, caretOffset, psiFile.getFileType())) {\n        EditorActionHandler enterHandler = EditorActionManager.getInstance().getActionHandler(\n            IdeActions.ACTION_EDITOR_ENTER);\n        enterHandler.execute(editor, dataContext);\n        return;\n      }\n\n      if (!(psiFile instanceof PsiJavaFile)) {\n        plainEnter(editor, dataContext);\n        return;\n      }\n\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.complete.statement\");\n      new SmartEnterProcessor(project, editor, psiFile).process();\n    }","id":71495,"modified_method":"public void executeWriteAction(Editor editor, DataContext dataContext) {\n      final Document doc = editor.getDocument();\n      Project project = (Project) dataContext.getData(DataConstants.PROJECT);\n      if (project == null || doc.getLineCount() < 2) {\n        plainEnter(editor, dataContext);\n        return;\n      }\n      final int caretOffset = editor.getCaretModel().getOffset();\n      if (isInPreceedingBlanks(editor)) {\n        final int caretLine = doc.getLineNumber(caretOffset);\n        if (caretLine > 0) {\n          int prevLineEnd = doc.getLineEndOffset(caretLine - 1);\n          editor.getCaretModel().moveToOffset(prevLineEnd);\n        }\n        EditorActionHandler enterHandler = EditorActionManager.getInstance().getActionHandler(\n            IdeActions.ACTION_EDITOR_ENTER);\n        enterHandler.execute(editor, dataContext);\n        return;\n      }\n\n      PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(doc);\n\n      if (EnterHandler.isAfterUnmatchedLBrace(editor, caretOffset, psiFile.getFileType())) {\n        EditorActionHandler enterHandler = EditorActionManager.getInstance().getActionHandler(\n            IdeActions.ACTION_EDITOR_ENTER);\n        enterHandler.execute(editor, dataContext);\n        return;\n      }\n\n      if (!(psiFile instanceof PsiJavaFile)) {\n        plainEnter(editor, dataContext);\n        return;\n      }\n\n      FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.complete.statement\");\n\n      final String textForRollback = doc.getText();\n      try {\n        new SmartEnterProcessor(project, editor, psiFile).process(0);\n      }\n      catch (SmartEnterProcessor.TooManyAttemptsException e) {\n        doc.replaceString(0, doc.getTextLength(), textForRollback);\n      }\n    }","commit_id":"f7008208b87fa3b54d26b237698a2ac81b879f1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EditorActionHandler getEnterHandler() {\n      EditorActionHandler enterHandler = EditorActionManager.getInstance().getActionHandler(\n          IdeActions.ACTION_EDITOR_START_NEW_LINE\n      );\n      return enterHandler;\n    }","id":71496,"modified_method":"private EditorActionHandler getEnterHandler() {\n      return EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_START_NEW_LINE);\n    }","commit_id":"f7008208b87fa3b54d26b237698a2ac81b879f1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiElement getStatementAtCaret(Editor editor, int caret, PsiFile psiFile) {\n    final Document doc = editor.getDocument();\n    CharSequence chars = doc.getCharsSequence();\n    int offset = CharArrayUtil.shiftBackward(chars, caret - 1, \" \\t\");\n    if (doc.getLineNumber(offset) < doc.getLineNumber(caret)) {\n      offset = CharArrayUtil.shiftForward(chars, caret, \" \\t\");\n    }\n\n    PsiElement atCaret = psiFile.findElementAt(offset);\n    if (atCaret instanceof PsiWhiteSpace) return null;\n    if (atCaret instanceof PsiJavaToken && \"}\".equals(atCaret.getText())) return null;\n\n    PsiElement statementAtCaret = PsiTreeUtil.getNonStrictParentOfType(atCaret,\n                                                                       PsiStatement.class, PsiCodeBlock.class,\n                                                                       PsiMember.class,\n                                                                       PsiComment.class);\n\n    if (statementAtCaret instanceof PsiBlockStatement) return null;\n\n    if (statementAtCaret != null && statementAtCaret.getParent() instanceof PsiForStatement) statementAtCaret = statementAtCaret.getParent();\n\n    return statementAtCaret instanceof PsiStatement || statementAtCaret instanceof PsiMember\n           ? statementAtCaret\n           : null;\n  }","id":71497,"modified_method":"private PsiElement getStatementAtCaret(Editor editor, int caret, PsiFile psiFile) {\n    final Document doc = editor.getDocument();\n    CharSequence chars = doc.getCharsSequence();\n    int offset = CharArrayUtil.shiftBackward(chars, caret - 1, \" \\t\");\n    if (doc.getLineNumber(offset) < doc.getLineNumber(caret)) {\n      offset = CharArrayUtil.shiftForward(chars, caret, \" \\t\");\n    }\n\n    PsiElement atCaret = psiFile.findElementAt(offset);\n    if (atCaret instanceof PsiWhiteSpace) return null;\n    if (atCaret instanceof PsiJavaToken && \"}\".equals(atCaret.getText())) return null;\n\n    PsiElement statementAtCaret = PsiTreeUtil.getParentOfType(atCaret,\n                                                              PsiStatement.class,\n                                                              PsiCodeBlock.class,\n                                                              PsiMember.class,\n                                                              PsiComment.class);\n\n    if (statementAtCaret instanceof PsiBlockStatement) return null;\n\n    if (statementAtCaret != null && statementAtCaret.getParent() instanceof PsiForStatement) statementAtCaret = statementAtCaret.getParent();\n\n    return statementAtCaret instanceof PsiStatement || statementAtCaret instanceof PsiMember\n           ? statementAtCaret\n           : null;\n  }","commit_id":"f7008208b87fa3b54d26b237698a2ac81b879f1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void process() {\n    try {\n      commit();\n      myFirstErrorOffset = Integer.MAX_VALUE;\n\n      PsiElement atCaret = getStatementAtCaret();\n      if (atCaret == null) {\n        if (!new CommentBreakerEnterProcessor().doEnter(myEditor, myPsiFile, false)) {\n          plainEnter();\n        }\n        return;\n      }\n\n      List<PsiElement> queue = new ArrayList<PsiElement>();\n      collectAllElements(atCaret, queue, true);\n      queue.add(atCaret);\n\n      for (PsiElement psiElement : queue) {\n        if (StdFileTypes.JAVA.getLanguage().equals(psiElement.getLanguage())) {\n          for (Fixer fixer : ourFixers) {\n            fixer.apply(myEditor, this, psiElement);\n            if (myEditor.getUserData(LookupImpl.LOOKUP_IN_EDITOR_KEY) != null) return;\n            if (isUncommited() || !psiElement.isValid()) {\n              moveCaretInsideBracesIfAny();\n              process();\n              return;\n            }\n          }\n        }\n      }\n\n      doEnter(atCaret);\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","id":71498,"modified_method":"public void process(final int attempt) throws TooManyAttemptsException {\n    if (attempt > MAX_ATTEMPTS) throw new TooManyAttemptsException();\n\n    try {\n      commit();\n      myFirstErrorOffset = Integer.MAX_VALUE;\n\n      PsiElement atCaret = getStatementAtCaret();\n      if (atCaret == null) {\n        if (!new CommentBreakerEnterProcessor().doEnter(myEditor, myPsiFile, false)) {\n          plainEnter();\n        }\n        return;\n      }\n\n      List<PsiElement> queue = new ArrayList<PsiElement>();\n      collectAllElements(atCaret, queue, true);\n      queue.add(atCaret);\n\n      for (PsiElement psiElement : queue) {\n        if (StdFileTypes.JAVA.getLanguage().equals(psiElement.getLanguage())) {\n          for (Fixer fixer : ourFixers) {\n            fixer.apply(myEditor, this, psiElement);\n            if (myEditor.getUserData(LookupImpl.LOOKUP_IN_EDITOR_KEY) != null) return;\n            if (isUncommited() || !psiElement.isValid()) {\n              moveCaretInsideBracesIfAny();\n              process(attempt + 1);\n              return;\n            }\n          }\n        }\n      }\n\n      doEnter(atCaret);\n    } catch (IncorrectOperationException e) {\n      LOG.error(e);\n    }\n  }","commit_id":"f7008208b87fa3b54d26b237698a2ac81b879f1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EditorActionHandler getEnterHandler() {\n    EditorActionHandler enterHandler = EditorActionManager.getInstance().getActionHandler(\n        IdeActions.ACTION_EDITOR_START_NEW_LINE\n    );\n    return enterHandler;\n  }","id":71499,"modified_method":"private EditorActionHandler getEnterHandler() {\n    return EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_START_NEW_LINE);\n  }","commit_id":"f7008208b87fa3b54d26b237698a2ac81b879f1c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean doEnter(Editor editor, PsiElement psiElement, boolean isModified) {\n    PsiCodeBlock block = getControlStatementBlock(editor.getCaretModel().getOffset(), psiElement);\n    if (block != null) {\n      PsiElement firstElement = block.getFirstBodyElement();\n      if (firstElement == null) firstElement = block.getRBrace();\n      editor.getCaretModel().moveToOffset(firstElement != null ?\n                                          firstElement.getTextRange().getStartOffset() :\n                                          block.getTextRange().getEndOffset());\n    }\n\n    getEnterHandler().execute(editor, ((EditorEx)editor).getDataContext());\n    return true;\n  }","id":71500,"modified_method":"public boolean doEnter(Editor editor, PsiElement psiElement, boolean isModified) {\n    PsiCodeBlock block = getControlStatementBlock(editor.getCaretModel().getOffset(), psiElement);\n    EditorActionHandler enterHandler = getEnterHandler(IdeActions.ACTION_EDITOR_START_NEW_LINE);\n    if (block != null) {\n      PsiElement firstElement = block.getFirstBodyElement();\n      if (firstElement == null) {\n        firstElement = block.getRBrace();\n        // Plain enter processor inserts enter after the end of line, hence, we don't want to use it here because the line ends with \n        // the empty braces block. So, we get the following in case of default handler usage:\n        //     Before:\n        //         if (condition[caret]) {}\n        //     After:\n        //         if (condition) {}\n        //             [caret]\n        enterHandler = getEnterHandler(IdeActions.ACTION_EDITOR_ENTER);\n      }\n      editor.getCaretModel().moveToOffset(firstElement != null ?\n                                          firstElement.getTextRange().getStartOffset() :\n                                          block.getTextRange().getEndOffset());\n    }\n\n    enterHandler.execute(editor, ((EditorEx)editor).getDataContext());\n    return true;\n  }","commit_id":"5fe8f15981e2485ee8fde8b4f5e4c22aa81a6cc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private EditorActionHandler getEnterHandler() {\n    EditorActionHandler enterHandler = EditorActionManager.getInstance().getActionHandler(\n        IdeActions.ACTION_EDITOR_START_NEW_LINE\n    );\n    return enterHandler;\n  }","id":71501,"modified_method":"private static EditorActionHandler getEnterHandler(String actionId) {\n    return EditorActionManager.getInstance().getActionHandler(actionId);\n  }","commit_id":"5fe8f15981e2485ee8fde8b4f5e4c22aa81a6cc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiCodeBlock getControlStatementBlock(int caret, PsiElement element) {\n    PsiStatement body = null;\n    if (element instanceof PsiIfStatement) {\n      body =  ((PsiIfStatement)element).getThenBranch();\n      if (caret > body.getTextRange().getEndOffset()) {\n        body = ((PsiIfStatement)element).getElseBranch();\n      }\n    }\n    else if (element instanceof PsiWhileStatement) {\n      body =  ((PsiWhileStatement)element).getBody();\n    }\n    else if (element instanceof PsiForStatement) {\n      body =  ((PsiForStatement)element).getBody();\n    }\n    else if (element instanceof PsiForeachStatement) {\n      body =  ((PsiForeachStatement)element).getBody();\n    }\n    else if (element instanceof PsiDoWhileStatement) {\n      body =  ((PsiDoWhileStatement)element).getBody();\n    }\n    else if (element instanceof PsiMethod) {\n      PsiCodeBlock methodBody = ((PsiMethod)element).getBody();\n      if (methodBody != null) return methodBody;\n    }\n\n    return body instanceof PsiBlockStatement ? ((PsiBlockStatement)body).getCodeBlock() : null;\n  }","id":71502,"modified_method":"@Nullable\n  private static PsiCodeBlock getControlStatementBlock(int caret, PsiElement element) {\n    PsiStatement body = null;\n    if (element instanceof PsiIfStatement) {\n      body =  ((PsiIfStatement)element).getThenBranch();\n      if (body != null && caret > body.getTextRange().getEndOffset()) {\n        body = ((PsiIfStatement)element).getElseBranch();\n      }\n    }\n    else if (element instanceof PsiWhileStatement) {\n      body =  ((PsiWhileStatement)element).getBody();\n    }\n    else if (element instanceof PsiForStatement) {\n      body =  ((PsiForStatement)element).getBody();\n    }\n    else if (element instanceof PsiForeachStatement) {\n      body =  ((PsiForeachStatement)element).getBody();\n    }\n    else if (element instanceof PsiDoWhileStatement) {\n      body =  ((PsiDoWhileStatement)element).getBody();\n    }\n    else if (element instanceof PsiMethod) {\n      PsiCodeBlock methodBody = ((PsiMethod)element).getBody();\n      if (methodBody != null) return methodBody;\n    }\n\n    return body instanceof PsiBlockStatement ? ((PsiBlockStatement)body).getCodeBlock() : null;\n  }","commit_id":"5fe8f15981e2485ee8fde8b4f5e4c22aa81a6cc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String processFile(final PsiFile file) throws IncorrectOperationException, InvalidDataException, IOException {\n    String result;\n    String fileText = file.getText();\n    int offset = fileText.indexOf(CARET_MARKER);\n    fileText = TestUtils.removeCaretMarker(fileText, offset);\n    myFile = TestUtils.createPseudoPhysicalFile(myProject, fileText);\n    fileEditorManager = FileEditorManager.getInstance(myProject);\n    VirtualFile virtualFile = myFile.getVirtualFile();\n    assert virtualFile != null;\n    myEditor = fileEditorManager.openTextEditor(new OpenFileDescriptor(myProject, virtualFile, 0), false);\n    Assert.assertNotNull(myEditor);\n    myEditor.getCaretModel().moveToOffset(offset);\n\n    final myDataContext dataContext = getDataContext(myFile);\n    final EditorActionHandler handler = getMyHandler();\n\n    try {\n      performAction(myProject, new Runnable() {\n        public void run() {\n          handler.execute(myEditor, dataContext);\n        }\n      });\n\n      offset = myEditor.getCaretModel().getOffset();\n      result = myEditor.getDocument().getText();\n      result = result.substring(0, offset) + CARET_MARKER + result.substring(offset);\n    }\n    catch (IndexOutOfBoundsException e) {\n      offset = myEditor.getCaretModel().getOffset();\n      result = myEditor.getDocument().getText();\n      result = result.substring(0, offset) + CARET_MARKER + result.substring(offset);\n    }\n    finally {\n      fileEditorManager.closeFile(virtualFile);\n      myEditor = null;\n    }\n\n    return result;\n  }","id":71503,"modified_method":"private String processFile(final PsiFile file) throws IncorrectOperationException, InvalidDataException, IOException {\n    String result;\n    String fileText = file.getText();\n    int offset = fileText.indexOf(CARET_MARKER);\n    fileText = TestUtils.removeCaretMarker(fileText, offset);\n    myFile = TestUtils.createPseudoPhysicalFile(myProject, fileText);\n    fileEditorManager = FileEditorManager.getInstance(myProject);\n    VirtualFile virtualFile = myFile.getVirtualFile();\n    assert virtualFile != null;\n    myEditor = fileEditorManager.openTextEditor(new OpenFileDescriptor(myProject, virtualFile, 0), false);\n    Assert.assertNotNull(myEditor);\n    myEditor.getCaretModel().moveToOffset(offset);\n\n    final myDataContext dataContext = getDataContext(myFile);\n    final EditorActionHandler handler = getMyHandler();\n\n    try {\n      performAction(myProject, new Runnable() {\n        public void run() {\n          handler.execute(myEditor, dataContext);\n        }\n      });\n\n      offset = myEditor.getCaretModel().getOffset();\n      result = myEditor.getDocument().getText();\n      result = result.substring(0, offset) + CARET_MARKER + result.substring(offset);\n    } finally {\n      fileEditorManager.closeFile(virtualFile);\n      myEditor = null;\n    }\n\n    return result;\n  }","commit_id":"d86fe72c4431971545dac70218a684913949759c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected EditorActionHandler getMyHandler() {\n    EditorActionManager manager = EditorActionManager.getInstance();\n    final EditorActionHandler handler = new EnterHandler(manager.getActionHandler(IdeActions.ACTION_EDITOR_ENTER));\n    manager.setActionHandler(IdeActions.ACTION_EDITOR_ENTER, handler);\n    return handler;\n  }","id":71504,"modified_method":"protected EditorActionHandler getMyHandler() {\n    return EditorActionManager.getInstance().getActionHandler(IdeActions.ACTION_EDITOR_ENTER);\n  }","commit_id":"d86fe72c4431971545dac70218a684913949759c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean checkStringApplicable(Editor editor, int carret) {\n    final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();\n    HighlighterIterator iteratorLeft = highlighter.createIterator(carret - 1);\n    HighlighterIterator iteratorRight = highlighter.createIterator(carret);\n\n    if (iteratorLeft != null && !(ALL_STRINGS.contains(iteratorLeft.getTokenType()))) {\n      return true;\n    }\n    if (iteratorLeft != null && BEFORE_DOLLAR.contains(iteratorLeft.getTokenType()) &&\n        iteratorRight != null && !AFTER_DOLLAR.contains(iteratorRight.getTokenType())) {\n      return true;\n    }\n    if (iteratorLeft != null && EXPR_END.contains(iteratorLeft.getTokenType()) &&\n        iteratorRight != null && !AFTER_EXPR_END.contains(iteratorRight.getTokenType())) {\n      return true;\n    }\n    if (iteratorLeft != null && STRING_END.contains(iteratorLeft.getTokenType()) &&\n        iteratorRight != null && !STRING_END.contains(iteratorRight.getTokenType())) {\n      return true;\n    }\n    return false;\n  }","id":71505,"modified_method":"private static boolean checkStringApplicable(Editor editor, int carret) {\n    final EditorHighlighter highlighter = ((EditorEx) editor).getHighlighter();\n    HighlighterIterator iteratorLeft = highlighter.createIterator(carret - 1);\n    HighlighterIterator iteratorRight = highlighter.createIterator(carret);\n\n    if (iteratorLeft != null && !(ALL_STRINGS.contains(iteratorLeft.getTokenType()))) {\n      return false;\n    }\n    if (iteratorLeft != null && BEFORE_DOLLAR.contains(iteratorLeft.getTokenType()) &&\n        iteratorRight != null && !AFTER_DOLLAR.contains(iteratorRight.getTokenType())) {\n      return false;\n    }\n    if (iteratorLeft != null && EXPR_END.contains(iteratorLeft.getTokenType()) &&\n        iteratorRight != null && !AFTER_EXPR_END.contains(iteratorRight.getTokenType())) {\n      return false;\n    }\n    if (iteratorLeft != null && STRING_END.contains(iteratorLeft.getTokenType()) &&\n        iteratorRight != null && !STRING_END.contains(iteratorRight.getTokenType())) {\n      return false;\n    }\n    return true;\n  }","commit_id":"d86fe72c4431971545dac70218a684913949759c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean handleInString(Editor editor, int carret, DataContext dataContext) throws IncorrectOperationException {\n    PsiFile file = DataKeys.PSI_FILE.getData(dataContext);\n    Project project = DataKeys.PROJECT.getData(dataContext);\n\n    String fileText = editor.getDocument().getText();\n    if (fileText.length() == carret) return false;\n\n    if (checkStringApplicable(editor, carret)) return false;\n    if (file == null || project == null) return false;\n\n    PsiElement stringElement = file.findElementAt(carret - 1);\n    if (stringElement == null) return false;\n    ASTNode node = stringElement.getNode();\n    if (node == null) return false;\n\n    GroovyElementFactory factory = GroovyElementFactory.getInstance(project);\n\n    // For simple String literals like 'abcdef'\n    if (GroovyTokenTypes.mSTRING_LITERAL == node.getElementType()) {\n      if (GroovyEditorActionUtil.isPlainStringLiteral(node)) {\n        String text = node.getText();\n        String innerText = text.equals(\"''\") ? \"\" : text.substring(1, text.length() - 1);\n        PsiElement literal = stringElement.getParent();\n        if (!(literal instanceof GrLiteral)) return false;\n        ((GrExpression) literal).replaceWithExpression(factory.createExpressionFromText(\"'''\" + innerText + \"'''\"), false);\n        editor.getCaretModel().moveToOffset(carret + 2);\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n        //myOriginalHandler.execute(editor, dataContext);\n      } else {\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n      }\n      return true;\n    }\n\n    // For expression injection in GString like \"abc ${}<caret>  abc\"\n    if (!GroovyEditorActionUtil.GSTRING_TOKENS.contains(node.getElementType()) &&\n        checkGStringInnerExpression(stringElement)) {\n      stringElement = stringElement.getParent().getNextSibling();\n      if (stringElement == null) return false;\n      node = stringElement.getNode();\n      if (node == null) return false;\n    }\n\n    if (GroovyEditorActionUtil.GSTRING_TOKENS.contains(node.getElementType())) {\n      PsiElement parent = stringElement.getParent();\n      while (parent != null && !(parent instanceof GrLiteral)) {\n        parent = parent.getParent();\n      }\n      if (parent == null || parent.getLastChild() instanceof PsiErrorElement) return false;\n      if (GroovyEditorActionUtil.isPlainGString(parent.getNode())) {\n        PsiElement exprSibling = stringElement.getNextSibling();\n        boolean rightFromDollar = exprSibling instanceof GrExpression &&\n            exprSibling.getTextRange().getStartOffset() == carret;\n        if (rightFromDollar) carret--;\n        String text = parent.getText();\n        String innerText = text.equals(\"\\\"\\\"\") ? \"\" : text.substring(1, text.length() - 1);\n        ((GrLiteral) parent).replaceWithExpression(factory.createExpressionFromText(\"\\\"\\\"\\\"\" + innerText + \"\\\"\\\"\\\"\"), false);\n        editor.getCaretModel().moveToOffset(carret + 2);\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n        //myOriginalHandler.execute(editor, dataContext);\n        if (rightFromDollar) {\n          editor.getCaretModel().moveCaretRelatively(1, 0, false, false, true);\n        }\n      } else {\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n      }\n      return true;\n    }\n    return false;\n  }","id":71506,"modified_method":"private boolean handleInString(Editor editor, int caretOffset, DataContext dataContext) throws IncorrectOperationException {\n    PsiFile file = DataKeys.PSI_FILE.getData(dataContext);\n    Project project = DataKeys.PROJECT.getData(dataContext);\n\n    String fileText = editor.getDocument().getText();\n    if (fileText.length() == caretOffset) return false;\n\n    if (!checkStringApplicable(editor, caretOffset)) return false;\n    if (file == null || project == null) return false;\n\n    PsiElement stringElement = file.findElementAt(caretOffset - 1);\n    if (stringElement == null) return false;\n    ASTNode node = stringElement.getNode();\n    if (node == null) return false;\n\n    GroovyElementFactory factory = GroovyElementFactory.getInstance(project);\n\n    // For simple String literals like 'abcdef'\n    if (GroovyTokenTypes.mSTRING_LITERAL == node.getElementType()) {\n      if (GroovyEditorActionUtil.isPlainStringLiteral(node)) {\n        String text = node.getText();\n        String innerText = text.equals(\"''\") ? \"\" : text.substring(1, text.length() - 1);\n        PsiElement literal = stringElement.getParent();\n        if (!(literal instanceof GrLiteral)) return false;\n        ((GrExpression) literal).replaceWithExpression(factory.createExpressionFromText(\"'''\" + innerText + \"'''\"), false);\n        editor.getCaretModel().moveToOffset(caretOffset + 2);\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n        //myOriginalHandler.execute(editor, dataContext);\n      } else {\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n      }\n      return true;\n    }\n\n    // For expression injection in GString like \"abc ${}<caret>  abc\"\n    if (!GroovyEditorActionUtil.GSTRING_TOKENS.contains(node.getElementType()) &&\n        checkGStringInnerExpression(stringElement)) {\n      stringElement = stringElement.getParent().getNextSibling();\n      if (stringElement == null) return false;\n      node = stringElement.getNode();\n      if (node == null) return false;\n    }\n\n    if (GroovyEditorActionUtil.GSTRING_TOKENS.contains(node.getElementType())) {\n      PsiElement parent = stringElement.getParent();\n      while (parent != null && !(parent instanceof GrLiteral)) {\n        parent = parent.getParent();\n      }\n      if (parent == null || parent.getLastChild() instanceof PsiErrorElement) return false;\n      if (GroovyEditorActionUtil.isPlainGString(parent.getNode())) {\n        PsiElement exprSibling = stringElement.getNextSibling();\n        boolean rightFromDollar = exprSibling instanceof GrExpression &&\n            exprSibling.getTextRange().getStartOffset() == caretOffset;\n        if (rightFromDollar) caretOffset--;\n        String text = parent.getText();\n        String innerText = text.equals(\"\\\"\\\"\") ? \"\" : text.substring(1, text.length() - 1);\n        ((GrLiteral) parent).replaceWithExpression(factory.createExpressionFromText(\"\\\"\\\"\\\"\" + innerText + \"\\\"\\\"\\\"\"), false);\n        editor.getCaretModel().moveToOffset(caretOffset + 2);\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n        //myOriginalHandler.execute(editor, dataContext);\n        if (rightFromDollar) {\n          editor.getCaretModel().moveCaretRelatively(1, 0, false, false, true);\n        }\n      } else {\n        EditorModificationUtil.insertStringAtCaret(editor, \"\\n\");\n      }\n      return true;\n    }\n    return false;\n  }","commit_id":"d86fe72c4431971545dac70218a684913949759c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean handleEnter(Editor editor, DataContext dataContext) throws IncorrectOperationException {\n    final Project project = DataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n    int carret = editor.getCaretModel().getOffset();\n    if (carret < 1) return false;\n\n    if (handleJspLikeScriptlet(editor, carret, dataContext)) {\n      GroovyEditorActionUtil.insertSpacesByIndent(editor, project);\n      return true;\n    }\n    if (handleInLineComment(editor, carret, dataContext)) {\n      return true;\n    }\n    if (handleInString(editor, carret, dataContext)) {\n      return true;\n    }\n    return false;\n  }","id":71507,"modified_method":"private boolean handleEnter(Editor editor, DataContext dataContext) throws IncorrectOperationException {\n    final Project project = DataKeys.PROJECT.getData(dataContext);\n    if (project == null) return false;\n    int caretOffset = editor.getCaretModel().getOffset();\n    if (caretOffset < 1) return false;\n\n    if (handleJspLikeScriptlet(editor, caretOffset, dataContext)) {\n      GroovyEditorActionUtil.insertSpacesByIndent(editor, project);\n      return true;\n    }\n    if (handleInLineComment(editor, caretOffset, dataContext)) {\n      return true;\n    }\n    if (handleInString(editor, caretOffset, dataContext)) {\n      return true;\n    }\n    return false;\n  }","commit_id":"d86fe72c4431971545dac70218a684913949759c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Serialize more tuples from the specified table that already has a stream enabled\n     * @param c Buffer to serialize tuple data too\n     * @param tableId Catalog ID of the table to serialize\n     * @return A positive number indicating the number of bytes serialized or 0 if there is no more data.\n     *        -1 is returned if there is an error (such as the table not having the specified stream type activated).\n     */\n    public abstract int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType type);","id":71508,"modified_method":"/**\n     * Serialize more tuples from the specified table that already has a stream enabled\n     * @param bbcontainers Buffers to receive serialized tuple data\n     * @param tableId Catalog ID of the table to serialize\n     * @return A positive number indicating the number of bytes serialized or 0 if there is no more data.\n     *        -1 is returned if there is an error (such as the table not having the specified stream type activated).\n     */\n    public abstract int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType type);","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Serialize more tuples from the specified table that has an active stream of the specified type\n     * @param pointer Pointer to an engine instance\n     * @param bufferPointer Buffer to serialize data to\n     * @param offset Offset into the buffer to start serializing to\n     * @param length length of the buffer\n     * @param tableId Catalog ID of the table to serialize\n     * @param streamType type of stream to pull data from\n     * @return A positive number indicating the number of bytes serialized or 0 if there is no more data.\n     *         -1 is returned if there is an error (such as the table not being COW mode).\n     */\n    protected native int nativeTableStreamSerializeMore(long pointer, long bufferPointer, int offset, int length, int tableId, int streamType);","id":71509,"modified_method":"/**\n     * Serialize more tuples from the specified table that has an active stream of the specified type\n     * @param pointer Pointer to an engine instance\n     * @param tableId Catalog ID of the table to serialize\n     * @param streamType type of stream to pull data from\n     * @param data Serialized buffer count and array\n     * @return remaining tuple count, 0 when done, or -1 for an error.\n     * array of per-buffer byte counts with an extra leading int that is set to\n     *         the count of unstreamed tuples, 0 when done, or -1 indicating an error\n     *         (such as the table not being COW mode).\n     */\n    protected native long nativeTableStreamSerializeMore(long pointer, int tableId, int streamType, byte[] data);","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Active a table stream of the specified type for a table.\n     * @param pointer Pointer to an engine instance\n     * @param tableId Catalog ID of the table\n     * @param streamType type of stream to activate\n     * @return <code>true<\/code> on success and <code>false<\/code> on failure\n     */\n    protected native boolean nativeActivateTableStream(long pointer, int tableId, int streamType);","id":71510,"modified_method":"/**\n     * Active a table stream of the specified type for a table.\n     * @param pointer Pointer to an engine instance\n     * @param tableId Catalog ID of the table\n     * @param streamType type of stream to activate\n     * @param data serialized predicates\n     * @return <code>true<\/code> on success and <code>false<\/code> on failure\n     */\n    protected native boolean nativeActivateTableStream(long pointer, int tableId, int streamType, byte[] data);","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        m_data.clear();\n        m_data.putInt(Commands.ActivateTableStream.m_id);\n        m_data.putInt(tableId);\n        m_data.putInt(streamType.ordinal());\n\n        try {\n            m_data.flip();\n            m_connection.write();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        int result = ExecutionEngine.ERRORCODE_ERROR;\n        try {\n            result = m_connection.readStatusByte();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        if (result != ExecutionEngine.ERRORCODE_SUCCESS) {\n            return false;\n        }\n        return true;\n    }","id":71511,"modified_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        m_data.clear();\n        m_data.putInt(Commands.ActivateTableStream.m_id);\n        m_data.putInt(tableId);\n        m_data.putInt(streamType.ordinal());\n        m_data.putInt(0);       // Predicate count\n\n        try {\n            m_data.flip();\n            m_connection.write();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        int result = ExecutionEngine.ERRORCODE_ERROR;\n        try {\n            result = m_connection.readStatusByte();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        if (result != ExecutionEngine.ERRORCODE_SUCCESS) {\n            return false;\n        }\n        return true;\n    }","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"Connection(BackendTarget target, int port) {\n            if (target == BackendTarget.NATIVE_EE_IPC) {\n                System.out.printf(\"Ready to connect to voltdbipc process on port %d\\n\", port);\n                System.out\n                        .println(\"Press enter after you have started the EE process to initiate the connection to the EE\");\n                try {\n                    System.in.read();\n                } catch (final IOException e1) {\n                    e1.printStackTrace();\n                }\n            }\n            try {\n                System.out.println(\"Connecting to localhost:\" + port);\n                m_socketChannel = SocketChannel.open(new InetSocketAddress(\n                        \"localhost\", port));\n                m_socketChannel.configureBlocking(true);\n                m_socket = m_socketChannel.socket();\n                m_socket.setTcpNoDelay(true);\n            } catch (final Exception e) {\n                System.out.println(e.getMessage());\n                System.out\n                        .println(\"Failed to initialize IPC EE connection. Quitting.\");\n                while (true) {}\n\n                //System.exit(-1);\n            }\n            System.out.println(\"Created IPC connection for site.\");\n        }","id":71512,"modified_method":"Connection(BackendTarget target, int port) {\n            boolean connected = false;\n            int retries = 0;\n            while (!connected) {\n                try {\n                    System.out.println(\"Connecting to localhost:\" + port);\n                    m_socketChannel = SocketChannel.open(new InetSocketAddress(\n                            \"localhost\", port));\n                    m_socketChannel.configureBlocking(true);\n                    m_socket = m_socketChannel.socket();\n                    m_socket.setTcpNoDelay(true);\n                    connected = true;\n                } catch (final Exception e) {\n                    System.out.println(e.getMessage());\n                    if (retries++ <= 10) {\n                        if (retries > 1) {\n                            System.out.printf(\"Failed to connect to IPC EE on port %d. Retry #%d of 10\\n\", port, retries-1);\n                            try {\n                                Thread.sleep(10000);\n                            }\n                            catch (InterruptedException e1) {}\n                        }\n                    }\n                    else {\n                        System.out.printf(\"Failed to initialize IPC EE connection on port %d. Quitting.\\n\", port);\n                        System.exit(-1);\n                    }\n                }\n                if (!connected && retries == 1 && target == BackendTarget.NATIVE_EE_IPC) {\n                    System.out.printf(\"Ready to connect to voltdbipc process on port %d\\n\", port);\n                    System.out.println(\"Press Enter after you have started the EE process to initiate the connection to the EE\");\n                    try {\n                        System.in.read();\n                    } catch (final IOException e1) {\n                        e1.printStackTrace();\n                    }\n                }\n            }\n            System.out.println(\"Created IPC connection for site.\");\n        }","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        int bytesReturned = -1;\n        ByteBuffer view = c.b.duplicate();\n        try {\n            m_data.clear();\n            m_data.putInt(Commands.TableStreamSerializeMore.m_id);\n            m_data.putInt(tableId);\n            m_data.putInt(streamType.ordinal());\n            m_data.putInt(c.b.remaining());\n\n            m_data.flip();\n            m_connection.write();\n\n            m_connection.readStatusByte();\n\n            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n            while (lengthBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(lengthBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            lengthBuffer.flip();\n            final int length = lengthBuffer.getInt();\n            bytesReturned = length;\n            /*\n             * Error or no more tuple data for this table.\n             */\n            if (length == -1 || length == 0) {\n                return length;\n            }\n            view.limit(view.position() + length);\n            while (view.hasRemaining()) {\n                m_connection.m_socketChannel.read(view);\n            }\n        } catch (final IOException e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        return bytesReturned;\n    }","id":71513,"modified_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        int bytesReturned = -1;\n        ByteBuffer view = c.b.duplicate();\n        try {\n            m_data.clear();\n            m_data.putInt(Commands.TableStreamSerializeMore.m_id);\n            m_data.putInt(tableId);\n            m_data.putInt(streamType.ordinal());\n            m_data.putInt(1);                   // Number of buffers\n            m_data.putInt(c.b.remaining());     // Byte limit\n\n            m_data.flip();\n            m_connection.write();\n\n            m_connection.readStatusByte();\n\n            // Get the count.\n            ByteBuffer countBuffer = ByteBuffer.allocate(4);\n            while (countBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(countBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            countBuffer.flip();\n            final int count = countBuffer.getInt();\n\n            /*\n             * Error or no more tuple data for this table.\n             */\n            if (count == -1 || count == 0) {\n                return count;\n            }\n\n            // Get the remaining tuple count.\n            ByteBuffer remainingBuffer = ByteBuffer.allocate(8);\n            while (remainingBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(remainingBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            remainingBuffer.flip();\n            //TODO: Do something useful with the remaining count.\n            /*final long remaining = */ remainingBuffer.getLong();\n\n            // Get the first length.\n            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n            while (lengthBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(lengthBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            lengthBuffer.flip();\n            final int length = lengthBuffer.getInt();\n\n            bytesReturned = length;\n            view.limit(view.position() + length);\n            while (view.hasRemaining()) {\n                m_connection.m_socketChannel.read(view);\n            }\n        } catch (final IOException e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        return bytesReturned;\n    }","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        return nativeTableStreamSerializeMore(pointer, c.address, c.b.position(), c.b.remaining(), tableId, streamType.ordinal());\n    }","id":71514,"modified_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        FastSerializer fs = new FastSerializer();\n        try {\n            fs.writeInt(1);                 // Buffer count\n            fs.writeLong(c.address);        // Pointer\n            fs.writeInt(c.b.position());    // Offset\n            fs.writeInt(c.b.remaining());   // Length\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        long remaining = nativeTableStreamSerializeMore(pointer, tableId, streamType.ordinal(), fs.getBytes());\n        int[] positions = null;\n        //TODO: Pass remaining count back to caller.\n        // -1 is end of stream.\n        if (remaining == -1) {\n            return 0;\n        }\n        // -2 is an error.\n        if (remaining == -2) {\n            return -1;\n        }\n        assert(deserializer != null);\n        deserializer.clear();\n        int count;\n        try {\n            count = deserializer.readInt();\n            if (count > 0) {\n                positions = new int[count];\n                for (int i = 0; i < count; i++) {\n                    positions[i] = deserializer.readInt();\n                }\n                //TODO: Support multiple streams.\n                assert(positions.length == 1);\n                return positions[0];\n            }\n        } catch (final IOException ex) {\n            LOG.error(\"Failed to deserialize position array\" + ex);\n            throw new EEException(ERRORCODE_WRONG_SERIALIZED_BYTES);\n        }\n\n        return 0;\n    }","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        return nativeActivateTableStream( pointer, tableId, streamType.ordinal());\n    }","id":71515,"modified_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        FastSerializer fs = new FastSerializer();\n        try {\n            fs.writeInt(0);                 // Predicate count\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return nativeActivateTableStream(pointer, tableId, streamType.ordinal(), fs.getBytes());\n    }","commit_id":"0e3f0c8a428a800148307c5388bedaa9f2a96f98","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Test\n    @Repeat(10000)\n    public void testNoServerPresent() throws Exception {\n        \n        final TcpDetector detector = m_detector.get();\n        detector.setPort(1999);\n        \n        final DetectFuture future = detector.isServiceDetected(InetAddress.getLocalHost(), new NullDetectorMonitor());\n        future.addListener(new IoFutureListener<DetectFuture>() {\n\n            public void operationComplete(final DetectFuture future) {\n                detector.dispose();\n            }\n            \n        });\n        assertNotNull(future);\n        future.awaitUninterruptibly();\n        assertFalse(future.isServiceDetected());\n        \n        \n        m_detector.set(null);\n        System.err.println(\"Finish test\");\n    }","id":71516,"modified_method":"@Test\n    @Repeat(10000)\n    public void testNoServerPresent() throws Exception {\n        \n        final TcpDetector detector = m_detector.get();\n        detector.setPort(1999);\n        System.err.printf(\"Starting testNoServerPresent with detector: %s\\n\", m_detector);\n        \n        final DetectFuture future = detector.isServiceDetected(InetAddress.getLocalHost(), new NullDetectorMonitor());\n        future.addListener(new IoFutureListener<DetectFuture>() {\n\n            public void operationComplete(final DetectFuture future) {\n                detector.dispose();\n            }\n            \n        });\n        assertNotNull(future);\n        future.awaitUninterruptibly();\n        assertFalse(future.isServiceDetected());\n        \n        System.err.printf(\"Finished testNoServerPresent with detector: %s\\n\", m_detector);\n        m_detector.set(null);\n    }","commit_id":"263c7ed21b4841e3afda2a3cb9fc88f4e308ec72","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    public void testSucessServer() throws Throwable {\n        setUpServer();\n        final int port = m_server.getLocalPort();\n        final InetAddress address = m_server.getInetAddress();\n\n        final double connectionRate = 0.2;\n        \n        final long startTime = System.currentTimeMillis();\n\n        int i = 0;\n        while (i < 10000) {\n            long now = Math.max(System.currentTimeMillis(), 1);\n            double actualRate = ((double)i) / ((double)(now - startTime));\n            LogUtils.debugf(this, \"Expected Rate: %f Actual Rate: %f Events Sent: %d\", connectionRate, actualRate, i);\n            if (actualRate < connectionRate) {\n                setUp();\n                LogUtils.debugf(this, \"current loop: %d\", i);\n                assertNotNull(m_detector);\n                \n                final TcpDetector detector = m_detector.get();\n\n                detector.setPort(port);\n\n                final DefaultDetectFuture future = (DefaultDetectFuture)detector.isServiceDetected(address, new NullDetectorMonitor());\n                future.addListener(new IoFutureListener<DetectFuture>() {\n                    public void operationComplete(final DetectFuture future) {\n                        detector.dispose();\n                    }\n                });\n\n                future.awaitUninterruptibly();\n                assertNotNull(future);\n                if (future.getException() != null) {\n                    LogUtils.debugf(this, future.getException(), \"got future exception\");\n                    throw future.getException();\n                }\n                LogUtils.debugf(this, \"got value: %s\", future.getObjectValue());\n                assertTrue(future.isServiceDetected());\n\n                m_detector.set(null);\n                \n                i++;\n            } else {\n                Thread.sleep(5);\n            }\n        }\n    }","id":71517,"modified_method":"@Test\n    public void testSuccessServer() throws Throwable {\n        setUpServer();\n        final int port = m_server.getLocalPort();\n        final InetAddress address = m_server.getInetAddress();\n\n        final double connectionRate = 0.2;\n        \n        final long startTime = System.currentTimeMillis();\n\n        int i = 0;\n        while (i < 10000) {\n            long now = Math.max(System.currentTimeMillis(), 1);\n            double actualRate = ((double)i) / ((double)(now - startTime));\n            LogUtils.debugf(this, \"Expected Rate: %f Actual Rate: %f Events Sent: %d\", connectionRate, actualRate, i);\n            if (actualRate < connectionRate) {\n                setUp();\n                LogUtils.debugf(this, \"current loop: %d\", i);\n                assertNotNull(m_detector);\n                \n                final TcpDetector detector = m_detector.get();\n\n                detector.setPort(port);\n\n                final DefaultDetectFuture future = (DefaultDetectFuture)detector.isServiceDetected(address, new NullDetectorMonitor());\n                future.addListener(new IoFutureListener<DetectFuture>() {\n                    public void operationComplete(final DetectFuture future) {\n                        detector.dispose();\n                    }\n                });\n\n                future.awaitUninterruptibly();\n                assertNotNull(future);\n                if (future.getException() != null) {\n                    LogUtils.debugf(this, future.getException(), \"got future exception\");\n                    throw future.getException();\n                }\n                LogUtils.debugf(this, \"got value: %s\", future.getObjectValue());\n                assertTrue(future.isServiceDetected());\n\n                m_detector.set(null);\n                \n                i++;\n            } else {\n                Thread.sleep(5);\n            }\n        }\n    }","commit_id":"263c7ed21b4841e3afda2a3cb9fc88f4e308ec72","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n        public void validate() {\n            if (runs <= 0) exitWithMessageAndUsage(\"runs must be > 0\");\n            if (rows < 0) exitWithMessageAndUsage(\"rows must be >= 0\");\n        }","id":71518,"modified_method":"@Override\n        public void validate() {\n            boolean testIsValid = false;\n            for (String t : tests) {\n              if (test.equals(t))\n                  testIsValid = true;\n            }\n            if (!testIsValid) exitWithMessageAndUsage(\"test is invalid\");\n            if (runs <= 0) exitWithMessageAndUsage(\"runs must be > 0\");\n            if (rows < 0) exitWithMessageAndUsage(\"rows must be >= 0\");\n        }","commit_id":"e3a9f6fba7ce3017e82fec9fb016e12d82168a7c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public void runBenchmark() throws Exception {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // connect to one or more servers, loop until success\n        connect(config.servers);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Loading Tuples\");\n        System.out.println(HORIZONTAL_RULE);\n\n        for (long i = 0; i < config.rows; i++) {\n            client.callProcedure(new NullCallback(), \"NARROW_P.insert\", i % 509 /* radom prime */, i);\n            client.callProcedure(new NullCallback(), \"NARROW_INDEX_P.insert\", i % 509 /* radom prime */, i);\n            if ((i % 100000) == 0) {\n                System.out.printf(\"Loading row at index %d.\\n\", i);\n            }\n        }\n        client.drain();\n        ClientResponse cr = client.callProcedure(\"@AdHoc\", \"select count(*) from narrow_p;\");\n        long rows1 = cr.getResults()[0].asScalarLong();\n        cr = client.callProcedure(\"@AdHoc\", \"select count(*) from narrow_index_p;\");\n        long rows2 = cr.getResults()[0].asScalarLong();\n        System.out.printf(\"Loaded %d,%d rows.\\n\", rows1, rows2);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Starting Benchmark\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // reset the stats after warmup\n        fullStatsContext.fetchAndResetBaseline();\n        periodicStatsContext.fetchAndResetBaseline();\n\n        benchmark1StartTS = System.currentTimeMillis();\n\n        System.out.println(\"\\nRunning seq scan benchmark...\");\n\n        for (int i = 0; i < config.runs; i++) {\n            client.callProcedure(\"MinSeqScan\");\n        }\n\n        benchmark1EndTS = System.currentTimeMillis();\n\n        benchmark2StartTS = System.currentTimeMillis();\n\n        System.out.println(\"\\nRunning index scan benchmark...\");\n\n        for (int i = 0; i < config.runs; i++) {\n            client.callProcedure(\"MinIndexScan\");\n        }\n\n        benchmark2EndTS = System.currentTimeMillis();\n\n        // print the summary results\n        printResults();\n\n        // close down the client connections\n        client.close();\n    }","id":71519,"modified_method":"/**\n     * Core benchmark code.\n     * Connect. Initialize. Run the loop. Cleanup. Print Results.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public void runBenchmark() throws Exception {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // connect to one or more servers, loop until success\n        connect(config.servers);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Loading Tuples\");\n        System.out.println(HORIZONTAL_RULE);\n\n        String loadproc = null;\n        String tablename = null;\n        String scanproc = null;\n\n        if (config.test.equals(\"sequential\")) {\n\n            loadproc = \"NARROW_P.insert\";\n            tablename = \"narrow_p\";\n            scanproc = \"MinSeqScan\";\n\n        } else if (config.test.equals(\"index\")) {\n\n            loadproc = \"NARROW_INDEX_P.insert\";\n            tablename = \"narrow_index_p\";\n            scanproc = \"MinIndexScan\";\n        }\n\n        for (long i = 0; i < config.rows; i++) {\n            client.callProcedure(new NullCallback(), loadproc, i % 509 /* radom prime */, i);\n            if ((i % 100000) == 0) {\n                System.out.printf(\"Loading row at index %d.\\n\", i);\n            }\n        }\n        client.drain();\n\n        ClientResponse cr = client.callProcedure(\"@AdHoc\", \"select count(*) from \" + tablename + \";\");\n        long rows = cr.getResults()[0].asScalarLong();\n\n        System.out.printf(\"Loaded %d rows.\\n\", rows);\n\n        assert (rows == config.rows);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Starting Benchmark\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // reset the stats after warmup\n        fullStatsContext.fetchAndResetBaseline();\n        periodicStatsContext.fetchAndResetBaseline();\n\n        benchmarkStartTS = System.currentTimeMillis();\n\n        System.out.printf(\"\\nRunning %s scan benchmark...\\n\", config.test);\n\n        for (int i = 0; i < config.runs; i++) {\n            client.callProcedure(scanproc);\n        }\n\n        benchmarkEndTS = System.currentTimeMillis();\n\n        // print the summary results\n        printResults();\n\n        // close down the client connections\n        client.close();\n    }","commit_id":"e3a9f6fba7ce3017e82fec9fb016e12d82168a7c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Prints the results of the voting simulation and statistics\n     * about performance.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public synchronized void printResults() throws Exception {\n        ClientStats stats = fullStatsContext.fetch().getStats();\n\n        // 3. Performance statistics\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Client Workload Statistics\");\n        System.out.println(HORIZONTAL_RULE);\n\n        //\n        double averageTimePerScan = (benchmark1EndTS - benchmark1StartTS) / (double) config.runs;\n        double tuplesPerSecond = (config.rows / averageTimePerScan) * 1000.0;\n\n        System.out.printf(\"Each of %d sequential scans of %d tuples took %.2fms for a throughput of %.2f tuples/second.\\n\",\n                config.runs, config.rows, averageTimePerScan, tuplesPerSecond);\n\n        averageTimePerScan = (benchmark2EndTS - benchmark2StartTS) / (double) config.runs;\n        tuplesPerSecond = (config.rows / averageTimePerScan) * 1000.0;\n\n        System.out.printf(\"Each of %d index scans of %d tuples took %.2fms for a throughput of %.2f tuples/second.\\n\",\n                config.runs, config.rows, averageTimePerScan, tuplesPerSecond);\n    }","id":71520,"modified_method":"/**\n     * Prints the results of the voting simulation and statistics\n     * about performance.\n     *\n     * @throws Exception if anything unexpected happens.\n     */\n    public synchronized void printResults() throws Exception {\n        ClientStats stats = fullStatsContext.fetch().getStats();\n\n        // 3. Performance statistics\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Client Workload Statistics\");\n        System.out.println(HORIZONTAL_RULE);\n\n        double averageTimePerScan = (benchmarkEndTS - benchmarkStartTS) / (double) config.runs;\n        double tuplesPerSecond = (config.rows / averageTimePerScan) * 1000.0;\n\n        System.out.printf(\"Each of %d %s scans of %d tuples took %.2fms for a throughput of %.2f tuples/second.\\n\",\n                config.runs, config.test, config.rows, averageTimePerScan, tuplesPerSecond);\n\n        PrintWriter outputStream = null;\n\n        if (config.statsfile != \"\") {\n            try {\n                outputStream = new PrintWriter(new FileWriter(config.statsfile));\n                // for stats: duration in milliseconds, # iterations (# rows in this case)\n                outputStream.printf(\"0,%d,%d,0,0,0,0\\n\", (long)Math.round(averageTimePerScan), config.rows);\n            } catch (Exception e) {\n                System.err.println(\"ERROR unable to write stats file\");\n                System.err.println(e);\n                System.exit(1);\n            } finally {\n                outputStream.close();\n            }\n        }\n    }","commit_id":"e3a9f6fba7ce3017e82fec9fb016e12d82168a7c","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void applyPermissionTemplate(Map<String, Object> params) {\n    UserSession.get().checkLoggedIn();\n\n    ApplyPermissionTemplateQuery query = ApplyPermissionTemplateQuery.buildFromParams(params);\n    query.validate();\n\n    // If only one project is selected, check user has admin permission on it, otherwise we are in the case of a bulk change and only system\n    // admin has permission to do it\n    if (query.getSelectedComponents().size() == 1) {\n      checkProjectAdminPermission(query.getSelectedComponents().get(0));\n    } else {\n      checkProjectAdminPermission(null);\n      UserSession.get().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n    }\n\n    for (String componentKey : query.getSelectedComponents()) {\n      ComponentDto component = (ComponentDto) resourceDao.findByKey(componentKey);\n      permissionFacade.applyPermissionTemplate(query.getTemplateKey(), component.getId());\n    }\n  }","id":71521,"modified_method":"public void applyPermissionTemplate(Map<String, Object> params) {\n    UserSession.get().checkLoggedIn();\n\n    ApplyPermissionTemplateQuery query = ApplyPermissionTemplateQuery.buildFromParams(params);\n    query.validate();\n\n    // If only one project is selected, check user has admin permission on it, otherwise we are in the case of a bulk change and only system\n    // admin has permission to do it\n    if (query.getSelectedComponents().size() == 1) {\n      checkProjectAdminPermission(query.getSelectedComponents().get(0));\n    } else {\n      checkProjectAdminPermission(null);\n      UserSession.get().checkGlobalPermission(GlobalPermissions.SYSTEM_ADMIN);\n    }\n\n    for (String componentKey : query.getSelectedComponents()) {\n      ComponentDto component = (ComponentDto) resourceDao.findByKey(componentKey);\n      if (component == null) {\n        throw new IllegalStateException(\"Unable to find component with key \" + componentKey);\n      }\n      permissionFacade.applyPermissionTemplate(query.getTemplateKey(), component.getId());\n    }\n  }","commit_id":"b9dd1505c80e7acf40a415b995eed30fe23d1e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public InternalPermissionTemplateService(PermissionTemplateDao permissionTemplateDao, UserDao userDao, ResourceDao resourceDao) {\n    this.permissionTemplateDao = permissionTemplateDao;\n    this.userDao = userDao;\n    this.resourceDao = resourceDao;\n  }","id":71522,"modified_method":"public InternalPermissionTemplateService(PermissionTemplateDao permissionTemplateDao, UserDao userDao) {\n    this.permissionTemplateDao = permissionTemplateDao;\n    this.userDao = userDao;\n  }","commit_id":"b9dd1505c80e7acf40a415b995eed30fe23d1e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    permissionTemplateDao = mock(PermissionTemplateDao.class);\n    userDao = mock(UserDao.class);\n    resourceDao = mock(ResourceDao.class);\n    permissionTemplateService = new InternalPermissionTemplateService(permissionTemplateDao, userDao, resourceDao);\n  }","id":71523,"modified_method":"@Before\n  public void setUp() {\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n    permissionTemplateDao = mock(PermissionTemplateDao.class);\n    userDao = mock(UserDao.class);\n    permissionTemplateService = new InternalPermissionTemplateService(permissionTemplateDao, userDao);\n  }","commit_id":"b9dd1505c80e7acf40a415b995eed30fe23d1e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_retrieve_all_permission_templates_from_project() throws Exception {\n    MockUserSession.set().setLogin(\"admin\").addProjectPermissions(UserRole.ADMIN, \"org.sample.Sample\");\n\n    PermissionTemplateDto template1 =\n      new PermissionTemplateDto().setId(1L).setName(\"template1\").setDescription(\"template1\");\n    PermissionTemplateDto template2 =\n      new PermissionTemplateDto().setId(2L).setName(\"template2\").setDescription(\"template2\");\n    when(permissionTemplateDao.selectAllPermissionTemplates()).thenReturn(Lists.newArrayList(template1, template2));\n\n    when(resourceDao.getResource(any(ResourceQuery.class))).thenReturn(\n      new ResourceDto().setId(10L).setKey(\"org.sample.Sample\"));\n\n    List<PermissionTemplate> templates = permissionTemplateService.selectAllPermissionTemplates(\"org.sample.Sample\");\n\n    assertThat(templates).hasSize(2);\n    assertThat(templates).onProperty(\"id\").containsOnly(1L, 2L);\n    assertThat(templates).onProperty(\"name\").containsOnly(\"template1\", \"template2\");\n    assertThat(templates).onProperty(\"description\").containsOnly(\"template1\", \"template2\");\n  }","id":71524,"modified_method":"@Test\n  public void should_retrieve_all_permission_templates_from_project() throws Exception {\n    MockUserSession.set().setLogin(\"admin\").addProjectPermissions(UserRole.ADMIN, \"org.sample.Sample\");\n\n    PermissionTemplateDto template1 =\n      new PermissionTemplateDto().setId(1L).setName(\"template1\").setDescription(\"template1\");\n    PermissionTemplateDto template2 =\n      new PermissionTemplateDto().setId(2L).setName(\"template2\").setDescription(\"template2\");\n    when(permissionTemplateDao.selectAllPermissionTemplates()).thenReturn(Lists.newArrayList(template1, template2));\n\n    List<PermissionTemplate> templates = permissionTemplateService.selectAllPermissionTemplates(\"org.sample.Sample\");\n\n    assertThat(templates).hasSize(2);\n    assertThat(templates).onProperty(\"id\").containsOnly(1L, 2L);\n    assertThat(templates).onProperty(\"name\").containsOnly(\"template1\", \"template2\");\n    assertThat(templates).onProperty(\"description\").containsOnly(\"template1\", \"template2\");\n  }","commit_id":"b9dd1505c80e7acf40a415b995eed30fe23d1e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Never return null, but an empty list if the issue does not exist.\n   * No security check is done since it should already have been done to get the issue\n   */\n  public List<Transition> listTransitions(@Nullable Issue issue, UserSession userSession) {\n    if (issue == null) {\n      return Collections.emptyList();\n    }\n    List<Transition> outTransitions = workflow.outTransitions(issue);\n    List<Transition> allowedTransitions = new ArrayList<Transition>();\n    for (Transition transition : outTransitions) {\n      DefaultIssue defaultIssue = (DefaultIssue) issue;\n      if (StringUtils.isBlank(transition.requiredProjectPermission()) ||\n        userSession.hasProjectPermission(UserRole.ISSUE_ADMIN, defaultIssue.projectKey())) {\n        allowedTransitions.add(transition);\n      }\n    }\n    return allowedTransitions;\n  }","id":71525,"modified_method":"/**\n   * Never return null, but an empty list if the issue does not exist.\n   * No security check is done since it should already have been done to get the issue\n   */\n  public List<Transition> listTransitions(@Nullable Issue issue, UserSession userSession) {\n    if (issue == null) {\n      return Collections.emptyList();\n    }\n    List<Transition> outTransitions = workflow.outTransitions(issue);\n    List<Transition> allowedTransitions = new ArrayList<Transition>();\n    for (Transition transition : outTransitions) {\n      DefaultIssue defaultIssue = (DefaultIssue) issue;\n      String projectKey = defaultIssue.projectKey();\n      if (StringUtils.isBlank(transition.requiredProjectPermission()) ||\n        (projectKey != null && userSession.hasProjectPermission(UserRole.ISSUE_ADMIN, projectKey))) {\n        allowedTransitions.add(transition);\n      }\n    }\n    return allowedTransitions;\n  }","commit_id":"b9dd1505c80e7acf40a415b995eed30fe23d1e1d","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void saveIssue(DbSession session, DefaultIssue issue, IssueChangeContext context) {\n    issueStorage.save(issue);\n    issueNotifications.sendChanges(issue, context,\n      getRuleByKey(issue.ruleKey()),\n      dbClient.componentDao().getByKey(session, issue.projectKey()),\n      dbClient.componentDao().getNullableByKey(session, issue.componentKey()));\n    dryRunCache.reportResourceModification(issue.componentKey());\n  }","id":71526,"modified_method":"private void saveIssue(DbSession session, DefaultIssue issue, IssueChangeContext context) {\n    String projectKey = issue.projectKey();\n    if (projectKey == null) {\n      throw new IllegalStateException(String.format(\"Issue '%s' has no project key\", issue.key()));\n    }\n    issueStorage.save(issue);\n    issueNotifications.sendChanges(issue, context,\n      getRuleByKey(issue.ruleKey()),\n      dbClient.componentDao().getByKey(session, projectKey),\n      dbClient.componentDao().getNullableByKey(session, issue.componentKey()));\n    dryRunCache.reportResourceModification(issue.componentKey());\n  }","commit_id":"e91859fc277ed458a180201c7fa128822661cde8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void setUp() {\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    MyBatis myBatis = mock(MyBatis.class);\n    when(myBatis.openSession(false)).thenReturn(session);\n    service = new InternalPermissionTemplateService(db, myBatis, permissionTemplateDao, userDao, finder);\n  }","id":71527,"modified_method":"@Before\n  public void setUp() {\n    MockUserSession.set().setLogin(\"admin\").setGlobalPermissions(GlobalPermissions.SYSTEM_ADMIN);\n\n    when(db.propertiesDao()).thenReturn(propertiesDao);\n\n    MyBatis myBatis = mock(MyBatis.class);\n    when(myBatis.openSession(false)).thenReturn(session);\n    service = new InternalPermissionTemplateService(db, myBatis, permissionTemplateDao, userDao, finder);\n  }","commit_id":"e91859fc277ed458a180201c7fa128822661cde8","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_create() {\n    BulkChangeQuery query = BulkChangeQuery.create()\n      .issues(\"ABCD\", \"EFGH\")\n      .actions(\"assign\")\n      .actionParameter(\"assign\", \"assignee\", \"geoffrey\")\n    ;\n\n    assertThat(query.urlParams()).hasSize(3).includes(\n      entry(\"issues\", \"ABCD,EFGH\"),\n      entry(\"actions\", \"assign\"),\n      entry(\"assign.assignee\", \"geoffrey\")\n    );\n  }","id":71528,"modified_method":"@Test\n  public void test_create() {\n    BulkChangeQuery query = BulkChangeQuery.create()\n      .issues(\"ABCD\", \"EFGH\")\n      .actions(\"assign\")\n      .actionParameter(\"assign\", \"assignee\", \"geoffrey\")\n      .comment(\"My bulk comment\")\n    ;\n\n    assertThat(query.urlParams()).hasSize(4).includes(\n      entry(\"issues\", \"ABCD,EFGH\"),\n      entry(\"actions\", \"assign\"),\n      entry(\"assign.assignee\", \"geoffrey\"),\n      entry(\"comment\", \"My bulk comment\")\n    );\n  }","commit_id":"c0880d1f396241e7dd0226ff6cd66f84fc73c33a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public IssueBulkChangeService(DefaultIssueFinder issueFinder, IssueUpdater issueUpdater, IssueStorage issueStorage, IssueNotifications issueNotifications, List<Action> actions) {\n    this.issueFinder = issueFinder;\n    this.issueUpdater = issueUpdater;\n    this.issueStorage = issueStorage;\n    this.issueNotifications = issueNotifications;\n    this.actions = actions;\n  }","id":71529,"modified_method":"public IssueBulkChangeService(DefaultIssueFinder issueFinder, IssueStorage issueStorage, IssueNotifications issueNotifications, List<Action> actions) {\n    this.issueFinder = issueFinder;\n    this.issueStorage = issueStorage;\n    this.issueNotifications = issueNotifications;\n    this.actions = actions;\n  }","commit_id":"c0880d1f396241e7dd0226ff6cd66f84fc73c33a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public IssueBulkChangeResult execute(IssueBulkChangeQuery issueBulkChangeQuery, UserSession userSession) {\n    LOG.debug(\"BulkChangeQuery : {}\", issueBulkChangeQuery);\n    verifyLoggedIn(userSession);\n\n    IssueBulkChangeResult result = new IssueBulkChangeResult();\n    IssueQueryResult issueQueryResult = issueFinder.find(IssueQuery.builder().issueKeys(issueBulkChangeQuery.issues()).requiredRole(UserRole.USER).build());\n    List<Issue> issues = issueQueryResult.issues();\n    for (String actionName : issueBulkChangeQuery.actions()) {\n      Action action = getAction(actionName);\n      if (action == null) {\n        throw new IllegalArgumentException(\"The action : '\"+ actionName + \"' is unknown\");\n      }\n      action.verify(issueBulkChangeQuery.properties(actionName), issues, userSession);\n    }\n\n    IssueChangeContext issueChangeContext = IssueChangeContext.createUser(new Date(), userSession.login());\n    for (Issue issue : issues) {\n      for (String actionName : issueBulkChangeQuery.actions()) {\n        try {\n          Action action = getAction(actionName);\n          ActionContext actionContext = new ActionContext(issue, issueChangeContext);\n          if (action.supports(issue) && action.execute(issueBulkChangeQuery.properties(actionName), actionContext)) {\n            issueStorage.save((DefaultIssue) issue);\n            issueNotifications.sendChanges((DefaultIssue) issue, issueChangeContext, issueQueryResult);\n            result.addIssueChanged(issue);\n          } else {\n            result.addIssueNotChanged(issue);\n          }\n        } catch (Exception e) {\n          result.addIssueNotChanged(issue);\n          LOG.info(\"An error occur when trying to apply the action : \"+ actionName + \" on issue : \"+ issue.key() + \". This issue has been ignored.\", e);\n        }\n      }\n    }\n    return result;\n  }","id":71530,"modified_method":"public IssueBulkChangeResult execute(IssueBulkChangeQuery issueBulkChangeQuery, UserSession userSession) {\n    LOG.debug(\"BulkChangeQuery : {}\", issueBulkChangeQuery);\n    verifyLoggedIn(userSession);\n\n    IssueBulkChangeResult result = new IssueBulkChangeResult();\n    IssueQueryResult issueQueryResult = issueFinder.find(IssueQuery.builder().issueKeys(issueBulkChangeQuery.issues()).requiredRole(UserRole.USER).build());\n    List<Issue> issues = issueQueryResult.issues();\n    List<Action> actions = newArrayList();\n    for (String actionName : issueBulkChangeQuery.actions()) {\n      Action action = getAction(actionName);\n      if (action == null) {\n        throw new IllegalArgumentException(\"The action : '\"+ actionName + \"' is unknown\");\n      }\n      action.verify(issueBulkChangeQuery.properties(actionName), issues, userSession);\n      actions.add(action);\n    }\n\n    IssueChangeContext issueChangeContext = IssueChangeContext.createUser(new Date(), userSession.login());\n    for (Issue issue : issues) {\n      for (Action action : actions) {\n        try {\n          ActionContext actionContext = new ActionContext(issue, issueChangeContext);\n          if (action.supports(issue) && action.execute(issueBulkChangeQuery.properties(action.key()), actionContext)) {\n            issueStorage.save((DefaultIssue) issue);\n            issueNotifications.sendChanges((DefaultIssue) issue, issueChangeContext, issueQueryResult);\n            result.addIssueChanged(issue);\n          } else {\n            result.addIssueNotChanged(issue);\n          }\n        } catch (Exception e) {\n          result.addIssueNotChanged(issue);\n          LOG.info(\"An error occur when trying to apply the action : \"+ action.key() + \" on issue : \"+ issue.key() + \". This issue has been ignored.\", e);\n        }\n      }\n    }\n    return result;\n  }","commit_id":"c0880d1f396241e7dd0226ff6cd66f84fc73c33a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void before() {\n    when(userSession.isLoggedIn()).thenReturn(true);\n    when(userSession.userId()).thenReturn(10);\n    when(userSession.login()).thenReturn(\"fred\");\n\n    when(finder.find(any(IssueQuery.class))).thenReturn(issueQueryResult);\n    when(issueQueryResult.issues()).thenReturn(newArrayList((Issue) issue));\n\n    when(action.key()).thenReturn(\"assign\");\n\n    actions = newArrayList();\n    actions.add(action);\n\n    service = new IssueBulkChangeService(finder, issueUpdater, issueStorage, issueNotifications, actions);\n  }","id":71531,"modified_method":"@Before\n  public void before() {\n    when(userSession.isLoggedIn()).thenReturn(true);\n    when(userSession.userId()).thenReturn(10);\n    when(userSession.login()).thenReturn(\"fred\");\n\n    when(finder.find(any(IssueQuery.class))).thenReturn(issueQueryResult);\n    when(issueQueryResult.issues()).thenReturn(newArrayList((Issue) issue));\n\n    when(action.key()).thenReturn(\"assign\");\n\n    List<Action> actions = newArrayList();\n    actions.add(action);\n\n    service = new IssueBulkChangeService(finder, issueStorage, issueNotifications, actions);\n  }","commit_id":"c0880d1f396241e7dd0226ff6cd66f84fc73c33a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public DefaultIssueFilter update(DefaultIssueFilter issueFilter, UserSession userSession) {\n    String user = getNotNullLogin(userSession);\n    IssueFilterDto issueFilterDto = findIssueFilterDto(issueFilter.id(), user);\n    verifyCurrentUserCanModifyFilter(issueFilterDto.toIssueFilter(), user);\n    if(issueFilterDto.getUserLogin() != issueFilter.user()) {\n      verifyCurrentUserCanChangeFilterOwnership(user);\n    }\n    validateFilter(issueFilter, user);\n\n    issueFilterDao.update(IssueFilterDto.toIssueFilter(issueFilter));\n    return issueFilter;\n  }","id":71532,"modified_method":"public DefaultIssueFilter update(DefaultIssueFilter issueFilter, UserSession userSession) {\n    String user = getNotNullLogin(userSession);\n    IssueFilterDto issueFilterDto = findIssueFilterDto(issueFilter.id(), user);\n    verifyCurrentUserCanModifyFilter(issueFilterDto.toIssueFilter(), user);\n    if(!issueFilterDto.getUserLogin().equals(issueFilter.user())) {\n      verifyCurrentUserCanChangeFilterOwnership(user);\n    }\n    validateFilter(issueFilter, user);\n\n    issueFilterDao.update(IssueFilterDto.toIssueFilter(issueFilter));\n    return issueFilter;\n  }","commit_id":"c0880d1f396241e7dd0226ff6cd66f84fc73c33a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void verifyIssuesAreAllRelatedOnActionPlanProject(List<Issue> issues, ActionPlan actionPlan) {\n    String projectKey = actionPlan.projectKey();\n    for (Issue issue : issues) {\n      DefaultIssue defaultIssue = (DefaultIssue) issue;\n      if (!defaultIssue.projectKey().equals(projectKey)) {\n        throw new IllegalArgumentException(\"Issues are not all related to the action plan project: \" + projectKey);\n      }\n    }\n  }","id":71533,"modified_method":"private void verifyIssuesAreAllRelatedOnActionPlanProject(List<Issue> issues, ActionPlan actionPlan) {\n    String projectKey = actionPlan.projectKey();\n    for (Issue issue : issues) {\n      DefaultIssue defaultIssue = (DefaultIssue) issue;\n      String issueProjectKey = defaultIssue.projectKey();\n      if (issueProjectKey == null || !issueProjectKey.equals(projectKey)) {\n        throw new IllegalArgumentException(\"Issues are not all related to the action plan project: \" + projectKey);\n      }\n    }\n  }","commit_id":"c0880d1f396241e7dd0226ff6cd66f84fc73c33a","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch sb) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) sb;\r\n        serverObjects prop = new serverObjects();\r\n        File defaultSettingsFile = new File(switchboard.getRootPath(), \"yacy.init\");\r\n        Map<String, String> defaultSettings = ((post == null) || (!(post.containsKey(\"submitdefault\")))) ? null : serverFileUtils.loadHashMap(defaultSettingsFile);\r\n        Iterator<String> threads = switchboard.threadNames();\r\n        String threadName;\r\n        serverThread thread;\r\n        \r\n        boolean xml = ((String)header.get(\"PATH\")).endsWith(\".xml\");\r\n        prop.setLocalized(!xml);\r\n        \r\n        // calculate totals\r\n        long blocktime_total = 0, sleeptime_total = 0, exectime_total = 0;\r\n        while (threads.hasNext()) {\r\n            threadName = (String) threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            blocktime_total += thread.getBlockTime();\r\n            sleeptime_total += thread.getSleepTime();\r\n            exectime_total += thread.getExecTime();\r\n        }   \r\n        if (blocktime_total == 0) blocktime_total = 1;\r\n        if (sleeptime_total == 0) sleeptime_total = 1;\r\n        if (exectime_total == 0) exectime_total = 1;\r\n        \r\n        // set templates for latest news from the threads\r\n        long blocktime, sleeptime, exectime;\r\n        long idlesleep, busysleep, memuse, memprereq;\r\n        int queuesize;\r\n        threads = switchboard.threadNames();\r\n        int c = 0;\r\n        long idleCycles, busyCycles, memshortageCycles;\r\n        while (threads.hasNext()) {\r\n            threadName = (String) threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            \r\n            // set values to templates\r\n            prop.put(\"table_\" + c + \"_threadname\", threadName);\r\n\r\n\t\t\tprop.putHTML(\"table_\" + c + \"_hasurl_shortdescr\", thread.getShortDescription(), xml);\r\n\t\t\tif(thread.getMonitorURL() == null) {\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"0\");\r\n\t\t\t}else{\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"1\");\r\n\t\t\t\tprop.put(\"table_\" + c + \"_hasurl_url\", thread.getMonitorURL());\r\n\t\t\t}\r\n            prop.putHTML(\"table_\" + c + \"_longdescr\", thread.getLongDescription(), xml);\r\n            queuesize = thread.getJobCount();\r\n            prop.put(\"table_\" + c + \"_queuesize\", (queuesize == Integer.MAX_VALUE) ? \"unlimited\" : yFormatter.number(queuesize, !xml));\r\n            \r\n            blocktime = thread.getBlockTime();\r\n            sleeptime = thread.getSleepTime();\r\n            exectime = thread.getExecTime();\r\n            memuse = thread.getMemoryUse();\r\n            idleCycles = thread.getIdleCycles();\r\n            busyCycles = thread.getBusyCycles();\r\n            memshortageCycles = thread.getOutOfMemoryCycles();\r\n            prop.putNum(\"table_\" + c + \"_blocktime\", blocktime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_blockpercent\", 100 * blocktime / blocktime_total);\r\n            prop.putNum(\"table_\" + c + \"_sleeptime\", sleeptime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercent\", 100 * sleeptime / sleeptime_total);\r\n            prop.putNum(\"table_\" + c + \"_exectime\", exectime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_execpercent\", 100 * exectime / exectime_total);\r\n            prop.putNum(\"table_\" + c + \"_totalcycles\", idleCycles + busyCycles + memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_idlecycles\", idleCycles);\r\n            prop.putNum(\"table_\" + c + \"_busycycles\", busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memscycles\", memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercycle\", ((idleCycles + busyCycles) == 0) ? -1 : sleeptime / (idleCycles + busyCycles));\r\n            prop.putNum(\"table_\" + c + \"_execpercycle\", (busyCycles == 0) ? -1 : exectime / busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memusepercycle\", (busyCycles == 0) ? -1 : memuse / busyCycles / 1024);\r\n            \r\n            if ((post != null) && (post.containsKey(\"submitdelay\"))) {\r\n                // load with new values\r\n                idlesleep = post.getLong(threadName + \"_idlesleep\", 1000);\r\n                busysleep = post.getLong(threadName + \"_busysleep\",  100);\r\n                memprereq = post.getLong(threadName + \"_memprereq\",    0) * 1024;\r\n                if (memprereq == 0) memprereq = sb.getConfigLong(threadName + \"_memprereq\", 0);\r\n                    \r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                \r\n                // on-the-fly re-configuration\r\n                switchboard.setThreadPerformance(threadName, idlesleep, busysleep, memprereq);\r\n                switchboard.setConfig(threadName + \"_idlesleep\", idlesleep);\r\n                switchboard.setConfig(threadName + \"_busysleep\", busysleep);\r\n                switchboard.setConfig(threadName + \"_memprereq\", memprereq);\r\n            } if ((post != null) && (post.containsKey(\"submitdefault\"))) {\r\n                // load with new values\r\n                idlesleep = Long.parseLong(d((String) defaultSettings.get(threadName + \"_idlesleep\"), \"1000\"));\r\n                busysleep = Long.parseLong(d((String) defaultSettings.get(threadName + \"_busysleep\"),  \"100\"));\r\n                memprereq = Long.parseLong(d((String) defaultSettings.get(threadName + \"_memprereq\"),    \"0\"));\r\n\r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                if ((threadName.equals(\"50_localcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"61_globalcrawltrigger\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"62_remotetriggeredcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n\r\n                // on-the-fly re-configuration\r\n                switchboard.setThreadPerformance(threadName, idlesleep, busysleep, memprereq);\r\n                switchboard.setConfig(threadName + \"_idlesleep\", idlesleep);\r\n                switchboard.setConfig(threadName + \"_busysleep\", busysleep);\r\n                switchboard.setConfig(threadName + \"_memprereq\", memprereq);\r\n            } else {\r\n                // load with old values\r\n                idlesleep = Long.parseLong(switchboard.getConfig(threadName + \"_idlesleep\" , \"1000\"));\r\n                busysleep = Long.parseLong(switchboard.getConfig(threadName + \"_busysleep\",   \"100\"));\r\n                memprereq = Long.parseLong(switchboard.getConfig(threadName + \"_memprereq\",     \"0\"));\r\n            }\r\n            prop.put(\"table_\" + c + \"_idlesleep\", idlesleep);\r\n            prop.put(\"table_\" + c + \"_busysleep\", busysleep);\r\n            prop.put(\"table_\" + c + \"_memprereq\", memprereq / 1024);\r\n            // disallow setting of memprereq for indexer to prevent db from throwing OOMs\r\n            prop.put(\"table_\" + c + \"_disabled\", /*(threadName.endsWith(\"_indexing\")) ? 1 :*/ \"0\");\r\n            prop.put(\"table_\" + c + \"_recommendation\", threadName.endsWith(\"_indexing\") ? \"1\" : \"0\");\r\n            prop.putNum(\"table_\" + c + \"_recommendation_value\", threadName.endsWith(\"_indexing\") ? (switchboard.wordIndex.minMem() / 1024) : 0);\r\n            c++;\r\n        }\r\n        prop.put(\"table\", c);\r\n        \r\n        if ((post != null) && (post.containsKey(\"cacheSizeSubmit\"))) {\r\n            int wordCacheMaxCount = post.getInt(\"wordCacheMaxCount\", 20000);\r\n            switchboard.setConfig(plasmaSwitchboard.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\r\n            switchboard.wordIndex.setMaxWordCount(wordCacheMaxCount);\r\n            \r\n            int wordCacheInitCount = post.getInt(plasmaSwitchboard.WORDCACHE_INIT_COUNT, 30000);\r\n            switchboard.setConfig(plasmaSwitchboard.WORDCACHE_INIT_COUNT, Integer.toString(wordCacheInitCount));\r\n            \r\n            int flushsize = post.getInt(\"wordFlushSize\", 2000);\r\n            switchboard.setConfig(\"wordFlushSize\", Integer.toString(flushsize));\r\n            switchboard.wordIndex.setWordFlushSize(flushsize);\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"poolConfig\"))) {\r\n            \r\n            /* \r\n             * configuring the crawler pool \r\n             */\r\n            // getting the current crawler pool configuration\r\n            int maxBusy = Integer.parseInt(post.get(\"Crawler Pool_maxActive\",\"8\"));\r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(plasmaSwitchboard.CRAWLER_THREADS_ACTIVE_MAX,maxBusy);\r\n            //switchboard.setConfig(\"crawler.MinIdleThreads\",minIdle);\r\n            \r\n            /* \r\n             * configuring the http pool \r\n             */\r\n            serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n            try {\r\n                maxBusy = Integer.parseInt(post.get(\"httpd Session Pool_maxActive\",\"8\"));\r\n            } catch (NumberFormatException e) {\r\n                maxBusy = 8;\r\n            }\r\n\r\n            ((serverCore)httpd).setMaxSessionCount(maxBusy);    \r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(\"httpdMaxBusySessions\",maxBusy);\r\n\r\n        }        \r\n        \r\n        if ((post != null) && (post.containsKey(\"PrioritySubmit\"))) {\r\n        \tswitchboard.setConfig(\"javastart_priority\",post.get(\"YaCyPriority\",\"0\"));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"proxyControlSubmit\"))) {\r\n            int onlineCautionDelay = post.getInt(\"onlineCautionDelay\", 30000);\r\n            switchboard.setConfig(\"onlineCautionDelay\", Integer.toString(onlineCautionDelay));\r\n        }\r\n        \r\n        // table cache settings\r\n        prop.putNum(\"urlCacheSize\", switchboard.wordIndex.loadedURL.writeCacheSize());  \r\n        prop.putNum(\"wordCacheWSize\", switchboard.wordIndex.dhtOutCacheSize());\r\n        prop.putNum(\"wordCacheKSize\", switchboard.wordIndex.dhtInCacheSize());\r\n        prop.putNum(\"wordCacheWSizeKBytes\", switchboard.wordIndex.dhtCacheSizeBytes(false)/1024);\r\n        prop.putNum(\"wordCacheKSizeKBytes\", switchboard.wordIndex.dhtCacheSizeBytes(true)/1024);\r\n        prop.putNum(\"maxURLinWCache\", switchboard.wordIndex.maxURLinDHTOutCache());\r\n        prop.putNum(\"maxURLinKCache\", switchboard.wordIndex.maxURLinDHTInCache());\r\n        prop.putNum(\"maxAgeOfWCache\", switchboard.wordIndex.maxAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxAgeOfKCache\", switchboard.wordIndex.maxAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfWCache\", switchboard.wordIndex.minAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfKCache\", switchboard.wordIndex.minAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxWaitingWordFlush\", switchboard.getConfigLong(\"maxWaitingWordFlush\", 180));\r\n        prop.put(\"wordCacheMaxCount\", switchboard.getConfigLong(plasmaSwitchboard.WORDCACHE_MAX_COUNT, 20000));\r\n        prop.put(\"wordCacheInitCount\", switchboard.getConfigLong(plasmaSwitchboard.WORDCACHE_INIT_COUNT, 30000));\r\n        prop.put(\"wordFlushSize\", switchboard.getConfigLong(\"wordFlushSize\", 2000));\r\n        prop.put(\"onlineCautionDelay\", switchboard.getConfigLong(\"onlineCautionDelay\", 30000));\r\n        prop.putNum(\"onlineCautionDelayCurrent\", System.currentTimeMillis() - switchboard.proxyLastAccess);\r\n        \r\n        // table thread pool settings\n        prop.put(\"pool_0_name\",\"Crawler Pool\");\r\n        prop.put(\"pool_0_maxActive\", switchboard.getConfigLong(\"crawler.MaxActiveThreads\", 0));\r\n        prop.put(\"pool_0_numActive\",switchboard.crawlQueues.size());\n        \r\n        serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n        prop.put(\"pool_1_name\", \"httpd Session Pool\");\r\n        prop.put(\"pool_1_maxActive\", ((serverCore)httpd).getMaxSessionCount());\r\n        prop.put(\"pool_1_numActive\", ((serverCore)httpd).getJobCount());\r\n        \n        prop.put(\"pool\", \"2\");\n        \r\n        long curr_prio = switchboard.getConfigLong(\"javastart_priority\",0);\r\n        prop.put(\"priority_normal\",(curr_prio==0) ? \"1\" : \"0\");\r\n        prop.put(\"priority_below\",(curr_prio==10) ? \"1\" : \"0\");\r\n        prop.put(\"priority_low\",(curr_prio==20) ? \"1\" : \"0\");\r\n        \r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","id":71534,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch sb) {\r\n        // return variable that accumulates replacements\r\n        plasmaSwitchboard switchboard = (plasmaSwitchboard) sb;\r\n        serverObjects prop = new serverObjects();\r\n        File defaultSettingsFile = new File(switchboard.getRootPath(), \"yacy.init\");\r\n        Map<String, String> defaultSettings = ((post == null) || (!(post.containsKey(\"submitdefault\")))) ? null : serverFileUtils.loadHashMap(defaultSettingsFile);\r\n        Iterator<String> threads = switchboard.threadNames();\r\n        String threadName;\r\n        serverThread thread;\r\n        \r\n        boolean xml = ((String)header.get(\"PATH\")).endsWith(\".xml\");\r\n        prop.setLocalized(!xml);\r\n        \r\n        // calculate totals\r\n        long blocktime_total = 0, sleeptime_total = 0, exectime_total = 0;\r\n        while (threads.hasNext()) {\r\n            threadName = (String) threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            blocktime_total += thread.getBlockTime();\r\n            sleeptime_total += thread.getSleepTime();\r\n            exectime_total += thread.getExecTime();\r\n        }   \r\n        if (blocktime_total == 0) blocktime_total = 1;\r\n        if (sleeptime_total == 0) sleeptime_total = 1;\r\n        if (exectime_total == 0) exectime_total = 1;\r\n        \r\n        // set templates for latest news from the threads\r\n        long blocktime, sleeptime, exectime;\r\n        long idlesleep, busysleep, memuse, memprereq;\r\n        int queuesize;\r\n        threads = switchboard.threadNames();\r\n        int c = 0;\r\n        long idleCycles, busyCycles, memshortageCycles;\r\n        while (threads.hasNext()) {\r\n            threadName = (String) threads.next();\r\n            thread = switchboard.getThread(threadName);\r\n            \r\n            // set values to templates\r\n            prop.put(\"table_\" + c + \"_threadname\", threadName);\r\n\r\n\t\t\tprop.putHTML(\"table_\" + c + \"_hasurl_shortdescr\", thread.getShortDescription(), xml);\r\n\t\t\tif(thread.getMonitorURL() == null) {\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"0\");\r\n\t\t\t}else{\r\n\t\t\t\tprop.put(\"table_\"+c+\"_hasurl\", \"1\");\r\n\t\t\t\tprop.put(\"table_\" + c + \"_hasurl_url\", thread.getMonitorURL());\r\n\t\t\t}\r\n            prop.putHTML(\"table_\" + c + \"_longdescr\", thread.getLongDescription(), xml);\r\n            queuesize = thread.getJobCount();\r\n            prop.put(\"table_\" + c + \"_queuesize\", (queuesize == Integer.MAX_VALUE) ? \"unlimited\" : yFormatter.number(queuesize, !xml));\r\n            \r\n            blocktime = thread.getBlockTime();\r\n            sleeptime = thread.getSleepTime();\r\n            exectime = thread.getExecTime();\r\n            memuse = thread.getMemoryUse();\r\n            idleCycles = thread.getIdleCycles();\r\n            busyCycles = thread.getBusyCycles();\r\n            memshortageCycles = thread.getOutOfMemoryCycles();\r\n            prop.putNum(\"table_\" + c + \"_blocktime\", blocktime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_blockpercent\", 100 * blocktime / blocktime_total);\r\n            prop.putNum(\"table_\" + c + \"_sleeptime\", sleeptime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercent\", 100 * sleeptime / sleeptime_total);\r\n            prop.putNum(\"table_\" + c + \"_exectime\", exectime / 1000);\r\n            prop.putNum(\"table_\" + c + \"_execpercent\", 100 * exectime / exectime_total);\r\n            prop.putNum(\"table_\" + c + \"_totalcycles\", idleCycles + busyCycles + memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_idlecycles\", idleCycles);\r\n            prop.putNum(\"table_\" + c + \"_busycycles\", busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memscycles\", memshortageCycles);\r\n            prop.putNum(\"table_\" + c + \"_sleeppercycle\", ((idleCycles + busyCycles) == 0) ? -1 : sleeptime / (idleCycles + busyCycles));\r\n            prop.putNum(\"table_\" + c + \"_execpercycle\", (busyCycles == 0) ? -1 : exectime / busyCycles);\r\n            prop.putNum(\"table_\" + c + \"_memusepercycle\", (busyCycles == 0) ? -1 : memuse / busyCycles / 1024);\r\n            \r\n            if ((post != null) && (post.containsKey(\"submitdelay\"))) {\r\n                // load with new values\r\n                idlesleep = post.getLong(threadName + \"_idlesleep\", 1000);\r\n                busysleep = post.getLong(threadName + \"_busysleep\",  100);\r\n                memprereq = post.getLong(threadName + \"_memprereq\",    0) * 1024;\r\n                if (memprereq == 0) memprereq = sb.getConfigLong(threadName + \"_memprereq\", 0);\r\n                    \r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                \r\n                // on-the-fly re-configuration\r\n                switchboard.setThreadPerformance(threadName, idlesleep, busysleep, memprereq);\r\n                switchboard.setConfig(threadName + \"_idlesleep\", idlesleep);\r\n                switchboard.setConfig(threadName + \"_busysleep\", busysleep);\r\n                switchboard.setConfig(threadName + \"_memprereq\", memprereq);\r\n            } if ((post != null) && (post.containsKey(\"submitdefault\"))) {\r\n                // load with new values\r\n                idlesleep = Long.parseLong(d((String) defaultSettings.get(threadName + \"_idlesleep\"), \"1000\"));\r\n                busysleep = Long.parseLong(d((String) defaultSettings.get(threadName + \"_busysleep\"),  \"100\"));\r\n                memprereq = Long.parseLong(d((String) defaultSettings.get(threadName + \"_memprereq\"),    \"0\"));\r\n\r\n                // check values to prevent short-cut loops\r\n                if (idlesleep < 1000) idlesleep = 1000;\r\n                if (threadName.equals(\"10_httpd\")) { idlesleep = 0; busysleep = 0; memprereq = 0; }\r\n                if ((threadName.equals(\"50_localcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"61_globalcrawltrigger\")) && (busysleep < 100)) busysleep = 100;\r\n                if ((threadName.equals(\"62_remotetriggeredcrawl\")) && (busysleep < 100)) busysleep = 100;\r\n\r\n                // on-the-fly re-configuration\r\n                switchboard.setThreadPerformance(threadName, idlesleep, busysleep, memprereq);\r\n                switchboard.setConfig(threadName + \"_idlesleep\", idlesleep);\r\n                switchboard.setConfig(threadName + \"_busysleep\", busysleep);\r\n                switchboard.setConfig(threadName + \"_memprereq\", memprereq);\r\n            } else {\r\n                // load with old values\r\n                idlesleep = Long.parseLong(switchboard.getConfig(threadName + \"_idlesleep\" , \"1000\"));\r\n                busysleep = Long.parseLong(switchboard.getConfig(threadName + \"_busysleep\",   \"100\"));\r\n                memprereq = Long.parseLong(switchboard.getConfig(threadName + \"_memprereq\",     \"0\"));\r\n            }\r\n            prop.put(\"table_\" + c + \"_idlesleep\", idlesleep);\r\n            prop.put(\"table_\" + c + \"_busysleep\", busysleep);\r\n            prop.put(\"table_\" + c + \"_memprereq\", memprereq / 1024);\r\n            // disallow setting of memprereq for indexer to prevent db from throwing OOMs\r\n            prop.put(\"table_\" + c + \"_disabled\", /*(threadName.endsWith(\"_indexing\")) ? 1 :*/ \"0\");\r\n            prop.put(\"table_\" + c + \"_recommendation\", threadName.endsWith(\"_indexing\") ? \"1\" : \"0\");\r\n            prop.putNum(\"table_\" + c + \"_recommendation_value\", threadName.endsWith(\"_indexing\") ? (switchboard.wordIndex.minMem() / 1024) : 0);\r\n            c++;\r\n        }\r\n        prop.put(\"table\", c);\r\n        \r\n        if ((post != null) && (post.containsKey(\"cacheSizeSubmit\"))) {\r\n            int wordCacheMaxCount = post.getInt(\"wordCacheMaxCount\", 20000);\r\n            switchboard.setConfig(plasmaSwitchboard.WORDCACHE_MAX_COUNT, Integer.toString(wordCacheMaxCount));\r\n            switchboard.wordIndex.setMaxWordCount(wordCacheMaxCount);\r\n            \r\n            int wordCacheInitCount = post.getInt(plasmaSwitchboard.WORDCACHE_INIT_COUNT, 30000);\r\n            switchboard.setConfig(plasmaSwitchboard.WORDCACHE_INIT_COUNT, Integer.toString(wordCacheInitCount));\r\n            \r\n            int flushsize = post.getInt(\"wordFlushSize\", 2000);\r\n            switchboard.setConfig(\"wordFlushSize\", Integer.toString(flushsize));\r\n            switchboard.wordIndex.setWordFlushSize(flushsize);\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"poolConfig\"))) {\r\n            \r\n            /* \r\n             * configuring the crawler pool \r\n             */\r\n            // getting the current crawler pool configuration\r\n            int maxBusy = Integer.parseInt(post.get(\"Crawler Pool_maxActive\",\"8\"));\r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(plasmaSwitchboard.CRAWLER_THREADS_ACTIVE_MAX,maxBusy);\r\n            //switchboard.setConfig(\"crawler.MinIdleThreads\",minIdle);\r\n            \r\n            /* \r\n             * configuring the http pool \r\n             */\r\n            serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n            try {\r\n                maxBusy = Integer.parseInt(post.get(\"httpd Session Pool_maxActive\",\"8\"));\r\n            } catch (NumberFormatException e) {\r\n                maxBusy = 8;\r\n            }\r\n\r\n            ((serverCore)httpd).setMaxSessionCount(maxBusy);    \r\n            \r\n            // storing the new values into configfile\r\n            switchboard.setConfig(\"httpdMaxBusySessions\",maxBusy);\r\n\r\n        }        \r\n        \r\n        if ((post != null) && (post.containsKey(\"PrioritySubmit\"))) {\r\n        \tswitchboard.setConfig(\"javastart_priority\",post.get(\"YaCyPriority\",\"0\"));\r\n        }\r\n        \r\n        if ((post != null) && (post.containsKey(\"onlineCautionSubmit\"))) {\r\n            switchboard.setConfig(plasmaSwitchboard.PROXY_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseProxy\", 30000)));\r\n            switchboard.setConfig(plasmaSwitchboard.LOCALSEACH_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseLocalsearch\", 30000)));\r\n            switchboard.setConfig(plasmaSwitchboard.REMOTESEARCH_ONLINE_CAUTION_DELAY, Integer.toString(post.getInt(\"crawlPauseRemotesearch\", 30000)));\r\n        }\r\n        \r\n        // table cache settings\r\n        prop.putNum(\"urlCacheSize\", switchboard.wordIndex.loadedURL.writeCacheSize());  \r\n        prop.putNum(\"wordCacheWSize\", switchboard.wordIndex.dhtOutCacheSize());\r\n        prop.putNum(\"wordCacheKSize\", switchboard.wordIndex.dhtInCacheSize());\r\n        prop.putNum(\"wordCacheWSizeKBytes\", switchboard.wordIndex.dhtCacheSizeBytes(false)/1024);\r\n        prop.putNum(\"wordCacheKSizeKBytes\", switchboard.wordIndex.dhtCacheSizeBytes(true)/1024);\r\n        prop.putNum(\"maxURLinWCache\", switchboard.wordIndex.maxURLinDHTOutCache());\r\n        prop.putNum(\"maxURLinKCache\", switchboard.wordIndex.maxURLinDHTInCache());\r\n        prop.putNum(\"maxAgeOfWCache\", switchboard.wordIndex.maxAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxAgeOfKCache\", switchboard.wordIndex.maxAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfWCache\", switchboard.wordIndex.minAgeOfDHTOutCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"minAgeOfKCache\", switchboard.wordIndex.minAgeOfDHTInCache() / 1000 / 60); // minutes\r\n        prop.putNum(\"maxWaitingWordFlush\", switchboard.getConfigLong(\"maxWaitingWordFlush\", 180));\r\n        prop.put(\"wordCacheMaxCount\", switchboard.getConfigLong(plasmaSwitchboard.WORDCACHE_MAX_COUNT, 20000));\r\n        prop.put(\"wordCacheInitCount\", switchboard.getConfigLong(plasmaSwitchboard.WORDCACHE_INIT_COUNT, 30000));\r\n        prop.put(\"wordFlushSize\", switchboard.getConfigLong(\"wordFlushSize\", 2000));\r\n        prop.put(\"crawlPauseProxy\", switchboard.getConfigLong(plasmaSwitchboard.PROXY_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.put(\"crawlPauseLocalsearch\", switchboard.getConfigLong(plasmaSwitchboard.LOCALSEACH_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.put(\"crawlPauseRemotesearch\", switchboard.getConfigLong(plasmaSwitchboard.REMOTESEARCH_ONLINE_CAUTION_DELAY, 30000));\r\n        prop.putNum(\"crawlPauseProxyCurrent\", (System.currentTimeMillis() - switchboard.proxyLastAccess) / 1000);\r\n        prop.putNum(\"crawlPauseLocalsearchCurrent\", (System.currentTimeMillis() - switchboard.localSearchLastAccess) / 1000);\r\n        prop.putNum(\"crawlPauseRemotesearchCurrent\", (System.currentTimeMillis() - switchboard.remoteSearchLastAccess) / 1000);\r\n        \r\n        // table thread pool settings\n        prop.put(\"pool_0_name\",\"Crawler Pool\");\r\n        prop.put(\"pool_0_maxActive\", switchboard.getConfigLong(\"crawler.MaxActiveThreads\", 0));\r\n        prop.put(\"pool_0_numActive\",switchboard.crawlQueues.size());\n        \r\n        serverThread httpd = switchboard.getThread(\"10_httpd\");\r\n        prop.put(\"pool_1_name\", \"httpd Session Pool\");\r\n        prop.put(\"pool_1_maxActive\", ((serverCore)httpd).getMaxSessionCount());\r\n        prop.put(\"pool_1_numActive\", ((serverCore)httpd).getJobCount());\r\n        \n        prop.put(\"pool\", \"2\");\n        \r\n        long curr_prio = switchboard.getConfigLong(\"javastart_priority\",0);\r\n        prop.put(\"priority_normal\",(curr_prio==0) ? \"1\" : \"0\");\r\n        prop.put(\"priority_below\",(curr_prio==10) ? \"1\" : \"0\");\r\n        prop.put(\"priority_low\",(curr_prio==20) ? \"1\" : \"0\");\r\n        \r\n        // return rewrite values for templates\r\n        return prop;\r\n    }","commit_id":"3c7b94c119085a02a5871d97faa954bda9aa35e0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        // access control\r\n        boolean publicPage = sb.getConfigBool(\"publicSearchpage\", true);\r\n        boolean authorizedAccess = sb.verifyAuthentication(header, false);\r\n        if ((post != null) && (post.containsKey(\"publicPage\"))) {\r\n            if (!authorizedAccess) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            publicPage = post.get(\"publicPage\", \"0\").equals(\"1\");\r\n            sb.setConfig(\"publicSearchpage\", publicPage);\r\n        }\r\n        \r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        final int display = ((post == null) || (!authenticated)) ? 0 : post.getInt(\"display\", 0);\r\n        final int searchoptions = (post == null) ? 0 : post.getInt(\"searchoptions\", 0);\r\n        final String former = (post == null) ? \"\" : post.get(\"former\", \"\");\r\n        final int count = Math.min(100, (post == null) ? 10 : post.getInt(\"count\", 10));\r\n        final String urlmaskfilter = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\");\r\n        final String prefermaskfilter = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        final String constraint = (post == null) ? \"\" : post.get(\"constraint\", \"\");\r\n        final String cat = (post == null) ? \"href\" : post.get(\"cat\", \"href\");\r\n        final int type = (post == null) ? 0 : post.getInt(\"type\", 0);\r\n        \r\n        final boolean indexDistributeGranted = sb.getConfigBool(plasmaSwitchboard.INDEX_DIST_ALLOW, true);\r\n        final boolean indexReceiveGranted = sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, true);\r\n        global = global && indexDistributeGranted && indexReceiveGranted;\r\n/*\r\n        final String referer = (String) header.get(httpHeader.REFERER);\r\n        if (referer != null) {\r\n            yacyURL url;\r\n            try {\r\n                url = new yacyURL(referer, null);\r\n            } catch (MalformedURLException e) {\r\n                url = null;\r\n            }\r\n            if ((url != null) && (!url.isLocal())) {\r\n                final HashMap referrerprop = new HashMap();\r\n                referrerprop.put(\"count\", \"1\");\r\n                referrerprop.put(\"clientip\", header.get(httpHeader.CONNECTION_PROP_CLIENTIP));\r\n                referrerprop.put(\"useragent\", header.get(httpHeader.USER_AGENT));\r\n                referrerprop.put(\"date\", (new serverDate()).toShortString(false));\r\n                if (sb.facilityDB != null) try {sb.facilityDB.update(\"backlinks\", referer, referrerprop);} catch (IOException e) {}\r\n            }\r\n        }\r\n*/\r\n        // search domain\r\n        int contentdom = plasmaSearchQuery.CONTENTDOM_TEXT;\r\n        String cds = (post == null) ? \"text\" : post.get(\"contentdom\", \"text\");\r\n        if (cds.equals(\"text\")) contentdom = plasmaSearchQuery.CONTENTDOM_TEXT;\r\n        if (cds.equals(\"audio\")) contentdom = plasmaSearchQuery.CONTENTDOM_AUDIO;\r\n        if (cds.equals(\"video\")) contentdom = plasmaSearchQuery.CONTENTDOM_VIDEO;\r\n        if (cds.equals(\"image\")) contentdom = plasmaSearchQuery.CONTENTDOM_IMAGE;\r\n        if (cds.equals(\"app\")) contentdom = plasmaSearchQuery.CONTENTDOM_APP;\r\n        \r\n        //long mylinks = 0;\r\n        prop.putNum(\"links\", yacyCore.seedDB.mySeed().getLinkCount());\r\n        \r\n        // we create empty entries for template strings\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        prop.putHTML(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"former\", former);\r\n        prop.put(\"num-results\", \"0\");\r\n        prop.put(\"excluded\", \"0\");\r\n        prop.put(\"combine\", \"0\");\r\n        prop.put(\"resultbottomline\", \"0\");\r\n        prop.put(\"searchoptions\", searchoptions);\r\n        prop.put(\"searchoptions_count-10\", (count == 10) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-50\", (count == 50) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-100\", (count == 100) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global\", global ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global-disabled\", (indexReceiveGranted && indexDistributeGranted) ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_resource-global-disabled_reason\", (indexReceiveGranted) ? \"0\" : (indexDistributeGranted ? \"1\" : \"2\"));\r\n        prop.put(\"searchoptions_resource-local\", global ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_urlmaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_urlmaskoptions_urlmaskfilter\", urlmaskfilter);\r\n        prop.put(\"searchoptions_prefermaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_prefermaskoptions_prefermaskfilter\", prefermaskfilter);\r\n        prop.put(\"searchoptions_indexofChecked\", \"\");\r\n        prop.put(\"searchoptions_publicSearchpage\", (publicPage == true) ? \"0\" : \"1\");\r\n        prop.put(\"results\", \"\");\r\n        prop.put(\"cat\", cat);\r\n        prop.put(\"type\", type);\r\n        prop.put(\"depth\", \"0\");\r\n        prop.put(\"display\", display);\r\n        prop.put(\"constraint\", constraint);\r\n        prop.put(\"searchoptions_display\", display);\r\n        prop.put(\"contentdomCheckText\", (contentdom == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckAudio\", (contentdom == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckVideo\", (contentdom == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckImage\", (contentdom == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckApp\", (contentdom == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // online caution timing\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        return prop;\r\n    }","id":71535,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        // access control\r\n        boolean publicPage = sb.getConfigBool(\"publicSearchpage\", true);\r\n        boolean authorizedAccess = sb.verifyAuthentication(header, false);\r\n        if ((post != null) && (post.containsKey(\"publicPage\"))) {\r\n            if (!authorizedAccess) {\r\n                prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                return prop;\r\n            }\r\n            publicPage = post.get(\"publicPage\", \"0\").equals(\"1\");\r\n            sb.setConfig(\"publicSearchpage\", publicPage);\r\n        }\r\n        \r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        final int display = ((post == null) || (!authenticated)) ? 0 : post.getInt(\"display\", 0);\r\n        final int searchoptions = (post == null) ? 0 : post.getInt(\"searchoptions\", 0);\r\n        final String former = (post == null) ? \"\" : post.get(\"former\", \"\");\r\n        final int count = Math.min(100, (post == null) ? 10 : post.getInt(\"count\", 10));\r\n        final String urlmaskfilter = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\");\r\n        final String prefermaskfilter = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\r\n        final String constraint = (post == null) ? \"\" : post.get(\"constraint\", \"\");\r\n        final String cat = (post == null) ? \"href\" : post.get(\"cat\", \"href\");\r\n        final int type = (post == null) ? 0 : post.getInt(\"type\", 0);\r\n        \r\n        final boolean indexDistributeGranted = sb.getConfigBool(plasmaSwitchboard.INDEX_DIST_ALLOW, true);\r\n        final boolean indexReceiveGranted = sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, true);\r\n        //global = global && indexDistributeGranted && indexReceiveGranted;\r\n        \r\n        // search domain\r\n        int contentdom = plasmaSearchQuery.CONTENTDOM_TEXT;\r\n        String cds = (post == null) ? \"text\" : post.get(\"contentdom\", \"text\");\r\n        if (cds.equals(\"text\")) contentdom = plasmaSearchQuery.CONTENTDOM_TEXT;\r\n        if (cds.equals(\"audio\")) contentdom = plasmaSearchQuery.CONTENTDOM_AUDIO;\r\n        if (cds.equals(\"video\")) contentdom = plasmaSearchQuery.CONTENTDOM_VIDEO;\r\n        if (cds.equals(\"image\")) contentdom = plasmaSearchQuery.CONTENTDOM_IMAGE;\r\n        if (cds.equals(\"app\")) contentdom = plasmaSearchQuery.CONTENTDOM_APP;\r\n        \r\n        //long mylinks = 0;\r\n        prop.putNum(\"links\", yacyCore.seedDB.mySeed().getLinkCount());\r\n        \r\n        // we create empty entries for template strings\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        prop.putHTML(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"former\", former);\r\n        prop.put(\"num-results\", \"0\");\r\n        prop.put(\"excluded\", \"0\");\r\n        prop.put(\"combine\", \"0\");\r\n        prop.put(\"resultbottomline\", \"0\");\r\n        prop.put(\"searchoptions\", searchoptions);\r\n        prop.put(\"searchoptions_count-10\", (count == 10) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-50\", (count == 50) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_count-100\", (count == 100) ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global\", global ? \"1\" : \"0\");\r\n        prop.put(\"searchoptions_resource-global-disabled\", (indexReceiveGranted && indexDistributeGranted) ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_resource-global-disabled_reason\", (indexReceiveGranted) ? \"0\" : (indexDistributeGranted ? \"1\" : \"2\"));\r\n        prop.put(\"searchoptions_resource-local\", global ? \"0\" : \"1\");\r\n        prop.put(\"searchoptions_urlmaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_urlmaskoptions_urlmaskfilter\", urlmaskfilter);\r\n        prop.put(\"searchoptions_prefermaskoptions\", \"0\");\r\n        prop.putHTML(\"searchoptions_prefermaskoptions_prefermaskfilter\", prefermaskfilter);\r\n        prop.put(\"searchoptions_indexofChecked\", \"\");\r\n        prop.put(\"searchoptions_publicSearchpage\", (publicPage == true) ? \"0\" : \"1\");\r\n        prop.put(\"results\", \"\");\r\n        prop.put(\"cat\", cat);\r\n        prop.put(\"type\", type);\r\n        prop.put(\"depth\", \"0\");\r\n        prop.put(\"display\", display);\r\n        prop.put(\"constraint\", constraint);\r\n        prop.put(\"searchoptions_display\", display);\r\n        prop.put(\"contentdomCheckText\", (contentdom == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckAudio\", (contentdom == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckVideo\", (contentdom == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckImage\", (contentdom == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"contentdomCheckApp\", (contentdom == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // online caution timing\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        return prop;\r\n    }","commit_id":"3c7b94c119085a02a5871d97faa954bda9aa35e0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static void deployScript(File scriptFile, String theScript) throws IOException {\r\n        serverFileUtils.write(theScript.getBytes(), scriptFile);\r\n        try {\r\n            Runtime.getRuntime().exec(\"chmod 755 \" + scriptFile.getAbsolutePath().replaceAll(\" \", \"\\\\ \")).waitFor();\r\n        } catch (InterruptedException e) {\r\n            throw new IOException(e.getMessage());\r\n        }\r\n    }","id":71536,"modified_method":"public static void deployScript(File scriptFile, String theScript) throws IOException {\r\n        serverFileUtils.write(theScript.getBytes(), scriptFile);\r\n        try {\r\n            Runtime.getRuntime().exec(\"chmod 755 \" + scriptFile.getAbsolutePath().replaceAll(\" \", \"\\\\ \")).waitFor();\r\n        } catch (InterruptedException e) {\r\n            serverLog.logSevere(\"DEPLOY\", \"deploy of script file failed. file = \" + scriptFile.getAbsolutePath(), e);\r\n            throw new IOException(e.getMessage());\r\n        }\r\n    }","commit_id":"3c7b94c119085a02a5871d97faa954bda9aa35e0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n\r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"search\", \"\").trim();\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n        \t/*\r\n            // save referrer\r\n            final String referer = (String) header.get(\"Referer\");\r\n        \tif (referer != null) {\r\n                yacyURL url;\r\n                try { url = new yacyURL(referer, null); } catch (MalformedURLException e) { url = null; }\r\n                if ((url != null) && (!url.isLocal())) {\r\n                    final HashMap referrerprop = new HashMap();\r\n                    referrerprop.put(\"count\", \"1\");\r\n                    referrerprop.put(\"clientip\", header.get(\"CLIENTIP\"));\r\n                    referrerprop.put(\"useragent\", header.get(\"User-Agent\"));\r\n                    referrerprop.put(\"date\", (new serverDate()).toShortString(false));\r\n                    if (sb.facilityDB != null) try { sb.facilityDB.update(\"backlinks\", referer, referrerprop); } catch (IOException e) {}\r\n                }\r\n            }\r\n        \t */\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = post.getInt(\"count\", 10);\r\n        int offset = post.getInt(\"offset\", 0);\r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 30)) itemsPerPage = 30;\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if (post.get(\"cat\", \"href\").equals(\"href\")) {\r\n\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            boolean near = (query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0);\r\n            if (near) {\r\n            \tquery[0].remove(\"near\");\r\n            }\r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            if (near) {\r\n            \tranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \t\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post.containsKey(\"deleteref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                sb.wordIndex.removeWordReferences(query[0], delHash);\r\n\r\n                // make new news message with negative voting\r\n                HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                indexURLEntry urlentry = sb.wordIndex.loadedURL.load(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    indexURLEntry.Components comp = urlentry.comp();\r\n                    plasmaParserDocument document;\r\n                    document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", comp.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", ((document == null) ? comp.dc_title() : document.dc_title()).replace(',', ' '));\r\n                        map.put(\"author\", ((document == null) ? \"\" : document.dc_creator()));\r\n                        map.put(\"tags\", ((document == null) ? \"\" : document.dc_subject(' ')));\r\n                        yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((yacyCore.seedDB != null) && (yacyCore.seedDB.mySeed() != null) && (yacyCore.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline);\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = plasmaCondenser.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tplasmaCondenser.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true);\r\n\r\n            String client = (String) header.get(\"CLIENTIP\"); // the search client who initiated the search\r\n        \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.wordIndex, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            Long trackerHandle = new Long(System.currentTimeMillis());\r\n            HashMap<String, Object> searchProfile = theQuery.resultProfile(theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize(), System.currentTimeMillis() - timestamp, theSearch.getURLRetrievalTime(), theSearch.getSnippetComputationTime());\r\n            searchProfile.put(\"querystring\", theQuery.queryString);\r\n            searchProfile.put(\"time\", trackerHandle);\r\n            searchProfile.put(\"host\", client);\r\n            searchProfile.put(\"offset\", new Integer(0));\r\n            sb.localSearches.add(searchProfile);\r\n            TreeSet<Long> handles = sb.localSearchTracker.get(client);\r\n            if (handles == null) handles = new TreeSet<Long>();\r\n            handles.add(trackerHandle);\r\n            sb.localSearchTracker.put(client, handles);\r\n        \r\n            prop = new serverObjects();\r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n            \r\n            // compose page navigation\r\n            StringBuffer resnav = new StringBuffer();\r\n            int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) resnav.append(\"&lt;&nbsp;\"); else {\r\n                resnav.append(navurla(thispage - 1, display, theQuery));\r\n                resnav.append(\"<strong>&lt;<\/strong><\/a>&nbsp;\");\r\n            }\r\n            int numberofpages = Math.min(10, Math.max(thispage + 2, totalcount / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<strong>\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/strong>&nbsp;\");\r\n                } else {\r\n                    resnav.append(navurla(i, display, theQuery));\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) resnav.append(\"&gt;\"); else {\r\n                resnav.append(navurla(thispage + 1, display, theQuery));\r\n                resnav.append(\"<strong>&gt;<\/strong><\/a>\");\r\n            }\r\n            prop.put(\"num-results_resnav\", resnav.toString());\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":71537,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n\r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"search\", \"\").trim();\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = post.getInt(\"count\", 10);\r\n        int offset = post.getInt(\"offset\", 0);\r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        //final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        //final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 30)) itemsPerPage = 30;\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if (post.get(\"cat\", \"href\").equals(\"href\")) {\r\n\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            boolean near = (query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0);\r\n            if (near) {\r\n            \tquery[0].remove(\"near\");\r\n            }\r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            if (near) {\r\n            \tranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \t\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post.containsKey(\"deleteref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                sb.wordIndex.removeWordReferences(query[0], delHash);\r\n\r\n                // make new news message with negative voting\r\n                HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                indexURLEntry urlentry = sb.wordIndex.loadedURL.load(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    indexURLEntry.Components comp = urlentry.comp();\r\n                    plasmaParserDocument document;\r\n                    document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", comp.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", ((document == null) ? comp.dc_title() : document.dc_title()).replace(',', ' '));\r\n                        map.put(\"author\", ((document == null) ? \"\" : document.dc_creator()));\r\n                        map.put(\"tags\", ((document == null) ? \"\" : document.dc_subject(' ')));\r\n                        yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((yacyCore.seedDB != null) && (yacyCore.seedDB.mySeed() != null) && (yacyCore.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline);\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = plasmaCondenser.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tplasmaCondenser.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true);\r\n\r\n            String client = (String) header.get(\"CLIENTIP\"); // the search client who initiated the search\r\n        \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.wordIndex, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            Long trackerHandle = new Long(System.currentTimeMillis());\r\n            HashMap<String, Object> searchProfile = theQuery.resultProfile(theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize(), System.currentTimeMillis() - timestamp, theSearch.getURLRetrievalTime(), theSearch.getSnippetComputationTime());\r\n            searchProfile.put(\"querystring\", theQuery.queryString);\r\n            searchProfile.put(\"time\", trackerHandle);\r\n            searchProfile.put(\"host\", client);\r\n            searchProfile.put(\"offset\", new Integer(0));\r\n            sb.localSearches.add(searchProfile);\r\n            TreeSet<Long> handles = sb.localSearchTracker.get(client);\r\n            if (handles == null) handles = new TreeSet<Long>();\r\n            handles.add(trackerHandle);\r\n            sb.localSearchTracker.put(client, handles);\r\n        \r\n            prop = new serverObjects();\r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n            \r\n            // compose page navigation\r\n            StringBuffer resnav = new StringBuffer();\r\n            int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) resnav.append(\"&lt;&nbsp;\"); else {\r\n                resnav.append(navurla(thispage - 1, display, theQuery));\r\n                resnav.append(\"<strong>&lt;<\/strong><\/a>&nbsp;\");\r\n            }\r\n            int numberofpages = Math.min(10, Math.max(thispage + 2, totalcount / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<strong>\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/strong>&nbsp;\");\r\n                } else {\r\n                    resnav.append(navurla(i, display, theQuery));\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) resnav.append(\"&gt;\"); else {\r\n                resnav.append(navurla(thispage + 1, display, theQuery));\r\n                resnav.append(\"<strong>&gt;<\/strong><\/a>\");\r\n            }\r\n            prop.put(\"num-results_resnav\", resnav.toString());\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"3c7b94c119085a02a5871d97faa954bda9aa35e0","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * \n     * @param portlet\n     * @param context\n     * @param rundata\n     * @param state\n     * @return\n     */\n    public String buildResultsPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n    {\n\t\t// always put appropriate bundle in velocity context\n\t\tcontext.put(\"tlang\", rb);\n\n\t\t// validators\n\t\tcontext.put(\"TextValidator\", new QuotedTextValidator());\n\t\tcontext.put(\"xilator\", new Validator());\n\t\t\n\t\t// javascript to run on page load\n\t\tcontext.put(\"sakai_onload\", \"setMainFrameHeight( window.name ); highlightButtonSelections( '\" + rb.getString(\"remove.results\") + \"' )\");\n\n\t\t// signal basic/advanced search\n\t\tObject basicSearch = state.getAttribute( STATE_BASIC_SEARCH );\n\t\tcontext.put( \"basicSearch\", basicSearch );\n\t\tif( basicSearch != null )\n\t\t{\n\t\t\tcontext.put( \"searchType\", ActiveSearch.BASIC_SEARCH_TYPE );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontext.put( \"searchType\", ActiveSearch.ADVANCED_SEARCH_TYPE );\n\t\t}\n\t\t\n\t\t/*\n\t\t * ERROR CHECKING\n\t\t */\n\t\tString alertMessages = (String) state.removeAttribute(STATE_MESSAGE);\n\t\tif(alertMessages != null)\n\t\t{\n\t\t\tcontext.put(\"alertMessages\", alertMessages);\n\t\t\treturn TEMPLATE_RESULTS;\n\t\t}\n\t\t\n\t\tObject noSearch = state.removeAttribute(STATE_NO_KEYWORDS);\n\t\tif(noSearch != null)\n\t\t{\n\t\t\tcontext.put(\"noSearch\", noSearch);\n\t\t\treturn TEMPLATE_RESULTS;\n\t\t}\n\t\t\n\t\tObject noDatabases = state.removeAttribute( STATE_NO_DATABASES );\n\t\tif( noDatabases != null )\n\t\t{\n\t\t\tcontext.put( \"noDatabases\", noDatabases );\n\t\t\treturn TEMPLATE_RESULTS;\n\t\t}\n\n\t\t/*\n\t\t * SEARCH RESULTS\n\t\t */\n\t\tActiveSearch searchResults = (ActiveSearch) state.getAttribute(STATE_SEARCH_RESULTS);\n\t\tif(searchResults != null)\n\t\t{\n\t\t\tcontext.put(\"searchResults\", searchResults);\n\t\t\tList currentResults = (List) state.getAttribute(STATE_CURRENT_RESULTS);\n\t\t\tcontext.put(\"currentResults\", currentResults);\n\t\t\t\n\t\t\tInteger[] position = { new Integer(searchResults.getFirstRecordIndex() + 1) , new Integer(searchResults.getLastRecordIndex()), searchResults.getNumRecordsFound()};\n\t\t\tString showing = (String) rb.getFormattedMessage(\"showing.results\", position);\n\t\t\tcontext.put(\"showing\", showing);\n\t\t}\n\t\t\n\t\t// selected databases\n\t\tString[] databaseIds = (String[])state.getAttribute( STATE_CURRENT_DATABASES );\n\t\tcontext.put( \"selectedDatabases\", databaseIds );\n\t\t\n\t\t// load basic/advanced search form state\n\t\tloadSearchFormState( context, state );\n\t\t\n\t\t/*\n\t\t * OTHER CONTEXT PARAMS\n\t\t */\n\t\t// collection id\n\t\tString collectionId = (String) state.getAttribute(STATE_COLLECTION_ID);\n\t\tcontext.put(\"collectionId\", collectionId);\n\n\t\t// searchInfo\n\t\tActiveSearch searchInfo = (ActiveSearch) state.getAttribute(STATE_SEARCH_INFO);\n\t\tcontext.put(\"searchInfo\", searchInfo);\n\t\t\n\t\t// form name\n\t\tcontext.put(PARAM_FORM_NAME, ELEMENT_ID_SEARCH_FORM);\n\t\t\n\t\t// OpenURL Label\n\t\tcontext.put( \"openUrlLabel\", ConfigurationService.getSiteConfigOpenUrlLabel() );\n\n\t\t// object arrays for formatted messages\n\t\tObject[] instrMainArgs = { rb.getString( \"add.results\" ) };\n\t\tcontext.put( \"instrMainArgs\", instrMainArgs );\n\t\t\n\t\tObject[] instrSubArgs = { rb.getString( \"label.new.search\" ) };\n\t\tcontext.put( \"instrSubArgs\", instrSubArgs );\n\n    \treturn TEMPLATE_RESULTS;\n    \t\n    }","id":71538,"modified_method":"/**\n     * \n     * @param portlet\n     * @param context\n     * @param rundata\n     * @param state\n     * @return\n     */\n    public String buildResultsPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n    {\n\t\t// always put appropriate bundle in velocity context\n\t\tcontext.put(\"tlang\", rb);\n\n\t\t// validators\n\t\tcontext.put(\"TextValidator\", new QuotedTextValidator());\n\t\tcontext.put(\"xilator\", new Validator());\n\t\t\n\t\t// javascript to run on page load\n\t\tcontext.put(\"sakai_onload\", \"setMainFrameHeight( window.name ); highlightButtonSelections( '\" + rb.getString(\"remove.results\") + \"' )\");\n\n\t\t// put the citation list title and size\n\t\tputCitationCollectionDetails(context, state);\n\t\t\n\t\t// signal basic/advanced search\n\t\tObject basicSearch = state.getAttribute( STATE_BASIC_SEARCH );\n\t\tcontext.put( \"basicSearch\", basicSearch );\n\t\tif( basicSearch != null )\n\t\t{\n\t\t\tcontext.put( \"searchType\", ActiveSearch.BASIC_SEARCH_TYPE );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontext.put( \"searchType\", ActiveSearch.ADVANCED_SEARCH_TYPE );\n\t\t}\n\t\t\n\t\t/*\n\t\t * ERROR CHECKING\n\t\t */\n\t\tString alertMessages = (String) state.removeAttribute(STATE_MESSAGE);\n\t\tif(alertMessages != null)\n\t\t{\n\t\t\tcontext.put(\"alertMessages\", alertMessages);\n\t\t\treturn TEMPLATE_RESULTS;\n\t\t}\n\t\t\n\t\tObject noSearch = state.removeAttribute(STATE_NO_KEYWORDS);\n\t\tif(noSearch != null)\n\t\t{\n\t\t\tcontext.put(\"noSearch\", noSearch);\n\t\t\treturn TEMPLATE_RESULTS;\n\t\t}\n\t\t\n\t\tObject noDatabases = state.removeAttribute( STATE_NO_DATABASES );\n\t\tif( noDatabases != null )\n\t\t{\n\t\t\tcontext.put( \"noDatabases\", noDatabases );\n\t\t\treturn TEMPLATE_RESULTS;\n\t\t}\n\n\t\t/*\n\t\t * SEARCH RESULTS\n\t\t */\n\t\tActiveSearch searchResults = (ActiveSearch) state.getAttribute(STATE_SEARCH_RESULTS);\n\t\tif(searchResults != null)\n\t\t{\n\t\t\tcontext.put(\"searchResults\", searchResults);\n\t\t\tList currentResults = (List) state.getAttribute(STATE_CURRENT_RESULTS);\n\t\t\tcontext.put(\"currentResults\", currentResults);\n\t\t\t\n\t\t\tInteger[] position = { new Integer(searchResults.getFirstRecordIndex() + 1) , new Integer(searchResults.getLastRecordIndex()), searchResults.getNumRecordsFound()};\n\t\t\tString showing = (String) rb.getFormattedMessage(\"showing.results\", position);\n\t\t\tcontext.put(\"showing\", showing);\n\t\t}\n\t\t\n\t\t// selected databases\n\t\tString[] databaseIds = (String[])state.getAttribute( STATE_CURRENT_DATABASES );\n\t\tcontext.put( \"selectedDatabases\", databaseIds );\n\t\t\n\t\t// load basic/advanced search form state\n\t\tloadSearchFormState( context, state );\n\t\t\n\t\t/*\n\t\t * OTHER CONTEXT PARAMS\n\t\t */\n\t\t// searchInfo\n\t\tActiveSearch searchInfo = (ActiveSearch) state.getAttribute(STATE_SEARCH_INFO);\n\t\tcontext.put(\"searchInfo\", searchInfo);\n\t\t\n\t\t// form name\n\t\tcontext.put(PARAM_FORM_NAME, ELEMENT_ID_RESULTS_FORM);\n\t\t\n\t\t// OpenURL Label\n\t\tcontext.put( \"openUrlLabel\", ConfigurationService.getSiteConfigOpenUrlLabel() );\n\n\t\t// object arrays for formatted messages\n\t\tObject[] instrMainArgs = { rb.getString( \"add.results\" ) };\n\t\tcontext.put( \"instrMainArgs\", instrMainArgs );\n\t\t\n\t\tObject[] instrSubArgs = { rb.getString( \"label.new.search\" ) };\n\t\tcontext.put( \"instrSubArgs\", instrSubArgs );\n\n    \treturn TEMPLATE_RESULTS;\n    \t\n    }","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * build the context.\n\t * \n\t * @return The name of the template to use.\n\t */\n\tpublic String buildListPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n\t{\n\t\t// always put appropriate bundle in velocity context\n\t\tcontext.put(\"tlang\", rb);\n\t\t\n\t\tif( state.removeAttribute( STATE_LIST_NO_SCROLL ) == null )\n\t\t{\n\t\t\tcontext.put(\"sakai_onload\", \"setMainFrameHeight( window.name )\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontext.put(\"sakai_onload\", \"resizeFrame()\");\n\t\t}\n\t\t\n\t\t//context.put(\"mainFrameId\", CitationHelper.CITATION_FRAME_ID);\n\t\t//context.put(\"citationToolId\", CitationHelper.CITATION_ID);\n\t\t//context.put(\"specialHelperFlag\", CitationHelper.SPECIAL_HELPER_ID);\n\t\t\n\t\tcontext.put(\"openUrlLabel\", ConfigurationService.getSiteConfigOpenUrlLabel());\n\t\t\n\t\tcontext.put(PARAM_FORM_NAME, ELEMENT_ID_LIST_FORM);\n\t\t\n\t\tCitationCollection collection = null;\n\t\tString collectionId = (String) state.getAttribute(STATE_COLLECTION_ID);\n\t\tif(collectionId == null)\n\t\t{\n\t\t\tcollection = CitationService.addCollection();\n\t\t\tstate.setAttribute(STATE_COLLECTION_ID, collection.getId());\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttry\n            {\n\t            collection = CitationService.getCollection(collectionId);\n            }\n            catch (IdUnusedException e)\n            {\n\t            logger.warn(\"CitationHelperAction.buildListPanelContext unable to access citationCollection \" + collectionId);\n            }\n\t\t\tif(collection == null)\n\t\t\t{\n\t\t\t\tcollection = CitationService.addCollection();\n\t\t\t\tstate.setAttribute(STATE_COLLECTION_ID, collection.getId());\n\t\t\t}\n\t\t}\n\t\t\n\t\tString exportUrlSel = collection.getUrl(CitationService.REF_TYPE_EXPORT_RIS_SEL);\n\t\tString exportUrlAll = collection.getUrl(CitationService.REF_TYPE_EXPORT_RIS_ALL);\n\t\tcontext.put(\"exportUrlSel\", exportUrlSel);\n\t\tcontext.put(\"exportUrlAll\", exportUrlAll);\n\t\t\n\t\tInteger listPageSize = (Integer) state.getAttribute(STATE_LIST_PAGE_SIZE);\n\t\tif(listPageSize == null)\n\t\t{\n\t\t\tlistPageSize = DEFAULT_LIST_PAGE_SIZE;\n\t\t\tstate.setAttribute(STATE_LIST_PAGE_SIZE, listPageSize);\n\t\t}\n\t\tcontext.put(\"listPageSize\", listPageSize);\n\t    \n\t\tCitationIterator newIterator = collection.iterator();\n\t\tCitationIterator oldIterator = (CitationIterator) state.getAttribute(STATE_LIST_ITERATOR);\n\t\tif(oldIterator != null)\n\t\t{\n\t\t\tnewIterator.setPageSize(listPageSize.intValue());\n\t\t\tnewIterator.setPage(oldIterator.getPage());\n\t\t}\n\t\tcontext.put(\"citations\", newIterator);\n\t\tcontext.put(\"collectionId\", collection.getId());\n\t\tif(! collection.isEmpty())\n\t\t{\n\t\t\tcontext.put(\"show_citations\", Boolean.TRUE);\n\t\t\t\n\t\t\tint page = newIterator.getPage();\n\t\t\tint pageSize = newIterator.getPageSize();\n\t\t\tint totalSize = collection.size();\n\t\t\t\n\t\t\tint start = page * pageSize + 1;\n\t\t\tint end = Math.min((page + 1) * pageSize, totalSize);\n\t\t\t\n\t\t\tInteger[] position = { new Integer(start) , new Integer(end), new Integer(totalSize)};\n\t\t\tString showing = (String) rb.getFormattedMessage(\"showing.results\", position);\n\t\t\tcontext.put(\"showing\", showing);\n\n\t\t}\n\t\tstate.setAttribute(STATE_LIST_ITERATOR, newIterator);\n\t\t\n\t\t// back to search results button control\n\t\tcontext.put(\"searchResults\", state.getAttribute(STATE_SEARCH_RESULTS) );\n\t\t\n\t\t/*\n\t\t * Object arrays for formatted messages\n\t\t */\n\t\tObject[] instrMainArgs = { ConfigurationService.getSiteConfigOpenUrlLabel() };\n\t\tcontext.put( \"instrMainArgs\", instrMainArgs );\n\t\t\n\t\tObject[] instrSubArgs = { rb.getString( \"label.finish\" ) };\n\t\tcontext.put( \"instrSubArgs\", instrSubArgs );\n\t\t\n\t\tObject[] emptyListArgs = { rb.getString( \"label.menu\" ) };\n\t\tcontext.put( \"emptyListArgs\", emptyListArgs );\n\t\t\n\t\treturn TEMPLATE_LIST;\n\t\t\n\t}","id":71539,"modified_method":"/**\n\t * build the context.\n\t * \n\t * @return The name of the template to use.\n\t */\n\tpublic String buildListPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n\t{\n\t\t// always put appropriate bundle in velocity context\n\t\tcontext.put(\"tlang\", rb);\n\t\t\n\t\tif( state.removeAttribute( STATE_LIST_NO_SCROLL ) == null )\n\t\t{\n\t\t\tcontext.put(\"sakai_onload\", \"setMainFrameHeight( window.name )\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontext.put(\"sakai_onload\", \"resizeFrame()\");\n\t\t}\n\t\t\n\t\t//context.put(\"mainFrameId\", CitationHelper.CITATION_FRAME_ID);\n\t\t//context.put(\"citationToolId\", CitationHelper.CITATION_ID);\n\t\t//context.put(\"specialHelperFlag\", CitationHelper.SPECIAL_HELPER_ID);\n\t\t\n\t\t// get the citation list title\n\t\tString resourceId = (String) state.getAttribute(CitationHelper.RESOURCE_ID);\n\t\tContentHostingService contentService = (ContentHostingService) ComponentManager.get(\"org.sakaiproject.content.api.ContentHostingService\");\n\t\tString refStr = contentService.getReference(resourceId);\n\t\tReference ref = EntityManager.newReference(refStr);\n\t\tString collectionTitle = ref.getProperties().getProperty(ResourceProperties.PROP_DISPLAY_NAME);\n\t\tif( collectionTitle != null && !collectionTitle.trim().equals(\"\") )\n\t\t{\n\t\t\tcontext.put( \"collectionTitle\", collectionTitle );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcontext.put( \"collectionTitle\", (String)state.getAttribute( STATE_COLLECTION_TITLE ) );\n\t\t}\n\t\t\n\t\tcontext.put(\"openUrlLabel\", ConfigurationService.getSiteConfigOpenUrlLabel());\n\t\t\n\t\tcontext.put(PARAM_FORM_NAME, ELEMENT_ID_LIST_FORM);\n\t\t\n\t\tCitationCollection collection = null;\n\t\tString collectionId = (String) state.getAttribute(STATE_COLLECTION_ID);\n\t\tif(collectionId == null)\n\t\t{\n\t\t\tcollection = CitationService.addCollection();\n\t\t\tstate.setAttribute(STATE_COLLECTION_ID, collection.getId());\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttry\n            {\n\t            collection = CitationService.getCollection(collectionId);\n            }\n            catch (IdUnusedException e)\n            {\n\t            logger.warn(\"CitationHelperAction.buildListPanelContext unable to access citationCollection \" + collectionId);\n            }\n\t\t\tif(collection == null)\n\t\t\t{\n\t\t\t\tcollection = CitationService.addCollection();\n\t\t\t\tstate.setAttribute(STATE_COLLECTION_ID, collection.getId());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// collection size\n\t\tcontext.put( \"collectionSize\", new Integer( collection.size() ) );\n\t\t\n\t\t// export URLs\n\t\tString exportUrlSel = collection.getUrl(CitationService.REF_TYPE_EXPORT_RIS_SEL);\n\t\tString exportUrlAll = collection.getUrl(CitationService.REF_TYPE_EXPORT_RIS_ALL);\n\t\tcontext.put(\"exportUrlSel\", exportUrlSel);\n\t\tcontext.put(\"exportUrlAll\", exportUrlAll);\n\t\t\n\t\tInteger listPageSize = (Integer) state.getAttribute(STATE_LIST_PAGE_SIZE);\n\t\tif(listPageSize == null)\n\t\t{\n\t\t\tlistPageSize = DEFAULT_LIST_PAGE_SIZE;\n\t\t\tstate.setAttribute(STATE_LIST_PAGE_SIZE, listPageSize);\n\t\t}\n\t\tcontext.put(\"listPageSize\", listPageSize);\n\t    \n\t\tCitationIterator newIterator = collection.iterator();\n\t\tCitationIterator oldIterator = (CitationIterator) state.getAttribute(STATE_LIST_ITERATOR);\n\t\tif(oldIterator != null)\n\t\t{\n\t\t\tnewIterator.setPageSize(listPageSize.intValue());\n\t\t\tnewIterator.setPage(oldIterator.getPage());\n\t\t}\n\t\tcontext.put(\"citations\", newIterator);\n\t\tcontext.put(\"collectionId\", collection.getId());\n\t\tif(! collection.isEmpty())\n\t\t{\n\t\t\tcontext.put(\"show_citations\", Boolean.TRUE);\n\t\t\t\n\t\t\tint page = newIterator.getPage();\n\t\t\tint pageSize = newIterator.getPageSize();\n\t\t\tint totalSize = collection.size();\n\n\t\t\tint start = page * pageSize + 1;\n\t\t\tint end = Math.min((page + 1) * pageSize, totalSize);\n\t\t\t\n\t\t\tInteger[] position = { new Integer(start) , new Integer(end), new Integer(totalSize)};\n\t\t\tString showing = (String) rb.getFormattedMessage(\"showing.results\", position);\n\t\t\tcontext.put(\"showing\", showing);\n\n\t\t}\n\t\tstate.setAttribute(STATE_LIST_ITERATOR, newIterator);\n\t\t\n\t\t// back to search results button control\n\t\tcontext.put(\"searchResults\", state.getAttribute(STATE_SEARCH_RESULTS) );\n\t\t\n\t\t/*\n\t\t * Object arrays for formatted messages\n\t\t */\n\t\tObject[] instrMainArgs = { ConfigurationService.getSiteConfigOpenUrlLabel() };\n\t\tcontext.put( \"instrMainArgs\", instrMainArgs );\n\t\t\n\t\tObject[] instrSubArgs = { rb.getString( \"label.finish\" ) };\n\t\tcontext.put( \"instrSubArgs\", instrSubArgs );\n\t\t\n\t\tObject[] emptyListArgs = { rb.getString( \"label.menu\" ) };\n\t\tcontext.put( \"emptyListArgs\", emptyListArgs );\n\t\t\n\t\treturn TEMPLATE_LIST;\n\t\t\n\t}","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * \n\t */\n\tpublic void doBeginSearch ( RunData data)\n\t{\n\t\t// get state and params\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\tParameterParser params = data.getParameters();\n\t\t\n\t\t// get search object from state\n\t\tActiveSearch search = (ActiveSearch) state.getAttribute(STATE_SEARCH_INFO);\n\t\tif(search == null)\n\t\t{\n\t\t\tlogger.debug( \"doBeginSearch() got null ActiveSearch from state.\" );\n\t\t\tsearch = SearchManager.newSearch();\n\t\t}\n\t\t\n\t\t// get databases selected\n\t\tString[] databaseIds = params.getStrings( \"databasesSelected\" );\n\t\tlogger.debug( \"Databases selected:\" );\n\t\tfor( String databaseId : databaseIds )\n\t\t{\n\t\t\tlogger.debug( \"  \" + databaseId );\n\t\t}\n\t\t\n\t\t// check the databases to make sure they are indeed searchable by this user\n\t\tif( databaseIds != null )\n\t\t{\n\t\t\tSearchDatabaseHierarchy hierarchy =\n\t\t\t\t(SearchDatabaseHierarchy)state.getAttribute(STATE_SEARCH_HIERARCHY);\n\t\t\tfor( int i = 0; i < databaseIds.length; i++ )\n\t\t\t{\n\t\t\t\tif( !hierarchy.isSearchableDatabase( databaseIds[ i ] ) )\n\t\t\t\t{\n\t\t\t\t\t// TODO collect a list of the databases which are\n\t\t\t\t\t// not searchable and pass them to the UI\n\t\n\t\t\t\t\t// do not search if databases selected\n\t\t\t\t\t// are not searchable by this user\n\t\t\t\t\tstate.setAttribute( STATE_UNAUTHORIZED_DB, Boolean.TRUE );\n\t\t\t\t\tlogger.warn( \"doBeginSearch() unauthorized database: \" + databaseIds[i] );\n\t\t\t\t\tsetMode(state, Mode.RESULTS);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// databases are searchable\n\t\t\tSearchManager.setDatabaseIds( databaseIds );\n\t\t\tstate.setAttribute( STATE_CURRENT_DATABASES, databaseIds );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no databases selected, cannot continue\n\t\t\tstate.setAttribute( STATE_NO_DATABASES, Boolean.TRUE );\n\t\t\tsetMode(state, Mode.RESULTS);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t *  do basic/advanced search-specific processing\n\t\t */\n\t\t// determine which type of search has been issued\n\t\tString searchType = params.getString( \"searchType\" );\n\t\tif( searchType != null && searchType.equalsIgnoreCase( ActiveSearch.ADVANCED_SEARCH_TYPE ) )\n\t\t{\n\t\t\tdoAdvancedSearch( params, state, search );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoBasicSearch( params, state, search );\n\t\t}\n\t\t\n\t\t/*\n\t\t * BEGIN SEARCH\n\t\t */\n\t\ttry\n\t    {\n\t        List latestResults = search.viewPage();\n\t        String msg = search.getStatusMessage();\n\t        if(msg != null)\n\t        {\n\t        \taddAlert(state, msg);\n\t        \tsearch.setStatusMessage();\n\t        }\n\t        state.setAttribute(STATE_SEARCH_RESULTS, search);\n\t        state.setAttribute(STATE_CURRENT_RESULTS, latestResults);\n\t        setMode(state, Mode.RESULTS);\n\t    }\n\t    catch(Exception e)\n\t    {\n\t    \tlogger.warn(\"doBeginSearch() caught Exception\", e);\n\t    }\n\t    \n\t    ActiveSearch newSearch = SearchManager.newSearch();\n\t\tstate.setAttribute( STATE_SEARCH_INFO, newSearch );\n\t\n\t}","id":71540,"modified_method":"/**\n\t * \n\t */\n\tpublic void doBeginSearch ( RunData data)\n\t{\n\t\t// get state and params\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\tParameterParser params = data.getParameters();\n\t\t\n\t\t// check for a cancel\n\t\tString cancel = params.getString( \"cancelOp\" );\n\t\tif( cancel != null && cancel.equals( \"cancel\" ) )\n\t\t{\n\t\t\tsetMode(state, Mode.RESULTS);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// get search object from state\n\t\tActiveSearch search = (ActiveSearch) state.getAttribute(STATE_SEARCH_INFO);\n\t\tif(search == null)\n\t\t{\n\t\t\tlogger.debug( \"doBeginSearch() got null ActiveSearch from state.\" );\n\t\t\tsearch = SearchManager.newSearch();\n\t\t}\n\t\t\n\t\t// get databases selected\n\t\tString[] databaseIds = params.getStrings( \"databasesSelected\" );\n\t\tlogger.debug( \"Databases selected:\" );\n\t\tfor( String databaseId : databaseIds )\n\t\t{\n\t\t\tlogger.debug( \"  \" + databaseId );\n\t\t}\n\t\t\n\t\t// check the databases to make sure they are indeed searchable by this user\n\t\tif( databaseIds != null )\n\t\t{\n\t\t\tSearchDatabaseHierarchy hierarchy =\n\t\t\t\t(SearchDatabaseHierarchy)state.getAttribute(STATE_SEARCH_HIERARCHY);\n\t\t\tfor( int i = 0; i < databaseIds.length; i++ )\n\t\t\t{\n\t\t\t\tif( !hierarchy.isSearchableDatabase( databaseIds[ i ] ) )\n\t\t\t\t{\n\t\t\t\t\t// TODO collect a list of the databases which are\n\t\t\t\t\t// not searchable and pass them to the UI\n\t\n\t\t\t\t\t// do not search if databases selected\n\t\t\t\t\t// are not searchable by this user\n\t\t\t\t\tstate.setAttribute( STATE_UNAUTHORIZED_DB, Boolean.TRUE );\n\t\t\t\t\tlogger.warn( \"doBeginSearch() unauthorized database: \" + databaseIds[i] );\n\t\t\t\t\tsetMode(state, Mode.RESULTS);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// databases are searchable\n\t\t\tSearchManager.setDatabaseIds( databaseIds );\n\t\t\tstate.setAttribute( STATE_CURRENT_DATABASES, databaseIds );\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// no databases selected, cannot continue\n\t\t\tstate.setAttribute( STATE_NO_DATABASES, Boolean.TRUE );\n\t\t\tsetMode(state, Mode.RESULTS);\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t *  do basic/advanced search-specific processing\n\t\t */\n\t\t// determine which type of search has been issued\n\t\tString searchType = params.getString( \"searchType\" );\n\t\tif( searchType != null && searchType.equalsIgnoreCase( ActiveSearch.ADVANCED_SEARCH_TYPE ) )\n\t\t{\n\t\t\tdoAdvancedSearch( params, state, search );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoBasicSearch( params, state, search );\n\t\t}\n\t\t\n\t\t/*\n\t\t * BEGIN SEARCH\n\t\t */\n\t\ttry\n\t    {\n\t        List latestResults = search.viewPage();\n\t        String msg = search.getStatusMessage();\n\t        if(msg != null)\n\t        {\n\t        \taddAlert(state, msg);\n\t        \tsearch.setStatusMessage();\n\t        }\n\t        state.setAttribute(STATE_SEARCH_RESULTS, search);\n\t        state.setAttribute(STATE_CURRENT_RESULTS, latestResults);\n\t        setMode(state, Mode.RESULTS);\n\t    }\n\t    catch(Exception e)\n\t    {\n\t    \tlogger.warn(\"doBeginSearch() caught Exception\", e);\n\t    }\n\t    \n\t    ActiveSearch newSearch = SearchManager.newSearch();\n\t\tstate.setAttribute( STATE_SEARCH_INFO, newSearch );\n\t\n\t}","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t* \n\t*/\n\tpublic void doChangeListPageSize ( RunData data)\n\t{\n\t\t// get the state object\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\tParameterParser params = data.getParameters();\n\t\t\n\t\tint pageSize = params.getInt(\"pageSize\", DEFAULT_LIST_PAGE_SIZE.intValue());\n\t\t\n\t\tif(pageSize > 0)\n\t\t{\n\t\t\tstate.setAttribute(STATE_LIST_PAGE_SIZE, new Integer(pageSize));\n\t\t}\n\t\t\n \t}","id":71541,"modified_method":"/**\n\t* \n\t*/\n\tpublic void doChangeListPageSize ( RunData data)\n\t{\n\t\t// get the state object\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\tParameterParser params = data.getParameters();\n\t\n\t\t// check for top or bottom page selector\n\t\tString pageSelector = params.get( \"pageSelector\" );\n\t\tint pageSize;\n\t\tif( pageSelector.equals( \"top\" ) )\n\t\t{\n\t\t\tpageSize = params.getInt( \"pageSizeTop\" );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpageSize = params.getInt(\"pageSizeBottom\");\n\t\t}\n\t\t\n\t\tif(pageSize > 0)\n\t\t{\n\t\t\tstate.setAttribute(STATE_LIST_PAGE_SIZE, new Integer(pageSize));\n\t\t}\n\t\t\n \t}","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t* \n\t*/\n\tpublic void doChangeSearchPageSize ( RunData data)\n\t{\n\t\t// get the state object\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\tParameterParser params = data.getParameters();\n\t\t\n\t\tActiveSearch search = (ActiveSearch) state.getAttribute(STATE_SEARCH_RESULTS);\n\t\tif(search == null)\n\t\t{\n\t\t\tsearch = SearchManager.newSearch();\n\t\t\tstate.setAttribute(STATE_SEARCH_RESULTS, search);\n\t\t}\n\t\t// search.prepareForNextPage();\n\t\t\n\t\tint pageSize = params.getInt(\"pageSize\");\n\t\t\n\t\tif(pageSize > 0)\n\t\t{\n\t\t\t// use the new value\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// use the old value\n\t\t\tpageSize = search.getViewPageSize();\n\t\t}\n\t\t\n\t\tstate.setAttribute(STATE_RESULTS_PAGE_SIZE, new Integer(pageSize));\n\t\t\n\t\ttry\n        {\n\t\t\tint last = search.getLastRecordIndex();\n\t\t\tint page = (last - 1)/pageSize;\n\t\t\t\n\t\t\tsearch.setViewPageSize(pageSize);\n\t        List latestResults = search.viewPage(page);\n\t        String msg = search.getStatusMessage();\n\t        if(msg != null)\n\t        {\n\t        \taddAlert(state, msg);\n\t        \tsearch.setStatusMessage();\n\t        }\n\t        state.setAttribute(STATE_CURRENT_RESULTS, latestResults);\n\t\t\tsetMode(state, Mode.RESULTS);\n        }\n        catch (SearchException e)\n        {\n        \tlogger.warn(\"doNextPage\", e);\n        \taddAlert(state, e.getMessage());\n    \t\t//state.setAttribute (CitationHelper.STATE_HELPER_MODE, Mode.ERROR);\n        }\n        catch(Exception e)\n        {\n        \tlogger.warn(\"doNextPage\", e);\n        }\n                \n \t}","id":71542,"modified_method":"/**\n\t* \n\t*/\n\tpublic void doChangeSearchPageSize ( RunData data)\n\t{\n\t\t// get the state object\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\tParameterParser params = data.getParameters();\n\t\t\n\t\tActiveSearch search = (ActiveSearch) state.getAttribute(STATE_SEARCH_RESULTS);\n\t\tif(search == null)\n\t\t{\n\t\t\tsearch = SearchManager.newSearch();\n\t\t\tstate.setAttribute(STATE_SEARCH_RESULTS, search);\n\t\t}\n\t\t// search.prepareForNextPage();\n\t\t\n\t\t// check for top or bottom page selector\n\t\tString pageSelector = params.get( \"pageSelector\" );\n\t\tint pageSize;\n\t\tif( pageSelector.equals( \"top\" ) )\n\t\t{\n\t\t\tpageSize = params.getInt( \"pageSizeTop\" );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpageSize = params.getInt(\"pageSizeBottom\");\n\t\t}\n\t\t\n\t\tif(pageSize > 0)\n\t\t{\n\t\t\t// use the new value\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// use the old value\n\t\t\tpageSize = search.getViewPageSize();\n\t\t}\n\t\t\n\t\tstate.setAttribute(STATE_RESULTS_PAGE_SIZE, new Integer(pageSize));\n\t\t\n\t\ttry\n        {\n\t\t\tint last = search.getLastRecordIndex();\n\t\t\tint page = (last - 1)/pageSize;\n\t\t\t\n\t\t\tsearch.setViewPageSize(pageSize);\n\t        List latestResults = search.viewPage(page);\n\t        String msg = search.getStatusMessage();\n\t        if(msg != null)\n\t        {\n\t        \taddAlert(state, msg);\n\t        \tsearch.setStatusMessage();\n\t        }\n\t        state.setAttribute(STATE_CURRENT_RESULTS, latestResults);\n\t\t\tsetMode(state, Mode.RESULTS);\n        }\n        catch (SearchException e)\n        {\n        \tlogger.warn(\"doNextPage\", e);\n        \taddAlert(state, e.getMessage());\n    \t\t//state.setAttribute (CitationHelper.STATE_HELPER_MODE, Mode.ERROR);\n        }\n        catch(Exception e)\n        {\n        \tlogger.warn(\"doNextPage\", e);\n        }\n                \n \t}","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t* \n\t*/\n\tpublic void doSearch ( RunData data)\n\t{\n\t\t// get the state object\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\t\n\t\t// remove attributes from an old search session, if any\n\t\tstate.removeAttribute( STATE_SEARCH_RESULTS );\n\t\tstate.removeAttribute( STATE_CURRENT_RESULTS );\n\t\tstate.removeAttribute( STATE_KEYWORDS );\n\n\t\t// indicate a basic search\n\t\tstate.setAttribute( STATE_BASIC_SEARCH, new Object() );\n\t\t\n\t\ttry\n\t    {\n\t        SearchDatabaseHierarchy hierarchy = SearchManager.getSearchHierarchy();\n\t        if(hierarchy == null)\n\t        {\n\t\t        addAlert(state, rb.getString(\"search.problem\"));\n\t\t\t\tsetMode(state, Mode.ERROR);\n\t\t\t\treturn;\n\t        }\n\t        \n\t        state.setAttribute(STATE_SEARCH_HIERARCHY, hierarchy);\n\t        \n\t\t\tsetMode(state, Mode.SEARCH);\n\t    }\n\t    catch (SearchException e)\n\t    {\n\t        // addAlert(state, rb.getString(\"search.problem\"));\n\t        addAlert(state, e.getMessage());\n\t\t\tsetMode(state, Mode.ERROR);\n\t    }\n\t\n\t}","id":71543,"modified_method":"/**\n\t* \n\t*/\n\tpublic void doSearch ( RunData data)\n\t{\n\t\t// get the state object\n\t\tSessionState state = ((JetspeedRunData)data).getPortletSessionState (((JetspeedRunData)data).getJs_peid ());\n\t\tParameterParser params = data.getParameters();\n\t\t\n\t\t// check for a cancel\n\t\tString cancel = params.getString( \"cancelOp\" );\n\t\tif( cancel != null && cancel.equals( \"cancel\" ) )\n\t\t{\n\t\t\tsetMode(state, Mode.SEARCH);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// remove attributes from an old search session, if any\n\t\tstate.removeAttribute( STATE_SEARCH_RESULTS );\n\t\tstate.removeAttribute( STATE_CURRENT_RESULTS );\n\t\tstate.removeAttribute( STATE_KEYWORDS );\n\n\t\t// indicate a basic search\n\t\tstate.setAttribute( STATE_BASIC_SEARCH, new Object() );\n\t\t\n\t\ttry\n\t    {\n\t        SearchDatabaseHierarchy hierarchy = SearchManager.getSearchHierarchy();\n\t        if(hierarchy == null)\n\t        {\n\t\t        addAlert(state, rb.getString(\"search.problem\"));\n\t\t\t\tsetMode(state, Mode.ERROR);\n\t\t\t\treturn;\n\t        }\n\t        \n\t        state.setAttribute(STATE_SEARCH_HIERARCHY, hierarchy);\n\t        \n\t\t\tsetMode(state, Mode.SEARCH);\n\t    }\n\t    catch (SearchException e)\n\t    {\n\t        // addAlert(state, rb.getString(\"search.problem\"));\n\t        addAlert(state, e.getMessage());\n\t\t\tsetMode(state, Mode.ERROR);\n\t    }\n\t\n\t}","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * @param portlet\n     * @param context\n     * @param rundata\n     * @param state\n     * @return\n     */\n    public String buildMessagePanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n    {\n\t    context.put(\"sakai_onload\", \"\");\n\t    //context.put(\"FORM_NAME\", \"messageForm\");\n\t    \n\t    context.put( \"citationId\", state.getAttribute( STATE_CITATION_ID ) );\n\t    \n\t    return TEMPLATE_MESSAGE;\n    }","id":71544,"modified_method":"/**\n     * @param portlet\n     * @param context\n     * @param rundata\n     * @param state\n     * @return\n     */\n    public String buildMessagePanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n    {\n\t    context.put(\"sakai_onload\", \"\");\n\t    //context.put(\"FORM_NAME\", \"messageForm\");\n\t    \n\t    context.put( \"citationId\", state.getAttribute( STATE_CITATION_ID ) );\n\t    \n\t\t// get the collection we're now working on\n\t\tString collectionId = (String)state.getAttribute(STATE_COLLECTION_ID);\n\t\tcontext.put( \"collectionId\", collectionId );\n\t\t\n\t\tCitationCollection collection = null;\n\t\ttry\n        {\n            collection = CitationService.getCollection(collectionId);\n        }\n        catch (IdUnusedException e)\n        {\n            logger.warn(\"buildAddCitationsPanelContext unable to access citationCollection \" + collectionId);\n        }\n\t\tif(collection == null)\n\t\t{\n\t\t\tlogger.warn( \"buildAddCitationsPanelContext unable to access citationCollection \" + collectionId );\n\t\t}\n\t\t\n\t\t// get the size of the list\n\t\tcontext.put( \"citationCount\", new Integer( collection.size() ) );\n\t    \n\t    return TEMPLATE_MESSAGE;\n    }","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * @param portlet\n\t * @param context\n\t * @param rundata\n\t * @param state\n\t * @return\n\t */\n\tpublic String buildSearchPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n\t{\n\t\t// always put appropriate bundle in velocity context\n\t\tcontext.put(\"tlang\", rb);\n\t\t\n\t\t// validators\n\t\tcontext.put(\"TextValidator\", new QuotedTextValidator());\n\t\tcontext.put(\"xilator\", new Validator());\n\t\t\n\t\t// javascript to run on page load\n\t\tcontext.put(\"sakai_onload\", \"setMainFrameHeight( window.name ); showTopCategory()\");\n\t\n\t\t// resource-related\n\t\tString resourceId = (String) state.getAttribute(CitationHelper.RESOURCE_ID);\n\t\tContentHostingService contentService = (ContentHostingService) ComponentManager.get(\"org.sakaiproject.content.api.ContentHostingService\");\n\t\tString guid = contentService.getUuid(resourceId);\n\t\tcontext.put(\"RESOURCE_ID\", guid);\n\t\n\t\t// category information from hierarchy\n\t\tSearchDatabaseHierarchy hierarchy = (SearchDatabaseHierarchy) state.getAttribute(STATE_SEARCH_HIERARCHY);\n\t\tcontext.put( \"defaultCategory\", hierarchy.getDefaultCategory() );\n\t\tcontext.put( \"categoryListing\", hierarchy.getCategoryListing() );\n\t\t\n\t\t// load basic/advanced search form state\n\t\tloadSearchFormState( context, state );\n\t\t\n\t\t/*\n\t\t * MISCELLANEOUS CONTEXT PARAMS\n\t\t */\n\t\t// default to basicSearch\n\t\tcontext.put( \"basicSearch\", state.getAttribute( STATE_BASIC_SEARCH ) );\n\t\t\n\t\t// collection id\n\t\tString collectionId = (String) state.getAttribute(STATE_COLLECTION_ID);\n\t\tcontext.put(\"collectionId\", collectionId);\n\t\n\t\t// searchInfo\n\t\tActiveSearch searchInfo = (ActiveSearch) state.getAttribute(STATE_SEARCH_INFO);\n\t\tcontext.put(\"searchInfo\", searchInfo);\n\t\n\t\t// max number of searchable databases\n\t\tInteger maxDbNum = new Integer(hierarchy.getNumMaxSearchableDb());\n\t\tcontext.put( \"maxDbNum\", maxDbNum );\n\t\n\t\t// form name\n\t\tcontext.put(PARAM_FORM_NAME, ELEMENT_ID_SEARCH_FORM);\n\t\t\n\t\t// OpenURL Label\n\t\tcontext.put( \"openUrlLabel\", ConfigurationService.getSiteConfigOpenUrlLabel() );\n\t\t\n\t\t// object arrays for formatted messages\n\t\tObject[] instrArgs = { rb.getString( \"submit.search\" ) };\n\t\tcontext.put( \"instrArgs\", instrArgs );\n\t    \n\t    return TEMPLATE_SEARCH;\n\t    \n\t}","id":71545,"modified_method":"/**\n\t * @param portlet\n\t * @param context\n\t * @param rundata\n\t * @param state\n\t * @return\n\t */\n\tpublic String buildSearchPanelContext(VelocityPortlet portlet, Context context, RunData rundata, SessionState state)\n\t{\n\t\t// always put appropriate bundle in velocity context\n\t\tcontext.put(\"tlang\", rb);\n\t\t\n\t\t// validators\n\t\tcontext.put(\"TextValidator\", new QuotedTextValidator());\n\t\tcontext.put(\"xilator\", new Validator());\n\t\t\n\t\t// javascript to run on page load\n\t\tcontext.put(\"sakai_onload\", \"setMainFrameHeight( window.name ); showTopCategory()\");\n\n\t\t// put citation list title/size\n\t\tputCitationCollectionDetails(context, state);\n\t\t\n\t\t// resource-related\n\t\tString resourceId = (String) state.getAttribute(CitationHelper.RESOURCE_ID);\n\t\tContentHostingService contentService = (ContentHostingService) ComponentManager.get(\"org.sakaiproject.content.api.ContentHostingService\");\n\t\tString guid = contentService.getUuid(resourceId);\n\t\tcontext.put(\"RESOURCE_ID\", guid);\n\t\n\t\t// category information from hierarchy\n\t\tSearchDatabaseHierarchy hierarchy = (SearchDatabaseHierarchy) state.getAttribute(STATE_SEARCH_HIERARCHY);\n\t\tcontext.put( \"defaultCategory\", hierarchy.getDefaultCategory() );\n\t\tcontext.put( \"categoryListing\", hierarchy.getCategoryListing() );\n\t\t\n\t\t// load basic/advanced search form state\n\t\tloadSearchFormState( context, state );\n\t\t\n\t\t/*\n\t\t * MISCELLANEOUS CONTEXT PARAMS\n\t\t */\n\t\t// default to basicSearch\n\t\tcontext.put( \"basicSearch\", state.getAttribute( STATE_BASIC_SEARCH ) );\n\t\t\n\t\t// searchInfo\n\t\tActiveSearch searchInfo = (ActiveSearch) state.getAttribute(STATE_SEARCH_INFO);\n\t\tcontext.put(\"searchInfo\", searchInfo);\n\t\n\t\t// max number of searchable databases\n\t\tInteger maxDbNum = new Integer(hierarchy.getNumMaxSearchableDb());\n\t\tcontext.put( \"maxDbNum\", maxDbNum );\n\t\n\t\t// form name\n\t\tcontext.put(PARAM_FORM_NAME, ELEMENT_ID_SEARCH_FORM);\n\t\t\n\t\t// OpenURL Label\n\t\tcontext.put( \"openUrlLabel\", ConfigurationService.getSiteConfigOpenUrlLabel() );\n\t\t\n\t\t// object arrays for formatted messages\n\t\tObject[] instrArgs = { rb.getString( \"submit.search\" ) };\n\t\tcontext.put( \"instrArgs\", instrArgs );\n\t    \n\t    return TEMPLATE_SEARCH;\n\t    \n\t}","commit_id":"0ef0f8978a281da1d4e84893526d3b7fa2197bb2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"search\", \"\").trim();\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = post.getInt(\"count\", 10);\r\n        int offset = post.getInt(\"offset\", 0);\r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        //final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        //final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 32)) itemsPerPage = 32;\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if (post.get(\"cat\", \"href\").equals(\"href\")) {\r\n\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            boolean near = (query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0);\r\n            if (near) {\r\n            \tquery[0].remove(\"near\");\r\n            }\r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            if (near) {\r\n            \tranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \t\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post.containsKey(\"deleteref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                sb.wordIndex.removeWordReferences(query[0], delHash);\r\n\r\n                // make new news message with negative voting\r\n                HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                indexURLReference urlentry = sb.wordIndex.getURL(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    indexURLReference.Components comp = urlentry.comp();\r\n                    plasmaParserDocument document;\r\n                    document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", comp.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", ((document == null) ? comp.dc_title() : document.dc_title()).replace(',', ' '));\r\n                        map.put(\"author\", ((document == null) ? \"\" : document.dc_creator()));\r\n                        map.put(\"tags\", ((document == null) ? \"\" : document.dc_subject(' ')));\r\n                        yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((yacyCore.seedDB != null) && (yacyCore.seedDB.mySeed() != null) && (yacyCore.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline) && (sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false));\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = indexWord.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tindexWord.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    yacyURL.TLD_any_zone_filter,\r\n                    client);\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.INITIALIZATION, 0, 0));\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.wordIndex, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n            TreeSet<Long> handles = sb.localSearchTracker.get(client);\r\n            if (handles == null) handles = new TreeSet<Long>();\r\n            handles.add(theQuery.handle);\r\n            sb.localSearchTracker.put(client, handles);\r\n            \r\n            prop = new serverObjects();\r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n            \r\n            // compose page navigation\r\n            StringBuffer resnav = new StringBuffer();\r\n            int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) resnav.append(\"&lt;&nbsp;\"); else {\r\n                resnav.append(navurla(thispage - 1, display, theQuery));\r\n                resnav.append(\"<strong>&lt;<\/strong><\/a>&nbsp;\");\r\n            }\r\n            int numberofpages = Math.min(10, Math.max(thispage + 2, totalcount / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<strong>\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/strong>&nbsp;\");\r\n                } else {\r\n                    resnav.append(navurla(i, display, theQuery));\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) resnav.append(\"&gt;\"); else {\r\n                resnav.append(navurla(thispage + 1, display, theQuery));\r\n                resnav.append(\"<strong>&gt;<\/strong><\/a>\");\r\n            }\r\n            prop.put(\"num-results_resnav\", resnav.toString());\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":71546,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim(); // SRU compliance\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n            // we create empty entries for template strings\r\n            final serverObjects prop = new serverObjects();\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = post.getInt(\"maximumRecords\", post.getInt(\"count\", 10)); // SRU syntax with old property as alternative\r\n        int offset = post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n        \r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        //final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        //final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 32)) itemsPerPage = 32;\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if (post.get(\"cat\", \"href\").equals(\"href\")) {\r\n\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            boolean near = (query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0);\r\n            if (near) {\r\n            \tquery[0].remove(\"near\");\r\n            }\r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            if (near) {\r\n            \tranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \t\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post.containsKey(\"deleteref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                sb.wordIndex.removeWordReferences(query[0], delHash);\r\n\r\n                // make new news message with negative voting\r\n                HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                indexURLReference urlentry = sb.wordIndex.getURL(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    indexURLReference.Components comp = urlentry.comp();\r\n                    plasmaParserDocument document;\r\n                    document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", comp.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", ((document == null) ? comp.dc_title() : document.dc_title()).replace(',', ' '));\r\n                        map.put(\"author\", ((document == null) ? \"\" : document.dc_creator()));\r\n                        map.put(\"tags\", ((document == null) ? \"\" : document.dc_subject(' ')));\r\n                        yacyCore.newsPool.publishMyNews(yacyNewsRecord.newRecord(yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((yacyCore.seedDB != null) && (yacyCore.seedDB.mySeed() != null) && (yacyCore.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline) && (sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false));\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = indexWord.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tindexWord.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    yacyURL.TLD_any_zone_filter,\r\n                    client);\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.INITIALIZATION, 0, 0));\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.wordIndex, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n            TreeSet<Long> handles = sb.localSearchTracker.get(client);\r\n            if (handles == null) handles = new TreeSet<Long>();\r\n            handles.add(theQuery.handle);\r\n            sb.localSearchTracker.put(client, handles);\r\n            \r\n            prop = new serverObjects();\r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n            \r\n            // compose page navigation\r\n            StringBuffer resnav = new StringBuffer();\r\n            int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) resnav.append(\"&lt;&nbsp;\"); else {\r\n                resnav.append(navurla(thispage - 1, display, theQuery));\r\n                resnav.append(\"<strong>&lt;<\/strong><\/a>&nbsp;\");\r\n            }\r\n            int numberofpages = Math.min(10, Math.max(thispage + 2, totalcount / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<strong>\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/strong>&nbsp;\");\r\n                } else {\r\n                    resnav.append(navurla(i, display, theQuery));\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) resnav.append(\"&gt;\"); else {\r\n                resnav.append(navurla(thispage + 1, display, theQuery));\r\n                resnav.append(\"<strong>&gt;<\/strong><\/a>\");\r\n            }\r\n            prop.put(\"num-results_resnav\", resnav.toString());\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"2c0c8f0f0c06fb931c7590bcd139ed1f340b01b6","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaSearchQuery(String queryString,\r\n    \t\t\t\t\t\t int lines,\r\n    \t\t                 plasmaSearchRankingProfile ranking,\r\n    \t\t                 kelondroBitfield constraint) {\r\n    \tif ((queryString.length() == 12) && (kelondroBase64Order.enhancedCoder.wellformed(queryString.getBytes()))) {\r\n    \t\tthis.queryString = null;\r\n            this.queryHashes = new TreeSet<String>();\r\n            this.excludeHashes = new TreeSet<String>();\r\n            this.queryHashes.add(queryString);\r\n    \t} else {\r\n    \t\tthis.queryString = queryString;\r\n    \t\tTreeSet<String>[] cq = cleanQuery(queryString);\r\n    \t\tthis.queryHashes = indexWord.words2hashes(cq[0]);\r\n    \t\tthis.excludeHashes = indexWord.words2hashes(cq[1]);\r\n    \t}\r\n    \tthis.ranking = ranking;\r\n        this.maxDistance = Integer.MAX_VALUE;\r\n        this.prefer = \"\";\r\n        this.contentdom = CONTENTDOM_ALL;\r\n        this.linesPerPage = lines;\r\n        this.offset = 0;\r\n        this.urlMask = \".*\";\r\n        this.domType = SEARCHDOM_LOCAL;\r\n        this.zonecode = yacyURL.TLD_any_zone_filter;\r\n        this.domMaxTargets = 0;\r\n        this.constraint = constraint;\r\n        this.allofconstraint = false;\r\n        this.onlineSnippetFetch = false;\r\n        this.host = null;\r\n        this.remotepeer = null;\r\n        this.handle = new Long(System.currentTimeMillis());\r\n    }","id":71547,"modified_method":"public plasmaSearchQuery(String queryString,\r\n    \t\t\t\t\t\t int lines,\r\n    \t\t                 plasmaSearchRankingProfile ranking,\r\n    \t\t                 kelondroBitfield constraint) {\r\n    \tif ((queryString.length() == 12) && (kelondroBase64Order.enhancedCoder.wellformed(queryString.getBytes()))) {\r\n    \t\tthis.queryString = null;\r\n            this.queryHashes = new TreeSet<String>();\r\n            this.excludeHashes = new TreeSet<String>();\r\n            this.queryHashes.add(queryString);\r\n    \t} else {\r\n    \t\tthis.queryString = queryString;\r\n    \t\tTreeSet<String>[] cq = cleanQuery(queryString);\r\n    \t\tthis.queryHashes = indexWord.words2hashes(cq[0]);\r\n    \t\tthis.excludeHashes = indexWord.words2hashes(cq[1]);\r\n    \t}\r\n    \tthis.ranking = ranking;\r\n        this.maxDistance = Integer.MAX_VALUE;\r\n        this.prefer = \"\";\r\n        this.contentdom = CONTENTDOM_ALL;\r\n        this.linesPerPage = lines;\r\n        this.offset = 0;\r\n        this.urlMask = \".*\";\r\n        this.domType = SEARCHDOM_LOCAL;\r\n        this.zonecode = yacyURL.TLD_any_zone_filter;\r\n        this.domMaxTargets = 0;\r\n        this.constraint = constraint;\r\n        this.allofconstraint = false;\r\n        this.onlineSnippetFetch = false;\r\n        this.host = null;\r\n        this.remotepeer = null;\r\n        this.handle = new Long(System.currentTimeMillis());\r\n        this.specialRights = false;\r\n    }","commit_id":"0c173821fd5ce17d201435530af0a82c60743962","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public plasmaSearchQuery(\r\n\t\tString queryString, TreeSet<String> queryHashes, TreeSet<String> excludeHashes, \r\n        plasmaSearchRankingProfile ranking,\r\n        int maxDistance, String prefer, int contentdom,\r\n        boolean onlineSnippetFetch,\r\n        int lines, int offset, String urlMask,\r\n        int domType, String domGroupName, int domMaxTargets,\r\n        kelondroBitfield constraint, boolean allofconstraint,\r\n        int domainzone,\r\n        String host) {\r\n\t\tthis.queryString = queryString;\r\n\t\tthis.queryHashes = queryHashes;\r\n\t\tthis.excludeHashes = excludeHashes;\r\n\t\tthis.ranking = ranking;\r\n\t\tthis.maxDistance = maxDistance;\r\n\t\tthis.prefer = prefer;\r\n\t\tthis.contentdom = contentdom;\r\n\t\tthis.linesPerPage = Math.min(100, lines);\r\n\t\tthis.offset = Math.min(100, offset);\r\n\t\tthis.urlMask = urlMask;\r\n\t\tthis.domType = domType;\r\n        this.zonecode = domainzone;\r\n\t\tthis.domMaxTargets = domMaxTargets;\r\n\t\tthis.constraint = constraint;\r\n\t\tthis.allofconstraint = allofconstraint;\r\n\t\tthis.onlineSnippetFetch = onlineSnippetFetch;\r\n\t\tthis.host = host;\r\n        this.remotepeer = null;\r\n\t\tthis.handle = new Long(System.currentTimeMillis());\r\n    }","id":71548,"modified_method":"public plasmaSearchQuery(\r\n\t\tString queryString, TreeSet<String> queryHashes,\r\n\t\tTreeSet<String> excludeHashes, \r\n        plasmaSearchRankingProfile ranking,\r\n        int maxDistance, String prefer, int contentdom,\r\n        boolean onlineSnippetFetch,\r\n        int lines, int offset, String urlMask,\r\n        int domType, String domGroupName, int domMaxTargets,\r\n        kelondroBitfield constraint, boolean allofconstraint,\r\n        int domainzone,\r\n        String host,\r\n        boolean specialRights) {\r\n\t\tthis.queryString = queryString;\r\n\t\tthis.queryHashes = queryHashes;\r\n\t\tthis.excludeHashes = excludeHashes;\r\n\t\tthis.ranking = ranking;\r\n\t\tthis.maxDistance = maxDistance;\r\n\t\tthis.prefer = prefer;\r\n\t\tthis.contentdom = contentdom;\r\n\t\tthis.linesPerPage = Math.min((specialRights) ? 1000 : 10, lines);\r\n\t\tthis.offset = Math.min((specialRights) ? 10000 : 100, offset);\r\n\t\tthis.urlMask = urlMask;\r\n\t\tthis.domType = domType;\r\n        this.zonecode = domainzone;\r\n\t\tthis.domMaxTargets = domMaxTargets;\r\n\t\tthis.constraint = constraint;\r\n\t\tthis.allofconstraint = allofconstraint;\r\n\t\tthis.onlineSnippetFetch = onlineSnippetFetch;\r\n\t\tthis.host = host;\r\n        this.remotepeer = null;\r\n\t\tthis.handle = new Long(System.currentTimeMillis());\r\n\t\tthis.specialRights = specialRights;\r\n    }","commit_id":"0c173821fd5ce17d201435530af0a82c60743962","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private kelondroSortStack<indexRWIVarEntry>.stackElement bestRWI(boolean skipDoubleDom) {\r\n        // returns from the current RWI list the best entry and removes this entry from the list\r\n        kelondroSortStack<indexRWIVarEntry> m;\r\n        kelondroSortStack<indexRWIVarEntry>.stackElement rwi;\r\n        while (stack.size() > 0) {\r\n            rwi = stack.pop();\r\n            if (rwi == null) continue; // in case that a synchronization problem occurred just go lazy over it\r\n            if (!skipDoubleDom) return rwi;\r\n            // check doubledom\r\n            String domhash = rwi.element.urlHash().substring(6);\r\n            m = this.doubleDomCache.get(domhash);\r\n            if (m == null) {\r\n                // first appearance of dom\r\n                m = new kelondroSortStack<indexRWIVarEntry>(maxDoubleDom);\r\n                this.doubleDomCache.put(domhash, m);\r\n                return rwi;\r\n            }\r\n            // second appearances of dom\r\n            m.push(rwi);\r\n        }\r\n        // no more entries in sorted RWI entries. Now take Elements from the doubleDomCache\r\n        // find best entry from all caches\r\n        Iterator<kelondroSortStack<indexRWIVarEntry>> i = this.doubleDomCache.values().iterator();\r\n        kelondroSortStack<indexRWIVarEntry>.stackElement bestEntry = null;\r\n        kelondroSortStack<indexRWIVarEntry>.stackElement o;\r\n        while (i.hasNext()) {\r\n            m = i.next();\r\n            if (m == null) continue;\r\n            if (m.size() == 0) continue;\r\n            if (bestEntry == null) {\r\n                bestEntry = m.top();\r\n                continue;\r\n            }\r\n            o = m.top();\r\n            if (o.weight.longValue() < bestEntry.weight.longValue()) {\r\n                bestEntry = o;\r\n            }\r\n        }\r\n        if (bestEntry == null) return null;\r\n        // finally remove the best entry from the doubledom cache\r\n        m = this.doubleDomCache.get(bestEntry.element.urlHash().substring(6));\r\n        o = m.pop();\r\n        assert o.element.urlHash().equals(bestEntry.element.urlHash());\r\n        return bestEntry;\r\n    }","id":71549,"modified_method":"private kelondroSortStack<indexRWIVarEntry>.stackElement bestRWI(boolean skipDoubleDom) {\r\n        // returns from the current RWI list the best entry and removes this entry from the list\r\n        kelondroSortStack<indexRWIVarEntry> m;\r\n        kelondroSortStack<indexRWIVarEntry>.stackElement rwi;\r\n        while (stack.size() > 0) {\r\n            rwi = stack.pop();\r\n            if (rwi == null) continue; // in case that a synchronization problem occurred just go lazy over it\r\n            if (!skipDoubleDom) return rwi;\r\n            // check doubledom\r\n            String domhash = rwi.element.urlHash().substring(6);\r\n            m = this.doubleDomCache.get(domhash);\r\n            if (m == null) {\r\n                // first appearance of dom\r\n                m = new kelondroSortStack<indexRWIVarEntry>((query.specialRights) ? maxDoubleDomSpecial : maxDoubleDomAll);\r\n                this.doubleDomCache.put(domhash, m);\r\n                return rwi;\r\n            }\r\n            // second appearances of dom\r\n            m.push(rwi);\r\n        }\r\n        // no more entries in sorted RWI entries. Now take Elements from the doubleDomCache\r\n        // find best entry from all caches\r\n        Iterator<kelondroSortStack<indexRWIVarEntry>> i = this.doubleDomCache.values().iterator();\r\n        kelondroSortStack<indexRWIVarEntry>.stackElement bestEntry = null;\r\n        kelondroSortStack<indexRWIVarEntry>.stackElement o;\r\n        while (i.hasNext()) {\r\n            m = i.next();\r\n            if (m == null) continue;\r\n            if (m.size() == 0) continue;\r\n            if (bestEntry == null) {\r\n                bestEntry = m.top();\r\n                continue;\r\n            }\r\n            o = m.top();\r\n            if (o.weight.longValue() < bestEntry.weight.longValue()) {\r\n                bestEntry = o;\r\n            }\r\n        }\r\n        if (bestEntry == null) return null;\r\n        // finally remove the best entry from the doubledom cache\r\n        m = this.doubleDomCache.get(bestEntry.element.urlHash().substring(6));\r\n        o = m.pop();\r\n        assert o.element.urlHash().equals(bestEntry.element.urlHash());\r\n        return bestEntry;\r\n    }","commit_id":"0c173821fd5ce17d201435530af0a82c60743962","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.remoteSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP);\r\n\r\n        //System.out.println(\"yacy: search received request = \" + post.toString());\r\n\r\n        final String  oseed  = post.get(\"myseed\", \"\"); // complete seed of the requesting peer\r\n//      final String  youare = post.get(\"youare\", \"\"); // seed hash of the target peer, used for testing network stability\r\n        final String  key    = post.get(\"key\", \"\");    // transmission key for response\r\n        final String  query  = post.get(\"query\", \"\");  // a string of word hashes that shall be searched and combined\r\n        final String  exclude= post.get(\"exclude\", \"\");// a string of word hashes that shall not be within the search result\r\n        String  urls   = post.get(\"urls\", \"\");         // a string of url hashes that are preselected for the search: no other may be returned\r\n        String abstracts = post.get(\"abstracts\", \"\");  // a string of word hashes for abstracts that shall be generated, or 'auto' (for maxcount-word), or '' (for none)\r\n//      final String  fwdep  = post.get(\"fwdep\", \"\");  // forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n//      final String  fwden  = post.get(\"fwden\", \"\");  // forward deny, a list of seed hashes. They may NOT be target of forward hopping\r\n        final int     count  = Math.min(100, post.getInt(\"count\", 10)); // maximum number of wanted results\r\n        final int     maxdist= post.getInt(\"maxdist\", Integer.MAX_VALUE);\r\n        final String  prefer = post.get(\"prefer\", \"\");\r\n        final String  contentdom = post.get(\"contentdom\", \"text\");\r\n        final String  filter = post.get(\"filter\", \".*\");\r\n        final int     partitions = post.getInt(\"partitions\", 30);\r\n        String  profile = post.get(\"profile\", \"\"); // remote profile hand-over\r\n        if (profile.length() > 0) profile = crypt.simpleDecode(profile, null);\r\n        //final boolean includesnippet = post.get(\"includesnippet\", \"false\").equals(\"true\");\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (constraint != null) {\r\n        \t// check bad handover parameter from older versions\r\n            boolean allon = true;\r\n            for (int i = 0; i < 32; i++) {\r\n            \tif (!constraint.get(i)) {allon = false; break;}\r\n            }\r\n            if (allon) constraint = null;\r\n        }\r\n//      final boolean global = ((String) post.get(\"resource\", \"global\")).equals(\"global\"); // if true, then result may consist of answers from other peers\r\n//      Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME));        // read remote time\r\n\r\n        // test:\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Q (search for linux)\r\n        // http://localhost:8080/yacy/search.html?query=gh8DKIhGKXws (search for book)\r\n        // http://localhost:8080/yacy/search.html?query=UEhMGfGv2vOE (search for kernel)\r\n        // http://localhost:8080/yacy/search.html?query=ZX-LjaYo74PP (search for help)\r\n        // http://localhost:8080/yacy/search.html?query=uDqIalxDfM2a (search for mail)\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Qgh8DKIhGKXws&abstracts=auto (search for linux and book, generate abstract automatically)\r\n        // http://localhost:8080/yacy/search.html?query=&abstracts=4galTpdpDM5Q (only abstracts for linux)\r\n\r\n        if ((sb.isRobinsonMode()) &&\r\n             \t (!((sb.isPublicRobinson()) ||\r\n             \t    (sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))))) {\r\n                 // if we are a robinson cluster, answer only if this client is known by our network definition\r\n        \tprop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n        \treturn prop;\r\n        }\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.remoteSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -   6000)).size() >  1) try {\r\n            Thread.sleep(3000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -  60000)).size() > 12) try {\r\n            Thread.sleep(10000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() - 600000)).size() > 36) try {\r\n            Thread.sleep(30000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (block) {\r\n            prop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n            return prop;\r\n        }\r\n        \r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(3000);\r\n\r\n        TreeSet<String> abstractSet = ((abstracts.length() == 0) || (abstracts.equals(\"auto\"))) ? null : plasmaSearchQuery.hashes2Set(abstracts);\r\n        \r\n        // store accessing peer\r\n        yacySeed remoteSeed = yacySeed.genRemoteSeed(oseed, key, true);\r\n        if (sb.webIndex.seedDB == null) {\r\n            yacyCore.log.logSevere(\"yacy.search: seed cache not initialized\");\r\n        } else {\r\n            yacyCore.peerActions.peerArrival(remoteSeed, true);\r\n        }\r\n\r\n        // prepare search\r\n        final TreeSet<String> queryhashes = plasmaSearchQuery.hashes2Set(query);\r\n        final TreeSet<String> excludehashes = (exclude.length() == 0) ? new TreeSet<String>(kelondroBase64Order.enhancedComparator) : plasmaSearchQuery.hashes2Set(exclude);\r\n        final long timestamp = System.currentTimeMillis();\r\n        \r\n    \t// prepare a search profile\r\n        plasmaSearchRankingProfile rankingProfile = (profile.length() == 0) ? new plasmaSearchRankingProfile(plasmaSearchQuery.contentdomParser(contentdom)) : new plasmaSearchRankingProfile(\"\", profile);\r\n        \r\n        // prepare an abstract result\r\n        StringBuffer indexabstract = new StringBuffer();\r\n        int indexabstractContainercount = 0;\r\n        int joincount = 0;\r\n        plasmaSearchQuery theQuery = null;\r\n        ArrayList<kelondroSortStack<ResultEntry>.stackElement> accu = null;\r\n        plasmaSearchEvent theSearch = null;\r\n        if ((query.length() == 0) && (abstractSet != null)) {\r\n            // this is _not_ a normal search, only a request for index abstracts\r\n            theQuery = new plasmaSearchQuery(null, abstractSet, new TreeSet<String>(kelondroBase64Order.enhancedComparator), rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, null, false, yacyURL.TLD_any_zone_filter, client);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (abstracts only): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n\r\n            long timer = System.currentTimeMillis();\r\n            Map<String, indexContainer>[] containers = sb.webIndex.localSearchContainers(theQuery, plasmaSearchQuery.hashes2Set(urls));\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.COLLECTION, containers[0].size(), System.currentTimeMillis() - timer));\r\n            if (containers != null) {\r\n                Iterator<Map.Entry<String, indexContainer>> ci = containers[0].entrySet().iterator();\r\n                Map.Entry<String, indexContainer> entry;\r\n                String wordhash;\r\n                while (ci.hasNext()) {\r\n                    entry = ci.next();\r\n                    wordhash = entry.getKey();\r\n                    indexContainer container = entry.getValue();\r\n                    indexabstractContainercount += container.size();\r\n                    indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append(indexContainer.compressIndex(container, null, 1000).toString()).append(serverCore.CRLF_STRING);                \r\n                }\r\n            }\r\n            \r\n            prop.put(\"indexcount\", \"\");\r\n            prop.put(\"joincount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n            \r\n        } else {\r\n            // retrieve index containers from search request\r\n            theQuery = new plasmaSearchQuery(null, queryhashes, excludehashes, rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, constraint, false, yacyURL.TLD_any_zone_filter, client);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (query-\" + abstracts + \"): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n            RSSFeed.channels(RSSFeed.REMOTESEARCH).addMessage(new RSSMessage(\"Remote Search Request from \" + remoteSeed.getName(), plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes), \"\"));\r\n            \r\n            // make event\r\n            theSearch = plasmaSearchEvent.getEvent(theQuery, rankingProfile, sb.webIndex, sb.crawlResults, null, true); \r\n            \r\n            // set statistic details of search result and find best result index set\r\n            if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                prop.put(\"indexcount\", \"\");\r\n                prop.put(\"joincount\", \"0\");\r\n            } else {\r\n                // attach information about index abstracts\r\n                StringBuffer indexcount = new StringBuffer();\r\n                Map.Entry<String, Integer> entry;\r\n                Iterator<Map.Entry<String, Integer>> i = theSearch.IACount.entrySet().iterator();\r\n                while (i.hasNext()) {\r\n                    entry = i.next();\r\n                    indexcount.append(\"indexcount.\").append((String) entry.getKey()).append('=').append(((Integer) entry.getValue()).toString()).append(serverCore.CRLF_STRING);\r\n                }\r\n                if (abstractSet != null) {\r\n                    // if a specific index-abstract is demanded, attach it here\r\n                    Iterator<String> j = abstractSet.iterator();\r\n                    String wordhash;\r\n                    while (j.hasNext()) {\r\n                        wordhash = (String) j.next();\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(wordhash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append((String) theSearch.IAResults.get(wordhash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                }\r\n                prop.put(\"indexcount\", indexcount.toString());\r\n                \r\n                if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                    joincount = 0;\r\n                    prop.put(\"joincount\", \"0\");\r\n                } else {\r\n                    joincount = theSearch.getRankingResult().getLocalResourceSize();\r\n                    prop.put(\"joincount\", Integer.toString(joincount));\r\n                    accu = theSearch.completeResults(3000);\r\n                }\r\n                \r\n                // generate compressed index for maxcounthash\r\n                // this is not needed if the search is restricted to specific\r\n                // urls, because it is a re-search\r\n                if ((theSearch.IAmaxcounthash == null) || (urls.length() != 0) || (queryhashes.size() <= 1) || (abstracts.length() == 0)) {\r\n                    prop.put(\"indexabstract\", \"\");\r\n                } else if (abstracts.equals(\"auto\")) {\r\n                    // automatically attach the index abstract for the index that has the most references. This should be our target dht position\r\n                    indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAmaxcounthash)).intValue();\r\n                    indexabstract.append(\"indexabstract.\" + theSearch.IAmaxcounthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAmaxcounthash)).append(serverCore.CRLF_STRING);\r\n                    if ((theSearch.IAneardhthash != null) && (!(theSearch.IAneardhthash.equals(theSearch.IAmaxcounthash)))) {\r\n                        // in case that the neardhthash is different from the maxcounthash attach also the neardhthash-container\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAneardhthash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + theSearch.IAneardhthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAneardhthash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: maxcounthash = \" + maxcounthash);\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: neardhthash  = \"+ neardhthash);\r\n                    //yacyCore.log.logFine(\"DEBUG HASH SEARCH: \" + indexabstract);\r\n                }\r\n            }\r\n            if (partitions > 0) sb.requestedQueries = sb.requestedQueries + 1d / partitions; // increase query counter\r\n            \r\n            // prepare reference hints\r\n            long timer = System.currentTimeMillis();\r\n            Set<String> ws = theSearch.references(10);\r\n            StringBuffer refstr = new StringBuffer();\r\n            Iterator<String> j = ws.iterator();\r\n            while (j.hasNext()) {\r\n                refstr.append(\",\").append((String) j.next());\r\n            }\r\n            prop.put(\"references\", (refstr.length() > 0) ? refstr.substring(1) : refstr.toString());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"reference collection\", ws.size(), System.currentTimeMillis() - timer));\r\n        }\r\n        prop.put(\"indexabstract\", indexabstract.toString());\r\n        \r\n        // prepare result\r\n        if ((joincount == 0) || (accu == null)) {\r\n            \r\n            // no results\r\n            prop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n\r\n        } else {\r\n            // result is a List of urlEntry elements\r\n            long timer = System.currentTimeMillis();\r\n            StringBuffer links = new StringBuffer();\r\n            String resource = null;\r\n            kelondroSortStack<plasmaSearchEvent.ResultEntry>.stackElement entry;\r\n            for (int i = 0; i < accu.size(); i++) {\r\n                entry = accu.get(i);\r\n                resource = entry.element.resource();\r\n                if (resource != null) {\r\n                    links.append(\"resource\").append(i).append('=').append(resource).append(serverCore.CRLF_STRING);\r\n                }\r\n            }\r\n            prop.put(\"links\", links.toString());\r\n            prop.put(\"linkcount\", accu.size());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"result list preparation\", accu.size(), System.currentTimeMillis() - timer));\r\n        }\r\n        \r\n        // add information about forward peers\r\n        prop.put(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n        prop.put(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n        prop.put(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n\r\n        // prepare search statistics\r\n        theQuery.remotepeer = sb.webIndex.seedDB.lookupByIP(natLib.getInetAddress(client), true, false, false);\r\n        theQuery.resultcount = (theSearch == null) ? 0 : theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n        theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n        theQuery.urlretrievaltime = (theSearch == null) ? 0 : theSearch.getURLRetrievalTime();\r\n        theQuery.snippetcomputationtime = (theSearch == null) ? 0 : theSearch.getSnippetComputationTime();\r\n        sb.remoteSearches.add(theQuery);\r\n        \r\n        // update the search tracker\r\n        trackerHandles.add(theQuery.handle);\r\n        sb.remoteSearchTracker.put(client, trackerHandles);\r\n        \r\n        \r\n        // log\r\n        yacyCore.log.logInfo(\"EXIT HASH SEARCH: \" +\r\n                plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + joincount + \" links found, \" +\r\n                prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n                indexabstractContainercount + \" index abstracts, \" +\r\n                (System.currentTimeMillis() - timestamp) + \" milliseconds\");\r\n \r\n        prop.put(\"searchtime\", System.currentTimeMillis() - timestamp);\r\n\r\n        final int links = Integer.parseInt(prop.get(\"linkcount\",\"0\"));\r\n        sb.webIndex.seedDB.mySeed().incSI(links);\r\n        sb.webIndex.seedDB.mySeed().incSU(links);\r\n        return prop;\r\n    }","id":71550,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        // return variable that accumulates replacements\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.remoteSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        serverObjects prop = new serverObjects();\r\n        if ((post == null) || (env == null)) return prop;\r\n        if (!yacyNetwork.authentifyRequest(post, env)) return prop;\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP);\r\n\r\n        //System.out.println(\"yacy: search received request = \" + post.toString());\r\n\r\n        final String  oseed  = post.get(\"myseed\", \"\"); // complete seed of the requesting peer\r\n//      final String  youare = post.get(\"youare\", \"\"); // seed hash of the target peer, used for testing network stability\r\n        final String  key    = post.get(\"key\", \"\");    // transmission key for response\r\n        final String  query  = post.get(\"query\", \"\");  // a string of word hashes that shall be searched and combined\r\n        final String  exclude= post.get(\"exclude\", \"\");// a string of word hashes that shall not be within the search result\r\n        String  urls   = post.get(\"urls\", \"\");         // a string of url hashes that are preselected for the search: no other may be returned\r\n        String abstracts = post.get(\"abstracts\", \"\");  // a string of word hashes for abstracts that shall be generated, or 'auto' (for maxcount-word), or '' (for none)\r\n//      final String  fwdep  = post.get(\"fwdep\", \"\");  // forward depth. if \"0\" then peer may NOT ask another peer for more results\r\n//      final String  fwden  = post.get(\"fwden\", \"\");  // forward deny, a list of seed hashes. They may NOT be target of forward hopping\r\n        final int     count  = Math.min(100, post.getInt(\"count\", 10)); // maximum number of wanted results\r\n        final int     maxdist= post.getInt(\"maxdist\", Integer.MAX_VALUE);\r\n        final String  prefer = post.get(\"prefer\", \"\");\r\n        final String  contentdom = post.get(\"contentdom\", \"text\");\r\n        final String  filter = post.get(\"filter\", \".*\");\r\n        final int     partitions = post.getInt(\"partitions\", 30);\r\n        String  profile = post.get(\"profile\", \"\"); // remote profile hand-over\r\n        if (profile.length() > 0) profile = crypt.simpleDecode(profile, null);\r\n        //final boolean includesnippet = post.get(\"includesnippet\", \"false\").equals(\"true\");\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (constraint != null) {\r\n        \t// check bad handover parameter from older versions\r\n            boolean allon = true;\r\n            for (int i = 0; i < 32; i++) {\r\n            \tif (!constraint.get(i)) {allon = false; break;}\r\n            }\r\n            if (allon) constraint = null;\r\n        }\r\n//      final boolean global = ((String) post.get(\"resource\", \"global\")).equals(\"global\"); // if true, then result may consist of answers from other peers\r\n//      Date remoteTime = yacyCore.parseUniversalDate((String) post.get(yacySeed.MYTIME));        // read remote time\r\n\r\n        // test:\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Q (search for linux)\r\n        // http://localhost:8080/yacy/search.html?query=gh8DKIhGKXws (search for book)\r\n        // http://localhost:8080/yacy/search.html?query=UEhMGfGv2vOE (search for kernel)\r\n        // http://localhost:8080/yacy/search.html?query=ZX-LjaYo74PP (search for help)\r\n        // http://localhost:8080/yacy/search.html?query=uDqIalxDfM2a (search for mail)\r\n        // http://localhost:8080/yacy/search.html?query=4galTpdpDM5Qgh8DKIhGKXws&abstracts=auto (search for linux and book, generate abstract automatically)\r\n        // http://localhost:8080/yacy/search.html?query=&abstracts=4galTpdpDM5Q (only abstracts for linux)\r\n\r\n        if ((sb.isRobinsonMode()) &&\r\n             \t (!((sb.isPublicRobinson()) ||\r\n             \t    (sb.isInMyCluster((String)header.get(httpHeader.CONNECTION_PROP_CLIENTIP)))))) {\r\n                 // if we are a robinson cluster, answer only if this client is known by our network definition\r\n        \tprop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n        \treturn prop;\r\n        }\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.remoteSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -   6000)).size() >  1) try {\r\n            Thread.sleep(3000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -  60000)).size() > 12) try {\r\n            Thread.sleep(10000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() - 600000)).size() > 36) try {\r\n            Thread.sleep(30000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (block) {\r\n            prop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n            return prop;\r\n        }\r\n        \r\n        // tell all threads to do nothing for a specific time\r\n        sb.intermissionAllThreads(3000);\r\n\r\n        TreeSet<String> abstractSet = ((abstracts.length() == 0) || (abstracts.equals(\"auto\"))) ? null : plasmaSearchQuery.hashes2Set(abstracts);\r\n        \r\n        // store accessing peer\r\n        yacySeed remoteSeed = yacySeed.genRemoteSeed(oseed, key, true);\r\n        if (sb.webIndex.seedDB == null) {\r\n            yacyCore.log.logSevere(\"yacy.search: seed cache not initialized\");\r\n        } else {\r\n            yacyCore.peerActions.peerArrival(remoteSeed, true);\r\n        }\r\n\r\n        // prepare search\r\n        final TreeSet<String> queryhashes = plasmaSearchQuery.hashes2Set(query);\r\n        final TreeSet<String> excludehashes = (exclude.length() == 0) ? new TreeSet<String>(kelondroBase64Order.enhancedComparator) : plasmaSearchQuery.hashes2Set(exclude);\r\n        final long timestamp = System.currentTimeMillis();\r\n        \r\n    \t// prepare a search profile\r\n        plasmaSearchRankingProfile rankingProfile = (profile.length() == 0) ? new plasmaSearchRankingProfile(plasmaSearchQuery.contentdomParser(contentdom)) : new plasmaSearchRankingProfile(\"\", profile);\r\n        \r\n        // prepare an abstract result\r\n        StringBuffer indexabstract = new StringBuffer();\r\n        int indexabstractContainercount = 0;\r\n        int joincount = 0;\r\n        plasmaSearchQuery theQuery = null;\r\n        ArrayList<kelondroSortStack<ResultEntry>.stackElement> accu = null;\r\n        plasmaSearchEvent theSearch = null;\r\n        if ((query.length() == 0) && (abstractSet != null)) {\r\n            // this is _not_ a normal search, only a request for index abstracts\r\n            theQuery = new plasmaSearchQuery(null, abstractSet, new TreeSet<String>(kelondroBase64Order.enhancedComparator), rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, null, false, yacyURL.TLD_any_zone_filter, client, false);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (abstracts only): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n\r\n            long timer = System.currentTimeMillis();\r\n            Map<String, indexContainer>[] containers = sb.webIndex.localSearchContainers(theQuery, plasmaSearchQuery.hashes2Set(urls));\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.COLLECTION, containers[0].size(), System.currentTimeMillis() - timer));\r\n            if (containers != null) {\r\n                Iterator<Map.Entry<String, indexContainer>> ci = containers[0].entrySet().iterator();\r\n                Map.Entry<String, indexContainer> entry;\r\n                String wordhash;\r\n                while (ci.hasNext()) {\r\n                    entry = ci.next();\r\n                    wordhash = entry.getKey();\r\n                    indexContainer container = entry.getValue();\r\n                    indexabstractContainercount += container.size();\r\n                    indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append(indexContainer.compressIndex(container, null, 1000).toString()).append(serverCore.CRLF_STRING);                \r\n                }\r\n            }\r\n            \r\n            prop.put(\"indexcount\", \"\");\r\n            prop.put(\"joincount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n            \r\n        } else {\r\n            // retrieve index containers from search request\r\n            theQuery = new plasmaSearchQuery(null, queryhashes, excludehashes, rankingProfile, maxdist, prefer, plasmaSearchQuery.contentdomParser(contentdom), false, count, 0, filter, plasmaSearchQuery.SEARCHDOM_LOCAL, null, -1, constraint, false, yacyURL.TLD_any_zone_filter, client, false);\r\n            theQuery.domType = plasmaSearchQuery.SEARCHDOM_LOCAL;\r\n            yacyCore.log.logInfo(\"INIT HASH SEARCH (query-\" + abstracts + \"): \" + plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + theQuery.displayResults() + \" links\");\r\n            RSSFeed.channels(RSSFeed.REMOTESEARCH).addMessage(new RSSMessage(\"Remote Search Request from \" + remoteSeed.getName(), plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes), \"\"));\r\n            \r\n            // make event\r\n            theSearch = plasmaSearchEvent.getEvent(theQuery, rankingProfile, sb.webIndex, sb.crawlResults, null, true); \r\n            \r\n            // set statistic details of search result and find best result index set\r\n            if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                prop.put(\"indexcount\", \"\");\r\n                prop.put(\"joincount\", \"0\");\r\n            } else {\r\n                // attach information about index abstracts\r\n                StringBuffer indexcount = new StringBuffer();\r\n                Map.Entry<String, Integer> entry;\r\n                Iterator<Map.Entry<String, Integer>> i = theSearch.IACount.entrySet().iterator();\r\n                while (i.hasNext()) {\r\n                    entry = i.next();\r\n                    indexcount.append(\"indexcount.\").append((String) entry.getKey()).append('=').append(((Integer) entry.getValue()).toString()).append(serverCore.CRLF_STRING);\r\n                }\r\n                if (abstractSet != null) {\r\n                    // if a specific index-abstract is demanded, attach it here\r\n                    Iterator<String> j = abstractSet.iterator();\r\n                    String wordhash;\r\n                    while (j.hasNext()) {\r\n                        wordhash = (String) j.next();\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(wordhash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + wordhash + \"=\").append((String) theSearch.IAResults.get(wordhash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                }\r\n                prop.put(\"indexcount\", indexcount.toString());\r\n                \r\n                if (theSearch.getRankingResult().getLocalResourceSize() == 0) {\r\n                    joincount = 0;\r\n                    prop.put(\"joincount\", \"0\");\r\n                } else {\r\n                    joincount = theSearch.getRankingResult().getLocalResourceSize();\r\n                    prop.put(\"joincount\", Integer.toString(joincount));\r\n                    accu = theSearch.completeResults(3000);\r\n                }\r\n                \r\n                // generate compressed index for maxcounthash\r\n                // this is not needed if the search is restricted to specific\r\n                // urls, because it is a re-search\r\n                if ((theSearch.IAmaxcounthash == null) || (urls.length() != 0) || (queryhashes.size() <= 1) || (abstracts.length() == 0)) {\r\n                    prop.put(\"indexabstract\", \"\");\r\n                } else if (abstracts.equals(\"auto\")) {\r\n                    // automatically attach the index abstract for the index that has the most references. This should be our target dht position\r\n                    indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAmaxcounthash)).intValue();\r\n                    indexabstract.append(\"indexabstract.\" + theSearch.IAmaxcounthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAmaxcounthash)).append(serverCore.CRLF_STRING);\r\n                    if ((theSearch.IAneardhthash != null) && (!(theSearch.IAneardhthash.equals(theSearch.IAmaxcounthash)))) {\r\n                        // in case that the neardhthash is different from the maxcounthash attach also the neardhthash-container\r\n                        indexabstractContainercount += ((Integer) theSearch.IACount.get(theSearch.IAneardhthash)).intValue();\r\n                        indexabstract.append(\"indexabstract.\" + theSearch.IAneardhthash + \"=\").append((String) theSearch.IAResults.get(theSearch.IAneardhthash)).append(serverCore.CRLF_STRING);\r\n                    }\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: maxcounthash = \" + maxcounthash);\r\n                    //System.out.println(\"DEBUG-ABSTRACTGENERATION: neardhthash  = \"+ neardhthash);\r\n                    //yacyCore.log.logFine(\"DEBUG HASH SEARCH: \" + indexabstract);\r\n                }\r\n            }\r\n            if (partitions > 0) sb.requestedQueries = sb.requestedQueries + 1d / partitions; // increase query counter\r\n            \r\n            // prepare reference hints\r\n            long timer = System.currentTimeMillis();\r\n            Set<String> ws = theSearch.references(10);\r\n            StringBuffer refstr = new StringBuffer();\r\n            Iterator<String> j = ws.iterator();\r\n            while (j.hasNext()) {\r\n                refstr.append(\",\").append((String) j.next());\r\n            }\r\n            prop.put(\"references\", (refstr.length() > 0) ? refstr.substring(1) : refstr.toString());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"reference collection\", ws.size(), System.currentTimeMillis() - timer));\r\n        }\r\n        prop.put(\"indexabstract\", indexabstract.toString());\r\n        \r\n        // prepare result\r\n        if ((joincount == 0) || (accu == null)) {\r\n            \r\n            // no results\r\n            prop.put(\"links\", \"\");\r\n            prop.put(\"linkcount\", \"0\");\r\n            prop.put(\"references\", \"\");\r\n\r\n        } else {\r\n            // result is a List of urlEntry elements\r\n            long timer = System.currentTimeMillis();\r\n            StringBuffer links = new StringBuffer();\r\n            String resource = null;\r\n            kelondroSortStack<plasmaSearchEvent.ResultEntry>.stackElement entry;\r\n            for (int i = 0; i < accu.size(); i++) {\r\n                entry = accu.get(i);\r\n                resource = entry.element.resource();\r\n                if (resource != null) {\r\n                    links.append(\"resource\").append(i).append('=').append(resource).append(serverCore.CRLF_STRING);\r\n                }\r\n            }\r\n            prop.put(\"links\", links.toString());\r\n            prop.put(\"linkcount\", accu.size());\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), \"result list preparation\", accu.size(), System.currentTimeMillis() - timer));\r\n        }\r\n        \r\n        // add information about forward peers\r\n        prop.put(\"fwhop\", \"\"); // hops (depth) of forwards that had been performed to construct this result\r\n        prop.put(\"fwsrc\", \"\"); // peers that helped to construct this result\r\n        prop.put(\"fwrec\", \"\"); // peers that would have helped to construct this result (recommendations)\r\n\r\n        // prepare search statistics\r\n        theQuery.remotepeer = sb.webIndex.seedDB.lookupByIP(natLib.getInetAddress(client), true, false, false);\r\n        theQuery.resultcount = (theSearch == null) ? 0 : theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n        theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n        theQuery.urlretrievaltime = (theSearch == null) ? 0 : theSearch.getURLRetrievalTime();\r\n        theQuery.snippetcomputationtime = (theSearch == null) ? 0 : theSearch.getSnippetComputationTime();\r\n        sb.remoteSearches.add(theQuery);\r\n        \r\n        // update the search tracker\r\n        trackerHandles.add(theQuery.handle);\r\n        sb.remoteSearchTracker.put(client, trackerHandles);\r\n        \r\n        \r\n        // log\r\n        yacyCore.log.logInfo(\"EXIT HASH SEARCH: \" +\r\n                plasmaSearchQuery.anonymizedQueryHashes(theQuery.queryHashes) + \" - \" + joincount + \" links found, \" +\r\n                prop.get(\"linkcount\", \"?\") + \" links selected, \" +\r\n                indexabstractContainercount + \" index abstracts, \" +\r\n                (System.currentTimeMillis() - timestamp) + \" milliseconds\");\r\n \r\n        prop.put(\"searchtime\", System.currentTimeMillis() - timestamp);\r\n\r\n        final int links = Integer.parseInt(prop.get(\"linkcount\",\"0\"));\r\n        sb.webIndex.seedDB.mySeed().incSI(links);\r\n        sb.webIndex.seedDB.mySeed().incSU(links);\r\n        return prop;\r\n    }","commit_id":"0c173821fd5ce17d201435530af0a82c60743962","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim(); // SRU compliance\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = post.getInt(\"maximumRecords\", post.getInt(\"count\", 10)); // SRU syntax with old property as alternative\r\n        int offset = post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n        \r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        //final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        //final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 32)) itemsPerPage = 32;\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -   3000)).size() >  1) try {\r\n            Thread.sleep(3000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -  60000)).size() > 12) try {\r\n            Thread.sleep(10000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() - 600000)).size() > 36) try {\r\n            Thread.sleep(30000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        \r\n        if ((!block) && (post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            \r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            if ((query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0)) {\r\n            \tquery[0].remove(\"near\");\r\n            \tranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            if ((query[0].contains(\"recent\")) && (querystring.indexOf(\"RECENT\") >= 0)) {\r\n                query[0].remove(\"recent\");\r\n                ranking.coeff_date = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \t\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post.containsKey(\"deleteref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                sb.webIndex.removeWordReferences(query[0], delHash);\r\n\r\n                // make new news message with negative voting\r\n                HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                sb.webIndex.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.webIndex.seedDB.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                indexURLReference urlentry = sb.webIndex.getURL(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    indexURLReference.Components comp = urlentry.comp();\r\n                    plasmaParserDocument document;\r\n                    document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true, false);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", comp.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", ((document == null) ? comp.dc_title() : document.dc_title()).replace(',', ' '));\r\n                        map.put(\"author\", ((document == null) ? \"\" : document.dc_creator()));\r\n                        map.put(\"tags\", ((document == null) ? \"\" : document.dc_subject(' ')));\r\n                        sb.webIndex.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.webIndex.seedDB.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((sb.webIndex.seedDB != null) && (sb.webIndex.seedDB.mySeed() != null) && (sb.webIndex.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline) && (sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false));\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = indexWord.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tindexWord.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    yacyURL.TLD_any_zone_filter,\r\n                    client);\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.INITIALIZATION, 0, 0));\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            RSSFeed.channels(RSSFeed.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.webIndex, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n            \r\n            // update the search tracker\r\n            trackerHandles.add(theQuery.handle);\r\n            sb.localSearchTracker.put(client, trackerHandles);\r\n            \r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n            \r\n            // compose page navigation\r\n            StringBuffer resnav = new StringBuffer();\r\n            int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) resnav.append(\"&lt;&nbsp;\"); else {\r\n                resnav.append(navurla(thispage - 1, display, theQuery));\r\n                resnav.append(\"<strong>&lt;<\/strong><\/a>&nbsp;\");\r\n            }\r\n            int numberofpages = Math.min(10, Math.max(thispage + 2, totalcount / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<strong>\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/strong>&nbsp;\");\r\n                } else {\r\n                    resnav.append(navurla(i, display, theQuery));\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) resnav.append(\"&gt;\"); else {\r\n                resnav.append(navurla(thispage + 1, display, theQuery));\r\n                resnav.append(\"<strong>&gt;<\/strong><\/a>\");\r\n            }\r\n            prop.put(\"num-results_resnav\", resnav.toString());\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":71551,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        \r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim(); // SRU compliance\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = Math.max((authenticated) ? 1000 : 10, post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n        \r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        // SEARCH\r\n        //final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        //final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 32)) itemsPerPage = 32;\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -   3000)).size() >  1) try {\r\n            Thread.sleep(3000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -  60000)).size() > 12) try {\r\n            Thread.sleep(10000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() - 600000)).size() > 36) try {\r\n            Thread.sleep(30000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        \r\n        if ((!block) && (post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n            \r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            if ((query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0)) {\r\n            \tquery[0].remove(\"near\");\r\n            \tranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            if ((query[0].contains(\"recent\")) && (querystring.indexOf(\"RECENT\") >= 0)) {\r\n                query[0].remove(\"recent\");\r\n                ranking.coeff_date = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \t\r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // if a minus-button was hit, remove a special reference first\r\n            if (post.containsKey(\"deleteref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                \r\n                // delete the index entry locally\r\n                final String delHash = post.get(\"deleteref\", \"\"); // urlhash\r\n                sb.webIndex.removeWordReferences(query[0], delHash);\r\n\r\n                // make new news message with negative voting\r\n                HashMap<String, String> map = new HashMap<String, String>();\r\n                map.put(\"urlhash\", delHash);\r\n                map.put(\"vote\", \"negative\");\r\n                map.put(\"refid\", \"\");\r\n                sb.webIndex.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.webIndex.seedDB.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_VOTE_ADD, map));\r\n            }\r\n\r\n            // if a plus-button was hit, create new voting message\r\n            if (post.containsKey(\"recommendref\")) {\r\n                if (!sb.verifyAuthentication(header, true)) {\r\n                    prop.put(\"AUTHENTICATE\", \"admin log-in\"); // force log-in\r\n                    return prop;\r\n                }\r\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\r\n                indexURLReference urlentry = sb.webIndex.getURL(recommendHash, null, 0);\r\n                if (urlentry != null) {\r\n                    indexURLReference.Components comp = urlentry.comp();\r\n                    plasmaParserDocument document;\r\n                    document = plasmaSnippetCache.retrieveDocument(comp.url(), true, 5000, true, false);\r\n                    if (document != null) {\r\n                        // create a news message\r\n                        HashMap<String, String> map = new HashMap<String, String>();\r\n                        map.put(\"url\", comp.url().toNormalform(false, true).replace(',', '|'));\r\n                        map.put(\"title\", comp.dc_title().replace(',', ' '));\r\n                        map.put(\"description\", ((document == null) ? comp.dc_title() : document.dc_title()).replace(',', ' '));\r\n                        map.put(\"author\", ((document == null) ? \"\" : document.dc_creator()));\r\n                        map.put(\"tags\", ((document == null) ? \"\" : document.dc_subject(' ')));\r\n                        sb.webIndex.newsPool.publishMyNews(yacyNewsRecord.newRecord(sb.webIndex.seedDB.mySeed(), yacyNewsPool.CATEGORY_SURFTIPP_ADD, map));\r\n                        document.close();\r\n                    }\r\n                }\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((sb.webIndex.seedDB != null) && (sb.webIndex.seedDB.mySeed() != null) && (sb.webIndex.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline) && (sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false));\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = indexWord.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tindexWord.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    yacyURL.TLD_any_zone_filter,\r\n                    client,\r\n                    authenticated);\r\n            serverProfiling.update(\"SEARCH\", new plasmaProfiling.searchEvent(theQuery.id(true), plasmaSearchEvent.INITIALIZATION, 0, 0));\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(10000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            RSSFeed.channels(RSSFeed.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.webIndex, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n            \r\n            // update the search tracker\r\n            trackerHandles.add(theQuery.handle);\r\n            sb.localSearchTracker.put(client, trackerHandles);\r\n            \r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n            \r\n            // compose page navigation\r\n            StringBuffer resnav = new StringBuffer();\r\n            int thispage = offset / theQuery.displayResults();\r\n            if (thispage == 0) resnav.append(\"&lt;&nbsp;\"); else {\r\n                resnav.append(navurla(thispage - 1, display, theQuery));\r\n                resnav.append(\"<strong>&lt;<\/strong><\/a>&nbsp;\");\r\n            }\r\n            int numberofpages = Math.min(10, Math.max(thispage + 2, totalcount / theQuery.displayResults()));\r\n            for (int i = 0; i < numberofpages; i++) {\r\n                if (i == thispage) {\r\n                    resnav.append(\"<strong>\");\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/strong>&nbsp;\");\r\n                } else {\r\n                    resnav.append(navurla(i, display, theQuery));\r\n                    resnav.append(i + 1);\r\n                    resnav.append(\"<\/a>&nbsp;\");\r\n                }\r\n            }\r\n            if (thispage >= numberofpages) resnav.append(\"&gt;\"); else {\r\n                resnav.append(navurla(thispage + 1, display, theQuery));\r\n                resnav.append(\"<strong>&gt;<\/strong><\/a>\");\r\n            }\r\n            prop.put(\"num-results_resnav\", resnav.toString());\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"input_promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"0c173821fd5ce17d201435530af0a82c60743962","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"search\", \"\").trim();\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = post.getInt(\"count\", 10);\r\n        int offset = post.getInt(\"offset\", 0);\r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        int domainzone = post.getInt(\"zone\", yacyURL.TLD_any_zone_filter);\r\n        \r\n        // SEARCH\r\n        //final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        //final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 32)) itemsPerPage = 32;\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -   3000)).size() >  1) try {\r\n            Thread.sleep(3000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -  60000)).size() > 12) try {\r\n            Thread.sleep(10000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() - 600000)).size() > 36) try {\r\n            Thread.sleep(30000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        \r\n        if ((!block) && (post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n\r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            if ((query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0)) {\r\n                query[0].remove(\"near\");\r\n                ranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            if ((query[0].contains(\"recent\")) && (querystring.indexOf(\"RECENT\") >= 0)) {\r\n                query[0].remove(\"recent\");\r\n                ranking.coeff_date = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((sb.webIndex.seedDB != null) && (sb.webIndex.seedDB.mySeed() != null) && (sb.webIndex.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline) && (sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false));\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = indexWord.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tindexWord.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    domainzone,\r\n                    client);\r\n\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(3000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            RSSFeed.channels(RSSFeed.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.webIndex, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n            \r\n            // update the search tracker\r\n            trackerHandles.add(theQuery.handle);\r\n            sb.localSearchTracker.put(client, trackerHandles);\r\n            \r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","id":71552,"modified_method":"public static serverObjects respond(httpHeader header, serverObjects post, serverSwitch<?> env) {\r\n        final plasmaSwitchboard sb = (plasmaSwitchboard) env;\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        boolean searchAllowed = sb.getConfigBool(\"publicSearchpage\", true) || sb.verifyAuthentication(header, false);\r\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\r\n        int display = (post == null) ? 0 : post.getInt(\"display\", 0);\r\n        if ((display == 1) && (!authenticated)) display = 0;\r\n        int input = (post == null) ? 2 : post.getInt(\"input\", 2);\r\n        String promoteSearchPageGreeting = env.getConfig(\"promoteSearchPageGreeting\", \"\");\r\n        if (env.getConfigBool(\"promoteSearchPageGreeting.useNetworkName\", false)) promoteSearchPageGreeting = env.getConfig(\"network.unit.description\", \"\");\r\n        if (promoteSearchPageGreeting.length() == 0) promoteSearchPageGreeting = \"P2P WEB SEARCH\";\r\n        String client = (String) header.get(httpHeader.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\r\n        \r\n        // get query\r\n        String querystring = (post == null) ? \"\" : post.get(\"search\", \"\").trim();\r\n        final serverObjects prop = new serverObjects();\r\n        \r\n        boolean rss = (post == null) ? false : post.get(\"rss\", \"false\").equals(\"true\");\r\n        if ((post == null) || (env == null) || (querystring.length() == 0) || (!searchAllowed)) {\r\n            // we create empty entries for template strings\r\n            prop.put(\"searchagain\", \"0\");\r\n            prop.put(\"input\", input);\r\n            prop.put(\"display\", display);\r\n            prop.put(\"input_input\", input);\r\n            prop.put(\"input_display\", display);\r\n            prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n            prop.put(\"input_former\", \"\");\r\n            prop.put(\"former\", \"\");\r\n            prop.put(\"input_count\", \"10\");\r\n            prop.put(\"input_offset\", \"0\");\r\n            prop.put(\"input_resource\", \"global\");\r\n            prop.put(\"input_urlmaskfilter\", \".*\");\r\n            prop.put(\"input_prefermaskfilter\", \"\");\r\n            prop.put(\"input_indexof\", \"off\");\r\n            prop.put(\"input_constraint\", \"\");\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n            prop.put(\"input_contentdom\", \"text\");\r\n            prop.put(\"input_contentdomCheckText\", \"1\");\r\n            prop.put(\"input_contentdomCheckAudio\", \"0\");\r\n            prop.put(\"input_contentdomCheckVideo\", \"0\");\r\n            prop.put(\"input_contentdomCheckImage\", \"0\");\r\n            prop.put(\"input_contentdomCheckApp\", \"0\");\r\n            prop.put(\"excluded\", \"0\");\r\n            prop.put(\"results\", \"\");\r\n            prop.put(\"resultTable\", \"0\");\r\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\r\n            \r\n            return prop;\r\n        }\r\n\r\n        // collect search attributes\r\n        int maxDistance = Integer.MAX_VALUE;\r\n        \r\n        if ((querystring.length() > 2) && (querystring.charAt(0) == '\"') && (querystring.charAt(querystring.length() - 1) == '\"')) {\r\n            querystring = querystring.substring(1, querystring.length() - 1).trim();\r\n            maxDistance = 1;\r\n        }\r\n        if (sb.facilityDB != null) try { sb.facilityDB.update(\"zeitgeist\", querystring, post); } catch (Exception e) {}\r\n\r\n        int itemsPerPage = Math.max((authenticated) ? 1000 : 10, post.getInt(\"maximumRecords\", post.getInt(\"count\", 10))); // SRU syntax with old property as alternative\r\n        int offset = post.getInt(\"startRecord\", post.getInt(\"offset\", 0));\r\n        \r\n        boolean global = (post == null) ? true : post.get(\"resource\", \"global\").equals(\"global\");\r\n        final boolean indexof = post.get(\"indexof\",\"\").equals(\"on\"); \r\n        String urlmask = \"\";\r\n        if (post.containsKey(\"urlmask\") && post.get(\"urlmask\").equals(\"no\")) {\r\n            urlmask = \".*\";\r\n        } else {\r\n            urlmask = (post.containsKey(\"urlmaskfilter\")) ? (String) post.get(\"urlmaskfilter\") : \".*\";\r\n        }\r\n        String prefermask = post.get(\"prefermaskfilter\", \"\");\r\n        if ((prefermask.length() > 0) && (prefermask.indexOf(\".*\") < 0)) prefermask = \".*\" + prefermask + \".*\";\r\n\r\n        kelondroBitfield constraint = ((post.containsKey(\"constraint\")) && (post.get(\"constraint\", \"\").length() > 0)) ? new kelondroBitfield(4, post.get(\"constraint\", \"______\")) : null;\r\n        if (indexof) {\r\n            constraint = new kelondroBitfield(4);\r\n            constraint.set(plasmaCondenser.flag_cat_indexof, true);\r\n        }\r\n        \r\n        int domainzone = post.getInt(\"zone\", yacyURL.TLD_any_zone_filter);\r\n        \r\n        // SEARCH\r\n        //final boolean indexDistributeGranted = sb.getConfig(plasmaSwitchboard.INDEX_DIST_ALLOW, \"true\").equals(\"true\");\r\n        //final boolean indexReceiveGranted = sb.getConfig(\"allowReceiveIndex\", \"true\").equals(\"true\");\r\n        //final boolean offline = yacyCore.seedDB.mySeed().isVirgin();\r\n        final boolean clustersearch = sb.isRobinsonMode() &&\r\n    \t\t\t\t\t\t\t\t\t(sb.getConfig(\"cluster.mode\", \"\").equals(\"privatecluster\") ||\r\n    \t\t\t\t\t\t\t\t\t sb.getConfig(\"cluster.mode\", \"\").equals(\"publiccluster\"));\r\n        //if (offline || !indexDistributeGranted || !indexReceiveGranted) { global = false; }\r\n        if (clustersearch) global = true; // switches search on, but search target is limited to cluster nodes\r\n        \r\n        // find search domain\r\n        int contentdomCode = plasmaSearchQuery.contentdomParser(post.get(\"contentdom\", \"text\"));\r\n        \r\n        // patch until better search profiles are available\r\n        if ((contentdomCode != plasmaSearchQuery.CONTENTDOM_TEXT) && (itemsPerPage <= 32)) itemsPerPage = 32;\r\n        \r\n        // check the search tracker\r\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\r\n        if (trackerHandles == null) trackerHandles = new TreeSet<Long>();\r\n        boolean block = false;\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -   3000)).size() >  1) try {\r\n            Thread.sleep(3000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() -  60000)).size() > 12) try {\r\n            Thread.sleep(10000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        if (trackerHandles.tailSet(new Long(System.currentTimeMillis() - 600000)).size() > 36) try {\r\n            Thread.sleep(30000);\r\n            block = true;\r\n        } catch (InterruptedException e) { e.printStackTrace(); }\r\n        \r\n        if ((!block) && (post.get(\"cat\", \"href\").equals(\"href\"))) {\r\n\r\n            plasmaSearchRankingProfile ranking = sb.getRanking();\r\n            final TreeSet<String>[] query = plasmaSearchQuery.cleanQuery(querystring); // converts also umlaute\r\n            if ((query[0].contains(\"near\")) && (querystring.indexOf(\"NEAR\") >= 0)) {\r\n                query[0].remove(\"near\");\r\n                ranking.coeff_worddistance = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            if ((query[0].contains(\"recent\")) && (querystring.indexOf(\"RECENT\") >= 0)) {\r\n                query[0].remove(\"recent\");\r\n                ranking.coeff_date = plasmaSearchRankingProfile.COEFF_MAX;\r\n            }\r\n            \r\n            // filter out stopwords\r\n            final TreeSet<String> filtered = kelondroMSetTools.joinConstructive(query[0], plasmaSwitchboard.stopwords);\r\n            if (filtered.size() > 0) {\r\n                kelondroMSetTools.excludeDestructive(query[0], plasmaSwitchboard.stopwords);\r\n            }\r\n\r\n            // prepare search properties\r\n            final boolean yacyonline = ((sb.webIndex.seedDB != null) && (sb.webIndex.seedDB.mySeed() != null) && (sb.webIndex.seedDB.mySeed().getPublicAddress() != null));\r\n            final boolean globalsearch = (global) && (yacyonline) && (sb.getConfigBool(plasmaSwitchboard.INDEX_RECEIVE_ALLOW, false));\r\n        \r\n            // do the search\r\n            TreeSet<String> queryHashes = indexWord.words2hashes(query[0]);\r\n            plasmaSearchQuery theQuery = new plasmaSearchQuery(\r\n        \t\t\tquerystring,\r\n        \t\t\tqueryHashes,\r\n        \t\t\tindexWord.words2hashes(query[1]),\r\n        \t\t\tranking,\r\n                    maxDistance,\r\n                    prefermask,\r\n                    contentdomCode,\r\n                    true,\r\n                    itemsPerPage,\r\n                    offset,\r\n                    urlmask,\r\n                    (clustersearch && globalsearch) ? plasmaSearchQuery.SEARCHDOM_CLUSTERALL :\r\n                    ((globalsearch) ? plasmaSearchQuery.SEARCHDOM_GLOBALDHT : plasmaSearchQuery.SEARCHDOM_LOCAL),\r\n                    \"\",\r\n                    20,\r\n                    constraint,\r\n                    true,\r\n                    domainzone,\r\n                    client,\r\n                    authenticated);\r\n\r\n            \r\n            // tell all threads to do nothing for a specific time\r\n            sb.intermissionAllThreads(3000);\r\n        \r\n            // filter out words that appear in bluelist\r\n            theQuery.filterOut(plasmaSwitchboard.blueList);\r\n            \r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"INIT WORD SEARCH: \" + theQuery.queryString + \":\" + theQuery.queryHashes + \" - \" + theQuery.neededResults() + \" links to be computed, \" + theQuery.displayResults() + \" lines to be displayed\");\r\n            RSSFeed.channels(RSSFeed.LOCALSEARCH).addMessage(new RSSMessage(\"Local Search Request\", theQuery.queryString, \"\"));\r\n            long timestamp = System.currentTimeMillis();\r\n\r\n            // create a new search event\r\n            if (plasmaSearchEvent.getEvent(theQuery.id(false)) == null) {\r\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset \r\n                offset = 0;\r\n            }\r\n            plasmaSearchEvent theSearch = plasmaSearchEvent.getEvent(theQuery, ranking, sb.webIndex, sb.crawlResults, (sb.isRobinsonMode()) ? sb.clusterhashes : null, false);\r\n            \r\n            // generate result object\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER ORDERING OF SEARCH RESULTS: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER RESULT PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n                \r\n            // calc some more cross-reference\r\n            serverLog.logFine(\"LOCAL_SEARCH\", \"SEARCH TIME AFTER XREF PREPARATION: \" + ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // log\r\n            serverLog.logInfo(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \" + theQuery.queryString + \" - \" +\r\n                    (theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize()) + \" links found, \" +\r\n                    ((System.currentTimeMillis() - timestamp) / 1000) + \" seconds\");\r\n\r\n            // prepare search statistics\r\n            theQuery.resultcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\r\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\r\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\r\n            sb.localSearches.add(theQuery);\r\n            \r\n            // update the search tracker\r\n            trackerHandles.add(theQuery.handle);\r\n            sb.localSearchTracker.put(client, trackerHandles);\r\n            \r\n            int totalcount = theSearch.getRankingResult().getLocalResourceSize() + theSearch.getRankingResult().getRemoteResourceSize();\r\n            prop.put(\"num-results_offset\", offset);\r\n            prop.put(\"num-results_itemscount\", \"0\");\r\n            prop.put(\"num-results_itemsPerPage\", itemsPerPage);\r\n            prop.put(\"num-results_totalcount\", yFormatter.number(totalcount, !rss));\r\n            prop.put(\"num-results_globalresults\", (globalsearch) ? \"1\" : \"0\");\r\n            prop.put(\"num-results_globalresults_localResourceSize\", yFormatter.number(theSearch.getRankingResult().getLocalResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteResourceSize\", yFormatter.number(theSearch.getRankingResult().getRemoteResourceSize(), !rss));\r\n            prop.put(\"num-results_globalresults_remoteIndexCount\", yFormatter.number(theSearch.getRankingResult().getRemoteIndexCount(), !rss));\r\n            prop.put(\"num-results_globalresults_remotePeerCount\", yFormatter.number(theSearch.getRankingResult().getRemotePeerCount(), !rss));\r\n        \r\n            // generate the search result lines; they will be produced by another servlet\r\n            for (int i = 0; i < theQuery.displayResults(); i++) {\r\n                prop.put(\"results_\" + i + \"_item\", offset + i);\r\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\r\n            }\r\n            prop.put(\"results\", theQuery.displayResults());\r\n            prop.put(\"resultTable\", (contentdomCode <= 1) ? \"0\" : \"1\");\r\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\r\n            \r\n            // process result of search\r\n            if (filtered.size() > 0) {\r\n                prop.put(\"excluded\", \"1\");\r\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\r\n            } else {\r\n                prop.put(\"excluded\", \"0\");\r\n            }\r\n\r\n            if (prop == null || prop.size() == 0) {\r\n                if (post.get(\"search\", \"\").length() < 3) {\r\n                    prop.put(\"num-results\", \"2\"); // no results - at least 3 chars\r\n                } else {\r\n                    prop.put(\"num-results\", \"1\"); // no results\r\n                }\r\n            } else {\r\n                prop.put(\"num-results\", \"3\");\r\n            }\r\n\r\n            prop.put(\"input_cat\", \"href\");\r\n            prop.put(\"input_depth\", \"0\");\r\n\r\n            // adding some additional properties needed for the rss feed\r\n            String hostName = (String) header.get(\"Host\", \"localhost\");\r\n            if (hostName.indexOf(\":\") == -1) hostName += \":\" + serverCore.getPortNr(env.getConfig(\"port\", \"8080\"));\r\n            prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\r\n            prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.gif\");\r\n        }\r\n        \r\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\r\n        prop.put(\"input\", input);\r\n        prop.put(\"display\", display);\r\n        prop.put(\"input_input\", input);\r\n        prop.put(\"input_display\", display);\r\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\r\n        prop.putHTML(\"input_former\", querystring);\r\n        //prop.put(\"former\", post.get(\"search\", \"\"));\r\n        prop.put(\"input_count\", itemsPerPage);\r\n        prop.put(\"input_offset\", offset);\r\n        prop.put(\"input_resource\", global ? \"global\" : \"local\");\r\n        prop.putHTML(\"input_urlmaskfilter\", urlmask);\r\n        prop.putHTML(\"input_prefermaskfilter\", prefermask);\r\n        prop.put(\"input_indexof\", (indexof) ? \"on\" : \"off\");\r\n        prop.put(\"input_constraint\", (constraint == null) ? \"\" : constraint.exportB64());\r\n        prop.put(\"input_contentdom\", post.get(\"contentdom\", \"text\"));\r\n        prop.put(\"input_contentdomCheckText\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_TEXT) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckAudio\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_AUDIO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckVideo\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_VIDEO) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckImage\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_IMAGE) ? \"1\" : \"0\");\r\n        prop.put(\"input_contentdomCheckApp\", (contentdomCode == plasmaSearchQuery.CONTENTDOM_APP) ? \"1\" : \"0\");\r\n        \r\n        // for RSS: don't HTML encode some elements\r\n        prop.putHTML(\"rss_query\", querystring, true);\r\n        prop.put(\"rss_queryenc\", yacyURL.escape(querystring.replace(' ', '+')));\r\n\r\n        sb.localSearchLastAccess = System.currentTimeMillis();\r\n        \r\n        // return rewrite properties\r\n        return prop;\r\n    }","commit_id":"0c173821fd5ce17d201435530af0a82c60743962","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"protected void updateIGImageEntries(long companyId, long fileEntryTypeId)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tString sql = \"select * from IGImage\";\n\n\t\t\tif (companyId != 0) {\n\t\t\t\tsql = \"select * from IGImage where companyId = ?\";\n\t\t\t}\n\n\t\t\tps = con.prepareStatement(sql);\n\n\t\t\tif (companyId != 0) {\n\t\t\t\tps.setLong(1, companyId);\n\t\t\t}\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tString uuid = rs.getString(\"uuid_\");\n\t\t\t\tlong imageId = rs.getLong(\"imageId\");\n\t\t\t\tlong groupId = rs.getLong(\"groupId\");\n\t\t\t\tcompanyId = rs.getLong(\"companyId\");\n\t\t\t\tlong userId = rs.getLong(\"userId\");\n\t\t\t\tString userName = rs.getString(\"userName\");\n\t\t\t\tTimestamp createDate = rs.getTimestamp(\"createDate\");\n\t\t\t\tTimestamp modifiedDate = rs.getTimestamp(\"modifiedDate\");\n\t\t\t\tlong folderId = rs.getLong(\"folderId\");\n\t\t\t\tString title = rs.getString(\"name\");\n\t\t\t\tString description = rs.getString(\"description\");\n\t\t\t\tlong smallImageId = rs.getLong(\"smallImageId\");\n\t\t\t\tlong largeImageId = rs.getLong(\"largeImageId\");\n\t\t\t\tlong custom1ImageId = rs.getLong(\"custom1ImageId\");\n\t\t\t\tlong custom2ImageId = rs.getLong(\"custom2ImageId\");\n\n\t\t\t\tObject[] image = getImage(largeImageId);\n\n\t\t\t\tif (image == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString extension = (String)image[0];\n\n\t\t\t\tString mimeType = MimeTypesUtil.getExtensionContentType(\n\t\t\t\t\textension);\n\n\t\t\t\tString name = String.valueOf(\n\t\t\t\t\tincrement(DLFileEntry.class.getName()));\n\n\t\t\t\tlong size = (Long)image[1];\n\n\t\t\t\ttry {\n\t\t\t\t\taddDLFileEntry(\n\t\t\t\t\t\tuuid, imageId, groupId, companyId, userId, userName,\n\t\t\t\t\t\tuserId, userName, createDate, modifiedDate, groupId,\n\t\t\t\t\t\tfolderId, name, extension, mimeType, title, description,\n\t\t\t\t\t\tStringPool.BLANK, fileEntryTypeId, \"1.0\", size, 0,\n\t\t\t\t\t\tsmallImageId, largeImageId, custom1ImageId,\n\t\t\t\t\t\tcustom2ImageId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\ttitle = title.concat(StringPool.SPACE).concat(\n\t\t\t\t\t\tString.valueOf(imageId));\n\n\t\t\t\t\taddDLFileEntry(\n\t\t\t\t\t\tuuid, imageId, groupId, companyId, userId, userName,\n\t\t\t\t\t\tuserId, userName, createDate, modifiedDate, groupId,\n\t\t\t\t\t\tfolderId, name, extension, mimeType, title, description,\n\t\t\t\t\t\tStringPool.BLANK, fileEntryTypeId, \"1.0\", size, 0,\n\t\t\t\t\t\tsmallImageId, largeImageId, custom1ImageId,\n\t\t\t\t\t\tcustom2ImageId);\n\t\t\t\t}\n\n\t\t\t\taddDLFileVersion(\n\t\t\t\t\tincrement(), groupId, companyId, userId, userName,\n\t\t\t\t\tcreateDate, groupId, folderId, imageId, extension, mimeType,\n\t\t\t\t\ttitle, description, StringPool.BLANK, StringPool.BLANK,\n\t\t\t\t\tfileEntryTypeId, \"1.0\", size, 0, userId, userName,\n\t\t\t\t\tmodifiedDate);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","id":71553,"modified_method":"protected void updateIGImageEntries(long companyId, long fileEntryTypeId)\n\t\tthrows Exception {\n\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tString sql = \"select * from IGImage\";\n\n\t\t\tif (companyId != 0) {\n\t\t\t\tsql = \"select * from IGImage where companyId = ?\";\n\t\t\t}\n\n\t\t\tps = con.prepareStatement(sql);\n\n\t\t\tif (companyId != 0) {\n\t\t\t\tps.setLong(1, companyId);\n\t\t\t}\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\twhile (rs.next()) {\n\t\t\t\tString uuid = rs.getString(\"uuid_\");\n\t\t\t\tlong imageId = rs.getLong(\"imageId\");\n\t\t\t\tlong groupId = rs.getLong(\"groupId\");\n\t\t\t\tcompanyId = rs.getLong(\"companyId\");\n\t\t\t\tlong userId = rs.getLong(\"userId\");\n\t\t\t\tString userName = rs.getString(\"userName\");\n\t\t\t\tTimestamp createDate = rs.getTimestamp(\"createDate\");\n\t\t\t\tTimestamp modifiedDate = rs.getTimestamp(\"modifiedDate\");\n\t\t\t\tlong folderId = rs.getLong(\"folderId\");\n\t\t\t\tString title = rs.getString(\"name\");\n\t\t\t\tString description = rs.getString(\"description\");\n\t\t\t\tlong smallImageId = rs.getLong(\"smallImageId\");\n\t\t\t\tlong largeImageId = rs.getLong(\"largeImageId\");\n\t\t\t\tlong custom1ImageId = rs.getLong(\"custom1ImageId\");\n\t\t\t\tlong custom2ImageId = rs.getLong(\"custom2ImageId\");\n\n\t\t\t\tImage image = getImage(largeImageId);\n\n\t\t\t\tif (image == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tString extension = image.getType();\n\n\t\t\t\tString mimeType = MimeTypesUtil.getExtensionContentType(\n\t\t\t\t\textension);\n\n\t\t\t\tString name = String.valueOf(\n\t\t\t\t\tincrement(DLFileEntry.class.getName()));\n\n\t\t\t\tlong size = image.getSize();\n\n\t\t\t\ttry {\n\t\t\t\t\taddDLFileEntry(\n\t\t\t\t\t\tuuid, imageId, groupId, companyId, userId, userName,\n\t\t\t\t\t\tuserId, userName, createDate, modifiedDate, groupId,\n\t\t\t\t\t\tfolderId, name, extension, mimeType, title, description,\n\t\t\t\t\t\tStringPool.BLANK, fileEntryTypeId, \"1.0\", size, 0,\n\t\t\t\t\t\tsmallImageId, largeImageId, custom1ImageId,\n\t\t\t\t\t\tcustom2ImageId);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\ttitle = title.concat(StringPool.SPACE).concat(\n\t\t\t\t\t\tString.valueOf(imageId));\n\n\t\t\t\t\taddDLFileEntry(\n\t\t\t\t\t\tuuid, imageId, groupId, companyId, userId, userName,\n\t\t\t\t\t\tuserId, userName, createDate, modifiedDate, groupId,\n\t\t\t\t\t\tfolderId, name, extension, mimeType, title, description,\n\t\t\t\t\t\tStringPool.BLANK, fileEntryTypeId, \"1.0\", size, 0,\n\t\t\t\t\t\tsmallImageId, largeImageId, custom1ImageId,\n\t\t\t\t\t\tcustom2ImageId);\n\t\t\t\t}\n\n\t\t\t\taddDLFileVersion(\n\t\t\t\t\tincrement(), groupId, companyId, userId, userName,\n\t\t\t\t\tcreateDate, groupId, folderId, imageId, extension, mimeType,\n\t\t\t\t\ttitle, description, StringPool.BLANK, StringPool.BLANK,\n\t\t\t\t\tfileEntryTypeId, \"1.0\", size, 0, userId, userName,\n\t\t\t\t\tmodifiedDate);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","commit_id":"0705a92d45f07be6c3918154a2ae59c377690c4c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected Object[] getImage(long imageId) throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select type_, size_ from Image where imageId = \" + imageId);\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\tif (rs.next()) {\n\t\t\t\tString type = rs.getString(\"type_\");\n\t\t\t\tlong size = rs.getInt(\"size_\");\n\n\t\t\t\treturn new Object[] {type, size};\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","id":71554,"modified_method":"protected Image getImage(long imageId) throws Exception {\n\t\tConnection con = null;\n\t\tPreparedStatement ps = null;\n\t\tResultSet rs = null;\n\n\t\ttry {\n\t\t\tcon = DataAccess.getUpgradeOptimizedConnection();\n\n\t\t\tps = con.prepareStatement(\n\t\t\t\t\"select imageId, modifiedDate, type_, height, width, size_ \" +\n\t\t\t\t\t\"from Image where imageId = \" + imageId);\n\n\t\t\trs = ps.executeQuery();\n\n\t\t\tif (rs.next()) {\n\t\t\t\tImage image = ImageLocalServiceUtil.createImage(\n\t\t\t\t\trs.getLong(\"imageId\"));\n\n\t\t\t\timage.setModifiedDate(rs.getTimestamp(\"modifiedDate\"));\n\t\t\t\timage.setType(rs.getString(\"type_\"));\n\t\t\t\timage.setHeight(rs.getInt(\"height\"));\n\t\t\t\timage.setWidth(rs.getInt(\"width\"));\n\t\t\t\timage.setSize(rs.getInt(\"size_\"));\n\n\t\t\t\treturn image;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t\tfinally {\n\t\t\tDataAccess.cleanUp(con, ps, rs);\n\t\t}\n\t}","commit_id":"0705a92d45f07be6c3918154a2ae59c377690c4c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String getUnstableMessage(String buildURL) throws Exception {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tJSONObject testReportJSONObject = JenkinsResultsParserUtil.toJSONObject(\n\t\t\tJenkinsResultsParserUtil.getLocalURL(\n\t\t\t\tbuildURL + \"testReport/api/json\"));\n\n\t\tint failCount = testReportJSONObject.getInt(\"failCount\");\n\t\tint totalCount = testReportJSONObject.getInt(\"totalCount\");\n\n\t\tint passCount = totalCount - failCount;\n\n\t\tsb.append(\"<h6>Job Results:<\/h6><p>\");\n\t\tsb.append(passCount);\n\t\tsb.append(\" Test\");\n\n\t\tif (passCount != 1) {\n\t\t\tsb.append(\"s\");\n\t\t}\n\n\t\tsb.append(\" Passed.<br />\");\n\t\tsb.append(failCount);\n\t\tsb.append(\" Test\");\n\n\t\tif (failCount != 1) {\n\t\t\tsb.append(\"s\");\n\t\t}\n\n\t\tsb.append(\" Failed.<\/p><ol>\");\n\n\t\tList<String> runBuildURLs = new ArrayList<>();\n\n\t\tJSONObject jsonObject = JenkinsResultsParserUtil.toJSONObject(\n\t\t\tJenkinsResultsParserUtil.getLocalURL(buildURL + \"api/json\"));\n\n\t\tif (jsonObject.has(\"runs\")) {\n\t\t\tJSONArray runsJSONArray = jsonObject.getJSONArray(\"runs\");\n\n\t\t\tfor (int i = 0; i < runsJSONArray.length(); i++) {\n\t\t\t\tJSONObject runJSONObject = runsJSONArray.getJSONObject(i);\n\n\t\t\t\tString runBuildURL = runJSONObject.getString(\"url\");\n\n\t\t\t\tif (!runBuildURL.endsWith(\n\t\t\t\t\t\t\"/\" + jsonObject.getInt(\"number\") + \"/\")) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tJSONObject runBuildURLJSONObject =\n\t\t\t\t\tJenkinsResultsParserUtil.toJSONObject(\n\t\t\t\t\t\tJenkinsResultsParserUtil.getLocalURL(\n\t\t\t\t\t\t\trunBuildURL + \"api/json\"));\n\n\t\t\t\tString result = runBuildURLJSONObject.getString(\"result\");\n\n\t\t\t\tif (!result.equals(\"SUCCESS\")) {\n\t\t\t\t\trunBuildURLs.add(runBuildURL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trunBuildURLs.add(buildURL);\n\t\t}\n\n\t\tint failureCount = _getUnstableMessage(runBuildURLs, sb);\n\n\t\tsb.append(\"<\/ol>\");\n\n\t\tif (failureCount > 3) {\n\t\t\tsb.append(\"<p><strong>Click <a href=\\\"\");\n\t\t\tsb.append(buildURL);\n\t\t\tsb.append(\"/testReport/\\\">here<\/a> for more failures.<\/strong>\");\n\t\t\tsb.append(\"<\/p>\");\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":71555,"modified_method":"public static String getUnstableMessage(String buildURL) throws Exception {\n\t\tStringBuilder sb = new StringBuilder();\n\n\t\tJSONObject testReportJSONObject = JenkinsResultsParserUtil.toJSONObject(\n\t\t\tJenkinsResultsParserUtil.getLocalURL(\n\t\t\t\tbuildURL + \"testReport/api/json\"));\n\n\t\tint failCount = testReportJSONObject.getInt(\"failCount\");\n\n\t\tint totalCount;\n\t\tint passCount;\n\n\t\tif (testReportJSONObject.has(\"totalCount\") &&\n\t\t\t!testReportJSONObject.has(\"passCount\")) {\n\n\t\t\ttotalCount = testReportJSONObject.getInt(\"totalCount\");\n\n\t\t\tpassCount = totalCount - failCount;\n\t\t}\n\t\telse {\n\t\t\tpassCount = testReportJSONObject.getInt(\"passCount\");\n\n\t\t\ttotalCount = failCount + passCount;\n\t\t}\n\n\t\tsb.append(\"<h6>Job Results:<\/h6><p>\");\n\t\tsb.append(passCount);\n\t\tsb.append(\" Test\");\n\n\t\tif (passCount != 1) {\n\t\t\tsb.append(\"s\");\n\t\t}\n\n\t\tsb.append(\" Passed.<br />\");\n\t\tsb.append(failCount);\n\t\tsb.append(\" Test\");\n\n\t\tif (failCount != 1) {\n\t\t\tsb.append(\"s\");\n\t\t}\n\n\t\tsb.append(\" Failed.<\/p><ol>\");\n\n\t\tList<String> runBuildURLs = new ArrayList<>();\n\n\t\tJSONObject jsonObject = JenkinsResultsParserUtil.toJSONObject(\n\t\t\tJenkinsResultsParserUtil.getLocalURL(buildURL + \"api/json\"));\n\n\t\tif (jsonObject.has(\"runs\")) {\n\t\t\tJSONArray runsJSONArray = jsonObject.getJSONArray(\"runs\");\n\n\t\t\tfor (int i = 0; i < runsJSONArray.length(); i++) {\n\t\t\t\tJSONObject runJSONObject = runsJSONArray.getJSONObject(i);\n\n\t\t\t\tString runBuildURL = runJSONObject.getString(\"url\");\n\n\t\t\t\tif (!runBuildURL.endsWith(\n\t\t\t\t\t\t\"/\" + jsonObject.getInt(\"number\") + \"/\")) {\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tJSONObject runBuildURLJSONObject =\n\t\t\t\t\tJenkinsResultsParserUtil.toJSONObject(\n\t\t\t\t\t\tJenkinsResultsParserUtil.getLocalURL(\n\t\t\t\t\t\t\trunBuildURL + \"api/json\"));\n\n\t\t\t\tString result = runBuildURLJSONObject.getString(\"result\");\n\n\t\t\t\tif (!result.equals(\"SUCCESS\")) {\n\t\t\t\t\trunBuildURLs.add(runBuildURL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\trunBuildURLs.add(buildURL);\n\t\t}\n\n\t\tint failureCount = _getUnstableMessage(runBuildURLs, sb);\n\n\t\tsb.append(\"<\/ol>\");\n\n\t\tif (failureCount > 3) {\n\t\t\tsb.append(\"<p><strong>Click <a href=\\\"\");\n\t\t\tsb.append(buildURL);\n\t\t\tsb.append(\"/testReport/\\\">here<\/a> for more failures.<\/strong>\");\n\t\t\tsb.append(\"<\/p>\");\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"b482984306178a724362f4ba3d488bbf5f80b2a2","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected EPackageDescriptor target(EClassDescriptor source) {\n\t\t\t\treturn source.getEPackageDescriptor();\n\t\t\t}\n\t\t};\n\t}","id":71556,"modified_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EPackageDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getEPackageDescriptor());\n\t\t\t}\n\t\t};\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"public ECrossReferenceDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tsourceScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected EObjectDescriptor target(ECrossReferenceDescriptor source) {\n\t\t\t\treturn source.getSource();\n\t\t\t}\n\t\t};\n\t\ttargetScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected EObjectDescriptor target(ECrossReferenceDescriptor source) {\n\t\t\t\treturn source.getTarget();\n\t\t\t}\n\t\t};\n\t}","id":71557,"modified_method":"public ECrossReferenceDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tsourceScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<EObjectDescriptor> targets(ECrossReferenceDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getSource());\n\t\t\t}\n\t\t};\n\t\ttargetScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<EObjectDescriptor> targets(ECrossReferenceDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getTarget());\n\t\t\t}\n\t\t};\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"public EObjectDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tresourceScope = new InverseReferenceCache<ResourceDescriptor, EObjectDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected ResourceDescriptor target(EObjectDescriptor source) {\n\t\t\t\treturn source.getResourceDescriptor();\n\t\t\t}\n\t\t};\n\t\teClassScope = new InverseReferenceCache<EClassDescriptor, EObjectDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected EClassDescriptor target(EObjectDescriptor source) {\n\t\t\t\treturn source.getEClassDescriptor();\n\t\t\t}\n\t\t};\n\t}","id":71558,"modified_method":"public EObjectDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tresourceScope = new InverseReferenceCache<ResourceDescriptor, EObjectDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<ResourceDescriptor> targets(EObjectDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getResourceDescriptor());\n\t\t\t}\n\t\t};\n\t\teClassScope = new InverseReferenceCache<EClassDescriptor, EObjectDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<EClassDescriptor> targets(EObjectDescriptor source) {\n\t\t\t\tList<EClassDescriptor> classes = new ArrayList<EClassDescriptor>();\n\t\t\t\tclasses.add(source.getEClassDescriptor());\n\t\t\t\tEClassDescriptor[] superClasses = source.getEClassDescriptor().getSuperClasses();\n\t\t\t\tif (superClasses != null)\n\t\t\t\t\tclasses.addAll(Arrays.asList(superClasses));\n\t\t\t\treturn classes;\n\t\t\t}\n\t\t};\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected EClassDescriptor internalIndexEClass(EClass eClass, EPackageDescriptor ePackageDescriptor,\n\t\t\tCollection<EClassDescriptor> oldEClassDescriptors, MultiMap<EClassDescriptor, EClass> forwardSuperClassMap) {\n\t\tList<EClassDescriptor> indexedSuperClasses = null;\n\t\tList<EClass> forwardSuperClasses = null;\n\t\tfor (EClass superType : eClass.getEAllSuperTypes()) {\n\t\t\tEClassDescriptor superClassDescriptor = index.eClassDAO().createQueryEClass(superType)\n\t\t\t\t\t.executeSingleResult();\n\t\t\tif (superClassDescriptor == null) {\n\t\t\t\tif (forwardSuperClasses == null)\n\t\t\t\t\tforwardSuperClasses = new ArrayList<EClass>();\n\t\t\t\tforwardSuperClasses.add(superType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (indexedSuperClasses == null)\n\t\t\t\t\tindexedSuperClasses = new ArrayList<EClassDescriptor>();\n\t\t\t\tindexedSuperClasses.add(superClassDescriptor);\n\t\t\t}\n\t\t}\n\t\tEClassDescriptor[] superClassDescriptors = (indexedSuperClasses == null) ? null : indexedSuperClasses\n\t\t\t\t.toArray(new EClassDescriptor[indexedSuperClasses.size()]);\n\t\tEClassDescriptor typeDescriptor = typeFactory.createDescriptor(eClass, ePackageDescriptor,\n\t\t\t\tsuperClassDescriptors);\n\t\tif (oldEClassDescriptors == null || !oldEClassDescriptors.remove(typeDescriptor))\n\t\t\tindex.eClassDAO().store(typeDescriptor);\n\t\treturn typeDescriptor;\n\t}","id":71559,"modified_method":"protected EClassDescriptor internalIndexEClass(EClass eClass, EPackageDescriptor ePackageDescriptor,\n\t\t\tCollection<EClassDescriptor> oldEClassDescriptors, MultiMap<EClassDescriptor, EClass> forwardSuperClassMap) {\n\t\tList<EClassDescriptor> indexedSuperClasses = null;\n\t\tSet<EClass> forwardSuperClasses = null;\n\t\tfor (EClass superType : eClass.getEAllSuperTypes()) {\n\t\t\tEClassDescriptor superClassDescriptor = index.eClassDAO().createQueryEClass(superType)\n\t\t\t\t\t.executeSingleResult();\n\t\t\tif (superClassDescriptor == null) {\n\t\t\t\tif (forwardSuperClasses == null)\n\t\t\t\t\tforwardSuperClasses = new HashSet<EClass>();\n\t\t\t\tforwardSuperClasses.add(superType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (indexedSuperClasses == null)\n\t\t\t\t\tindexedSuperClasses = new ArrayList<EClassDescriptor>();\n\t\t\t\tindexedSuperClasses.add(superClassDescriptor);\n\t\t\t}\n\t\t}\n\t\tEClassDescriptor[] superClassDescriptors = (indexedSuperClasses == null) ? null : indexedSuperClasses\n\t\t\t\t.toArray(new EClassDescriptor[indexedSuperClasses.size()]);\n\t\tEClassDescriptor typeDescriptor = typeFactory.createDescriptor(eClass, ePackageDescriptor,\n\t\t\t\tsuperClassDescriptors);\n\t\tif (oldEClassDescriptors == null || !oldEClassDescriptors.remove(typeDescriptor))\n\t\t\tindex.eClassDAO().store(typeDescriptor);\n\t\tif (forwardSuperClasses != null)\n\t\t\tforwardSuperClassMap.put(typeDescriptor, forwardSuperClasses);\n\t\treturn typeDescriptor;\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<EClassDescriptor> internalIndexEPackageContents(EPackage ePackage,\n\t\t\tEPackageDescriptor ePackageDescriptor) {\n\t\tCollection<EClassDescriptor> oldEClassDescriptors = index.eClassDAO().createQueryEClassesInPackage(\n\t\t\t\tePackageDescriptor).executeListResult();\n\t\tList<EClassDescriptor> newEClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\tMultiMap<EClassDescriptor, EClass> forwardSuperClassMap = new MultiMap<EClassDescriptor, EClass>();\n\t\tfor (EClassifier eClassifier : ePackage.getEClassifiers()) {\n\t\t\tif (eClassifier instanceof EClass)\n\t\t\t\tnewEClassDescriptors.add(internalIndexEClass((EClass) eClassifier, ePackageDescriptor,\n\t\t\t\t\t\toldEClassDescriptors, forwardSuperClassMap));\n\t\t}\n\t\tfor (Entry<EClassDescriptor, Set<EClass>> danglingSuperClassEntry : forwardSuperClassMap.entrySet()) {\n\t\t\tboolean isSuperClassesAdded = false;\n\t\t\tList<EClassDescriptor> superClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\t\tEClassDescriptor subClassDescriptor = danglingSuperClassEntry.getKey();\n\t\t\tsuperClassDescriptors.addAll(Arrays.asList(subClassDescriptor.getSuperClasses()));\n\t\t\tfor (EClass danglingSuperClass : danglingSuperClassEntry.getValue()) {\n\t\t\t\tEClassDescriptor superClassDescriptor = internalIndexSingleEClass(danglingSuperClass);\n\t\t\t\tif (superClassDescriptor != null) {\n\t\t\t\t\tisSuperClassesAdded = true;\n\t\t\t\t\tsuperClassDescriptors.add(superClassDescriptor);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"Cannot index superclass \" + danglingSuperClass.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isSuperClassesAdded) {\n\t\t\t\tindex.eClassDAO().delete(subClassDescriptor);\n\t\t\t\tsubClassDescriptor = typeFactory.createDescriptor(subClassDescriptor.getName(), ePackageDescriptor,\n\t\t\t\t\t\tsuperClassDescriptors.toArray(new EClassDescriptor[superClassDescriptors.size()]));\n\t\t\t}\n\t\t}\n\t\tif (oldEClassDescriptors != null)\n\t\t\tfor (EClassDescriptor staleClassDescriptor : oldEClassDescriptors) {\n\t\t\t\tindex.eClassDAO().delete(staleClassDescriptor);\n\t\t\t}\n\t\treturn newEClassDescriptors;\n\t}","id":71560,"modified_method":"protected List<EClassDescriptor> internalIndexEPackageContents(EPackage ePackage,\n\t\t\tEPackageDescriptor ePackageDescriptor) {\n\t\tCollection<EClassDescriptor> oldEClassDescriptors = index.eClassDAO().createQueryEClassesInPackage(\n\t\t\t\tePackageDescriptor).executeListResult();\n\t\tList<EClassDescriptor> newEClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\tMultiMap<EClassDescriptor, EClass> forwardSuperClassMap = new MultiMap<EClassDescriptor, EClass>();\n\t\tfor (EClassifier eClassifier : ePackage.getEClassifiers()) {\n\t\t\tif (eClassifier instanceof EClass)\n\t\t\t\tnewEClassDescriptors.add(internalIndexEClass((EClass) eClassifier, ePackageDescriptor,\n\t\t\t\t\t\toldEClassDescriptors, forwardSuperClassMap));\n\t\t}\n\t\tfor (Entry<EClassDescriptor, Set<EClass>> danglingSuperClassEntry : forwardSuperClassMap.entrySet()) {\n\t\t\tboolean isSuperClassesAdded = false;\n\t\t\tList<EClassDescriptor> superClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\t\tEClassDescriptor subClassDescriptor = danglingSuperClassEntry.getKey();\n\t\t\tEClassDescriptor[] existingSuperClasses = subClassDescriptor.getSuperClasses();\n\t\t\tif (existingSuperClasses != null)\n\t\t\t\tsuperClassDescriptors.addAll(Arrays.asList(existingSuperClasses));\n\t\t\tfor (EClass danglingSuperClass : danglingSuperClassEntry.getValue()) {\n\t\t\t\tEClassDescriptor superClassDescriptor = internalIndexSingleEClass(danglingSuperClass);\n\t\t\t\tif (superClassDescriptor != null) {\n\t\t\t\t\tisSuperClassesAdded = true;\n\t\t\t\t\tsuperClassDescriptors.add(superClassDescriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\terror(\"Cannot index superclass \" + danglingSuperClass.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isSuperClassesAdded) {\n\t\t\t\tindex.eClassDAO().delete(subClassDescriptor);\n\t\t\t\tsubClassDescriptor = typeFactory.createDescriptor(subClassDescriptor.getName(), ePackageDescriptor,\n\t\t\t\t\t\tsuperClassDescriptors.toArray(new EClassDescriptor[superClassDescriptors.size()]));\n\t\t\t\tindex.eClassDAO().store(subClassDescriptor);\n\t\t\t}\n\t\t}\n\t\tif (oldEClassDescriptors != null)\n\t\t\tfor (EClassDescriptor staleClassDescriptor : oldEClassDescriptors) {\n\t\t\t\tindex.eClassDAO().delete(staleClassDescriptor);\n\t\t\t}\n\t\treturn newEClassDescriptors;\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testIntegration() throws Exception {\n\t\tfeeder.index(EcorePackage.eINSTANCE, true);\n\t\tfeeder.registerCrossReferenceDescriptorFactory(new CrossReferenceDescriptorImpl.CachingFactory());\n\t\tindexExampleResource();\n\t\tCollection<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tassertEquals(1, elementResult.size());\n\t\tEObjectDescriptor elementDescriptor = elementResult.iterator().next();\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), false);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tCollection<org.eclipse.emf.index.EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tassertEquals(1, typeResult.size());\n\t\tEClassDescriptor typeDescriptor0 = typeResult.iterator().next();\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tCollection<org.eclipse.emf.index.ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.size() > 0);\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\t}","id":71561,"modified_method":"public void testIntegration() throws Exception {\n\t\tfeeder.index(EcorePackage.eINSTANCE, true);\n\t\tindexExampleResource();\n\t\tCollection<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tassertEquals(1, elementResult.size());\n\t\tEObjectDescriptor elementDescriptor = elementResult.iterator().next();\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), false);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tCollection<org.eclipse.emf.index.EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tassertEquals(1, typeResult.size());\n\t\tEClassDescriptor typeDescriptor0 = typeResult.iterator().next();\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\t\tEClassDescriptor[] superClasses = typeDescriptor0.getSuperClasses();\n\t\tassertNotNull(superClasses);\n\t\t// four super classes: EClassifier, ENamedElement, EModelElement and EObject\n\t\tassertEquals(4, superClasses.length);\n\t\t\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tCollection<org.eclipse.emf.index.ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.size() > 0);\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void put(SourceDesc sourceDescriptor) {\n\t\tTargetDesc targetDescriptor = target(sourceDescriptor);\n\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\tif(sources == null) {\n\t\t\tsources = new HashSet<SourceDesc>();\n\t\t\tresultMap.put(targetDescriptor, sources);\n\t\t}\n\t\tsources.add(sourceDescriptor);\n\t}","id":71562,"modified_method":"public void put(SourceDesc sourceDescriptor) {\n\t\tList<TargetDesc> targetDescriptors = targets(sourceDescriptor);\n\t\tfor (TargetDesc targetDescriptor : targetDescriptors) {\n\t\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\t\tif (sources == null) {\n\t\t\t\tsources = new HashSet<SourceDesc>();\n\t\t\t\tresultMap.put(targetDescriptor, sources);\n\t\t\t}\n\t\t\tsources.add(sourceDescriptor);\n\t\t}\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"public void remove(SourceDesc sourceDescriptor) {\n\t\tTargetDesc targetDescriptor = target(sourceDescriptor);\n\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\tif(sources != null) {\n\t\t\tsources.remove(sourceDescriptor);\n\t\t\tif(sources.isEmpty()) {\n\t\t\t\tresultMap.remove(targetDescriptor);\n\t\t\t}\n\t\t}\n\t}","id":71563,"modified_method":"public void remove(SourceDesc sourceDescriptor) {\n\t\tList<TargetDesc> targetDescriptors = targets(sourceDescriptor);\n\t\tfor (TargetDesc targetDescriptor : targetDescriptors) {\n\t\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\t\tif (sources != null) {\n\t\t\t\tsources.remove(sourceDescriptor);\n\t\t\t\tif (sources.isEmpty()) {\n\t\t\t\t\tresultMap.remove(targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"protected abstract TargetDesc target(SourceDesc source);","id":71564,"modified_method":"protected abstract List<TargetDesc> targets(SourceDesc source);","commit_id":"e010e348d48650cba006ed41f6f52bc55223bf0e","url":"https://github.com/eclipse/xtext"},{"original_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected EPackageDescriptor target(EClassDescriptor source) {\n\t\t\t\treturn source.getEPackageDescriptor();\n\t\t\t}\n\t\t};\n\t}","id":71565,"modified_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EPackageDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getEPackageDescriptor());\n\t\t\t}\n\t\t};\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"public ECrossReferenceDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tsourceScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected EObjectDescriptor target(ECrossReferenceDescriptor source) {\n\t\t\t\treturn source.getSource();\n\t\t\t}\n\t\t};\n\t\ttargetScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected EObjectDescriptor target(ECrossReferenceDescriptor source) {\n\t\t\t\treturn source.getTarget();\n\t\t\t}\n\t\t};\n\t}","id":71566,"modified_method":"public ECrossReferenceDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tsourceScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<EObjectDescriptor> targets(ECrossReferenceDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getSource());\n\t\t\t}\n\t\t};\n\t\ttargetScope = new InverseReferenceCache<EObjectDescriptor, ECrossReferenceDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<EObjectDescriptor> targets(ECrossReferenceDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getTarget());\n\t\t\t}\n\t\t};\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"public EObjectDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tresourceScope = new InverseReferenceCache<ResourceDescriptor, EObjectDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected ResourceDescriptor target(EObjectDescriptor source) {\n\t\t\t\treturn source.getResourceDescriptor();\n\t\t\t}\n\t\t};\n\t\teClassScope = new InverseReferenceCache<EClassDescriptor, EObjectDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected EClassDescriptor target(EObjectDescriptor source) {\n\t\t\t\treturn source.getEClassDescriptor();\n\t\t\t}\n\t\t};\n\t}","id":71567,"modified_method":"public EObjectDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tresourceScope = new InverseReferenceCache<ResourceDescriptor, EObjectDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<ResourceDescriptor> targets(EObjectDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getResourceDescriptor());\n\t\t\t}\n\t\t};\n\t\teClassScope = new InverseReferenceCache<EClassDescriptor, EObjectDescriptor>() {\n\t\t\t@Override\n\t\t\tprotected List<EClassDescriptor> targets(EObjectDescriptor source) {\n\t\t\t\tList<EClassDescriptor> classes = new ArrayList<EClassDescriptor>();\n\t\t\t\tclasses.add(source.getEClassDescriptor());\n\t\t\t\tEClassDescriptor[] superClasses = source.getEClassDescriptor().getSuperClasses();\n\t\t\t\tif (superClasses != null)\n\t\t\t\t\tclasses.addAll(Arrays.asList(superClasses));\n\t\t\t\treturn classes;\n\t\t\t}\n\t\t};\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"protected EClassDescriptor internalIndexEClass(EClass eClass, EPackageDescriptor ePackageDescriptor,\n\t\t\tCollection<EClassDescriptor> oldEClassDescriptors, MultiMap<EClassDescriptor, EClass> forwardSuperClassMap) {\n\t\tList<EClassDescriptor> indexedSuperClasses = null;\n\t\tList<EClass> forwardSuperClasses = null;\n\t\tfor (EClass superType : eClass.getEAllSuperTypes()) {\n\t\t\tEClassDescriptor superClassDescriptor = index.eClassDAO().createQueryEClass(superType)\n\t\t\t\t\t.executeSingleResult();\n\t\t\tif (superClassDescriptor == null) {\n\t\t\t\tif (forwardSuperClasses == null)\n\t\t\t\t\tforwardSuperClasses = new ArrayList<EClass>();\n\t\t\t\tforwardSuperClasses.add(superType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (indexedSuperClasses == null)\n\t\t\t\t\tindexedSuperClasses = new ArrayList<EClassDescriptor>();\n\t\t\t\tindexedSuperClasses.add(superClassDescriptor);\n\t\t\t}\n\t\t}\n\t\tEClassDescriptor[] superClassDescriptors = (indexedSuperClasses == null) ? null : indexedSuperClasses\n\t\t\t\t.toArray(new EClassDescriptor[indexedSuperClasses.size()]);\n\t\tEClassDescriptor typeDescriptor = typeFactory.createDescriptor(eClass, ePackageDescriptor,\n\t\t\t\tsuperClassDescriptors);\n\t\tif (oldEClassDescriptors == null || !oldEClassDescriptors.remove(typeDescriptor))\n\t\t\tindex.eClassDAO().store(typeDescriptor);\n\t\treturn typeDescriptor;\n\t}","id":71568,"modified_method":"protected EClassDescriptor internalIndexEClass(EClass eClass, EPackageDescriptor ePackageDescriptor,\n\t\t\tCollection<EClassDescriptor> oldEClassDescriptors, MultiMap<EClassDescriptor, EClass> forwardSuperClassMap) {\n\t\tList<EClassDescriptor> indexedSuperClasses = null;\n\t\tSet<EClass> forwardSuperClasses = null;\n\t\tfor (EClass superType : eClass.getEAllSuperTypes()) {\n\t\t\tEClassDescriptor superClassDescriptor = index.eClassDAO().createQueryEClass(superType)\n\t\t\t\t\t.executeSingleResult();\n\t\t\tif (superClassDescriptor == null) {\n\t\t\t\tif (forwardSuperClasses == null)\n\t\t\t\t\tforwardSuperClasses = new HashSet<EClass>();\n\t\t\t\tforwardSuperClasses.add(superType);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (indexedSuperClasses == null)\n\t\t\t\t\tindexedSuperClasses = new ArrayList<EClassDescriptor>();\n\t\t\t\tindexedSuperClasses.add(superClassDescriptor);\n\t\t\t}\n\t\t}\n\t\tEClassDescriptor[] superClassDescriptors = (indexedSuperClasses == null) ? null : indexedSuperClasses\n\t\t\t\t.toArray(new EClassDescriptor[indexedSuperClasses.size()]);\n\t\tEClassDescriptor typeDescriptor = typeFactory.createDescriptor(eClass, ePackageDescriptor,\n\t\t\t\tsuperClassDescriptors);\n\t\tif (oldEClassDescriptors == null || !oldEClassDescriptors.remove(typeDescriptor))\n\t\t\tindex.eClassDAO().store(typeDescriptor);\n\t\tif (forwardSuperClasses != null)\n\t\t\tforwardSuperClassMap.put(typeDescriptor, forwardSuperClasses);\n\t\treturn typeDescriptor;\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"protected List<EClassDescriptor> internalIndexEPackageContents(EPackage ePackage,\n\t\t\tEPackageDescriptor ePackageDescriptor) {\n\t\tCollection<EClassDescriptor> oldEClassDescriptors = index.eClassDAO().createQueryEClassesInPackage(\n\t\t\t\tePackageDescriptor).executeListResult();\n\t\tList<EClassDescriptor> newEClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\tMultiMap<EClassDescriptor, EClass> forwardSuperClassMap = new MultiMap<EClassDescriptor, EClass>();\n\t\tfor (EClassifier eClassifier : ePackage.getEClassifiers()) {\n\t\t\tif (eClassifier instanceof EClass)\n\t\t\t\tnewEClassDescriptors.add(internalIndexEClass((EClass) eClassifier, ePackageDescriptor,\n\t\t\t\t\t\toldEClassDescriptors, forwardSuperClassMap));\n\t\t}\n\t\tfor (Entry<EClassDescriptor, Set<EClass>> danglingSuperClassEntry : forwardSuperClassMap.entrySet()) {\n\t\t\tboolean isSuperClassesAdded = false;\n\t\t\tList<EClassDescriptor> superClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\t\tEClassDescriptor subClassDescriptor = danglingSuperClassEntry.getKey();\n\t\t\tsuperClassDescriptors.addAll(Arrays.asList(subClassDescriptor.getSuperClasses()));\n\t\t\tfor (EClass danglingSuperClass : danglingSuperClassEntry.getValue()) {\n\t\t\t\tEClassDescriptor superClassDescriptor = internalIndexSingleEClass(danglingSuperClass);\n\t\t\t\tif (superClassDescriptor != null) {\n\t\t\t\t\tisSuperClassesAdded = true;\n\t\t\t\t\tsuperClassDescriptors.add(superClassDescriptor);\n\t\t\t\t} else {\n\t\t\t\t\terror(\"Cannot index superclass \" + danglingSuperClass.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isSuperClassesAdded) {\n\t\t\t\tindex.eClassDAO().delete(subClassDescriptor);\n\t\t\t\tsubClassDescriptor = typeFactory.createDescriptor(subClassDescriptor.getName(), ePackageDescriptor,\n\t\t\t\t\t\tsuperClassDescriptors.toArray(new EClassDescriptor[superClassDescriptors.size()]));\n\t\t\t}\n\t\t}\n\t\tif (oldEClassDescriptors != null)\n\t\t\tfor (EClassDescriptor staleClassDescriptor : oldEClassDescriptors) {\n\t\t\t\tindex.eClassDAO().delete(staleClassDescriptor);\n\t\t\t}\n\t\treturn newEClassDescriptors;\n\t}","id":71569,"modified_method":"protected List<EClassDescriptor> internalIndexEPackageContents(EPackage ePackage,\n\t\t\tEPackageDescriptor ePackageDescriptor) {\n\t\tCollection<EClassDescriptor> oldEClassDescriptors = index.eClassDAO().createQueryEClassesInPackage(\n\t\t\t\tePackageDescriptor).executeListResult();\n\t\tList<EClassDescriptor> newEClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\tMultiMap<EClassDescriptor, EClass> forwardSuperClassMap = new MultiMap<EClassDescriptor, EClass>();\n\t\tfor (EClassifier eClassifier : ePackage.getEClassifiers()) {\n\t\t\tif (eClassifier instanceof EClass)\n\t\t\t\tnewEClassDescriptors.add(internalIndexEClass((EClass) eClassifier, ePackageDescriptor,\n\t\t\t\t\t\toldEClassDescriptors, forwardSuperClassMap));\n\t\t}\n\t\tfor (Entry<EClassDescriptor, Set<EClass>> danglingSuperClassEntry : forwardSuperClassMap.entrySet()) {\n\t\t\tboolean isSuperClassesAdded = false;\n\t\t\tList<EClassDescriptor> superClassDescriptors = new ArrayList<EClassDescriptor>();\n\t\t\tEClassDescriptor subClassDescriptor = danglingSuperClassEntry.getKey();\n\t\t\tEClassDescriptor[] existingSuperClasses = subClassDescriptor.getSuperClasses();\n\t\t\tif (existingSuperClasses != null)\n\t\t\t\tsuperClassDescriptors.addAll(Arrays.asList(existingSuperClasses));\n\t\t\tfor (EClass danglingSuperClass : danglingSuperClassEntry.getValue()) {\n\t\t\t\tEClassDescriptor superClassDescriptor = internalIndexSingleEClass(danglingSuperClass);\n\t\t\t\tif (superClassDescriptor != null) {\n\t\t\t\t\tisSuperClassesAdded = true;\n\t\t\t\t\tsuperClassDescriptors.add(superClassDescriptor);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\terror(\"Cannot index superclass \" + danglingSuperClass.getName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isSuperClassesAdded) {\n\t\t\t\tindex.eClassDAO().delete(subClassDescriptor);\n\t\t\t\tsubClassDescriptor = typeFactory.createDescriptor(subClassDescriptor.getName(), ePackageDescriptor,\n\t\t\t\t\t\tsuperClassDescriptors.toArray(new EClassDescriptor[superClassDescriptors.size()]));\n\t\t\t\tindex.eClassDAO().store(subClassDescriptor);\n\t\t\t}\n\t\t}\n\t\tif (oldEClassDescriptors != null)\n\t\t\tfor (EClassDescriptor staleClassDescriptor : oldEClassDescriptors) {\n\t\t\t\tindex.eClassDAO().delete(staleClassDescriptor);\n\t\t\t}\n\t\treturn newEClassDescriptors;\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testIntegration() throws Exception {\n\t\tfeeder.index(EcorePackage.eINSTANCE, true);\n\t\tfeeder.registerCrossReferenceDescriptorFactory(new CrossReferenceDescriptorImpl.CachingFactory());\n\t\tindexExampleResource();\n\t\tCollection<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tassertEquals(1, elementResult.size());\n\t\tEObjectDescriptor elementDescriptor = elementResult.iterator().next();\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), false);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tCollection<org.eclipse.emf.index.EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tassertEquals(1, typeResult.size());\n\t\tEClassDescriptor typeDescriptor0 = typeResult.iterator().next();\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tCollection<org.eclipse.emf.index.ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.size() > 0);\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\t}","id":71570,"modified_method":"public void testIntegration() throws Exception {\n\t\tfeeder.index(EcorePackage.eINSTANCE, true);\n\t\tindexExampleResource();\n\t\tCollection<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tassertEquals(1, elementResult.size());\n\t\tEObjectDescriptor elementDescriptor = elementResult.iterator().next();\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), false);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tCollection<org.eclipse.emf.index.EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\")\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tassertEquals(1, typeResult.size());\n\t\tEClassDescriptor typeDescriptor0 = typeResult.iterator().next();\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\t\tEClassDescriptor[] superClasses = typeDescriptor0.getSuperClasses();\n\t\tassertNotNull(superClasses);\n\t\t// four super classes: EClassifier, ENamedElement, EModelElement and EObject\n\t\tassertEquals(4, superClasses.length);\n\t\t\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tCollection<org.eclipse.emf.index.ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery\n\t\t\t\t.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.size() > 0);\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void remove(SourceDesc sourceDescriptor) {\n\t\tTargetDesc targetDescriptor = target(sourceDescriptor);\n\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\tif(sources != null) {\n\t\t\tsources.remove(sourceDescriptor);\n\t\t\tif(sources.isEmpty()) {\n\t\t\t\tresultMap.remove(targetDescriptor);\n\t\t\t}\n\t\t}\n\t}","id":71571,"modified_method":"public void remove(SourceDesc sourceDescriptor) {\n\t\tList<TargetDesc> targetDescriptors = targets(sourceDescriptor);\n\t\tfor (TargetDesc targetDescriptor : targetDescriptors) {\n\t\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\t\tif (sources != null) {\n\t\t\t\tsources.remove(sourceDescriptor);\n\t\t\t\tif (sources.isEmpty()) {\n\t\t\t\t\tresultMap.remove(targetDescriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"protected abstract TargetDesc target(SourceDesc source);","id":71572,"modified_method":"protected abstract List<TargetDesc> targets(SourceDesc source);","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void put(SourceDesc sourceDescriptor) {\n\t\tTargetDesc targetDescriptor = target(sourceDescriptor);\n\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\tif(sources == null) {\n\t\t\tsources = new HashSet<SourceDesc>();\n\t\t\tresultMap.put(targetDescriptor, sources);\n\t\t}\n\t\tsources.add(sourceDescriptor);\n\t}","id":71573,"modified_method":"public void put(SourceDesc sourceDescriptor) {\n\t\tList<TargetDesc> targetDescriptors = targets(sourceDescriptor);\n\t\tfor (TargetDesc targetDescriptor : targetDescriptors) {\n\t\t\tSet<SourceDesc> sources = resultMap.get(targetDescriptor);\n\t\t\tif (sources == null) {\n\t\t\t\tsources = new HashSet<SourceDesc>();\n\t\t\t\tresultMap.put(targetDescriptor, sources);\n\t\t\t}\n\t\t\tsources.add(sourceDescriptor);\n\t\t}\n\t}","commit_id":"9f0d7e906f739946ab3cb9f21c21a8c053a2396c","url":"https://github.com/eclipse/xtext"},{"original_method":"public void handleElement(Lexer lexer) {\n      final CharSequence buffer = lexer.getBufferSequence();\n      final char firstCh = buffer.charAt(lexer.getTokenStart());\n\n      if (seenScript && !seenTag) {\n        seenContentType = false;\n\n        if (((firstCh == 'l' || firstCh == 't') || (caseInsensitive && (firstCh == 'L' || firstCh == 'T')))) {\n          @NonNls String name = TreeUtil.getTokenText(lexer);\n          if (caseInsensitive) name = name.toLowerCase();\n\n          if (\"language\".equals(name) || \"type\".equals(name)) {\n            seenContentType = true;\n          }\n        }\n\n        return;\n      }\n\n      if (firstCh !='o' && firstCh !='s' &&\n          (!caseInsensitive || (firstCh !='S' && firstCh !='O') )\n          ) {\n        return; // optimization\n      }\n\n      String name = TreeUtil.getTokenText(lexer);\n      if (caseInsensitive) name = name.toLowerCase();\n\n      final boolean style = name.equals(TOKEN_STYLE);\n      final int state = getState() & BASE_STATE_MASK;\n      final boolean script = name.equals(TOKEN_SCRIPT) || \n                       ((name.startsWith(TOKEN_ON) && name.indexOf(':') == -1 && !isHtmlTagState(state)));\n\n      if (style || script) {\n        // encountered tag name in end of tag\n        if (seenTag) {\n          if (isHtmlTagState(state)) {\n            seenTag = false;\n          }\n          return;\n        }\n\n        seenStyle = style;\n        seenScript = script;\n\n        if (!isHtmlTagState(state)) {\n          seenAttribute=true;\n        }\n      }\n    }","id":71574,"modified_method":"public void handleElement(Lexer lexer) {\n      final CharSequence buffer;\n      if (lexerOfCacheBufferSequence == lexer) {\n        buffer = cachedBufferSequence;\n      } else {\n        cachedBufferSequence = lexer.getBufferSequence();\n        buffer = cachedBufferSequence;\n        lexerOfCacheBufferSequence = lexer;\n      }\n\n      final char firstCh = buffer.charAt(lexer.getTokenStart());\n\n      if (seenScript && !seenTag) {\n        seenContentType = false;\n\n        if (((firstCh == 'l' || firstCh == 't') || (caseInsensitive && (firstCh == 'L' || firstCh == 'T')))) {\n          @NonNls String name = TreeUtil.getTokenText(lexer);\n          if (caseInsensitive) name = name.toLowerCase();\n\n          if (\"language\".equals(name) || \"type\".equals(name)) {\n            seenContentType = true;\n          }\n        }\n\n        return;\n      }\n\n      if (firstCh !='o' && firstCh !='s' &&\n          (!caseInsensitive || (firstCh !='S' && firstCh !='O') )\n          ) {\n        return; // optimization\n      }\n\n      String name = TreeUtil.getTokenText(lexer);\n      if (caseInsensitive) name = name.toLowerCase();\n\n      final boolean style = name.equals(TOKEN_STYLE);\n      final int state = getState() & BASE_STATE_MASK;\n      final boolean script = name.equals(TOKEN_SCRIPT) || \n                       ((name.startsWith(TOKEN_ON) && name.indexOf(':') == -1 && !isHtmlTagState(state)));\n\n      if (style || script) {\n        // encountered tag name in end of tag\n        if (seenTag) {\n          if (isHtmlTagState(state)) {\n            seenTag = false;\n          }\n          return;\n        }\n\n        seenStyle = style;\n        seenScript = script;\n\n        if (!isHtmlTagState(state)) {\n          seenAttribute=true;\n        }\n      }\n    }","commit_id":"edb0f8da53c5af48789527ac121af257e7f55b34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void addOccurrenceInToken(final int occurrenceMask) {\n    myOccurrenceConsumer.addOccurrence(getBufferSequence(), getTokenStart(), getTokenEnd(), occurrenceMask);\n  }","id":71575,"modified_method":"protected final void addOccurrenceInToken(final int occurrenceMask) {\n    if (myCachedBufferSequence == null) myCachedBufferSequence = getBufferSequence();\n    myOccurrenceConsumer.addOccurrence(myCachedBufferSequence, getTokenStart(), getTokenEnd(), occurrenceMask);\n  }","commit_id":"82efd7711c6fcd40266f8ca45d6b4532dd9203c5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected final void scanWordsInToken(final int occurrenceMask, boolean mayHaveFileRefs, final boolean mayHaveEscapes) {\n    myOccurenceMask = occurrenceMask;\n    final int start = getTokenStart();\n    final int end = getTokenEnd();\n    IdTableBuilding.scanWords(this, getBufferSequence(), null, start, end, mayHaveEscapes);\n\n    if (mayHaveFileRefs) {\n      processPossibleComplexFileName(getBufferSequence(), start, end);\n    }\n  }","id":71576,"modified_method":"protected final void scanWordsInToken(final int occurrenceMask, boolean mayHaveFileRefs, final boolean mayHaveEscapes) {\n    myOccurenceMask = occurrenceMask;\n    final int start = getTokenStart();\n    final int end = getTokenEnd();\n    if (myCachedBufferSequence == null) myCachedBufferSequence = getBufferSequence();\n    IdTableBuilding.scanWords(this, myCachedBufferSequence, null, start, end, mayHaveEscapes);\n\n    if (mayHaveFileRefs) {\n      processPossibleComplexFileName(myCachedBufferSequence, start, end);\n    }\n  }","commit_id":"19320b663052222fc38612d2a64d50e72796fbe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Lexer getDelegate() {\n    return myDelegate;\n  }","id":71577,"modified_method":"public final Lexer getDelegate() {\n    return myDelegate;\n  }","commit_id":"19320b663052222fc38612d2a64d50e72796fbe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CharSequence getBufferSequence() {\n    return myDelegate.getBufferSequence();\n  }","id":71578,"modified_method":"public final CharSequence getBufferSequence() {\n    return myDelegate.getBufferSequence();\n  }","commit_id":"19320b663052222fc38612d2a64d50e72796fbe7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void unregisterForTraps(TrapNotificationListener listener, int snmpTrapPort) {\n        RegistrationInfo info = (RegistrationInfo)JoeSnmpStrategy.m_registrations.remove(listener);\n        info.getSession().close();\n    }","id":71579,"modified_method":"public void unregisterForTraps(TrapNotificationListener listener, int snmpTrapPort) {\n        RegistrationInfo info = s_registrations.remove(listener);\n        info.getSession().close();\n    }","commit_id":"1e71d51ff7b0e487f505ddcfa41952707f5d9e9a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduTrap pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator it = m_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = (RegistrationInfo) it.next();\n            if (destPort == info.getPort())\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n        }\n    }","id":71580,"modified_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduTrap pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator<RegistrationInfo> it = s_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = it.next();\n            if (destPort == info.getPort()) {\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n            }\n        }\n    }","commit_id":"1e71d51ff7b0e487f505ddcfa41952707f5d9e9a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduRequest pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator it = m_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = (RegistrationInfo) it.next();\n            if (destPort == info.getPort())\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n        }\n    }","id":71581,"modified_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduRequest pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator<RegistrationInfo> it = s_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = it.next();\n            if (destPort == info.getPort()) {\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n            }\n        }\n    }","commit_id":"1e71d51ff7b0e487f505ddcfa41952707f5d9e9a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized static SnmpTrapSession getTrapSession() throws SocketException {\n        if (sm_trapSession == null) {\n            sm_trapSession = new SnmpTrapSession(null, -1);\n        }\n        return sm_trapSession;\n    }","id":71582,"modified_method":"private synchronized static SnmpTrapSession getTrapSession() throws SocketException {\n        if (s_trapSession == null) {\n            s_trapSession = new SnmpTrapSession(null, -1);\n        }\n        return s_trapSession;\n    }","commit_id":"1e71d51ff7b0e487f505ddcfa41952707f5d9e9a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void registerForTraps(TrapNotificationListener listener, TrapProcessorFactory processorFactory, int snmpTrapPort) throws IOException {\n        RegistrationInfo info = new RegistrationInfo(listener, snmpTrapPort);\n        \n        JoeSnmpTrapNotifier m_trapHandler = new JoeSnmpTrapNotifier(listener, processorFactory);\n        info.setHandler(m_trapHandler);\n        SnmpTrapSession m_trapSession = new SnmpTrapSession(m_trapHandler, snmpTrapPort);\n        info.setSession(m_trapSession);\n        \n        JoeSnmpStrategy.m_registrations.put(listener, info);\n    }","id":71583,"modified_method":"public void registerForTraps(TrapNotificationListener listener, TrapProcessorFactory processorFactory, int snmpTrapPort) throws IOException {\n        RegistrationInfo info = new RegistrationInfo(listener, snmpTrapPort);\n        \n        JoeSnmpTrapNotifier m_trapHandler = new JoeSnmpTrapNotifier(listener, processorFactory);\n        info.setHandler(m_trapHandler);\n        SnmpTrapSession m_trapSession = new SnmpTrapSession(m_trapHandler, snmpTrapPort);\n        info.setSession(m_trapSession);\n        \n        s_registrations.put(listener, info);\n    }","commit_id":"1e71d51ff7b0e487f505ddcfa41952707f5d9e9a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void registerForTraps(TrapNotificationListener listener, TrapProcessorFactory processorFactory, int snmpTrapPort) throws IOException {\n        RegistrationInfo info = new RegistrationInfo(listener, snmpTrapPort);\n        \n        JoeSnmpTrapNotifier m_trapHandler = new JoeSnmpTrapNotifier(listener, processorFactory);\n        info.setHandler(m_trapHandler);\n        SnmpTrapSession m_trapSession = new SnmpTrapSession(m_trapHandler, snmpTrapPort);\n        info.setSession(m_trapSession);\n        \n        JoeSnmpStrategy.m_registrations.put(listener, info);\n    }","id":71584,"modified_method":"public void registerForTraps(TrapNotificationListener listener, TrapProcessorFactory processorFactory, int snmpTrapPort) throws IOException {\n        RegistrationInfo info = new RegistrationInfo(listener, snmpTrapPort);\n        \n        JoeSnmpTrapNotifier m_trapHandler = new JoeSnmpTrapNotifier(listener, processorFactory);\n        info.setHandler(m_trapHandler);\n        SnmpTrapSession m_trapSession = new SnmpTrapSession(m_trapHandler, snmpTrapPort);\n        info.setSession(m_trapSession);\n        \n        s_registrations.put(listener, info);\n    }","commit_id":"83ebdca15f2fc68d0885bce0100b61f72b4d311c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void unregisterForTraps(TrapNotificationListener listener, int snmpTrapPort) {\n        RegistrationInfo info = (RegistrationInfo)JoeSnmpStrategy.m_registrations.remove(listener);\n        info.getSession().close();\n    }","id":71585,"modified_method":"public void unregisterForTraps(TrapNotificationListener listener, int snmpTrapPort) {\n        RegistrationInfo info = s_registrations.remove(listener);\n        info.getSession().close();\n    }","commit_id":"83ebdca15f2fc68d0885bce0100b61f72b4d311c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduRequest pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator it = m_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = (RegistrationInfo) it.next();\n            if (destPort == info.getPort())\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n        }\n    }","id":71586,"modified_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduRequest pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator<RegistrationInfo> it = s_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = it.next();\n            if (destPort == info.getPort()) {\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n            }\n        }\n    }","commit_id":"83ebdca15f2fc68d0885bce0100b61f72b4d311c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"private synchronized static SnmpTrapSession getTrapSession() throws SocketException {\n        if (sm_trapSession == null) {\n            sm_trapSession = new SnmpTrapSession(null, -1);\n        }\n        return sm_trapSession;\n    }","id":71587,"modified_method":"private synchronized static SnmpTrapSession getTrapSession() throws SocketException {\n        if (s_trapSession == null) {\n            s_trapSession = new SnmpTrapSession(null, -1);\n        }\n        return s_trapSession;\n    }","commit_id":"83ebdca15f2fc68d0885bce0100b61f72b4d311c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduTrap pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator it = m_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = (RegistrationInfo) it.next();\n            if (destPort == info.getPort())\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n        }\n    }","id":71588,"modified_method":"public static void sendTest(String destAddr, int destPort, String community, SnmpPduTrap pdu) throws UnknownHostException {\n        InetAddress agentAddress = InetAddress.getByName(destAddr);\n        for (Iterator<RegistrationInfo> it = s_registrations.values().iterator(); it.hasNext();) {\n            RegistrationInfo info = it.next();\n            if (destPort == info.getPort()) {\n                info.getHandler().snmpReceivedTrap(info.getSession(), agentAddress, destPort, new SnmpOctetString(community.getBytes()), pdu);\n            }\n        }\n    }","commit_id":"83ebdca15f2fc68d0885bce0100b61f72b4d311c","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected Option[] baseConfiguration() {\n        return new Option[]{\n            karafDistributionConfiguration()\n                .frameworkUrl(maven().groupId(karafGroupId()).artifactId(karafArtifactId()).version(karafVersion()).type(\"tar.gz\"))\n                .karafVersion(karafVersion())\n                .useDeployFolder(false)\n                .name(karafName())\n                .unpackDirectory(new File(\"target/paxexam/\")),\n            keepRuntimeFolder(),\n            logLevel(LogLevelOption.LogLevel.INFO),\n            editConfigurationFileExtend(\"etc/org.apache.karaf.features.cfg\", \"featuresRepositories\", \",mvn:org.apache.sling/org.apache.sling.launchpad.karaf-features/0.1.1-SNAPSHOT/xml/features\"),\n            mavenBundle()\n                .groupId(\"org.ops4j.pax.tinybundles\")\n                .artifactId(\"tinybundles\")\n                .version(\"2.0.0\"),\n            karafTestSupportBundle()\n        };\n    }","id":71589,"modified_method":"protected Option[] baseConfiguration() {\n        return options(\n            karafDistributionConfiguration()\n                .frameworkUrl(maven().groupId(karafGroupId()).artifactId(karafArtifactId()).version(karafVersion()).type(\"tar.gz\"))\n                .karafVersion(karafVersion())\n                .useDeployFolder(false)\n                .name(karafName())\n                .unpackDirectory(new File(\"target/paxexam/\")),\n            keepRuntimeFolder(),\n            logLevel(LogLevelOption.LogLevel.INFO),\n            editConfigurationFileExtend(\"etc/org.apache.karaf.features.cfg\", \"featuresRepositories\", \",\" + featureRepository()),\n            editConfigurationFilePut(\"etc/org.apache.karaf.management.cfg\", \"rmiRegistryPort\", Integer.toString(rmiRegistryPort())),\n            editConfigurationFilePut(\"etc/org.apache.karaf.management.cfg\", \"rmiServerPort\", Integer.toString(rmiServerPort())),\n            editConfigurationFilePut(\"etc/org.apache.karaf.shell.cfg\", \"sshPort\", Integer.toString(sshPort())),\n            editConfigurationFilePut(\"etc/org.ops4j.pax.web.cfg\", \"org.osgi.service.http.port\", Integer.toString(httpPort())),\n            mavenBundle()\n                .groupId(\"org.ops4j.pax.tinybundles\")\n                .artifactId(\"tinybundles\")\n                .version(\"2.0.0\"),\n            karafTestSupportBundle()\n        );\n    }","commit_id":"7b1da9f1d7c52730bf5a091b0ec4d847aaa3668b","url":"https://github.com/apache/sling"},{"original_method":"@Test\n    public void testCxfNmr() throws Exception {\n        installAndCheckFeature(\"examples-cxf-nmr\");\n        unInstallAndCheckFeature(\"examples-cxf-nmr\");\n    }","id":71590,"modified_method":"@Test\n    public void testCbr() throws Exception {\n        installQuickstartBundle(\"cbr\");\n    }","commit_id":"f00a0a1b3f3b9d2ca6b899c8c364bf4e3538ba22","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return new Option[]{\n                esbDistributionConfiguration(), keepRuntimeFolder(),\n                editConfigurationFilePut(\"system.properties\", \"esb.version\", MavenUtils.asInProject().getVersion(GROUP_ID, ARTIFACT_ID)),\n                logLevel(LogLevelOption.LogLevel.INFO)};\n    }","id":71591,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[] {\n                karafDistributionConfiguration().frameworkUrl(maven().groupId(\"org.jboss.fuse\").artifactId(\"jboss-fuse-full\").versionAsInProject().type(\"zip\"))\n                        .karafVersion(MavenUtils.getArtifactVersion(\"org.jboss.fuse\", \"jboss-fuse-full\")).name(\"JBoss Fuse\").unpackDirectory(new File(\"target/exam\")), \n                        useOwnExamBundlesStartLevel(50),\n                        editConfigurationFilePut(\"etc/config.properties\", \"karaf.startlevel.bundle\", \"50\"),\n                        editConfigurationFilePut(\"etc/config.properties\", \"karaf.startup.message\", \"Loading Fuse from: ${karaf.home}\"),\n                        editConfigurationFilePut(\"etc/users.properties\", \"admin\", \"admin,admin\"),\n                        mavenBundle(\"org.fusesource.tooling.testing\", \"pax-exam-karaf\", MavenUtils.getArtifactVersion(\"org.fusesource.tooling.testing\", \"pax-exam-karaf\")),                      \n                        keepRuntimeFolder(),\n                        logLevel(LogLevelOption.LogLevel.ERROR) };\n    }","commit_id":"f00a0a1b3f3b9d2ca6b899c8c364bf4e3538ba22","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixCxfBc() throws Exception {\n        installAndCheckFeature(\"servicemix-cxf-bc\");\n        unInstallAndCheckFeature(\"servicemix-cxf-bc\");\n    }","id":71592,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixCxfBc() throws Exception {\n        installUninstallCommand(\"servicemix-cxf-bc\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testJpaHibernate() throws Exception {\n        installAndCheckFeature(\"jpa-hibernate\");\n        unInstallAndCheckFeature(\"jpa-hibernate\");\n    }","id":71593,"modified_method":"@Test\n    @Ignore\n    public void testJpaHibernate() throws Exception {\n        installUninstallCommand(\"jpa-hibernate\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixEip() throws Exception {\n        installAndCheckFeature(\"servicemix-eip\");\n        unInstallAndCheckFeature(\"servicemix-eip\");\n    }","id":71594,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixEip() throws Exception {\n        installUninstallCommand(\"servicemix-eip\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixSaxon() throws Exception {\n        installAndCheckFeature(\"servicemix-saxon\");\n        unInstallAndCheckFeature(\"servicemix-saxon\");\n    }","id":71595,"modified_method":"@Test\n    @Ignore\n    public void testServicemixSaxon() throws Exception {\n        installUninstallCommand(\"servicemix-saxon\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixJms() throws Exception {\n        installAndCheckFeature(\"servicemix-jms\");\n        unInstallAndCheckFeature(\"servicemix-jms\");\n    }","id":71596,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixJms() throws Exception {\n        installUninstallCommand(\"servicemix-jms\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testSaaj() throws Exception {\n        installAndCheckFeature(\"saaj\");\n        unInstallAndCheckFeature(\"saaj\");\n    }","id":71597,"modified_method":"@Test\n    public void testSaaj() throws Exception {\n        installUninstallCommand(\"saaj\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixValidation() throws Exception {\n        installAndCheckFeature(\"servicemix-validation\");\n        unInstallAndCheckFeature(\"servicemix-validation\");\n    }","id":71598,"modified_method":"@Test\n    @Ignore\n    public void testServicemixValidation() throws Exception {\n        installUninstallCommand(\"servicemix-validation\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixWsn2005() throws Exception {\n        installAndCheckFeature(\"mq-fabric\");\n        installAndCheckFeature(\"servicemix-wsn2005\");\n        unInstallAndCheckFeature(\"servicemix-wsn2005\");\n    }","id":71599,"modified_method":"@Test\n    @Ignore\n    public void testServicemixWsn2005() throws Exception {        \n        installUninstallCommand(\"servicemix-wsn2005\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixCxfSe() throws Exception {\n        installAndCheckFeature(\"servicemix-cxf-se\");\n        unInstallAndCheckFeature(\"servicemix-cxf-se\");\n    }","id":71600,"modified_method":"@Test\n    @Ignore\n    public void testServicemixCxfSe() throws Exception {\n        installUninstallCommand(\"servicemix-cxf-se\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testConnector() throws Exception {\n        installAndCheckFeature(\"connector\");\n        unInstallAndCheckFeature(\"connector\");\n    }","id":71601,"modified_method":"@Test\n    @Ignore\n    public void testConnector() throws Exception {\n        installUninstallCommand(\"connector\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixSmpp() throws Exception {\n        installAndCheckFeature(\"servicemix-smpp\");\n        unInstallAndCheckFeature(\"servicemix-smpp\");\n    }","id":71602,"modified_method":"@Test\n    @Ignore\n    public void testServicemixSmpp() throws Exception {\n        installUninstallCommand(\"servicemix-smpp\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testCamelNmr() throws Exception {\n        installAndCheckFeature(\"camel-nmr\");\n        unInstallAndCheckFeature(\"camel-nmr\");\n    }","id":71603,"modified_method":"@Test\n    public void testCamelNmr() throws Exception {\n        installUninstallCommand(\"camel-nmr\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixScripting() throws Exception {\n        installAndCheckFeature(\"servicemix-scripting\");\n        unInstallAndCheckFeature(\"servicemix-scripting\");\n    }","id":71604,"modified_method":"@Test\n    @Ignore\n    public void testServicemixScripting() throws Exception {\n        installUninstallCommand(\"servicemix-scripting\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixShared() throws Exception {\n        installAndCheckFeature(\"servicemix-shared\");\n        unInstallAndCheckFeature(\"servicemix-shared\");\n    }","id":71605,"modified_method":"@Test\n    @Ignore\n    public void testServicemixShared() throws Exception {\n        installUninstallCommand(\"servicemix-shared\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixFile() throws Exception {\n        installAndCheckFeature(\"servicemix-file\");\n        unInstallAndCheckFeature(\"servicemix-file\");\n    }","id":71606,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixFile() throws Exception {\n        installUninstallCommand(\"servicemix-file\");        \n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixQuartz() throws Exception {\n        installAndCheckFeature(\"servicemix-quartz\");\n        unInstallAndCheckFeature(\"servicemix-quartz\");\n    }","id":71607,"modified_method":"@Test\n    @Ignore\n    public void testServicemixQuartz() throws Exception {\n        installUninstallCommand(\"servicemix-quartz\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixSnmp() throws Exception {\n        installAndCheckFeature(\"servicemix-snmp\");\n        unInstallAndCheckFeature(\"servicemix-snmp\");\n    }","id":71608,"modified_method":"@Test\n    @Ignore\n    public void testServicemixSnmp() throws Exception {\n        installUninstallCommand(\"servicemix-snmp\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixVfs() throws Exception {\n        installAndCheckFeature(\"servicemix-vfs\");\n        unInstallAndCheckFeature(\"servicemix-vfs\");\n    }","id":71609,"modified_method":"@Test\n    @Ignore\n    public void testServicemixVfs() throws Exception {\n        installUninstallCommand(\"servicemix-vfs\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixDrools() throws Exception {\n        installAndCheckFeature(\"servicemix-drools\");\n        unInstallAndCheckFeature(\"servicemix-drools\");\n    }","id":71610,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixDrools() throws Exception {\n        installUninstallCommand(\"servicemix-drools\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixFtp() throws Exception {\n        installAndCheckFeature(\"servicemix-ftp\");\n        unInstallAndCheckFeature(\"servicemix-ftp\");\n    }","id":71611,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixFtp() throws Exception {\n        installUninstallCommand(\"servicemix-ftp\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testCxfNmr() throws Exception {\n        installAndCheckFeature(\"cxf-nmr\");\n        unInstallAndCheckFeature(\"cxf-nmr\");\n    }","id":71612,"modified_method":"@Test\n    public void testCxfNmr() throws Exception {\n        installUninstallCommand(\"cxf-nmr\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixHttp() throws Exception {\n        installAndCheckFeature(\"servicemix-http\");\n        unInstallAndCheckFeature(\"servicemix-http\");\n    }","id":71613,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixHttp() throws Exception {\n        installUninstallCommand(\"servicemix-http\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixOsWorkflow() throws Exception {\n        installAndCheckFeature(\"servicemix-osworkflow\");\n        unInstallAndCheckFeature(\"servicemix-osworkflow\");\n    }","id":71614,"modified_method":"@Test\n    @Ignore\n    public void testServicemixOsWorkflow() throws Exception {\n        installUninstallCommand(\"servicemix-osworkflow\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Configuration\n    public Option[] config() {\n        return new Option[]{\n                esbDistributionConfiguration(), keepRuntimeFolder(),\n                editConfigurationFilePut(\"system.properties\", \"esb.version\", MavenUtils.asInProject().getVersion(GROUP_ID, ARTIFACT_ID)),\n                logLevel(LogLevelOption.LogLevel.INFO)};\n    }","id":71615,"modified_method":"@Configuration\n    public Option[] config() {\n        return new Option[] {\n                karafDistributionConfiguration().frameworkUrl(maven().groupId(\"org.jboss.fuse\").artifactId(\"jboss-fuse-full\").versionAsInProject().type(\"zip\"))\n                        .karafVersion(MavenUtils.getArtifactVersion(\"org.jboss.fuse\", \"jboss-fuse-full\")).name(\"JBoss Fuse\").unpackDirectory(new File(\"target/exam\")), \n                        useOwnExamBundlesStartLevel(50),\n                        editConfigurationFilePut(\"etc/config.properties\", \"karaf.startlevel.bundle\", \"50\"),\n                        editConfigurationFilePut(\"etc/config.properties\", \"karaf.startup.message\", \"Loading Fuse from: ${karaf.home}\"),\n                        editConfigurationFilePut(\"etc/users.properties\", \"admin\", \"admin,admin\"),\n                        mavenBundle(\"org.fusesource.tooling.testing\", \"pax-exam-karaf\", MavenUtils.getArtifactVersion(\"org.fusesource.tooling.testing\", \"pax-exam-karaf\")),                      \n                        keepRuntimeFolder(),\n                        logLevel(LogLevelOption.LogLevel.ERROR) };\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"@Test\n    public void testServicemixMail() throws Exception {\n        installAndCheckFeature(\"servicemix-mail\");\n        unInstallAndCheckFeature(\"servicemix-mail\");\n    }","id":71616,"modified_method":"@Test\n    @Ignore    \n    public void testServicemixMail() throws Exception {\n        installUninstallCommand(\"servicemix-mail\");\n    }","commit_id":"6ad34617d4d094e7fda6070bf6af3033bc9d6c23","url":"https://github.com/fabric8io/fabric8"},{"original_method":"protected void appendImmutableCollectionExpression(XCollectionLiteral literal,\n\t\t\tITreeAppendable b, String collectionsMethod, Class<?> guavaHelper, String guavaHelperMethod) {\n\t\tLightweightTypeReference collectionElementType = getCollectionElementType(literal);\n\t\tITypeReferenceOwner owner = collectionElementType.getOwner();\n\t\tJvmType collectionsClass = findKnownTopLevelType(Collections.class, literal);\n\t\tJvmType guavaHelperType = findKnownTopLevelType(guavaHelper, literal);\n\t\tLightweightTypeReference guavaClass = guavaHelperType == null ? owner.newUnknownTypeReference(guavaHelper.getName()) : owner.newParameterizedTypeReference(guavaHelperType);\n\t\tif (collectionsClass != null) {\n\t\t\tb.append(collectionsClass);\n\t\t} else {\n\t\t\tb.append(Collections.class.getSimpleName());\n\t\t}\n\t\tb.append(\".<\").append(collectionElementType).append(\">\").append(collectionsMethod).append(\"(\")\n\t\t\t.append(guavaClass).append(\".<\").append(collectionElementType).append(\">\").append(guavaHelperMethod).append(\"(\");\n\t\tboolean isFirst = true;\n\t\tfor(XExpression element: literal.getElements())  {\n\t\t\tif(!isFirst)\n\t\t\t\tb.append(\", \");\n\t\t\tisFirst = false;\n\t\t\tif(element instanceof XNullLiteral) {\n\t\t\t\tb.append(\"(\").append(collectionElementType).append(\")\");\n\t\t\t}\n\t\t\tinternalToJavaExpression(element, b);\n\t\t}\n\t\tb.append(\"))\");\n\t\treturn;\n\t}","id":71617,"modified_method":"protected void appendImmutableCollectionExpression(XCollectionLiteral literal,\n\t\t\tITreeAppendable b, String collectionsMethod, Class<?> guavaHelper, String guavaHelperMethod) {\n\t\tLightweightTypeReference collectionElementType = getCollectionElementType(literal);\n\t\tb.append(Collections.class);\n\t\tb.append(\".<\").append(collectionElementType).append(\">\").append(collectionsMethod).append(\"(\");\n\t\tb.append(guavaHelper).append(\".<\").append(collectionElementType).append(\">\").append(guavaHelperMethod).append(\"(\");\n\t\tboolean isFirst = true;\n\t\tfor(XExpression element: literal.getElements())  {\n\t\t\tif(!isFirst)\n\t\t\t\tb.append(\", \");\n\t\t\tisFirst = false;\n\t\t\tif(element instanceof XNullLiteral) {\n\t\t\t\tb.append(\"(\").append(collectionElementType).append(\")\");\n\t\t\t}\n\t\t\tinternalToJavaExpression(element, b);\n\t\t}\n\t\tb.append(\"))\");\n\t\treturn;\n\t}","commit_id":"8f96324b3ee9cef8537f1a92f4be8c0433157117","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _toJavaExpression(XSetLiteral literal, ITreeAppendable b) {\n\t\tLightweightTypeReference literalType = batchTypeResolver.resolveTypes(literal).getActualType(literal);\n\t\tif (literalType == null) {\n\t\t\tb.append(\"error - couldn't compute type for literal : \"+literal);\n\t\t\treturn;\n\t\t} \n\t\tif (literalType.isType(Map.class)) {\n\t\t\tLightweightTypeReference keyType = literalType.getTypeArguments().get(0);\n\t\t\tLightweightTypeReference valueType = literalType.getTypeArguments().get(1);\n\t\t\tJvmType literalsClass = findKnownTopLevelType(CollectionLiterals.class, literal);\n\t\t\tJvmType collectionsClass = findKnownTopLevelType(Collections.class, literal);\n\t\t\tb.append(collectionsClass)\n\t\t\t\t.append(\".<\").append(keyType).append(\", \").append(valueType)\n\t\t\t\t.append(\">unmodifiableMap(\");\n\t\t\tb.append(literalsClass).append(\".<\").append(keyType).append(\", \").append(valueType).append(\">newHashMap(\");\n\t\t\tIterator<XExpression> elements = literal.getElements().iterator();\n\t\t\twhile(elements.hasNext())  {\n\t\t\t\tXExpression element = elements.next();\n\t\t\t\tinternalToJavaExpression(element, b);\n\t\t\t\tif (elements.hasNext()) {\n\t\t\t\t\tb.append(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.append(\"))\");\n\t\t} else {\n\t\t\tappendImmutableCollectionExpression(literal, b, \"unmodifiableSet\", CollectionLiterals.class, \"newHashSet\");\n\t\t}\n\t}","id":71618,"modified_method":"protected void _toJavaExpression(XSetLiteral literal, ITreeAppendable b) {\n\t\tLightweightTypeReference literalType = batchTypeResolver.resolveTypes(literal).getActualType(literal);\n\t\tif (literalType == null) {\n\t\t\tb.append(\"error - couldn't compute type for literal : \"+literal);\n\t\t\treturn;\n\t\t} \n\t\tif (literalType.isType(Map.class)) {\n\t\t\tLightweightTypeReference keyType = literalType.getTypeArguments().get(0);\n\t\t\tLightweightTypeReference valueType = literalType.getTypeArguments().get(1);\n\t\t\tb.append(Collections.class)\n\t\t\t\t.append(\".<\").append(keyType).append(\", \").append(valueType)\n\t\t\t\t.append(\">unmodifiableMap(\");\n\t\t\tb.append(CollectionLiterals.class).append(\".<\").append(keyType).append(\", \").append(valueType).append(\">newHashMap(\");\n\t\t\tIterator<XExpression> elements = literal.getElements().iterator();\n\t\t\twhile(elements.hasNext())  {\n\t\t\t\tXExpression element = elements.next();\n\t\t\t\tinternalToJavaExpression(element, b);\n\t\t\t\tif (elements.hasNext()) {\n\t\t\t\t\tb.append(\", \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tb.append(\"))\");\n\t\t} else {\n\t\t\tappendImmutableCollectionExpression(literal, b, \"unmodifiableSet\", CollectionLiterals.class, \"newHashSet\");\n\t\t}\n\t}","commit_id":"8f96324b3ee9cef8537f1a92f4be8c0433157117","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * THIS METHOD IS NOT PART OF THE WICKET API. DO NOT ATTEMPT TO OVERRIDE OR CALL IT.\n\t * \n\t * Handles form submissions.\n\t * \n\t * @param submitter\n\t *            listener that will receive form processing events, if {@code null} the form will\n\t *            attempt to locate one\n\t * \n\t * @see Form#validate()\n\t */\n\tpublic final void onFormSubmitted(IFormSubmitter submitter)\n\t{\n\t\tmarkFormsSubmitted();\n\n\t\tif (handleMultiPart())\n\t\t{\n\t\t\t// Tells FormComponents that a new user input has come\n\t\t\tinputChanged();\n\n\t\t\tString url = getRequest().getRequestParameters()\n\t\t\t\t.getParameterValue(getHiddenFieldId())\n\t\t\t\t.toString();\n\t\t\tif (!Strings.isEmpty(url))\n\t\t\t{\n\t\t\t\tdispatchEvent(getPage(), url);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// First, see if the processing was triggered by a Wicket IFormSubmittingComponent\n\t\t\t\tif (submitter == null)\n\t\t\t\t{\n\t\t\t\t\tsubmitter = findSubmittingButton();\n\n\t\t\t\t\tif (submitter instanceof IFormSubmittingComponent)\n\t\t\t\t\t{\n\t\t\t\t\t\tIFormSubmittingComponent submittingComponent = (IFormSubmittingComponent)submitter;\n\t\t\t\t\t\tComponent component = (Component)submitter;\n\n\t\t\t\t\t\tif (!component.isVisibleInHierarchy())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new WicketRuntimeException(\"Submit Button \" +\n\t\t\t\t\t\t\t\tsubmittingComponent.getInputName() + \" (path=\" +\n\t\t\t\t\t\t\t\tcomponent.getPageRelativePath() + \") is not visible\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!component.isEnabledInHierarchy())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthrow new WicketRuntimeException(\"Submit Button \" +\n\t\t\t\t\t\t\t\tsubmittingComponent.getInputName() + \" (path=\" +\n\t\t\t\t\t\t\t\tcomponent.getPageRelativePath() + \") is not enabled\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// When processing was triggered by a Wicket IFormSubmittingComponent and that\n\t\t\t\t// component indicates it wants to be called immediately\n\t\t\t\t// (without processing), call the IFormSubmittingComponent.onSubmit* methods right\n\t\t\t\t// away.\n\t\t\t\tif (submitter != null && !submitter.getDefaultFormProcessing())\n\t\t\t\t{\n\t\t\t\t\tsubmitter.onSubmit();\n\t\t\t\t\tsubmitter.onAfterSubmit();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// the submit request might be for one of the nested forms, so let's\n\t\t\t\t\t// find the right one:\n\t\t\t\t\tfinal Form<?> formToProcess = findFormToProcess(submitter);\n\n\t\t\t\t\t// process the form for this request\n\t\t\t\t\tformToProcess.process(submitter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If multi part did fail check if an error is registered and call\n\t\t// onError\n\t\telse if (hasError())\n\t\t{\n\t\t\tcallOnError(submitter);\n\t\t}\n\n\t\t// update auto labels if we are inside an ajax request\n\t\tgetRequestCycle().find(AjaxRequestTarget.class).ifPresent(target -> {\n\t\t\tvisitChildren(FormComponent.class, new IVisitor<FormComponent<?>, Void>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void component(FormComponent<?> component, IVisit<Void> visit)\n\t\t\t\t{\n\t\t\t\t\tcomponent.updateAutoLabels(target);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}","id":71619,"modified_method":"/**\n\t * THIS METHOD IS NOT PART OF THE WICKET API. DO NOT ATTEMPT TO OVERRIDE OR CALL IT.\n\t * \n\t * Handles form submissions.\n\t * \n\t * @param submitter\n\t *            listener that will receive form processing events, if {@code null} the form will\n\t *            attempt to locate one\n\t * \n\t * @see Form#validate()\n\t */\n\tpublic final void onFormSubmitted(final IFormSubmitter submitter)\n\t{\n\t\tfinal IFormSubmitter actualSubmitter =  submitter != null ? submitter :\n\t\t\tfindActualSubmitter();\n\t\t//find the actual form to process\n\t\tfinal Form<?> formToProcess = findFormToProcess(actualSubmitter);\n\t\t\n\t\tformToProcess.markFormsSubmitted();\n\t\t\n\t\tif (handleMultiPart())\n\t\t{\n\t\t\t// Tells FormComponents that a new user input has come\n\t\t\tformToProcess.inputChanged();\n\n\t\t\tString url = getRequest().getRequestParameters()\n\t\t\t\t.getParameterValue(getHiddenFieldId())\n\t\t\t\t.toString();\n\t\t\tif (!Strings.isEmpty(url))\n\t\t\t{\n\t\t\t\tdispatchEvent(getPage(), url);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// When processing was triggered by a Wicket IFormSubmittingComponent and that\n\t\t\t\t// component indicates it wants to be called immediately\n\t\t\t\t// (without processing), call the IFormSubmittingComponent.onSubmit* methods right\n\t\t\t\t// away.\n\t\t\t\tif (actualSubmitter != null && !actualSubmitter.getDefaultFormProcessing())\n\t\t\t\t{\n\t\t\t\t\tactualSubmitter.onSubmit();\n\t\t\t\t\tactualSubmitter.onAfterSubmit();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// process the form for this request\n\t\t\t\t\tformToProcess.process(actualSubmitter);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// If multi part did fail check if an error is registered and call\n\t\t// onError\n\t\telse if (hasError())\n\t\t{\n\t\t\tcallOnError(actualSubmitter);\n\t\t}\n\n\t\t// update auto labels if we are inside an ajax request\n\t\tgetRequestCycle().find(AjaxRequestTarget.class).ifPresent(target -> {\n\t\t\tvisitChildren(FormComponent.class, new IVisitor<FormComponent<?>, Void>()\n\t\t\t{\n\t\t\t\t@Override\n\t\t\t\tpublic void component(FormComponent<?> component, IVisit<Void> visit)\n\t\t\t\t{\n\t\t\t\t\tcomponent.updateAutoLabels(target);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}","commit_id":"ece7575f5ea74ec27f88618fd287e4348aa9cc35","url":"https://github.com/apache/wicket"},{"original_method":"public static boolean isAcceptable(@Nullable final PsiMethodReferenceExpression methodReferenceExpression, PsiType left) {\n    if (methodReferenceExpression == null) return false;\n    Map<PsiMethodReferenceExpression, PsiType> map = ourRefs.get();\n    if (map == null) {\n      map = new HashMap<PsiMethodReferenceExpression, PsiType>();\n      ourRefs.set(map);\n    }\n\n    final JavaResolveResult result;\n    try {\n      if (map.put(methodReferenceExpression, left) != null) return false;\n      result = methodReferenceExpression.advancedResolve(false);\n    }\n    finally {\n      map.remove(methodReferenceExpression);\n    }\n\n    final PsiElement resolve = result.getElement();\n    if (resolve instanceof PsiMethod) {\n      final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(left);\n      final PsiMethod method = getFunctionalInterfaceMethod(resolveResult);\n      if (method != null) {\n        final Ref<PsiClass> classRef = new Ref<PsiClass>();\n        final Ref<PsiSubstitutor> substRef = new Ref<PsiSubstitutor>();\n        methodReferenceExpression.process(classRef, substRef);\n\n        final MethodSignature signature1 = method.getSignature(resolveResult.getSubstitutor());\n        PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n        subst = subst.putAll(substRef.get());\n        subst = subst.putAll(result.getSubstitutor());\n        final MethodSignature signature2 = ((PsiMethod)resolve).getSignature(subst);\n        \n        final PsiType interfaceReturnType = getFunctionalInterfaceReturnType(left);\n        final PsiType methodReturnType = subst.substitute(((PsiMethod)resolve).getReturnType());\n        if (interfaceReturnType != null && methodReturnType != null && interfaceReturnType != PsiType.VOID && \n            !TypeConversionUtil.isAssignable(interfaceReturnType, methodReturnType)) return false;\n        if (areAcceptable(signature1, signature2, classRef.get(), substRef.get(), ((PsiMethod)resolve).isVarArgs())) return true;\n      }\n    }\n    return false;\n  }","id":71620,"modified_method":"public static boolean isAcceptable(@Nullable final PsiMethodReferenceExpression methodReferenceExpression, PsiType left) {\n    if (methodReferenceExpression == null) return false;\n    Map<PsiMethodReferenceExpression, PsiType> map = ourRefs.get();\n    if (map == null) {\n      map = new HashMap<PsiMethodReferenceExpression, PsiType>();\n      ourRefs.set(map);\n    }\n\n    final JavaResolveResult result;\n    try {\n      if (map.put(methodReferenceExpression, left) != null) return false;\n      result = methodReferenceExpression.advancedResolve(false);\n    }\n    finally {\n      map.remove(methodReferenceExpression);\n    }\n\n    final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(left);\n    final PsiMethod method = getFunctionalInterfaceMethod(resolveResult);\n    if (method != null) {\n      final Ref<PsiClass> classRef = new Ref<PsiClass>();\n      final Ref<PsiSubstitutor> substRef = new Ref<PsiSubstitutor>();\n      methodReferenceExpression.process(classRef, substRef);\n      final PsiElement resolve = result.getElement();\n      if (resolve instanceof PsiMethod) {\n        final MethodSignature signature1 = method.getSignature(resolveResult.getSubstitutor());\n        PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n        subst = subst.putAll(substRef.get());\n        subst = subst.putAll(result.getSubstitutor());\n        final MethodSignature signature2 = ((PsiMethod)resolve).getSignature(subst);\n\n        final PsiType interfaceReturnType = getFunctionalInterfaceReturnType(left);\n        final PsiType methodReturnType = subst.substitute(((PsiMethod)resolve).getReturnType());\n        if (interfaceReturnType != null && methodReturnType != null && interfaceReturnType != PsiType.VOID && \n            !TypeConversionUtil.isAssignable(interfaceReturnType, methodReturnType)) return false;\n        if (areAcceptable(signature1, signature2, classRef.get(), substRef.get(), ((PsiMethod)resolve).isVarArgs())) return true;\n      } else if (resolve instanceof PsiClass) {\n        final PsiType interfaceReturnType = getFunctionalInterfaceReturnType(left);\n        if (interfaceReturnType != null) {\n          final PsiClassType classType = JavaPsiFacade.getElementFactory(methodReferenceExpression.getProject()).createType((PsiClass)resolve, result.getSubstitutor());\n          if (TypeConversionUtil.isAssignable(interfaceReturnType, classType)) {\n            final PsiParameter[] parameters = method.getParameterList().getParameters();\n            if (parameters.length == 0) return true;\n            if (parameters.length == 1) {\n              if (isReceiverType(resolveResult.getSubstitutor().substitute(parameters[0].getType()), classRef.get(), substRef.get())) return true;\n            }\n          }\n        }\n      }\n    }\n    return false;\n  }","commit_id":"4eeaeb4f2fc5d054879ceb4fe087b3ded8520987","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n      @Override\n      public CandidateInfo resolveConflict(List<CandidateInfo> conflicts) {\n        if (mySignature == null) return null;\n\n        boolean hasReceiver = false;\n        final PsiType[] parameterTypes = mySignature.getParameterTypes();\n        if (parameterTypes.length > 0) {\n          final PsiClassType.ClassResolveResult classResolveResult = PsiUtil.resolveGenericsClassInType(parameterTypes[0]);\n          if (LambdaUtil.isReceiverType(parameterTypes[0], myContainingClass, mySubstitutor)) {\n            hasReceiver = true;\n          }\n        }\n\n        final List<CandidateInfo> firstCandidates = new ArrayList<CandidateInfo>();\n        final List<CandidateInfo> secondCandidates = new ArrayList<CandidateInfo>();\n        for (CandidateInfo conflict : conflicts) {\n          if (!(conflict instanceof MethodCandidateInfo)) continue;\n          final PsiMethod psiMethod = ((MethodCandidateInfo)conflict).getElement();\n          if (psiMethod == null) continue;\n          PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n          subst = subst.putAll(mySubstitutor);\n          subst = subst.putAll(conflict.getSubstitutor());\n          final PsiType[] signatureParameterTypes2 = psiMethod.getSignature(subst).getParameterTypes();\n\n          final boolean varArgs = psiMethod.isVarArgs();\n          final boolean validConstructorRef = psiMethod.isConstructor() && (myContainingClass.getContainingClass() == null || myContainingClass.hasModifierProperty(PsiModifier.STATIC));\n          final boolean staticOrValidConstructorRef = psiMethod.hasModifierProperty(PsiModifier.STATIC) || validConstructorRef;\n\n          if ((parameterTypes.length == signatureParameterTypes2.length || varArgs && parameterTypes.length >= signatureParameterTypes2.length) && \n              (!myBeginsWithReferenceType || staticOrValidConstructorRef || (psiMethod.isConstructor() && conflict.isStaticsScopeCorrect()))) {\n            boolean correct = true;\n            for (int i = 0; i < parameterTypes.length; i++) {\n              final PsiType type1 = parameterTypes[i];\n              final PsiType type2 = varArgs && i >= signatureParameterTypes2.length - 1 ?\n                                    ((PsiArrayType)signatureParameterTypes2[signatureParameterTypes2.length -1]).getComponentType() :\n                                    signatureParameterTypes2[i];\n              correct &= TypeConversionUtil.isAssignable(type2, subst.substitute(GenericsUtil.eliminateWildcards(type1)));\n            }\n            if (correct) {\n              firstCandidates.add(conflict);\n            }\n          }\n\n          if (hasReceiver && parameterTypes.length == signatureParameterTypes2.length + 1 && !staticOrValidConstructorRef) {\n            boolean correct = true;\n            for (int i = 0; i < signatureParameterTypes2.length; i++) {\n              final PsiType type1 = parameterTypes[i + 1];\n              final PsiType type2 = signatureParameterTypes2[i];\n              correct &= TypeConversionUtil.isAssignable(type2, subst.substitute(GenericsUtil.eliminateWildcards(type1)));\n            }\n            if (correct) {\n              secondCandidates.add(conflict);\n            }\n          }\n        }\n\n        final int acceptedCount = secondCandidates.size() + firstCandidates.size();\n        if (acceptedCount != 1) {\n          if (acceptedCount == 0) {\n            conflicts.clear();\n          }\n          firstCandidates.addAll(secondCandidates);\n          conflicts.retainAll(firstCandidates);\n          return null;\n        }\n        return !firstCandidates.isEmpty() ? firstCandidates.get(0) : secondCandidates.get(0);\n      }","id":71621,"modified_method":"@Nullable\n      @Override\n      public CandidateInfo resolveConflict(List<CandidateInfo> conflicts) {\n        if (mySignature == null) return null;\n\n        boolean hasReceiver = false;\n        final PsiType[] parameterTypes = mySignature.getParameterTypes();\n        if (parameterTypes.length > 0 && LambdaUtil.isReceiverType(parameterTypes[0], myContainingClass, mySubstitutor)) {\n          hasReceiver = true;\n        }\n\n        final List<CandidateInfo> firstCandidates = new ArrayList<CandidateInfo>();\n        final List<CandidateInfo> secondCandidates = new ArrayList<CandidateInfo>();\n        for (CandidateInfo conflict : conflicts) {\n          if (!(conflict instanceof MethodCandidateInfo)) continue;\n          final PsiMethod psiMethod = ((MethodCandidateInfo)conflict).getElement();\n          if (psiMethod == null) continue;\n          PsiSubstitutor subst = PsiSubstitutor.EMPTY;\n          subst = subst.putAll(mySubstitutor);\n          subst = subst.putAll(conflict.getSubstitutor());\n          final PsiType[] signatureParameterTypes2 = psiMethod.getSignature(subst).getParameterTypes();\n\n          final boolean varArgs = psiMethod.isVarArgs();\n          final boolean validConstructorRef = psiMethod.isConstructor() && (myContainingClass.getContainingClass() == null || myContainingClass.hasModifierProperty(PsiModifier.STATIC));\n          final boolean staticOrValidConstructorRef = psiMethod.hasModifierProperty(PsiModifier.STATIC) || validConstructorRef;\n\n          if ((parameterTypes.length == signatureParameterTypes2.length || varArgs && parameterTypes.length >= signatureParameterTypes2.length) && \n              (!myBeginsWithReferenceType || staticOrValidConstructorRef || (psiMethod.isConstructor() && conflict.isStaticsScopeCorrect()))) {\n            boolean correct = true;\n            for (int i = 0; i < parameterTypes.length; i++) {\n              final PsiType type1 = parameterTypes[i];\n              final PsiType type2 = varArgs && i >= signatureParameterTypes2.length - 1 ?\n                                    ((PsiArrayType)signatureParameterTypes2[signatureParameterTypes2.length -1]).getComponentType() :\n                                    signatureParameterTypes2[i];\n              correct &= TypeConversionUtil.isAssignable(type2, subst.substitute(GenericsUtil.eliminateWildcards(type1)));\n            }\n            if (correct) {\n              firstCandidates.add(conflict);\n            }\n          }\n\n          if (hasReceiver && parameterTypes.length == signatureParameterTypes2.length + 1 && !staticOrValidConstructorRef) {\n            boolean correct = true;\n            for (int i = 0; i < signatureParameterTypes2.length; i++) {\n              final PsiType type1 = parameterTypes[i + 1];\n              final PsiType type2 = signatureParameterTypes2[i];\n              correct &= TypeConversionUtil.isAssignable(type2, subst.substitute(GenericsUtil.eliminateWildcards(type1)));\n            }\n            if (correct) {\n              secondCandidates.add(conflict);\n            }\n          }\n        }\n\n        final int acceptedCount = secondCandidates.size() + firstCandidates.size();\n        if (acceptedCount != 1) {\n          if (acceptedCount == 0) {\n            conflicts.clear();\n          }\n          firstCandidates.addAll(secondCandidates);\n          conflicts.retainAll(firstCandidates);\n          return null;\n        }\n        return !firstCandidates.isEmpty() ? firstCandidates.get(0) : secondCandidates.get(0);\n      }","commit_id":"4eeaeb4f2fc5d054879ceb4fe087b3ded8520987","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public ResolveResult[] resolve(@NotNull PsiJavaReference reference, boolean incompleteCode) {\n      final Ref<PsiClass> classRef = new Ref<PsiClass>();\n      final Ref<PsiSubstitutor> substRef = new Ref<PsiSubstitutor>();\n      final boolean beginsWithReferenceType = process(classRef, substRef);\n\n      final PsiClass containingClass = classRef.get();\n      final PsiSubstitutor substitutor = substRef.get();\n\n      if (containingClass != null) {\n        final PsiElement element = getReferenceNameElement();\n        final boolean isConstructor = element instanceof PsiKeyword && PsiKeyword.NEW.equals(element.getText());\n        if (element instanceof PsiIdentifier || isConstructor) {\n          PsiType functionalInterfaceType = null;\n          final Map<PsiMethodReferenceExpression,PsiType> map = LambdaUtil.ourRefs.get();\n          if (map != null) {\n            functionalInterfaceType = map.get(PsiMethodReferenceExpressionImpl.this);\n          }\n          if (functionalInterfaceType == null) {\n            functionalInterfaceType = getFunctionalInterfaceType();\n          }\n          final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n          final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(resolveResult);\n          final MethodSignature signature = interfaceMethod != null ? interfaceMethod.getSignature(resolveResult.getSubstitutor()) : null;\n          final MethodReferenceConflictResolver conflictResolver =\n            new MethodReferenceConflictResolver(containingClass, substitutor, signature, beginsWithReferenceType);\n          final PsiConflictResolver[] resolvers;\n          if (signature != null) {\n            final PsiType[] parameterTypes = signature.getParameterTypes();\n            resolvers = new PsiConflictResolver[]{conflictResolver,\n              new JavaMethodsConflictResolver(PsiMethodReferenceExpressionImpl.this, parameterTypes) {\n                @Override\n                public CandidateInfo resolveConflict(List<CandidateInfo> conflicts) {\n                  boolean varargs = false;\n                  for (CandidateInfo conflict : conflicts) {\n                    final PsiElement psiElement = conflict.getElement();\n                    if (psiElement instanceof PsiMethod && ((PsiMethod)psiElement).isVarArgs()) {\n                      varargs = true;\n                      break;\n                    }\n                  }\n                  checkSpecifics(conflicts, varargs ? MethodCandidateInfo.ApplicabilityLevel.VARARGS : MethodCandidateInfo.ApplicabilityLevel.FIXED_ARITY);\n                  return conflicts.size() == 1 ? conflicts.get(0) : null; \n                }\n              }};\n          }\n          else {\n            resolvers = new PsiConflictResolver[]{conflictResolver};\n          }\n          final MethodCandidatesProcessor processor =\n            new MethodCandidatesProcessor(PsiMethodReferenceExpressionImpl.this, resolvers, new SmartList<CandidateInfo>()) {\n              @Override\n              protected MethodCandidateInfo createCandidateInfo(final PsiMethod method,\n                                                                PsiSubstitutor substitutor,\n                                                                boolean staticProblem,\n                                                                boolean accessible) {\n                final PsiExpressionList argumentList = getArgumentList();\n                return new MethodCandidateInfo(method, substitutor, !accessible, staticProblem, argumentList, myCurrentFileContext,\n                                               argumentList != null ? argumentList.getExpressionTypes() : null, getTypeArguments(),\n                                               getLanguageLevel()) {\n                  @Override\n                  public PsiSubstitutor inferTypeArguments(ParameterTypeInferencePolicy policy) {\n                    if (signature == null) return PsiSubstitutor.EMPTY;\n                    final PsiType[] types = method.getSignature(PsiSubstitutor.EMPTY).getParameterTypes();\n                    final PsiType[] rightTypes = signature.getParameterTypes();\n                    if (types.length < rightTypes.length) {\n                      return PsiUtil.resolveGenericsClassInType(rightTypes[0]).getSubstitutor();\n                    } else if (types.length > rightTypes.length) {\n                      return PsiUtil.resolveGenericsClassInType(types[0]).getSubstitutor();\n                    }\n                    return JavaPsiFacade.getInstance(getProject()).getResolveHelper()\n                      .inferTypeArguments(method.getTypeParameters(), types, rightTypes,\n                                          PsiUtil.getLanguageLevel(PsiMethodReferenceExpressionImpl.this));\n                  }\n                };\n              }\n          };\n          processor.setIsConstructor(isConstructor);\n          processor.setName(isConstructor ? containingClass.getName() : element.getText());\n          final PsiExpression expression = getQualifierExpression();\n          if (expression == null || !(expression.getType() instanceof PsiArrayType)) {\n            processor.setAccessClass(containingClass);\n          }\n\n          if (beginsWithReferenceType) {\n            if (containingClass.getContainingClass() == null || !containingClass.hasModifierProperty(PsiModifier.STATIC)) {\n              PsiClass aClass = null;\n              if (PsiTreeUtil.isAncestor(containingClass, PsiMethodReferenceExpressionImpl.this, false)) {\n                aClass = containingClass;\n              }\n              if (PsiUtil.getEnclosingStaticElement(PsiMethodReferenceExpressionImpl.this, aClass) != null) {\n                processor.handleEvent(JavaScopeProcessorEvent.START_STATIC, null);\n              }\n            }\n          }\n          ResolveState state = ResolveState.initial().put(PsiSubstitutor.KEY, substitutor);\n          containingClass.processDeclarations(processor, state,\n                                              PsiMethodReferenceExpressionImpl.this,\n                                              PsiMethodReferenceExpressionImpl.this);\n          return processor.getResult();\n        }\n      }\n      return JavaResolveResult.EMPTY_ARRAY;\n    }","id":71622,"modified_method":"@NotNull\n    @Override\n    public ResolveResult[] resolve(@NotNull PsiJavaReference reference, boolean incompleteCode) {\n      final Ref<PsiClass> classRef = new Ref<PsiClass>();\n      final Ref<PsiSubstitutor> substRef = new Ref<PsiSubstitutor>();\n      final boolean beginsWithReferenceType = process(classRef, substRef);\n\n      final PsiClass containingClass = classRef.get();\n      final PsiSubstitutor substitutor = substRef.get();\n\n      if (containingClass != null) {\n        final PsiElement element = getReferenceNameElement();\n        final boolean isConstructor = element instanceof PsiKeyword && PsiKeyword.NEW.equals(element.getText());\n        if (element instanceof PsiIdentifier || isConstructor) {\n          PsiType functionalInterfaceType = null;\n          final Map<PsiMethodReferenceExpression,PsiType> map = LambdaUtil.ourRefs.get();\n          if (map != null) {\n            functionalInterfaceType = map.get(PsiMethodReferenceExpressionImpl.this);\n          }\n          if (functionalInterfaceType == null) {\n            functionalInterfaceType = getFunctionalInterfaceType();\n          }\n          final PsiClassType.ClassResolveResult resolveResult = PsiUtil.resolveGenericsClassInType(functionalInterfaceType);\n          final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(resolveResult);\n          final MethodSignature signature = interfaceMethod != null ? interfaceMethod.getSignature(resolveResult.getSubstitutor()) : null;\n          final MethodReferenceConflictResolver conflictResolver =\n            new MethodReferenceConflictResolver(containingClass, substitutor, signature, beginsWithReferenceType);\n          final PsiConflictResolver[] resolvers;\n          if (signature != null) {\n            if (isConstructor && containingClass.getConstructors().length == 0 && !containingClass.isEnum() && !containingClass.hasModifierProperty(PsiModifier.ABSTRACT)) {\n              return new JavaResolveResult[]{new ClassCandidateInfo(containingClass, substitutor)};\n            }\n            final PsiType[] parameterTypes = signature.getParameterTypes();\n            resolvers = new PsiConflictResolver[]{conflictResolver,\n              new JavaMethodsConflictResolver(PsiMethodReferenceExpressionImpl.this, parameterTypes) {\n                @Override\n                public CandidateInfo resolveConflict(List<CandidateInfo> conflicts) {\n                  boolean varargs = false;\n                  for (CandidateInfo conflict : conflicts) {\n                    final PsiElement psiElement = conflict.getElement();\n                    if (psiElement instanceof PsiMethod && ((PsiMethod)psiElement).isVarArgs()) {\n                      varargs = true;\n                      break;\n                    }\n                  }\n                  checkSpecifics(conflicts, varargs ? MethodCandidateInfo.ApplicabilityLevel.VARARGS : MethodCandidateInfo.ApplicabilityLevel.FIXED_ARITY);\n                  return conflicts.size() == 1 ? conflicts.get(0) : null; \n                }\n              }};\n          }\n          else {\n            resolvers = new PsiConflictResolver[]{conflictResolver};\n          }\n          final MethodCandidatesProcessor processor =\n            new MethodCandidatesProcessor(PsiMethodReferenceExpressionImpl.this, resolvers, new SmartList<CandidateInfo>()) {\n              @Override\n              protected MethodCandidateInfo createCandidateInfo(final PsiMethod method,\n                                                                PsiSubstitutor substitutor,\n                                                                boolean staticProblem,\n                                                                boolean accessible) {\n                final PsiExpressionList argumentList = getArgumentList();\n                return new MethodCandidateInfo(method, substitutor, !accessible, staticProblem, argumentList, myCurrentFileContext,\n                                               argumentList != null ? argumentList.getExpressionTypes() : null, getTypeArguments(),\n                                               getLanguageLevel()) {\n                  @Override\n                  public PsiSubstitutor inferTypeArguments(ParameterTypeInferencePolicy policy) {\n                    if (signature == null) return PsiSubstitutor.EMPTY;\n                    final PsiType[] types = method.getSignature(PsiSubstitutor.EMPTY).getParameterTypes();\n                    final PsiType[] rightTypes = signature.getParameterTypes();\n                    if (types.length < rightTypes.length) {\n                      return PsiUtil.resolveGenericsClassInType(rightTypes[0]).getSubstitutor();\n                    } else if (types.length > rightTypes.length) {\n                      return PsiUtil.resolveGenericsClassInType(types[0]).getSubstitutor();\n                    }\n                    return JavaPsiFacade.getInstance(getProject()).getResolveHelper()\n                      .inferTypeArguments(method.getTypeParameters(), types, rightTypes,\n                                          PsiUtil.getLanguageLevel(PsiMethodReferenceExpressionImpl.this));\n                  }\n                };\n              }\n          };\n          processor.setIsConstructor(isConstructor);\n          processor.setName(isConstructor ? containingClass.getName() : element.getText());\n          final PsiExpression expression = getQualifierExpression();\n          if (expression == null || !(expression.getType() instanceof PsiArrayType)) {\n            processor.setAccessClass(containingClass);\n          }\n\n          if (beginsWithReferenceType) {\n            final PsiClass gContainingClass = containingClass.getContainingClass();\n            if (gContainingClass == null || !containingClass.hasModifierProperty(PsiModifier.STATIC)) {\n              PsiClass aClass = null;\n              if (PsiTreeUtil.isAncestor(gContainingClass != null ? gContainingClass : containingClass, PsiMethodReferenceExpressionImpl.this, false)) {\n                aClass = gContainingClass != null ? gContainingClass : containingClass;\n              }\n              if (PsiUtil.getEnclosingStaticElement(PsiMethodReferenceExpressionImpl.this, aClass) != null) {\n                processor.handleEvent(JavaScopeProcessorEvent.START_STATIC, null);\n              }\n            }\n          }\n          ResolveState state = ResolveState.initial().put(PsiSubstitutor.KEY, substitutor);\n          containingClass.processDeclarations(processor, state,\n                                              PsiMethodReferenceExpressionImpl.this,\n                                              PsiMethodReferenceExpressionImpl.this);\n          return processor.getResult();\n        }\n      }\n      return JavaResolveResult.EMPTY_ARRAY;\n    }","commit_id":"4eeaeb4f2fc5d054879ceb4fe087b3ded8520987","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks if an HTTP request matches this function and its constraints.\n   * @param http http context\n   * @return result of check\n   */\n  boolean matches(final HTTPContext http) {\n    // check method, path, consumed and produced media type\n    return methods.contains(http.method) && pathMatches(http) &&\n        consumes(http) && produces(http);\n  }","id":71623,"modified_method":"/**\n   * Checks if an HTTP request matches this function and its constraints.\n   * @param http http context\n   * @param err error code\n   * @return result of check\n   */\n  boolean matches(final HTTPContext http, final QNm err) {\n    // check method, consumed and produced media type, and path or error\n    return methods.contains(http.method) && consumes(http) && produces(http) &&\n        (err == null ? path != null && path.matches(http) :\n          error != null && error.matches(err));\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Binds the annotated variables.\n   * @param http http context\n   * @param arg argument array\n   * @throws QueryException query exception\n   * @throws IOException I/O exception\n   */\n  void bind(final HTTPContext http, final Expr[] arg) throws QueryException, IOException {\n    // bind variables from segments\n    for(int s = 0; s < path.size; s++) {\n      final Matcher m = TEMPLATE.matcher(path.segment[s]);\n      if(!m.find()) continue;\n      final QNm qnm = new QNm(token(m.group(1)), context);\n      bind(qnm, arg, new Atm(http.segment(s)));\n    }\n\n    // cache request body\n    final String ct = http.contentType();\n    IOContent body = null;\n\n    if(requestBody != null) {\n      body = cache(http, null);\n      try {\n        // bind request body in the correct format\n        body.name(http.method + IO.XMLSUFFIX);\n        bind(requestBody, arg, Parser.item(body, context.context.prop, ct));\n      } catch(final IOException ex) {\n        error(INPUT_CONV, ex);\n      }\n    }\n\n    // bind query parameters\n    final Map<String, String[]> params = http.params();\n    for(final RestXqParam rxp : queryParams) bind(rxp, arg, params.get(rxp.key));\n\n    // bind form parameters\n    if(!formParams.isEmpty()) {\n      if(MimeTypes.APP_FORM.equals(ct)) {\n        // convert parameters encoded in a form\n        body = cache(http, body);\n        addParams(body.toString(), params);\n      }\n      for(final RestXqParam rxp : formParams) bind(rxp, arg, params.get(rxp.key));\n    }\n\n    // bind header parameters\n    for(final RestXqParam rxp : headerParams) {\n      final StringList sl = new StringList();\n      final Enumeration<?> en =  http.req.getHeaders(rxp.key);\n      while(en.hasMoreElements()) {\n        for(final String s : en.nextElement().toString().split(\", *\")) sl.add(s);\n      }\n      bind(rxp, arg, sl.toArray());\n    }\n\n    // bind cookie parameters\n    final Cookie[] ck = http.req.getCookies();\n    for(final RestXqParam rxp : cookieParams) {\n      String v = null;\n      if(ck != null) {\n        for(final Cookie c : ck) {\n          if(rxp.key.equals(c.getName())) v = c.getValue();\n        }\n      }\n      if(v == null) bind(rxp, arg);\n      else bind(rxp, arg, v);\n    }\n  }","id":71624,"modified_method":"/**\n   * Binds the annotated variables.\n   * @param http http context\n   * @param arg argument array\n   * @param err optional query error\n   * @throws QueryException query exception\n   * @throws IOException I/O exception\n   */\n  void bind(final HTTPContext http, final Expr[] arg, final QueryException err)\n      throws QueryException, IOException {\n\n    // bind variables from segments\n    if(path != null) {\n      for(int s = 0; s < path.size; s++) {\n        final Matcher m = TEMPLATE.matcher(path.segment[s]);\n        if(!m.find()) continue;\n        final QNm qnm = new QNm(token(m.group(1)), context);\n        bind(qnm, arg, new Atm(http.segment(s)));\n      }\n    }\n\n    // cache request body\n    final String ct = http.contentType();\n    IOContent body = null;\n\n    if(requestBody != null) {\n      body = cache(http, null);\n      try {\n        // bind request body in the correct format\n        body.name(http.method + IO.XMLSUFFIX);\n        bind(requestBody, arg, Parser.item(body, context.context.prop, ct));\n      } catch(final IOException ex) {\n        error(INPUT_CONV, ex);\n      }\n    }\n\n    // bind query parameters\n    final Map<String, String[]> params = http.params();\n    for(final RestXqParam rxp : queryParams) {\n      final ValueBuilder vb = new ValueBuilder();\n      final String[] strings = params.get(rxp.key);\n      if(strings != null) for(final String v : params.get(rxp.key)) vb.add(new Atm(v));\n      bind(rxp, arg, vb.value());\n    }\n\n    // bind form parameters\n    if(!formParams.isEmpty()) {\n      if(MimeTypes.APP_FORM.equals(ct)) {\n        // convert parameters encoded in a form\n        body = cache(http, body);\n        addParams(body.toString(), params);\n      }\n      for(final RestXqParam rxp : formParams) {\n        final ValueBuilder vb = new ValueBuilder();\n        final String[] strings = params.get(rxp.key);\n        if(strings != null) for(final String v : params.get(rxp.key)) vb.add(new Atm(v));\n        bind(rxp, arg, vb.value());\n      }\n    }\n\n    // bind header parameters\n    for(final RestXqParam rxp : headerParams) {\n      final TokenList tl = new TokenList();\n      final Enumeration<?> en =  http.req.getHeaders(rxp.key);\n      while(en.hasMoreElements()) {\n        for(final String s : en.nextElement().toString().split(\", *\")) tl.add(s);\n      }\n      bind(rxp, arg, StrSeq.get(tl));\n    }\n\n    // bind cookie parameters\n    final Cookie[] ck = http.req.getCookies();\n    for(final RestXqParam rxp : cookieParams) {\n      Value val = Empty.SEQ;\n      if(ck != null) {\n        for(final Cookie c : ck) {\n          if(rxp.key.equals(c.getName())) val = Str.get(c.getValue());\n        }\n      }\n      bind(rxp, arg, val);\n    }\n\n    // bind errors\n    final Map<String, Value> errs = new HashMap<String, Value>();\n    if(err != null) {\n      final Value[] values = Catch.values(err);\n      for(int v = 0; v < Catch.NAMES.length; v++) {\n        errs.put(string(Catch.NAMES[v].local()), values[v]);\n      }\n    }\n    for(final RestXqParam rxp : errorParams) {\n      bind(rxp, arg, errs.get(rxp.key));\n    }\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  public int compareTo(final RestXqFunction rxf) {\n    return path.compareTo(rxf.path);\n  }","id":71625,"modified_method":"@Override\n  public int compareTo(final RestXqFunction rxf) {\n    return path == null ? error.compareTo(rxf.error) : path.compareTo(rxf.path);\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a parameter.\n   * @param value value\n   * @param name name\n   * @param declared variable declaration flags\n   * @return parameter\n   * @throws QueryException HTTP exception\n   */\n  private RestXqParam param(final Value value, final QNm name, final boolean[] declared)\n      throws QueryException {\n    // [CG] RESTXQ: allow identical field names?\n    final long vs = value.size();\n    if(vs < 2) error(function.info, ANN_PARAMS, \"%\", name.string(), 2);\n    // name of parameter\n    final String key = toString(value.itemAt(0), name);\n    // variable template\n    final QNm qnm = checkVariable(toString(value.itemAt(1), name), declared);\n    // default value\n    final ValueBuilder vb = new ValueBuilder();\n    for(int v = 2; v < vs; v++) vb.add(value.itemAt(v));\n    return new RestXqParam(qnm, key, vb.value());\n  }","id":71626,"modified_method":"/**\n   * Returns a parameter.\n   * @param value value\n   * @param name name\n   * @param declared variable declaration flags\n   * @return parameter\n   * @throws QueryException HTTP exception\n   */\n  private RestXqParam param(final Value value, final QNm name, final boolean[] declared)\n      throws QueryException {\n\n    final long vs = value.size();\n    if(vs < 2) error(function.info, ANN_ATLEAST, \"%\", name.string(), 2);\n    // name of parameter\n    final String key = toString(value.itemAt(0), name);\n    // variable template\n    final QNm qnm = checkVariable(toString(value.itemAt(1), name), declared);\n    // default value\n    final ValueBuilder vb = new ValueBuilder();\n    for(int v = 2; v < vs; v++) vb.add(value.itemAt(v));\n    return new RestXqParam(qnm, key, vb.value());\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Processes the HTTP request.\n   * Parses new modules and discards obsolete ones.\n   * @param http HTTP context\n   * @throws Exception exception\n   */\n  void process(final HTTPContext http) throws Exception {\n    try {\n      module.process(http, this);\n    } catch(final QueryException ex) {\n      if(ex.file() == null) ex.info(function.info);\n      throw ex;\n    }\n  }","id":71627,"modified_method":"/**\n   * Processes the HTTP request.\n   * Parses new modules and discards obsolete ones.\n   * @param http HTTP context\n   * @param exc optional query exception\n   * @throws Exception exception\n   */\n  void process(final HTTPContext http, final QueryException exc) throws Exception {\n    try {\n      module.process(http, this, exc);\n    } catch(final QueryException ex) {\n      if(ex.file() == null) ex.info(function.info);\n      throw ex;\n    }\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Binds the specified parameter to a variable.\n   * @param rxp parameter\n   * @param args argument array\n   * @param values values to be bound; the parameter's default value is assigned\n   *        if the argument is {@code null} or empty\n   * @throws QueryException query exception\n   */\n  private void bind(final RestXqParam rxp, final Expr[] args, final String... values)\n      throws QueryException {\n    final Value val;\n    if(values == null || values.length == 0) {\n      val = rxp.value;\n    } else {\n      final ValueBuilder vb = new ValueBuilder();\n      for(final String s : values) vb.add(new Atm(s));\n      val = vb.value();\n    }\n    bind(rxp.name, args, val);\n  }","id":71628,"modified_method":"/**\n   * Binds the specified parameter to a variable.\n   * @param rxp parameter\n   * @param args argument array\n   * @param values values to be bound; the parameter's default value is assigned\n   *        if the argument is {@code null} or empty\n   * @throws QueryException query exception\n   */\n  private void bind(final RestXqParam rxp, final Expr[] args, final Value values)\n      throws QueryException {\n\n    final Value val;\n    if(values == null || values.size() == 0) {\n      val = rxp.value;\n    } else {\n      final ValueBuilder vb = new ValueBuilder();\n      for(final Object o : values) {\n        vb.add(o instanceof Value ? (Value) o : new Atm(o.toString()));\n      }\n      val = vb.value();\n    }\n    bind(rxp.name, args, val);\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Parses the module and returns the query context.\n   * @param http http context\n   * @return query context\n   * @throws QueryException query exception\n   */\n  private QueryContext parse(final HTTPContext http) throws QueryException {\n    final QueryContext qc = new QueryContext(http.context());\n    try {\n      qc.parseLibrary(string(file.read()), file.path());\n      return qc;\n    } catch(final IOException ex) {\n      throw IOERR.thrw(null, ex);\n    }\n  }","id":71629,"modified_method":"/**\n   * Checks the module for RESTXQ annotations.\n   * @param http http context\n   * @return {@code true} if module contains relevant annotations\n   * @throws QueryException query exception\n   */\n  boolean parse(final HTTPContext http) throws QueryException {\n    functions.clear();\n\n    // loop through all functions\n    final QueryContext qc = parseModule(http);\n    try {\n      for(final StaticFunc uf : qc.funcs.funcs()) {\n        // consider only functions that are defined in this module\n        if(!file.name().equals(new IOFile(uf.info.file()).name())) continue;\n        final RestXqFunction rxf = new RestXqFunction(uf, qc, this);\n        if(rxf.parse()) functions.add(rxf);\n      }\n    } finally {\n      qc.close();\n    }\n    return !functions.isEmpty();\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Checks the module for RESTFful annotations.\n   * @param http http context\n   * @return {@code true} if module contains relevant annotations\n   * @throws QueryException query exception\n   */\n  boolean analyze(final HTTPContext http) throws QueryException {\n    functions.clear();\n\n    // loop through all functions\n    final QueryContext qc = parse(http);\n    try {\n      for(final StaticFunc uf : qc.funcs.funcs()) {\n        // consider only functions that are defined in this module\n        if(!file.name().equals(new IOFile(uf.info.file()).name())) continue;\n        final RestXqFunction rxf = new RestXqFunction(uf, qc, this);\n        if(rxf.analyze()) functions.add(rxf);\n      }\n    } finally {\n      qc.close();\n    }\n    return !functions.isEmpty();\n  }","id":71630,"modified_method":"/**\n   * Parses the module and returns the query context.\n   * @param http http context\n   * @return query context\n   * @throws QueryException query exception\n   */\n  private QueryContext parseModule(final HTTPContext http) throws QueryException {\n    final QueryContext qc = new QueryContext(http.context());\n    try {\n      qc.parseLibrary(string(file.read()), file.path());\n      return qc;\n    } catch(final IOException ex) {\n      throw IOERR.thrw(null, ex);\n    }\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Processes the HTTP request.\n   * @param http HTTP context\n   * @param func function to be processed\n   * @throws Exception exception\n   */\n  void process(final HTTPContext http, final RestXqFunction func) throws Exception {\n    // create new XQuery instance\n    final QueryContext qc = parse(http);\n    try {\n      // loop through all functions\n      for(final StaticFunc uf : qc.funcs.funcs()) {\n        // compare input info\n        if(func.function.info.equals(uf.info)) {\n          // find and evaluate relevant function\n          final RestXqFunction rxf = new RestXqFunction(uf, qc, this);\n          rxf.analyze();\n          new RestXqResponse(rxf, qc, http).create();\n          break;\n        }\n      }\n    } finally {\n      qc.close();\n    }\n  }","id":71631,"modified_method":"/**\n   * Processes the HTTP request.\n   * @param http HTTP context\n   * @param func function to be processed\n   * @param error optional error reference\n   * @throws Exception exception\n   */\n  void process(final HTTPContext http, final RestXqFunction func,\n      final QueryException error) throws Exception {\n\n    // create new XQuery instance\n    final QueryContext qc = parseModule(http);\n    try {\n      // loop through all functions\n      for(final StaticFunc uf : qc.funcs.funcs()) {\n        // compare input info\n        if(func.function.info.equals(uf.info)) {\n          // find and evaluate relevant function\n          final RestXqFunction rxf = new RestXqFunction(uf, qc, this);\n          rxf.parse();\n          new RestXqResponse(rxf, qc, http, error).create();\n          break;\n        }\n      }\n    } finally {\n      qc.close();\n    }\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns a WADL description for all available URIs.\n   * @param http HTTP context\n   * @return WADL description\n   * @throws QueryException query exception\n   */\n  public synchronized FElem wadl(final HTTPContext http) throws QueryException {\n    analyze(http);\n    return new RestXqWadl(http).create(modules);\n  }","id":71632,"modified_method":"/**\n   * Returns a WADL description for all available URIs.\n   * @param http HTTP context\n   * @return WADL description\n   */\n  public FElem wadl(final HTTPContext http) {\n    return new RestXqWadl(http).create(modules);\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Updates the module cache. Parses new modules and discards obsolete ones.\n   * @param http http context\n   * @throws QueryException query exception\n   */\n  private void analyze(final HTTPContext http) throws QueryException {\n    // initialize RESTXQ directory (may be relative against WEBPATH)\n    if(restxq == null) {\n      final File fl = new File(http.context().mprop.get(MainProp.RESTXQPATH));\n      restxq = fl.isAbsolute() ? new IOFile(fl) :\n        new IOFile(http.context().mprop.get(MainProp.WEBPATH), fl.getPath());\n    }\n    // create new cache\n    final HashMap<String, RestXqModule> cache = new HashMap<String, RestXqModule>();\n    analyze(http, restxq, cache);\n    modules = cache;\n  }","id":71633,"modified_method":"/**\n   * Updates the module cache. Parses new modules and discards obsolete ones.\n   * @param http http context\n   * @throws QueryException query exception\n   */\n  private synchronized void cache(final HTTPContext http) throws QueryException {\n    // initialize RESTXQ directory (may be relative against WEBPATH)\n    if(restxq == null) {\n      final File fl = new File(http.context().mprop.get(MainProp.RESTXQPATH));\n      restxq = fl.isAbsolute() ? new IOFile(fl) :\n        new IOFile(http.context().mprop.get(MainProp.WEBPATH), fl.getPath());\n    }\n    // create new cache\n    final HashMap<String, RestXqModule> cache = new HashMap<String, RestXqModule>();\n    cache(http, restxq, cache);\n    modules = cache;\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Returns the module that matches the specified request, or {@code null}.\n   * @param http HTTP context\n   * @throws QueryException query exception\n   * @return instance\n   */\n  synchronized RestXqFunction find(final HTTPContext http) throws QueryException {\n    analyze(http);\n    // collect all functions\n    final ArrayList<RestXqFunction> list = new ArrayList<RestXqFunction>();\n    for(final RestXqModule mod : modules.values()) mod.add(http, list);\n    // no path matches\n    if(list.isEmpty()) return null;\n    // choose most appropriate function\n    RestXqFunction first = list.get(0);\n    if(list.size() > 1) {\n      // sort by specifity\n      Collections.sort(list);\n      first = list.get(0);\n      // disallow more than one path with the same specifity\n      if(first.compareTo(list.get(1)) == 0) {\n        final TokenBuilder tb = new TokenBuilder();\n        for(final RestXqFunction rxf : list) {\n          if(first.compareTo(rxf) != 0) break;\n          tb.add(Prop.NL).add(rxf.function.info.toString());\n        }\n        first.error(PATH_CONFLICT, first.path, tb);\n      }\n    }\n    // choose most specific function\n    return first;\n  }","id":71634,"modified_method":"/**\n   * Returns the function that matches the current request or the specified error code.\n   * Returns {@code null} if no function matches.\n   * @param http HTTP context\n   * @param error error code (optional)\n   * @throws QueryException query exception\n   * @return function\n   */\n  RestXqFunction find(final HTTPContext http, final QNm error) throws QueryException {\n    cache(http);\n    // collect all functions\n    final ArrayList<RestXqFunction> list = new ArrayList<RestXqFunction>();\n    for(final RestXqModule mod : modules.values()) {\n      for(final RestXqFunction rxf : mod.functions()) {\n        if(rxf.matches(http, error)) list.add(rxf);\n      }\n    }\n    // no path matches\n    if(list.isEmpty()) return null;\n    // choose most appropriate function\n    RestXqFunction first = list.get(0);\n    if(list.size() > 1) {\n      // sort by specifity\n      Collections.sort(list);\n      first = list.get(0);\n      // disallow more than one path with the same specifity\n      if(first.compareTo(list.get(1)) == 0) {\n        final TokenBuilder tb = new TokenBuilder();\n        for(final RestXqFunction rxf : list) {\n          if(first.compareTo(rxf) != 0) break;\n          tb.add(Prop.NL).add(rxf.function.info.toString());\n        }\n        if(first.path != null) first.error(PATH_CONFLICT, first.path, tb);\n        first.error(ERROR_CONFLICT, first.error, tb);\n      }\n    }\n    // choose most specific function\n    return first;\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Analyzes the specified path.\n   * @param root root path\n   * @param http http context\n   * @param cache cached modules\n   * @throws QueryException query exception\n   */\n  private void analyze(final HTTPContext http, final IOFile root,\n      final HashMap<String, RestXqModule> cache) throws QueryException {\n\n    for(final IOFile file : root.children()) {\n      if(file.isDir()) {\n        analyze(http, file, cache);\n      } else if(file.path().endsWith(IO.XQMSUFFIX)) {\n        // all files with .xqm suffix will be parsed for RESTXQ annotations\n        final String path = file.path();\n        RestXqModule module = modules.get(path);\n\n        boolean parsed = false;\n        if(module != null) {\n          // check if module has been modified\n          parsed = module.uptodate();\n        } else {\n          // create new module\n          module = new RestXqModule(file);\n        }\n        // add module if it has been parsed, and if it contains annotations\n        if(parsed || module.analyze(http)) {\n          module.touch();\n          cache.put(path, module);\n        }\n      }\n    }\n  }","id":71635,"modified_method":"/**\n   * Parses the specified path for RESTXQ modules and caches new entries.\n   * @param root root path\n   * @param http http context\n   * @param cache cached modules\n   * @throws QueryException query exception\n   */\n  private synchronized void cache(final HTTPContext http, final IOFile root,\n      final HashMap<String, RestXqModule> cache) throws QueryException {\n\n    for(final IOFile file : root.children()) {\n      if(file.isDir()) {\n        cache(http, file, cache);\n      } else if(file.path().endsWith(IO.XQMSUFFIX)) {\n        // all files with .xqm suffix will be parsed for RESTXQ annotations\n        final String path = file.path();\n        RestXqModule module = modules.get(path);\n\n        boolean parsed = false;\n        if(module != null) {\n          // check if module has been modified\n          parsed = module.uptodate();\n        } else {\n          // create new module\n          module = new RestXqModule(file);\n        }\n        // add module if it has been parsed, and if it contains annotations\n        if(parsed || module.parse(http)) {\n          module.touch();\n          cache.put(path, module);\n        }\n      }\n    }\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param n variable name\n   * @param k name of parameter\n   * @param v default value\n   */\n  RestXqParam(final QNm n, final String k, final Value v) {\n    name = n;\n    key = k;\n    value = v;\n  }","id":71636,"modified_method":"/**\n   * Constructor.\n   * @param nm variable name\n   * @param param name of parameter\n   * @param def default value\n   */\n  RestXqParam(final QNm nm, final String param, final Value def) {\n    name = nm;\n    key = param;\n    value = def;\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Constructor.\n   * @param rxf function to be evaluated\n   * @param ctx query context\n   * @param hc HTTP context\n   */\n  RestXqResponse(final RestXqFunction rxf, final QueryContext ctx, final HTTPContext hc) {\n    function = rxf;\n    qc = ctx;\n    http = hc;\n  }","id":71637,"modified_method":"/**\n   * Constructor.\n   * @param rxf function to be evaluated\n   * @param ctx query context\n   * @param hc HTTP context\n   * @param err optional query error\n   */\n  RestXqResponse(final RestXqFunction rxf, final QueryContext ctx, final HTTPContext hc,\n      final QueryException err) {\n    function = rxf;\n    query = ctx;\n    http = hc;\n    error = err;\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"/**\n   * Evaluates the specified function and creates a response.\n   * @throws Exception exception (including unexpected ones)\n   */\n  void create() throws Exception {\n    String redirect = null, forward = null;\n    RestXqRespBuilder resp = null;\n\n    try {\n      // bind variables\n      final StaticFunc uf = function.function;\n      final Expr[] args = new Expr[uf.args.length];\n      function.bind(http, args);\n\n      // wrap function with a function call\n      final StaticFuncCall sfc = new BaseFuncCall(uf.name, args, uf.sc, uf.info).init(uf);\n      final MainModule mod = new MainModule(sfc, new VarScope(), null);\n\n      // assign main module and http context and register process\n      qc.mainModule(mod);\n      qc.context(http, null);\n      qc.context.register(qc);\n\n      // compile and evaluate query\n      qc.compile();\n      final Iter iter = qc.iter();\n      Item item = iter.next();\n\n      // handle response element\n      if(item != null && item.type.isNode()) {\n        final ANode node = (ANode) item;\n        // send redirect to browser\n        if(REST_REDIRECT.eq(node)) {\n          final ANode ch = node.children().next();\n          if(ch == null || ch.type != NodeType.TXT) function.error(NO_VALUE, node.name());\n          redirect = string(ch.string()).trim();\n          return;\n        }\n        // server-side forwarding\n        if(REST_FORWARD.eq(node)) {\n          final ANode ch = node.children().next();\n          if(ch == null || ch.type != NodeType.TXT) function.error(NO_VALUE, node.name());\n          forward = string(ch.string()).trim();\n          return;\n        }\n        if(REST_RESPONSE.eq(node)) {\n          resp = new RestXqRespBuilder();\n          resp.build(node, function, iter, http);\n          return;\n        }\n      }\n\n      // HEAD method must return a single response element\n      if(function.methods.size() == 1 && function.methods.contains(HTTPMethod.HEAD))\n        function.error(HEAD_METHOD);\n\n      // serialize result\n      final SerializerProp sp = function.output;\n      http.initResponse(sp);\n      final Serializer ser = Serializer.get(http.res.getOutputStream(), sp);\n      for(; item != null; item = iter.next()) ser.serialize(item);\n      ser.close();\n\n    } finally {\n      qc.close();\n      qc.context.unregister(qc);\n\n      if(redirect != null) {\n        http.res.sendRedirect(redirect);\n      } else if(forward != null) {\n        http.req.getRequestDispatcher(forward).forward(http.req, http.res);\n      } else if(resp != null) {\n        if(resp.status != 0) http.status(resp.status, resp.message, resp.error);\n        http.res.getOutputStream().write(resp.cache.toArray());\n      }\n    }\n  }","id":71638,"modified_method":"/**\n   * Evaluates the specified function and creates a response.\n   * @throws Exception exception (including unexpected ones)\n   */\n  void create() throws Exception {\n    String redirect = null, forward = null;\n    RestXqRespBuilder resp = null;\n\n    try {\n      // bind variables\n      final StaticFunc uf = function.function;\n      final Expr[] args = new Expr[uf.args.length];\n      function.bind(http, args, error);\n\n      // wrap function with a function call\n      final StaticFuncCall sfc = new BaseFuncCall(uf.name, args, uf.sc, uf.info).init(uf);\n      final MainModule mod = new MainModule(sfc, new VarScope(), null);\n\n      // assign main module and http context and register process\n      query.mainModule(mod);\n      query.context(http, null);\n      query.context.register(query);\n\n      // compile and evaluate query\n      query.compile();\n      final Iter iter = query.iter();\n      Item item = iter.next();\n\n      // handle response element\n      if(item != null && item.type.isNode()) {\n        final ANode node = (ANode) item;\n        // send redirect to browser\n        if(REST_REDIRECT.eq(node)) {\n          final ANode ch = node.children().next();\n          if(ch == null || ch.type != NodeType.TXT) function.error(NO_VALUE, node.name());\n          redirect = string(ch.string()).trim();\n          return;\n        }\n        // server-side forwarding\n        if(REST_FORWARD.eq(node)) {\n          final ANode ch = node.children().next();\n          if(ch == null || ch.type != NodeType.TXT) function.error(NO_VALUE, node.name());\n          forward = string(ch.string()).trim();\n          return;\n        }\n        if(REST_RESPONSE.eq(node)) {\n          resp = new RestXqRespBuilder();\n          resp.build(node, function, iter, http);\n          return;\n        }\n      }\n\n      // HEAD method must return a single response element\n      if(function.methods.size() == 1 && function.methods.contains(HTTPMethod.HEAD))\n        function.error(HEAD_METHOD);\n\n      // serialize result\n      final SerializerProp sp = function.output;\n      http.initResponse(sp);\n      final Serializer ser = Serializer.get(http.res.getOutputStream(), sp);\n      for(; item != null; item = iter.next()) ser.serialize(item);\n      ser.close();\n\n    } finally {\n      query.close();\n      query.context.unregister(query);\n\n      if(redirect != null) {\n        http.res.sendRedirect(redirect);\n      } else if(forward != null) {\n        http.req.getRequestDispatcher(forward).forward(http.req, http.res);\n      } else if(resp != null) {\n        if(resp.status != 0) http.status(resp.status, resp.message, resp.error);\n        http.res.getOutputStream().write(resp.cache.toArray());\n      }\n    }\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"@Override\n  protected void run(final HTTPContext http) throws Exception {\n    // authenticate user\n    http.session();\n\n    // analyze input path\n    final RestXqModules rxm = RestXqModules.get();\n    // select XQuery function\n    final RestXqFunction func = rxm.find(http);\n    if(func == null) HTTPErr.NO_XQUERY.thrw();\n    // process function\n    func.process(http);\n  }","id":71639,"modified_method":"@Override\n  protected void run(final HTTPContext http) throws Exception {\n    // authenticate user\n    http.session();\n\n    // analyze input path\n    final RestXqModules rxm = RestXqModules.get();\n    // select XQuery function\n    RestXqFunction func = rxm.find(http, null);\n    if(func == null) HTTPErr.NO_XQUERY.thrw();\n    try {\n      // process function that matches the current request\n      func.process(http, null);\n    } catch(final QueryException ex) {\n      // process optional error function\n      func = rxm.find(http, ex.qname());\n      if(func == null) throw ex;\n      func.process(http, ex);\n    }\n  }","commit_id":"456bb514e22b3e94f19b771fe1a37fb869a13d63","url":"https://github.com/BaseXdb/basex"},{"original_method":"private void fixNullValueInModel( Model modelToFix, Model correctModel )\n    {\n        modelToFix.setModelVersion( correctModel.getModelVersion() );\n        modelToFix.setName( correctModel.getName() );\n        modelToFix.setParent( cloneParent( correctModel.getParent() ) );\n        modelToFix.setVersion( correctModel.getVersion() );\n        modelToFix.setArtifactId( correctModel.getArtifactId() );\n        modelToFix.setProperties( new Properties( correctModel.getProperties() ) );\n        modelToFix.setGroupId( correctModel.getGroupId() );\n        modelToFix.setPackaging( correctModel.getPackaging() );\n        modelToFix.setModules( cloneModules( correctModel.getModules() ) );\n        modelToFix.setDistributionManagement( correctModel.getDistributionManagement() );\n    }","id":71640,"modified_method":"private void fixNullValueInModel( Model modelToFix, Model correctModel )\n    {\n        if ( modelToFix.getModelVersion() != null )\n        {\n            modelToFix.setModelVersion( correctModel.getModelVersion() );\n        }\n\n        if ( modelToFix.getName() != null )\n        {\n            modelToFix.setName( correctModel.getName() );\n        }\n\n        if ( modelToFix.getParent() != null )\n        {\n            modelToFix.setParent( cloneParent( correctModel.getParent() ) );\n        }\n\n        if ( modelToFix.getVersion() != null )\n        {\n            modelToFix.setVersion( correctModel.getVersion() );\n        }\n\n        if ( modelToFix.getArtifactId() != null )\n        {\n            modelToFix.setArtifactId( correctModel.getArtifactId() );\n        }\n\n        if ( modelToFix.getProperties() != null && modelToFix.getProperties().isEmpty() )\n        {\n            modelToFix.setProperties( new Properties( correctModel.getProperties() ) );\n        }\n\n        if ( modelToFix.getGroupId() != null )\n        {\n            modelToFix.setGroupId( correctModel.getGroupId() );\n        }\n\n        if ( modelToFix.getPackaging() != null )\n        {\n            modelToFix.setPackaging( correctModel.getPackaging() );\n        }\n\n        if ( modelToFix.getModules() != null && !modelToFix.getModules().isEmpty() )\n        {\n            modelToFix.setModules( cloneModules( correctModel.getModules() ) );\n        }\n\n        if ( modelToFix.getDistributionManagement() != null )\n        {\n            modelToFix.setDistributionManagement( correctModel.getDistributionManagement() );\n        }\n    }","commit_id":"818a398e35357e6f4abca348f94b29381eaec77f","url":"https://github.com/apache/maven-plugins"},{"original_method":"private static void doMarshallMap(File file, LWMap map)\n        throws java.io.IOException,\n               org.exolab.castor.mapping.MappingException,\n               org.exolab.castor.xml.MarshalException,\n               org.exolab.castor.xml.ValidationException\n    {\n        Marshaller marshaller = null;\n\n        final String path = file.getAbsolutePath().replaceAll(\"%20\",\" \");\n        final Writer writer;\n        if (OUTPUT_ENCODING.equals(\"UTF-8\") || OUTPUT_ENCODING.equals(\"UTF8\")) {\n            writer = new OutputStreamWriter(new FileOutputStream(path), OUTPUT_ENCODING);\n        } else {\n            writer = new FileWriter(path);\n            // For the actual file writer we can use the default encoding because\n            // we're marshalling specifically in US-ASCII.  E.g., because we direct\n            // castor to fully encode any special characters via\n            // setEncoding(\"US-ASCII\"), we'll only have ASCII chars to write anyway,\n            // and any default encoding will handle that...\n                \n        }\n            \n        writer.write(VUE_COMMENT_START\n                     + \" VUE mapping \"\n                     + \"@version(\" + XML_MAPPING_CURRENT_VERSION_ID + \")\"\n                     + \" \" + XML_MAPPING_DEFAULT\n                     + \" -->\\n\");\n        writer.write(VUE_COMMENT_START\n                     + \" Saved date \" + new java.util.Date()\n                     + \" by \" + VUE.getSystemProperty(\"user.name\")\n                     + \" on platform \" + VUE.getSystemProperty(\"os.name\")\n                     + \" \" + VUE.getSystemProperty(\"os.version\")\n                     + \" in JVM \" + VUE.getSystemProperty(\"java.runtime.version\")\n                     + \" -->\\n\");\n        writer.write(VUE_COMMENT_START\n                     + \" Saving version \" + tufts.vue.Version.WhatString\n                     + \" -->\\n\");\n        if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Wrote VUE header to \" + writer);\n        marshaller = new Marshaller(writer);\n        //marshaller.setDebug(DEBUG.CASTOR);\n        marshaller.setEncoding(OUTPUT_ENCODING);\n        // marshal as document (default): make sure we add at top: <?xml version=\"1.0\" encoding=\"<encoding>\"?>\n        marshaller.setMarshalAsDocument(true);\n        marshaller.setNoNamespaceSchemaLocation(\"none\");\n        // setting to \"none\" gets rid of all the spurious tags like these:\n        // xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\n        //marshaller.setDoctype(\"foo\", \"bar\"); // not in 0.9.4.3, must wait till we can run 0.9.5.3+\n\n        /*\n          marshaller.setMarshalListener(new MarshalListener() {\n          public boolean preMarshal(Object o) {\n          System.out.println(\" preMarshal \" + o.getClass().getName() + \" \" + o);\n          return true;\n          }\n          public void postMarshal(Object o) {\n          System.out.println(\"postMarshal \" + o.getClass().getName() + \" \" + o);\n          }\n          });\n        */\n\n        //marshaller.setRootElement(\"FOOBIE\"); // overrides name of root element\n            \n        marshaller.setMapping(getDefaultMapping());\n\n        //----------------------------------------------------------------------------------------\n        // \n        // 2007-10-01 SMF -- turning off validation during marshalling now required\n        // w/castor-1.1.2.1-xml.jar, otherwise, for some unknown reason, LWLink's\n        // with any connected endpoints cause validation exceptions when attempting to\n        // save.  E.g, from a map with one node and one link connected to it:\n        //\n        // ValidationException: The following exception occured while validating field: childList of class:\n        // tufts.vue.LWMap: The object associated with IDREF \"LWNode[2         \"New Node\"  +415,+24 69x22]\" of type\n        // class tufts.vue.LWNode has no ID!;\n        // - location of error: XPATH: /LW-MAP\n        // The object associated with IDREF \"LWNode[2         \"New Node\"  +415,+24 69x22]\" of type class tufts.vue.LWNode has no ID!\n        //\n        // Even tho the node's getID() is correctly returning \"2\"\n        //\n        marshaller.setValidation(false); \n        //----------------------------------------------------------------------------------------\n            \n        /*\n          Logger logger = new Logger(System.err);\n          logger.setPrefix(\"Castor \");\n          marshaller.setLogWriter(logger);\n        */\n        marshaller.setLogWriter(new PrintWriter(System.err));\n\n        // Make modifications to the map at the last minute, so any prior exceptions leave the map untouched.\n\n        final int oldModelVersion = map.getModelVersion();\n        final File oldSaveFile = map.getFile();\n        \n        map.setModelVersion(LWMap.getCurrentModelVersion());\n        // note that if this file is different from it's last save file, this\n        // operation may cause any/all of the resources in the map to be\n        // updated before returning.\n        map.setFile(file);\n            \n        //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Marshalling \" + map + \" ...\");\n        Log.debug(\"marshalling \" + map + \" ...\");\n\n        try {\n            marshaller.marshal(map);\n            Log.debug(\"marshalled \" + map);\n            writer.flush();\n            writer.close();\n            //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Completed marshalling \" + map);\n        } catch (Throwable t) {\n            try {\n                // revert map model version & save file\n                map.setModelVersion(oldModelVersion);\n                map.setFile(oldSaveFile);\n            } catch (Throwable tx) {\n                Util.printStackTrace(tx);\n            } finally {\n                throw new WrappedMarshallException(t);\n            }\n        }\n            \n        map.markAsSaved();\n        Log.debug(\"saved \" + map);\n\n        //map.setFile(file);\n\n        //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Wrote \" + file);\n\n    }","id":71641,"modified_method":"private static void doMarshallMap(File file, LWMap map)\n        throws java.io.IOException,\n               org.exolab.castor.mapping.MappingException,\n               org.exolab.castor.xml.MarshalException,\n               org.exolab.castor.xml.ValidationException\n    {\n        final String path = file.getAbsolutePath().replaceAll(\"%20\",\" \");\n        final Writer writer;\n        if (OUTPUT_ENCODING.equals(\"UTF-8\") || OUTPUT_ENCODING.equals(\"UTF8\")) {\n            writer = new OutputStreamWriter(new FileOutputStream(path), OUTPUT_ENCODING);\n        } else {\n            writer = new FileWriter(path);\n            // For the actual file writer we can use the default encoding because\n            // we're marshalling specifically in US-ASCII.  E.g., because we direct\n            // castor to fully encode any special characters via\n            // setEncoding(\"US-ASCII\"), we'll only have ASCII chars to write anyway,\n            // and any default encoding will handle that...\n                \n        }\n\n        marshallMapToWriter(writer, map, file);\n        writer.close();\n    }","commit_id":"3cff8c8f01852b46063624163c4a58f27ac3523e","url":"https://github.com/VUE/VUE"},{"original_method":"private static void doMarshallMap(Writer writer, LWMap map)\n    throws java.io.IOException,\n           org.exolab.castor.mapping.MappingException,\n           org.exolab.castor.xml.MarshalException,\n           org.exolab.castor.xml.ValidationException\n{\n    Marshaller marshaller = null;\n\n//    final String path = file.getAbsolutePath().replaceAll(\"%20\",\" \");\n//    final Writer writer;\n    if (OUTPUT_ENCODING.equals(\"UTF-8\") || OUTPUT_ENCODING.equals(\"UTF8\")) {\n//        writer = new OutputStreamWriter(new FileOutputStream(path), OUTPUT_ENCODING);\n    } else {\n//        writer = new FileWriter(path);\n        // For the actual file writer we can use the default encoding because\n        // we're marshalling specifically in US-ASCII.  E.g., because we direct\n        // castor to fully encode any special characters via\n        // setEncoding(\"US-ASCII\"), we'll only have ASCII chars to write anyway,\n        // and any default encoding will handle that...\n            \n    }\n        \n    writer.write(VUE_COMMENT_START\n                 + \" VUE mapping \"\n                 + \"@version(\" + XML_MAPPING_CURRENT_VERSION_ID + \")\"\n                 + \" \" + XML_MAPPING_DEFAULT\n                 + \" -->\\n\");\n    writer.write(VUE_COMMENT_START\n                 + \" Saved date \" + new java.util.Date()\n                 + \" by \" + VUE.getSystemProperty(\"user.name\")\n                 + \" on platform \" + VUE.getSystemProperty(\"os.name\")\n                 + \" \" + VUE.getSystemProperty(\"os.version\")\n                 + \" in JVM \" + VUE.getSystemProperty(\"java.runtime.version\")\n                 + \" -->\\n\");\n    writer.write(VUE_COMMENT_START\n                 + \" Saving version \" + tufts.vue.Version.WhatString\n                 + \" -->\\n\");\n    if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Wrote VUE header to \" + writer);\n    marshaller = new Marshaller(writer);\n    //marshaller.setDebug(DEBUG.CASTOR);\n    marshaller.setEncoding(OUTPUT_ENCODING);\n    // marshal as document (default): make sure we add at top: <?xml version=\"1.0\" encoding=\"<encoding>\"?>\n    marshaller.setMarshalAsDocument(true);\n    marshaller.setNoNamespaceSchemaLocation(\"none\");\n    // setting to \"none\" gets rid of all the spurious tags like these:\n    // xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\n    //marshaller.setDoctype(\"foo\", \"bar\"); // not in 0.9.4.3, must wait till we can run 0.9.5.3+\n\n    /*\n      marshaller.setMarshalListener(new MarshalListener() {\n      public boolean preMarshal(Object o) {\n      System.out.println(\" preMarshal \" + o.getClass().getName() + \" \" + o);\n      return true;\n      }\n      public void postMarshal(Object o) {\n      System.out.println(\"postMarshal \" + o.getClass().getName() + \" \" + o);\n      }\n      });\n    */\n\n    //marshaller.setRootElement(\"FOOBIE\"); // overrides name of root element\n        \n    marshaller.setMapping(getDefaultMapping());\n\n    //----------------------------------------------------------------------------------------\n    // \n    // 2007-10-01 SMF -- turning off validation during marshalling now required\n    // w/castor-1.1.2.1-xml.jar, otherwise, for some unknown reason, LWLink's\n    // with any connected endpoints cause validation exceptions when attempting to\n    // save.  E.g, from a map with one node and one link connected to it:\n    //\n    // ValidationException: The following exception occured while validating field: childList of class:\n    // tufts.vue.LWMap: The object associated with IDREF \"LWNode[2         \"New Node\"  +415,+24 69x22]\" of type\n    // class tufts.vue.LWNode has no ID!;\n    // - location of error: XPATH: /LW-MAP\n    // The object associated with IDREF \"LWNode[2         \"New Node\"  +415,+24 69x22]\" of type class tufts.vue.LWNode has no ID!\n    //\n    // Even tho the node's getID() is correctly returning \"2\"\n    //\n    marshaller.setValidation(false); \n    //----------------------------------------------------------------------------------------\n        \n    /*\n      Logger logger = new Logger(System.err);\n      logger.setPrefix(\"Castor \");\n      marshaller.setLogWriter(logger);\n    */\n    marshaller.setLogWriter(new PrintWriter(System.err));\n\n    // Make modifications to the map at the last minute, so any prior exceptions leave the map untouched.\n\n    final int oldModelVersion = map.getModelVersion();\n    final File oldSaveFile = map.getFile();\n    \n    map.setModelVersion(LWMap.getCurrentModelVersion());\n    // note that if this file is different from it's last save file, this\n    // operation may cause any/all of the resources in the map to be\n    // updated before returning.\n//    map.setFile(file);\n        \n    //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Marshalling \" + map + \" ...\");\n    Log.debug(\"marshalling \" + map + \" ...\");\n\n    try {\n        marshaller.marshal(map);\n        Log.debug(\"marshalled \" + map);\n        writer.flush();\n        writer.close();\n        //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Completed marshalling \" + map);\n    } catch (Throwable t) {\n        try {\n            // revert map model version & save file\n            map.setModelVersion(oldModelVersion);\n            map.setFile(oldSaveFile);\n        } catch (Throwable tx) {\n            Util.printStackTrace(tx);\n        } finally {\n            throw new WrappedMarshallException(t);\n        }\n    }\n        \n    map.markAsSaved();\n    Log.debug(\"saved \" + map);\n\n    //map.setFile(file);\n\n    //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Wrote \" + file);\n\n}","id":71642,"modified_method":"/**\n     * @param file - if null, map state is untouched, otherwise, map state is updated\n     */\n    private static void marshallMapToWriter(final Writer writer, final LWMap map, final File file)\n        throws java.io.IOException,\n               org.exolab.castor.mapping.MappingException,\n               org.exolab.castor.xml.MarshalException,\n               org.exolab.castor.xml.ValidationException\n    {\n\n        Marshaller marshaller = null;\n        writer.write(VUE_COMMENT_START\n                     + \" VUE mapping \"\n                     + \"@version(\" + XML_MAPPING_CURRENT_VERSION_ID + \")\"\n                     + \" \" + XML_MAPPING_DEFAULT\n                     + \" -->\\n\");\n        writer.write(VUE_COMMENT_START\n                     + \" Saved date \" + new java.util.Date()\n                     + \" by \" + VUE.getSystemProperty(\"user.name\")\n                     + \" on platform \" + VUE.getSystemProperty(\"os.name\")\n                     + \" \" + VUE.getSystemProperty(\"os.version\")\n                     + \" in JVM \" + VUE.getSystemProperty(\"java.runtime.version\")\n                     + \" -->\\n\");\n        writer.write(VUE_COMMENT_START\n                     + \" Saving version \" + tufts.vue.Version.WhatString\n                     + \" -->\\n\");\n        if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Wrote VUE header to \" + writer);\n        marshaller = new Marshaller(writer);\n        //marshaller.setDebug(DEBUG.CASTOR);\n        marshaller.setEncoding(OUTPUT_ENCODING);\n        // marshal as document (default): make sure we add at top: <?xml version=\"1.0\" encoding=\"<encoding>\"?>\n        marshaller.setMarshalAsDocument(true);\n        marshaller.setNoNamespaceSchemaLocation(\"none\");\n        marshaller.setMarshalListener(new VueMarshalListener());\n        // setting to \"none\" gets rid of all the spurious tags like these:\n        // xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\n        //marshaller.setDoctype(\"foo\", \"bar\"); // not in 0.9.4.3, must wait till we can run 0.9.5.3+\n\n        /*\n          marshaller.setMarshalListener(new MarshalListener() {\n          public boolean preMarshal(Object o) {\n          System.out.println(\" preMarshal \" + o.getClass().getName() + \" \" + o);\n          return true;\n          }\n          public void postMarshal(Object o) {\n          System.out.println(\"postMarshal \" + o.getClass().getName() + \" \" + o);\n          }\n          });\n        */\n\n        //marshaller.setRootElement(\"FOOBIE\"); // overrides name of root element\n            \n        marshaller.setMapping(getDefaultMapping());\n\n        //----------------------------------------------------------------------------------------\n        // \n        // 2007-10-01 SMF -- turning off validation during marshalling now required\n        // w/castor-1.1.2.1-xml.jar, otherwise, for some unknown reason, LWLink's\n        // with any connected endpoints cause validation exceptions when attempting to\n        // save.  E.g, from a map with one node and one link connected to it:\n        //\n        // ValidationException: The following exception occured while validating field: childList of class:\n        // tufts.vue.LWMap: The object associated with IDREF \"LWNode[2         \"New Node\"  +415,+24 69x22]\" of type\n        // class tufts.vue.LWNode has no ID!;\n        // - location of error: XPATH: /LW-MAP\n        // The object associated with IDREF \"LWNode[2         \"New Node\"  +415,+24 69x22]\" of type class tufts.vue.LWNode has no ID!\n        //\n        // Even tho the node's getID() is correctly returning \"2\"\n        //\n        marshaller.setValidation(false); \n        //----------------------------------------------------------------------------------------\n            \n        /*\n          Logger logger = new Logger(System.err);\n          logger.setPrefix(\"Castor \");\n          marshaller.setLogWriter(logger);\n        */\n        marshaller.setLogWriter(new PrintWriter(System.err));\n\n        // Make modifications to the map at the last minute, so any prior exceptions leave the map untouched.\n\n        final int oldModelVersion = map.getModelVersion();\n        final File oldSaveFile = map.getFile();\n        if (file != null) {\n            map.setModelVersion(LWMap.getCurrentModelVersion());\n            // note that if this file is different from it's last save file, this\n            // operation may cause any/all of the resources in the map to be\n            // updated before returning.\n            map.setFile(file);\n        }\n            \n        //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Marshalling \" + map + \" ...\");\n        Log.debug(\"marshalling \" + map + \" ...\");\n\n        try {\n            marshaller.marshal(map);\n            Log.debug(\"marshalled \" + map + \" to \" + writer + \"; file=\" + file);\n            writer.flush();\n            //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Completed marshalling \" + map);\n        } catch (Throwable t) {\n            try {\n                if (file != null) {\n                    // revert map model version & save file\n                    map.setModelVersion(oldModelVersion);\n                    map.setFile(oldSaveFile);\n                }\n            } catch (Throwable tx) {\n                Util.printStackTrace(tx);\n            } finally {\n                throw new WrappedMarshallException(t);\n            }\n        }\n            \n        if (file != null) {\n            map.markAsSaved();\n            Log.debug(\"saved \" + map + \" to \" + file);\n        }\n\n        //map.setFile(file);\n\n        //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Wrote \" + file);\n\n    }","commit_id":"3cff8c8f01852b46063624163c4a58f27ac3523e","url":"https://github.com/VUE/VUE"},{"original_method":"private static LWMap unmarshallMap(final java.net.URL url, Mapping mapping, String charsetEncoding, boolean allowOldFormat, String savingVersion)\n      //throws IOException, org.exolab.castor.mapping.MappingException, org.exolab.castor.xml.ValidationException\n        throws IOException\n    {\n        LWMap map = null;\n\n        //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"UNMARSHALLING: \" + url + \" charset=\" + charsetEncoding);\n        Log.debug(\"unmarshalling: \" + url + \"; charset=\" + charsetEncoding);\n        \n        BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream(), charsetEncoding));\n\n        // Skip over comments to get to start of XML\n\n        for (;;) {\n            reader.mark(2048); // a single comment line can't be longer than this...\n            String line = reader.readLine();\n            if (line == null) {\n                System.err.println(\"Unexpected end-of-stream in [\" + url + \"]\");\n                throw new java.io.IOException(\"end of stream in \" + url);\n            }\n            if (line.startsWith(\"<!--\") == false) {\n                // we should have just hit thie \"<?xml ...\" line -- done with comments\n                break;\n            }\n            if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Skipping[\" + line + \"]\");\n        }\n\n        // Reset the reader to the start of the last line read, which should be the <?xml line,\n        // which is what castor needs to see at start (it can't handle ignoring comments...)\n        reader.reset();\n\n        final String sourceName = url.toString();\n\n        try {\n            Unmarshaller unmarshaller = getDefaultUnmarshaller(mapping, sourceName);\n\n            // unmarshall the map:\n            \n            try {\n                map = (LWMap) unmarshaller.unmarshal(new InputSource(reader));\n            } catch (org.exolab.castor.xml.MarshalException me) {\n                //if (allowOldFormat && me.getMessage().endsWith(\"tufts.vue.Resource\")) {\n                //if (allowOldFormat && me.getMessage().indexOf(\"Unable to instantiate tufts.vue.Resource\") >= 0) {\n                // 2007-10-01 SMF: rev forward the special exception to check for once again in new castor version: castor-1.1.2.1-xml.jar\n                if (allowOldFormat && me.getMessage().indexOf(\"tufts.vue.Resource can no longer be constructed\") >= 0) {\n                    System.err.println(\"ActionUtil.unmarshallMap: \" + me);\n                    System.err.println(\"Attempting specialized MapResource mapping for old format.\");\n                    // NOTE: delicate recursion here: won't loop as long as we pass in a non-null mapping.\n                    return unmarshallMap(url, getMapping(XML_MAPPING_OLD_RESOURCES), charsetEncoding, false, savingVersion);\n                } else\n                    throw me;\n            }\n            \n            reader.close();\n\n            final File file = new File(url.getFile());\n            final String fileName = file.getName();\n\n            map.setFile(file); // VUE-713: do this always:\n\n            if (map.getModelVersion() > LWMap.getCurrentModelVersion()) {\n                VueUtil.alert(String.format(\"The file %s was saved in a newer version of VUE than is currently running.\\n\"\n                                            + \"\\nThe data model in this map is #%d, and this version of VUE only understands up to model #%d.\\n\",\n                                            file, map.getModelVersion(), LWMap.getCurrentModelVersion())\n                              + \"\\nVersion of VUE that saved this file:\\n        \" + savingVersion\n                              + \"\\nCurrent running version of VUE:\\n        \" + \"VUE: built \" + tufts.vue.Version.AllInfo\n                                + \" (public v\" + VueResources.getString(\"vue.version\") + \")\"\n                              + \"\\n\"\n                              + \"\\nThis version of VUE may not display this map properly.  Saving\"\n                              + \"\\nthis map in this version of VUE may result in a corrupted map.\"\n                              ,\n                              String.format(\"Version Warning: %s\", fileName));\n\n                map.setLabel(fileName + \" (as available)\");\n                // Skip setting the file: this will force save-as if they try to save.\n            } else {\n\n// VUE-713: don't do this conditionallly\n//                 // This setFile also sets the label name, so it appears as a modification in the map.\n//                 // So be sure to do completeXMLRestore last, as it will reset the modification count.\n//                 if (map.getModelVersion() < 1) {\n//                     map.setLabel(file.getName());\n//                     // force save as for old maps as they will no longer work in old stable versions of VUE (1.5 & prior)\n//                     // if they're saved in this new version of VUE.\n//                 } else {\n//                     map.setFile(file);\n//                 }\n                \n                if (DEBUG.Enabled) map.setLabel(\"|\" + map.getModelVersion() + \"| \" + map.getLabel());\n            }\n                \n\n            Log.debug(\"unmarshalled: \" + map);\n            // Note that map.setFile must have been done before map.completeXMLResource is called.\n            map.completeXMLRestore();\n            Log.debug(\"restored: \" + map);\n        }\n        catch (Exception e) {\n            tufts.Util.printStackTrace(e, \"Exception restoring map from [\" + url + \"]: \" + e.getClass().getName());\n            map = null;\n            throw new Error(\"Exception restoring map from [\" + url + \"]\", e);\n        }\n\n        \n        return map;\n    }","id":71643,"modified_method":"private static LWMap unmarshallMap(final java.net.URL url, Mapping mapping, String charsetEncoding, boolean allowOldFormat, String savingVersion)\n      //throws IOException, org.exolab.castor.mapping.MappingException, org.exolab.castor.xml.ValidationException\n        throws IOException\n    {\n        LWMap map = null;\n\n        //if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"UNMARSHALLING: \" + url + \" charset=\" + charsetEncoding);\n        Log.debug(\"unmarshalling: \" + url + \"; charset=\" + charsetEncoding);\n\n        final InputStream urlStream;\n\n        if (\"file\".equals(url.getProtocol()))\n            urlStream = url.openStream();\n        else\n            urlStream = tufts.vue.UrlAuthentication.getAuthenticatedConnection(url).getInputStream();\n        \n        final BufferedReader reader = new BufferedReader(new InputStreamReader(urlStream, charsetEncoding));\n\n        // Skip over comments to get to start of XML\n\n        for (;;) {\n            reader.mark(2048); // a single comment line can't be longer than this...\n            String line = reader.readLine();\n            if (line == null) {\n                System.err.println(\"Unexpected end-of-stream in [\" + url + \"]\");\n                throw new java.io.IOException(\"end of stream in \" + url);\n            }\n            if (line.startsWith(\"<!--\") == false) {\n                // we should have just hit thie \"<?xml ...\" line -- done with comments\n                break;\n            }\n            if (DEBUG.CASTOR || DEBUG.IO) System.out.println(\"Skipping[\" + line + \"]\");\n        }\n\n        // Reset the reader to the start of the last line read, which should be the <?xml line,\n        // which is what castor needs to see at start (it can't handle ignoring comments...)\n        reader.reset();\n\n        final String sourceName = url.toString();\n\n        try {\n            Unmarshaller unmarshaller = getDefaultUnmarshaller(mapping, sourceName);\n\n            // unmarshall the map:\n            \n            try {\n                map = (LWMap) unmarshaller.unmarshal(new InputSource(reader));\n            } catch (org.exolab.castor.xml.MarshalException me) {\n                //if (allowOldFormat && me.getMessage().endsWith(\"tufts.vue.Resource\")) {\n                //if (allowOldFormat && me.getMessage().indexOf(\"Unable to instantiate tufts.vue.Resource\") >= 0) {\n                // 2007-10-01 SMF: rev forward the special exception to check for once again in new castor version: castor-1.1.2.1-xml.jar\n                if (allowOldFormat && me.getMessage().indexOf(\"tufts.vue.Resource can no longer be constructed\") >= 0) {\n                    System.err.println(\"ActionUtil.unmarshallMap: \" + me);\n                    System.err.println(\"Attempting specialized MapResource mapping for old format.\");\n                    // NOTE: delicate recursion here: won't loop as long as we pass in a non-null mapping.\n                    return unmarshallMap(url, getMapping(XML_MAPPING_OLD_RESOURCES), charsetEncoding, false, savingVersion);\n                } else\n                    throw me;\n            }\n            \n            reader.close();\n\n            final File file = new File(url.getFile());\n            final String fileName = file.getName();\n\n            map.setFile(file); // VUE-713: do this always:\n\n            if (map.getModelVersion() > LWMap.getCurrentModelVersion()) {\n                VueUtil.alert(String.format(\"The file %s was saved in a newer version of VUE than is currently running.\\n\"\n                                            + \"\\nThe data model in this map is #%d, and this version of VUE only understands up to model #%d.\\n\",\n                                            file, map.getModelVersion(), LWMap.getCurrentModelVersion())\n                              + \"\\nVersion of VUE that saved this file:\\n        \" + savingVersion\n                              + \"\\nCurrent running version of VUE:\\n        \" + \"VUE: built \" + tufts.vue.Version.AllInfo\n                                + \" (public v\" + VueResources.getString(\"vue.version\") + \")\"\n                              + \"\\n\"\n                              + \"\\nThis version of VUE may not display this map properly.  Saving\"\n                              + \"\\nthis map in this version of VUE may result in a corrupted map.\"\n                              ,\n                              String.format(\"Version Warning: %s\", fileName));\n\n                map.setLabel(fileName + \" (as available)\");\n                // Skip setting the file: this will force save-as if they try to save.\n            } else {\n\n// VUE-713: don't do this conditionallly\n//                 // This setFile also sets the label name, so it appears as a modification in the map.\n//                 // So be sure to do completeXMLRestore last, as it will reset the modification count.\n//                 if (map.getModelVersion() < 1) {\n//                     map.setLabel(file.getName());\n//                     // force save as for old maps as they will no longer work in old stable versions of VUE (1.5 & prior)\n//                     // if they're saved in this new version of VUE.\n//                 } else {\n//                     map.setFile(file);\n//                 }\n                \n                if (DEBUG.DATA) map.setLabel(\"|\" + map.getModelVersion() + \"| \" + map.getLabel());\n            }\n                \n\n            Log.debug(\"unmarshalled: \" + map);\n            // Note that map.setFile must have been done before map.completeXMLResource is called.\n            map.completeXMLRestore();\n            Log.debug(\"restored: \" + map);\n        }\n        catch (Exception e) {\n            tufts.Util.printStackTrace(e, \"Exception restoring map from [\" + url + \"]: \" + e.getClass().getName());\n            map = null;\n            throw new Error(\"Exception restoring map from [\" + url + \"]\", e);\n        }\n\n        \n        return map;\n    }","commit_id":"3cff8c8f01852b46063624163c4a58f27ac3523e","url":"https://github.com/VUE/VUE"},{"original_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, final String fileType)\n    {\n        File picked = null;\n        final VueFileChooser chooser = new VueFileChooser();\n      JFileChooser choose = new JFileChooser();\n     \n        \n        chooser.setDialogTitle(title);\n        chooser.setAcceptAllFileFilterUsed(false);    \n        //chooser.set\n        chooser.addPropertyChangeListener(new PropertyChangeListener()\n        {\n\t\t\tpublic void propertyChange(PropertyChangeEvent arg0) {\t\t\t\t\n\t\t\t\tif (arg0.getPropertyName() == VueFileChooser.FILE_FILTER_CHANGED_PROPERTY)\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t\tString baseName = null;\n\t\t\t        if (VUE.getActiveMap().getFile() == null)\n\t\t\t        \tbaseName = VUE.getActiveMap().getLabel();\n\t\t\t        else\n\t\t\t        {\t\t\t        \t\n\t\t\t        \tbaseName = VUE.getActiveMap().getLabel();\n\t\t\t    \t\tif (baseName.indexOf(\".\") > 0)\n\t\t\t    \t\t\tbaseName = VUE.getActiveMap().getLabel().substring(0, baseName.lastIndexOf(\".\"));\n\t\t\t    \t\tbaseName = baseName.replaceAll(\"\\\\*\",\"\") + \"-copy\";\n\t\t\t        }\n\t\t\t     \n\t\t\t        if (fileType == null)\n\t\t\t        {\n\t\t\t        \tchooser.setSelectedFile(new File(baseName.replaceAll(\"\\\\*\", \"\")));\n\t\t\t        }\n\t\t\t\t}\n\t\t\t}\n        });\n        \n        if (fileType != null && !fileType.equals(\"export\"))\n         chooser.setFileFilter(new VueFileFilter(fileType)); \n        else if (fileType != null && fileType.equals(\"export\"))\n        {\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.JPEG_DESCRIPTION));\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.PNG_DESCRIPTION));\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.SVG_DESCRIPTION));        \t\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMS_DESCRIPTION));\n        \tchooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMAGEMAP_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.ZIP_DESCRIPTION));\n        \t\n        }\n        else\n        {\n            VueFileFilter defaultFilter = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n            \n            chooser.addChoosableFileFilter(defaultFilter);  \n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMAGEMAP_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"PDF\"));\n            \n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.JPEG_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.PNG_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.SVG_DESCRIPTION));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"html\"));\n            \n            chooser.addChoosableFileFilter(new VueFileFilter(\"RDF\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMS_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.ZIP_DESCRIPTION));\n            \n            //chooser.addChoosableFileFilter(new VueFileFilter(\"HTML Outline\", \"htm\"));\n            \n            chooser.setFileFilter(defaultFilter); \n        }\n         \n    //    JPanel p1 = (JPanel)chooser.getComponent(2);\n      //  JPanel p2 = (JPanel)p1.getComponent(2);\n       // JPanel p3 = (JPanel)p2.getComponent(2);\n       // JComboBox box = (JComboBox)p3.getComponent(3);\n        //box.g\n       // box.setRenderer(new PaddedCellRenderer());\n        \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(VUE.getDialogParentAsFrame(), \"Save\");\n        \n        if (option == VueFileChooser.APPROVE_OPTION) \n        {\n            picked = chooser.getSelectedFile();\n            \n            String fileName = picked.getAbsolutePath();\n            //String extension = chooser.getFileFilter().getDescription();\n              String extension = ((VueFileFilter)chooser.getFileFilter()).getExtensions()[0];  \n            //if it isn't a file name with the right extension \n            if (!fileName.endsWith(\".\" + extension)) {\n                fileName += \".\" + extension;\n                picked = new File(fileName);\n            }\n            \n            if (picked.exists()) {\n                int n = JOptionPane.showConfirmDialog(null, VueResources.getString(\"replaceFile.text\") + \" \\'\" + picked.getName() + \"\\'\", \n                        VueResources.getString(\"replaceFile.title\"), JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                    picked = null;\n            } \n            \n            if (picked != null)\n                VueUtil.setCurrentDirectoryPath(picked.getParent());\n        }\n        \n        return picked;\n    }","id":71644,"modified_method":"/**A static method which displays a file chooser for the user to choose which file to save into.\n       It returns the selected file or null if the process didn't complete*/\n    public static File selectFile(String title, final String fileType)\n    {\n        File picked = null;\n        final VueFileChooser chooser = new VueFileChooser();\n      JFileChooser choose = new JFileChooser();\n     \n        \n        chooser.setDialogTitle(title);\n        chooser.setAcceptAllFileFilterUsed(false);    \n        //chooser.set\n        chooser.addPropertyChangeListener(new PropertyChangeListener()\n        {\n\t\t\tpublic void propertyChange(PropertyChangeEvent arg0) {\t\t\t\t\n\t\t\t\tif (arg0.getPropertyName() == VueFileChooser.FILE_FILTER_CHANGED_PROPERTY)\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t\tString baseName = null;\n\t\t\t        if (VUE.getActiveMap().getFile() == null)\n\t\t\t        \tbaseName = VUE.getActiveMap().getLabel();\n\t\t\t        else\n\t\t\t        {\t\t\t        \t\n\t\t\t        \tbaseName = VUE.getActiveMap().getLabel();\n\t\t\t    \t\tif (baseName.indexOf(\".\") > 0)\n\t\t\t    \t\t\tbaseName = VUE.getActiveMap().getLabel().substring(0, baseName.lastIndexOf(\".\"));\n\t\t\t    \t\tbaseName = baseName.replaceAll(\"\\\\*\",\"\") + \"-copy\";\n\t\t\t        }\n\t\t\t     \n\t\t\t        if (fileType == null)\n\t\t\t        {\n\t\t\t        \tchooser.setSelectedFile(new File(baseName.replaceAll(\"\\\\*\", \"\")));\n\t\t\t        }\n\t\t\t\t}\n\t\t\t}\n        });\n        \n        if (fileType != null && !fileType.equals(\"export\"))\n         chooser.setFileFilter(new VueFileFilter(fileType)); \n        else if (fileType != null && fileType.equals(\"export\"))\n        {\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.JPEG_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.PNG_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.SVG_DESCRIPTION));        \t\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMS_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMAGEMAP_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.ZIP_DESCRIPTION));\n        }\n        else\n        {\n            VueFileFilter defaultFilter = new VueFileFilter(VueFileFilter.VUE_DESCRIPTION);\n            \n            chooser.addChoosableFileFilter(defaultFilter);  \n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.VPK_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMAGEMAP_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(\"PDF\"));\n            \n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.JPEG_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.PNG_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.SVG_DESCRIPTION));\n            //chooser.addChoosableFileFilter(new VueFileFilter(\"html\"));\n            \n            chooser.addChoosableFileFilter(new VueFileFilter(\"RDF\"));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.IMS_DESCRIPTION));\n            chooser.addChoosableFileFilter(new VueFileFilter(VueFileFilter.ZIP_DESCRIPTION));\n            \n            //chooser.addChoosableFileFilter(new VueFileFilter(\"HTML Outline\", \"htm\"));\n            \n            chooser.setFileFilter(defaultFilter); \n        }\n         \n    //    JPanel p1 = (JPanel)chooser.getComponent(2);\n      //  JPanel p2 = (JPanel)p1.getComponent(2);\n       // JPanel p3 = (JPanel)p2.getComponent(2);\n       // JComboBox box = (JComboBox)p3.getComponent(3);\n        //box.g\n       // box.setRenderer(new PaddedCellRenderer());\n        \n        if(VueUtil.isCurrentDirectoryPathSet()) \n          chooser.setCurrentDirectory(new File(VueUtil.getCurrentDirectoryPath()));  \n        \n        int option = chooser.showDialog(VUE.getDialogParentAsFrame(), \"Save\");\n        \n        if (option == VueFileChooser.APPROVE_OPTION) \n        {\n            picked = chooser.getSelectedFile();\n            \n            String fileName = picked.getAbsolutePath();\n            //String extension = chooser.getFileFilter().getDescription();\n              String extension = ((VueFileFilter)chooser.getFileFilter()).getExtensions()[0];  \n            //if it isn't a file name with the right extension \n            if (!fileName.endsWith(\".\" + extension)) {\n                fileName += \".\" + extension;\n                picked = new File(fileName);\n            }\n            \n            if (picked.exists()) {\n                int n = JOptionPane.showConfirmDialog(null, VueResources.getString(\"replaceFile.text\") + \" \\'\" + picked.getName() + \"\\'\", \n                        VueResources.getString(\"replaceFile.title\"), JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n                  \n                if (n == JOptionPane.NO_OPTION)\n                    picked = null;\n            } \n            \n            if (picked != null)\n                VueUtil.setCurrentDirectoryPath(picked.getParent());\n        }\n        \n        return picked;\n    }","commit_id":"3cff8c8f01852b46063624163c4a58f27ac3523e","url":"https://github.com/VUE/VUE"},{"original_method":"private void fixNullValueInModel( Model modelToFix, Model correctModel )\n    {\n        modelToFix.setModelVersion( correctModel.getModelVersion() );\n        modelToFix.setName( correctModel.getName() );\n        modelToFix.setParent( cloneParent( correctModel.getParent() ) );\n        modelToFix.setVersion( correctModel.getVersion() );\n        modelToFix.setArtifactId( correctModel.getArtifactId() );\n        modelToFix.setProperties( new Properties( correctModel.getProperties() ) );\n        modelToFix.setGroupId( correctModel.getGroupId() );\n        modelToFix.setPackaging( correctModel.getPackaging() );\n        modelToFix.setModules( cloneModules( correctModel.getModules() ) );\n        modelToFix.setDistributionManagement( correctModel.getDistributionManagement() );\n    }","id":71645,"modified_method":"private void fixNullValueInModel( Model modelToFix, Model correctModel )\n    {\n        if ( modelToFix.getModelVersion() != null )\n        {\n            modelToFix.setModelVersion( correctModel.getModelVersion() );\n        }\n\n        if ( modelToFix.getName() != null )\n        {\n            modelToFix.setName( correctModel.getName() );\n        }\n\n        if ( modelToFix.getParent() != null )\n        {\n            modelToFix.setParent( cloneParent( correctModel.getParent() ) );\n        }\n\n        if ( modelToFix.getVersion() != null )\n        {\n            modelToFix.setVersion( correctModel.getVersion() );\n        }\n\n        if ( modelToFix.getArtifactId() != null )\n        {\n            modelToFix.setArtifactId( correctModel.getArtifactId() );\n        }\n\n        if ( modelToFix.getProperties() != null && modelToFix.getProperties().isEmpty() )\n        {\n            modelToFix.setProperties( new Properties( correctModel.getProperties() ) );\n        }\n\n        if ( modelToFix.getGroupId() != null )\n        {\n            modelToFix.setGroupId( correctModel.getGroupId() );\n        }\n\n        if ( modelToFix.getPackaging() != null )\n        {\n            modelToFix.setPackaging( correctModel.getPackaging() );\n        }\n\n        if ( modelToFix.getModules() != null && !modelToFix.getModules().isEmpty() )\n        {\n            modelToFix.setModules( cloneModules( correctModel.getModules() ) );\n        }\n\n        if ( modelToFix.getDistributionManagement() != null )\n        {\n            modelToFix.setDistributionManagement( correctModel.getDistributionManagement() );\n        }\n    }","commit_id":"d72b1ae50c53e32e25d0d2d6f277e40008a1f97c","url":"https://github.com/apache/maven"},{"original_method":"/**\n     * Strategy for validating if the given remote file should be included or not\n     *\n     * @param file         the remote file\n     * @param isDirectory  wether the file is a directory or a file\n     * @return <tt>true<\/tt> to include the file, <tt>false<\/tt> to skip it\n     */\n    protected boolean isValidFile(RemoteFile file, boolean isDirectory) {\n        if (!isMatched(file, isDirectory)) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Remote file did not match. Will skip this remote file: \" + file);\n            }\n            return false;\n        } else if (endpoint.isIdempotent() && endpoint.getIdempotentRepository().contains(file.getAbsolutelFileName())) {\n            // use file.getAbsoluteFileName as key for the idempotent repository to support files with same name but in different folders\n            log.warn(\"RemoteFileConsumer is idempotent and the file has been consumed before. Will skip this remote file: \" + file);\n            return false;\n        }\n\n        // file matched\n        return true;\n    }","id":71646,"modified_method":"/**\n     * Strategy for validating if the given remote file should be included or not\n     *\n     * @param file         the remote file\n     * @param isDirectory  wether the file is a directory or a file\n     * @return <tt>true<\/tt> to include the file, <tt>false<\/tt> to skip it\n     */\n    protected boolean isValidFile(RemoteFile file, boolean isDirectory) {\n        if (!isMatched(file, isDirectory)) {\n            if (log.isTraceEnabled()) {\n                log.trace(\"Remote file did not match. Will skip this remote file: \" + file);\n            }\n            return false;\n        } else if (endpoint.isIdempotent() && endpoint.getIdempotentRepository().contains(file.getAbsolutelFileName())) {\n            // use file.getAbsoluteFileName as key for the idempotent repository to support files with same name but in different folders\n            if (log.isTraceEnabled()) {\n                log.trace(\"RemoteFileConsumer is idempotent and the file has been consumed before. Will skip this remote file: \" + file);\n            }\n            return false;\n        }\n\n        // file matched\n        return true;\n    }","commit_id":"a87071788935181888a02adf7e399b6186a61466","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Process a downward event.\n     * @param evt The event.\n     */\n    public Object down(Event evt) {\n        try {\n            // If not a MSG, just pass down.\n            if (evt.getType()!=Event.MSG) {\n                return down_prot.down(evt);\n            }\n            \n            Message msg = (Message) evt.getArg();\n            \n            // If unicast, just pass down.\n            if (msg.getDest()!=null && ! msg.getDest().isMulticastAddress()) {\n                return down_prot.down(evt);\n            }\n    \n            // Multicast MSG:\n            // - if enabled, get the next time vector, add it and pass down;\n            // - otherwise, add to the downward waiting queue.\n            TransportedVectorTime tvt=null;\n            \n            synchronized(lock) {\n                if (isEnabled()) {\n                    currentView.increment();\n                    tvt=currentView.getTransportedVectorTime();\n                    if (log.isDebugEnabled()) log.debug(\"Sent 1 down message @ \"+currentView.timeVectorString());\n                } else {\n                    if (log.isDebugEnabled()) log.debug(\"Enqueued 1 down message...\");\n                    downwardWaitingQueue.add(evt);\n                }\n            }\n            \n            if (tvt!=null) {\n                msg.putHeader(getName(), new CausalHeader(tvt));\n                return down_prot.down(evt);\n            }\n        } catch (RuntimeException e) {\n            if (debug) log.error(\"*** down: \"+e.getMessage(), e);\n            throw e;\n        }\n\n        return null;\n    }","id":71647,"modified_method":"/**\n     * Process a downward event.\n     * @param evt The event.\n     */\n    public Object down(Event evt) {\n        try {\n            // If not a MSG, just pass down.\n            if (evt.getType()!=Event.MSG) {\n                return down_prot.down(evt);\n            }\n            \n            Message msg = (Message) evt.getArg();\n            \n            // If unicast, just pass down.\n            if (msg.getDest()!=null && ! msg.getDest().isMulticastAddress()) {\n                return down_prot.down(evt);\n            }\n    \n            // Multicast MSG:\n            // - if enabled, get the next time vector, add it and pass down;\n            // - otherwise, add to the downward waiting queue.\n            TransportedVectorTime tvt=null;\n            \n            synchronized(lock) {\n                if (isEnabled()) {\n                    currentView.increment();\n                    tvt=currentView.getTransportedVectorTime();\n                    if (log.isTraceEnabled()) log.trace(\"Sent 1 down message @ \"+currentView.timeVectorString());\n                } else {\n                    if (log.isTraceEnabled()) log.trace(\"Enqueued 1 down message...\");\n                    downwardWaitingQueue.add(evt);\n                }\n            }\n            \n            if (tvt!=null) {\n                msg.putHeader(getName(), new CausalHeader(tvt));\n                return down_prot.down(evt);\n            }\n        } catch (RuntimeException e) {\n            if (debug) log.error(\"*** down: \"+e.getMessage(), e);\n            throw e;\n        }\n\n        return null;\n    }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Process a VIEW_CHANGE event.\n     * @param evt The event.\n     */\n    private void upViewChange(Event evt)\n    {\n        View view=(View)evt.getArg();      \n        InternalView iView=new InternalView(view.getVid(), view.getMembers(), localAddress);\n\n        log.warn(\"New view: \"+view);\n        \n        synchronized(lock) {\n            // Disable sending\n            disable();\n            \n            // Create new causal view\n            NewCausalView newView=new NewCausalView(currentView, iView);\n            if (currentView!=null) {\n                currentView.clearFinalTimeVector();\n                newView.setMemberLocalTime(localAddress, currentView.getLocalTime());\n            } else {\n                newView.setMemberLocalTime(localAddress, 0);\n            }\n            \n            if (log.isWarnEnabled()) log.warn(\"Starting synchronization thread for \"+newView);\n            \n            newViewThread=new NewViewThread(newView);\n            newViewThread.start();\n        }\n        \n        up_prot.up(evt);\n    }","id":71648,"modified_method":"/**\n     * Process a VIEW_CHANGE event.\n     * @param evt The event.\n     */\n    private void upViewChange(Event evt)\n    {\n        View view=(View)evt.getArg();      \n        InternalView iView=new InternalView(view.getVid(), view.getMembers(), localAddress);\n        if(log.isDebugEnabled())\n            log.debug(\"New view: \"+view);\n        \n        synchronized(lock) {\n            // Disable sending\n            disable();\n            \n            // Create new causal view\n            NewCausalView newView=new NewCausalView(currentView, iView);\n            if (currentView!=null) {\n                currentView.clearFinalTimeVector();\n                newView.setMemberLocalTime(localAddress, currentView.getLocalTime());\n            } else {\n                newView.setMemberLocalTime(localAddress, 0);\n            }\n            \n            if (log.isTraceEnabled()) log.trace(\"Starting synchronization thread for \"+newView);\n            \n            newViewThread=new NewViewThread(newView);\n            newViewThread.start();\n        }\n        \n        up_prot.up(evt);\n    }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void setFinalTimeVector(InternalView newView, int startTimeVector[]) {\n            finalTimeVector=new int[timeVector.length];\n            System.arraycopy(timeVector, 0, finalTimeVector, 0, timeVector.length);\n            \n            for(int i=0;i<view.size();i++) {\n                Address member=view.getMember(i);\n                int startIndex=newView.getIndex(member);\n                if (startIndex<0) continue; // Member disappeared, keep existing time.\n                finalTimeVector[i]=startTimeVector[startIndex]; // update the final time vector.\n            }\n            \n            if (log.isInfoEnabled()) log.info(this+\": final vector time set @ \"+timeVectorString());\n        }","id":71649,"modified_method":"public synchronized void setFinalTimeVector(InternalView newView, int startTimeVector[]) {\n            finalTimeVector=new int[timeVector.length];\n            System.arraycopy(timeVector, 0, finalTimeVector, 0, timeVector.length);\n            \n            for(int i=0;i<view.size();i++) {\n                Address member=view.getMember(i);\n                int startIndex=newView.getIndex(member);\n                if (startIndex<0) continue; // Member disappeared, keep existing time.\n                finalTimeVector[i]=startTimeVector[startIndex]; // update the final time vector.\n            }\n            \n            if (log.isTraceEnabled())\n                log.trace(this+\": final vector time set @ \"+timeVectorString());\n        }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n            if(t == null)\n            {\n                out.writeBoolean(false);\n                return;\n            }\n            out.writeBoolean(true);\n\n            out.write(t.senderPosition);\n            \n            int values[]=t.values;\n            \n            int len=values.length;\n            out.write(len);\n            for(int i=0;i<len;i++) out.write(values[i]);\n        }","id":71650,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n            if(t == null)\n            {\n                out.writeBoolean(false);\n                return;\n            }\n            out.writeBoolean(true);\n\n            out.writeInt(t.senderPosition);\n            \n            int values[]=t.values;\n            \n            int len=values.length;\n            out.writeInt(len);\n            for(int i=0;i<len;i++) out.writeInt(values[i]);\n        }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            boolean sendUpdate=false, complete=false;\n            LinkedList flush=null;\n\n            for(;;) {\n                Message update=null;\n\n                synchronized(lock) {\n                    if(this != newViewThread) {\n                        break;\n                    }\n\n                    if(newView.hasMissingTimes()) {\n                        sendUpdate=true;\n                    }\n                    else\n                    if(currentView == null || (!currentView.getViewId().equals(newView.getViewId()) && currentView.hasEnded()))\n                    {\n                        currentView=new ActiveCausalView(newView.getView(), newView.timeVector);\n                        complete=true;\n                        newView.setMemberCompleted(localAddress);\n\n                        if(log.isInfoEnabled())\n                            log.info(\"Set up new active view: \" + currentView + \" @ \" + currentView.timeVectorString());\n                    }\n\n                    if(newView.hasMissingCompletions()) {\n                        sendUpdate=true;\n                    }\n                    else {\n                        newViewThread=null;\n                        enabled=true;\n                        flush=(LinkedList)downwardWaitingQueue.clone();\n                        downwardWaitingQueue.clear();\n\n                        if(log.isInfoEnabled())\n                            log.info(\"Done synchronizing, enabled view: \" + currentView + \" @ \" + currentView.timeVectorString());\n\n                        break;\n                    }\n\n                    if(sendUpdate) {\n                        update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(newView.getViewId(), newView.getLocalTime(), complete));\n                        update.setObject(new MissingIndexesMessage(newView.getMissingTimes(), newView.getMissingCompletions()));\n                    }\n                }\n\n                if(update != null) {\n                    log.warn(\"Sending sync update\");\n\n                    down_prot.down(new Event(Event.MSG, update));\n                }\n\n                synchronized(this) {\n                    // Wait for 50ms\n                    try {\n                        wait(500);\n                    }\n                    catch(InterruptedException e) {\n                        Thread.currentThread().interrupt(); // set interrupt flag again\n                        // Ignore\n                        log.warn(\"Interrupted?!?\", e);\n                    }\n\n                    sendUpdate=updateRequested;\n                    updateRequested=false;\n                }\n            }\n            \n            if (flush!=null) {\n                int n=flush.size();\n                if (log.isInfoEnabled()) log.info(\"Flushing \"+n+\" messages down...\");\n                \n                while(!flush.isEmpty()) {\n                    Event evt=(Event)flush.removeFirst();\n                    down(evt);\n                }\n                \n                if (log.isDebugEnabled()) log.debug(\"Done flushing \"+n+\" messages down...\");\n            }\n        }","id":71651,"modified_method":"public void run() {\n            boolean sendUpdate=false, complete=false;\n            LinkedList flush=null;\n\n            for(;;) {\n                Message update=null;\n\n                synchronized(lock) {\n                    if(this != newViewThread) {\n                        break;\n                    }\n\n                    if(newView.hasMissingTimes()) {\n                        sendUpdate=true;\n                    }\n                    else\n                    if(currentView == null || (!currentView.getViewId().equals(newView.getViewId()) && currentView.hasEnded()))\n                    {\n                        currentView=new ActiveCausalView(newView.getView(), newView.timeVector);\n                        complete=true;\n                        newView.setMemberCompleted(localAddress);\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"Set up new active view: \" + currentView + \" @ \" + currentView.timeVectorString());\n                    }\n\n                    if(newView.hasMissingCompletions()) {\n                        sendUpdate=true;\n                    }\n                    else {\n                        newViewThread=null;\n                        enabled=true;\n                        flush=(LinkedList)downwardWaitingQueue.clone();\n                        downwardWaitingQueue.clear();\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"Done synchronizing, enabled view: \" + currentView + \" @ \" + currentView.timeVectorString());\n\n                        break;\n                    }\n\n                    if(sendUpdate) {\n                        update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(newView.getViewId(), newView.getLocalTime(), complete));\n                        update.setObject(new MissingIndexesMessage(newView.getMissingTimes(), newView.getMissingCompletions()));\n                    }\n                }\n\n                if(update != null) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"Sending sync update\");\n                    down_prot.down(new Event(Event.MSG, update));\n                }\n\n                synchronized(this) {\n                    // Wait for 50ms\n                    try {\n                        wait(500);\n                    }\n                    catch(InterruptedException e) {\n                        Thread.currentThread().interrupt(); // set interrupt flag again\n                        // Ignore\n                        log.warn(\"Interrupted?!?\", e);\n                    }\n\n                    sendUpdate=updateRequested;\n                    updateRequested=false;\n                }\n            }\n            \n            if (flush!=null) {\n                int n=flush.size();\n                if (log.isDebugEnabled()) log.debug(\"Flushing \"+n+\" messages down...\");\n                \n                while(!flush.isEmpty()) {\n                    Event evt=(Event)flush.removeFirst();\n                    down(evt);\n                }\n                \n                if (log.isDebugEnabled()) log.debug(\"Done flushing \"+n+\" messages down...\");\n            }\n        }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void setMemberLocalTime(Address address, int time) {\n            if (missingTimes.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            timeVector[index]=time;           \n            missingTimes.remove(new Integer(index));\n            \n            if (missingTimes.isEmpty()) {\n                if (active!=null) active.setFinalTimeVector(view, timeVector);                        \n                if (log.isInfoEnabled()) log.info(this+\" has all the times\");\n            } else {\n                if (log.isDebugEnabled()) log.debug(this+\" missing times: \"+missingTimes);\n            }\n        }","id":71652,"modified_method":"public synchronized void setMemberLocalTime(Address address, int time) {\n            if (missingTimes.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            timeVector[index]=time;           \n            missingTimes.remove(new Integer(index));\n            \n            if (missingTimes.isEmpty()) {\n                if (active!=null) active.setFinalTimeVector(view, timeVector);                        \n                if (log.isTraceEnabled()) log.trace(this+\" has all the times\");\n            }\n            else {\n                if (log.isTraceEnabled()) log.trace(this+\" missing times: \"+missingTimes);\n            }\n        }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void setMemberCompleted(Address address) {\n            if (missingCompletions.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            missingCompletions.remove(new Integer(index));\n            \n            if (missingCompletions.isEmpty()) {\n                if (log.isInfoEnabled()) log.info(this+\" has all the completions\");\n            } else {\n                if (log.isDebugEnabled()) log.debug(this+\" missing completions: \"+missingCompletions);\n            }\n        }","id":71653,"modified_method":"public synchronized void setMemberCompleted(Address address) {\n            if (missingCompletions.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            missingCompletions.remove(new Integer(index));\n            \n            if (missingCompletions.isEmpty()) {\n                if (log.isTraceEnabled()) log.trace(this+\" has all the completions\");\n            } else {\n                if (log.isTraceEnabled()) log.trace(this+\" missing completions: \"+missingCompletions);\n            }\n        }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void max(TransportedVectorTime vector) {\n            int otherTimeVector[]=vector.getValues();\n            \n            if (otherTimeVector.length!=timeVector.length) {\n                log.warn(\"max: got message with wrong time vector length: \"+otherTimeVector.length+\", expected: \"+timeVector.length);\n                return;\n            }\n            \n            for(int i=0;i<timeVector.length;i++) {\n                if (otherTimeVector[i]>timeVector[i]) timeVector[i]=otherTimeVector[i];\n            }\n        }","id":71654,"modified_method":"public synchronized void max(TransportedVectorTime vector) {\n            int otherTimeVector[]=vector.getValues();\n            \n            if (otherTimeVector.length!=timeVector.length) {\n                if(log.isWarnEnabled())\n                    log.warn(\"max: got message with wrong time vector length: \"+otherTimeVector.length+\", expected: \"+\n                            timeVector.length);\n                return;\n            }\n            \n            for(int i=0;i<timeVector.length;i++) {\n                if (otherTimeVector[i]>timeVector[i]) timeVector[i]=otherTimeVector[i];\n            }\n        }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"private Object upMsg(Event evt) {\n        Message msg = (Message) evt.getArg();\n        Address src=msg.getSrc();\n        \n        // Check for a causal new view header\n        Object obj = msg.getHeader(CausalNewViewHeader.NAME);\n\n        if (obj instanceof CausalNewViewHeader) {\n            processNewViewSynchronization(src, (CausalNewViewHeader)obj, msg.getObject());           \n            return null;\n        }\n        \n        obj = msg.getHeader(getName());\n\n        if (!(obj instanceof CausalHeader)) {\n            if((msg.getDest() == null || msg.getDest().isMulticastAddress()) \n                    && log.isErrorEnabled()) log.error(\"NO CAUSAL.Header found\");\n            return up_prot.up(evt);\n        }\n        \n        TransportedVectorTime messageVector = ((CausalHeader)obj).getVectorTime();\n        \n        synchronized (lock) {\n            if (currentView==null||currentView.getView().getIndex(src)<0) {\n                if (log.isDebugEnabled()) log.debug(\"Discarding \"+obj+\" from \"+msg.getSrc());\n                return null;\n            }\n            \n            if (currentView.isCausallyNext(messageVector)) {\n                if (log.isDebugEnabled()) log.debug(\"passing up message \"+msg+\", headers are \"+msg.printHeaders()+\", local vector is \"+currentView.timeVectorString());\n                up_prot.up(evt);\n                currentView.max(messageVector);\n            } else  {\n                if (log.isDebugEnabled()) log.debug(\"queuing message \"+msg+\", headers are \"+msg.printHeaders());\n                messageVector.setAssociatedMessage(msg);\n                addToDelayQueue(messageVector);\n            }\n            \n            TransportedVectorTime queuedVector = null;\n            \n            while ((!upwardWaitingQueue.isEmpty()) &&\n                    currentView.isCausallyNext((queuedVector = (TransportedVectorTime) upwardWaitingQueue.getFirst()))) {\n                upwardWaitingQueue.remove(queuedVector);\n                Message tmp=queuedVector.getAssociatedMessage();\n                if (log.isDebugEnabled()) log.debug(\"released message \"+tmp+\", headers are \"+tmp.printHeaders());\n                up_prot.up(new Event(Event.MSG, tmp));\n                currentView.max(queuedVector);\n            }\n        }\n        return null;\n    }","id":71655,"modified_method":"private Object upMsg(Event evt) {\n        Message msg = (Message) evt.getArg();\n        Address src=msg.getSrc();\n        \n        // Check for a causal new view header\n        Object obj = msg.getHeader(CausalNewViewHeader.NAME);\n\n        if (obj instanceof CausalNewViewHeader) {\n            processNewViewSynchronization(src, (CausalNewViewHeader)obj, msg.getObject());           \n            return null;\n        }\n        \n        obj = msg.getHeader(getName());\n\n        if (!(obj instanceof CausalHeader)) {\n            if((msg.getDest() == null || msg.getDest().isMulticastAddress()) \n                    && log.isErrorEnabled()) log.error(\"NO CAUSAL.Header found\");\n            return up_prot.up(evt);\n        }\n        \n        TransportedVectorTime messageVector = ((CausalHeader)obj).getVectorTime();\n        \n        synchronized (lock) {\n            if (currentView==null||currentView.getView().getIndex(src)<0) {\n                if (log.isDebugEnabled()) log.debug(\"Discarding \"+obj+\" from \"+msg.getSrc());\n                return null;\n            }\n            \n            if (currentView.isCausallyNext(messageVector)) {\n                if (log.isTraceEnabled()) log.trace(\"passing up message \"+msg+\", headers are \"+msg.printHeaders()+\", local vector is \"+currentView.timeVectorString());\n                up_prot.up(evt);\n                currentView.max(messageVector);\n            } else  {\n                if (log.isTraceEnabled()) log.trace(\"queuing message \"+msg+\", headers are \"+msg.printHeaders());\n                messageVector.setAssociatedMessage(msg);\n                addToDelayQueue(messageVector);\n            }\n            \n            TransportedVectorTime queuedVector = null;\n            \n            while ((!upwardWaitingQueue.isEmpty()) &&\n                    currentView.isCausallyNext((queuedVector = (TransportedVectorTime) upwardWaitingQueue.getFirst()))) {\n                upwardWaitingQueue.remove(queuedVector);\n                Message tmp=queuedVector.getAssociatedMessage();\n                if (log.isTraceEnabled()) log.trace(\"released message \"+tmp+\", headers are \"+tmp.printHeaders());\n                up_prot.up(new Event(Event.MSG, tmp));\n                currentView.max(queuedVector);\n            }\n        }\n        return null;\n    }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized boolean isCausallyNext(TransportedVectorTime vector) {\n            int senderIndex = vector.getSenderIndex();\n\n            if (senderIndex == view.getLocalIndex()) return true;\n\n            int[] otherTimeVector = vector.getValues();\n\n            if (otherTimeVector.length!=timeVector.length) {\n                log.warn(\"isCausallyNext: got message with wrong time vector length: \"+otherTimeVector.length+\", expected: \"+timeVector.length);\n                return true;\n            }\n            \n            boolean nextCausalFromSender = false;\n            boolean nextCausal = true;\n\n            for (int i=0;i<timeVector.length;i++) {\n               if ((i == senderIndex) && (otherTimeVector[i] == timeVector[i] + 1)) {\n                  nextCausalFromSender = true;\n                  continue;\n               }\n               if (i == view.getLocalIndex()) continue;\n               if (otherTimeVector[i] > timeVector[i]) nextCausal = false;\n            }\n            \n            return (nextCausalFromSender && nextCausal);\n        }","id":71656,"modified_method":"public synchronized boolean isCausallyNext(TransportedVectorTime vector) {\n            int senderIndex = vector.getSenderIndex();\n\n            if (senderIndex == view.getLocalIndex()) return true;\n\n            int[] otherTimeVector = vector.getValues();\n\n            if (otherTimeVector.length!=timeVector.length) {\n                if(log.isWarnEnabled())\n                    log.warn(\"isCausallyNext: got message with wrong time vector length: \"+otherTimeVector.length+\n                            \", expected: \"+timeVector.length);\n                return true;\n            }\n            \n            boolean nextCausalFromSender = false;\n            boolean nextCausal = true;\n\n            for (int i=0;i<timeVector.length;i++) {\n               if ((i == senderIndex) && (otherTimeVector[i] == timeVector[i] + 1)) {\n                  nextCausalFromSender = true;\n                  continue;\n               }\n               if (i == view.getLocalIndex()) continue;\n               if (otherTimeVector[i] > timeVector[i]) nextCausal = false;\n            }\n            \n            return (nextCausalFromSender && nextCausal);\n        }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * \n     */\n    private void processNewViewSynchronization(Address src, CausalNewViewHeader header, Object object) {\n        // If from ourselves, ignore.\n        if (localAddress.equals(src)) return;\n        \n        MissingIndexesMessage content=(MissingIndexesMessage)object;\n        \n        log.warn(\"Got sync update from \"+src);\n        \n        synchronized(lock) {\n            if (newViewThread==null) {\n                if (currentView!=null&&currentView.getView().getViewId().equals(header.newViewId)) {\n                    // Somebody's late...\n                    int localIndex=currentView.getLocalIndex();\n                    \n                    if (Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0) {\n                        Message update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(currentView.getView().getViewId(), 0, true)); // It has the time already\n                        update.setObject(new MissingIndexesMessage(Collections.EMPTY_LIST, Collections.EMPTY_LIST));\n                        \n                        down_prot.down(new Event(Event.MSG, update));\n                    }\n                    \n                    if (Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0) {\n                        \n                    }\n                } else {\n                    // Somebody's early...\n                    disable();\n                }\n                return;\n            }\n            \n            if (!newViewThread.getCausalView().getViewId().equals(header.newViewId)) return;\n        \n            if (log.isDebugEnabled()) log.debug(\"From \"+src+\": \"+header);\n\n            // Update the local time and completion status for the source.\n            newViewThread.getCausalView().setMemberLocalTime(src, header.localTime);\n            if (header.isComplete()) newViewThread.getCausalView().setMemberCompleted(src);\n            \n            // Check the requested times and completions\n            int localIndex=newViewThread.getCausalView().getLocalIndex();\n            \n            if ( Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0\n                    || Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0 ) {\n                newViewThread.updateRequested();\n            }\n        }      \n    }","id":71657,"modified_method":"/**\n     * \n     */\n    private void processNewViewSynchronization(Address src, CausalNewViewHeader header, Object object) {\n        // If from ourselves, ignore.\n        if (localAddress.equals(src)) return;\n        \n        MissingIndexesMessage content=(MissingIndexesMessage)object;\n\n        if(log.isTraceEnabled())\n            log.trace(\"Got sync update from \"+src);\n        \n        synchronized(lock) {\n            if (newViewThread==null) {\n                if (currentView!=null&&currentView.getView().getViewId().equals(header.newViewId)) {\n                    // Somebody's late...\n                    int localIndex=currentView.getLocalIndex();\n                    \n                    if (Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0) {\n                        Message update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(currentView.getView().getViewId(), 0, true)); // It has the time already\n                        update.setObject(new MissingIndexesMessage(Collections.EMPTY_LIST, Collections.EMPTY_LIST));\n                        \n                        down_prot.down(new Event(Event.MSG, update));\n                    }\n                    \n                    if (Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0) {\n                        \n                    }\n                } else {\n                    // Somebody's early...\n                    disable();\n                }\n                return;\n            }\n            \n            if (!newViewThread.getCausalView().getViewId().equals(header.newViewId)) return;\n        \n            if (log.isTraceEnabled()) log.trace(\"From \"+src+\": \"+header);\n\n            // Update the local time and completion status for the source.\n            newViewThread.getCausalView().setMemberLocalTime(src, header.localTime);\n            if (header.isComplete()) newViewThread.getCausalView().setMemberCompleted(src);\n            \n            // Check the requested times and completions\n            int localIndex=newViewThread.getCausalView().getLocalIndex();\n            \n            if ( Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0\n                    || Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0 ) {\n                newViewThread.updateRequested();\n            }\n        }      \n    }","commit_id":"5f5fe65bf65ad5b486a06a76da259009131c420b","url":"https://github.com/belaban/JGroups"},{"original_method":"private Object upMsg(Event evt) {\n        Message msg = (Message) evt.getArg();\n        Address src=msg.getSrc();\n        \n        // Check for a causal new view header\n        Object obj = msg.getHeader(CausalNewViewHeader.NAME);\n\n        if (obj instanceof CausalNewViewHeader) {\n            processNewViewSynchronization(src, (CausalNewViewHeader)obj, msg.getObject());           \n            return null;\n        }\n        \n        obj = msg.getHeader(getName());\n\n        if (!(obj instanceof CausalHeader)) {\n            if((msg.getDest() == null || msg.getDest().isMulticastAddress()) \n                    && log.isErrorEnabled()) log.error(\"NO CAUSAL.Header found\");\n            return up_prot.up(evt);\n        }\n        \n        TransportedVectorTime messageVector = ((CausalHeader)obj).getVectorTime();\n        \n        synchronized (lock) {\n            if (currentView==null||currentView.getView().getIndex(src)<0) {\n                if (log.isDebugEnabled()) log.debug(\"Discarding \"+obj+\" from \"+msg.getSrc());\n                return null;\n            }\n            \n            if (currentView.isCausallyNext(messageVector)) {\n                if (log.isDebugEnabled()) log.debug(\"passing up message \"+msg+\", headers are \"+msg.printHeaders()+\", local vector is \"+currentView.timeVectorString());\n                up_prot.up(evt);\n                currentView.max(messageVector);\n            } else  {\n                if (log.isDebugEnabled()) log.debug(\"queuing message \"+msg+\", headers are \"+msg.printHeaders());\n                messageVector.setAssociatedMessage(msg);\n                addToDelayQueue(messageVector);\n            }\n            \n            TransportedVectorTime queuedVector = null;\n            \n            while ((!upwardWaitingQueue.isEmpty()) &&\n                    currentView.isCausallyNext((queuedVector = (TransportedVectorTime) upwardWaitingQueue.getFirst()))) {\n                upwardWaitingQueue.remove(queuedVector);\n                Message tmp=queuedVector.getAssociatedMessage();\n                if (log.isDebugEnabled()) log.debug(\"released message \"+tmp+\", headers are \"+tmp.printHeaders());\n                up_prot.up(new Event(Event.MSG, tmp));\n                currentView.max(queuedVector);\n            }\n        }\n        return null;\n    }","id":71658,"modified_method":"private Object upMsg(Event evt) {\n        Message msg = (Message) evt.getArg();\n        Address src=msg.getSrc();\n        \n        // Check for a causal new view header\n        Object obj = msg.getHeader(CausalNewViewHeader.NAME);\n\n        if (obj instanceof CausalNewViewHeader) {\n            processNewViewSynchronization(src, (CausalNewViewHeader)obj, msg.getObject());           \n            return null;\n        }\n        \n        obj = msg.getHeader(getName());\n\n        if (!(obj instanceof CausalHeader)) {\n            if((msg.getDest() == null || msg.getDest().isMulticastAddress()) \n                    && log.isErrorEnabled()) log.error(\"NO CAUSAL.Header found\");\n            return up_prot.up(evt);\n        }\n        \n        TransportedVectorTime messageVector = ((CausalHeader)obj).getVectorTime();\n        \n        synchronized (lock) {\n            if (currentView==null||currentView.getView().getIndex(src)<0) {\n                if (log.isDebugEnabled()) log.debug(\"Discarding \"+obj+\" from \"+msg.getSrc());\n                return null;\n            }\n            \n            if (currentView.isCausallyNext(messageVector)) {\n                if (log.isTraceEnabled()) log.trace(\"passing up message \"+msg+\", headers are \"+msg.printHeaders()+\", local vector is \"+currentView.timeVectorString());\n                up_prot.up(evt);\n                currentView.max(messageVector);\n            } else  {\n                if (log.isTraceEnabled()) log.trace(\"queuing message \"+msg+\", headers are \"+msg.printHeaders());\n                messageVector.setAssociatedMessage(msg);\n                addToDelayQueue(messageVector);\n            }\n            \n            TransportedVectorTime queuedVector = null;\n            \n            while ((!upwardWaitingQueue.isEmpty()) &&\n                    currentView.isCausallyNext((queuedVector = (TransportedVectorTime) upwardWaitingQueue.getFirst()))) {\n                upwardWaitingQueue.remove(queuedVector);\n                Message tmp=queuedVector.getAssociatedMessage();\n                if (log.isTraceEnabled()) log.trace(\"released message \"+tmp+\", headers are \"+tmp.printHeaders());\n                up_prot.up(new Event(Event.MSG, tmp));\n                currentView.max(queuedVector);\n            }\n        }\n        return null;\n    }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * \n     */\n    private void processNewViewSynchronization(Address src, CausalNewViewHeader header, Object object) {\n        // If from ourselves, ignore.\n        if (localAddress.equals(src)) return;\n        \n        MissingIndexesMessage content=(MissingIndexesMessage)object;\n        \n        log.warn(\"Got sync update from \"+src);\n        \n        synchronized(lock) {\n            if (newViewThread==null) {\n                if (currentView!=null&&currentView.getView().getViewId().equals(header.newViewId)) {\n                    // Somebody's late...\n                    int localIndex=currentView.getLocalIndex();\n                    \n                    if (Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0) {\n                        Message update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(currentView.getView().getViewId(), 0, true)); // It has the time already\n                        update.setObject(new MissingIndexesMessage(Collections.EMPTY_LIST, Collections.EMPTY_LIST));\n                        \n                        down_prot.down(new Event(Event.MSG, update));\n                    }\n                    \n                    if (Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0) {\n                        \n                    }\n                } else {\n                    // Somebody's early...\n                    disable();\n                }\n                return;\n            }\n            \n            if (!newViewThread.getCausalView().getViewId().equals(header.newViewId)) return;\n        \n            if (log.isDebugEnabled()) log.debug(\"From \"+src+\": \"+header);\n\n            // Update the local time and completion status for the source.\n            newViewThread.getCausalView().setMemberLocalTime(src, header.localTime);\n            if (header.isComplete()) newViewThread.getCausalView().setMemberCompleted(src);\n            \n            // Check the requested times and completions\n            int localIndex=newViewThread.getCausalView().getLocalIndex();\n            \n            if ( Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0\n                    || Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0 ) {\n                newViewThread.updateRequested();\n            }\n        }      \n    }","id":71659,"modified_method":"/**\n     * \n     */\n    private void processNewViewSynchronization(Address src, CausalNewViewHeader header, Object object) {\n        // If from ourselves, ignore.\n        if (localAddress.equals(src)) return;\n        \n        MissingIndexesMessage content=(MissingIndexesMessage)object;\n\n        if(log.isTraceEnabled())\n            log.trace(\"Got sync update from \"+src);\n        \n        synchronized(lock) {\n            if (newViewThread==null) {\n                if (currentView!=null&&currentView.getView().getViewId().equals(header.newViewId)) {\n                    // Somebody's late...\n                    int localIndex=currentView.getLocalIndex();\n                    \n                    if (Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0) {\n                        Message update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(currentView.getView().getViewId(), 0, true)); // It has the time already\n                        update.setObject(new MissingIndexesMessage(Collections.EMPTY_LIST, Collections.EMPTY_LIST));\n                        \n                        down_prot.down(new Event(Event.MSG, update));\n                    }\n                    \n                    if (Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0) {\n                        \n                    }\n                } else {\n                    // Somebody's early...\n                    disable();\n                }\n                return;\n            }\n            \n            if (!newViewThread.getCausalView().getViewId().equals(header.newViewId)) return;\n        \n            if (log.isTraceEnabled()) log.trace(\"From \"+src+\": \"+header);\n\n            // Update the local time and completion status for the source.\n            newViewThread.getCausalView().setMemberLocalTime(src, header.localTime);\n            if (header.isComplete()) newViewThread.getCausalView().setMemberCompleted(src);\n            \n            // Check the requested times and completions\n            int localIndex=newViewThread.getCausalView().getLocalIndex();\n            \n            if ( Arrays.binarySearch(content.getMissingTimeIndexes(), localIndex)>=0\n                    || Arrays.binarySearch(content.getMissingCompletionIndexes(), localIndex)>=0 ) {\n                newViewThread.updateRequested();\n            }\n        }      \n    }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void setFinalTimeVector(InternalView newView, int startTimeVector[]) {\n            finalTimeVector=new int[timeVector.length];\n            System.arraycopy(timeVector, 0, finalTimeVector, 0, timeVector.length);\n            \n            for(int i=0;i<view.size();i++) {\n                Address member=view.getMember(i);\n                int startIndex=newView.getIndex(member);\n                if (startIndex<0) continue; // Member disappeared, keep existing time.\n                finalTimeVector[i]=startTimeVector[startIndex]; // update the final time vector.\n            }\n            \n            if (log.isInfoEnabled()) log.info(this+\": final vector time set @ \"+timeVectorString());\n        }","id":71660,"modified_method":"public synchronized void setFinalTimeVector(InternalView newView, int startTimeVector[]) {\n            finalTimeVector=new int[timeVector.length];\n            System.arraycopy(timeVector, 0, finalTimeVector, 0, timeVector.length);\n            \n            for(int i=0;i<view.size();i++) {\n                Address member=view.getMember(i);\n                int startIndex=newView.getIndex(member);\n                if (startIndex<0) continue; // Member disappeared, keep existing time.\n                finalTimeVector[i]=startTimeVector[startIndex]; // update the final time vector.\n            }\n            \n            if (log.isTraceEnabled())\n                log.trace(this+\": final vector time set @ \"+timeVectorString());\n        }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized boolean isCausallyNext(TransportedVectorTime vector) {\n            int senderIndex = vector.getSenderIndex();\n\n            if (senderIndex == view.getLocalIndex()) return true;\n\n            int[] otherTimeVector = vector.getValues();\n\n            if (otherTimeVector.length!=timeVector.length) {\n                log.warn(\"isCausallyNext: got message with wrong time vector length: \"+otherTimeVector.length+\", expected: \"+timeVector.length);\n                return true;\n            }\n            \n            boolean nextCausalFromSender = false;\n            boolean nextCausal = true;\n\n            for (int i=0;i<timeVector.length;i++) {\n               if ((i == senderIndex) && (otherTimeVector[i] == timeVector[i] + 1)) {\n                  nextCausalFromSender = true;\n                  continue;\n               }\n               if (i == view.getLocalIndex()) continue;\n               if (otherTimeVector[i] > timeVector[i]) nextCausal = false;\n            }\n            \n            return (nextCausalFromSender && nextCausal);\n        }","id":71661,"modified_method":"public synchronized boolean isCausallyNext(TransportedVectorTime vector) {\n            int senderIndex = vector.getSenderIndex();\n\n            if (senderIndex == view.getLocalIndex()) return true;\n\n            int[] otherTimeVector = vector.getValues();\n\n            if (otherTimeVector.length!=timeVector.length) {\n                if(log.isWarnEnabled())\n                    log.warn(\"isCausallyNext: got message with wrong time vector length: \"+otherTimeVector.length+\n                            \", expected: \"+timeVector.length);\n                return true;\n            }\n            \n            boolean nextCausalFromSender = false;\n            boolean nextCausal = true;\n\n            for (int i=0;i<timeVector.length;i++) {\n               if ((i == senderIndex) && (otherTimeVector[i] == timeVector[i] + 1)) {\n                  nextCausalFromSender = true;\n                  continue;\n               }\n               if (i == view.getLocalIndex()) continue;\n               if (otherTimeVector[i] > timeVector[i]) nextCausal = false;\n            }\n            \n            return (nextCausalFromSender && nextCausal);\n        }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void max(TransportedVectorTime vector) {\n            int otherTimeVector[]=vector.getValues();\n            \n            if (otherTimeVector.length!=timeVector.length) {\n                log.warn(\"max: got message with wrong time vector length: \"+otherTimeVector.length+\", expected: \"+timeVector.length);\n                return;\n            }\n            \n            for(int i=0;i<timeVector.length;i++) {\n                if (otherTimeVector[i]>timeVector[i]) timeVector[i]=otherTimeVector[i];\n            }\n        }","id":71662,"modified_method":"public synchronized void max(TransportedVectorTime vector) {\n            int otherTimeVector[]=vector.getValues();\n            \n            if (otherTimeVector.length!=timeVector.length) {\n                if(log.isWarnEnabled())\n                    log.warn(\"max: got message with wrong time vector length: \"+otherTimeVector.length+\", expected: \"+\n                            timeVector.length);\n                return;\n            }\n            \n            for(int i=0;i<timeVector.length;i++) {\n                if (otherTimeVector[i]>timeVector[i]) timeVector[i]=otherTimeVector[i];\n            }\n        }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Process a downward event.\n     * @param evt The event.\n     */\n    public Object down(Event evt) {\n        try {\n            // If not a MSG, just pass down.\n            if (evt.getType()!=Event.MSG) {\n                return down_prot.down(evt);\n            }\n            \n            Message msg = (Message) evt.getArg();\n            \n            // If unicast, just pass down.\n            if (msg.getDest()!=null && ! msg.getDest().isMulticastAddress()) {\n                return down_prot.down(evt);\n            }\n    \n            // Multicast MSG:\n            // - if enabled, get the next time vector, add it and pass down;\n            // - otherwise, add to the downward waiting queue.\n            TransportedVectorTime tvt=null;\n            \n            synchronized(lock) {\n                if (isEnabled()) {\n                    currentView.increment();\n                    tvt=currentView.getTransportedVectorTime();\n                    if (log.isDebugEnabled()) log.debug(\"Sent 1 down message @ \"+currentView.timeVectorString());\n                } else {\n                    if (log.isDebugEnabled()) log.debug(\"Enqueued 1 down message...\");\n                    downwardWaitingQueue.add(evt);\n                }\n            }\n            \n            if (tvt!=null) {\n                msg.putHeader(getName(), new CausalHeader(tvt));\n                return down_prot.down(evt);\n            }\n        } catch (RuntimeException e) {\n            if (debug) log.error(\"*** down: \"+e.getMessage(), e);\n            throw e;\n        }\n\n        return null;\n    }","id":71663,"modified_method":"/**\n     * Process a downward event.\n     * @param evt The event.\n     */\n    public Object down(Event evt) {\n        try {\n            // If not a MSG, just pass down.\n            if (evt.getType()!=Event.MSG) {\n                return down_prot.down(evt);\n            }\n            \n            Message msg = (Message) evt.getArg();\n            \n            // If unicast, just pass down.\n            if (msg.getDest()!=null && ! msg.getDest().isMulticastAddress()) {\n                return down_prot.down(evt);\n            }\n    \n            // Multicast MSG:\n            // - if enabled, get the next time vector, add it and pass down;\n            // - otherwise, add to the downward waiting queue.\n            TransportedVectorTime tvt=null;\n            \n            synchronized(lock) {\n                if (isEnabled()) {\n                    currentView.increment();\n                    tvt=currentView.getTransportedVectorTime();\n                    if (log.isTraceEnabled()) log.trace(\"Sent 1 down message @ \"+currentView.timeVectorString());\n                } else {\n                    if (log.isTraceEnabled()) log.trace(\"Enqueued 1 down message...\");\n                    downwardWaitingQueue.add(evt);\n                }\n            }\n            \n            if (tvt!=null) {\n                msg.putHeader(getName(), new CausalHeader(tvt));\n                return down_prot.down(evt);\n            }\n        } catch (RuntimeException e) {\n            if (debug) log.error(\"*** down: \"+e.getMessage(), e);\n            throw e;\n        }\n\n        return null;\n    }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n            boolean sendUpdate=false, complete=false;\n            LinkedList flush=null;\n\n            for(;;) {\n                Message update=null;\n\n                synchronized(lock) {\n                    if(this != newViewThread) {\n                        break;\n                    }\n\n                    if(newView.hasMissingTimes()) {\n                        sendUpdate=true;\n                    }\n                    else\n                    if(currentView == null || (!currentView.getViewId().equals(newView.getViewId()) && currentView.hasEnded()))\n                    {\n                        currentView=new ActiveCausalView(newView.getView(), newView.timeVector);\n                        complete=true;\n                        newView.setMemberCompleted(localAddress);\n\n                        if(log.isInfoEnabled())\n                            log.info(\"Set up new active view: \" + currentView + \" @ \" + currentView.timeVectorString());\n                    }\n\n                    if(newView.hasMissingCompletions()) {\n                        sendUpdate=true;\n                    }\n                    else {\n                        newViewThread=null;\n                        enabled=true;\n                        flush=(LinkedList)downwardWaitingQueue.clone();\n                        downwardWaitingQueue.clear();\n\n                        if(log.isInfoEnabled())\n                            log.info(\"Done synchronizing, enabled view: \" + currentView + \" @ \" + currentView.timeVectorString());\n\n                        break;\n                    }\n\n                    if(sendUpdate) {\n                        update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(newView.getViewId(), newView.getLocalTime(), complete));\n                        update.setObject(new MissingIndexesMessage(newView.getMissingTimes(), newView.getMissingCompletions()));\n                    }\n                }\n\n                if(update != null) {\n                    log.warn(\"Sending sync update\");\n\n                    down_prot.down(new Event(Event.MSG, update));\n                }\n\n                synchronized(this) {\n                    // Wait for 50ms\n                    try {\n                        wait(500);\n                    }\n                    catch(InterruptedException e) {\n                        Thread.currentThread().interrupt(); // set interrupt flag again\n                        // Ignore\n                        log.warn(\"Interrupted?!?\", e);\n                    }\n\n                    sendUpdate=updateRequested;\n                    updateRequested=false;\n                }\n            }\n            \n            if (flush!=null) {\n                int n=flush.size();\n                if (log.isInfoEnabled()) log.info(\"Flushing \"+n+\" messages down...\");\n                \n                while(!flush.isEmpty()) {\n                    Event evt=(Event)flush.removeFirst();\n                    down(evt);\n                }\n                \n                if (log.isDebugEnabled()) log.debug(\"Done flushing \"+n+\" messages down...\");\n            }\n        }","id":71664,"modified_method":"public void run() {\n            boolean sendUpdate=false, complete=false;\n            LinkedList flush=null;\n\n            for(;;) {\n                Message update=null;\n\n                synchronized(lock) {\n                    if(this != newViewThread) {\n                        break;\n                    }\n\n                    if(newView.hasMissingTimes()) {\n                        sendUpdate=true;\n                    }\n                    else\n                    if(currentView == null || (!currentView.getViewId().equals(newView.getViewId()) && currentView.hasEnded()))\n                    {\n                        currentView=new ActiveCausalView(newView.getView(), newView.timeVector);\n                        complete=true;\n                        newView.setMemberCompleted(localAddress);\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"Set up new active view: \" + currentView + \" @ \" + currentView.timeVectorString());\n                    }\n\n                    if(newView.hasMissingCompletions()) {\n                        sendUpdate=true;\n                    }\n                    else {\n                        newViewThread=null;\n                        enabled=true;\n                        flush=(LinkedList)downwardWaitingQueue.clone();\n                        downwardWaitingQueue.clear();\n\n                        if(log.isTraceEnabled())\n                            log.trace(\"Done synchronizing, enabled view: \" + currentView + \" @ \" + currentView.timeVectorString());\n\n                        break;\n                    }\n\n                    if(sendUpdate) {\n                        update=new Message(null, localAddress, null);\n                        update.putHeader(CausalNewViewHeader.NAME\n                                , new CausalNewViewHeader(newView.getViewId(), newView.getLocalTime(), complete));\n                        update.setObject(new MissingIndexesMessage(newView.getMissingTimes(), newView.getMissingCompletions()));\n                    }\n                }\n\n                if(update != null) {\n                    if(log.isTraceEnabled())\n                        log.trace(\"Sending sync update\");\n                    down_prot.down(new Event(Event.MSG, update));\n                }\n\n                synchronized(this) {\n                    // Wait for 50ms\n                    try {\n                        wait(500);\n                    }\n                    catch(InterruptedException e) {\n                        Thread.currentThread().interrupt(); // set interrupt flag again\n                        // Ignore\n                        log.warn(\"Interrupted?!?\", e);\n                    }\n\n                    sendUpdate=updateRequested;\n                    updateRequested=false;\n                }\n            }\n            \n            if (flush!=null) {\n                int n=flush.size();\n                if (log.isDebugEnabled()) log.debug(\"Flushing \"+n+\" messages down...\");\n                \n                while(!flush.isEmpty()) {\n                    Event evt=(Event)flush.removeFirst();\n                    down(evt);\n                }\n                \n                if (log.isDebugEnabled()) log.debug(\"Done flushing \"+n+\" messages down...\");\n            }\n        }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"public void writeTo(DataOutputStream out) throws IOException {\n            if(t == null)\n            {\n                out.writeBoolean(false);\n                return;\n            }\n            out.writeBoolean(true);\n\n            out.write(t.senderPosition);\n            \n            int values[]=t.values;\n            \n            int len=values.length;\n            out.write(len);\n            for(int i=0;i<len;i++) out.write(values[i]);\n        }","id":71665,"modified_method":"public void writeTo(DataOutputStream out) throws IOException {\n            if(t == null)\n            {\n                out.writeBoolean(false);\n                return;\n            }\n            out.writeBoolean(true);\n\n            out.writeInt(t.senderPosition);\n            \n            int values[]=t.values;\n            \n            int len=values.length;\n            out.writeInt(len);\n            for(int i=0;i<len;i++) out.writeInt(values[i]);\n        }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void setMemberCompleted(Address address) {\n            if (missingCompletions.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            missingCompletions.remove(new Integer(index));\n            \n            if (missingCompletions.isEmpty()) {\n                if (log.isInfoEnabled()) log.info(this+\" has all the completions\");\n            } else {\n                if (log.isDebugEnabled()) log.debug(this+\" missing completions: \"+missingCompletions);\n            }\n        }","id":71666,"modified_method":"public synchronized void setMemberCompleted(Address address) {\n            if (missingCompletions.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            missingCompletions.remove(new Integer(index));\n            \n            if (missingCompletions.isEmpty()) {\n                if (log.isTraceEnabled()) log.trace(this+\" has all the completions\");\n            } else {\n                if (log.isTraceEnabled()) log.trace(this+\" missing completions: \"+missingCompletions);\n            }\n        }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Process a VIEW_CHANGE event.\n     * @param evt The event.\n     */\n    private void upViewChange(Event evt)\n    {\n        View view=(View)evt.getArg();      \n        InternalView iView=new InternalView(view.getVid(), view.getMembers(), localAddress);\n\n        log.warn(\"New view: \"+view);\n        \n        synchronized(lock) {\n            // Disable sending\n            disable();\n            \n            // Create new causal view\n            NewCausalView newView=new NewCausalView(currentView, iView);\n            if (currentView!=null) {\n                currentView.clearFinalTimeVector();\n                newView.setMemberLocalTime(localAddress, currentView.getLocalTime());\n            } else {\n                newView.setMemberLocalTime(localAddress, 0);\n            }\n            \n            if (log.isWarnEnabled()) log.warn(\"Starting synchronization thread for \"+newView);\n            \n            newViewThread=new NewViewThread(newView);\n            newViewThread.start();\n        }\n        \n        up_prot.up(evt);\n    }","id":71667,"modified_method":"/**\n     * Process a VIEW_CHANGE event.\n     * @param evt The event.\n     */\n    private void upViewChange(Event evt)\n    {\n        View view=(View)evt.getArg();      \n        InternalView iView=new InternalView(view.getVid(), view.getMembers(), localAddress);\n        if(log.isDebugEnabled())\n            log.debug(\"New view: \"+view);\n        \n        synchronized(lock) {\n            // Disable sending\n            disable();\n            \n            // Create new causal view\n            NewCausalView newView=new NewCausalView(currentView, iView);\n            if (currentView!=null) {\n                currentView.clearFinalTimeVector();\n                newView.setMemberLocalTime(localAddress, currentView.getLocalTime());\n            } else {\n                newView.setMemberLocalTime(localAddress, 0);\n            }\n            \n            if (log.isTraceEnabled()) log.trace(\"Starting synchronization thread for \"+newView);\n            \n            newViewThread=new NewViewThread(newView);\n            newViewThread.start();\n        }\n        \n        up_prot.up(evt);\n    }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"public synchronized void setMemberLocalTime(Address address, int time) {\n            if (missingTimes.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            timeVector[index]=time;           \n            missingTimes.remove(new Integer(index));\n            \n            if (missingTimes.isEmpty()) {\n                if (active!=null) active.setFinalTimeVector(view, timeVector);                        \n                if (log.isInfoEnabled()) log.info(this+\" has all the times\");\n            } else {\n                if (log.isDebugEnabled()) log.debug(this+\" missing times: \"+missingTimes);\n            }\n        }","id":71668,"modified_method":"public synchronized void setMemberLocalTime(Address address, int time) {\n            if (missingTimes.isEmpty()) return;\n            \n            int index=view.getIndex(address);\n            if (index<0) return;\n            timeVector[index]=time;           \n            missingTimes.remove(new Integer(index));\n            \n            if (missingTimes.isEmpty()) {\n                if (active!=null) active.setFinalTimeVector(view, timeVector);                        \n                if (log.isTraceEnabled()) log.trace(this+\" has all the times\");\n            }\n            else {\n                if (log.isTraceEnabled()) log.trace(this+\" missing times: \"+missingTimes);\n            }\n        }","commit_id":"5cc646ac04930a8f2acf189ccd8dfe1cf4f3ee23","url":"https://github.com/belaban/JGroups"},{"original_method":"private List<EntitySpec<?>> buildTemplateServicesAsSpecsImpl(BrooklynClassLoadingContext loader, AssemblyTemplate template, CampPlatform platform, Set<String> encounteredCatalogTypes) {\n        List<EntitySpec<?>> result = Lists.newArrayList();\n        \n        for (ResolvableLink<PlatformComponentTemplate> ctl: template.getPlatformComponentTemplates().links()) {\n            PlatformComponentTemplate appChildComponentTemplate = ctl.resolve();\n            BrooklynComponentTemplateResolver entityResolver = BrooklynComponentTemplateResolver.Factory.newInstance(loader, appChildComponentTemplate);\n            ManagementContext mgmt = loader.getManagementContext();\n\n            String catalogIdOrJavaType = entityResolver.getCatalogIdOrJavaType();\n\n            EntitySpec<?> spec;\n            \n            CatalogItem<Entity, EntitySpec<?>> item = entityResolver.getCatalogItem();\n            \n            // FIXME\n            log.warn(\"buildTemplateServicesAsSpecsImpl: catalogIdOrJavaType=\"+catalogIdOrJavaType+\"; item=\"+item+\"; loader=\"+loader+\"; template=\"+template+\"; encounteredCatalogTypes=\"+encounteredCatalogTypes);\n\n\n            if (item == null || item.getJavaType() != null) {\n                spec = entityResolver.resolveSpec();\n            } else {\n                boolean firstOccurrence = encounteredCatalogTypes.add(catalogIdOrJavaType);\n                if (firstOccurrence) {\n                    spec = resolveCatalogYamlReferenceSpec(platform, mgmt, item, encounteredCatalogTypes);\n                } else {\n                    throw new IllegalStateException(\"Recursive reference to \" + catalogIdOrJavaType);\n                }\n            }\n\n            BrooklynClassLoadingContext newLoader = entityResolver.loader;\n            buildChildrenEntitySpecs(newLoader, spec, entityResolver.getChildren(appChildComponentTemplate.getCustomAttributes()));\n            \n            result.add(spec);\n        }\n        return result;\n    }","id":71669,"modified_method":"private List<EntitySpec<?>> buildTemplateServicesAsSpecsImpl(BrooklynClassLoadingContext loader, AssemblyTemplate template, CampPlatform platform, Set<String> encounteredCatalogTypes) {\n        List<EntitySpec<?>> result = Lists.newArrayList();\n        \n        for (ResolvableLink<PlatformComponentTemplate> ctl: template.getPlatformComponentTemplates().links()) {\n            PlatformComponentTemplate appChildComponentTemplate = ctl.resolve();\n            BrooklynComponentTemplateResolver entityResolver = BrooklynComponentTemplateResolver.Factory.newInstance(loader, appChildComponentTemplate);\n            ManagementContext mgmt = loader.getManagementContext();\n\n            String catalogIdOrJavaType = entityResolver.getCatalogIdOrJavaType();\n            CatalogItem<Entity, EntitySpec<?>> item = entityResolver.getCatalogItem();\n            \n            if (log.isTraceEnabled()) log.trace(\"Building CAMP template services: type=\"+catalogIdOrJavaType+\"; item=\"+item+\"; loader=\"+loader+\"; template=\"+template+\"; encounteredCatalogTypes=\"+encounteredCatalogTypes);\n\n            EntitySpec<?> spec;\n            if (item == null || item.getJavaType() != null || entityResolver.isJavaTypePrefix()) {\n                spec = entityResolver.resolveSpec();\n            } else {\n                boolean firstOccurrence = encounteredCatalogTypes.add(catalogIdOrJavaType);\n                if (firstOccurrence) {\n                    spec = resolveCatalogYamlReferenceSpec(platform, mgmt, item, encounteredCatalogTypes);\n                } else {\n                    throw new IllegalStateException(\"Recursive reference to \" + catalogIdOrJavaType);\n                }\n            }\n\n            BrooklynClassLoadingContext newLoader = entityResolver.loader;\n            buildChildrenEntitySpecs(newLoader, spec, entityResolver.getChildren(appChildComponentTemplate.getCustomAttributes()));\n            \n            result.add(spec);\n        }\n        return result;\n    }","commit_id":"8e57fb0b78dcc667c61f6cbb43c9a72c7b4d0aec","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"private void registerAndLaunchAndAssertSimpleEntity(String registeredTypeName, String serviceType) {\n        addCatalogOSGiEntity(registeredTypeName, serviceType);\n\n        String yaml = \"{ name: simple-app-yaml, location: localhost, services: [ { serviceType: \"+registeredTypeName+\" } ] }\";\n        ApplicationSummary appSummary = createAndWaitForApp(yaml);\n\n        String appId = appSummary.getId();\n        assertEquals(appSummary.getSpec().getName(), \"simple-app-yaml\");\n\n        Application app = (Application) getManagementContext().getEntityManager().getEntity(appId);\n        Entity simpleEntity = Iterables.getOnlyElement(app.getChildren());\n        assertEquals(simpleEntity.getEntityType().getName(), SIMPLE_ENTITY_TYPE);\n    }","id":71670,"modified_method":"private void registerAndLaunchAndAssertSimpleEntity(String registeredTypeName, String serviceType) {\n        addCatalogOSGiEntity(registeredTypeName, serviceType);\n        try {\n            String yaml = \"{ name: simple-app-yaml, location: localhost, services: [ { serviceType: \"+registeredTypeName+\" } ] }\";\n            ApplicationSummary appSummary = createAndWaitForApp(yaml);\n    \n            String appId = appSummary.getId();\n            assertEquals(appSummary.getSpec().getName(), \"simple-app-yaml\");\n    \n            Application app = (Application) getManagementContext().getEntityManager().getEntity(appId);\n            Entity simpleEntity = Iterables.getOnlyElement(app.getChildren());\n            assertEquals(simpleEntity.getEntityType().getName(), SIMPLE_ENTITY_TYPE);\n        } finally {\n            deleteCatalogEntity(registeredTypeName);\n        }\n    }","commit_id":"8e57fb0b78dcc667c61f6cbb43c9a72c7b4d0aec","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"protected String getWhere(String key, Object value) {\n\t\tString join = StringPool.BLANK;\n\n\t\tif (key.equals(\"organizations\")) {\n\t\t\tLong[] organizationIds = (Long[])value;\n\n\t\t\tif (organizationIds.length == 0) {\n\t\t\t\tjoin = \"WHERE ((Organization_.organizationId = -1) )\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\torganizationIds.length * 2 + 1);\n\n\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\tfor (int i = 0; i < organizationIds.length; i++) {\n\t\t\t\t\tsb.append(\"(Organization_.organizationId = ?) \");\n\n\t\t\t\t\tif ((i + 1) < organizationIds.length) {\n\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsb.append(\")\");\n\n\t\t\t\tjoin = sb.toString();\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"organizationsGroups\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_GROUPS);\n\t\t}\n\t\telse if (key.equals(\"organizationsPasswordPolicies\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_PASSWORD_POLICIES);\n\t\t}\n\t\telse if (key.equals(\"organizationsRoles\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_ROLES);\n\t\t}\n\t\telse if (key.equals(\"organizationsTree\")) {\n\t\t\tList<Organization> organizationsTree = (List<Organization>)value;\n\n\t\t\tint size = organizationsTree.size();\n\n\t\t\tif (!organizationsTree.isEmpty()) {\n\t\t\t\tStringBundler sb = new StringBundler(size * 2 + 1);\n\n\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tsb.append(\"(Organization_.treePath LIKE ?) \");\n\n\t\t\t\t\tif ((i + 1) < size) {\n\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsb.append(\")\");\n\n\t\t\t\tjoin = sb.toString();\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"organizationsUsers\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_USERS);\n\t\t}\n\t\telse if (key.equals(\"usersOrgs\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_ORGS);\n\t\t}\n\n\t\tif (Validator.isNotNull(join)) {\n\t\t\tint pos = join.indexOf(\"WHERE\");\n\n\t\t\tif (pos != -1) {\n\t\t\t\tjoin = join.substring(pos + 5, join.length()).concat(\" AND \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = StringPool.BLANK;\n\t\t\t}\n\t\t}\n\n\t\treturn join;\n\t}","id":71671,"modified_method":"protected String getWhere(String key, Object value) {\n\t\tString join = StringPool.BLANK;\n\n\t\tif (key.equals(\"organizations\")) {\n\t\t\tLong[] organizationIds = (Long[])value;\n\n\t\t\tif (organizationIds.length == 0) {\n\t\t\t\tjoin = \"WHERE ((Organization_.organizationId = -1) )\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\torganizationIds.length * 2 + 1);\n\n\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\tfor (int i = 0; i < organizationIds.length; i++) {\n\t\t\t\t\tsb.append(\"(Organization_.organizationId = ?) \");\n\n\t\t\t\t\tif ((i + 1) < organizationIds.length) {\n\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsb.append(\")\");\n\n\t\t\t\tjoin = sb.toString();\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"organizationsGroups\")) {\n\t\t\tif (value instanceof Long) {\n\t\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_GROUPS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLong[] organizationGroupIds = (Long[])value;\n\n\t\t\t\tif (organizationGroupIds.length == 0) {\n\t\t\t\t\tjoin = \"WHERE (Groups_Orgs.groupId = -1)\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\t\torganizationGroupIds.length * 2 + 1);\n\n\t\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\t\tfor (int i = 0; i < organizationGroupIds.length; i++) {\n\t\t\t\t\t\tsb.append(\"(Groups_Orgs.groupId = ?) \");\n\n\t\t\t\t\t\tif ((i + 1) < organizationGroupIds.length) {\n\t\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\t\tjoin = sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"organizationsPasswordPolicies\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_PASSWORD_POLICIES);\n\t\t}\n\t\telse if (key.equals(\"organizationsRoles\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_ROLES);\n\t\t}\n\t\telse if (key.equals(\"organizationsTree\")) {\n\t\t\tList<Organization> organizationsTree = (List<Organization>)value;\n\n\t\t\tint size = organizationsTree.size();\n\n\t\t\tif (!organizationsTree.isEmpty()) {\n\t\t\t\tStringBundler sb = new StringBundler(size * 2 + 1);\n\n\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tsb.append(\"(Organization_.treePath LIKE ?) \");\n\n\t\t\t\t\tif ((i + 1) < size) {\n\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsb.append(\")\");\n\n\t\t\t\tjoin = sb.toString();\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"organizationsUsers\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_ORGANIZATIONS_USERS);\n\t\t}\n\t\telse if (key.equals(\"usersOrgs\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_ORGS);\n\t\t}\n\n\t\tif (Validator.isNotNull(join)) {\n\t\t\tint pos = join.indexOf(\"WHERE\");\n\n\t\t\tif (pos != -1) {\n\t\t\t\tjoin = join.substring(pos + 5, join.length()).concat(\" AND \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = StringPool.BLANK;\n\t\t\t}\n\t\t}\n\n\t\treturn join;\n\t}","commit_id":"f1f373890d55fb83ba61f9144ad4d585fc6f0630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public int countByC_FN_MN_LN_SN_EA_S(\n\t\t\tlong companyId, String[] firstNames, String[] middleNames,\n\t\t\tString[] lastNames, String[] screenNames, String[] emailAddresses,\n\t\t\tint status, LinkedHashMap<String, Object> params,\n\t\t\tboolean andOperator)\n\t\tthrows SystemException {\n\n\t\tfirstNames = CustomSQLUtil.keywords(firstNames);\n\t\tmiddleNames = CustomSQLUtil.keywords(middleNames);\n\t\tlastNames = CustomSQLUtil.keywords(lastNames);\n\t\tscreenNames = CustomSQLUtil.keywords(screenNames);\n\t\temailAddresses = CustomSQLUtil.keywords(emailAddresses);\n\n\t\tif (params == null) {\n\t\t\tparams = _emptyLinkedHashMap;\n\t\t}\n\n\t\tLong groupId = (Long)params.get(\"usersGroups\");\n\t\tboolean inherit = GetterUtil.getBoolean(params.get(\"inherit\"));\n\n\t\tboolean doUnion = Validator.isNotNull(groupId) && inherit;\n\n\t\tLinkedHashMap<String, Object> params1 = params;\n\n\t\tLinkedHashMap<String, Object> params2 = null;\n\n\t\tLinkedHashMap<String, Object> params3 = null;\n\n\t\tif (doUnion) {\n\t\t\tparams2 = new LinkedHashMap<String, Object>(params1);\n\n\t\t\tList<Long> organizationIds = new ArrayList<Long>();\n\n\t\t\tGroup group = GroupLocalServiceUtil.fetchGroup(groupId);\n\n\t\t\tif ((group != null) && group.isOrganization()) {\n\t\t\t\torganizationIds.add(group.getOrganizationId());\n\t\t\t}\n\n\t\t\tList<Organization> organizations = GroupUtil.getOrganizations(\n\t\t\t\tgroupId);\n\n\t\t\tfor (Organization organization : organizations) {\n\t\t\t\torganizationIds.add(organization.getOrganizationId());\n\t\t\t}\n\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams2.put(\n\t\t\t\t\"usersOrgs\",\n\t\t\t\torganizationIds.toArray(new Long[organizationIds.size()]));\n\n\t\t\tparams3 = new LinkedHashMap<String, Object>(params1);\n\n\t\t\tList<UserGroup> userGroups = GroupUtil.getUserGroups(groupId);\n\n\t\t\tLong[] userGroupIds = new Long[userGroups.size()];\n\n\t\t\tfor (int i = 0; i < userGroups.size(); i++) {\n\t\t\t\tUserGroup userGroup = userGroups.get(i);\n\n\t\t\t\tuserGroupIds[i] = userGroup.getUserGroupId();\n\t\t\t}\n\n\t\t\tparams3.remove(\"usersGroups\");\n\t\t\tparams3.put(\"usersUserGroups\", userGroupIds);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tSet<Long> userIds = new HashSet<Long>();\n\n\t\t\tuserIds.addAll(\n\t\t\t\tcountByC_FN_MN_LN_SN_EA_S(\n\t\t\t\t\tsession, companyId, firstNames, middleNames, lastNames,\n\t\t\t\t\tscreenNames, emailAddresses, status, params1, andOperator));\n\n\t\t\tif (doUnion) {\n\t\t\t\tuserIds.addAll(\n\t\t\t\t\tcountByC_FN_MN_LN_SN_EA_S(\n\t\t\t\t\t\tsession, companyId, firstNames, middleNames, lastNames,\n\t\t\t\t\t\tscreenNames, emailAddresses, status, params2,\n\t\t\t\t\t\tandOperator));\n\n\t\t\t\tuserIds.addAll(\n\t\t\t\t\tcountByC_FN_MN_LN_SN_EA_S(\n\t\t\t\t\t\tsession, companyId, firstNames, middleNames, lastNames,\n\t\t\t\t\t\tscreenNames, emailAddresses, status, params3,\n\t\t\t\t\t\tandOperator));\n\t\t\t}\n\n\t\t\treturn userIds.size();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":71672,"modified_method":"public int countByC_FN_MN_LN_SN_EA_S(\n\t\t\tlong companyId, String[] firstNames, String[] middleNames,\n\t\t\tString[] lastNames, String[] screenNames, String[] emailAddresses,\n\t\t\tint status, LinkedHashMap<String, Object> params,\n\t\t\tboolean andOperator)\n\t\tthrows SystemException {\n\n\t\tfirstNames = CustomSQLUtil.keywords(firstNames);\n\t\tmiddleNames = CustomSQLUtil.keywords(middleNames);\n\t\tlastNames = CustomSQLUtil.keywords(lastNames);\n\t\tscreenNames = CustomSQLUtil.keywords(screenNames);\n\t\temailAddresses = CustomSQLUtil.keywords(emailAddresses);\n\n\t\tif (params == null) {\n\t\t\tparams = _emptyLinkedHashMap;\n\t\t}\n\n\t\tLong[] groupIds = null;\n\n\t\tif (params.get(\"usersGroups\") instanceof Long) {\n\t\t\tgroupIds = new Long[] {(Long)params.get(\"usersGroups\")};\n\t\t}\n\t\telse {\n\t\t\tgroupIds = (Long[])params.get(\"usersGroups\");\n\t\t}\n\n\t\tboolean inherit = GetterUtil.getBoolean(params.get(\"inherit\"));\n\n\t\tboolean doUnion = Validator.isNotNull(groupIds) && inherit;\n\n\t\tLinkedHashMap<String, Object> params1 = params;\n\n\t\tLinkedHashMap<String, Object> params2 = null;\n\n\t\tLinkedHashMap<String, Object> params3 = null;\n\n\t\tif (doUnion) {\n\t\t\tparams2 = new LinkedHashMap<String, Object>(params1);\n\t\t\tparams3 = new LinkedHashMap<String, Object>(params1);\n\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams3.remove(\"usersGroups\");\n\n\t\t\tList<Long> organizationIds = new ArrayList<Long>();\n\t\t\tList<Long> userGroupIds = new ArrayList<Long>();\n\n\t\t\tfor (long groupId : groupIds) {\n\t\t\t\tGroup group = GroupLocalServiceUtil.fetchGroup(groupId);\n\n\t\t\t\tif ((group != null) && group.isOrganization()) {\n\t\t\t\t\torganizationIds.add(group.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\tList<Organization> organizations = GroupUtil.getOrganizations(\n\t\t\t\t\tgroupId);\n\n\t\t\t\tfor (Organization organization : organizations) {\n\t\t\t\t\torganizationIds.add(organization.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\tList<UserGroup> userGroups = GroupUtil.getUserGroups(groupId);\n\n\t\t\t\tfor (int i = 0; i < userGroups.size(); i++) {\n\t\t\t\t\tUserGroup userGroup = userGroups.get(i);\n\n\t\t\t\t\tuserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparams2.put(\n\t\t\t\t\"usersOrgs\",\n\t\t\t\torganizationIds.toArray(new Long[organizationIds.size()]));\n\n\t\t\tparams3.put(\"usersUserGroups\", userGroupIds);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tSet<Long> userIds = new HashSet<Long>();\n\n\t\t\tuserIds.addAll(\n\t\t\t\tcountByC_FN_MN_LN_SN_EA_S(\n\t\t\t\t\tsession, companyId, firstNames, middleNames, lastNames,\n\t\t\t\t\tscreenNames, emailAddresses, status, params1, andOperator));\n\n\t\t\tif (doUnion) {\n\t\t\t\tuserIds.addAll(\n\t\t\t\t\tcountByC_FN_MN_LN_SN_EA_S(\n\t\t\t\t\t\tsession, companyId, firstNames, middleNames, lastNames,\n\t\t\t\t\t\tscreenNames, emailAddresses, status, params2,\n\t\t\t\t\t\tandOperator));\n\n\t\t\t\tuserIds.addAll(\n\t\t\t\t\tcountByC_FN_MN_LN_SN_EA_S(\n\t\t\t\t\t\tsession, companyId, firstNames, middleNames, lastNames,\n\t\t\t\t\t\tscreenNames, emailAddresses, status, params3,\n\t\t\t\t\t\tandOperator));\n\t\t\t}\n\n\t\t\treturn userIds.size();\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","commit_id":"f1f373890d55fb83ba61f9144ad4d585fc6f0630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getWhere(String key, Object value) {\n\t\tString join = StringPool.BLANK;\n\n\t\tif (key.equals(\"contactTwitterSn\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_CONTACT_TWITTER_SN);\n\t\t}\n\t\telse if (key.equals(\"noOrganizations\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_NO_ORGANIZATIONS);\n\t\t}\n\t\telse if (key.equals(\"userGroupRole\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUP_ROLE);\n\t\t}\n\t\telse if (key.equals(\"usersGroups\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_GROUPS);\n\t\t}\n\t\telse if (key.equals(\"usersOrgs\")) {\n\t\t\tif (value instanceof Long) {\n\t\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_ORGS);\n\t\t\t}\n\t\t\telse if (value instanceof Long[]) {\n\t\t\t\tLong[] organizationIds = (Long[])value;\n\n\t\t\t\tif (organizationIds.length == 0) {\n\t\t\t\t\tjoin = \"WHERE (Users_Orgs.organizationId = -1)\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\t\torganizationIds.length * 2 + 1);\n\n\t\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\t\tfor (int i = 0; i < organizationIds.length; i++) {\n\t\t\t\t\t\tsb.append(\"(Users_Orgs.organizationId = ?) \");\n\n\t\t\t\t\t\tif ((i + 1) < organizationIds.length) {\n\t\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\t\tjoin = sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"usersOrgsTree\")) {\n\t\t\tList<Organization> organizationsTree = (List<Organization>)value;\n\n\t\t\tint size = organizationsTree.size();\n\n\t\t\tif (size > 0) {\n\t\t\t\tStringBundler sb = new StringBundler(size * 2 + 1);\n\n\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tsb.append(\"(Organization_.treePath LIKE ?) \");\n\n\t\t\t\t\tif ((i + 1) < size) {\n\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\tjoin = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = \"WHERE (Organization_.treePath LIKE ?)\";\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"usersPasswordPolicies\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_PASSWORD_POLICIES);\n\t\t}\n\t\telse if (key.equals(\"usersRoles\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_ROLES);\n\t\t}\n\t\telse if (key.equals(\"usersTeams\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_TEAMS);\n\t\t}\n\t\telse if (key.equals(\"usersUserGroups\")) {\n\t\t\tif (value instanceof Long) {\n\t\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_USER_GROUPS);\n\t\t\t}\n\t\t\telse if (value instanceof Long[]) {\n\t\t\t\tLong[] userGroupIds = (Long[])value;\n\n\t\t\t\tif (userGroupIds.length == 0) {\n\t\t\t\t\tjoin = \"WHERE (Users_UserGroups.userGroupId = -1)\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\t\tuserGroupIds.length * 2 + 1);\n\n\t\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\t\tfor (int i = 0; i < userGroupIds.length; i++) {\n\t\t\t\t\t\tsb.append(\"(Users_UserGroups.userGroupId = ?) \");\n\n\t\t\t\t\t\tif ((i + 1) < userGroupIds.length) {\n\t\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\t\tjoin = sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"announcementsDeliveryEmailOrSms\")) {\n\t\t\tjoin = CustomSQLUtil.get(\n\t\t\t\tJOIN_BY_ANNOUNCEMENTS_DELIVERY_EMAIL_OR_SMS);\n\t\t}\n\t\telse if (key.equals(\"socialMutualRelation\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_MUTUAL_RELATION);\n\t\t}\n\t\telse if (key.equals(\"socialMutualRelationType\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_MUTUAL_RELATION_TYPE);\n\t\t}\n\t\telse if (key.equals(\"socialRelation\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_RELATION);\n\t\t}\n\t\telse if (key.equals(\"socialRelationType\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_RELATION_TYPE);\n\t\t}\n\t\telse if (value instanceof CustomSQLParam) {\n\t\t\tCustomSQLParam customSQLParam = (CustomSQLParam)value;\n\n\t\t\tjoin = customSQLParam.getSQL();\n\t\t}\n\n\t\tif (Validator.isNotNull(join)) {\n\t\t\tint pos = join.indexOf(\"WHERE\");\n\n\t\t\tif (pos != -1) {\n\t\t\t\tjoin = join.substring(pos + 5, join.length()).concat(\" AND \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = StringPool.BLANK;\n\t\t\t}\n\t\t}\n\n\t\treturn join;\n\t}","id":71673,"modified_method":"protected String getWhere(String key, Object value) {\n\t\tString join = StringPool.BLANK;\n\n\t\tif (key.equals(\"contactTwitterSn\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_CONTACT_TWITTER_SN);\n\t\t}\n\t\telse if (key.equals(\"noOrganizations\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_NO_ORGANIZATIONS);\n\t\t}\n\t\telse if (key.equals(\"userGroupRole\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUP_ROLE);\n\t\t}\n\t\telse if (key.equals(\"usersGroups\")) {\n\t\t\tif (value instanceof Long) {\n\t\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_GROUPS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLong[] groupIds = (Long[])value;\n\n\t\t\t\tif (groupIds.length == 0) {\n\t\t\t\t\tjoin = \"WHERE (Users_Groups.groupId = -1)\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\t\tgroupIds.length * 2 + 1);\n\n\t\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\t\tfor (int i = 0; i < groupIds.length; i++) {\n\t\t\t\t\t\tsb.append(\"(Users_Groups.groupId = ?) \");\n\n\t\t\t\t\t\tif ((i + 1) < groupIds.length) {\n\t\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\t\tjoin = sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"usersOrgs\")) {\n\t\t\tif (value instanceof Long) {\n\t\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_ORGS);\n\t\t\t}\n\t\t\telse if (value instanceof Long[]) {\n\t\t\t\tLong[] organizationIds = (Long[])value;\n\n\t\t\t\tif (organizationIds.length == 0) {\n\t\t\t\t\tjoin = \"WHERE (Users_Orgs.organizationId = -1)\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\t\torganizationIds.length * 2 + 1);\n\n\t\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\t\tfor (int i = 0; i < organizationIds.length; i++) {\n\t\t\t\t\t\tsb.append(\"(Users_Orgs.organizationId = ?) \");\n\n\t\t\t\t\t\tif ((i + 1) < organizationIds.length) {\n\t\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\t\tjoin = sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"usersOrgsTree\")) {\n\t\t\tList<Organization> organizationsTree = (List<Organization>)value;\n\n\t\t\tint size = organizationsTree.size();\n\n\t\t\tif (size > 0) {\n\t\t\t\tStringBundler sb = new StringBundler(size * 2 + 1);\n\n\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\tsb.append(\"(Organization_.treePath LIKE ?) \");\n\n\t\t\t\t\tif ((i + 1) < size) {\n\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\tjoin = sb.toString();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = \"WHERE (Organization_.treePath LIKE ?)\";\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"usersPasswordPolicies\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_PASSWORD_POLICIES);\n\t\t}\n\t\telse if (key.equals(\"usersRoles\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_ROLES);\n\t\t}\n\t\telse if (key.equals(\"usersTeams\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_TEAMS);\n\t\t}\n\t\telse if (key.equals(\"usersUserGroups\")) {\n\t\t\tif (value instanceof Long) {\n\t\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USERS_USER_GROUPS);\n\t\t\t}\n\t\t\telse if (value instanceof Long[]) {\n\t\t\t\tLong[] userGroupIds = (Long[])value;\n\n\t\t\t\tif (userGroupIds.length == 0) {\n\t\t\t\t\tjoin = \"WHERE (Users_UserGroups.userGroupId = -1)\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\t\tuserGroupIds.length * 2 + 1);\n\n\t\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\t\tfor (int i = 0; i < userGroupIds.length; i++) {\n\t\t\t\t\t\tsb.append(\"(Users_UserGroups.userGroupId = ?) \");\n\n\t\t\t\t\t\tif ((i + 1) < userGroupIds.length) {\n\t\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\t\tjoin = sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"announcementsDeliveryEmailOrSms\")) {\n\t\t\tjoin = CustomSQLUtil.get(\n\t\t\t\tJOIN_BY_ANNOUNCEMENTS_DELIVERY_EMAIL_OR_SMS);\n\t\t}\n\t\telse if (key.equals(\"socialMutualRelation\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_MUTUAL_RELATION);\n\t\t}\n\t\telse if (key.equals(\"socialMutualRelationType\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_MUTUAL_RELATION_TYPE);\n\t\t}\n\t\telse if (key.equals(\"socialRelation\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_RELATION);\n\t\t}\n\t\telse if (key.equals(\"socialRelationType\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_SOCIAL_RELATION_TYPE);\n\t\t}\n\t\telse if (value instanceof CustomSQLParam) {\n\t\t\tCustomSQLParam customSQLParam = (CustomSQLParam)value;\n\n\t\t\tjoin = customSQLParam.getSQL();\n\t\t}\n\n\t\tif (Validator.isNotNull(join)) {\n\t\t\tint pos = join.indexOf(\"WHERE\");\n\n\t\t\tif (pos != -1) {\n\t\t\t\tjoin = join.substring(pos + 5, join.length()).concat(\" AND \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = StringPool.BLANK;\n\t\t\t}\n\t\t}\n\n\t\treturn join;\n\t}","commit_id":"f1f373890d55fb83ba61f9144ad4d585fc6f0630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<User> findByC_FN_MN_LN_SN_EA_S(\n\t\t\tlong companyId, String[] firstNames, String[] middleNames,\n\t\t\tString[] lastNames, String[] screenNames, String[] emailAddresses,\n\t\t\tint status, LinkedHashMap<String, Object> params,\n\t\t\tboolean andOperator, int start, int end, OrderByComparator obc)\n\t\tthrows SystemException {\n\n\t\tfirstNames = CustomSQLUtil.keywords(firstNames);\n\t\tmiddleNames = CustomSQLUtil.keywords(middleNames);\n\t\tlastNames = CustomSQLUtil.keywords(lastNames);\n\t\tscreenNames = CustomSQLUtil.keywords(screenNames);\n\t\temailAddresses = CustomSQLUtil.keywords(emailAddresses);\n\n\t\tif (params == null) {\n\t\t\tparams = _emptyLinkedHashMap;\n\t\t}\n\n\t\tLong groupId = (Long)params.get(\"usersGroups\");\n\t\tboolean inherit = GetterUtil.getBoolean(params.get(\"inherit\"));\n\n\t\tboolean doUnion = Validator.isNotNull(groupId) && inherit;\n\n\t\tLinkedHashMap<String, Object> params1 = params;\n\n\t\tLinkedHashMap<String, Object> params2 = null;\n\n\t\tLinkedHashMap<String, Object> params3 = null;\n\n\t\tif (doUnion) {\n\t\t\tparams2 = new LinkedHashMap<String, Object>(params1);\n\n\t\t\tList<Long> organizationIds = new ArrayList<Long>();\n\n\t\t\tGroup group = GroupLocalServiceUtil.fetchGroup(groupId);\n\n\t\t\tif ((group != null) && group.isOrganization()) {\n\t\t\t\torganizationIds.add(group.getOrganizationId());\n\t\t\t}\n\n\t\t\tList<Organization> organizations = GroupUtil.getOrganizations(\n\t\t\t\tgroupId);\n\n\t\t\tfor (Organization organization : organizations) {\n\t\t\t\torganizationIds.add(organization.getOrganizationId());\n\t\t\t}\n\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams2.put(\n\t\t\t\t\"usersOrgs\",\n\t\t\t\torganizationIds.toArray(new Long[organizationIds.size()]));\n\n\t\t\tparams3 = new LinkedHashMap<String, Object>(params1);\n\n\t\t\tList<UserGroup> userGroups = GroupUtil.getUserGroups(groupId);\n\n\t\t\tLong[] userGroupIds = new Long[userGroups.size()];\n\n\t\t\tfor (int i = 0; i < userGroups.size(); i++) {\n\t\t\t\tUserGroup userGroup = userGroups.get(i);\n\n\t\t\t\tuserGroupIds[i] = userGroup.getUserGroupId();\n\t\t\t}\n\n\t\t\tparams3.remove(\"usersGroups\");\n\t\t\tparams3.put(\"usersUserGroups\", userGroupIds);\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_C_FN_MN_LN_SN_EA_S);\n\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.firstName)\", StringPool.LIKE, false,\n\t\t\t\tfirstNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.middleName)\", StringPool.LIKE, false,\n\t\t\t\tmiddleNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.lastName)\", StringPool.LIKE, false,\n\t\t\t\tlastNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.screenName)\", StringPool.LIKE, false,\n\t\t\t\tscreenNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.emailAddress)\", StringPool.LIKE, true,\n\t\t\t\temailAddresses);\n\n\t\t\tif (status == WorkflowConstants.STATUS_ANY) {\n\t\t\t\tsql = StringUtil.replace(sql, _STATUS_SQL, StringPool.BLANK);\n\t\t\t}\n\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(replaceJoinAndWhere(sql, params1));\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\tif (doUnion) {\n\t\t\t\tsb.append(\" UNION (\");\n\t\t\t\tsb.append(replaceJoinAndWhere(sql, params2));\n\t\t\t\tsb.append(\") UNION (\");\n\t\t\t\tsb.append(replaceJoinAndWhere(sql, params3));\n\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\t\t}\n\n\t\t\tif (obc != null) {\n\t\t\t\tsb.append(\" ORDER BY \");\n\t\t\t\tsb.append(obc.toString());\n\t\t\t}\n\n\t\t\tsql = sb.toString();\n\n\t\t\tsql = CustomSQLUtil.replaceAndOperator(sql, andOperator);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tsetJoin(qPos, params1);\n\n\t\t\tqPos.add(companyId);\n\t\t\tqPos.add(false);\n\t\t\tqPos.add(firstNames, 2);\n\t\t\tqPos.add(middleNames, 2);\n\t\t\tqPos.add(lastNames, 2);\n\t\t\tqPos.add(screenNames, 2);\n\t\t\tqPos.add(emailAddresses, 2);\n\n\t\t\tif (status != WorkflowConstants.STATUS_ANY) {\n\t\t\t\tqPos.add(status);\n\t\t\t}\n\n\t\t\tif (doUnion) {\n\t\t\t\tsetJoin(qPos, params2);\n\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(false);\n\t\t\t\tqPos.add(firstNames, 2);\n\t\t\t\tqPos.add(middleNames, 2);\n\t\t\t\tqPos.add(lastNames, 2);\n\t\t\t\tqPos.add(screenNames, 2);\n\t\t\t\tqPos.add(emailAddresses, 2);\n\n\t\t\t\tif (status != WorkflowConstants.STATUS_ANY) {\n\t\t\t\t\tqPos.add(status);\n\t\t\t\t}\n\n\t\t\t\tsetJoin(qPos, params3);\n\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(false);\n\t\t\t\tqPos.add(firstNames, 2);\n\t\t\t\tqPos.add(middleNames, 2);\n\t\t\t\tqPos.add(lastNames, 2);\n\t\t\t\tqPos.add(screenNames, 2);\n\t\t\t\tqPos.add(emailAddresses, 2);\n\n\t\t\t\tif (status != WorkflowConstants.STATUS_ANY) {\n\t\t\t\t\tqPos.add(status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Long> userIds = (List<Long>)QueryUtil.list(\n\t\t\t\tq, getDialect(), start, end);\n\n\t\t\tList<User> users = new ArrayList<User>(userIds.size());\n\n\t\t\tfor (Long userId : userIds) {\n\t\t\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\n\t\t\t\tusers.add(user);\n\t\t\t}\n\n\t\t\treturn users;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","id":71674,"modified_method":"public List<User> findByC_FN_MN_LN_SN_EA_S(\n\t\t\tlong companyId, String[] firstNames, String[] middleNames,\n\t\t\tString[] lastNames, String[] screenNames, String[] emailAddresses,\n\t\t\tint status, LinkedHashMap<String, Object> params,\n\t\t\tboolean andOperator, int start, int end, OrderByComparator obc)\n\t\tthrows SystemException {\n\n\t\tfirstNames = CustomSQLUtil.keywords(firstNames);\n\t\tmiddleNames = CustomSQLUtil.keywords(middleNames);\n\t\tlastNames = CustomSQLUtil.keywords(lastNames);\n\t\tscreenNames = CustomSQLUtil.keywords(screenNames);\n\t\temailAddresses = CustomSQLUtil.keywords(emailAddresses);\n\n\t\tif (params == null) {\n\t\t\tparams = _emptyLinkedHashMap;\n\t\t}\n\n\t\tLong[] groupIds = null;\n\n\t\tif (params.get(\"usersGroups\") instanceof Long) {\n\t\t\tgroupIds = new Long[] {(Long)params.get(\"usersGroups\")};\n\t\t}\n\t\telse {\n\t\t\tgroupIds = (Long[])params.get(\"usersGroups\");\n\t\t}\n\n\t\tboolean inherit = GetterUtil.getBoolean(params.get(\"inherit\"));\n\n\t\tboolean doUnion = Validator.isNotNull(groupIds) && inherit;\n\n\t\tLinkedHashMap<String, Object> params1 = params;\n\n\t\tLinkedHashMap<String, Object> params2 = null;\n\n\t\tLinkedHashMap<String, Object> params3 = null;\n\n\t\tif (doUnion) {\n\t\t\tparams2 = new LinkedHashMap<String, Object>(params1);\n\t\t\tparams3 = new LinkedHashMap<String, Object>(params1);\n\n\t\t\tparams2.remove(\"usersGroups\");\n\t\t\tparams3.remove(\"usersGroups\");\n\n\t\t\tList<Long> organizationIds = new ArrayList<Long>();\n\t\t\tList<Long> userGroupIds = new ArrayList<Long>();\n\n\t\t\tfor (long groupId : groupIds) {\n\t\t\t\tGroup group = GroupLocalServiceUtil.fetchGroup(groupId);\n\n\t\t\t\tif ((group != null) && group.isOrganization()) {\n\t\t\t\t\torganizationIds.add(group.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\tList<Organization> organizations = GroupUtil.getOrganizations(\n\t\t\t\t\tgroupId);\n\n\t\t\t\tfor (Organization organization : organizations) {\n\t\t\t\t\torganizationIds.add(organization.getOrganizationId());\n\t\t\t\t}\n\n\t\t\t\tList<UserGroup> userGroups = GroupUtil.getUserGroups(groupId);\n\n\t\t\t\tfor (int i = 0; i < userGroups.size(); i++) {\n\t\t\t\t\tUserGroup userGroup = userGroups.get(i);\n\n\t\t\t\t\tuserGroupIds.add(userGroup.getUserGroupId());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparams2.put(\n\t\t\t\t\"usersOrgs\",\n\t\t\t\torganizationIds.toArray(new Long[organizationIds.size()]));\n\n\t\t\tparams3.put(\n\t\t\t\t\"usersUserGroups\",\n\t\t\t\tuserGroupIds.toArray(new Long[userGroupIds.size()]));\n\t\t}\n\n\t\tSession session = null;\n\n\t\ttry {\n\t\t\tsession = openSession();\n\n\t\t\tString sql = CustomSQLUtil.get(FIND_BY_C_FN_MN_LN_SN_EA_S);\n\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.firstName)\", StringPool.LIKE, false,\n\t\t\t\tfirstNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.middleName)\", StringPool.LIKE, false,\n\t\t\t\tmiddleNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.lastName)\", StringPool.LIKE, false,\n\t\t\t\tlastNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.screenName)\", StringPool.LIKE, false,\n\t\t\t\tscreenNames);\n\t\t\tsql = CustomSQLUtil.replaceKeywords(\n\t\t\t\tsql, \"lower(User_.emailAddress)\", StringPool.LIKE, true,\n\t\t\t\temailAddresses);\n\n\t\t\tif (status == WorkflowConstants.STATUS_ANY) {\n\t\t\t\tsql = StringUtil.replace(sql, _STATUS_SQL, StringPool.BLANK);\n\t\t\t}\n\n\t\t\tStringBundler sb = new StringBundler();\n\n\t\t\tsb.append(StringPool.OPEN_PARENTHESIS);\n\t\t\tsb.append(replaceJoinAndWhere(sql, params1));\n\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\tif (doUnion) {\n\t\t\t\tsb.append(\" UNION (\");\n\t\t\t\tsb.append(replaceJoinAndWhere(sql, params2));\n\t\t\t\tsb.append(\") UNION (\");\n\t\t\t\tsb.append(replaceJoinAndWhere(sql, params3));\n\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\t\t\t}\n\n\t\t\tif (obc != null) {\n\t\t\t\tsb.append(\" ORDER BY \");\n\t\t\t\tsb.append(obc.toString());\n\t\t\t}\n\n\t\t\tsql = sb.toString();\n\n\t\t\tsql = CustomSQLUtil.replaceAndOperator(sql, andOperator);\n\n\t\t\tSQLQuery q = session.createSQLQuery(sql);\n\n\t\t\tq.addScalar(\"userId\", Type.LONG);\n\n\t\t\tQueryPos qPos = QueryPos.getInstance(q);\n\n\t\t\tsetJoin(qPos, params1);\n\n\t\t\tqPos.add(companyId);\n\t\t\tqPos.add(false);\n\t\t\tqPos.add(firstNames, 2);\n\t\t\tqPos.add(middleNames, 2);\n\t\t\tqPos.add(lastNames, 2);\n\t\t\tqPos.add(screenNames, 2);\n\t\t\tqPos.add(emailAddresses, 2);\n\n\t\t\tif (status != WorkflowConstants.STATUS_ANY) {\n\t\t\t\tqPos.add(status);\n\t\t\t}\n\n\t\t\tif (doUnion) {\n\t\t\t\tsetJoin(qPos, params2);\n\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(false);\n\t\t\t\tqPos.add(firstNames, 2);\n\t\t\t\tqPos.add(middleNames, 2);\n\t\t\t\tqPos.add(lastNames, 2);\n\t\t\t\tqPos.add(screenNames, 2);\n\t\t\t\tqPos.add(emailAddresses, 2);\n\n\t\t\t\tif (status != WorkflowConstants.STATUS_ANY) {\n\t\t\t\t\tqPos.add(status);\n\t\t\t\t}\n\n\t\t\t\tsetJoin(qPos, params3);\n\n\t\t\t\tqPos.add(companyId);\n\t\t\t\tqPos.add(false);\n\t\t\t\tqPos.add(firstNames, 2);\n\t\t\t\tqPos.add(middleNames, 2);\n\t\t\t\tqPos.add(lastNames, 2);\n\t\t\t\tqPos.add(screenNames, 2);\n\t\t\t\tqPos.add(emailAddresses, 2);\n\n\t\t\t\tif (status != WorkflowConstants.STATUS_ANY) {\n\t\t\t\t\tqPos.add(status);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tList<Long> userIds = (List<Long>)QueryUtil.list(\n\t\t\t\tq, getDialect(), start, end);\n\n\t\t\tList<User> users = new ArrayList<User>(userIds.size());\n\n\t\t\tfor (Long userId : userIds) {\n\t\t\t\tUser user = UserUtil.findByPrimaryKey(userId);\n\n\t\t\t\tusers.add(user);\n\t\t\t}\n\n\t\t\treturn users;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new SystemException(e);\n\t\t}\n\t\tfinally {\n\t\t\tcloseSession(session);\n\t\t}\n\t}","commit_id":"f1f373890d55fb83ba61f9144ad4d585fc6f0630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getWhere(LinkedHashMap<String, Object> params) {\n\t\tif ((params == null) || params.isEmpty()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(params.size());\n\n\t\tfor (Map.Entry<String, Object> entry : params.entrySet()) {\n\t\t\tString key = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\tsb.append(getWhere(key));\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":71675,"modified_method":"protected String getWhere(LinkedHashMap<String, Object> params) {\n\t\tif ((params == null) || params.isEmpty()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(params.size());\n\n\t\tfor (Map.Entry<String, Object> entry : params.entrySet()) {\n\t\t\tString key = entry.getKey();\n\t\t\tObject value = entry.getValue();\n\n\t\t\tif (Validator.isNotNull(value)) {\n\t\t\t\tsb.append(getWhere(key, value));\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"f1f373890d55fb83ba61f9144ad4d585fc6f0630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String getWhere(String key) {\n\t\tString join = StringPool.BLANK;\n\n\t\tif (key.equals(\"userGroupGroupRole\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUP_GROUP_ROLE);\n\t\t}\n\t\telse if (key.equals(\"userGroupsGroups\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_GROUPS);\n\t\t}\n\t\telse if (key.equals(\"userGroupsRoles\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_ROLES);\n\t\t}\n\t\telse if (key.equals(\"userGroupsTeams\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_TEAMS);\n\t\t}\n\t\telse if (key.equals(\"userGroupsUsers\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_USERS);\n\t\t}\n\n\t\tif (Validator.isNotNull(join)) {\n\t\t\tint pos = join.indexOf(\"WHERE\");\n\n\t\t\tif (pos != -1) {\n\t\t\t\tjoin = join.substring(pos + 5, join.length()).concat(\" AND \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = StringPool.BLANK;\n\t\t\t}\n\t\t}\n\n\t\treturn join;\n\t}","id":71676,"modified_method":"protected String getWhere(String key, Object value) {\n\t\tString join = StringPool.BLANK;\n\n\t\tif (key.equals(\"userGroupGroupRole\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUP_GROUP_ROLE);\n\t\t}\n\t\telse if (key.equals(\"userGroupsGroups\")) {\n\t\t\tif (value instanceof Long) {\n\t\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_GROUPS);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tLong[] userGroupIds = (Long[])value;\n\n\t\t\t\tif (userGroupIds.length == 0) {\n\t\t\t\t\tjoin = \"WHERE (Groups_UserGroups.groupId = -1)\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tStringBundler sb = new StringBundler(\n\t\t\t\t\t\tuserGroupIds.length * 2 + 1);\n\n\t\t\t\t\tsb.append(\"WHERE (\");\n\n\t\t\t\t\tfor (int i = 0; i < userGroupIds.length; i++) {\n\t\t\t\t\t\tsb.append(\"(Groups_UserGroups.groupId = ?) \");\n\n\t\t\t\t\t\tif ((i + 1) < userGroupIds.length) {\n\t\t\t\t\t\t\tsb.append(\"OR \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tsb.append(StringPool.CLOSE_PARENTHESIS);\n\n\t\t\t\t\tjoin = sb.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (key.equals(\"userGroupsRoles\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_ROLES);\n\t\t}\n\t\telse if (key.equals(\"userGroupsTeams\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_TEAMS);\n\t\t}\n\t\telse if (key.equals(\"userGroupsUsers\")) {\n\t\t\tjoin = CustomSQLUtil.get(JOIN_BY_USER_GROUPS_USERS);\n\t\t}\n\n\t\tif (Validator.isNotNull(join)) {\n\t\t\tint pos = join.indexOf(\"WHERE\");\n\n\t\t\tif (pos != -1) {\n\t\t\t\tjoin = join.substring(pos + 5, join.length()).concat(\" AND \");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tjoin = StringPool.BLANK;\n\t\t\t}\n\t\t}\n\n\t\treturn join;\n\t}","commit_id":"f1f373890d55fb83ba61f9144ad4d585fc6f0630","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final Editor editor = PlatformDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());\n      assert editor != null;\n      final TextRange textRange = ((ProblemDescriptorImpl)descriptor).getTextRange();\n      editor.getSelectionModel().setSelection(textRange.getStartOffset(), textRange.getEndOffset());\n\n      final String word = editor.getSelectionModel().getSelectedText();\n\n      if (word == null || StringUtil.isEmptyOrSpaces(word)) {\n        return;\n      }\n      final List<LookupElement> items = new ArrayList<LookupElement>();\n      for (String variant : myUnboundParams) {\n        items.add(LookupElementBuilder.create(variant));\n      }\n      LookupManager.getInstance(project).showLookup(editor, items.toArray(new LookupElement[items.size()]));\n    }","id":71677,"modified_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n      final AsyncResult<DataContext> asyncResult = DataManager.getInstance().getDataContextFromFocus();\n      asyncResult.doWhenDone(new AsyncResult.Handler<DataContext>() {\n        @Override\n        public void run(DataContext dataContext) {\n          final Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n          assert editor != null;\n          final TextRange textRange = ((ProblemDescriptorImpl)descriptor).getTextRange();\n          editor.getSelectionModel().setSelection(textRange.getStartOffset(), textRange.getEndOffset());\n\n          final String word = editor.getSelectionModel().getSelectedText();\n\n          if (word == null || StringUtil.isEmptyOrSpaces(word)) {\n            return;\n          }\n          final List<LookupElement> items = new ArrayList<LookupElement>();\n          for (String variant : myUnboundParams) {\n            items.add(LookupElementBuilder.create(variant));\n          }\n          LookupManager.getInstance(project).showLookup(editor, items.toArray(new LookupElement[items.size()]));\n        }\n      });\n    }","commit_id":"d272009327b16b23905db10b55d109f9216134f6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n      final PsiElement element = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PsiJavaCodeReferenceElement.class);\n      if (element instanceof PsiJavaCodeReferenceElement) {\n        final PsiJavaCodeReferenceElement referenceElement = (PsiJavaCodeReferenceElement)element;\n        Collections.sort(myClassesToImport, new PsiProximityComparator(referenceElement.getElement()));\n        final JList list = new JBList(myClassesToImport.toArray(new PsiClass[myClassesToImport.size()]));\n        list.setCellRenderer(new FQNameCellRenderer());\n        Runnable runnable = new Runnable() {\n          public void run() {\n            if (!element.isValid()) return;\n            final int index = list.getSelectedIndex();\n            if (index < 0) return;\n            new WriteCommandAction(project, element.getContainingFile()){\n              protected void run(final Result result) throws Throwable {\n                final PsiClass psiClass = myClassesToImport.get(index);\n                if (psiClass.isValid()) {\n                  PsiDocumentManager.getInstance(project).commitAllDocuments();\n                  referenceElement.bindToElement(psiClass);\n                }\n              }\n            }.execute();\n          }\n        };\n        final Editor editor = PlatformDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());\n        assert editor != null; //available for on the fly mode only\n        new PopupChooserBuilder(list).\n          setTitle(QuickFixBundle.message(\"class.to.import.chooser.title\")).\n          setItemChoosenCallback(runnable).\n          createPopup().\n          showInBestPositionFor(editor);\n      }\n    }","id":71678,"modified_method":"public void applyFix(@NotNull final Project project, @NotNull final ProblemDescriptor descriptor) {\n      final PsiElement element = PsiTreeUtil.getParentOfType(descriptor.getPsiElement(), PsiJavaCodeReferenceElement.class);\n      if (element instanceof PsiJavaCodeReferenceElement) {\n        final PsiJavaCodeReferenceElement referenceElement = (PsiJavaCodeReferenceElement)element;\n        Collections.sort(myClassesToImport, new PsiProximityComparator(referenceElement.getElement()));\n        final JList list = new JBList(myClassesToImport.toArray(new PsiClass[myClassesToImport.size()]));\n        list.setCellRenderer(new FQNameCellRenderer());\n        final Runnable runnable = new Runnable() {\n          public void run() {\n            if (!element.isValid()) return;\n            final int index = list.getSelectedIndex();\n            if (index < 0) return;\n            new WriteCommandAction(project, element.getContainingFile()){\n              protected void run(final Result result) throws Throwable {\n                final PsiClass psiClass = myClassesToImport.get(index);\n                if (psiClass.isValid()) {\n                  PsiDocumentManager.getInstance(project).commitAllDocuments();\n                  referenceElement.bindToElement(psiClass);\n                }\n              }\n            }.execute();\n          }\n        };\n        final AsyncResult<DataContext> asyncResult = DataManager.getInstance().getDataContextFromFocus();\n        asyncResult.doWhenDone(new AsyncResult.Handler<DataContext>() {\n          @Override\n          public void run(DataContext dataContext) {\n            final Editor editor = PlatformDataKeys.EDITOR.getData(dataContext);\n            assert editor != null; //available for on the fly mode only\n            new PopupChooserBuilder(list).\n              setTitle(QuickFixBundle.message(\"class.to.import.chooser.title\")).\n              setItemChoosenCallback(runnable).\n              createPopup().\n              showInBestPositionFor(editor);\n          }\n        });\n      }\n    }","commit_id":"258e8abd1f2d2e0b1b9faf8be9ea04f4d313986d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      final RefactoringActionHandler handler = JavaRefactoringActionHandlerFactory.getInstance().createIntroduceVariableHandler();\n      handler.invoke(project, new PsiElement[]{myExpr}, DataManager.getInstance().getDataContext());\n      // how to automatically annotate the variable after it has been introduced?\n    }","id":71679,"modified_method":"public void applyFix(@NotNull final Project project, @NotNull ProblemDescriptor descriptor) {\n      final RefactoringActionHandler handler = JavaRefactoringActionHandlerFactory.getInstance().createIntroduceVariableHandler();\n      final AsyncResult<DataContext> dataContextContainer = DataManager.getInstance().getDataContextFromFocus();\n      dataContextContainer.doWhenDone(new AsyncResult.Handler<DataContext>() {\n        public void run(DataContext dataContext) {\n          handler.invoke(project, new PsiElement[]{myExpr}, dataContext);\n        }\n      });\n      // how to automatically annotate the variable after it has been introduced?\n    }","commit_id":"d411058586ee21846db8d366806eb13fd4b6bd68","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DirectoryWatcher(Dictionary properties, BundleContext context)\n    {\n        super(properties.toString());\n        this.context = context;\n        poll = getLong(properties, POLL, 2000);\n        debug = getLong(properties, DEBUG, -1);\n        originatingFileName = (String) properties.get(FILENAME);\n        watchedDirectory = getFile(properties, DIR, new File(\"./load\"));\n        prepareDir(watchedDirectory);\n        tmpDir = getFile(properties, TMPDIR, new File(\"./tmp\"));\n        startBundles = getBoolean(properties, START_NEW_BUNDLES, true);  // by default, we start bundles.\n        filter = (String) properties.get(FILTER);\n\n        FilenameFilter flt;\n        if (filter != null && filter.length() > 0)\n        {\n            flt = new FilenameFilter()\n            {\n                public boolean accept(File dir, String name) {\n                    return name.matches(filter);\n                }\n            };\n        }\n        else\n        {\n            flt = null;\n        }\n        scanner = new Scanner(watchedDirectory, flt);\n    }","id":71680,"modified_method":"public DirectoryWatcher(Dictionary properties, BundleContext context)\n    {\n        super(properties.toString());\n        this.context = context;\n        poll = getLong(properties, POLL, 2000);\n        debug = getLong(properties, DEBUG, -1);\n        originatingFileName = (String) properties.get(FILENAME);\n        watchedDirectory = getFile(properties, DIR, new File(\"./load\"));\n        prepareDir(watchedDirectory);\n        tmpDir = getFile(properties, TMPDIR, new File(\"./tmp\"));\n        startBundles = getBoolean(properties, START_NEW_BUNDLES, true);  // by default, we start bundles.\n        filter = (String) properties.get(FILTER);\n        noInitialDelay = getBoolean(properties, NO_INITIAL_DELAY, false);\n\n        FilenameFilter flt;\n        if (filter != null && filter.length() > 0)\n        {\n            flt = new FilenameFilter()\n            {\n                public boolean accept(File dir, String name) {\n                    return name.matches(filter);\n                }\n            };\n        }\n        else\n        {\n            flt = null;\n        }\n        scanner = new Scanner(watchedDirectory, flt);\n\n        if (noInitialDelay)\n        {\n            log(\"Starting initial scan\", null);\n            initializeCurrentManagedBundles();\n            scanner.initialize(currentManagedArtifacts.keySet());\n            Set/*<File>*/ files = scanner.scan(true);\n            if (files != null)\n            {\n                process(files);\n            }\n        }\n    }","commit_id":"644f9e309c7877943b47485ad1aad44e73ec6707","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Main run loop, will traverse the directory, and then handle the delta\n     * between installed and newly found/lost bundles and configurations.\n     *\n     */\n    public void run()\n    {\n        log(\"{\" + POLL + \" (ms) = \" + poll + \", \"\n                + DIR + \" = \" + watchedDirectory.getAbsolutePath() + \", \"\n                + DEBUG + \" = \" + debug + \", \"\n                + START_NEW_BUNDLES + \" = \" + startBundles + \", \"\n                + TMPDIR + \" = \" + tmpDir + \", \"\n                + FILTER + \" = \" + filter + \"}\", null);\n\n        initializeCurrentManagedBundles();\n\n        scanner.initialize(currentManagedArtifacts.keySet());\n\n        while (!interrupted())\n        {\n            try\n            {\n                Set/*<File>*/ files = scanner.scan();\n                // Check that there is a result.  If not, this means that the directory can not be listed,\n                // so it's presumably not a valid directory (it may have been deleted by someone).\n                // In such case, just sleep\n                if (files == null)\n                {\n                    Thread.sleep(poll);\n                    continue;\n                }\n\n                List/*<ArtifactListener>*/ listeners = FileInstall.getListeners();\n                List/*<Artifact>*/ deleted = new ArrayList/*<Artifact>*/();\n                List/*<Artifact>*/ modified = new ArrayList/*<Artifact>*/();\n                List/*<Artifact>*/ created = new ArrayList/*<Artifact>*/();\n\n                // Try to process again files that could not be processed\n                files.addAll(processingFailures);\n                processingFailures.clear();\n\n                for (Iterator it = files.iterator(); it.hasNext();)\n                {\n                    File file = (File) it.next();\n                    boolean exists = file.exists();\n                    Artifact artifact = (Artifact) currentManagedArtifacts.get(file);\n                    // File has been deleted\n                    if (!exists && artifact != null)\n                    {\n                        deleteJaredDirectory(artifact);\n                        deleteTransformedFile(artifact);\n                        deleted.add(artifact);\n                    }\n                    else\n                    {\n                        File jar  = file;\n                        // Jar up the directory if needed\n                        if (file.isDirectory())\n                        {\n                            prepareDir(tmpDir);\n                            try\n                            {\n                                jar = new File(tmpDir, file.getName() + \".jar\");\n                                Util.jarDir(file, jar);\n\n                            }\n                            catch (IOException e)\n                            {\n                                log(\"Unable to create jar for: \" + file.getAbsolutePath(), e);\n                                continue;\n                            }\n                        }\n                        // File has been modified\n                        if (exists && artifact != null)\n                        {\n                            // Check the last modified date against\n                            // the artifact last modified date if available.  This will loose\n                            // the possibility of the jar being replaced by an older one\n                            // or the content changed without the date being modified, but\n                            // else, we'd have to reinstall all the deployed bundles on restart.\n                            if (artifact.getLastModified() > Util.getLastModified(file))\n                            {\n                                continue;\n                            }\n                            // If there's no listener, this is because this artifact has been installed before\n                            // fileinstall has been restarted.  In this case, try to find a listener.\n                            if (artifact.getListener() == null)\n                            {\n                                ArtifactListener listener = findListener(jar, listeners);\n                                // If no listener can handle this artifact, we need to defer the\n                                // processing for this artifact until one is found\n                                if (listener == null)\n                                {\n                                    processingFailures.add(file);\n                                    continue;\n                                }\n                                artifact.setListener(listener);\n                            }\n                            // If the listener can not handle this file anymore,\n                            // uninstall the artifact and try as if is was new\n                            if (!listeners.contains(artifact.getListener()) || !artifact.getListener().canHandle(jar))\n                            {\n                                deleted.add(artifact);\n                                artifact = null;\n                            }\n                            // The listener is still ok\n                            else\n                            {\n                                deleteTransformedFile(artifact);\n                                artifact.setJaredDirectory(jar);\n                                if (transformArtifact(artifact))\n                                {\n                                    modified.add(artifact);\n                                }\n                                else\n                                {\n                                    deleteJaredDirectory(artifact);\n                                    deleted.add(artifact);\n                                }\n                                continue;\n                            }\n                        }\n                        // File has been added\n                        if (exists && artifact == null)\n                        {\n                            // Find the listener\n                            ArtifactListener listener = findListener(jar, listeners);\n                            // If no listener can handle this artifact, we need to defer the\n                            // processing for this artifact until one is found\n                            if (listener == null)\n                            {\n                                processingFailures.add(file);\n                                continue;\n                            }\n                            // Create the artifact\n                            artifact = new Artifact();\n                            artifact.setPath(file);\n                            artifact.setJaredDirectory(jar);\n                            artifact.setListener(listener);\n                            if (transformArtifact(artifact))\n                            {\n                                created.add(artifact);\n                            }\n                            else\n                            {\n                                deleteJaredDirectory(artifact);\n                            }\n                        }\n                    }\n                }\n                // Handle deleted artifacts\n                // We do the operations in the following order:\n                // uninstall, update, install, refresh & start.\n                Collection uninstalledBundles = uninstall(deleted);\n                Collection updatedBundles = update(modified);\n                Collection installedBundles = install(created);\n                if (uninstalledBundles.size() > 0 || updatedBundles.size() > 0)\n                {\n                    // Refresh if any bundle got uninstalled or updated.\n                    // This can lead to restart of recently updated bundles, but\n                    // don't worry about that at this point of time.\n                    refresh();\n                }\n\n                if (startBundles)\n                {\n                    // Try to start all the bundles that are not persistently stopped\n                    startAllBundles();\n                    // Try to start newly installed bundles\n                    start(installedBundles);\n                }\n\n                Thread.sleep(poll);\n            }\n            catch (InterruptedException e)\n            {\n                return;\n            }\n            catch (Throwable e)\n            {\n                log(\"In main loop, we have serious trouble\", e);\n            }\n        }\n    }","id":71681,"modified_method":"/**\n     * Main run loop, will traverse the directory, and then handle the delta\n     * between installed and newly found/lost bundles and configurations.\n     *\n     */\n    public void run()\n    {\n        log(\"{\" + POLL + \" (ms) = \" + poll + \", \"\n                + DIR + \" = \" + watchedDirectory.getAbsolutePath() + \", \"\n                + DEBUG + \" = \" + debug + \", \"\n                + START_NEW_BUNDLES + \" = \" + startBundles + \", \"\n                + TMPDIR + \" = \" + tmpDir + \", \"\n                + FILTER + \" = \" + filter + \"}\", null);\n\n        if (!noInitialDelay)\n        {\n            initializeCurrentManagedBundles();\n            scanner.initialize(currentManagedArtifacts.keySet());\n        }\n\n        while (!interrupted())\n        {\n            try\n            {\n                Set/*<File>*/ files = scanner.scan(false);\n                // Check that there is a result.  If not, this means that the directory can not be listed,\n                // so it's presumably not a valid directory (it may have been deleted by someone).\n                // In such case, just sleep\n                if (files == null)\n                {\n                    synchronized (this)\n                    {\n                        wait(poll);\n                    }\n                    continue;\n                }\n\n                process(files);\n\n                synchronized (this)\n                {\n                    wait(poll);\n                }\n            }\n            catch (InterruptedException e)\n            {\n                return;\n            }\n            catch (Throwable e)\n            {\n                log(\"In main loop, we have serious trouble\", e);\n            }\n        }\n    }","commit_id":"644f9e309c7877943b47485ad1aad44e73ec6707","url":"https://github.com/apache/felix"},{"original_method":"private void addListener(ArtifactListener listener)\n    {\n        synchronized (listeners)\n        {\n            listeners.add(listener);\n        }\n    }","id":71682,"modified_method":"private void addListener(ArtifactListener listener)\n    {\n        synchronized (listeners)\n        {\n            listeners.add(listener);\n        }\n        notifyWatchers();\n    }","commit_id":"644f9e309c7877943b47485ad1aad44e73ec6707","url":"https://github.com/apache/felix"},{"original_method":"public void deleted(String pid)\n    {\n        DirectoryWatcher watcher = (DirectoryWatcher) watchers.remove(pid);\n        if (watcher != null)\n        {\n            watcher.close();\n        }\n    }","id":71683,"modified_method":"public void deleted(String pid)\n    {\n        DirectoryWatcher watcher;\n        synchronized (watchers)\n        {\n            watcher = (DirectoryWatcher) watchers.remove(pid);\n        }\n        if (watcher != null)\n        {\n            watcher.close();\n        }\n    }","commit_id":"644f9e309c7877943b47485ad1aad44e73ec6707","url":"https://github.com/apache/felix"},{"original_method":"public void start(BundleContext context) throws Exception\n    {\n        this.context = context;\n        addListener(new BundleTransformer());\n        Hashtable props = new Hashtable();\n        props.put(Constants.SERVICE_PID, getName());\n        context.registerService(ManagedServiceFactory.class.getName(), this,\n            props);\n\n        padmin = new ServiceTracker(context, PackageAdmin.class.getName(), null);\n        padmin.open();\n        startLevel = new ServiceTracker(context, StartLevel.class.getName(), null);\n        startLevel.open();\n        cmTracker = new ServiceTracker(context, ConfigurationAdmin.class.getName(), null)\n        {\n            public Object addingService(ServiceReference serviceReference)\n            {\n                ConfigurationAdmin cm = (ConfigurationAdmin) super.addingService(serviceReference);\n                configInstaller = new ConfigInstaller(context);\n                addListener(configInstaller);\n                return cm;\n            }\n            public void removedService(ServiceReference serviceReference, Object o)\n            {\n                configInstaller = null;\n                removeListener(configInstaller);\n                super.removedService(serviceReference, o);\n            }\n        };\n        cmTracker.open();\n        String flt = \"(|(\" + Constants.OBJECTCLASS + \"=\" + ArtifactInstaller.class.getName() + \")\"\n                     + \"(\" + Constants.OBJECTCLASS + \"=\" + ArtifactTransformer.class.getName() + \"))\";\n        listenersTracker = new ServiceTracker(context, FrameworkUtil.createFilter(flt), null)\n        {\n            public Object addingService(ServiceReference serviceReference)\n            {\n                ArtifactListener listener = (ArtifactListener) super.addingService(serviceReference);\n                addListener(listener);\n                return listener;\n            }\n            public void removedService(ServiceReference serviceReference, Object o)\n            {\n                removeListener((ArtifactListener) o);\n            }\n        };\n        listenersTracker.open();\n\n        // Created the initial configuration\n        Hashtable ht = new Hashtable();\n\n        set(ht, DirectoryWatcher.POLL);\n        set(ht, DirectoryWatcher.DIR);\n        set(ht, DirectoryWatcher.DEBUG);\n        set(ht, DirectoryWatcher.FILTER);\n        set(ht, DirectoryWatcher.TMPDIR);\n        set(ht, DirectoryWatcher.START_NEW_BUNDLES);\n        updated(\"initial\", ht);\n    }","id":71684,"modified_method":"public void start(BundleContext context) throws Exception\n    {\n        this.context = context;\n        addListener(new BundleTransformer());\n        Hashtable props = new Hashtable();\n        props.put(Constants.SERVICE_PID, getName());\n        context.registerService(ManagedServiceFactory.class.getName(), this,\n            props);\n\n        padmin = new ServiceTracker(context, PackageAdmin.class.getName(), null);\n        padmin.open();\n        startLevel = new ServiceTracker(context, StartLevel.class.getName(), null);\n        startLevel.open();\n        cmTracker = new ServiceTracker(context, ConfigurationAdmin.class.getName(), null)\n        {\n            public Object addingService(ServiceReference serviceReference)\n            {\n                ConfigurationAdmin cm = (ConfigurationAdmin) super.addingService(serviceReference);\n                configInstaller = new ConfigInstaller(context);\n                addListener(configInstaller);\n                return cm;\n            }\n            public void removedService(ServiceReference serviceReference, Object o)\n            {\n                configInstaller = null;\n                removeListener(configInstaller);\n                super.removedService(serviceReference, o);\n            }\n        };\n        cmTracker.open();\n        String flt = \"(|(\" + Constants.OBJECTCLASS + \"=\" + ArtifactInstaller.class.getName() + \")\"\n                     + \"(\" + Constants.OBJECTCLASS + \"=\" + ArtifactTransformer.class.getName() + \"))\";\n        listenersTracker = new ServiceTracker(context, FrameworkUtil.createFilter(flt), null)\n        {\n            public Object addingService(ServiceReference serviceReference)\n            {\n                ArtifactListener listener = (ArtifactListener) super.addingService(serviceReference);\n                addListener(listener);\n                return listener;\n            }\n            public void removedService(ServiceReference serviceReference, Object o)\n            {\n                removeListener((ArtifactListener) o);\n            }\n        };\n        listenersTracker.open();\n\n        // Created the initial configuration\n        Hashtable ht = new Hashtable();\n\n        set(ht, DirectoryWatcher.POLL);\n        set(ht, DirectoryWatcher.DIR);\n        set(ht, DirectoryWatcher.DEBUG);\n        set(ht, DirectoryWatcher.FILTER);\n        set(ht, DirectoryWatcher.TMPDIR);\n        set(ht, DirectoryWatcher.START_NEW_BUNDLES);\n        set(ht, DirectoryWatcher.NO_INITIAL_DELAY);\n        updated(\"initial\", ht);\n    }","commit_id":"644f9e309c7877943b47485ad1aad44e73ec6707","url":"https://github.com/apache/felix"},{"original_method":"private void removeListener(ArtifactListener listener)\n    {\n        synchronized (listeners)\n        {\n            listeners.remove(listener);\n        }\n    }","id":71685,"modified_method":"private void removeListener(ArtifactListener listener)\n    {\n        synchronized (listeners)\n        {\n            listeners.remove(listener);\n        }\n        notifyWatchers();\n    }","commit_id":"644f9e309c7877943b47485ad1aad44e73ec6707","url":"https://github.com/apache/felix"},{"original_method":"public void stop(BundleContext context) throws Exception\n    {\n        for (Iterator w = watchers.values().iterator(); w.hasNext();)\n        {\n            try\n            {\n                DirectoryWatcher dir = (DirectoryWatcher) w.next();\n                w.remove();\n                dir.close();\n            }\n            catch (Exception e)\n            {\n                // Ignore\n            }\n        }\n        listenersTracker.close();\n        cmTracker.close();\n        padmin.close();\n    }","id":71686,"modified_method":"public void stop(BundleContext context) throws Exception\n    {\n        List /*<DirectoryWatcher>*/ toClose = new ArrayList /*<DirectoryWatcher>*/();\n        synchronized (watchers)\n        {\n            toClose.addAll(watchers.values());\n            watchers.clear();\n        }\n        for (Iterator w = toClose.iterator(); w.hasNext();)\n        {\n            try\n            {\n                DirectoryWatcher dir = (DirectoryWatcher) w.next();\n                dir.close();\n            }\n            catch (Exception e)\n            {\n                // Ignore\n            }\n        }\n        listenersTracker.close();\n        cmTracker.close();\n        padmin.close();\n    }","commit_id":"644f9e309c7877943b47485ad1aad44e73ec6707","url":"https://github.com/apache/felix"},{"original_method":"public void logStatus( Log log )\n    {\n        log.info( \"\" );\n        log.info( \"The following files have been resolved: \" );\n        if ( this.resolvedDependencies.isEmpty() )\n        {\n            log.info( \"   none\" );\n        }\n        else\n        {\n            for ( Iterator i = this.resolvedDependencies.iterator(); i.hasNext(); )\n            {\n                log.info( \"   \" + ( (Artifact) i.next() ).getId() );\n            }\n        }\n\n        if ( this.skippedDependencies != null && !this.skippedDependencies.isEmpty() )\n        {\n            log.info( \"\" );\n            log.info( \"The following files where skipped: \" );\n            for ( Iterator i = this.skippedDependencies.iterator(); i.hasNext(); )\n            {\n                log.info( \"   \" + ( (Artifact) i.next() ).getId() );\n            }\n        }\n        log.info( \"\" );\n\n        if ( this.unResolvedDependencies != null && !this.unResolvedDependencies.isEmpty() )\n        {\n            log.info( \"The following files have NOT been resolved: \" );\n            for ( Iterator i = this.unResolvedDependencies.iterator(); i.hasNext(); )\n            {\n                log.info( \"   \" + ( (Artifact) i.next() ).getId() );\n            }\n        }\n        log.info( \"\" );\n\n    }","id":71687,"modified_method":"public void logStatus( Log log )\n    {\n        log.info( \"\" );\n        log.info( \"The following files have been resolved: \" );\n        if ( this.resolvedDependencies.isEmpty() )\n        {\n            log.info( \"   none\" );\n        }\n        else\n        {\n        \tSortedSet sortedResolvedDependencies = new TreeSet();\n        \tsortedResolvedDependencies.addAll(resolvedDependencies);\n            for ( Iterator i = sortedResolvedDependencies.iterator(); i.hasNext(); )\n            {\n                log.info( \"   \" + ( (Artifact) i.next() ).getId() );\n            }\n        }\n\n        if ( this.skippedDependencies != null && !this.skippedDependencies.isEmpty() )\n        {\n            log.info( \"\" );\n            log.info( \"The following files where skipped: \" );\n            SortedSet sortedSkippedDependencies = new TreeSet();\n            sortedSkippedDependencies.addAll(this.skippedDependencies);\n            for ( Iterator i = sortedSkippedDependencies.iterator(); i.hasNext(); )\n            {\n                log.info( \"   \" + ( (Artifact) i.next() ).getId() );\n            }\n        }\n        log.info( \"\" );\n\n        if ( this.unResolvedDependencies != null && !this.unResolvedDependencies.isEmpty() )\n        {\n            log.info( \"The following files have NOT been resolved: \" );\n            SortedSet sortedUnResolvedDependencies = new TreeSet();\n            sortedUnResolvedDependencies.addAll(this.unResolvedDependencies);\n            for ( Iterator i = sortedUnResolvedDependencies.iterator(); i.hasNext(); )\n            {\n                log.info( \"   \" + ( (Artifact) i.next() ).getId() );\n            }\n        }\n        log.info( \"\" );\n\n    }","commit_id":"38296ebf2e9bd8e21858e4866ce5792dce3bd306","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n      * Manage the Get requests (GetFolders, GetFoldersAndFiles, CreateFolder).<br>\n      *\n      * The servlet accepts commands sent in the following format:<br>\n      * connector?Command=CommandName&Type=ResourceType&CurrentFolder=FolderPath<br><br>\n      * It executes the command and then return the results to the client in XML format.\n      *\n      * Valid values for Type are: Image, File, Flash and Link \n      *\n      */\n     public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n          \n          response.setContentType(\"text/xml; charset=UTF-8\");\n          response.setHeader(\"Cache-Control\",\"no-cache\");\n          PrintWriter out = null;\n          \n          String commandStr = request.getParameter(\"Command\");\n          String type = request.getParameter(\"Type\");\n          String currentFolder = request.getParameter(\"CurrentFolder\");\n\n          Document document = null;\n          try {\n               DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n               DocumentBuilder builder = factory.newDocumentBuilder();\n               document = builder.newDocument();\n          } \n          catch (ParserConfigurationException pce) {\n               pce.printStackTrace();\n          }\n          \n          Node root = createCommonXml(document, commandStr, type, currentFolder, \"/access/content\"+currentFolder);\n          \n          if (\"GetFolders\".equals(commandStr)) {\n               getFolders(currentFolder, root, document);\n          }\n          else if (\"GetFoldersAndFiles\".equals(commandStr)) {\n               getFolders(currentFolder, root, document);\n               getFiles(currentFolder, root, document, type);\n          }\n          else if (\"CreateFolder\".equals(commandStr)) {\n               String newFolderStr = request.getParameter(\"NewFolderName\");\n               String status = \"110\";\n               \n               try {\n            \t    ContentCollectionEdit edit = ContentHostingService.addCollection(currentFolder + Validator.escapeResourceName(newFolderStr) + Entity.SEPARATOR);\n                    ResourcePropertiesEdit resourceProperties = edit.getPropertiesEdit();\n                    resourceProperties.addProperty (ResourceProperties.PROP_DISPLAY_NAME, newFolderStr);\n                    ContentHostingService.commitCollection(edit);\n                    \n                    status=\"0\";\n               }\n               catch (IdUsedException iue) {\n                    status = \"101\";\n               }\n               catch(PermissionException pex) {\n                    status = \"103\";                    \n               }               \n               catch (Exception e) {\n                    status = \"102\";               \n               }\n               setCreateFolderResponse(status, root, document);\n          }          \n          \n          document.getDocumentElement().normalize();\n          try {\n               out = response.getWriter();\n               TransformerFactory tFactory = TransformerFactory.newInstance();\n               Transformer transformer = tFactory.newTransformer();\n               \n               DOMSource source = new DOMSource(document);\n     \n               StreamResult result = new StreamResult(out);\n               transformer.transform(source, result);\n\n          } \n          catch (Exception ex) {\n               ex.printStackTrace();\n          }\n          finally {  \t  \n\t          if (out != null) {\n\t        \t  out.close();\n\t          }\n          }\n     }","id":71688,"modified_method":"/**\n      * Manage the Get requests (GetFolders, GetFoldersAndFiles, CreateFolder).<br>\n      *\n      * The servlet accepts commands sent in the following format:<br>\n      * connector?Command=CommandName&Type=ResourceType&CurrentFolder=FolderPath<br><br>\n      * It executes the command and then return the results to the client in XML format.\n      *\n      * Valid values for Type are: Image, File, Flash and Link \n      *\n      */\n     public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n          \n          response.setContentType(\"text/xml; charset=UTF-8\");\n          response.setHeader(\"Cache-Control\",\"no-cache\");\n          PrintWriter out = null;\n          \n          String commandStr = request.getParameter(\"Command\");\n          String type = request.getParameter(\"Type\");\n          String currentFolder = request.getParameter(\"CurrentFolder\");\n\n          String collectionBase = request.getPathInfo();\n\n          SecurityAdvisor advisor = (SecurityAdvisor) SessionManager.getCurrentSession()\n               .getAttribute(FCK_ADVISOR_BASE + collectionBase);\n          if (advisor != null) {\n               SecurityService.pushAdvisor(advisor);\n          }\n          \n          Document document = null;\n          try {\n               DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n               DocumentBuilder builder = factory.newDocumentBuilder();\n               document = builder.newDocument();\n          } \n          catch (ParserConfigurationException pce) {\n               pce.printStackTrace();\n          }\n          \n          Node root = createCommonXml(document, commandStr, type, currentFolder, \n        \t   ContentHostingService.getUrl(currentFolder));\n          \n          if (\"GetFolders\".equals(commandStr)) {\n               getFolders(currentFolder, root, document, collectionBase);\n          }\n          else if (\"GetFoldersAndFiles\".equals(commandStr)) {\n               getFolders(currentFolder, root, document, collectionBase);\n               getFiles(currentFolder, root, document, type);\n          }\n          else if (\"CreateFolder\".equals(commandStr)) {\n               String newFolderStr = request.getParameter(\"NewFolderName\");\n               String status = \"110\";\n               \n               try {\n            \t    ContentCollectionEdit edit = ContentHostingService.addCollection(currentFolder + Validator.escapeResourceName(newFolderStr) + Entity.SEPARATOR);\n                    ResourcePropertiesEdit resourceProperties = edit.getPropertiesEdit();\n                    resourceProperties.addProperty (ResourceProperties.PROP_DISPLAY_NAME, newFolderStr);\n                    ContentHostingService.commitCollection(edit);\n                    \n                    status=\"0\";\n               }\n               catch (IdUsedException iue) {\n                    status = \"101\";\n               }\n               catch(PermissionException pex) {\n                    status = \"103\";                    \n               }               \n               catch (Exception e) {\n                    status = \"102\";               \n               }\n               setCreateFolderResponse(status, root, document);\n          }          \n          \n          document.getDocumentElement().normalize();\n          try {\n               out = response.getWriter();\n               TransformerFactory tFactory = TransformerFactory.newInstance();\n               Transformer transformer = tFactory.newTransformer();\n               \n               DOMSource source = new DOMSource(document);\n     \n               StreamResult result = new StreamResult(out);\n               transformer.transform(source, result);\n\n          } \n          catch (Exception ex) {\n               ex.printStackTrace();\n          }\n          finally {  \t  \n\t          if (out != null) {\n\t        \t  out.close();\n\t          }\n          }\n          \n          if (advisor != null) {\n        \t  SecurityService.clearAdvisors();\n          }\n     }","commit_id":"f562faca741a5e6aca5125450440249aaf62f455","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private void getFolders(String dir, Node root, Document doc) {\n          Element folders = doc.createElement(\"Folders\");\n          root.appendChild(folders);\n                    \n          ContentCollection collection = null;\n         \n          Map map = null; \n          Iterator foldersIterator = null;\n   \n          try {\n               //hides the real root level stuff and just shows the users the\n               //the root folders of all the sites they actually have access to.\n               if (dir.split(\"/\").length == 2) {\n                    map = ContentHostingService.getCollectionMap();\n                    if (map != null && map.keySet() != null)\n                         foldersIterator = map.keySet().iterator();\n               }\n               else if (dir.split(\"/\").length > 2) {\n                    collection = ContentHostingService.getCollection(dir);\n                    if (collection != null && collection.getMembers() != null) {\n                         foldersIterator = collection.getMembers().iterator();\n                    }\n               }          \n          }\n          catch (Exception e) {    \n               e.printStackTrace();\n               //not a valid collection? file list will be empty and so will the doc\n          }\n          if (foldersIterator != null) {\n               String current = null;\n               \n               while (foldersIterator.hasNext()) {\n                    try {\n                         current = (String) foldersIterator.next();\n                         ContentCollection myCollection = ContentHostingService.getCollection(current);\n                         Element element=doc.createElement(\"Folder\");\n                         element.setAttribute(\"url\", current);\n                         element.setAttribute(\"name\", myCollection.getProperties().getProperty(\n                        \t\t myCollection.getProperties().getNamePropDisplayName()));\n                         folders.appendChild(element);\n                    }\n                    catch (Exception e) {    \n                         //do nothing, we either don't have access to the collction or it's a resource\n                    }\n               }          \n          }\n     }","id":71689,"modified_method":"private void getFolders(String dir, Node root, Document doc, String collectionBase) {\n          Element folders = doc.createElement(\"Folders\");\n          root.appendChild(folders);\n                    \n          ContentCollection collection = null;\n         \n          Map map = null; \n          Iterator foldersIterator = null;\n   \n          try {\n               //hides the real root level stuff and just shows the users the\n               //the root folders of all the top collections they actually have access to.\n               if (dir.split(\"/\").length == 2) {\n                    List collections = new ArrayList();\n                    map = ContentHostingService.getCollectionMap();\n                    if (map != null && map.keySet() != null) {\n                         collections.addAll(map.keySet());\n                    }\n                    List extras = (List) SessionManager.getCurrentSession()\n                         .getAttribute(FCK_EXTRA_COLLECTIONS_BASE + collectionBase);\n                    if (extras != null) {\n                         collections.addAll(extras);\n                    }\n\n                    foldersIterator = collections.iterator();\n               }\n               else if (dir.split(\"/\").length > 2) {\n                    collection = ContentHostingService.getCollection(dir);\n                    if (collection != null && collection.getMembers() != null) {\n                         foldersIterator = collection.getMembers().iterator();\n                    }\n               }          \n          }\n          catch (Exception e) {    \n               e.printStackTrace();\n               //not a valid collection? file list will be empty and so will the doc\n          }\n          if (foldersIterator != null) {\n               String current = null;\n               \n               while (foldersIterator.hasNext()) {\n                    try {\n                         current = (String) foldersIterator.next();\n                         ContentCollection myCollection = ContentHostingService.getCollection(current);\n                         Element element=doc.createElement(\"Folder\");\n                         element.setAttribute(\"url\", current);\n                         element.setAttribute(\"name\", myCollection.getProperties().getProperty(\n                        \t\t myCollection.getProperties().getNamePropDisplayName()));\n                         folders.appendChild(element);\n                    }\n                    catch (Exception e) {    \n                         //do nothing, we either don't have access to the collction or it's a resource\n                    }\n               }          \n          }\n     }","commit_id":"f562faca741a5e6aca5125450440249aaf62f455","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n      * Manage the Post requests (FileUpload).<br>\n      *\n      * The servlet accepts commands sent in the following format:<br>\n      * connector?Command=FileUpload&Type=ResourceType&CurrentFolder=FolderPath<br><br>\n      * It stores the file (renaming it in case a file with the same name exists) and then return an HTML file\n      * with a javascript command in it.\n      *\n      */     \n     public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n          response.setContentType(\"text/html; charset=UTF-8\");\n          response.setHeader(\"Cache-Control\", \"no-cache\");\n          PrintWriter out = null;\n\n          String command = request.getParameter(\"Command\");\n          \n          String currentFolder = request.getParameter(\"CurrentFolder\");\n          \n          String currentDirPath = \"/access/content\" + currentFolder;\n          String fileName = \"\";\n          String errorMessage = \"\";\n          \n          String status=\"0\";\n\n          if (!\"FileUpload\".equals(command) && !\"QuickUpload\".equals(command)) {\n               status = \"203\";\n          }\n          else {\n               DiskFileUpload upload = new DiskFileUpload();\n               try {\n                    List items = upload.parseRequest(request);\n               \n                    Map fields = new HashMap();\n               \n                    Iterator iter = items.iterator();\n                    while (iter.hasNext()) {\n                    \t\n                        FileItem item = (FileItem) iter.next();\n                        if (item.isFormField()) {\n                             fields.put(item.getFieldName(), item.getString());\n                        }\n                        else {\n                             fields.put(item.getFieldName(), item);\n                        }\n                    }\n                    FileItem uplFile = (FileItem)fields.get(\"NewFile\");\n\n                    String filePath = uplFile.getName();\n                    filePath = filePath.replace('\\\\','/');\n                    String[] pathParts = filePath.split(\"/\");\n                    fileName = pathParts[pathParts.length-1];\n                    \n                    String nameWithoutExt = fileName; \n                    String ext = \"\"; \n\n                    if (fileName.lastIndexOf(\".\") > 0) {\n                         nameWithoutExt = fileName.substring(0, fileName.lastIndexOf(\".\")); \n                         ext = fileName.substring(fileName.lastIndexOf(\".\")); \n                    }\n\n                    String mime = uplFile.getContentType();\n\n                    int counter = 1;\n                    boolean done = false;\n\n                    while(!done) {\n                         try {\n                             ResourcePropertiesEdit resourceProperties = ContentHostingService.newResourceProperties();\n                             resourceProperties.addProperty (ResourceProperties.PROP_DISPLAY_NAME, fileName);\n                          \n                             int noti = NotificationService.NOTI_NONE;\n\n                             ContentHostingService.addResource(currentFolder+fileName, mime, uplFile.get(), \n                                    resourceProperties, noti);\n                             done = true;\n                         }\n                         catch (IdUsedException iue) {\n                              //the name is already used, so we do a slight rename to prevent the colision\n                              fileName = nameWithoutExt + \"(\" + counter + \")\" + ext;\n                              status = \"201\";\n                              counter++;\n                         }\n\n                         catch (Exception ex) {\n                              //this user can't write where they are trying to write.\n                              done = true;\n                              ex.printStackTrace();\n                              status = \"203\";\n                         }\n                    }\n               }\n               catch (Exception ex) {\n                    ex.printStackTrace();\n                    status = \"203\";\n               }\n          }\n\n          try {\n        \t   out = response.getWriter();\n               out.println(\"<script type=\\\"text/javascript\\\">\");\n\t          \n               if (\"QuickUpload\".equals(command)) {\n                    out.println(\"window.parent.OnUploadCompleted(\"+status+\",'\"+currentDirPath+fileName+\"','\"+fileName+\"','\"+errorMessage+\"');\");\n               }\n               else {\n                    out.println(\"window.parent.frames['frmUpload'].OnUploadCompleted(\"+status+\",'\"+fileName+\"');\");\n               }\n\t          \n               out.println(\"<\/script>\");\n          }\n          catch (Exception e) {\n        \t  e.printStackTrace();\n          }\n          finally {\t          \n               if (out != null) {\n                    out.close();\n               }\n          }\n     }","id":71690,"modified_method":"/**\n      * Manage the Post requests (FileUpload).<br>\n      *\n      * The servlet accepts commands sent in the following format:<br>\n      * connector?Command=FileUpload&Type=ResourceType&CurrentFolder=FolderPath<br><br>\n      * It stores the file (renaming it in case a file with the same name exists) and then return an HTML file\n      * with a javascript command in it.\n      *\n      */     \n     public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n          response.setContentType(\"text/html; charset=UTF-8\");\n          response.setHeader(\"Cache-Control\", \"no-cache\");\n          PrintWriter out = null;\n\n          String command = request.getParameter(\"Command\");\n          \n          String currentFolder = request.getParameter(\"CurrentFolder\");\n          String collectionBase = request.getPathInfo();\n          \n          SecurityAdvisor advisor = (SecurityAdvisor) SessionManager.getCurrentSession()\n               .getAttribute(FCK_ADVISOR_BASE + collectionBase);\n          if (advisor != null) {\n               SecurityService.pushAdvisor(advisor);\n          }\n          \n          String fileName = \"\";\n          String errorMessage = \"\";\n          \n          String status=\"0\";\n\n          if (!\"FileUpload\".equals(command) && !\"QuickUpload\".equals(command)) {\n               status = \"203\";\n          }\n          else {\n               DiskFileUpload upload = new DiskFileUpload();\n               try {\n                    List items = upload.parseRequest(request);\n               \n                    Map fields = new HashMap();\n               \n                    Iterator iter = items.iterator();\n                    while (iter.hasNext()) {\n                    \t\n                        FileItem item = (FileItem) iter.next();\n                        if (item.isFormField()) {\n                             fields.put(item.getFieldName(), item.getString());\n                        }\n                        else {\n                             fields.put(item.getFieldName(), item);\n                        }\n                    }\n                    FileItem uplFile = (FileItem)fields.get(\"NewFile\");\n\n                    String filePath = uplFile.getName();\n                    filePath = filePath.replace('\\\\','/');\n                    String[] pathParts = filePath.split(\"/\");\n                    fileName = pathParts[pathParts.length-1];\n                    \n                    String nameWithoutExt = fileName; \n                    String ext = \"\"; \n\n                    if (fileName.lastIndexOf(\".\") > 0) {\n                         nameWithoutExt = fileName.substring(0, fileName.lastIndexOf(\".\")); \n                         ext = fileName.substring(fileName.lastIndexOf(\".\")); \n                    }\n\n                    String mime = uplFile.getContentType();\n\n                    int counter = 1;\n                    boolean done = false;\n\n                    while(!done) {\n                         try {\n                             ResourcePropertiesEdit resourceProperties = ContentHostingService.newResourceProperties();\n                             resourceProperties.addProperty (ResourceProperties.PROP_DISPLAY_NAME, fileName);\n                          \n                             int noti = NotificationService.NOTI_NONE;\n\n                             ContentHostingService.addResource(currentFolder+fileName, mime, uplFile.get(), \n                                    resourceProperties, noti);\n                             done = true;\n                         }\n                         catch (IdUsedException iue) {\n                              //the name is already used, so we do a slight rename to prevent the colision\n                              fileName = nameWithoutExt + \"(\" + counter + \")\" + ext;\n                              status = \"201\";\n                              counter++;\n                         }\n\n                         catch (Exception ex) {\n                              //this user can't write where they are trying to write.\n                              done = true;\n                              ex.printStackTrace();\n                              status = \"203\";\n                         }\n                    }\n               }\n               catch (Exception ex) {\n                    ex.printStackTrace();\n                    status = \"203\";\n               }\n          }\n\n          try {\n        \t   out = response.getWriter();\n               out.println(\"<script type=\\\"text/javascript\\\">\");\n\t          \n               if (\"QuickUpload\".equals(command)) {\n                    out.println(\"window.parent.OnUploadCompleted(\" + status + \",'\"\n                    \t\t+ ContentHostingService.getUrl(currentFolder) + fileName\n                    \t\t+ \"','\" + fileName + \"','\" + errorMessage + \"');\");\n               }\n               else {\n                    out.println(\"window.parent.frames['frmUpload'].OnUploadCompleted(\"+status+\",'\"+fileName+\"');\");\n               }\n\t          \n               out.println(\"<\/script>\");\n          }\n          catch (Exception e) {\n        \t  e.printStackTrace();\n          }\n          finally {\t          \n               if (out != null) {\n                    out.close();\n               }\n          }\n          \n          if (advisor != null) {\n        \t  SecurityService.clearAdvisors();\n          }\n     }","commit_id":"f562faca741a5e6aca5125450440249aaf62f455","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Collects all projects locally reachable from the specified project. The method will as such try to read the POM\n     * and recursively follow its parent/module elements.\n     *\n     * @param projectsDir The base directory of all projects, must not be <code>null<\/code>.\n     * @param projectPath The relative path of the current project, can denote either the POM or its base directory,\n     *            must not be <code>null<\/code>.\n     * @param projectPaths The set of already collected projects to add new projects to, must not be <code>null<\/code>.\n     *            This set will hold the relative paths to either a POM file or a project base directory.\n     * @param included A flag indicating whether the specified project has been explicitly included via the parameter\n     *            {@link #pomIncludes}. Such projects will always be added to the result set even if there is no\n     *            corresponding POM.\n     * @throws org.apache.maven.plugin.MojoExecutionException If the project tree could not be traversed.\n     */\n    private void collectProjects( File projectsDir, String projectPath, Collection projectPaths, boolean included )\n        throws MojoExecutionException\n    {\n        projectPath = projectPath.replace( '\\\\', '/' );\n        File pomFile = new File( projectsDir, projectPath );\n        if ( pomFile.isDirectory() )\n        {\n            pomFile = new File( pomFile, \"pom.xml\" );\n            if ( !pomFile.exists() )\n            {\n                if ( included )\n                {\n                    projectPaths.add( projectPath );\n                }\n                return;\n            }\n            if ( !projectPath.endsWith( \"/\" ) )\n            {\n                projectPath += '/';\n            }\n            projectPath += \"pom.xml\";\n        }\n        else if ( !pomFile.isFile() )\n        {\n            return;\n        }\n        if ( !projectPaths.add( projectPath ) )\n        {\n            return;\n        }\n        getLog().debug( \"Collecting parent/child projects of \" + projectPath );\n\n        Model model = PomUtils.loadPom( pomFile );\n\n        try\n        {\n            String projectsRoot = projectsDir.getCanonicalPath();\n            String projectDir = pomFile.getParent();\n\n            String parentPath = \"../pom.xml\";\n            if ( model.getParent() != null && StringUtils.isNotEmpty( model.getParent().getRelativePath() ) )\n            {\n                parentPath = model.getParent().getRelativePath();\n            }\n            String parent = relativizePath( new File( projectDir, parentPath ), projectsRoot );\n            if ( parent != null )\n            {\n                collectProjects( projectsDir, parent, projectPaths, false );\n            }\n\n            if ( model.getModules() != null )\n            {\n                for ( Iterator it = model.getModules().iterator(); it.hasNext(); )\n                {\n                    String modulePath = (String) it.next();\n                    String module = relativizePath( new File( projectDir, modulePath ), projectsRoot );\n                    if ( module != null )\n                    {\n                        collectProjects( projectsDir, module, projectPaths, false );\n                    }\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Failed to analyze POM: \" + pomFile, e );\n        }\n    }","id":71691,"modified_method":"/**\n     * Collects all projects locally reachable from the specified project. The method will as such try to read the POM\n     * and recursively follow its parent/module elements.\n     *\n     * @param projectsDir The base directory of all projects, must not be <code>null<\/code>.\n     * @param projectPath The relative path of the current project, can denote either the POM or its base directory,\n     *            must not be <code>null<\/code>.\n     * @param projectPaths The set of already collected projects to add new projects to, must not be <code>null<\/code>.\n     *            This set will hold the relative paths to either a POM file or a project base directory.\n     * @param included A flag indicating whether the specified project has been explicitly included via the parameter\n     *            {@link #pomIncludes}. Such projects will always be added to the result set even if there is no\n     *            corresponding POM.\n     * @throws org.apache.maven.plugin.MojoExecutionException If the project tree could not be traversed.\n     */\n    private void collectProjects( File projectsDir, String projectPath, Collection projectPaths, boolean included )\n        throws MojoExecutionException\n    {\n        projectPath = projectPath.replace( '\\\\', '/' );\n        File pomFile = new File( projectsDir, projectPath );\n        if ( pomFile.isDirectory() )\n        {\n            pomFile = new File( pomFile, \"pom.xml\" );\n            if ( !pomFile.exists() )\n            {\n                if ( included )\n                {\n                    projectPaths.add( projectPath );\n                }\n                return;\n            }\n            if ( !projectPath.endsWith( \"/\" ) )\n            {\n                projectPath += '/';\n            }\n            projectPath += \"pom.xml\";\n        }\n        else if ( !pomFile.isFile() )\n        {\n            return;\n        }\n        if ( !projectPaths.add( projectPath ) )\n        {\n            return;\n        }\n        getLog().debug( \"Collecting parent/child projects of \" + projectPath );\n\n        Model model = PomUtils.loadPom( pomFile );\n\n        try\n        {\n            String projectsRoot = projectsDir.getCanonicalPath();\n            String projectDir = pomFile.getParent();\n\n            String parentPath = \"../pom.xml\";\n            if ( model.getParent() != null && StringUtils.isNotEmpty( model.getParent().getRelativePath() ) )\n            {\n                parentPath = model.getParent().getRelativePath();\n            }\n            String parent = relativizePath( new File( projectDir, parentPath ), projectsRoot );\n            if ( parent != null )\n            {\n                collectProjects( projectsDir, parent, projectPaths, false );\n            }\n\n            Collection modulePaths = new LinkedHashSet();\n\n            modulePaths.addAll( model.getModules() );\n\n            for ( Iterator it = model.getProfiles().iterator(); it.hasNext(); )\n            {\n                Profile profile = (Profile) it.next();\n                modulePaths.addAll( profile.getModules() );\n            }\n\n            for ( Iterator it = modulePaths.iterator(); it.hasNext(); )\n            {\n                String modulePath = (String) it.next();\n                String module = relativizePath( new File( projectDir, modulePath ), projectsRoot );\n                if ( module != null )\n                {\n                    collectProjects( projectsDir, module, projectPaths, false );\n                }\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new MojoExecutionException( \"Failed to analyze POM: \" + pomFile, e );\n        }\n    }","commit_id":"70f33068397fbbf228f79e6ddf02c9f458557e63","url":"https://github.com/apache/maven-plugins"},{"original_method":"@Override\n    void parse(VoltXMLElement stmtNode, Database db) {\n        String type = stmtNode.attributes.get(\"uniontype\");\n        // Set operation type\n        m_unionType = UnionType.valueOf(type);\n\n        assert(stmtNode.children.size() == m_children.size());\n        HashSet<Table> tableSet = new HashSet<Table>();\n        int i = 0;\n        for (VoltXMLElement selectSQL : stmtNode.children) {\n            AbstractParsedStmt nextSelectStmt = m_children.get(i++);\n            nextSelectStmt.parse(selectSQL, db);\n            // @TODO MIKE\n            // When HSQLInterface.getXMLCompiledStatement() parses the union statement\n            // it adds ALL tables across the entire union to each child statement (table sources)\n            // SCAN columns though contains right set of tables related to this particular\n            // sub-select only\n            // What to do if nextSelectStmt.scanColumns is NULL?\n            if (nextSelectStmt.scanColumns != null)\n            {\n                Set<String> tableNames = nextSelectStmt.scanColumns.keySet();\n                Iterator<Table> it = nextSelectStmt.tableList.iterator();\n\n                while (it.hasNext()) {\n                    Table next = it.next();\n                    if (!tableNames.contains(next.getTypeName())) {\n                        it.remove();\n                    }\n                }\n                tableSet.addAll(nextSelectStmt.tableList);\n            } else {\n                throw new RuntimeException(\"Select * is not supported within the UNION statement\");\n            }\n        }\n        // List of all tables across the union\n        tableList.clear();\n        tableList.addAll(tableSet);\n    }","id":71692,"modified_method":"@Override\n    void parse(VoltXMLElement stmtNode, Database db) {\n        String type = stmtNode.attributes.get(\"uniontype\");\n        // Set operation type\n        m_unionType = UnionType.valueOf(type);\n\n        assert(stmtNode.children.size() == m_children.size());\n        HashSet<Table> tableSet = new HashSet<Table>();\n        int i = 0;\n        for (VoltXMLElement selectSQL : stmtNode.children) {\n            AbstractParsedStmt nextSelectStmt = m_children.get(i++);\n            nextSelectStmt.parse(selectSQL, db);\n            // @TODO MIKE\n            // When HSQLInterface.getXMLCompiledStatement() parses the union statement\n            // it adds ALL tables across the entire union to each child statement (table sources)\n            // SCAN columns though contains right set of tables related to this particular\n            // sub-select only\n            // What to do if nextSelectStmt.scanColumns is NULL?\n            if (nextSelectStmt.scanColumns != null)\n            {\n                Set<String> tableNames = nextSelectStmt.scanColumns.keySet();\n                // need to remove duplicates in case of union of a same table\n                HashSet<Table> nextTableSet = new HashSet<Table>();\n                nextTableSet.addAll(nextSelectStmt.tableList);\n                Iterator<Table> it = nextTableSet.iterator();\n                // Filter out tables which are not from this statement\n                while (it.hasNext()) {\n                    Table next = it.next();\n                    if (!tableNames.contains(next.getTypeName())) {\n                        it.remove();\n                    }\n                }\n                // Replace the original tables\n                nextSelectStmt.tableList.clear();\n                nextSelectStmt.tableList.addAll(nextTableSet);\n                tableSet.addAll(nextTableSet);\n            } else {\n                throw new RuntimeException(\"Select * is not supported within the UNION statement\");\n            }\n        }\n        // List of all tables across the union\n        tableList.clear();\n        tableList.addAll(tableSet);\n    }","commit_id":"9af66ea7693a24d5b5260d83700b266ada885134","url":"https://github.com/VoltDB/voltdb"},{"original_method":"VoltXMLElement voltGetXMLExpression(QueryExpression queryExpr, Session session)\n    throws HSQLParseException\n    {\n        // \"select\" statements/clauses are always represented by a QueryExpression of type QuerySpecification.\n        // The only other instances of QueryExpression are direct QueryExpression instances instantiated in XreadSetOperation\n        // to represent UNION, etc.\n        // The latter are not yet supported in VoltDB.\n        if (queryExpr.getUnionType() == QueryExpression.NOUNION) {\n            return voltGetXMLSpecification(queryExpr, session);\n        } else {\n            VoltXMLElement union = new VoltXMLElement(\"union\");\n            union.attributes.put(\"uniontype\", queryExpr.operatorName());\n            VoltXMLElement leftExpr = voltGetXMLExpression(\n                    queryExpr.getLeftQueryExpression(), session);\n            VoltXMLElement rightExpr = voltGetXMLExpression(\n                    queryExpr.getRightQueryExpression(), session);\n            union.children.add(leftExpr);\n            union.children.add(rightExpr);\n            return union;\n        }\n    }","id":71693,"modified_method":"VoltXMLElement voltGetXMLExpression(QueryExpression queryExpr, Session session)\n    throws HSQLParseException\n    {\n        // \"select\" statements/clauses are always represented by a QueryExpression of type QuerySpecification.\n        // The only other instances of QueryExpression are direct QueryExpression instances instantiated in XreadSetOperation\n        // to represent UNION, etc.\n        // The latter are not yet supported in VoltDB.\n        if (queryExpr.getUnionType() == QueryExpression.NOUNION) {\n            return voltGetXMLSpecification(queryExpr, session);\n        } else {\n            String unionType = queryExpr.operatorName();\n            if (!\"UNION\".equalsIgnoreCase(unionType) && !\"UNION_ALL\".equalsIgnoreCase(unionType)) {\n                throw new HSQLParseException(queryExpression.operatorName() + \"  tuple set operator is not supported.\");\n            }\n            VoltXMLElement unionExpr = new VoltXMLElement(\"union\");\n            unionExpr.attributes.put(\"uniontype\", unionType);\n            VoltXMLElement leftExpr = voltGetXMLExpression(\n                    queryExpr.getLeftQueryExpression(), session);\n            VoltXMLElement rightExpr = voltGetXMLExpression(\n                    queryExpr.getRightQueryExpression(), session);\n            unionExpr = voltSimplifyUnionXMLExpression(unionExpr, leftExpr);\n            unionExpr = voltSimplifyUnionXMLExpression(unionExpr, rightExpr);\n            return unionExpr;\n        }\n    }","commit_id":"9af66ea7693a24d5b5260d83700b266ada885134","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private static void selectWithGuide(Editor editor, IndentGuideDescriptor guide) {\n      final Document doc = editor.getDocument();\n      int startOffset = editor.logicalPositionToOffset(new LogicalPosition(guide.startLine, 0));\n      int endOffset = Math.min(doc.getLineStartOffset(guide.endLine), doc.getTextLength());\n\n      final VirtualFile file = ((EditorEx)editor).getVirtualFile();\n      if (file != null) {\n        // Make sure selection contains closing matching brace.\n\n        final CharSequence chars = doc.getCharsSequence();\n        int nonWhitespaceOffset = CharArrayUtil.shiftForward(chars, endOffset, \" \\t\\n\");\n        HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(nonWhitespaceOffset);\n        if (BraceMatchingUtil.isRBraceToken(iterator, chars, file.getFileType())) {\n          if (((EditorEx)editor).calcColumnNumber(iterator.getStart(), doc.getLineNumber(iterator.getStart())) == guide.indentLevel) {\n            endOffset = iterator.getEnd();\n            endOffset = CharArrayUtil.shiftForward(chars, endOffset, \" \\t\");\n            if (endOffset < chars.length() && chars.charAt(endOffset) == '\\n') endOffset++;\n          }\n        }\n      }\n\n      editor.getSelectionModel().setSelection(startOffset, endOffset);\n    }","id":71694,"modified_method":"private static void selectWithGuide(Editor editor, IndentGuideDescriptor guide) {\n      final Document doc = editor.getDocument();\n      int startOffset = editor.logicalPositionToOffset(new LogicalPosition(guide.startLine, 0));\n      int endOffset = guide.endLine >= doc.getLineCount() ? doc.getTextLength() : doc.getLineStartOffset(guide.endLine);\n\n      final VirtualFile file = ((EditorEx)editor).getVirtualFile();\n      if (file != null) {\n        // Make sure selection contains closing matching brace.\n\n        final CharSequence chars = doc.getCharsSequence();\n        int nonWhitespaceOffset = CharArrayUtil.shiftForward(chars, endOffset, \" \\t\\n\");\n        HighlighterIterator iterator = ((EditorEx)editor).getHighlighter().createIterator(nonWhitespaceOffset);\n        if (BraceMatchingUtil.isRBraceToken(iterator, chars, file.getFileType())) {\n          if (((EditorEx)editor).calcColumnNumber(iterator.getStart(), doc.getLineNumber(iterator.getStart())) == guide.indentLevel) {\n            endOffset = iterator.getEnd();\n            endOffset = CharArrayUtil.shiftForward(chars, endOffset, \" \\t\");\n            if (endOffset < chars.length() && chars.charAt(endOffset) == '\\n') endOffset++;\n          }\n        }\n      }\n\n      editor.getSelectionModel().setSelection(startOffset, endOffset);\n    }","commit_id":"f5776acda989f0c2e1f7cd106d14f773488f6fd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  protected static Location createLocationFor(final Project project,\n                                            @NotNull final VirtualFile virtualFile, final int lineNum) {\n    assert lineNum > 0;\n\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(virtualFile);\n    if (psiFile == null) {\n      return null;\n    }\n\n    final Document doc = PsiDocumentManager.getInstance(project).getDocument(psiFile);\n    if (doc == null) {\n      return null;\n    }\n\n    final int lineStartOffset = doc.getLineStartOffset(lineNum - 1);\n\n    PsiElement elementAtLine = psiFile.findElementAt(lineStartOffset);\n    if (elementAtLine != null) {\n      // skip whitespaces\n      while (elementAtLine instanceof PsiWhiteSpace) {\n        elementAtLine = elementAtLine.getNextSibling();\n      }\n    }\n    final PsiElement leafPsiElementAtLine = elementAtLine == null\n        ? null\n        : psiFile.findElementAt(elementAtLine.getTextOffset());\n\n    return PsiLocation.fromPsiElement(project, leafPsiElementAtLine != null ? leafPsiElementAtLine : psiFile);\n  }","id":71695,"modified_method":"@Nullable\n  protected static Location createLocationFor(final Project project,\n                                            @NotNull final VirtualFile virtualFile, final int lineNum) {\n    assert lineNum > 0;\n\n    final PsiFile psiFile = PsiManager.getInstance(project).findFile(virtualFile);\n    if (psiFile == null) {\n      return null;\n    }\n\n    final Document doc = PsiDocumentManager.getInstance(project).getDocument(psiFile);\n    if (doc == null) {\n      return null;\n    }\n\n    final int lineCount = doc.getLineCount();\n    final int lineStartOffset;\n    if (lineNum <= lineCount) {\n      lineStartOffset = doc.getLineStartOffset(lineNum - 1);\n    } else {\n      // unknown line\n      lineStartOffset = 0;\n    }\n\n    PsiElement elementAtLine = psiFile.findElementAt(lineStartOffset);\n    if (elementAtLine != null) {\n      // skip whitespaces\n      while (elementAtLine instanceof PsiWhiteSpace) {\n        elementAtLine = elementAtLine.getNextSibling();\n      }\n    }\n    final PsiElement leafPsiElementAtLine = elementAtLine == null\n        ? null\n        : psiFile.findElementAt(elementAtLine.getTextOffset());\n\n    return PsiLocation.fromPsiElement(project, leafPsiElementAtLine != null ? leafPsiElementAtLine : psiFile);\n  }","commit_id":"ff66e295ac398e4c5714b58fd64da9296bbd947e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private TextRange getTextRange(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    int startOffset = getStartOffset(element, editor);\n    int endOffset = getEndOffset(element, editor);\n    return TextRange.create(startOffset, endOffset);\n  }","id":71696,"modified_method":"private TextRange getTextRange(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    int startOffset = getStartOffset(element, editor);\n    int endOffset = getEndOffset(element, editor);\n    return new UnfairTextRange(startOffset, endOffset);\n  }","commit_id":"ee299a720ad541ef8ddffd299e37407c1938f14b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private int getStartOffset(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    if (isBunchOfElement(element)) {\n      final PsiElement firstElement = getFirstElement(element);\n      return firstElement != null? firstElement.getTextRange().getStartOffset()\n                                        : element.getTextRange().getStartOffset();\n    }\n    final int offset = editor.getCaretModel().getOffset();\n    final int elementTextOffset = element.getTextOffset();\n    final Document document = editor.getDocument();\n    int lineNumber = document.getLineNumber(offset);\n\n    while (lineNumber != document.getLineNumber(elementTextOffset)) {\n      final String text = document.getText(TextRange.create(document.getLineStartOffset(lineNumber),\n                                                            document.getLineEndOffset(lineNumber)));\n      if (StringUtil.isEmptyOrSpaces(text)) {\n        lineNumber += 1;\n        break;\n      }\n      lineNumber -= 1;\n    }\n    final int lineStartOffset = document.getLineStartOffset(lineNumber);\n    final String lineText = document\n      .getText(TextRange.create(lineStartOffset, document.getLineEndOffset(lineNumber)));\n    int shift = StringUtil.findFirst(lineText, CharFilter.NOT_WHITESPACE_FILTER);\n\n    return lineStartOffset + shift;\n  }","id":71697,"modified_method":"private int getStartOffset(@NotNull final PsiElement element, @NotNull final Editor editor) {\n    if (isBunchOfElement(element)) {\n      final PsiElement firstElement = getFirstElement(element);\n      return firstElement != null? firstElement.getTextRange().getStartOffset()\n                                        : element.getTextRange().getStartOffset();\n    }\n    final int offset = editor.getCaretModel().getOffset();\n    final int elementTextOffset = element.getTextOffset();\n    final Document document = editor.getDocument();\n    int lineNumber = document.getLineNumber(offset);\n\n    while (lineNumber != document.getLineNumber(elementTextOffset)) {\n      final String text = document.getText(TextRange.create(document.getLineStartOffset(lineNumber),\n                                                            document.getLineEndOffset(lineNumber)));\n      if (StringUtil.isEmptyOrSpaces(text)) {\n        lineNumber += 1;\n        break;\n      }\n      lineNumber -= 1;\n    }\n    final int lineStartOffset = lineNumber == document.getLineNumber(elementTextOffset) ? elementTextOffset : document.getLineStartOffset(lineNumber);\n    final String lineText = document\n      .getText(TextRange.create(lineStartOffset, document.getLineEndOffset(lineNumber)));\n    int shift = StringUtil.findFirst(lineText, CharFilter.NOT_WHITESPACE_FILTER);\n\n    return lineStartOffset + shift;\n  }","commit_id":"ee299a720ad541ef8ddffd299e37407c1938f14b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void run() {\n        if (!Notification.isFirst(core, Notification.Type.ES_OPEN_FILES))\n            return;\n        boolean allHigher = true;\n        for (NodeInfo node : core.getIndexer().cluster().getDataNodes()) {\n            // Check number of maximum open files.\n            if (node.getProcess().getMaxFileDescriptors() < MINIMUM_OPEN_FILES_LIMIT) {\n                LOG.info(\"Indexer node <{}> has a too low open file limit: [{}]\",\n                        node.getNode().getName(),\n                        node.getProcess().getMaxFileDescriptors());\n\n                // Write notification.\n                Notification.buildNow(core)\n                        .addType(Notification.Type.ES_OPEN_FILES)\n                        .addSeverity(Notification.Severity.URGENT)\n                        .publishIfFirst();\n                allHigher = false;\n            }\n        }\n        if (allHigher) {\n            Notification.build(core).addType(Notification.Type.ES_OPEN_FILES).fixed();\n        }\n    }","id":71698,"modified_method":"@Override\n    public void run() {\n        if (!Notification.isFirst(core, Notification.Type.ES_OPEN_FILES))\n            return;\n        boolean allHigher = true;\n        for (NodeInfo node : core.getIndexer().cluster().getDataNodes()) {\n            // Check number of maximum open files.\n            if (node.getProcess().getMaxFileDescriptors() < MINIMUM_OPEN_FILES_LIMIT) {\n\n                // Write notification.\n                final boolean published = Notification.buildNow(core)\n                        .addType(Notification.Type.ES_OPEN_FILES)\n                        .addSeverity(Notification.Severity.URGENT)\n                        .publishIfFirst();\n                if (published) {\n                    LOG.warn(\"Indexer node <{}> open file limit is too low: [{}]. Set it to at least {}.\",\n                             new Object[] {\n                                     node.getNode().getName(),\n                                     node.getProcess().getMaxFileDescriptors(),\n                                     MINIMUM_OPEN_FILES_LIMIT\n                             });\n                }\n                allHigher = false;\n            }\n        }\n        if (allHigher) {\n            Notification.build(core).addType(Notification.Type.ES_OPEN_FILES).fixed();\n        }\n    }","commit_id":"f585958843cf103f48bb5d6cad188b2a83725886","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"private void getLinksFromCdp() {\n        LOG.info(\"getLinksFromCdp: adding links using Cisco Discovery Protocol\");\n\n        LOG.info(\"getLinksFromCdp: found # {} nodes using Cisco Discovery Protocol\", m_cdpNodes.size());\n\n        LOG.info(\"getLinksFromCdp: founding Cisco Discovery Protocol links between Cdp nodes\");\n        for (LinkableNode linknode1: m_cdpNodes.values()) {\n            LOG.info(\"getLinksFromCdp: parsing cdp device {} with cdpDeviceId {} using Cisco Discovery Protocol\",linknode1.getNodeId(), linknode1.getCdpDeviceId());\n            for (CdpInterface cdpiface1: linknode1.getCdpInterfaces()) {\n                LOG.info(\"getLinksFromCdp: found  cdpTargetDeviceId {} \", cdpiface1.getCdpTargetDeviceId());\n                if (cdpiface1.getCdpTargetDeviceId() != null) {\n                    LinkableNode linknode2 = m_cdpNodes.get(cdpiface1.getCdpTargetDeviceId());\n                    if (linknode2 == null) {\n                        LOG.info(\"getLinksFromCdp: no cdpdevice found for cdpDeviceId {} \", cdpiface1.getCdpTargetDeviceId());\n                        continue;\n                    }\n                    if (linknode1.getNodeId() >= linknode2.getNodeId())\n                        continue;\n                    LOG.info(\"getLinksFromCdp: cdpdevice found node {} for cdpTargetDeviceId {} \", linknode2.getNodeId(), cdpiface1.getCdpTargetDeviceId());\n                    \n                    for (CdpInterface cdpiface2: linknode2.getCdpInterfaces()) {\n                        if (cdpiface2 != null && cdpiface2.getCdpTargetDeviceId() != null \n                                && cdpiface2.getCdpTargetDeviceId().equals(linknode1.getCdpDeviceId()) \n                                && cdpiface1.getCdpIfName().equals(cdpiface2.getCdpTargetIfName())\n                                && cdpiface2.getCdpIfName().equals(cdpiface1.getCdpTargetIfName())) {\n                            NodeToNodeLink cdpLink = new NodeToNodeLink(linknode2.getNodeId(), cdpiface2.getCdpIfIndex());\n                            cdpLink.setNodeparentid(linknode1.getNodeId());\n                            cdpLink.setParentifindex(cdpiface1.getCdpIfIndex());\n                            addNodetoNodeLink(cdpLink);\n                        }\n                    }\n                } else if (cdpiface1.getCdpTargetNodeId() != null) {\n                    LOG.info(\"getLinksFromCdp: cdpdevice found no snmp target node {} for cdpTargetDeviceId {} \", cdpiface1.getCdpTargetNodeId(), cdpiface1.getCdpTargetDeviceId());\n                    NodeToNodeLink link = new NodeToNodeLink(cdpiface1.getCdpTargetNodeId(), -1);\n                    link.setNodeparentid(linknode1.getNodeId());\n                    link.setParentifindex(cdpiface1.getCdpIfIndex());\n                    addNodetoNodeLink(link);\n                }\n            }\n        }\n                \n    }","id":71699,"modified_method":"private void getLinksFromCdp() {\n        LOG.info(\"getLinksFromCdp: adding links using Cisco Discovery Protocol\");\n\n        LOG.info(\"getLinksFromCdp: found # {} nodes using Cisco Discovery Protocol\", m_cdpNodes.size());\n\n        LOG.info(\"getLinksFromCdp: founding Cisco Discovery Protocol links between Cdp nodes\");\n        for (LinkableNode linknode1: m_cdpNodes.values()) {\n            LOG.info(\"getLinksFromCdp: parsing cdp device {} with cdpDeviceId {} using Cisco Discovery Protocol\",linknode1.getNodeId(), linknode1.getCdpDeviceId());\n            for (CdpInterface cdpiface1: linknode1.getCdpInterfaces()) {\n                if (cdpiface1 == null) {\n                    LOG.warn(\"getLinksFromCdp: cdp interface null found on target device node {} for cdpTargetDeviceId {} \", linknode1.getNodeId());\n                    continue;\n                }\n                LOG.info(\"getLinksFromCdp: parsing cdpInterface {} \", cdpiface1);\n                if (cdpiface1.getCdpTargetDeviceId() != null) {\n                    LinkableNode linknode2 = m_cdpNodes.get(cdpiface1.getCdpTargetDeviceId());\n                    if (linknode2 == null) {\n                        LOG.info(\"getLinksFromCdp: no cdpdevice found for cdpDeviceId {} \", cdpiface1.getCdpTargetDeviceId());\n                        continue;\n                    }\n                    if (linknode1.getNodeId() >= linknode2.getNodeId())\n                        continue;\n                    LOG.info(\"getLinksFromCdp: found node {} for cdpTargetDeviceId {} \", linknode2.getNodeId(), cdpiface1.getCdpTargetDeviceId());\n                    \n                    for (CdpInterface cdpiface2: linknode2.getCdpInterfaces()) {\n                        if (cdpiface2 == null) {\n                            LOG.warn(\"getLinksFromCdp: cdp interface null found on target device node {} for cdpTargetDeviceId {} \", linknode2.getNodeId(), cdpiface1.getCdpTargetDeviceId());\n                            continue;\n                        }\n                        LOG.info(\"getLinksFromCdp: parsing target cdpInterface {} \", cdpiface2);\n                        if ( cdpiface2.getCdpTargetDeviceId() != null \n                                && cdpiface2.getCdpTargetDeviceId().equals(linknode1.getCdpDeviceId()) \n                                && cdpiface1.getCdpIfName().equals(cdpiface2.getCdpTargetIfName())\n                                && cdpiface2.getCdpIfName().equals(cdpiface1.getCdpTargetIfName())) {\n                            NodeToNodeLink cdpLink = new NodeToNodeLink(linknode2.getNodeId(), cdpiface2.getCdpIfIndex());\n                            cdpLink.setNodeparentid(linknode1.getNodeId());\n                            cdpLink.setParentifindex(cdpiface1.getCdpIfIndex());\n                            addNodetoNodeLink(cdpLink);\n                        }\n                    }\n                } else if (cdpiface1.getCdpTargetNodeId() != null) {\n                    LOG.info(\"getLinksFromCdp: cdpdevice found no snmp target node {} for cdpTargetDeviceId {} \", cdpiface1.getCdpTargetNodeId(), cdpiface1.getCdpTargetDeviceId());\n                    NodeToNodeLink link = new NodeToNodeLink(cdpiface1.getCdpTargetNodeId(), -1);\n                    link.setNodeparentid(linknode1.getNodeId());\n                    link.setParentifindex(cdpiface1.getCdpIfIndex());\n                    addNodetoNodeLink(link);\n                }\n            }\n        }\n                \n    }","commit_id":"c1fd3f231977e775f9ead421c416500db3389410","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void run() {\n        if (!Notification.isFirst(core, Notification.Type.ES_OPEN_FILES))\n            return;\n        boolean allHigher = true;\n        for (NodeInfo node : core.getIndexer().cluster().getDataNodes()) {\n            // Check number of maximum open files.\n            if (node.getProcess().getMaxFileDescriptors() < MINIMUM_OPEN_FILES_LIMIT) {\n                LOG.info(\"Indexer node <{}> has a too low open file limit: [{}]\",\n                        node.getNode().getName(),\n                        node.getProcess().getMaxFileDescriptors());\n\n                // Write notification.\n                Notification.buildNow(core)\n                        .addType(Notification.Type.ES_OPEN_FILES)\n                        .addSeverity(Notification.Severity.URGENT)\n                        .publishIfFirst();\n                allHigher = false;\n            }\n        }\n        if (allHigher) {\n            Notification.build(core).addType(Notification.Type.ES_OPEN_FILES).fixed();\n        }\n    }","id":71700,"modified_method":"@Override\n    public void run() {\n        if (!Notification.isFirst(core, Notification.Type.ES_OPEN_FILES))\n            return;\n        boolean allHigher = true;\n        for (NodeInfo node : core.getIndexer().cluster().getDataNodes()) {\n            // Check number of maximum open files.\n            if (node.getProcess().getMaxFileDescriptors() < MINIMUM_OPEN_FILES_LIMIT) {\n\n                // Write notification.\n                final boolean published = Notification.buildNow(core)\n                        .addType(Notification.Type.ES_OPEN_FILES)\n                        .addSeverity(Notification.Severity.URGENT)\n                        .publishIfFirst();\n                if (published) {\n                    LOG.warn(\"Indexer node <{}> open file limit is too low: [{}]. Set it to at least {}.\",\n                             new Object[] {\n                                     node.getNode().getName(),\n                                     node.getProcess().getMaxFileDescriptors(),\n                                     MINIMUM_OPEN_FILES_LIMIT\n                             });\n                }\n                allHigher = false;\n            }\n        }\n        if (allHigher) {\n            Notification.build(core).addType(Notification.Type.ES_OPEN_FILES).fixed();\n        }\n    }","commit_id":"f0406f0556e87c4031190181d6ba00665cdd2a8d","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public ReplyToHandler getReplyToHandler()\n    {\n        try\n        {\n            Session session = getSession(false);\n            return new JmsReplyToHandler(this, session, defaultResponseTransformer);\n        } catch (JMSException e)\n        {\n            logger.error(\"failed to get replyTo handler: \" + e.getMessage(), e);\n            return null;\n        }\n    }","id":71701,"modified_method":"public ReplyToHandler getReplyToHandler()\n    {\n        return new JmsReplyToHandler(this, defaultResponseTransformer);\n    }","commit_id":"de9fa56bece98b11b89015d6d4761b4dba3bf461","url":"https://github.com/mulesoft/mule"},{"original_method":"public void doDispose()\n    {\n    \tJmsUtils.closeQuietly(producer);\n    \tJmsUtils.closeQuietly(consumer);\n    \tJmsUtils.closeQuietly(receiveSession);\n        //only close the session if a tx is not in progress.  Otherwise\n        //let the consumer close it\n        if(TransactionCoordination.getInstance().getTransaction()==null) {\n    \t    JmsUtils.closeQuietly(session);\n        }\n        producer = null;\n        consumer = null;\n        receiveSession = null;\n        session = null;\n    }","id":71702,"modified_method":"public void doDispose()\n    {\n    \tJmsUtils.closeQuietly(producer);\n    \tJmsUtils.closeQuietly(consumer);\n    \tJmsUtils.closeQuietly(receiveSession);\n    \tJmsUtils.closeQuietly(session);\n        producer = null;\n        consumer = null;\n        receiveSession = null;\n        session = null;\n    }","commit_id":"de9fa56bece98b11b89015d6d4761b4dba3bf461","url":"https://github.com/mulesoft/mule"},{"original_method":"public JmsReplyToHandler(JmsConnector connector, Session session, UMOTransformer transformer)\n    {\n        super(transformer);\n        this.connector = connector;\n        this.session = session;\n    }","id":71703,"modified_method":"public JmsReplyToHandler(JmsConnector connector, UMOTransformer transformer)\n    {\n        super(transformer);\n        this.connector = connector;\n    }","commit_id":"de9fa56bece98b11b89015d6d4761b4dba3bf461","url":"https://github.com/mulesoft/mule"},{"original_method":"public void processReplyTo(UMOEvent event, UMOMessage returnMessage, Object replyTo) throws UMOException\n    {\n        Destination replyToDestination = null;\n        try\n        {\n            // now we need to send the response\n            if (replyTo instanceof Destination)\n            {\n                replyToDestination = (Destination) replyTo;\n            }\n            if (replyToDestination == null)\n            {\n                super.processReplyTo(event, returnMessage, replyTo);\n                return;\n            }\n            Object payload = returnMessage.getPayload();\n            if (getTransformer() != null)\n            {\n                payload = getTransformer().transform(payload);\n            }\n            Message replyToMessage = JmsMessageUtils.getMessageForObject(payload, session);\n\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Sending jms reply to: \" + replyToDestination + \"(\" + replyToDestination.getClass().getName() + \")\");\n            }\n            if (replyToProducer == null)\n            {\n                replyToProducer = ((JmsConnector) connector).getJmsSupport().createProducer(session, replyToDestination);\n            }\n\n            //QoS support\n            String ttlString = (String) event.removeProperty(\"TimeToLive\");\n            String priorityString = (String) event.removeProperty(\"Priority\");\n            String persistentDeliveryString = (String) event.removeProperty(\"PersistentDelivery\");\n\n            if (ttlString == null && priorityString == null && persistentDeliveryString == null)\n            {\n                connector.getJmsSupport().send(replyToProducer, replyToMessage);\n            } else\n            {\n                long ttl = Message.DEFAULT_TIME_TO_LIVE;\n                int priority = Message.DEFAULT_PRIORITY;\n                boolean persistent = Message.DEFAULT_DELIVERY_MODE == DeliveryMode.PERSISTENT;\n\n                if (ttlString != null) ttl = Long.parseLong(ttlString);\n                if (priorityString != null) priority = Integer.parseInt(priorityString);\n                if (persistentDeliveryString != null) persistent = Boolean.valueOf(persistentDeliveryString).booleanValue();\n\n                connector.getJmsSupport().send(replyToProducer, replyToMessage, persistent, priority, ttl);\n            }\n\n            //connector.getJmsSupport().send(replyToProducer, replyToMessage, replyToDestination);\n            logger.info(\"Reply Message sent to: \" + replyToDestination);\n            ((MuleComponent) event.getComponent()).getStatistics().incSentReplyToEvent();\n        } catch (Exception e)\n        {\n            throw new DispatchException(new org.mule.config.i18n.Message(\"jms\", 8, replyToDestination), returnMessage, null);\n        } finally\n        {\n            dispose();\n        }\n    }","id":71704,"modified_method":"public void processReplyTo(UMOEvent event, UMOMessage returnMessage, Object replyTo) throws UMOException\n    {\n        Destination replyToDestination = null;\n        MessageProducer replyToProducer = null;\n        Session session = null;\n        try\n        {\n            // now we need to send the response\n            if (replyTo instanceof Destination)\n            {\n                replyToDestination = (Destination) replyTo;\n            }\n            if (replyToDestination == null)\n            {\n                super.processReplyTo(event, returnMessage, replyTo);\n                return;\n            }\n            Object payload = returnMessage.getPayload();\n            if (getTransformer() != null)\n            {\n                payload = getTransformer().transform(payload);\n            }\n            session = connector.getSession(false);\n            Message replyToMessage = JmsMessageUtils.getMessageForObject(payload, session);\n\n            if (logger.isDebugEnabled())\n            {\n                logger.debug(\"Sending jms reply to: \" + replyToDestination + \"(\" + replyToDestination.getClass().getName() + \")\");\n            }\n            replyToProducer = ((JmsConnector) connector).getJmsSupport().createProducer(session, replyToDestination);\n\n            //QoS support\n            String ttlString = (String) event.removeProperty(\"TimeToLive\");\n            String priorityString = (String) event.removeProperty(\"Priority\");\n            String persistentDeliveryString = (String) event.removeProperty(\"PersistentDelivery\");\n\n            if (ttlString == null && priorityString == null && persistentDeliveryString == null)\n            {\n                connector.getJmsSupport().send(replyToProducer, replyToMessage);\n            } else\n            {\n                long ttl = Message.DEFAULT_TIME_TO_LIVE;\n                int priority = Message.DEFAULT_PRIORITY;\n                boolean persistent = Message.DEFAULT_DELIVERY_MODE == DeliveryMode.PERSISTENT;\n\n                if (ttlString != null) ttl = Long.parseLong(ttlString);\n                if (priorityString != null) priority = Integer.parseInt(priorityString);\n                if (persistentDeliveryString != null) persistent = Boolean.valueOf(persistentDeliveryString).booleanValue();\n\n                connector.getJmsSupport().send(replyToProducer, replyToMessage, persistent, priority, ttl);\n            }\n\n            //connector.getJmsSupport().send(replyToProducer, replyToMessage, replyToDestination);\n            logger.info(\"Reply Message sent to: \" + replyToDestination);\n            ((MuleComponent) event.getComponent()).getStatistics().incSentReplyToEvent();\n        } catch (Exception e)\n        {\n            throw new DispatchException(new org.mule.config.i18n.Message(\"jms\", 8, replyToDestination), returnMessage, null);\n        } finally\n        {\n            JmsUtils.closeQuietly(replyToProducer);\n            JmsUtils.closeQuietly(session);\n        }\n    }","commit_id":"de9fa56bece98b11b89015d6d4761b4dba3bf461","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void format(final EObject func, final FormattableDocument format) {\n    if (func instanceof XtendFunction) {\n      _format((XtendFunction)func, format);\n      return;\n    } else if (func instanceof XBinaryOperation) {\n      _format((XBinaryOperation)func, format);\n      return;\n    } else if (func instanceof XFeatureCall) {\n      _format((XFeatureCall)func, format);\n      return;\n    } else if (func instanceof XMemberFeatureCall) {\n      _format((XMemberFeatureCall)func, format);\n      return;\n    } else if (func instanceof XtendClass) {\n      _format((XtendClass)func, format);\n      return;\n    } else if (func instanceof XtendParameter) {\n      _format((XtendParameter)func, format);\n      return;\n    } else if (func instanceof XBlockExpression) {\n      _format((XBlockExpression)func, format);\n      return;\n    } else if (func instanceof XClosure) {\n      _format((XClosure)func, format);\n      return;\n    } else if (func instanceof XForLoopExpression) {\n      _format((XForLoopExpression)func, format);\n      return;\n    } else if (func instanceof XIfExpression) {\n      _format((XIfExpression)func, format);\n      return;\n    } else if (func instanceof XSwitchExpression) {\n      _format((XSwitchExpression)func, format);\n      return;\n    } else if (func instanceof XVariableDeclaration) {\n      _format((XVariableDeclaration)func, format);\n      return;\n    } else if (func instanceof XtendFile) {\n      _format((XtendFile)func, format);\n      return;\n    } else if (func instanceof XExpression) {\n      _format((XExpression)func, format);\n      return;\n    } else if (func == null) {\n      _format((Void)null, format);\n      return;\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(func, format).toString());\n    }\n  }","id":71705,"modified_method":"protected void format(final EObject func, final FormattableDocument format) {\n    if (func instanceof XtendFunction) {\n      _format((XtendFunction)func, format);\n      return;\n    } else if (func instanceof XBinaryOperation) {\n      _format((XBinaryOperation)func, format);\n      return;\n    } else if (func instanceof XFeatureCall) {\n      _format((XFeatureCall)func, format);\n      return;\n    } else if (func instanceof XMemberFeatureCall) {\n      _format((XMemberFeatureCall)func, format);\n      return;\n    } else if (func instanceof XtendClass) {\n      _format((XtendClass)func, format);\n      return;\n    } else if (func instanceof XtendParameter) {\n      _format((XtendParameter)func, format);\n      return;\n    } else if (func instanceof XBlockExpression) {\n      _format((XBlockExpression)func, format);\n      return;\n    } else if (func instanceof XClosure) {\n      _format((XClosure)func, format);\n      return;\n    } else if (func instanceof XForLoopExpression) {\n      _format((XForLoopExpression)func, format);\n      return;\n    } else if (func instanceof XIfExpression) {\n      _format((XIfExpression)func, format);\n      return;\n    } else if (func instanceof XSwitchExpression) {\n      _format((XSwitchExpression)func, format);\n      return;\n    } else if (func instanceof XVariableDeclaration) {\n      _format((XVariableDeclaration)func, format);\n      return;\n    } else if (func instanceof XtendFile) {\n      _format((XtendFile)func, format);\n      return;\n    } else if (func instanceof XExpression) {\n      _format((XExpression)func, format);\n      return;\n    } else if (func != null) {\n      _format(func, format);\n      return;\n    } else if (func == null) {\n      _format((Void)null, format);\n      return;\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(func, format).toString());\n    }\n  }","commit_id":"ca3beaeea39e453c457869fe65711b66b190bbd3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XIfExpression expr, final FormattableDocument format) {\n    XExpression _then = expr.getThen();\n    final INode thennode = this._nodeModelAccess.nodeForEObject(_then);\n    XExpression _else = expr.getElse();\n    final INode elsenode = _else==null?(INode)null:this._nodeModelAccess.nodeForEObject(_else);\n    boolean _or = false;\n    boolean _or_1 = false;\n    String _text = thennode.getText();\n    String _trim = _text.trim();\n    boolean _contains = _trim.contains(\"\\n\");\n    if (_contains) {\n      _or_1 = true;\n    } else {\n      ILeafNode _whitespaceBefore = this._nodeModelAccess.whitespaceBefore(thennode);\n      String _text_1 = _whitespaceBefore==null?(String)null:_whitespaceBefore.getText();\n      boolean _contains_1 = _text_1==null?false:_text_1.contains(\"\\n\");\n      _or_1 = (_contains || _contains_1);\n    }\n    if (_or_1) {\n      _or = true;\n    } else {\n      String _text_2 = elsenode==null?(String)null:elsenode.getText();\n      String _trim_1 = _text_2==null?(String)null:_text_2.trim();\n      boolean _contains_2 = _trim_1==null?false:_trim_1.contains(\"\\n\");\n      _or = (_or_1 || _contains_2);\n    }\n    final boolean multiline = _or;\n    boolean _or_2 = false;\n    XExpression _then_1 = expr.getThen();\n    if ((_then_1 instanceof XBlockExpression)) {\n      _or_2 = true;\n    } else {\n      boolean _not = (!multiline);\n      _or_2 = ((_then_1 instanceof XBlockExpression) || _not);\n    }\n    if (_or_2) {\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      FormattingData _prepend = this.prepend(thennode, _function);\n      format.operator_add(_prepend);\n      XExpression _else_1 = expr.getElse();\n      boolean _notEquals = (!Objects.equal(_else_1, null));\n      if (_notEquals) {\n        final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.space = \" \";\n            }\n          };\n        FormattingData _append = this.append(thennode, _function_1);\n        format.operator_add(_append);\n      }\n    } else {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      FormattingData _prepend_1 = this.prepend(thennode, _function_2);\n      format.operator_add(_prepend_1);\n      XExpression _else_2 = expr.getElse();\n      boolean _notEquals_1 = (!Objects.equal(_else_2, null));\n      if (_notEquals_1) {\n        final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.decreaseIndentation();\n            }\n          };\n        FormattingData _append_1 = this.append(thennode, _function_3);\n        format.operator_add(_append_1);\n      } else {\n        final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        FormattingData _append_2 = this.append(thennode, _function_4);\n        format.operator_add(_append_2);\n      }\n    }\n    boolean _or_3 = false;\n    XExpression _else_3 = expr.getElse();\n    if ((_else_3 instanceof XBlockExpression)) {\n      _or_3 = true;\n    } else {\n      boolean _not_1 = (!multiline);\n      _or_3 = ((_else_3 instanceof XBlockExpression) || _not_1);\n    }\n    if (_or_3) {\n      final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      FormattingData _prepend_2 = this.prepend(elsenode, _function_5);\n      format.operator_add(_prepend_2);\n    } else {\n      final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      FormattingData _prepend_3 = this.prepend(elsenode, _function_6);\n      format.operator_add(_prepend_3);\n      final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      FormattingData _append_3 = this.append(elsenode, _function_7);\n      format.operator_add(_append_3);\n    }\n    XExpression _then_2 = expr.getThen();\n    this.format(_then_2, format);\n    XExpression _else_4 = expr.getElse();\n    boolean _notEquals_2 = (!Objects.equal(_else_4, null));\n    if (_notEquals_2) {\n      XExpression _else_5 = expr.getElse();\n      this.format(_else_5, format);\n    }\n  }","id":71706,"modified_method":"protected void _format(final XIfExpression expr, final FormattableDocument format) {\n    EObject _eContainer = expr.eContainer();\n    boolean _not = (!(_eContainer instanceof XBlockExpression));\n    if (_not) {\n      ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"if\");\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.increaseIndentation();\n          }\n        };\n      FormattingData _append = this.append(_nodeForKeyword, _function);\n      format.operator_add(_append);\n      INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(expr);\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      FormattingData _append_1 = this.append(_nodeForEObject, _function_1);\n      format.operator_add(_append_1);\n    }\n    XExpression _then = expr.getThen();\n    final INode thennode = this._nodeModelAccess.nodeForEObject(_then);\n    XExpression _else = expr.getElse();\n    final INode elsenode = _else==null?(INode)null:this._nodeModelAccess.nodeForEObject(_else);\n    boolean _or = false;\n    boolean _or_1 = false;\n    String _text = thennode.getText();\n    String _trim = _text.trim();\n    boolean _contains = _trim.contains(\"\\n\");\n    if (_contains) {\n      _or_1 = true;\n    } else {\n      ILeafNode _whitespaceBefore = this._nodeModelAccess.whitespaceBefore(thennode);\n      String _text_1 = _whitespaceBefore==null?(String)null:_whitespaceBefore.getText();\n      boolean _contains_1 = _text_1==null?false:_text_1.contains(\"\\n\");\n      _or_1 = (_contains || _contains_1);\n    }\n    if (_or_1) {\n      _or = true;\n    } else {\n      String _text_2 = elsenode==null?(String)null:elsenode.getText();\n      String _trim_1 = _text_2==null?(String)null:_text_2.trim();\n      boolean _contains_2 = _trim_1==null?false:_trim_1.contains(\"\\n\");\n      _or = (_or_1 || _contains_2);\n    }\n    final boolean multiline = _or;\n    boolean _or_2 = false;\n    XExpression _then_1 = expr.getThen();\n    if ((_then_1 instanceof XBlockExpression)) {\n      _or_2 = true;\n    } else {\n      boolean _not_1 = (!multiline);\n      _or_2 = ((_then_1 instanceof XBlockExpression) || _not_1);\n    }\n    if (_or_2) {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      FormattingData _prepend = this.prepend(thennode, _function_2);\n      format.operator_add(_prepend);\n      XExpression _else_1 = expr.getElse();\n      boolean _notEquals = (!Objects.equal(_else_1, null));\n      if (_notEquals) {\n        final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.space = \" \";\n            }\n          };\n        FormattingData _append_2 = this.append(thennode, _function_3);\n        format.operator_add(_append_2);\n      }\n    } else {\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      FormattingData _prepend_1 = this.prepend(thennode, _function_4);\n      format.operator_add(_prepend_1);\n      XExpression _else_2 = expr.getElse();\n      boolean _notEquals_1 = (!Objects.equal(_else_2, null));\n      if (_notEquals_1) {\n        final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.decreaseIndentation();\n            }\n          };\n        FormattingData _append_3 = this.append(thennode, _function_5);\n        format.operator_add(_append_3);\n      } else {\n        final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        FormattingData _append_4 = this.append(thennode, _function_6);\n        format.operator_add(_append_4);\n      }\n    }\n    boolean _or_3 = false;\n    XExpression _else_3 = expr.getElse();\n    if ((_else_3 instanceof XBlockExpression)) {\n      _or_3 = true;\n    } else {\n      boolean _not_2 = (!multiline);\n      _or_3 = ((_else_3 instanceof XBlockExpression) || _not_2);\n    }\n    if (_or_3) {\n      final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      FormattingData _prepend_2 = this.prepend(elsenode, _function_7);\n      format.operator_add(_prepend_2);\n    } else {\n      final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      FormattingData _prepend_3 = this.prepend(elsenode, _function_8);\n      format.operator_add(_prepend_3);\n      final Procedure1<FormattingDataInit> _function_9 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      FormattingData _append_5 = this.append(elsenode, _function_9);\n      format.operator_add(_append_5);\n    }\n    XExpression _then_2 = expr.getThen();\n    this.format(_then_2, format);\n    XExpression _else_4 = expr.getElse();\n    boolean _notEquals_2 = (!Objects.equal(_else_4, null));\n    if (_notEquals_2) {\n      XExpression _else_5 = expr.getElse();\n      this.format(_else_5, format);\n    }\n  }","commit_id":"ca3beaeea39e453c457869fe65711b66b190bbd3","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XBlockExpression expr, final FormattableDocument format) {\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(expr, \"{\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(expr, \"}\");\n    boolean _and = false;\n    boolean _notEquals = (!Objects.equal(open, null));\n    if (!_notEquals) {\n      _and = false;\n    } else {\n      boolean _notEquals_1 = (!Objects.equal(close, null));\n      _and = (_notEquals && _notEquals_1);\n    }\n    if (_and) {\n      EList<XExpression> _expressions = expr.getExpressions();\n      boolean _isEmpty = _expressions.isEmpty();\n      if (_isEmpty) {\n        final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formattingDataFactory.append(open, _function);\n        format.operator_add(_append);\n      } else {\n        final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(XbaseFormatter2.this._xbaseFormatterConfigKeys.blankLinesAroundExpression);\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formattingDataFactory.append(open, _function_1);\n        format.operator_add(_append_1);\n        EList<XExpression> _expressions_1 = expr.getExpressions();\n        for (final XExpression child : _expressions_1) {\n          {\n            this.format(child, format);\n            boolean _or = false;\n            EList<XExpression> _expressions_2 = expr.getExpressions();\n            XExpression _last = IterableExtensions.<XExpression>last(_expressions_2);\n            boolean _notEquals_2 = (!Objects.equal(child, _last));\n            if (_notEquals_2) {\n              _or = true;\n            } else {\n              boolean _notEquals_3 = (!Objects.equal(close, null));\n              _or = (_notEquals_2 || _notEquals_3);\n            }\n            if (_or) {\n              final INode childNode = this._nodeModelAccess.nodeForEObject(child);\n              final ILeafNode sem = this._nodeModelAccess.immediatelyFollowingKeyword(childNode, \";\");\n              boolean _notEquals_4 = (!Objects.equal(sem, null));\n              if (_notEquals_4) {\n                final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.noSpace();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(sem, _function_2);\n                format.operator_add(_prepend);\n                final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XbaseFormatter2.this._xbaseFormatterConfigKeys.blankLinesAroundExpression);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formattingDataFactory.append(sem, _function_3);\n                format.operator_add(_append_2);\n              } else {\n                final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XbaseFormatter2.this._xbaseFormatterConfigKeys.blankLinesAroundExpression);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formattingDataFactory.append(childNode, _function_4);\n                format.operator_add(_append_3);\n              }\n            }\n          }\n        }\n        final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(close, _function_2);\n        format.operator_add(_prepend);\n      }\n    }\n  }","id":71707,"modified_method":"protected void _format(final XBlockExpression expr, final FormattableDocument format) {\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(expr, \"{\");\n    EObject _eContainer = expr.eContainer();\n    boolean _equals = Objects.equal(_eContainer, null);\n    if (_equals) {\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formattingDataFactory.prepend(open, _function);\n      format.operator_add(_prepend);\n    }\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(expr, \"}\");\n    boolean _and = false;\n    boolean _notEquals = (!Objects.equal(open, null));\n    if (!_notEquals) {\n      _and = false;\n    } else {\n      boolean _notEquals_1 = (!Objects.equal(close, null));\n      _and = (_notEquals && _notEquals_1);\n    }\n    if (_and) {\n      EList<XExpression> _expressions = expr.getExpressions();\n      boolean _isEmpty = _expressions.isEmpty();\n      if (_isEmpty) {\n        final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formattingDataFactory.append(open, _function_1);\n        format.operator_add(_append);\n      } else {\n        final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(XbaseFormatter2.this._xbaseFormatterConfigKeys.blankLinesAroundExpression);\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formattingDataFactory.append(open, _function_2);\n        format.operator_add(_append_1);\n        EList<XExpression> _expressions_1 = expr.getExpressions();\n        for (final XExpression child : _expressions_1) {\n          {\n            this.format(child, format);\n            boolean _or = false;\n            EList<XExpression> _expressions_2 = expr.getExpressions();\n            XExpression _last = IterableExtensions.<XExpression>last(_expressions_2);\n            boolean _notEquals_2 = (!Objects.equal(child, _last));\n            if (_notEquals_2) {\n              _or = true;\n            } else {\n              boolean _notEquals_3 = (!Objects.equal(close, null));\n              _or = (_notEquals_2 || _notEquals_3);\n            }\n            if (_or) {\n              final INode childNode = this._nodeModelAccess.nodeForEObject(child);\n              final ILeafNode sem = this._nodeModelAccess.immediatelyFollowingKeyword(childNode, \";\");\n              boolean _notEquals_4 = (!Objects.equal(sem, null));\n              if (_notEquals_4) {\n                final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.noSpace();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formattingDataFactory.prepend(sem, _function_3);\n                format.operator_add(_prepend_1);\n                final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XbaseFormatter2.this._xbaseFormatterConfigKeys.blankLinesAroundExpression);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formattingDataFactory.append(sem, _function_4);\n                format.operator_add(_append_2);\n              } else {\n                final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XbaseFormatter2.this._xbaseFormatterConfigKeys.blankLinesAroundExpression);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formattingDataFactory.append(childNode, _function_5);\n                format.operator_add(_append_3);\n              }\n            }\n          }\n        }\n        final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formattingDataFactory.prepend(close, _function_3);\n        format.operator_add(_prepend_1);\n      }\n    }\n  }","commit_id":"64ac51dcc0deae74e344690c09588e562a623cfb","url":"https://github.com/eclipse/xtext"},{"original_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> append(final INode node, final IConfigurationKey<? extends Object> key) {\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _xifexpression = null;\n    boolean _notEquals = (!Objects.equal(node, null));\n    if (_notEquals) {\n      HiddenLeafs _hiddenLeafsAfter = this._hiddenLeafAccess.getHiddenLeafsAfter(node);\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData = this.newFormattingData(_hiddenLeafsAfter, key, 0);\n      _xifexpression = _newFormattingData;\n    }\n    return _xifexpression;\n  }","id":71708,"modified_method":"protected Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData(final HiddenLeafs leafs, final IConfigurationKey<? extends Object> key, final FormattingDataInit it) {\n    Class<? extends Object> _class = key.getClass();\n    String _plus = (\"Unknown configuration key kind: \" + _class);\n    RuntimeException _runtimeException = new RuntimeException(_plus);\n    throw _runtimeException;\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> newFormattingData(final HiddenLeafs leafs, final Procedure1<? super FormattingDataInit> init) {\n    final Function1<FormattableDocument,Iterable<FormattingData>> _function = new Function1<FormattableDocument,Iterable<FormattingData>>() {\n        public Iterable<FormattingData> apply(final FormattableDocument doc) {\n          FormattingDataInit _formattingDataInit = new FormattingDataInit();\n          final FormattingDataInit it = _formattingDataInit;\n          init.apply(it);\n          boolean _and = false;\n          Integer _newLinesInComments = leafs.getNewLinesInComments();\n          boolean _equals = ((_newLinesInComments).intValue() == 0);\n          if (!_equals) {\n            _and = false;\n          } else {\n            boolean _or = false;\n            boolean _equals_1 = (it.newLines == 0);\n            if (_equals_1) {\n              _or = true;\n            } else {\n              boolean _equals_2 = Objects.equal(it.space, \"\");\n              _or = (_equals_1 || _equals_2);\n            }\n            _and = (_equals && _or);\n          }\n          if (_and) {\n            boolean _isDebugConflicts = doc.isDebugConflicts();\n            return FormatterExtensions.this.newFormattingData(leafs, it.space, it.indentationChange, _isDebugConflicts);\n          } else {\n            boolean _isDebugConflicts_1 = doc.isDebugConflicts();\n            return FormatterExtensions.this.newFormattingData(leafs, it.newLines, it.newLines, it.indentationChange, _isDebugConflicts_1);\n          }\n        }\n      };\n    return _function;\n  }","id":71709,"modified_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> newFormattingData(final HiddenLeafs leafs, final Procedure1<? super FormattingDataInit> init) {\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _xblockexpression = null;\n    {\n      FormattingDataInit _formattingDataInit = new FormattingDataInit();\n      final FormattingDataInit data = _formattingDataInit;\n      init.apply(data);\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _newFormattingData = this.newFormattingData(leafs, data.key, data);\n      _xblockexpression = (_newFormattingData);\n    }\n    return _xblockexpression;\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<FormattingData> newFormattingData(final HiddenLeafs leafs, final String space, final int indentationChange, final boolean trace) {\n    ArrayList<FormattingData> _xblockexpression = null;\n    {\n      final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n      List<LeafInfo> _leafs = leafs.getLeafs();\n      for (final LeafInfo leaf : _leafs) {\n        boolean _matched = false;\n        if (!_matched) {\n          if (leaf instanceof WhitespaceInfo) {\n            final WhitespaceInfo _whitespaceInfo = (WhitespaceInfo)leaf;\n            _matched=true;\n            int _offset = _whitespaceInfo.getOffset();\n            int _length = _whitespaceInfo.getLength();\n            RuntimeException _xifexpression = null;\n            if (trace) {\n              RuntimeException _runtimeException = new RuntimeException();\n              _xifexpression = _runtimeException;\n            }\n            WhitespaceData _whitespaceData = new WhitespaceData(_offset, _length, indentationChange, _xifexpression, space);\n            result.add(_whitespaceData);\n          }\n        }\n        if (!_matched) {\n          if (leaf instanceof CommentInfo) {\n            final CommentInfo _commentInfo = (CommentInfo)leaf;\n            _matched=true;\n          }\n        }\n      }\n      _xblockexpression = (result);\n    }\n    return _xblockexpression;\n  }","id":71710,"modified_method":"protected Iterable<FormattingData> newWhitespaceData(final HiddenLeafs leafs, final String space, final int indentationChange, final boolean trace) {\n    ArrayList<FormattingData> _xblockexpression = null;\n    {\n      final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n      List<LeafInfo> _leafs = leafs.getLeafs();\n      for (final LeafInfo leaf : _leafs) {\n        boolean _matched = false;\n        if (!_matched) {\n          if (leaf instanceof WhitespaceInfo) {\n            final WhitespaceInfo _whitespaceInfo = (WhitespaceInfo)leaf;\n            _matched=true;\n            int _offset = _whitespaceInfo.getOffset();\n            int _length = _whitespaceInfo.getLength();\n            RuntimeException _xifexpression = null;\n            if (trace) {\n              RuntimeException _runtimeException = new RuntimeException();\n              _xifexpression = _runtimeException;\n            }\n            WhitespaceData _whitespaceData = new WhitespaceData(_offset, _length, indentationChange, _xifexpression, space);\n            result.add(_whitespaceData);\n          }\n        }\n        if (!_matched) {\n          if (leaf instanceof CommentInfo) {\n            final CommentInfo _commentInfo = (CommentInfo)leaf;\n            _matched=true;\n          }\n        }\n      }\n      _xblockexpression = (result);\n    }\n    return _xblockexpression;\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"public Function1<? super FormattableDocument,? extends Iterable<FormattingData>> newFormattingData(final HiddenLeafs leafs, final IConfigurationKey<? extends Object> key, final int indentationChange) {\n    Function1<FormattableDocument,Iterable<FormattingData>> _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (key instanceof BlankLineKey) {\n        final BlankLineKey _blankLineKey = (BlankLineKey)key;\n        _matched=true;\n        final Function1<FormattableDocument,Iterable<FormattingData>> _function = new Function1<FormattableDocument,Iterable<FormattingData>>() {\n            public Iterable<FormattingData> apply(final FormattableDocument doc) {\n              Iterable<FormattingData> _xblockexpression = null;\n              {\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg = doc.getCfg();\n                final Integer blankline = _cfg.<Integer>get(_blankLineKey);\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg_1 = doc.getCfg();\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg_2 = doc.getCfg();\n                XtendFormatterConfigKeys _keys = _cfg_2.getKeys();\n                final Integer preserve = _cfg_1.<Integer>get(_keys.preserveBlankLines);\n                final int min = ((blankline).intValue() + 1);\n                int _plus = ((preserve).intValue() + 1);\n                final int max = Math.max(_plus, min);\n                boolean _isDebugConflicts = doc.isDebugConflicts();\n                Iterable<FormattingData> _newFormattingData = FormatterExtensions.this.newFormattingData(leafs, min, max, indentationChange, _isDebugConflicts);\n                _xblockexpression = (_newFormattingData);\n              }\n              return _xblockexpression;\n            }\n          };\n        _switchResult = _function;\n      }\n    }\n    if (!_matched) {\n      if (key instanceof NewLineOrPreserveKey) {\n        final NewLineOrPreserveKey _newLineOrPreserveKey = (NewLineOrPreserveKey)key;\n        _matched=true;\n        final Function1<FormattableDocument,Iterable<FormattingData>> _function = new Function1<FormattableDocument,Iterable<FormattingData>>() {\n            public Iterable<FormattingData> apply(final FormattableDocument doc) {\n              Iterable<FormattingData> _xblockexpression = null;\n              {\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg = doc.getCfg();\n                final Boolean newLine = _cfg.<Boolean>get(_newLineOrPreserveKey);\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg_1 = doc.getCfg();\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg_2 = doc.getCfg();\n                XtendFormatterConfigKeys _keys = _cfg_2.getKeys();\n                final Boolean preserve = _cfg_1.<Boolean>get(_keys.preserveNewLines);\n                int _xifexpression = (int) 0;\n                if ((newLine).booleanValue()) {\n                  _xifexpression = 1;\n                } else {\n                  _xifexpression = 0;\n                }\n                int _xifexpression_1 = (int) 0;\n                boolean _or = false;\n                if ((preserve).booleanValue()) {\n                  _or = true;\n                } else {\n                  _or = ((preserve).booleanValue() || (newLine).booleanValue());\n                }\n                if (_or) {\n                  _xifexpression_1 = 1;\n                } else {\n                  _xifexpression_1 = 0;\n                }\n                boolean _isDebugConflicts = doc.isDebugConflicts();\n                Iterable<FormattingData> _newFormattingData = FormatterExtensions.this.newFormattingData(leafs, _xifexpression, _xifexpression_1, indentationChange, _isDebugConflicts);\n                _xblockexpression = (_newFormattingData);\n              }\n              return _xblockexpression;\n            }\n          };\n        _switchResult = _function;\n      }\n    }\n    if (!_matched) {\n      if (key instanceof NewLineKey) {\n        final NewLineKey _newLineKey = (NewLineKey)key;\n        _matched=true;\n        final Function1<FormattableDocument,Iterable<FormattingData>> _function = new Function1<FormattableDocument,Iterable<FormattingData>>() {\n            public Iterable<FormattingData> apply(final FormattableDocument doc) {\n              Iterable<FormattingData> _xblockexpression = null;\n              {\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg = doc.getCfg();\n                final Boolean newLine = _cfg.<Boolean>get(_newLineKey);\n                int _xifexpression = (int) 0;\n                if ((newLine).booleanValue()) {\n                  _xifexpression = 1;\n                } else {\n                  _xifexpression = 0;\n                }\n                final int minmax = _xifexpression;\n                boolean _isDebugConflicts = doc.isDebugConflicts();\n                Iterable<FormattingData> _newFormattingData = FormatterExtensions.this.newFormattingData(leafs, minmax, minmax, indentationChange, _isDebugConflicts);\n                _xblockexpression = (_newFormattingData);\n              }\n              return _xblockexpression;\n            }\n          };\n        _switchResult = _function;\n      }\n    }\n    if (!_matched) {\n      if (key instanceof WhitespaceKey) {\n        final WhitespaceKey _whitespaceKey = (WhitespaceKey)key;\n        _matched=true;\n        final Function1<FormattableDocument,Iterable<FormattingData>> _function = new Function1<FormattableDocument,Iterable<FormattingData>>() {\n            public Iterable<FormattingData> apply(final FormattableDocument doc) {\n              Iterable<FormattingData> _xblockexpression = null;\n              {\n                IConfigurationValues<XtendFormatterConfigKeys> _cfg = doc.getCfg();\n                final Boolean space = _cfg.<Boolean>get(_whitespaceKey);\n                String _xifexpression = null;\n                if ((space).booleanValue()) {\n                  _xifexpression = \" \";\n                } else {\n                  _xifexpression = \"\";\n                }\n                boolean _isDebugConflicts = doc.isDebugConflicts();\n                Iterable<FormattingData> _newFormattingData = FormatterExtensions.this.newFormattingData(leafs, _xifexpression, indentationChange, _isDebugConflicts);\n                _xblockexpression = (_newFormattingData);\n              }\n              return _xblockexpression;\n            }\n          };\n        _switchResult = _function;\n      }\n    }\n    if (!_matched) {\n      RuntimeException _runtimeException = new RuntimeException(\"can\\'t handle configuration key\");\n      throw _runtimeException;\n    }\n    return _switchResult;\n  }","id":71711,"modified_method":"protected Function1<? super FormattableDocument,? extends Iterable<FormattingData>> newFormattingData(final HiddenLeafs leafs, final IConfigurationKey<? extends Object> key, final FormattingDataInit it) {\n    if (key instanceof BlankLineKey) {\n      return _newFormattingData(leafs, (BlankLineKey)key, it);\n    } else if (key instanceof NewLineKey) {\n      return _newFormattingData(leafs, (NewLineKey)key, it);\n    } else if (key instanceof NewLineOrPreserveKey) {\n      return _newFormattingData(leafs, (NewLineOrPreserveKey)key, it);\n    } else if (key instanceof WhitespaceKey) {\n      return _newFormattingData(leafs, (WhitespaceKey)key, it);\n    } else if (key == null) {\n      return _newFormattingData(leafs, (Void)null, it);\n    } else if (key != null) {\n      return _newFormattingData(leafs, key, it);\n    } else {\n      throw new IllegalArgumentException(\"Unhandled parameter types: \" +\n        Arrays.<Object>asList(leafs, key, it).toString());\n    }\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"public Iterable<FormattingData> newFormattingData(final HiddenLeafs leafs, final int minNewLines, final int maxNewLines, final int indentationChange, final boolean trace) {\n    ArrayList<FormattingData> _xblockexpression = null;\n    {\n      final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n      boolean applied = false;\n      List<LeafInfo> _leafs = leafs.getLeafs();\n      for (final LeafInfo leaf : _leafs) {\n        boolean _matched = false;\n        if (!_matched) {\n          if (leaf instanceof WhitespaceInfo) {\n            final WhitespaceInfo _whitespaceInfo = (WhitespaceInfo)leaf;\n            _matched=true;\n            boolean _and = false;\n            CommentInfo _trailingComment = _whitespaceInfo.trailingComment();\n            boolean _isTrailing = _trailingComment==null?false:_trailingComment.isTrailing();\n            if (!_isTrailing) {\n              _and = false;\n            } else {\n              CommentInfo _trailingComment_1 = _whitespaceInfo.trailingComment();\n              boolean _isMultiline = _trailingComment_1==null?false:_trailingComment_1.isMultiline();\n              boolean _not = (!_isMultiline);\n              _and = (_isTrailing && _not);\n            }\n            if (_and) {\n              String _xifexpression = null;\n              int _offset = _whitespaceInfo.getOffset();\n              boolean _equals = (_offset == 0);\n              if (_equals) {\n                _xifexpression = \"\";\n              } else {\n                _xifexpression = \" \";\n              }\n              final String space = _xifexpression;\n              int _offset_1 = _whitespaceInfo.getOffset();\n              int _length = _whitespaceInfo.getLength();\n              RuntimeException _xifexpression_1 = null;\n              if (trace) {\n                RuntimeException _runtimeException = new RuntimeException();\n                _xifexpression_1 = _runtimeException;\n              }\n              WhitespaceData _whitespaceData = new WhitespaceData(_offset_1, _length, indentationChange, _xifexpression_1, space);\n              result.add(_whitespaceData);\n            } else {\n              boolean _not_1 = (!applied);\n              if (_not_1) {\n                Integer _newLines = leafs.getNewLines();\n                int _max = Math.max((_newLines).intValue(), minNewLines);\n                int newLines = Math.min(_max, maxNewLines);\n                boolean _and_1 = false;\n                boolean _and_2 = false;\n                boolean _lessThan = (newLines < 1);\n                if (!_lessThan) {\n                  _and_2 = false;\n                } else {\n                  int _offset_2 = _whitespaceInfo.getOffset();\n                  boolean _greaterThan = (_offset_2 > 0);\n                  _and_2 = (_lessThan && _greaterThan);\n                }\n                if (!_and_2) {\n                  _and_1 = false;\n                } else {\n                  boolean _or = false;\n                  CommentInfo _leadingComment = _whitespaceInfo.leadingComment();\n                  boolean _isMultiline_1 = _leadingComment==null?false:_leadingComment.isMultiline();\n                  if (_isMultiline_1) {\n                    _or = true;\n                  } else {\n                    CommentInfo _trailingComment_2 = _whitespaceInfo.trailingComment();\n                    boolean _isMultiline_2 = _trailingComment_2==null?false:_trailingComment_2.isMultiline();\n                    _or = (_isMultiline_1 || _isMultiline_2);\n                  }\n                  _and_1 = (_and_2 && _or);\n                }\n                if (_and_1) {\n                  newLines = 1;\n                }\n                CommentInfo _leadingComment_1 = _whitespaceInfo.leadingComment();\n                boolean _endsWithNewLine = _leadingComment_1==null?false:_leadingComment_1.endsWithNewLine();\n                if (_endsWithNewLine) {\n                  int _minus = (newLines - 1);\n                  newLines = _minus;\n                }\n                boolean _and_3 = false;\n                CommentInfo _leadingComment_2 = _whitespaceInfo.leadingComment();\n                boolean _endsWithNewLine_1 = _leadingComment_2==null?false:_leadingComment_2.endsWithNewLine();\n                boolean _not_2 = (!_endsWithNewLine_1);\n                if (!_not_2) {\n                  _and_3 = false;\n                } else {\n                  boolean _equals_1 = (newLines == 0);\n                  _and_3 = (_not_2 && _equals_1);\n                }\n                if (_and_3) {\n                  int _offset_3 = _whitespaceInfo.getOffset();\n                  int _length_1 = _whitespaceInfo.getLength();\n                  RuntimeException _xifexpression_2 = null;\n                  if (trace) {\n                    RuntimeException _runtimeException_1 = new RuntimeException();\n                    _xifexpression_2 = _runtimeException_1;\n                  }\n                  String _xifexpression_3 = null;\n                  int _offset_4 = _whitespaceInfo.getOffset();\n                  boolean _equals_2 = (_offset_4 == 0);\n                  if (_equals_2) {\n                    _xifexpression_3 = \"\";\n                  } else {\n                    _xifexpression_3 = \" \";\n                  }\n                  WhitespaceData _whitespaceData_1 = new WhitespaceData(_offset_3, _length_1, indentationChange, _xifexpression_2, _xifexpression_3);\n                  result.add(_whitespaceData_1);\n                } else {\n                  int _offset_5 = _whitespaceInfo.getOffset();\n                  int _length_2 = _whitespaceInfo.getLength();\n                  RuntimeException _xifexpression_4 = null;\n                  if (trace) {\n                    RuntimeException _runtimeException_2 = new RuntimeException();\n                    _xifexpression_4 = _runtimeException_2;\n                  }\n                  NewLineData _newLineData = new NewLineData(_offset_5, _length_2, indentationChange, _xifexpression_4, newLines);\n                  result.add(_newLineData);\n                }\n                applied = true;\n              } else {\n                int newLines_1 = 1;\n                CommentInfo _leadingComment_3 = _whitespaceInfo.leadingComment();\n                boolean _endsWithNewLine_2 = _leadingComment_3==null?false:_leadingComment_3.endsWithNewLine();\n                if (_endsWithNewLine_2) {\n                  int _minus_1 = (newLines_1 - 1);\n                  newLines_1 = _minus_1;\n                }\n                int _offset_6 = _whitespaceInfo.getOffset();\n                int _length_3 = _whitespaceInfo.getLength();\n                RuntimeException _xifexpression_5 = null;\n                if (trace) {\n                  RuntimeException _runtimeException_3 = new RuntimeException();\n                  _xifexpression_5 = _runtimeException_3;\n                }\n                NewLineData _newLineData_1 = new NewLineData(_offset_6, _length_3, indentationChange, _xifexpression_5, newLines_1);\n                result.add(_newLineData_1);\n              }\n            }\n          }\n        }\n        if (!_matched) {\n          if (leaf instanceof CommentInfo) {\n            final CommentInfo _commentInfo = (CommentInfo)leaf;\n            _matched=true;\n          }\n        }\n      }\n      _xblockexpression = (result);\n    }\n    return _xblockexpression;\n  }","id":71712,"modified_method":"protected Iterable<FormattingData> newNewLineData(final HiddenLeafs leafs, final int minNewLines, final int maxNewLines, final int indentationChange, final boolean trace) {\n    ArrayList<FormattingData> _xblockexpression = null;\n    {\n      final ArrayList<FormattingData> result = CollectionLiterals.<FormattingData>newArrayList();\n      boolean applied = false;\n      List<LeafInfo> _leafs = leafs.getLeafs();\n      for (final LeafInfo leaf : _leafs) {\n        boolean _matched = false;\n        if (!_matched) {\n          if (leaf instanceof WhitespaceInfo) {\n            final WhitespaceInfo _whitespaceInfo = (WhitespaceInfo)leaf;\n            _matched=true;\n            boolean _and = false;\n            CommentInfo _trailingComment = _whitespaceInfo.trailingComment();\n            boolean _isTrailing = _trailingComment==null?false:_trailingComment.isTrailing();\n            if (!_isTrailing) {\n              _and = false;\n            } else {\n              CommentInfo _trailingComment_1 = _whitespaceInfo.trailingComment();\n              boolean _isMultiline = _trailingComment_1==null?false:_trailingComment_1.isMultiline();\n              boolean _not = (!_isMultiline);\n              _and = (_isTrailing && _not);\n            }\n            if (_and) {\n              String _xifexpression = null;\n              int _offset = _whitespaceInfo.getOffset();\n              boolean _equals = (_offset == 0);\n              if (_equals) {\n                _xifexpression = \"\";\n              } else {\n                _xifexpression = \" \";\n              }\n              final String space = _xifexpression;\n              int _offset_1 = _whitespaceInfo.getOffset();\n              int _length = _whitespaceInfo.getLength();\n              RuntimeException _xifexpression_1 = null;\n              if (trace) {\n                RuntimeException _runtimeException = new RuntimeException();\n                _xifexpression_1 = _runtimeException;\n              }\n              WhitespaceData _whitespaceData = new WhitespaceData(_offset_1, _length, indentationChange, _xifexpression_1, space);\n              result.add(_whitespaceData);\n            } else {\n              boolean _not_1 = (!applied);\n              if (_not_1) {\n                Integer _newLines = leafs.getNewLines();\n                int _max = Math.max((_newLines).intValue(), minNewLines);\n                int newLines = Math.min(_max, maxNewLines);\n                boolean _and_1 = false;\n                boolean _and_2 = false;\n                boolean _lessThan = (newLines < 1);\n                if (!_lessThan) {\n                  _and_2 = false;\n                } else {\n                  int _offset_2 = _whitespaceInfo.getOffset();\n                  boolean _greaterThan = (_offset_2 > 0);\n                  _and_2 = (_lessThan && _greaterThan);\n                }\n                if (!_and_2) {\n                  _and_1 = false;\n                } else {\n                  boolean _or = false;\n                  CommentInfo _leadingComment = _whitespaceInfo.leadingComment();\n                  boolean _isMultiline_1 = _leadingComment==null?false:_leadingComment.isMultiline();\n                  if (_isMultiline_1) {\n                    _or = true;\n                  } else {\n                    CommentInfo _trailingComment_2 = _whitespaceInfo.trailingComment();\n                    boolean _isMultiline_2 = _trailingComment_2==null?false:_trailingComment_2.isMultiline();\n                    _or = (_isMultiline_1 || _isMultiline_2);\n                  }\n                  _and_1 = (_and_2 && _or);\n                }\n                if (_and_1) {\n                  newLines = 1;\n                }\n                CommentInfo _leadingComment_1 = _whitespaceInfo.leadingComment();\n                boolean _endsWithNewLine = _leadingComment_1==null?false:_leadingComment_1.endsWithNewLine();\n                if (_endsWithNewLine) {\n                  int _minus = (newLines - 1);\n                  newLines = _minus;\n                }\n                boolean _and_3 = false;\n                CommentInfo _leadingComment_2 = _whitespaceInfo.leadingComment();\n                boolean _endsWithNewLine_1 = _leadingComment_2==null?false:_leadingComment_2.endsWithNewLine();\n                boolean _not_2 = (!_endsWithNewLine_1);\n                if (!_not_2) {\n                  _and_3 = false;\n                } else {\n                  boolean _equals_1 = (newLines == 0);\n                  _and_3 = (_not_2 && _equals_1);\n                }\n                if (_and_3) {\n                  int _offset_3 = _whitespaceInfo.getOffset();\n                  int _length_1 = _whitespaceInfo.getLength();\n                  RuntimeException _xifexpression_2 = null;\n                  if (trace) {\n                    RuntimeException _runtimeException_1 = new RuntimeException();\n                    _xifexpression_2 = _runtimeException_1;\n                  }\n                  String _xifexpression_3 = null;\n                  int _offset_4 = _whitespaceInfo.getOffset();\n                  boolean _equals_2 = (_offset_4 == 0);\n                  if (_equals_2) {\n                    _xifexpression_3 = \"\";\n                  } else {\n                    _xifexpression_3 = \" \";\n                  }\n                  WhitespaceData _whitespaceData_1 = new WhitespaceData(_offset_3, _length_1, indentationChange, _xifexpression_2, _xifexpression_3);\n                  result.add(_whitespaceData_1);\n                } else {\n                  int _offset_5 = _whitespaceInfo.getOffset();\n                  int _length_2 = _whitespaceInfo.getLength();\n                  RuntimeException _xifexpression_4 = null;\n                  if (trace) {\n                    RuntimeException _runtimeException_2 = new RuntimeException();\n                    _xifexpression_4 = _runtimeException_2;\n                  }\n                  NewLineData _newLineData = new NewLineData(_offset_5, _length_2, indentationChange, _xifexpression_4, newLines);\n                  result.add(_newLineData);\n                }\n                applied = true;\n              } else {\n                int newLines_1 = 1;\n                CommentInfo _leadingComment_3 = _whitespaceInfo.leadingComment();\n                boolean _endsWithNewLine_2 = _leadingComment_3==null?false:_leadingComment_3.endsWithNewLine();\n                if (_endsWithNewLine_2) {\n                  int _minus_1 = (newLines_1 - 1);\n                  newLines_1 = _minus_1;\n                }\n                int _offset_6 = _whitespaceInfo.getOffset();\n                int _length_3 = _whitespaceInfo.getLength();\n                RuntimeException _xifexpression_5 = null;\n                if (trace) {\n                  RuntimeException _runtimeException_3 = new RuntimeException();\n                  _xifexpression_5 = _runtimeException_3;\n                }\n                NewLineData _newLineData_1 = new NewLineData(_offset_6, _length_3, indentationChange, _xifexpression_5, newLines_1);\n                result.add(_newLineData_1);\n              }\n            }\n          }\n        }\n        if (!_matched) {\n          if (leaf instanceof CommentInfo) {\n            final CommentInfo _commentInfo = (CommentInfo)leaf;\n            _matched=true;\n          }\n        }\n      }\n      _xblockexpression = (result);\n    }\n    return _xblockexpression;\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void formatAnnotations(final XtendAnnotationTarget target, final FormattableDocument document, final IConfigurationKey<? extends Object> configKey) {\n    EList<XAnnotation> _annotations = target.getAnnotations();\n    boolean _isEmpty = _annotations.isEmpty();\n    if (_isEmpty) {\n      return;\n    }\n    EList<XAnnotation> _annotations_1 = target.getAnnotations();\n    for (final XAnnotation a : _annotations_1) {\n      {\n        this.format(a, document);\n        INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(a);\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForEObject, configKey);\n        document.operator_add(_append);\n      }\n    }\n  }","id":71713,"modified_method":"protected void formatAnnotations(final XtendAnnotationTarget target, final FormattableDocument document, final IConfigurationKey<? extends Object> configKey) {\n    EList<XAnnotation> _annotations = target.getAnnotations();\n    boolean _isEmpty = _annotations.isEmpty();\n    if (_isEmpty) {\n      return;\n    }\n    EList<XAnnotation> _annotations_1 = target.getAnnotations();\n    for (final XAnnotation a : _annotations_1) {\n      {\n        this.format(a, document);\n        INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(a);\n        final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(configKey);\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForEObject, _function);\n        document.operator_add(_append);\n      }\n    }\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XWhileExpression expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"while\");\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n    format.operator_add(_append);\n    XExpression _predicate = expr.getPredicate();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_predicate);\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForEObject, _function, _function_1);\n    format.operator_add(_surround);\n    XExpression _body = expr.getBody();\n    final INode body = this._nodeModelAccess.nodeForEObject(_body);\n    XExpression _body_1 = expr.getBody();\n    if ((_body_1 instanceof XBlockExpression)) {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_prepend);\n    } else {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function_2);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, _function_3);\n      format.operator_add(_append_1);\n    }\n    XExpression _predicate_1 = expr.getPredicate();\n    this.format(_predicate_1, format);\n    XExpression _body_2 = expr.getBody();\n    this.format(_body_2, format);\n  }","id":71714,"modified_method":"protected void _format(final XWhileExpression expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"while\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    XExpression _predicate = expr.getPredicate();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_predicate);\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForEObject, _function_1, _function_2);\n    format.operator_add(_surround);\n    XExpression _body = expr.getBody();\n    final INode body = this._nodeModelAccess.nodeForEObject(_body);\n    XExpression _body_1 = expr.getBody();\n    if ((_body_1 instanceof XBlockExpression)) {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, _function_3);\n      format.operator_add(_prepend);\n    } else {\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function_4);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, _function_5);\n      format.operator_add(_append_1);\n    }\n    XExpression _predicate_1 = expr.getPredicate();\n    this.format(_predicate_1, format);\n    XExpression _body_2 = expr.getBody();\n    this.format(_body_2, format);\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XtendConstructor func, final FormattableDocument format) {\n    this.formatAnnotations(func, format, this._xtendFormatterConfigKeys.newLineAfterConstructorAnnotations);\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(func, \"new\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    EList<JvmTypeParameter> _typeParameters = func.getTypeParameters();\n    boolean _isEmpty = _typeParameters.isEmpty();\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(func, \"<\");\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForKeyword_1, _function_1);\n      format.operator_add(_append_1);\n      EList<JvmTypeParameter> _typeParameters_1 = func.getTypeParameters();\n      for (final JvmTypeParameter arg : _typeParameters_1) {\n        {\n          this.format(arg, format);\n          ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(arg, \",\");\n          final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_2, _function_3);\n          format.operator_add(_surround);\n        }\n      }\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(func, \">\");\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForKeyword_2, _function_2);\n      format.operator_add(_surround);\n    }\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(func, \"(\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(func, \")\");\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(close, this._xtendFormatterConfigKeys.bracesInNewLine);\n    format.operator_add(_append_2);\n    EList<XtendParameter> _parameters = func.getParameters();\n    this.formatMemberParameter(_parameters, open, close, format);\n    XExpression _expression = func.getExpression();\n    this.format(_expression, format);\n  }","id":71715,"modified_method":"protected void _format(final XtendConstructor func, final FormattableDocument format) {\n    this.formatAnnotations(func, format, this._xtendFormatterConfigKeys.newLineAfterConstructorAnnotations);\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(func, \"new\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    EList<JvmTypeParameter> _typeParameters = func.getTypeParameters();\n    boolean _isEmpty = _typeParameters.isEmpty();\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(func, \"<\");\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForKeyword_1, _function_1);\n      format.operator_add(_append_1);\n      EList<JvmTypeParameter> _typeParameters_1 = func.getTypeParameters();\n      for (final JvmTypeParameter arg : _typeParameters_1) {\n        {\n          this.format(arg, format);\n          ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(arg, \",\");\n          final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_2, _function_3);\n          format.operator_add(_surround);\n        }\n      }\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(func, \">\");\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForKeyword_2, _function_2);\n      format.operator_add(_surround);\n    }\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(func, \"(\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(func, \")\");\n    final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(close, _function_3);\n    format.operator_add(_append_2);\n    EList<XtendParameter> _parameters = func.getParameters();\n    this.formatMemberParameter(_parameters, open, close, format);\n    XExpression _expression = func.getExpression();\n    this.format(_expression, format);\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XtendFunction func, final FormattableDocument format) {\n    this.formatAnnotations(func, format, this._xtendFormatterConfigKeys.newLineAfterMethodAnnotations);\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(func, \"def\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    EList<JvmTypeParameter> _typeParameters = func.getTypeParameters();\n    boolean _isEmpty = _typeParameters.isEmpty();\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(func, \"<\");\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForKeyword_1, _function_1);\n      format.operator_add(_append_1);\n      EList<JvmTypeParameter> _typeParameters_1 = func.getTypeParameters();\n      for (final JvmTypeParameter arg : _typeParameters_1) {\n        {\n          this.format(arg, format);\n          ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(arg, \",\");\n          final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_2, _function_3);\n          format.operator_add(_surround);\n        }\n      }\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(func, \">\");\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.oneSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForKeyword_2, _function_2, _function_3);\n      format.operator_add(_surround);\n    }\n    final INode nameNode = this._nodeModelAccess.nodeForFeature(func, Literals.XTEND_FUNCTION__NAME);\n    final ILeafNode open = this._nodeModelAccess.immediatelyFollowingKeyword(nameNode, \"(\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(func, \")\");\n    INode _nodeForFeature = this._nodeModelAccess.nodeForFeature(func, Literals.XTEND_FUNCTION__RETURN_TYPE);\n    final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForFeature, _function_4);\n    format.operator_add(_append_2);\n    final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(open, _function_5);\n    format.operator_add(_prepend);\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(close, this._xtendFormatterConfigKeys.bracesInNewLine);\n    format.operator_add(_append_3);\n    EList<XtendParameter> _parameters = func.getParameters();\n    this.formatMemberParameter(_parameters, open, close, format);\n    JvmTypeReference _returnType = func.getReturnType();\n    this.format(_returnType, format);\n    XExpression _expression = func.getExpression();\n    this.format(_expression, format);\n  }","id":71716,"modified_method":"protected void _format(final XtendFunction func, final FormattableDocument format) {\n    this.formatAnnotations(func, format, this._xtendFormatterConfigKeys.newLineAfterMethodAnnotations);\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(func, \"def\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    EList<JvmTypeParameter> _typeParameters = func.getTypeParameters();\n    boolean _isEmpty = _typeParameters.isEmpty();\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(func, \"<\");\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForKeyword_1, _function_1);\n      format.operator_add(_append_1);\n      EList<JvmTypeParameter> _typeParameters_1 = func.getTypeParameters();\n      for (final JvmTypeParameter arg : _typeParameters_1) {\n        {\n          this.format(arg, format);\n          ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(arg, \",\");\n          final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_2, _function_3);\n          format.operator_add(_surround);\n        }\n      }\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(func, \">\");\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.oneSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForKeyword_2, _function_2, _function_3);\n      format.operator_add(_surround);\n    }\n    final INode nameNode = this._nodeModelAccess.nodeForFeature(func, Literals.XTEND_FUNCTION__NAME);\n    final ILeafNode open = this._nodeModelAccess.immediatelyFollowingKeyword(nameNode, \"(\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(func, \")\");\n    INode _nodeForFeature = this._nodeModelAccess.nodeForFeature(func, Literals.XTEND_FUNCTION__RETURN_TYPE);\n    final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForFeature, _function_4);\n    format.operator_add(_append_2);\n    final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(open, _function_5);\n    format.operator_add(_prepend);\n    final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(close, _function_6);\n    format.operator_add(_append_3);\n    EList<XtendParameter> _parameters = func.getParameters();\n    this.formatMemberParameter(_parameters, open, close, format);\n    JvmTypeReference _returnType = func.getReturnType();\n    this.format(_returnType, format);\n    XExpression _expression = func.getExpression();\n    this.format(_expression, format);\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XSwitchExpression expr, final FormattableDocument format) {\n    EList<XCasePart> _cases = expr.getCases();\n    final Function1<XCasePart,Boolean> _function = new Function1<XCasePart,Boolean>() {\n        public Boolean apply(final XCasePart it) {\n          XExpression _then = it.getThen();\n          return Boolean.valueOf((_then instanceof XBlockExpression));\n        }\n      };\n    final boolean containsBlockExpr = IterableExtensions.<XCasePart>exists(_cases, _function);\n    boolean _and = false;\n    boolean _not = (!containsBlockExpr);\n    if (!_not) {\n      _and = false;\n    } else {\n      INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(expr);\n      String _text = _nodeForEObject.getText();\n      String _trim = _text.trim();\n      boolean _contains = _trim.contains(\"\\n\");\n      boolean _not_1 = (!_contains);\n      _and = (_not && _not_1);\n    }\n    final boolean switchSL = _and;\n    boolean _and_1 = false;\n    boolean _not_2 = (!containsBlockExpr);\n    if (!_not_2) {\n      _and_1 = false;\n    } else {\n      EList<XCasePart> _cases_1 = expr.getCases();\n      final Function1<XCasePart,Boolean> _function_1 = new Function1<XCasePart,Boolean>() {\n          public Boolean apply(final XCasePart it) {\n            INode _nodeForEObject = XtendFormatter.this._nodeModelAccess.nodeForEObject(it);\n            String _text = _nodeForEObject.getText();\n            String _trim = _text.trim();\n            boolean _contains = _trim.contains(\"\\n\");\n            return Boolean.valueOf(_contains);\n          }\n        };\n      boolean _exists = IterableExtensions.<XCasePart>exists(_cases_1, _function_1);\n      boolean _not_3 = (!_exists);\n      _and_1 = (_not_2 && _not_3);\n    }\n    final boolean caseSL = _and_1;\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(expr, \"{\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(expr, \"}\");\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"switch\");\n    final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function_2);\n    format.operator_add(_append);\n    if (switchSL) {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(open, _function_3);\n      format.operator_add(_prepend);\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(open, _function_4);\n      format.operator_add(_append_1);\n      EList<XCasePart> _cases_2 = expr.getCases();\n      for (final XCasePart c : _cases_2) {\n        {\n          XExpression _then = c.getThen();\n          final INode cnode = this._nodeModelAccess.nodeForEObject(_then);\n          final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(cnode, _function_5);\n          format.operator_add(_prepend_1);\n          final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(cnode, _function_6);\n          format.operator_add(_append_2);\n        }\n      }\n    } else {\n      if (caseSL) {\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(open, this._xtendFormatterConfigKeys.bracesInNewLine);\n        format.operator_add(_prepend_1);\n        final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(open, _function_5);\n        format.operator_add(_append_2);\n        EList<XCasePart> _cases_3 = expr.getCases();\n        for (final XCasePart c_1 : _cases_3) {\n          {\n            XExpression _then = c_1.getThen();\n            INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(_then);\n            final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.space = \" \";\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(_nodeForEObject_1, _function_6);\n            format.operator_add(_prepend_2);\n            EList<XCasePart> _cases_4 = expr.getCases();\n            XCasePart _last = IterableExtensions.<XCasePart>last(_cases_4);\n            boolean _notEquals = (!Objects.equal(c_1, _last));\n            if (_notEquals) {\n              INode _nodeForEObject_2 = this._nodeModelAccess.nodeForEObject(c_1);\n              final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.newLine();\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_2, _function_7);\n              format.operator_add(_append_3);\n            }\n          }\n        }\n        final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(close, _function_6);\n        format.operator_add(_prepend_2);\n      } else {\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_3 = this._formatterExtensions.prepend(open, this._xtendFormatterConfigKeys.bracesInNewLine);\n        format.operator_add(_prepend_3);\n        final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(open, _function_7);\n        format.operator_add(_append_3);\n        EList<XCasePart> _cases_4 = expr.getCases();\n        for (final XCasePart c_2 : _cases_4) {\n          {\n            XExpression _then = c_2.getThen();\n            final INode cnode = this._nodeModelAccess.nodeForEObject(_then);\n            XExpression _then_1 = c_2.getThen();\n            if ((_then_1 instanceof XBlockExpression)) {\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_4 = this._formatterExtensions.prepend(cnode, this._xtendFormatterConfigKeys.bracesInNewLine);\n              format.operator_add(_prepend_4);\n              EList<XCasePart> _cases_5 = expr.getCases();\n              XCasePart _last = IterableExtensions.<XCasePart>last(_cases_5);\n              boolean _notEquals = (!Objects.equal(c_2, _last));\n              if (_notEquals) {\n                final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(cnode, _function_8);\n                format.operator_add(_append_4);\n              } else {\n                final Procedure1<FormattingDataInit> _function_9 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                      it.decreaseIndentation();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(cnode, _function_9);\n                format.operator_add(_append_5);\n              }\n            } else {\n              final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.newLine();\n                    it.increaseIndentation();\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_5 = this._formatterExtensions.prepend(cnode, _function_10);\n              format.operator_add(_prepend_5);\n              EList<XCasePart> _cases_6 = expr.getCases();\n              XCasePart _last_1 = IterableExtensions.<XCasePart>last(_cases_6);\n              boolean _notEquals_1 = (!Objects.equal(c_2, _last_1));\n              if (_notEquals_1) {\n                final Procedure1<FormattingDataInit> _function_11 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                      it.decreaseIndentation();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(cnode, _function_11);\n                format.operator_add(_append_6);\n              } else {\n                final Procedure1<FormattingDataInit> _function_12 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                      int _minus = (-2);\n                      it.indentationChange = _minus;\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(cnode, _function_12);\n                format.operator_add(_append_7);\n              }\n            }\n          }\n        }\n      }\n    }\n    EList<XCasePart> _cases_5 = expr.getCases();\n    for (final XCasePart c_3 : _cases_5) {\n      {\n        boolean _and_2 = false;\n        JvmTypeReference _typeGuard = c_3.getTypeGuard();\n        boolean _notEquals = (!Objects.equal(_typeGuard, null));\n        if (!_notEquals) {\n          _and_2 = false;\n        } else {\n          XExpression _case = c_3.getCase();\n          boolean _notEquals_1 = (!Objects.equal(_case, null));\n          _and_2 = (_notEquals && _notEquals_1);\n        }\n        if (_and_2) {\n          final INode typenode = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__TYPE_GUARD);\n          final INode casenode = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__CASE);\n          final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(typenode, _function_8);\n          format.operator_add(_append_4);\n          final Procedure1<FormattingDataInit> _function_9 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_4 = this._formatterExtensions.prepend(casenode, _function_9);\n          format.operator_add(_prepend_4);\n          final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(casenode, _function_10);\n          format.operator_add(_append_5);\n        } else {\n          JvmTypeReference _typeGuard_1 = c_3.getTypeGuard();\n          boolean _notEquals_2 = (!Objects.equal(_typeGuard_1, null));\n          if (_notEquals_2) {\n            final INode typenode_1 = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__TYPE_GUARD);\n            final Procedure1<FormattingDataInit> _function_11 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.noSpace();\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(typenode_1, _function_11);\n            format.operator_add(_append_6);\n          } else {\n            XExpression _case_1 = c_3.getCase();\n            boolean _notEquals_3 = (!Objects.equal(_case_1, null));\n            if (_notEquals_3) {\n              final INode casenode_1 = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__CASE);\n              final Procedure1<FormattingDataInit> _function_12 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.space = \" \";\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_5 = this._formatterExtensions.prepend(casenode_1, _function_12);\n              format.operator_add(_prepend_5);\n              final Procedure1<FormattingDataInit> _function_13 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.noSpace();\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(casenode_1, _function_13);\n              format.operator_add(_append_7);\n            }\n          }\n        }\n        XExpression _case_2 = c_3.getCase();\n        this.format(_case_2, format);\n        XExpression _then = c_3.getThen();\n        this.format(_then, format);\n      }\n    }\n  }","id":71717,"modified_method":"protected void _format(final XSwitchExpression expr, final FormattableDocument format) {\n    EList<XCasePart> _cases = expr.getCases();\n    final Function1<XCasePart,Boolean> _function = new Function1<XCasePart,Boolean>() {\n        public Boolean apply(final XCasePart it) {\n          XExpression _then = it.getThen();\n          return Boolean.valueOf((_then instanceof XBlockExpression));\n        }\n      };\n    final boolean containsBlockExpr = IterableExtensions.<XCasePart>exists(_cases, _function);\n    boolean _and = false;\n    boolean _not = (!containsBlockExpr);\n    if (!_not) {\n      _and = false;\n    } else {\n      INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(expr);\n      String _text = _nodeForEObject.getText();\n      String _trim = _text.trim();\n      boolean _contains = _trim.contains(\"\\n\");\n      boolean _not_1 = (!_contains);\n      _and = (_not && _not_1);\n    }\n    final boolean switchSL = _and;\n    boolean _and_1 = false;\n    boolean _not_2 = (!containsBlockExpr);\n    if (!_not_2) {\n      _and_1 = false;\n    } else {\n      EList<XCasePart> _cases_1 = expr.getCases();\n      final Function1<XCasePart,Boolean> _function_1 = new Function1<XCasePart,Boolean>() {\n          public Boolean apply(final XCasePart it) {\n            INode _nodeForEObject = XtendFormatter.this._nodeModelAccess.nodeForEObject(it);\n            String _text = _nodeForEObject.getText();\n            String _trim = _text.trim();\n            boolean _contains = _trim.contains(\"\\n\");\n            return Boolean.valueOf(_contains);\n          }\n        };\n      boolean _exists = IterableExtensions.<XCasePart>exists(_cases_1, _function_1);\n      boolean _not_3 = (!_exists);\n      _and_1 = (_not_2 && _not_3);\n    }\n    final boolean caseSL = _and_1;\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(expr, \"{\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(expr, \"}\");\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"switch\");\n    final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function_2);\n    format.operator_add(_append);\n    if (switchSL) {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(open, _function_3);\n      format.operator_add(_prepend);\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \" \";\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(open, _function_4);\n      format.operator_add(_append_1);\n      EList<XCasePart> _cases_2 = expr.getCases();\n      for (final XCasePart c : _cases_2) {\n        {\n          XExpression _then = c.getThen();\n          final INode cnode = this._nodeModelAccess.nodeForEObject(_then);\n          final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(cnode, _function_5);\n          format.operator_add(_prepend_1);\n          final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(cnode, _function_6);\n          format.operator_add(_append_2);\n        }\n      }\n    } else {\n      if (caseSL) {\n        final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(open, _function_5);\n        format.operator_add(_prepend_1);\n        final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(open, _function_6);\n        format.operator_add(_append_2);\n        EList<XCasePart> _cases_3 = expr.getCases();\n        for (final XCasePart c_1 : _cases_3) {\n          {\n            XExpression _then = c_1.getThen();\n            INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(_then);\n            final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.space = \" \";\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(_nodeForEObject_1, _function_7);\n            format.operator_add(_prepend_2);\n            EList<XCasePart> _cases_4 = expr.getCases();\n            XCasePart _last = IterableExtensions.<XCasePart>last(_cases_4);\n            boolean _notEquals = (!Objects.equal(c_1, _last));\n            if (_notEquals) {\n              INode _nodeForEObject_2 = this._nodeModelAccess.nodeForEObject(c_1);\n              final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.newLine();\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_2, _function_8);\n              format.operator_add(_append_3);\n            }\n          }\n        }\n        final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(close, _function_7);\n        format.operator_add(_prepend_2);\n      } else {\n        final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_3 = this._formatterExtensions.prepend(open, _function_8);\n        format.operator_add(_prepend_3);\n        final Procedure1<FormattingDataInit> _function_9 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(open, _function_9);\n        format.operator_add(_append_3);\n        EList<XCasePart> _cases_4 = expr.getCases();\n        for (final XCasePart c_2 : _cases_4) {\n          {\n            XExpression _then = c_2.getThen();\n            final INode cnode = this._nodeModelAccess.nodeForEObject(_then);\n            XExpression _then_1 = c_2.getThen();\n            if ((_then_1 instanceof XBlockExpression)) {\n              final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_4 = this._formatterExtensions.prepend(cnode, _function_10);\n              format.operator_add(_prepend_4);\n              EList<XCasePart> _cases_5 = expr.getCases();\n              XCasePart _last = IterableExtensions.<XCasePart>last(_cases_5);\n              boolean _notEquals = (!Objects.equal(c_2, _last));\n              if (_notEquals) {\n                final Procedure1<FormattingDataInit> _function_11 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(cnode, _function_11);\n                format.operator_add(_append_4);\n              } else {\n                final Procedure1<FormattingDataInit> _function_12 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                      it.decreaseIndentation();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(cnode, _function_12);\n                format.operator_add(_append_5);\n              }\n            } else {\n              final Procedure1<FormattingDataInit> _function_13 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.newLine();\n                    it.increaseIndentation();\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_5 = this._formatterExtensions.prepend(cnode, _function_13);\n              format.operator_add(_prepend_5);\n              EList<XCasePart> _cases_6 = expr.getCases();\n              XCasePart _last_1 = IterableExtensions.<XCasePart>last(_cases_6);\n              boolean _notEquals_1 = (!Objects.equal(c_2, _last_1));\n              if (_notEquals_1) {\n                final Procedure1<FormattingDataInit> _function_14 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                      it.decreaseIndentation();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(cnode, _function_14);\n                format.operator_add(_append_6);\n              } else {\n                final Procedure1<FormattingDataInit> _function_15 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.newLine();\n                      int _minus = (-2);\n                      it.indentationChange = _minus;\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(cnode, _function_15);\n                format.operator_add(_append_7);\n              }\n            }\n          }\n        }\n      }\n    }\n    EList<XCasePart> _cases_5 = expr.getCases();\n    for (final XCasePart c_3 : _cases_5) {\n      {\n        boolean _and_2 = false;\n        JvmTypeReference _typeGuard = c_3.getTypeGuard();\n        boolean _notEquals = (!Objects.equal(_typeGuard, null));\n        if (!_notEquals) {\n          _and_2 = false;\n        } else {\n          XExpression _case = c_3.getCase();\n          boolean _notEquals_1 = (!Objects.equal(_case, null));\n          _and_2 = (_notEquals && _notEquals_1);\n        }\n        if (_and_2) {\n          final INode typenode = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__TYPE_GUARD);\n          final INode casenode = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__CASE);\n          final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(typenode, _function_10);\n          format.operator_add(_append_4);\n          final Procedure1<FormattingDataInit> _function_11 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.space = \" \";\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_4 = this._formatterExtensions.prepend(casenode, _function_11);\n          format.operator_add(_prepend_4);\n          final Procedure1<FormattingDataInit> _function_12 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(casenode, _function_12);\n          format.operator_add(_append_5);\n        } else {\n          JvmTypeReference _typeGuard_1 = c_3.getTypeGuard();\n          boolean _notEquals_2 = (!Objects.equal(_typeGuard_1, null));\n          if (_notEquals_2) {\n            final INode typenode_1 = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__TYPE_GUARD);\n            final Procedure1<FormattingDataInit> _function_13 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.noSpace();\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(typenode_1, _function_13);\n            format.operator_add(_append_6);\n          } else {\n            XExpression _case_1 = c_3.getCase();\n            boolean _notEquals_3 = (!Objects.equal(_case_1, null));\n            if (_notEquals_3) {\n              final INode casenode_1 = this._nodeModelAccess.nodeForFeature(c_3, org.eclipse.xtext.xbase.XbasePackage.Literals.XCASE_PART__CASE);\n              final Procedure1<FormattingDataInit> _function_14 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.space = \" \";\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_5 = this._formatterExtensions.prepend(casenode_1, _function_14);\n              format.operator_add(_prepend_5);\n              final Procedure1<FormattingDataInit> _function_15 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.noSpace();\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(casenode_1, _function_15);\n              format.operator_add(_append_7);\n            }\n          }\n        }\n        XExpression _case_2 = c_3.getCase();\n        this.format(_case_2, format);\n        XExpression _then = c_3.getThen();\n        this.format(_then, format);\n      }\n    }\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XTryCatchFinallyExpression expr, final FormattableDocument format) {\n    XExpression _expression = expr.getExpression();\n    final INode body = this._nodeModelAccess.nodeForEObject(_expression);\n    XExpression _expression_1 = expr.getExpression();\n    if ((_expression_1 instanceof XBlockExpression)) {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_prepend);\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(body, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_append);\n    } else {\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, _function_1);\n      format.operator_add(_append_1);\n    }\n    XExpression _expression_2 = expr.getExpression();\n    this.format(_expression_2, format);\n    EList<XCatchClause> _catchClauses = expr.getCatchClauses();\n    for (final XCatchClause cc : _catchClauses) {\n      {\n        this.format(cc, format);\n        boolean _or = false;\n        EList<XCatchClause> _catchClauses_1 = expr.getCatchClauses();\n        XCatchClause _last = IterableExtensions.<XCatchClause>last(_catchClauses_1);\n        boolean _notEquals = (!Objects.equal(cc, _last));\n        if (_notEquals) {\n          _or = true;\n        } else {\n          XExpression _finallyExpression = expr.getFinallyExpression();\n          boolean _notEquals_1 = (!Objects.equal(_finallyExpression, null));\n          _or = (_notEquals || _notEquals_1);\n        }\n        if (_or) {\n          XExpression _expression_3 = cc.getExpression();\n          if ((_expression_3 instanceof XBlockExpression)) {\n            INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(cc);\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForEObject, this._xtendFormatterConfigKeys.bracesInNewLine);\n            format.operator_add(_append_2);\n          } else {\n            INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(cc);\n            final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.newLine();\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, _function_2);\n            format.operator_add(_append_3);\n          }\n        }\n      }\n    }\n    XExpression _finallyExpression = expr.getFinallyExpression();\n    boolean _notEquals = (!Objects.equal(_finallyExpression, null));\n    if (_notEquals) {\n      XExpression _finallyExpression_1 = expr.getFinallyExpression();\n      final INode fin = this._nodeModelAccess.nodeForEObject(_finallyExpression_1);\n      XExpression _finallyExpression_2 = expr.getFinallyExpression();\n      if ((_finallyExpression_2 instanceof XBlockExpression)) {\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(fin, this._xtendFormatterConfigKeys.bracesInNewLine);\n        format.operator_add(_prepend_2);\n      } else {\n        final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_3 = this._formatterExtensions.prepend(fin, _function_2);\n        format.operator_add(_prepend_3);\n        final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(fin, _function_3);\n        format.operator_add(_append_2);\n      }\n      XExpression _finallyExpression_3 = expr.getFinallyExpression();\n      this.format(_finallyExpression_3, format);\n    }\n  }","id":71718,"modified_method":"protected void _format(final XTryCatchFinallyExpression expr, final FormattableDocument format) {\n    XExpression _expression = expr.getExpression();\n    final INode body = this._nodeModelAccess.nodeForEObject(_expression);\n    XExpression _expression_1 = expr.getExpression();\n    if ((_expression_1 instanceof XBlockExpression)) {\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, _function);\n      format.operator_add(_prepend);\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(body, _function_1);\n      format.operator_add(_append);\n    } else {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function_2);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, _function_3);\n      format.operator_add(_append_1);\n    }\n    XExpression _expression_2 = expr.getExpression();\n    this.format(_expression_2, format);\n    EList<XCatchClause> _catchClauses = expr.getCatchClauses();\n    for (final XCatchClause cc : _catchClauses) {\n      {\n        this.format(cc, format);\n        boolean _or = false;\n        EList<XCatchClause> _catchClauses_1 = expr.getCatchClauses();\n        XCatchClause _last = IterableExtensions.<XCatchClause>last(_catchClauses_1);\n        boolean _notEquals = (!Objects.equal(cc, _last));\n        if (_notEquals) {\n          _or = true;\n        } else {\n          XExpression _finallyExpression = expr.getFinallyExpression();\n          boolean _notEquals_1 = (!Objects.equal(_finallyExpression, null));\n          _or = (_notEquals || _notEquals_1);\n        }\n        if (_or) {\n          XExpression _expression_3 = cc.getExpression();\n          if ((_expression_3 instanceof XBlockExpression)) {\n            INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(cc);\n            final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForEObject, _function_4);\n            format.operator_add(_append_2);\n          } else {\n            INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(cc);\n            final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.newLine();\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, _function_5);\n            format.operator_add(_append_3);\n          }\n        }\n      }\n    }\n    XExpression _finallyExpression = expr.getFinallyExpression();\n    boolean _notEquals = (!Objects.equal(_finallyExpression, null));\n    if (_notEquals) {\n      XExpression _finallyExpression_1 = expr.getFinallyExpression();\n      final INode fin = this._nodeModelAccess.nodeForEObject(_finallyExpression_1);\n      XExpression _finallyExpression_2 = expr.getFinallyExpression();\n      if ((_finallyExpression_2 instanceof XBlockExpression)) {\n        final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(fin, _function_4);\n        format.operator_add(_prepend_2);\n      } else {\n        final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_3 = this._formatterExtensions.prepend(fin, _function_5);\n        format.operator_add(_prepend_3);\n        final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(fin, _function_6);\n        format.operator_add(_append_2);\n      }\n      XExpression _finallyExpression_3 = expr.getFinallyExpression();\n      this.format(_finallyExpression_3, format);\n    }\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XCatchClause expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"catch\");\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n    format.operator_add(_append);\n    JvmFormalParameter _declaredParam = expr.getDeclaredParam();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_declaredParam);\n    final Procedure1<INode> _function = new Procedure1<INode>() {\n        public void apply(final INode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = XtendFormatter.this._formatterExtensions.prepend(it, _function);\n          format.operator_add(_prepend);\n          final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function_1);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<INode>operator_doubleArrow(_nodeForEObject, _function);\n    XExpression _expression = expr.getExpression();\n    final INode body = this._nodeModelAccess.nodeForEObject(_expression);\n    XExpression _expression_1 = expr.getExpression();\n    if ((_expression_1 instanceof XBlockExpression)) {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_prepend);\n    } else {\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function_1);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, _function_2);\n      format.operator_add(_append_1);\n    }\n    JvmFormalParameter _declaredParam_1 = expr.getDeclaredParam();\n    this.format(_declaredParam_1, format);\n    XExpression _expression_2 = expr.getExpression();\n    this.format(_expression_2, format);\n  }","id":71719,"modified_method":"protected void _format(final XCatchClause expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"catch\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    JvmFormalParameter _declaredParam = expr.getDeclaredParam();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_declaredParam);\n    final Procedure1<INode> _function_1 = new Procedure1<INode>() {\n        public void apply(final INode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = XtendFormatter.this._formatterExtensions.prepend(it, _function);\n          format.operator_add(_prepend);\n          final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function_1);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<INode>operator_doubleArrow(_nodeForEObject, _function_1);\n    XExpression _expression = expr.getExpression();\n    final INode body = this._nodeModelAccess.nodeForEObject(_expression);\n    XExpression _expression_1 = expr.getExpression();\n    if ((_expression_1 instanceof XBlockExpression)) {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, _function_2);\n      format.operator_add(_prepend);\n    } else {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function_3);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, _function_4);\n      format.operator_add(_append_1);\n    }\n    JvmFormalParameter _declaredParam_1 = expr.getDeclaredParam();\n    this.format(_declaredParam_1, format);\n    XExpression _expression_2 = expr.getExpression();\n    this.format(_expression_2, format);\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XBlockExpression expr, final FormattableDocument format) {\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(expr, \"{\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(expr, \"}\");\n    boolean _and = false;\n    boolean _notEquals = (!Objects.equal(open, null));\n    if (!_notEquals) {\n      _and = false;\n    } else {\n      boolean _notEquals_1 = (!Objects.equal(close, null));\n      _and = (_notEquals && _notEquals_1);\n    }\n    if (_and) {\n      EList<XExpression> _expressions = expr.getExpressions();\n      boolean _isEmpty = _expressions.isEmpty();\n      if (_isEmpty) {\n        final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(open, _function);\n        format.operator_add(_append);\n      } else {\n        final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(open, _function_1);\n        format.operator_add(_append_1);\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(open, this._xtendFormatterConfigKeys.blankLinesAroundExpression);\n        format.operator_add(_append_2);\n        EList<XExpression> _expressions_1 = expr.getExpressions();\n        for (final XExpression child : _expressions_1) {\n          {\n            this.format(child, format);\n            boolean _or = false;\n            EList<XExpression> _expressions_2 = expr.getExpressions();\n            XExpression _last = IterableExtensions.<XExpression>last(_expressions_2);\n            boolean _notEquals_2 = (!Objects.equal(child, _last));\n            if (_notEquals_2) {\n              _or = true;\n            } else {\n              boolean _notEquals_3 = (!Objects.equal(close, null));\n              _or = (_notEquals_2 || _notEquals_3);\n            }\n            if (_or) {\n              final INode childNode = this._nodeModelAccess.nodeForEObject(child);\n              final ILeafNode sem = this._nodeModelAccess.immediatelyFollowingKeyword(childNode, \";\");\n              boolean _notEquals_4 = (!Objects.equal(sem, null));\n              if (_notEquals_4) {\n                final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.noSpace();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(sem, _function_2);\n                format.operator_add(_prepend);\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(sem, this._xtendFormatterConfigKeys.blankLinesAroundExpression);\n                format.operator_add(_append_3);\n              } else {\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(childNode, this._xtendFormatterConfigKeys.blankLinesAroundExpression);\n                format.operator_add(_append_4);\n              }\n            }\n          }\n        }\n        final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(close, _function_2);\n        format.operator_add(_prepend);\n      }\n    }\n  }","id":71720,"modified_method":"protected void _format(final XBlockExpression expr, final FormattableDocument format) {\n    final ILeafNode open = this._nodeModelAccess.nodeForKeyword(expr, \"{\");\n    final ILeafNode close = this._nodeModelAccess.nodeForKeyword(expr, \"}\");\n    boolean _and = false;\n    boolean _notEquals = (!Objects.equal(open, null));\n    if (!_notEquals) {\n      _and = false;\n    } else {\n      boolean _notEquals_1 = (!Objects.equal(close, null));\n      _and = (_notEquals && _notEquals_1);\n    }\n    if (_and) {\n      EList<XExpression> _expressions = expr.getExpressions();\n      boolean _isEmpty = _expressions.isEmpty();\n      if (_isEmpty) {\n        final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(open, _function);\n        format.operator_add(_append);\n      } else {\n        final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesAroundExpression);\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(open, _function_1);\n        format.operator_add(_append_1);\n        EList<XExpression> _expressions_1 = expr.getExpressions();\n        for (final XExpression child : _expressions_1) {\n          {\n            this.format(child, format);\n            boolean _or = false;\n            EList<XExpression> _expressions_2 = expr.getExpressions();\n            XExpression _last = IterableExtensions.<XExpression>last(_expressions_2);\n            boolean _notEquals_2 = (!Objects.equal(child, _last));\n            if (_notEquals_2) {\n              _or = true;\n            } else {\n              boolean _notEquals_3 = (!Objects.equal(close, null));\n              _or = (_notEquals_2 || _notEquals_3);\n            }\n            if (_or) {\n              final INode childNode = this._nodeModelAccess.nodeForEObject(child);\n              final ILeafNode sem = this._nodeModelAccess.immediatelyFollowingKeyword(childNode, \";\");\n              boolean _notEquals_4 = (!Objects.equal(sem, null));\n              if (_notEquals_4) {\n                final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.noSpace();\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(sem, _function_2);\n                format.operator_add(_prepend);\n                final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesAroundExpression);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(sem, _function_3);\n                format.operator_add(_append_2);\n              } else {\n                final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesAroundExpression);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(childNode, _function_4);\n                format.operator_add(_append_3);\n              }\n            }\n          }\n        }\n        final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(close, _function_2);\n        format.operator_add(_prepend);\n      }\n    }\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XtendFile xtendFile, final FormattableDocument format) {\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(xtendFile);\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(_nodeForEObject, _function);\n    format.operator_add(_prepend);\n    final INode pkg = this._nodeModelAccess.nodeForFeature(xtendFile, Literals.XTEND_FILE__PACKAGE);\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(pkg, _function_1);\n    format.operator_add(_prepend_1);\n    final ILeafNode pkgSemicolon = this._nodeModelAccess.immediatelyFollowingKeyword(pkg, \";\");\n    boolean _notEquals = (!Objects.equal(pkgSemicolon, null));\n    if (_notEquals) {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \"\";\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(pkg, _function_2);\n      format.operator_add(_append);\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(pkgSemicolon, this._xtendFormatterConfigKeys.blankLinesAfterPackageDecl);\n      format.operator_add(_append_1);\n    } else {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(pkg, this._xtendFormatterConfigKeys.blankLinesAfterPackageDecl);\n      format.operator_add(_append_2);\n    }\n    EList<XtendImport> _imports = xtendFile.getImports();\n    for (final XtendImport imp : _imports) {\n      {\n        this.format(imp, format);\n        EList<XtendImport> _imports_1 = xtendFile.getImports();\n        XtendImport _last = IterableExtensions.<XtendImport>last(_imports_1);\n        boolean _notEquals_1 = (!Objects.equal(imp, _last));\n        if (_notEquals_1) {\n          INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(imp);\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, this._xtendFormatterConfigKeys.blankLinesBetweenImports);\n          format.operator_add(_append_3);\n        } else {\n          INode _nodeForEObject_2 = this._nodeModelAccess.nodeForEObject(imp);\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(_nodeForEObject_2, this._xtendFormatterConfigKeys.blankLinesAfterImports);\n          format.operator_add(_append_4);\n        }\n      }\n    }\n    EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n    for (final XtendTypeDeclaration clazz : _xtendTypes) {\n      {\n        this.format(clazz, format);\n        EList<XtendTypeDeclaration> _xtendTypes_1 = xtendFile.getXtendTypes();\n        XtendTypeDeclaration _last = IterableExtensions.<XtendTypeDeclaration>last(_xtendTypes_1);\n        boolean _notEquals_1 = (!Objects.equal(clazz, _last));\n        if (_notEquals_1) {\n          INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(clazz);\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, this._xtendFormatterConfigKeys.blankLinesBetweenClasses);\n          format.operator_add(_append_3);\n        }\n      }\n    }\n    INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(xtendFile);\n    final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.newLine();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, _function_3);\n    format.operator_add(_append_3);\n  }","id":71721,"modified_method":"protected void _format(final XtendFile xtendFile, final FormattableDocument format) {\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(xtendFile);\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(_nodeForEObject, _function);\n    format.operator_add(_prepend);\n    final INode pkg = this._nodeModelAccess.nodeForFeature(xtendFile, Literals.XTEND_FILE__PACKAGE);\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(pkg, _function_1);\n    format.operator_add(_prepend_1);\n    final ILeafNode pkgSemicolon = this._nodeModelAccess.immediatelyFollowingKeyword(pkg, \";\");\n    boolean _notEquals = (!Objects.equal(pkgSemicolon, null));\n    if (_notEquals) {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.space = \"\";\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(pkg, _function_2);\n      format.operator_add(_append);\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesAfterPackageDecl);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(pkgSemicolon, _function_3);\n      format.operator_add(_append_1);\n    } else {\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesAfterPackageDecl);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(pkg, _function_4);\n      format.operator_add(_append_2);\n    }\n    EList<XtendImport> _imports = xtendFile.getImports();\n    for (final XtendImport imp : _imports) {\n      {\n        this.format(imp, format);\n        EList<XtendImport> _imports_1 = xtendFile.getImports();\n        XtendImport _last = IterableExtensions.<XtendImport>last(_imports_1);\n        boolean _notEquals_1 = (!Objects.equal(imp, _last));\n        if (_notEquals_1) {\n          INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(imp);\n          final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesBetweenImports);\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, _function_5);\n          format.operator_add(_append_3);\n        } else {\n          INode _nodeForEObject_2 = this._nodeModelAccess.nodeForEObject(imp);\n          final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesAfterImports);\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(_nodeForEObject_2, _function_6);\n          format.operator_add(_append_4);\n        }\n      }\n    }\n    EList<XtendTypeDeclaration> _xtendTypes = xtendFile.getXtendTypes();\n    for (final XtendTypeDeclaration clazz : _xtendTypes) {\n      {\n        this.format(clazz, format);\n        EList<XtendTypeDeclaration> _xtendTypes_1 = xtendFile.getXtendTypes();\n        XtendTypeDeclaration _last = IterableExtensions.<XtendTypeDeclaration>last(_xtendTypes_1);\n        boolean _notEquals_1 = (!Objects.equal(clazz, _last));\n        if (_notEquals_1) {\n          INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(clazz);\n          final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesBetweenClasses);\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, _function_5);\n          format.operator_add(_append_3);\n        }\n      }\n    }\n    INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(xtendFile);\n    final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.newLine();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForEObject_1, _function_5);\n    format.operator_add(_append_3);\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XIfExpression expr, final FormattableDocument format) {\n    EObject _eContainer = expr.eContainer();\n    if ((_eContainer instanceof XVariableDeclaration)) {\n      ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"if\");\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n      format.operator_add(_append);\n      INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(expr);\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForEObject, _function_1);\n      format.operator_add(_append_1);\n    }\n    XExpression _then = expr.getThen();\n    final INode thennode = this._nodeModelAccess.nodeForEObject(_then);\n    XExpression _else = expr.getElse();\n    final INode elsenode = _else==null?(INode)null:this._nodeModelAccess.nodeForEObject(_else);\n    boolean _or = false;\n    boolean _or_1 = false;\n    String _text = thennode==null?(String)null:thennode.getText();\n    String _trim = _text==null?(String)null:_text.trim();\n    boolean _contains = _trim==null?false:_trim.contains(\"\\n\");\n    if (_contains) {\n      _or_1 = true;\n    } else {\n      HiddenLeafs _hiddenLeafsBefore = thennode==null?(HiddenLeafs)null:this._hiddenLeafAccess.getHiddenLeafsBefore(thennode);\n      Integer _newLines = _hiddenLeafsBefore==null?(Integer)null:_hiddenLeafsBefore.getNewLines();\n      boolean _greaterThan = ((_newLines).intValue() > 0);\n      _or_1 = (_contains || _greaterThan);\n    }\n    if (_or_1) {\n      _or = true;\n    } else {\n      String _text_1 = elsenode==null?(String)null:elsenode.getText();\n      String _trim_1 = _text_1==null?(String)null:_text_1.trim();\n      boolean _contains_1 = _trim_1==null?false:_trim_1.contains(\"\\n\");\n      _or = (_or_1 || _contains_1);\n    }\n    final boolean multiline = _or;\n    INode _nodeForFeature = this._nodeModelAccess.nodeForFeature(expr, org.eclipse.xtext.xbase.XbasePackage.Literals.XIF_EXPRESSION__IF);\n    final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForFeature, _function_2);\n    format.operator_add(_surround);\n    boolean _or_2 = false;\n    XExpression _then_1 = expr.getThen();\n    if ((_then_1 instanceof XBlockExpression)) {\n      _or_2 = true;\n    } else {\n      _or_2 = ((_then_1 instanceof XBlockExpression) || multiline);\n    }\n    if (_or_2) {\n      ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(expr, \"if\");\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForKeyword_1, this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n      format.operator_add(_append_2);\n    } else {\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(expr, \"if\");\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForKeyword_2, this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisSL);\n      format.operator_add(_append_3);\n    }\n    XExpression _then_2 = expr.getThen();\n    if ((_then_2 instanceof XBlockExpression)) {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(thennode, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_prepend);\n      XExpression _else_1 = expr.getElse();\n      boolean _notEquals = (!Objects.equal(_else_1, null));\n      if (_notEquals) {\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(thennode, this._xtendFormatterConfigKeys.bracesInNewLine);\n        format.operator_add(_append_4);\n      }\n    } else {\n      boolean _not = (!multiline);\n      if (_not) {\n        final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.oneSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(thennode, _function_3);\n        format.operator_add(_prepend_1);\n        XExpression _else_2 = expr.getElse();\n        boolean _notEquals_1 = (!Objects.equal(_else_2, null));\n        if (_notEquals_1) {\n          final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(thennode, _function_4);\n          format.operator_add(_append_5);\n        }\n      } else {\n        final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(thennode, _function_5);\n        format.operator_add(_prepend_2);\n        XExpression _else_3 = expr.getElse();\n        boolean _notEquals_2 = (!Objects.equal(_else_3, null));\n        if (_notEquals_2) {\n          final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.newLine();\n                it.decreaseIndentation();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(thennode, _function_6);\n          format.operator_add(_append_6);\n        } else {\n          final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.decreaseIndentation();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(thennode, _function_7);\n          format.operator_add(_append_7);\n        }\n      }\n    }\n    XExpression _else_4 = expr.getElse();\n    if ((_else_4 instanceof XBlockExpression)) {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_3 = this._formatterExtensions.prepend(elsenode, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_prepend_3);\n    } else {\n      boolean _or_3 = false;\n      XExpression _else_5 = expr.getElse();\n      if ((_else_5 instanceof XIfExpression)) {\n        _or_3 = true;\n      } else {\n        boolean _not_1 = (!multiline);\n        _or_3 = ((_else_5 instanceof XIfExpression) || _not_1);\n      }\n      if (_or_3) {\n        final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.oneSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_4 = this._formatterExtensions.prepend(elsenode, _function_8);\n        format.operator_add(_prepend_4);\n      } else {\n        final Procedure1<FormattingDataInit> _function_9 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_5 = this._formatterExtensions.prepend(elsenode, _function_9);\n        format.operator_add(_prepend_5);\n        final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_8 = this._formatterExtensions.append(elsenode, _function_10);\n        format.operator_add(_append_8);\n      }\n    }\n    XExpression _if = expr.getIf();\n    this.format(_if, format);\n    XExpression _then_3 = expr.getThen();\n    this.format(_then_3, format);\n    XExpression _else_6 = expr.getElse();\n    boolean _notEquals_3 = (!Objects.equal(_else_6, null));\n    if (_notEquals_3) {\n      XExpression _else_7 = expr.getElse();\n      this.format(_else_7, format);\n    }\n  }","id":71722,"modified_method":"protected void _format(final XIfExpression expr, final FormattableDocument format) {\n    EObject _eContainer = expr.eContainer();\n    if ((_eContainer instanceof XVariableDeclaration)) {\n      ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"if\");\n      final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n      format.operator_add(_append);\n      INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(expr);\n      final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForEObject, _function_1);\n      format.operator_add(_append_1);\n    }\n    XExpression _then = expr.getThen();\n    final INode thennode = this._nodeModelAccess.nodeForEObject(_then);\n    XExpression _else = expr.getElse();\n    final INode elsenode = _else==null?(INode)null:this._nodeModelAccess.nodeForEObject(_else);\n    boolean _or = false;\n    boolean _or_1 = false;\n    String _text = thennode==null?(String)null:thennode.getText();\n    String _trim = _text==null?(String)null:_text.trim();\n    boolean _contains = _trim==null?false:_trim.contains(\"\\n\");\n    if (_contains) {\n      _or_1 = true;\n    } else {\n      HiddenLeafs _hiddenLeafsBefore = thennode==null?(HiddenLeafs)null:this._hiddenLeafAccess.getHiddenLeafsBefore(thennode);\n      Integer _newLines = _hiddenLeafsBefore==null?(Integer)null:_hiddenLeafsBefore.getNewLines();\n      boolean _greaterThan = ((_newLines).intValue() > 0);\n      _or_1 = (_contains || _greaterThan);\n    }\n    if (_or_1) {\n      _or = true;\n    } else {\n      String _text_1 = elsenode==null?(String)null:elsenode.getText();\n      String _trim_1 = _text_1==null?(String)null:_text_1.trim();\n      boolean _contains_1 = _trim_1==null?false:_trim_1.contains(\"\\n\");\n      _or = (_or_1 || _contains_1);\n    }\n    final boolean multiline = _or;\n    INode _nodeForFeature = this._nodeModelAccess.nodeForFeature(expr, org.eclipse.xtext.xbase.XbasePackage.Literals.XIF_EXPRESSION__IF);\n    final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForFeature, _function_2);\n    format.operator_add(_surround);\n    boolean _or_2 = false;\n    XExpression _then_1 = expr.getThen();\n    if ((_then_1 instanceof XBlockExpression)) {\n      _or_2 = true;\n    } else {\n      _or_2 = ((_then_1 instanceof XBlockExpression) || multiline);\n    }\n    if (_or_2) {\n      ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(expr, \"if\");\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForKeyword_1, _function_3);\n      format.operator_add(_append_2);\n    } else {\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(expr, \"if\");\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisSL);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(_nodeForKeyword_2, _function_4);\n      format.operator_add(_append_3);\n    }\n    XExpression _then_2 = expr.getThen();\n    if ((_then_2 instanceof XBlockExpression)) {\n      final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(thennode, _function_5);\n      format.operator_add(_prepend);\n      XExpression _else_1 = expr.getElse();\n      boolean _notEquals = (!Objects.equal(_else_1, null));\n      if (_notEquals) {\n        final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(thennode, _function_6);\n        format.operator_add(_append_4);\n      }\n    } else {\n      boolean _not = (!multiline);\n      if (_not) {\n        final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.oneSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(thennode, _function_7);\n        format.operator_add(_prepend_1);\n        XExpression _else_2 = expr.getElse();\n        boolean _notEquals_1 = (!Objects.equal(_else_2, null));\n        if (_notEquals_1) {\n          final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(thennode, _function_8);\n          format.operator_add(_append_5);\n        }\n      } else {\n        final Procedure1<FormattingDataInit> _function_9 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_2 = this._formatterExtensions.prepend(thennode, _function_9);\n        format.operator_add(_prepend_2);\n        XExpression _else_3 = expr.getElse();\n        boolean _notEquals_2 = (!Objects.equal(_else_3, null));\n        if (_notEquals_2) {\n          final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.newLine();\n                it.decreaseIndentation();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(thennode, _function_10);\n          format.operator_add(_append_6);\n        } else {\n          final Procedure1<FormattingDataInit> _function_11 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.decreaseIndentation();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(thennode, _function_11);\n          format.operator_add(_append_7);\n        }\n      }\n    }\n    XExpression _else_4 = expr.getElse();\n    if ((_else_4 instanceof XBlockExpression)) {\n      final Procedure1<FormattingDataInit> _function_12 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_3 = this._formatterExtensions.prepend(elsenode, _function_12);\n      format.operator_add(_prepend_3);\n    } else {\n      boolean _or_3 = false;\n      XExpression _else_5 = expr.getElse();\n      if ((_else_5 instanceof XIfExpression)) {\n        _or_3 = true;\n      } else {\n        boolean _not_1 = (!multiline);\n        _or_3 = ((_else_5 instanceof XIfExpression) || _not_1);\n      }\n      if (_or_3) {\n        final Procedure1<FormattingDataInit> _function_13 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.oneSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_4 = this._formatterExtensions.prepend(elsenode, _function_13);\n        format.operator_add(_prepend_4);\n      } else {\n        final Procedure1<FormattingDataInit> _function_14 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.newLine();\n              it.increaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_5 = this._formatterExtensions.prepend(elsenode, _function_14);\n        format.operator_add(_prepend_5);\n        final Procedure1<FormattingDataInit> _function_15 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.decreaseIndentation();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_8 = this._formatterExtensions.append(elsenode, _function_15);\n        format.operator_add(_append_8);\n      }\n    }\n    XExpression _if = expr.getIf();\n    this.format(_if, format);\n    XExpression _then_3 = expr.getThen();\n    this.format(_then_3, format);\n    XExpression _else_6 = expr.getElse();\n    boolean _notEquals_3 = (!Objects.equal(_else_6, null));\n    if (_notEquals_3) {\n      XExpression _else_7 = expr.getElse();\n      this.format(_else_7, format);\n    }\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XForLoopExpression expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"for\");\n    final Procedure1<ILeafNode> _function = new Procedure1<ILeafNode>() {\n        public void apply(final ILeafNode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<ILeafNode>operator_doubleArrow(_nodeForKeyword, _function);\n    JvmFormalParameter _declaredParam = expr.getDeclaredParam();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_declaredParam);\n    final Procedure1<INode> _function_1 = new Procedure1<INode>() {\n        public void apply(final INode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = XtendFormatter.this._formatterExtensions.prepend(it, _function);\n          format.operator_add(_prepend);\n          final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function_1);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<INode>operator_doubleArrow(_nodeForEObject, _function_1);\n    XExpression _forExpression = expr.getForExpression();\n    INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(_forExpression);\n    final Procedure1<INode> _function_2 = new Procedure1<INode>() {\n        public void apply(final INode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = XtendFormatter.this._formatterExtensions.prepend(it, _function);\n          format.operator_add(_prepend);\n          final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function_1);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<INode>operator_doubleArrow(_nodeForEObject_1, _function_2);\n    XExpression _eachExpression = expr.getEachExpression();\n    final INode each = this._nodeModelAccess.nodeForEObject(_eachExpression);\n    XExpression _eachExpression_1 = expr.getEachExpression();\n    if ((_eachExpression_1 instanceof XBlockExpression)) {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(each, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_prepend);\n    } else {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(each, _function_3);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(each, _function_4);\n      format.operator_add(_append);\n    }\n    XExpression _forExpression_1 = expr.getForExpression();\n    this.format(_forExpression_1, format);\n    XExpression _eachExpression_2 = expr.getEachExpression();\n    this.format(_eachExpression_2, format);\n  }","id":71723,"modified_method":"protected void _format(final XForLoopExpression expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"for\");\n    final Procedure1<ILeafNode> _function = new Procedure1<ILeafNode>() {\n        public void apply(final ILeafNode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<ILeafNode>operator_doubleArrow(_nodeForKeyword, _function);\n    JvmFormalParameter _declaredParam = expr.getDeclaredParam();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_declaredParam);\n    final Procedure1<INode> _function_1 = new Procedure1<INode>() {\n        public void apply(final INode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = XtendFormatter.this._formatterExtensions.prepend(it, _function);\n          format.operator_add(_prepend);\n          final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function_1);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<INode>operator_doubleArrow(_nodeForEObject, _function_1);\n    XExpression _forExpression = expr.getForExpression();\n    INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(_forExpression);\n    final Procedure1<INode> _function_2 = new Procedure1<INode>() {\n        public void apply(final INode it) {\n          final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = XtendFormatter.this._formatterExtensions.prepend(it, _function);\n          format.operator_add(_prepend);\n          final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = XtendFormatter.this._formatterExtensions.append(it, _function_1);\n          format.operator_add(_append);\n        }\n      };\n    ObjectExtensions.<INode>operator_doubleArrow(_nodeForEObject_1, _function_2);\n    XExpression _eachExpression = expr.getEachExpression();\n    final INode each = this._nodeModelAccess.nodeForEObject(_eachExpression);\n    XExpression _eachExpression_1 = expr.getEachExpression();\n    if ((_eachExpression_1 instanceof XBlockExpression)) {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(each, _function_3);\n      format.operator_add(_prepend);\n    } else {\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(each, _function_4);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(each, _function_5);\n      format.operator_add(_append);\n    }\n    XExpression _forExpression_1 = expr.getForExpression();\n    this.format(_forExpression_1, format);\n    XExpression _eachExpression_2 = expr.getEachExpression();\n    this.format(_eachExpression_2, format);\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XDoWhileExpression expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"while\");\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n    format.operator_add(_append);\n    XExpression _predicate = expr.getPredicate();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_predicate);\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForEObject, _function, _function_1);\n    format.operator_add(_surround);\n    XExpression _body = expr.getBody();\n    final INode body = this._nodeModelAccess.nodeForEObject(_body);\n    XExpression _body_1 = expr.getBody();\n    if ((_body_1 instanceof XBlockExpression)) {\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_prepend);\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, this._xtendFormatterConfigKeys.bracesInNewLine);\n      format.operator_add(_append_1);\n    } else {\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function_2);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(body, _function_3);\n      format.operator_add(_append_2);\n    }\n    XExpression _predicate_1 = expr.getPredicate();\n    this.format(_predicate_1, format);\n    XExpression _body_2 = expr.getBody();\n    this.format(_body_2, format);\n  }","id":71724,"modified_method":"protected void _format(final XDoWhileExpression expr, final FormattableDocument format) {\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(expr, \"while\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.whitespaceBetweenKeywordAndParenthesisML);\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    XExpression _predicate = expr.getPredicate();\n    INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(_predicate);\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.noSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForEObject, _function_1, _function_2);\n    format.operator_add(_surround);\n    XExpression _body = expr.getBody();\n    final INode body = this._nodeModelAccess.nodeForEObject(_body);\n    XExpression _body_1 = expr.getBody();\n    if ((_body_1 instanceof XBlockExpression)) {\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(body, _function_3);\n      format.operator_add(_prepend);\n      final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(body, _function_4);\n      format.operator_add(_append_1);\n    } else {\n      final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(body, _function_5);\n      format.operator_add(_prepend_1);\n      final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n            it.decreaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(body, _function_6);\n      format.operator_add(_append_2);\n    }\n    XExpression _predicate_1 = expr.getPredicate();\n    this.format(_predicate_1, format);\n    XExpression _body_2 = expr.getBody();\n    this.format(_body_2, format);\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void _format(final XtendClass clazz, final FormattableDocument format) {\n    this.formatAnnotations(clazz, format, this._xtendFormatterConfigKeys.newLineAfterClassAnnotations);\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(clazz, \"public\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(clazz, \"abstract\");\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForKeyword_1, _function_1);\n    format.operator_add(_append_1);\n    EList<JvmTypeParameter> _typeParameters = clazz.getTypeParameters();\n    boolean _isEmpty = _typeParameters.isEmpty();\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(clazz, \"<\");\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForKeyword_2, _function_2);\n      format.operator_add(_surround);\n      EList<JvmTypeParameter> _typeParameters_1 = clazz.getTypeParameters();\n      for (final JvmTypeParameter arg : _typeParameters_1) {\n        {\n          this.format(arg, format);\n          ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(arg, \",\");\n          final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_1 = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_3, _function_4);\n          format.operator_add(_surround_1);\n        }\n      }\n      ILeafNode _nodeForKeyword_3 = this._nodeModelAccess.nodeForKeyword(clazz, \">\");\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(_nodeForKeyword_3, _function_3);\n      format.operator_add(_prepend);\n    }\n    ILeafNode _nodeForKeyword_4 = this._nodeModelAccess.nodeForKeyword(clazz, \"class\");\n    final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForKeyword_4, _function_4);\n    format.operator_add(_append_2);\n    ILeafNode _nodeForKeyword_5 = this._nodeModelAccess.nodeForKeyword(clazz, \"extends\");\n    final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_1 = this._formatterExtensions.surround(_nodeForKeyword_5, _function_5);\n    format.operator_add(_surround_1);\n    JvmTypeReference _extends = clazz.getExtends();\n    this.format(_extends, format);\n    ILeafNode _nodeForKeyword_6 = this._nodeModelAccess.nodeForKeyword(clazz, \"implements\");\n    final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_2 = this._formatterExtensions.surround(_nodeForKeyword_6, _function_6);\n    format.operator_add(_surround_2);\n    EList<JvmTypeReference> _implements = clazz.getImplements();\n    for (final JvmTypeReference imp : _implements) {\n      {\n        INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(imp);\n        ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(_nodeForEObject, \",\");\n        final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.noSpace();\n            }\n          };\n        final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.oneSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_3 = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_7, _function_8);\n        format.operator_add(_surround_3);\n        this.format(imp, format);\n      }\n    }\n    final ILeafNode clazzOpenBrace = this._nodeModelAccess.nodeForKeyword(clazz, \"{\");\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(clazzOpenBrace, this._xtendFormatterConfigKeys.bracesInNewLine);\n    format.operator_add(_prepend_1);\n    EList<XtendMember> _members = clazz.getMembers();\n    boolean _isEmpty_1 = _members.isEmpty();\n    boolean _not_1 = (!_isEmpty_1);\n    if (_not_1) {\n      final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(clazzOpenBrace, _function_7);\n      format.operator_add(_append_3);\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(clazzOpenBrace, this._xtendFormatterConfigKeys.blankLinesBeforeFirstMember);\n      format.operator_add(_append_4);\n      EList<XtendMember> _members_1 = clazz.getMembers();\n      int _size = _members_1.size();\n      int _minus = (_size - 1);\n      IntegerRange _upTo = new IntegerRange(0, _minus);\n      for (final Integer i : _upTo) {\n        {\n          EList<XtendMember> _members_2 = clazz.getMembers();\n          final XtendMember current = _members_2.get((i).intValue());\n          this.format(current, format);\n          EList<XtendMember> _members_3 = clazz.getMembers();\n          int _size_1 = _members_3.size();\n          int _minus_1 = (_size_1 - 1);\n          boolean _lessThan = ((i).intValue() < _minus_1);\n          if (_lessThan) {\n            EList<XtendMember> _members_4 = clazz.getMembers();\n            int _plus = ((i).intValue() + 1);\n            final XtendMember next = _members_4.get(_plus);\n            boolean _and = false;\n            if (!(current instanceof XtendField)) {\n              _and = false;\n            } else {\n              _and = ((current instanceof XtendField) && (next instanceof XtendField));\n            }\n            if (_and) {\n              INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(current);\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(_nodeForEObject, this._xtendFormatterConfigKeys.blankLinesBetweenFields);\n              format.operator_add(_append_5);\n            } else {\n              boolean _and_1 = false;\n              if (!(current instanceof XtendFunction)) {\n                _and_1 = false;\n              } else {\n                _and_1 = ((current instanceof XtendFunction) && (next instanceof XtendFunction));\n              }\n              if (_and_1) {\n                INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(current);\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(_nodeForEObject_1, this._xtendFormatterConfigKeys.blankLinesBetweenMethods);\n                format.operator_add(_append_6);\n              } else {\n                INode _nodeForEObject_2 = this._nodeModelAccess.nodeForEObject(current);\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(_nodeForEObject_2, this._xtendFormatterConfigKeys.blankLinesBetweenFieldsAndMethods);\n                format.operator_add(_append_7);\n              }\n            }\n          } else {\n            EList<XtendMember> _members_5 = clazz.getMembers();\n            XtendMember _get = _members_5.get((i).intValue());\n            final INode node = this._nodeModelAccess.nodeForEObject(_get);\n            final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.decreaseIndentation();\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_8 = this._formatterExtensions.append(node, _function_8);\n            format.operator_add(_append_8);\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_9 = this._formatterExtensions.append(node, this._xtendFormatterConfigKeys.blankLinesAfterLastMember);\n            format.operator_add(_append_9);\n          }\n        }\n      }\n    } else {\n      final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(clazzOpenBrace, _function_8);\n      format.operator_add(_append_5);\n    }\n  }","id":71725,"modified_method":"protected void _format(final XtendClass clazz, final FormattableDocument format) {\n    this.formatAnnotations(clazz, format, this._xtendFormatterConfigKeys.newLineAfterClassAnnotations);\n    ILeafNode _nodeForKeyword = this._nodeModelAccess.nodeForKeyword(clazz, \"public\");\n    final Procedure1<FormattingDataInit> _function = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append = this._formatterExtensions.append(_nodeForKeyword, _function);\n    format.operator_add(_append);\n    ILeafNode _nodeForKeyword_1 = this._nodeModelAccess.nodeForKeyword(clazz, \"abstract\");\n    final Procedure1<FormattingDataInit> _function_1 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_1 = this._formatterExtensions.append(_nodeForKeyword_1, _function_1);\n    format.operator_add(_append_1);\n    EList<JvmTypeParameter> _typeParameters = clazz.getTypeParameters();\n    boolean _isEmpty = _typeParameters.isEmpty();\n    boolean _not = (!_isEmpty);\n    if (_not) {\n      ILeafNode _nodeForKeyword_2 = this._nodeModelAccess.nodeForKeyword(clazz, \"<\");\n      final Procedure1<FormattingDataInit> _function_2 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround = this._formatterExtensions.surround(_nodeForKeyword_2, _function_2);\n      format.operator_add(_surround);\n      EList<JvmTypeParameter> _typeParameters_1 = clazz.getTypeParameters();\n      for (final JvmTypeParameter arg : _typeParameters_1) {\n        {\n          this.format(arg, format);\n          ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(arg, \",\");\n          final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.noSpace();\n              }\n            };\n          final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n              public void apply(final FormattingDataInit it) {\n                it.oneSpace();\n              }\n            };\n          Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_1 = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_3, _function_4);\n          format.operator_add(_surround_1);\n        }\n      }\n      ILeafNode _nodeForKeyword_3 = this._nodeModelAccess.nodeForKeyword(clazz, \">\");\n      final Procedure1<FormattingDataInit> _function_3 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.noSpace();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend = this._formatterExtensions.prepend(_nodeForKeyword_3, _function_3);\n      format.operator_add(_prepend);\n    }\n    ILeafNode _nodeForKeyword_4 = this._nodeModelAccess.nodeForKeyword(clazz, \"class\");\n    final Procedure1<FormattingDataInit> _function_4 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_2 = this._formatterExtensions.append(_nodeForKeyword_4, _function_4);\n    format.operator_add(_append_2);\n    ILeafNode _nodeForKeyword_5 = this._nodeModelAccess.nodeForKeyword(clazz, \"extends\");\n    final Procedure1<FormattingDataInit> _function_5 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_1 = this._formatterExtensions.surround(_nodeForKeyword_5, _function_5);\n    format.operator_add(_surround_1);\n    JvmTypeReference _extends = clazz.getExtends();\n    this.format(_extends, format);\n    ILeafNode _nodeForKeyword_6 = this._nodeModelAccess.nodeForKeyword(clazz, \"implements\");\n    final Procedure1<FormattingDataInit> _function_6 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.oneSpace();\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_2 = this._formatterExtensions.surround(_nodeForKeyword_6, _function_6);\n    format.operator_add(_surround_2);\n    EList<JvmTypeReference> _implements = clazz.getImplements();\n    for (final JvmTypeReference imp : _implements) {\n      {\n        INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(imp);\n        ILeafNode _immediatelyFollowingKeyword = this._nodeModelAccess.immediatelyFollowingKeyword(_nodeForEObject, \",\");\n        final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.noSpace();\n            }\n          };\n        final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n            public void apply(final FormattingDataInit it) {\n              it.oneSpace();\n            }\n          };\n        Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _surround_3 = this._formatterExtensions.surround(_immediatelyFollowingKeyword, _function_7, _function_8);\n        format.operator_add(_surround_3);\n        this.format(imp, format);\n      }\n    }\n    final ILeafNode clazzOpenBrace = this._nodeModelAccess.nodeForKeyword(clazz, \"{\");\n    final Procedure1<FormattingDataInit> _function_7 = new Procedure1<FormattingDataInit>() {\n        public void apply(final FormattingDataInit it) {\n          it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.bracesInNewLine);\n        }\n      };\n    Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _prepend_1 = this._formatterExtensions.prepend(clazzOpenBrace, _function_7);\n    format.operator_add(_prepend_1);\n    EList<XtendMember> _members = clazz.getMembers();\n    boolean _isEmpty_1 = _members.isEmpty();\n    boolean _not_1 = (!_isEmpty_1);\n    if (_not_1) {\n      final Procedure1<FormattingDataInit> _function_8 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.increaseIndentation();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_3 = this._formatterExtensions.append(clazzOpenBrace, _function_8);\n      format.operator_add(_append_3);\n      final Procedure1<FormattingDataInit> _function_9 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesBeforeFirstMember);\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_4 = this._formatterExtensions.append(clazzOpenBrace, _function_9);\n      format.operator_add(_append_4);\n      EList<XtendMember> _members_1 = clazz.getMembers();\n      int _size = _members_1.size();\n      int _minus = (_size - 1);\n      IntegerRange _upTo = new IntegerRange(0, _minus);\n      for (final Integer i : _upTo) {\n        {\n          EList<XtendMember> _members_2 = clazz.getMembers();\n          final XtendMember current = _members_2.get((i).intValue());\n          this.format(current, format);\n          EList<XtendMember> _members_3 = clazz.getMembers();\n          int _size_1 = _members_3.size();\n          int _minus_1 = (_size_1 - 1);\n          boolean _lessThan = ((i).intValue() < _minus_1);\n          if (_lessThan) {\n            EList<XtendMember> _members_4 = clazz.getMembers();\n            int _plus = ((i).intValue() + 1);\n            final XtendMember next = _members_4.get(_plus);\n            boolean _and = false;\n            if (!(current instanceof XtendField)) {\n              _and = false;\n            } else {\n              _and = ((current instanceof XtendField) && (next instanceof XtendField));\n            }\n            if (_and) {\n              INode _nodeForEObject = this._nodeModelAccess.nodeForEObject(current);\n              final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n                  public void apply(final FormattingDataInit it) {\n                    it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesBetweenFields);\n                  }\n                };\n              Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(_nodeForEObject, _function_10);\n              format.operator_add(_append_5);\n            } else {\n              boolean _and_1 = false;\n              if (!(current instanceof XtendFunction)) {\n                _and_1 = false;\n              } else {\n                _and_1 = ((current instanceof XtendFunction) && (next instanceof XtendFunction));\n              }\n              if (_and_1) {\n                INode _nodeForEObject_1 = this._nodeModelAccess.nodeForEObject(current);\n                final Procedure1<FormattingDataInit> _function_11 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesBetweenMethods);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_6 = this._formatterExtensions.append(_nodeForEObject_1, _function_11);\n                format.operator_add(_append_6);\n              } else {\n                INode _nodeForEObject_2 = this._nodeModelAccess.nodeForEObject(current);\n                final Procedure1<FormattingDataInit> _function_12 = new Procedure1<FormattingDataInit>() {\n                    public void apply(final FormattingDataInit it) {\n                      it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesBetweenFieldsAndMethods);\n                    }\n                  };\n                Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_7 = this._formatterExtensions.append(_nodeForEObject_2, _function_12);\n                format.operator_add(_append_7);\n              }\n            }\n          } else {\n            EList<XtendMember> _members_5 = clazz.getMembers();\n            XtendMember _get = _members_5.get((i).intValue());\n            final INode node = this._nodeModelAccess.nodeForEObject(_get);\n            final Procedure1<FormattingDataInit> _function_13 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.decreaseIndentation();\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_8 = this._formatterExtensions.append(node, _function_13);\n            format.operator_add(_append_8);\n            final Procedure1<FormattingDataInit> _function_14 = new Procedure1<FormattingDataInit>() {\n                public void apply(final FormattingDataInit it) {\n                  it.cfg(XtendFormatter.this._xtendFormatterConfigKeys.blankLinesAfterLastMember);\n                }\n              };\n            Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_9 = this._formatterExtensions.append(node, _function_14);\n            format.operator_add(_append_9);\n          }\n        }\n      }\n    } else {\n      final Procedure1<FormattingDataInit> _function_10 = new Procedure1<FormattingDataInit>() {\n          public void apply(final FormattingDataInit it) {\n            it.newLine();\n          }\n        };\n      Function1<? super FormattableDocument,? extends Iterable<FormattingData>> _append_5 = this._formatterExtensions.append(clazzOpenBrace, _function_10);\n      format.operator_add(_append_5);\n    }\n  }","commit_id":"0fb6bf3c71ed810cefec7e3d2c14c04e24f0a409","url":"https://github.com/eclipse/xtext"},{"original_method":"@Test\n  public void testInvalidReservedId() throws Exception {\n    HttpResponse response = createNamespace(METADATA_VALID, INVALID_ID);\n    assertResponseCode(400, response);\n    // 'default' and 'system' are reserved namespaces\n    response = createNamespace(METADATA_VALID, Constants.DEFAULT_NAMESPACE);\n    assertResponseCode(409, response);\n    response = createNamespace(METADATA_VALID, Constants.SYSTEM_NAMESPACE);\n    assertResponseCode(409, response);\n    response = deleteNamespace(Constants.DEFAULT_NAMESPACE);\n    assertResponseCode(403, response);\n    response = deleteNamespace(Constants.DEFAULT_NAMESPACE);\n    assertResponseCode(403, response);\n  }","id":71726,"modified_method":"@Test\n  public void testInvalidReservedId() throws Exception {\n    HttpResponse response = createNamespace(METADATA_VALID, INVALID_ID);\n    assertResponseCode(400, response);\n    // 'default' and 'system' are reserved namespaces\n    response = createNamespace(METADATA_VALID, Constants.DEFAULT_NAMESPACE);\n    assertResponseCode(400, response);\n    response = createNamespace(METADATA_VALID, Constants.SYSTEM_NAMESPACE);\n    assertResponseCode(400, response);\n    response = deleteNamespace(Constants.DEFAULT_NAMESPACE);\n    assertResponseCode(403, response);\n    response = deleteNamespace(Constants.SYSTEM_NAMESPACE);\n    assertResponseCode(403, response);\n  }","commit_id":"3fb3f0833393910eee4a4442a307843ad3a55696","url":"https://github.com/caskdata/cdap"},{"original_method":"@Test\n  public void testCreateDuplicate() throws Exception {\n    // prepare - create namespace\n    HttpResponse response = createNamespace(METADATA_VALID, ID);\n    assertResponseCode(200, response);\n    response = getNamespace(ID);\n    JsonObject namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(ID, namespace.get(ID_FIELD).getAsString());\n    Assert.assertEquals(DISPLAY_NAME, namespace.get(DISPLAY_NAME_FIELD).getAsString());\n    Assert.assertEquals(DESCRIPTION, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // create again with the same name\n    response = createNamespace(METADATA_EMPTY_DISPLAY_NAME, ID);\n    assertResponseCode(409, response);\n    // check that no updates happened\n    response = getNamespace(ID);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(ID, namespace.get(ID_FIELD).getAsString());\n    Assert.assertEquals(DISPLAY_NAME, namespace.get(DISPLAY_NAME_FIELD).getAsString());\n    Assert.assertEquals(DESCRIPTION, namespace.get(DESCRIPTION_FIELD).getAsString());\n    // cleanup\n    response = deleteNamespace(ID);\n    assertResponseCode(200, response);\n  }","id":71727,"modified_method":"@Test\n  public void testCreateDuplicate() throws Exception {\n    // prepare - create namespace\n    HttpResponse response = createNamespace(METADATA_VALID, ID);\n    assertResponseCode(200, response);\n    response = getNamespace(ID);\n    JsonObject namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(ID, namespace.get(ID_FIELD).getAsString());\n    Assert.assertEquals(DISPLAY_NAME, namespace.get(DISPLAY_NAME_FIELD).getAsString());\n    Assert.assertEquals(DESCRIPTION, namespace.get(DESCRIPTION_FIELD).getAsString());\n\n    // create again with the same name\n    response = createNamespace(METADATA_EMPTY_DISPLAY_NAME, ID);\n    // create is idempotent, so response code is 200, but no updates should happen\n    assertResponseCode(200, response);\n    // check that no updates happened\n    response = getNamespace(ID);\n    namespace = readGetResponse(response);\n    Assert.assertNotNull(namespace);\n    Assert.assertEquals(ID, namespace.get(ID_FIELD).getAsString());\n    Assert.assertEquals(DISPLAY_NAME, namespace.get(DISPLAY_NAME_FIELD).getAsString());\n    Assert.assertEquals(DESCRIPTION, namespace.get(DESCRIPTION_FIELD).getAsString());\n    // cleanup\n    response = deleteNamespace(ID);\n    assertResponseCode(200, response);\n  }","commit_id":"3fb3f0833393910eee4a4442a307843ad3a55696","url":"https://github.com/caskdata/cdap"},{"original_method":"public List<NamespaceMeta> list() throws IOException, UnauthorizedException {\n    HttpRequest request = HttpRequest.get(resolve(\"namespaces\")).build();\n    HttpResponse response = execute(request);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return ObjectResponse.fromJsonBody(response, new TypeToken<List<NamespaceMeta>>() { })\n        .getResponseObject();\n    }\n    throw new IOException(\"Cannot list namespaces. Reason: \" + \"getDetails(response)\");\n  }","id":71728,"modified_method":"public List<NamespaceMeta> list() throws IOException, UnauthorizedException {\n    HttpRequest request = HttpRequest.get(resolve(\"namespaces\")).build();\n    HttpResponse response = execute(request);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return ObjectResponse.fromJsonBody(response, new TypeToken<List<NamespaceMeta>>() { })\n        .getResponseObject();\n    }\n    throw new IOException(String.format(\"Cannot list namespaces. Reason: %s\", response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public NamespaceMeta get(String namespaceId) throws NamespaceNotFoundException, IOException, UnauthorizedException {\n    Id.Namespace namespace = Id.Namespace.from(namespaceId);\n    HttpResponse response = execute(HttpRequest.get(resolve(String.format(\"namespaces/%s\", namespaceId))).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NamespaceNotFoundException(namespace);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return ObjectResponse.fromJsonBody(response, NamespaceMeta.class).getResponseObject();\n    }\n    throw new IOException(\"Cannot get namespace. Reason: \" + \"getDetails(response)\");\n  }","id":71729,"modified_method":"public NamespaceMeta get(String namespaceId) throws NamespaceNotFoundException, IOException, UnauthorizedException {\n    Id.Namespace namespace = Id.Namespace.from(namespaceId);\n    HttpResponse response = execute(HttpRequest.get(resolve(String.format(\"namespaces/%s\", namespaceId))).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NamespaceNotFoundException(namespace);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return ObjectResponse.fromJsonBody(response, NamespaceMeta.class).getResponseObject();\n    }\n    throw new IOException(\"Cannot get namespace. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void delete(String namespaceId)\n    throws NamespaceNotFoundException, NamespaceCannotBeDeletedException, IOException, UnauthorizedException {\n\n    Id.Namespace namespace = Id.Namespace.from(namespaceId);\n    URL url = resolve(String.format(\"unrecoverable/namespaces/%s\", namespaceId));\n    HttpResponse response = execute(HttpRequest.delete(url).build());\n\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NamespaceNotFoundException(namespace);\n    } else if (HttpURLConnection.HTTP_FORBIDDEN == response.getResponseCode()) {\n      throw new NamespaceCannotBeDeletedException(namespace);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return;\n    }\n    throw new IOException(\"Cannot delete namespace. Reason: \" + \"getDetails(response)\");\n  }","id":71730,"modified_method":"public void delete(String namespaceId)\n    throws NamespaceNotFoundException, NamespaceCannotBeDeletedException, IOException, UnauthorizedException {\n\n    Id.Namespace namespace = Id.Namespace.from(namespaceId);\n    URL url = resolve(String.format(\"unrecoverable/namespaces/%s\", namespaceId));\n    HttpResponse response = execute(HttpRequest.delete(url).build());\n\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NamespaceNotFoundException(namespace);\n    } else if (HttpURLConnection.HTTP_FORBIDDEN == response.getResponseCode()) {\n      throw new NamespaceCannotBeDeletedException(namespace, response.getResponseBodyAsString());\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return;\n    }\n    throw new IOException(\"Cannot delete namespace. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void create(NamespaceMeta namespaceMeta)\n    throws NamespaceAlreadyExistsException, BadRequestException, IOException, UnauthorizedException,\n    NamespaceCannotBeCreatedException {\n\n    Id.Namespace namespace = Id.Namespace.from(namespaceMeta.getName());\n    URL url = resolve(String.format(\"namespaces/%s\", namespace.getId()));\n    HttpResponse response = execute(HttpRequest.put(url).withBody(new Gson().toJson(namespaceMeta)).build());\n    String responseBody = response.getResponseBodyAsString();\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      if (responseBody != null && responseBody.equals(String.format(\"Namespace '%s' already exists.\",\n                                                                    namespaceMeta.getName()))) {\n        throw new NamespaceAlreadyExistsException(namespace);\n      }\n      return;\n    }\n    if (response.getResponseCode() == HttpURLConnection.HTTP_BAD_REQUEST) {\n      throw new BadRequestException(\"Bad request: \" + responseBody);\n    }\n    throw new IOException(\"Cannot get create namespace. Reason: \" + \"getDetails(response)\");\n  }","id":71731,"modified_method":"public void create(NamespaceMeta namespaceMeta)\n    throws NamespaceAlreadyExistsException, BadRequestException, IOException, UnauthorizedException,\n    NamespaceCannotBeCreatedException {\n\n    Id.Namespace namespace = Id.Namespace.from(namespaceMeta.getName());\n    URL url = resolve(String.format(\"namespaces/%s\", namespace.getId()));\n    HttpResponse response = execute(HttpRequest.put(url).withBody(GSON.toJson(namespaceMeta)).build());\n    String responseBody = response.getResponseBodyAsString();\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      if (responseBody != null && responseBody.equals(String.format(\"Namespace '%s' already exists.\",\n                                                                    namespaceMeta.getName()))) {\n        throw new NamespaceAlreadyExistsException(namespace);\n      }\n      return;\n    }\n    if (response.getResponseCode() == HttpURLConnection.HTTP_BAD_REQUEST) {\n      throw new BadRequestException(\"Bad request: \" + responseBody);\n    }\n    throw new IOException(String.format(\"Cannot create namespace %s. Reason: %s\", namespaceMeta.getName(), response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public CannotBeDeletedException(Id id, Throwable cause) {\n    super(String.format(\"'%s' could not be deleted. Reason: %s\", id.getIdRep(), cause.getMessage()), cause);\n    this.objectId = id;\n  }","id":71732,"modified_method":"public CannotBeDeletedException(Id id, Throwable cause) {\n    super(String.format(\"'%s' could not be deleted. Reason: %s\", id.getIdRep(), cause.getMessage()), cause);\n    this.objectId = id;\n    this.reason = cause.getMessage();\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public CannotBeDeletedException(Id id) {\n    super(String.format(\"'%s' could not be deleted\", id.getIdRep()));\n    this.objectId = id;\n  }","id":71733,"modified_method":"public CannotBeDeletedException(Id id) {\n    super(String.format(\"'%s' could not be deleted\", id.getIdRep()));\n    this.objectId = id;\n    this.reason = null;\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public CannotBeDeletedException(Id id, String reason) {\n    super(String.format(\"'%s' could not be deleted. Reason: %s\", id.getIdRep(), reason));\n    this.objectId = id;\n  }","id":71734,"modified_method":"public CannotBeDeletedException(Id id, String reason) {\n    super(String.format(\"'%s' could not be deleted. Reason: %s\", id.getIdRep(), reason));\n    this.objectId = id;\n    this.reason = reason;\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void addInstance(String datasetInstanceName, String datasetType, DatasetProperties props)\n    throws DatasetManagementException {\n    DatasetInstanceConfiguration creationProperties = new DatasetInstanceConfiguration(datasetType,\n                                                                                       props.getProperties());\n\n    HttpResponse response = doPut(\"datasets/\" + datasetInstanceName, GSON.toJson(creationProperties));\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new InstanceConflictException(String.format(\"Failed to add instance %s due to conflict, details: %s\",\n                                                         datasetInstanceName, getDetails(response)));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to add instance %s, details: %s\",\n                                                          datasetInstanceName, getDetails(response)));\n    }\n  }","id":71735,"modified_method":"public void addInstance(String datasetInstanceName, String datasetType, DatasetProperties props)\n    throws DatasetManagementException {\n    DatasetInstanceConfiguration creationProperties = new DatasetInstanceConfiguration(datasetType,\n                                                                                       props.getProperties());\n\n    HttpResponse response = doPut(\"datasets/\" + datasetInstanceName, GSON.toJson(creationProperties));\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new InstanceConflictException(String.format(\"Failed to add instance %s due to conflict, details: %s\",\n                                                         datasetInstanceName, response));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to add instance %s, details: %s\",\n                                                          datasetInstanceName, response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public Collection<DatasetModuleMeta> getAllModules() throws DatasetManagementException {\n    HttpResponse response = doGet(\"modules\");\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve all dataset instances, details: %s\",\n                                                         getDetails(response)));\n    }\n\n    return GSON.fromJson(new String(response.getResponseBody(), Charsets.UTF_8), MODULE_META_LIST_TYPE);\n  }","id":71736,"modified_method":"public Collection<DatasetModuleMeta> getAllModules() throws DatasetManagementException {\n    HttpResponse response = doGet(\"modules\");\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve all dataset instances, details: %s\",\n                                                         response));\n    }\n\n    return GSON.fromJson(response.getResponseBodyAsString(), MODULE_META_LIST_TYPE);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void updateInstance(String datasetInstanceName, DatasetProperties props)\n    throws DatasetManagementException {\n\n    HttpResponse response = doPut(\"datasets/\" + datasetInstanceName + \"/properties\",\n                                  GSON.toJson(props.getProperties()));\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new InstanceConflictException(String.format(\"Failed to add instance %s due to conflict, details: %s\",\n                                                        datasetInstanceName, getDetails(response)));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to add instance %s, details: %s\",\n                                                         datasetInstanceName, getDetails(response)));\n    }\n  }","id":71737,"modified_method":"public void updateInstance(String datasetInstanceName, DatasetProperties props)\n    throws DatasetManagementException {\n\n    HttpResponse response = doPut(\"datasets/\" + datasetInstanceName + \"/properties\",\n                                  GSON.toJson(props.getProperties()));\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new InstanceConflictException(String.format(\"Failed to add instance %s due to conflict, details: %s\",\n                                                        datasetInstanceName, response));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to add instance %s, details: %s\",\n                                                         datasetInstanceName, response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Nullable\n  public DatasetMeta getInstance(String instanceName,\n                                 @Nullable Iterable<? extends Id> owners) throws DatasetManagementException {\n\n    String query = \"\";\n    if (owners != null) {\n      Set<String> ownerParams = Sets.newHashSet();\n      for (Id owner : owners) {\n        ownerParams.add(\"owner=\" + owner.getIdType() + \"::\" + owner.getIdRep());\n      }\n      query = ownerParams.isEmpty() ? \"\" : \"?\" + Joiner.on(\"&\").join(ownerParams);\n    }\n\n    HttpResponse response = doGet(\"datasets/\" + instanceName + query);\n    if (HttpResponseStatus.NOT_FOUND.getCode() == response.getResponseCode()) {\n      return null;\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve dataset instance %s info, details: %s\",\n                                                         instanceName, getDetails(response)));\n    }\n\n    return GSON.fromJson(new String(response.getResponseBody(), Charsets.UTF_8), DatasetMeta.class);\n  }","id":71738,"modified_method":"@Nullable\n  public DatasetMeta getInstance(String instanceName,\n                                 @Nullable Iterable<? extends Id> owners) throws DatasetManagementException {\n\n    String query = \"\";\n    if (owners != null) {\n      Set<String> ownerParams = Sets.newHashSet();\n      for (Id owner : owners) {\n        ownerParams.add(\"owner=\" + owner.getIdType() + \"::\" + owner.getIdRep());\n      }\n      query = ownerParams.isEmpty() ? \"\" : \"?\" + Joiner.on(\"&\").join(ownerParams);\n    }\n\n    HttpResponse response = doGet(\"datasets/\" + instanceName + query);\n    if (HttpResponseStatus.NOT_FOUND.getCode() == response.getResponseCode()) {\n      return null;\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve dataset instance %s info, details: %s\",\n                                                         instanceName, response));\n    }\n\n    return GSON.fromJson(response.getResponseBodyAsString(), DatasetMeta.class);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void deleteModule(String moduleName) throws DatasetManagementException {\n    HttpResponse response = doDelete(\"modules/\" + moduleName);\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new ModuleConflictException(String.format(\"Failed to delete module %s due to conflict, details: %s\",\n                                                      moduleName, getDetails(response)));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete module %s, details: %s\",\n                                                         moduleName, getDetails(response)));\n    }\n  }","id":71739,"modified_method":"public void deleteModule(String moduleName) throws DatasetManagementException {\n    HttpResponse response = doDelete(\"modules/\" + moduleName);\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new ModuleConflictException(String.format(\"Failed to delete module %s due to conflict, details: %s\",\n                                                      moduleName, response));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete module %s, details: %s\",\n                                                         moduleName, response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void deleteModules() throws DatasetManagementException {\n    HttpResponse response = doDelete(\"modules\");\n\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete modules, details: %s\",\n                                                         getDetails(response)));\n    }\n  }","id":71740,"modified_method":"public void deleteModules() throws DatasetManagementException {\n    HttpResponse response = doDelete(\"modules\");\n\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete modules, details: %s\", response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void createNamespace() throws DatasetManagementException {\n    HttpResponse response = doPut(\"admin/create\", GSON.toJson(namespaceId));\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to create namespace, details: %s\",\n                                                         getDetails(response)));\n    }\n  }","id":71741,"modified_method":"public void createNamespace() throws DatasetManagementException {\n    HttpResponse response = doPut(\"admin/create\", GSON.toJson(namespaceId));\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to create namespace, details: %s\", response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public DatasetTypeMeta getType(String typeName) throws DatasetManagementException {\n    HttpResponse response = doGet(\"types/\" + typeName);\n    if (HttpResponseStatus.NOT_FOUND.getCode() == response.getResponseCode()) {\n      return null;\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve dataset type %s info, details: %s\",\n                                                         typeName, getDetails(response)));\n    }\n    return GSON.fromJson(new String(response.getResponseBody(), Charsets.UTF_8), DatasetTypeMeta.class);\n  }","id":71742,"modified_method":"public DatasetTypeMeta getType(String typeName) throws DatasetManagementException {\n    HttpResponse response = doGet(\"types/\" + typeName);\n    if (HttpResponseStatus.NOT_FOUND.getCode() == response.getResponseCode()) {\n      return null;\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve dataset type %s info, details: %s\",\n                                                         typeName, response));\n    }\n    return GSON.fromJson(response.getResponseBodyAsString(), DatasetTypeMeta.class);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void deleteInstance(String datasetInstanceName) throws DatasetManagementException {\n    HttpResponse response = doDelete(\"datasets/\" + datasetInstanceName);\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new InstanceConflictException(String.format(\"Failed to delete instance %s due to conflict, details: %s\",\n                                                        datasetInstanceName, getDetails(response)));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete instance %s, details: %s\",\n                                                         datasetInstanceName, getDetails(response)));\n    }\n  }","id":71743,"modified_method":"public void deleteInstance(String datasetInstanceName) throws DatasetManagementException {\n    HttpResponse response = doDelete(\"datasets/\" + datasetInstanceName);\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new InstanceConflictException(String.format(\"Failed to delete instance %s due to conflict, details: %s\",\n                                                        datasetInstanceName, response));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete instance %s, details: %s\",\n                                                         datasetInstanceName, response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void addModule(String moduleName, String className, Location jarLocation)\n    throws DatasetManagementException {\n\n    HttpResponse response = doRequest(HttpMethod.PUT, \"modules/\" + moduleName,\n                                      ImmutableMultimap.of(\"X-Class-Name\", className),\n                                      Locations.newInputSupplier(jarLocation));\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new ModuleConflictException(String.format(\"Failed to add module %s due to conflict, details: %s\",\n                                                      moduleName, getDetails(response)));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to add module %s, details: %s\",\n                                                         moduleName, getDetails(response)));\n    }\n  }","id":71744,"modified_method":"public void addModule(String moduleName, String className, Location jarLocation)\n    throws DatasetManagementException {\n\n    HttpResponse response = doRequest(HttpMethod.PUT, \"modules/\" + moduleName,\n                                      ImmutableMultimap.of(\"X-Class-Name\", className),\n                                      Locations.newInputSupplier(jarLocation));\n\n    if (HttpResponseStatus.CONFLICT.getCode() == response.getResponseCode()) {\n      throw new ModuleConflictException(String.format(\"Failed to add module %s due to conflict, details: %s\",\n                                                      moduleName, response));\n    }\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to add module %s, details: %s\", moduleName, response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public Collection<DatasetSpecificationSummary> getAllInstances() throws DatasetManagementException {\n    HttpResponse response = doGet(\"datasets\");\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve all dataset instances, details: %s\",\n                                                         getDetails(response)));\n    }\n\n    return GSON.fromJson(new String(response.getResponseBody(), Charsets.UTF_8), SUMMARY_LIST_TYPE);\n  }","id":71745,"modified_method":"public Collection<DatasetSpecificationSummary> getAllInstances() throws DatasetManagementException {\n    HttpResponse response = doGet(\"datasets\");\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Cannot retrieve all dataset instances, details: %s\",\n                                                         response));\n    }\n\n    return GSON.fromJson(response.getResponseBodyAsString(), SUMMARY_LIST_TYPE);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public void deleteNamespace() throws DatasetManagementException {\n    HttpResponse response = doDelete(\"admin/delete\");\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete namespace, details: %s\",\n                                                         getDetails(response)));\n    }\n  }","id":71746,"modified_method":"public void deleteNamespace() throws DatasetManagementException {\n    HttpResponse response = doDelete(\"admin/delete\");\n    if (HttpResponseStatus.OK.getCode() != response.getResponseCode()) {\n      throw new DatasetManagementException(String.format(\"Failed to delete namespace, details: %s\", response));\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public synchronized void deleteDatasets(Id.Namespace namespaceId)\n    throws NamespaceNotFoundException, NamespaceCannotBeDeletedException {\n    // TODO: CDAP-870, CDAP-1427: Delete should be in a single transaction.\n    if (!hasNamespace(namespaceId)) {\n      throw new NamespaceNotFoundException(namespaceId);\n    }\n\n    if (checkProgramsRunning(namespaceId)) {\n      throw new NamespaceCannotBeDeletedException(namespaceId,\n                                                  \"Some programs are currently running in namespace \" + namespaceId);\n    }\n\n    LOG.info(\"Deleting data in namespace '{}'.\", namespaceId);\n    try {\n      dsFramework.deleteAllInstances(namespaceId);\n    } catch (DatasetManagementException e) {\n      LOG.warn(\"Error while deleting data in namespace {}\", namespaceId, e);\n      throw new NamespaceCannotBeDeletedException(namespaceId, e);\n    } catch (IOException e) {\n      LOG.warn(\"Error while deleting data in namespace {}\", namespaceId, e);\n      throw new NamespaceCannotBeDeletedException(namespaceId, e);\n    }\n    LOG.info(\"Deleted data in namespace '{}'.\", namespaceId);\n  }","id":71747,"modified_method":"@Override\n  public synchronized void deleteDatasets(Id.Namespace namespaceId)\n    throws NamespaceNotFoundException, NamespaceCannotBeDeletedException {\n    // TODO: CDAP-870, CDAP-1427: Delete should be in a single transaction.\n    if (!hasNamespace(namespaceId)) {\n      throw new NamespaceNotFoundException(namespaceId);\n    }\n\n    if (checkProgramsRunning(namespaceId)) {\n      throw new NamespaceCannotBeDeletedException(namespaceId,\n                                                  String.format(\"Some programs are currently running in namespace \" +\n                                                                  \"'%s', please stop them before deleting datasets \" +\n                                                                  \"in the namespace.\",\n                                                                namespaceId));\n    }\n\n    try {\n      dsFramework.deleteAllInstances(namespaceId);\n    } catch (DatasetManagementException | IOException e) {\n      LOG.warn(\"Error while deleting datasets in namespace {}\", namespaceId, e);\n      throw new NamespaceCannotBeDeletedException(namespaceId, e);\n    }\n    LOG.debug(\"Deleted datasets in namespace '{}'.\", namespaceId);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<QueryResult> previewResults(QueryHandle handle)\n    throws ExploreException, HandleNotFoundException, SQLException {\n    HttpResponse response = doPost(String.format(\"data/explore/queries/%s/%s\",\n                                                 handle.getHandle(), \"preview\"),\n                                   null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, ROW_LIST_TYPE);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get results preview. Reason: \" + getDetails(response));\n  }","id":71748,"modified_method":"@Override\n  public List<QueryResult> previewResults(QueryHandle handle)\n    throws ExploreException, HandleNotFoundException, SQLException {\n    HttpResponse response = doPost(String.format(\"data/explore/queries/%s/%s\",\n                                                 handle.getHandle(), \"preview\"),\n                                   null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, ROW_LIST_TYPE);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get results preview. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public TableInfo getTableInfo(@Nullable String database, String table)\n    throws ExploreException, TableNotFoundException {\n    HttpResponse response = doGet(String.format(\"namespaces/%s/data/explore/tables/%s/info\", database, table));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, TableInfo.class);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new TableNotFoundException(\"Table \" + database + table + \" not found.\");\n    }\n    throw new ExploreException(\"Cannot get the schema of table \" + database + table +\n                               \". Reason: \" + getDetails(response));\n  }","id":71749,"modified_method":"@Override\n  public TableInfo getTableInfo(@Nullable String database, String table)\n    throws ExploreException, TableNotFoundException {\n    HttpResponse response = doGet(String.format(\"namespaces/%s/data/explore/tables/%s/info\", database, table));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, TableInfo.class);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new TableNotFoundException(\"Table \" + database + table + \" not found.\");\n    }\n    throw new ExploreException(\"Cannot get the schema of table \" + database + table +\n                               \". Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected QueryHandle doEnableExploreStream(Id.Stream stream) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/streams/%s/enable\",\n                                                 stream.getNamespaceId(), stream.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot enable explore on stream \" + stream.getId() + \". Reason: \" +\n                                 getDetails(response));\n  }","id":71750,"modified_method":"protected QueryHandle doEnableExploreStream(Id.Stream stream) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/streams/%s/enable\",\n                                                 stream.getNamespaceId(), stream.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(String.format(\"Cannot enable explore on stream %s. Reason: %s\",\n                                             stream.getId(), response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<ColumnDesc> getResultSchema(QueryHandle handle) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doGet(String.format(\"data/explore/queries/%s/%s\",\n                                                handle.getHandle(), \"schema\"));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, COL_DESC_LIST_TYPE);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get result schema. Reason: \" + getDetails(response));\n  }","id":71751,"modified_method":"@Override\n  public List<ColumnDesc> getResultSchema(QueryHandle handle) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doGet(String.format(\"data/explore/queries/%s/%s\",\n                                                handle.getHandle(), \"schema\"));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, COL_DESC_LIST_TYPE);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get result schema. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle getFunctions(String catalog, String schemaPattern, String functionNamePattern)\n    throws ExploreException, SQLException {\n    String body = GSON.toJson(new FunctionsArgs(catalog, schemaPattern, functionNamePattern));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/functions\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the functions. Reason: \" + getDetails(response));\n  }","id":71752,"modified_method":"@Override\n  public QueryHandle getFunctions(String catalog, String schemaPattern, String functionNamePattern)\n    throws ExploreException, SQLException {\n    String body = GSON.toJson(new FunctionsArgs(catalog, schemaPattern, functionNamePattern));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/functions\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the functions. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryStatus getStatus(QueryHandle handle) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doGet(String.format(\"data/explore/queries/%s/%s\",\n                                                handle.getHandle(), \"status\"));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, QueryStatus.class);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get status. Reason: \" + getDetails(response));\n  }","id":71753,"modified_method":"@Override\n  public QueryStatus getStatus(QueryHandle handle) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doGet(String.format(\"data/explore/queries/%s/%s\",\n                                                handle.getHandle(), \"status\"));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, QueryStatus.class);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get status. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void close(QueryHandle handle) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doDelete(String.format(\"data/explore/queries/%s\", handle.getHandle()));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return;\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot close operation. Reason: \" + getDetails(response));\n  }","id":71754,"modified_method":"@Override\n  public void close(QueryHandle handle) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doDelete(String.format(\"data/explore/queries/%s\", handle.getHandle()));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return;\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot close operation. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle getTypeInfo() throws ExploreException, SQLException {\n    HttpResponse response = doPost(\"data/explore/jdbc/types\", null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + getDetails(response));\n  }","id":71755,"modified_method":"@Override\n  public QueryHandle getTypeInfo() throws ExploreException, SQLException {\n    HttpResponse response = doPost(\"data/explore/jdbc/types\", null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected QueryHandle doDisableExploreStream(Id.Stream stream) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/streams/%s/disable\",\n                                                 stream.getNamespaceId(), stream.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot disable explore on stream \" + stream.getId() + \". Reason: \" +\n                                 getDetails(response));\n  }","id":71756,"modified_method":"protected QueryHandle doDisableExploreStream(Id.Stream stream) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/streams/%s/disable\",\n                                                 stream.getNamespaceId(), stream.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(String.format(\"Cannot disable explore on stream %s. Reason: %s\",\n                                             stream.getId(), response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle getCatalogs() throws ExploreException, SQLException {\n    HttpResponse response = doPost(\"data/explore/jdbc/catalogs\", null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the catalogs. Reason: \" + getDetails(response));\n  }","id":71757,"modified_method":"@Override\n  public QueryHandle getCatalogs() throws ExploreException, SQLException {\n    HttpResponse response = doPost(\"data/explore/jdbc/catalogs\", null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the catalogs. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected QueryHandle doAddPartition(Id.DatasetInstance datasetInstance,\n                                       PartitionKey key, String path) throws ExploreException {\n    Map<String, String> args = Maps.newHashMap();\n    PartitionedFileSetArguments.setOutputPartitionKey(args, key);\n    args.put(\"path\", path);\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/partitions\",\n                                                 datasetInstance.getNamespaceId(), datasetInstance.getId()),\n                                   GSON.toJson(args), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot add partition with key \" + key + \"to dataset \" + datasetInstance.getId() +\n                                 \". Reason: \" + getDetails(response));\n  }","id":71758,"modified_method":"protected QueryHandle doAddPartition(Id.DatasetInstance datasetInstance,\n                                       PartitionKey key, String path) throws ExploreException {\n    Map<String, String> args = Maps.newHashMap();\n    PartitionedFileSetArguments.setOutputPartitionKey(args, key);\n    args.put(\"path\", path);\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/partitions\",\n                                                 datasetInstance.getNamespaceId(), datasetInstance.getId()),\n                                   GSON.toJson(args), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(String.format(\"Cannot add partition with key %s to dataset %s. Reason: %s\",\n                                             key, datasetInstance.getId(), response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle createNamespace(Id.Namespace namespace) throws ExploreException, SQLException {\n    HttpResponse response = doPut(String.format(\"data/explore/namespaces/%s\", namespace.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot add a namespace. Reason: \" + getDetails(response));\n  }","id":71759,"modified_method":"@Override\n  public QueryHandle createNamespace(Id.Namespace namespace) throws ExploreException, SQLException {\n    HttpResponse response = doPut(String.format(\"data/explore/namespaces/%s\", namespace.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot add a namespace. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle getTableTypes() throws ExploreException, SQLException {\n    HttpResponse response = doPost(\"data/explore/jdbc/tableTypes\", null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + getDetails(response));\n  }","id":71760,"modified_method":"@Override\n  public QueryHandle getTableTypes() throws ExploreException, SQLException {\n    HttpResponse response = doPost(\"data/explore/jdbc/tableTypes\", null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<QueryResult> nextResults(QueryHandle handle, int size) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doPost(String.format(\"data/explore/queries/%s/%s\",\n                                                 handle.getHandle(), \"next\"),\n                                   GSON.toJson(ImmutableMap.of(\"size\", size)), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, ROW_LIST_TYPE);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get next results. Reason: \" + getDetails(response));\n  }","id":71761,"modified_method":"@Override\n  public List<QueryResult> nextResults(QueryHandle handle, int size) throws ExploreException, HandleNotFoundException {\n    HttpResponse response = doPost(String.format(\"data/explore/queries/%s/%s\",\n                                                 handle.getHandle(), \"next\"),\n                                   GSON.toJson(ImmutableMap.of(\"size\", size)), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, ROW_LIST_TYPE);\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new HandleNotFoundException(\"Handle \" + handle.getHandle() + \"not found.\");\n    }\n    throw new ExploreException(\"Cannot get next results. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public MetaDataInfo getInfo(MetaDataInfo.InfoType infoType) throws ExploreException, SQLException {\n    HttpResponse response = doGet(String.format(\"data/explore/jdbc/info/%s\", infoType.name()));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, MetaDataInfo.class);\n    }\n    throw new ExploreException(\"Cannot get information \" + infoType.name() + \". Reason: \" + getDetails(response));\n  }","id":71762,"modified_method":"@Override\n  public MetaDataInfo getInfo(MetaDataInfo.InfoType infoType) throws ExploreException, SQLException {\n    HttpResponse response = doGet(String.format(\"data/explore/jdbc/info/%s\", infoType.name()));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, MetaDataInfo.class);\n    }\n    throw new ExploreException(\"Cannot get information \" + infoType.name() + \". Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected QueryHandle doDisableExploreDataset(Id.DatasetInstance datasetInstance) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/disable\",\n                                                 datasetInstance.getNamespaceId(), datasetInstance.getId()),\n                                   null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot disable explore on dataset \" + datasetInstance.getId() + \". Reason: \" +\n                                 getDetails(response));\n  }","id":71763,"modified_method":"protected QueryHandle doDisableExploreDataset(Id.DatasetInstance datasetInstance) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/disable\",\n                                                 datasetInstance.getNamespaceId(), datasetInstance.getId()),\n                                   null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(String.format(\"Cannot disable explore on dataset %s. Reason: %s\",\n                                             datasetInstance.getId(), response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle deleteNamespace(Id.Namespace namespace) throws ExploreException, SQLException {\n    HttpResponse response = doDelete(String.format(\"data/explore/namespaces/%s\", namespace.getId()));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot remove a namespace. Reason: \" + getDetails(response));\n  }","id":71764,"modified_method":"@Override\n  public QueryHandle deleteNamespace(Id.Namespace namespace) throws ExploreException, SQLException {\n    HttpResponse response = doDelete(String.format(\"data/explore/namespaces/%s\", namespace.getId()));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot remove a namespace. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)\n    throws ExploreException, SQLException {\n    String body = GSON.toJson(new ColumnsArgs(catalog, schemaPattern,\n                                                                tableNamePattern, columnNamePattern));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/columns\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the columns. Reason: \" + getDetails(response));\n  }","id":71765,"modified_method":"@Override\n  public QueryHandle getColumns(String catalog, String schemaPattern, String tableNamePattern, String columnNamePattern)\n    throws ExploreException, SQLException {\n    String body = GSON.toJson(new ColumnsArgs(catalog, schemaPattern,\n                                                                tableNamePattern, columnNamePattern));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/columns\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the columns. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle getTables(String catalog, String schemaPattern,\n                               String tableNamePattern, List<String> tableTypes) throws ExploreException, SQLException {\n    String body = GSON.toJson(new TablesArgs(catalog, schemaPattern, tableNamePattern, tableTypes));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/tables\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + getDetails(response));\n  }","id":71766,"modified_method":"@Override\n  public QueryHandle getTables(String catalog, String schemaPattern,\n                               String tableNamePattern, List<String> tableTypes) throws ExploreException, SQLException {\n    String body = GSON.toJson(new TablesArgs(catalog, schemaPattern, tableNamePattern, tableTypes));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/tables\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<QueryInfo> getQueries(Id.Namespace namespace) throws ExploreException, SQLException {\n    String resource = String.format(\"namespaces/%s/data/explore/queries/\", namespace.getId());\n    HttpResponse response = doGet(resource);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, QUERY_INFO_LIST_TYPE);\n    }\n    throw new ExploreException(\"Cannot get list of queries. Reason: \" + getDetails(response));\n  }","id":71767,"modified_method":"@Override\n  public List<QueryInfo> getQueries(Id.Namespace namespace) throws ExploreException, SQLException {\n    String resource = String.format(\"namespaces/%s/data/explore/queries/\", namespace.getId());\n    HttpResponse response = doGet(resource);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, QUERY_INFO_LIST_TYPE);\n    }\n    throw new ExploreException(\"Cannot get list of queries. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle getSchemas(String catalog, String schemaPattern) throws ExploreException, SQLException {\n    String body = GSON.toJson(new SchemasArgs(catalog, schemaPattern));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/schemas\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the schemas. Reason: \" + getDetails(response));\n  }","id":71768,"modified_method":"@Override\n  public QueryHandle getSchemas(String catalog, String schemaPattern) throws ExploreException, SQLException {\n    String body = GSON.toJson(new SchemasArgs(catalog, schemaPattern));\n    String resource = String.format(\"namespaces/%s/data/explore/jdbc/schemas\", schemaPattern);\n    HttpResponse response = doPost(resource, body, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot get the schemas. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"private <T> T parseJson(HttpResponse response, Type type) throws ExploreException {\n    String responseString = new String(response.getResponseBody(), Charsets.UTF_8);\n    try {\n      return GSON.fromJson(responseString, type);\n    } catch (JsonSyntaxException e) {\n      String message = String.format(\"Cannot parse server response: %s\", responseString);\n      LOG.error(message, e);\n      throw new ExploreException(message, e);\n    } catch (JsonParseException e) {\n      String message = String.format(\"Cannot parse server response as map: %s\", responseString);\n      LOG.error(message, e);\n      throw new ExploreException(message, e);\n    }\n  }","id":71769,"modified_method":"private <T> T parseJson(HttpResponse response, Type type) throws ExploreException {\n    String responseString = response.getResponseBodyAsString();\n    try {\n      return GSON.fromJson(responseString, type);\n    } catch (JsonSyntaxException e) {\n      String message = String.format(\"Cannot parse server response: %s\", responseString);\n      LOG.error(message, e);\n      throw new ExploreException(message, e);\n    } catch (JsonParseException e) {\n      String message = String.format(\"Cannot parse server response as map: %s\", responseString);\n      LOG.error(message, e);\n      throw new ExploreException(message, e);\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected QueryHandle doEnableExploreDataset(Id.DatasetInstance datasetInstance) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/enable\",\n                                                 datasetInstance.getNamespace(), datasetInstance.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot enable explore on dataset \" + datasetInstance.getId() + \". Reason: \" +\n                                 getDetails(response));\n  }","id":71770,"modified_method":"protected QueryHandle doEnableExploreDataset(Id.DatasetInstance datasetInstance) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/enable\",\n                                                 datasetInstance.getNamespace(), datasetInstance.getId()), null, null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(String.format(\"Cannot enable explore on dataset %s. Reason: %s\",\n                                             datasetInstance.getId(), response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public QueryHandle execute(Id.Namespace namespace, String statement) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/queries\", namespace.getId()),\n                                   GSON.toJson(ImmutableMap.of(\"query\", statement)), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot execute query. Reason: \" + getDetails(response));\n  }","id":71771,"modified_method":"@Override\n  public QueryHandle execute(Id.Namespace namespace, String statement) throws ExploreException {\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/queries\", namespace.getId()),\n                                   GSON.toJson(ImmutableMap.of(\"query\", statement)), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot execute query. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"protected QueryHandle doDropPartition(Id.DatasetInstance datasetInstance, PartitionKey key) throws ExploreException {\n    Map<String, String> args = Maps.newHashMap();\n    PartitionedFileSetArguments.setOutputPartitionKey(args, key);\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/deletePartition\",\n                                                 datasetInstance.getNamespace(), datasetInstance.getId()),\n                                     GSON.toJson(args), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(\"Cannot drop partition with key \" + key + \"from dataset \" + datasetInstance.getId() +\n                                 \". Reason: \" + getDetails(response));\n  }","id":71772,"modified_method":"protected QueryHandle doDropPartition(Id.DatasetInstance datasetInstance, PartitionKey key) throws ExploreException {\n    Map<String, String> args = Maps.newHashMap();\n    PartitionedFileSetArguments.setOutputPartitionKey(args, key);\n    HttpResponse response = doPost(String.format(\"namespaces/%s/data/explore/datasets/%s/deletePartition\",\n                                                 datasetInstance.getNamespace(), datasetInstance.getId()),\n                                     GSON.toJson(args), null);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return QueryHandle.fromId(parseResponseAsMap(response, \"handle\"));\n    }\n    throw new ExploreException(String.format(\"Cannot drop partition with key %s from dataset %s. Reason: %s\",\n                                             key, datasetInstance.getId(), response));\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<TableNameInfo> getTables(@Nullable String database) throws ExploreException {\n    HttpResponse response = doGet(String.format(\"namespaces/%s/data/explore/tables\", database));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, TABLES_TYPE);\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + getDetails(response));\n  }","id":71773,"modified_method":"@Override\n  public List<TableNameInfo> getTables(@Nullable String database) throws ExploreException {\n    HttpResponse response = doGet(String.format(\"namespaces/%s/data/explore/tables\", database));\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return parseJson(response, TABLES_TYPE);\n    }\n    throw new ExploreException(\"Cannot get the tables. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void deleteFeed(Id.NotificationFeed feed) throws NotificationFeedNotFoundException, NotificationFeedException {\n    HttpResponse response = execute(HttpRequest.delete(resolve(\n      String.format(\"namespaces/%s/feeds/categories/%s/names/%s\",\n                    feed.getNamespaceId(), feed.getCategory(), feed.getName()))\n    ).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotificationFeedNotFoundException(feed);\n    } else if (response.getResponseCode() != HttpURLConnection.HTTP_OK) {\n      throw new NotificationFeedException(\"Cannot delete notification feed. Reason: \" + getDetails(response));\n    }\n  }","id":71774,"modified_method":"@Override\n  public void deleteFeed(Id.NotificationFeed feed) throws NotificationFeedNotFoundException, NotificationFeedException {\n    HttpResponse response = execute(HttpRequest.delete(resolve(\n      String.format(\"namespaces/%s/feeds/categories/%s/names/%s\",\n                    feed.getNamespaceId(), feed.getCategory(), feed.getName()))\n    ).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotificationFeedNotFoundException(feed);\n    } else if (response.getResponseCode() != HttpURLConnection.HTTP_OK) {\n      throw new NotificationFeedException(\"Cannot delete notification feed. Reason: \" + response);\n    }\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public List<Id.NotificationFeed> listFeeds(Id.Namespace namespace) throws NotificationFeedException {\n    HttpResponse response = execute(HttpRequest.get(resolve(\n      String.format(\"namespaces/%s/feeds\", namespace.getId()))).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      ObjectResponse<List<Id.NotificationFeed>> r =\n        ObjectResponse.fromJsonBody(response, new TypeToken<List<Id.NotificationFeed>>() { }.getType());\n      return r.getResponseObject();\n    }\n    throw new NotificationFeedException(\"Cannot list notification feeds. Reason: \" + getDetails(response));\n  }","id":71775,"modified_method":"@Override\n  public List<Id.NotificationFeed> listFeeds(Id.Namespace namespace) throws NotificationFeedException {\n    HttpResponse response = execute(HttpRequest.get(resolve(\n      String.format(\"namespaces/%s/feeds\", namespace.getId()))).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      ObjectResponse<List<Id.NotificationFeed>> r =\n        ObjectResponse.fromJsonBody(response, new TypeToken<List<Id.NotificationFeed>>() { }.getType());\n      return r.getResponseObject();\n    }\n    throw new NotificationFeedException(\"Cannot list notification feeds. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public Id.NotificationFeed getFeed(Id.NotificationFeed feed)\n    throws NotificationFeedNotFoundException, NotificationFeedException {\n    HttpResponse response = execute(HttpRequest.get(resolve(\n      String.format(\"namespaces/%s/feeds/categories/%s/names/%s\",\n                    feed.getNamespaceId(), feed.getCategory(), feed.getName()))\n    ).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotificationFeedNotFoundException(feed);\n    } else if (response.getResponseCode() != HttpURLConnection.HTTP_OK) {\n      throw new NotificationFeedException(\"Cannot get notification feed. Reason: \" + getDetails(response));\n    }\n    return ObjectResponse.fromJsonBody(response, Id.NotificationFeed.class).getResponseObject();\n  }","id":71776,"modified_method":"@Override\n  public Id.NotificationFeed getFeed(Id.NotificationFeed feed)\n    throws NotificationFeedNotFoundException, NotificationFeedException {\n    HttpResponse response = execute(HttpRequest.get(resolve(\n      String.format(\"namespaces/%s/feeds/categories/%s/names/%s\",\n                    feed.getNamespaceId(), feed.getCategory(), feed.getName()))\n    ).build());\n    if (response.getResponseCode() == HttpURLConnection.HTTP_NOT_FOUND) {\n      throw new NotificationFeedNotFoundException(feed);\n    } else if (response.getResponseCode() != HttpURLConnection.HTTP_OK) {\n      throw new NotificationFeedException(\"Cannot get notification feed. Reason: \" + response);\n    }\n    return ObjectResponse.fromJsonBody(response, Id.NotificationFeed.class).getResponseObject();\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public boolean createFeed(Id.NotificationFeed feed) throws NotificationFeedException {\n    HttpRequest request = HttpRequest.put(resolve(\n      String.format(\"namespaces/%s/feeds/categories/%s/names/%s\",\n                    feed.getNamespaceId(), feed.getCategory(), feed.getName())))\n      .withBody(GSON.toJson(feed)).build();\n    HttpResponse response = execute(request);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return true;\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_CONFLICT) {\n      return false;\n    }\n    throw new NotificationFeedException(\"Cannot create notification feed. Reason: \" + getDetails(response));\n  }","id":71777,"modified_method":"@Override\n  public boolean createFeed(Id.NotificationFeed feed) throws NotificationFeedException {\n    HttpRequest request = HttpRequest.put(resolve(\n      String.format(\"namespaces/%s/feeds/categories/%s/names/%s\",\n                    feed.getNamespaceId(), feed.getCategory(), feed.getName())))\n      .withBody(GSON.toJson(feed)).build();\n    HttpResponse response = execute(request);\n    if (response.getResponseCode() == HttpURLConnection.HTTP_OK) {\n      return true;\n    } else if (response.getResponseCode() == HttpURLConnection.HTTP_CONFLICT) {\n      return false;\n    }\n    throw new NotificationFeedException(\"Cannot create notification feed. Reason: \" + response);\n  }","commit_id":"4b617b4d32a577fbfd6d3d919843b75d916ee02f","url":"https://github.com/caskdata/cdap"},{"original_method":"public String onClick(WOContext context) {\n    NSDictionary options = createAjaxOptions(context.component());\n    String actionUrl = context.componentActionURL();\n    String id = (String) valueForBinding(\"updateContainerID\", context.component());\n    StringBuffer sb = new StringBuffer();\n    sb.append(\"new Ajax.Request('\");\n    sb.append(actionUrl);\n    sb.append(\"', \");\n    AjaxOptions.appendToBuffer(options, sb, context);\n    sb.append(\")\");\n    String onClick = (String)valueForBinding(\"onClick\", context.component());\n    if(onClick != null) {\n        sb.append(\";\");\n        sb.append(onClick);\n    }\n    return sb.toString();\n  }","id":71778,"modified_method":"public String onClick(WOContext context) {\n    NSDictionary options = createAjaxOptions(context.component());\n    StringBuffer sb = new StringBuffer();\n    if (associations().valueForKey(\"action\") == null) {\n      String updateContainerID = (String) valueForBinding(\"updateContainerID\", context.component());\n      sb.append(\"new Ajax.Updater('\"+updateContainerID+\"', $('\"+updateContainerID+\"').getAttribute('updateUrl'), \");\n      AjaxOptions.appendToBuffer(options, sb, context);\n      sb.append(\")\");\n    }\n    else {\n      String actionUrl = context.componentActionURL();\n      sb.append(\"new Ajax.Request('\");\n      sb.append(actionUrl);\n      sb.append(\"', \");\n      AjaxOptions.appendToBuffer(options, sb, context);\n      sb.append(\")\");\n    }\n    String onClick = (String)valueForBinding(\"onClick\", context.component());\n    if(onClick != null) {\n        sb.append(\";\");\n        sb.append(onClick);\n    }\n    return sb.toString();\n  }","commit_id":"e4a60ffba70c1e698f61355350f406c9e7c13d91","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String onClick(WOContext context) {\n    NSDictionary options = createAjaxOptions(context.component());\n    StringBuffer sb = new StringBuffer();\n    if (associations().valueForKey(\"action\") == null) {\n      String updateContainerID = (String) valueForBinding(\"updateContainerID\", context.component());\n      sb.append(\"new Ajax.Updater('\"+updateContainerID+\"', $('\"+updateContainerID+\"').getAttribute('updateUrl'), \");\n      AjaxOptions.appendToBuffer(options, sb, context);\n      sb.append(\")\");\n    }\n    else {\n      String actionUrl = context.componentActionURL();\n      sb.append(\"new Ajax.Request('\");\n      sb.append(actionUrl);\n      sb.append(\"', \");\n      AjaxOptions.appendToBuffer(options, sb, context);\n      sb.append(\")\");\n    }\n    String onClick = (String)valueForBinding(\"onClick\", context.component());\n    if(onClick != null) {\n        sb.append(\";\");\n        sb.append(onClick);\n    }\n    return sb.toString();\n  }","id":71779,"modified_method":"public String onClick(WOContext context) {\n    NSDictionary options = createAjaxOptions(context.component());\n    StringBuffer sb = new StringBuffer();\n    if (associations().valueForKey(\"action\") == null) {\n      String updateContainerID = (String) valueForBinding(\"updateContainerID\", context.component());\n      sb.append(\"new Ajax.Updater('\" + updateContainerID + \"', $('\" + updateContainerID + \"').getAttribute('updateUrl'), \");\n      AjaxOptions.appendToBuffer(options, sb, context);\n      sb.append(\")\");\n    }\n    else {\n      String actionUrl = context.componentActionURL();\n      String replaceID = (String) valueForBinding(\"replaceID\", context.component());\n      if (replaceID == null) {\n        sb.append(\"new Ajax.Request('\");\n        sb.append(actionUrl);\n        sb.append(\"', \");\n        AjaxOptions.appendToBuffer(options, sb, context);\n        sb.append(\")\");\n      }\n      else {\n        sb.append(\"new Ajax.Updater('\" + replaceID + \"', '\" + actionUrl + \"', \");\n        AjaxOptions.appendToBuffer(options, sb, context);\n        sb.append(\")\");\n      }\n    }\n    String onClick = (String) valueForBinding(\"onClick\", context.component());\n    if (onClick != null) {\n      sb.append(\";\");\n      sb.append(onClick);\n    }\n    return sb.toString();\n  }","commit_id":"850d5ff1aca18c9bdd497ba1c2d556bb796127ca","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String onClick(WOContext context, boolean generateFunctionWrapper) {\n\t\tWOComponent component = context.component();\n\t\tNSDictionary options = createAjaxOptions(component);\n\t\tStringBuffer onClickBuffer = new StringBuffer();\n\n\t\tString onClick = (String) valueForBinding(\"onClick\", component);\n\t\tString onClickBefore = (String) valueForBinding(\"onClickBefore\", component);\n\t\tString updateContainerID = (String) valueForBinding(\"updateContainerID\", component);\n\t\tString functionName = (String) valueForBinding(\"functionName\", component);\n\t\tString function = (String) valueForBinding(\"function\", component);\n\t\tString replaceID = (String) valueForBinding(\"replaceID\", component);\n\t\tWOAssociation directActionNameAssociation = (WOAssociation) associations().valueForKey(\"directActionName\");\n\t\tif (updateContainerID != null && directActionNameAssociation == null && replaceID == null && function == null && onClick == null && onClickBefore == null) {\n\t\t\tNSDictionary nonDefaultOptions = AjaxUpdateContainer.removeDefaultOptions(options);\n\t\t\tonClickBuffer.append(\"AUL.\");\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"updateFunc\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tonClickBuffer.append(\"update\");\n\t\t\t}\n\t\t\tonClickBuffer.append(\"('\");\n\t\t\tonClickBuffer.append(updateContainerID);\n\t\t\tonClickBuffer.append(\"', '\");\n\t\t\tonClickBuffer.append(context.contextID());\n\t\t\tonClickBuffer.append('.');\n\t\t\tonClickBuffer.append(context.elementID());\n\t\t\tonClickBuffer.append(\"', \");\n\t\t\tAjaxOptions.appendToBuffer(nonDefaultOptions, onClickBuffer, context);\n\t\t\t// if (generateFunctionWrapper) {\n\t\t\t// onClickBuffer.append(\", additionalParams\");\n\t\t\t// }\n\t\t\tonClickBuffer.append(\")\");\n\t\t\tonClickBuffer.append(\";\");\n\t\t}\n\t\telse {\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"function(additionalParams) {\");\n\t\t\t}\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"if (\");\n\t\t\t\tonClickBuffer.append(onClickBefore);\n\t\t\t\tonClickBuffer.append(\") {\");\n\t\t\t}\n\n\t\t\tString actionUrl = null;\n\t\t\tif (directActionNameAssociation != null) {\n\t\t\t\tactionUrl = context.directActionURLForActionNamed((String) directActionNameAssociation.valueInComponent(component), ERXComponentUtilities.queryParametersInComponent(associations(), component)).replaceAll(\"&amp;\", \"&\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactionUrl = AjaxUtils.ajaxComponentActionUrl(context);\n\t\t\t}\n\n\t\t\tactionUrl = \"'\" + actionUrl + \"'\";\n\t\t\tif (functionName != null) {\n\t\t\t\tactionUrl = actionUrl + \".addQueryParameters(additionalParams)\";\n\t\t\t}\n\n\t\t\tif (function != null) {\n\t\t\t\tonClickBuffer.append(\"return \" + function + \"(\" + actionUrl + \")\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (replaceID == null) {\n\t\t\t\t\tif (updateContainerID == null) {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Request(\" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + updateContainerID + \"', \" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + replaceID + \"', \" + actionUrl + \", \");\n\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onClick != null) {\n\t\t\t\tonClickBuffer.append(\";\");\n\t\t\t\tonClickBuffer.append(onClick);\n\t\t\t}\n\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\t\t}\n\n\t\treturn onClickBuffer.toString();\n\t}","id":71780,"modified_method":"public String onClick(WOContext context, boolean generateFunctionWrapper) {\n\t\tWOComponent component = context.component();\n\t\tNSDictionary options = createAjaxOptions(component);\n\t\tStringBuffer onClickBuffer = new StringBuffer();\n\n\t\tString onClick = (String) valueForBinding(\"onClick\", component);\n\t\tString onClickBefore = (String) valueForBinding(\"onClickBefore\", component);\n\t\tString updateContainerID = (String) valueForBinding(\"updateContainerID\", component);\n\t\tString functionName = (String) valueForBinding(\"functionName\", component);\n\t\tString function = (String) valueForBinding(\"function\", component);\n\t\tString replaceID = (String) valueForBinding(\"replaceID\", component);\n\t\tWOAssociation directActionNameAssociation = (WOAssociation) associations().valueForKey(\"directActionName\");\n\t\tif (updateContainerID != null && directActionNameAssociation == null && replaceID == null && function == null && onClick == null && onClickBefore == null) {\n\t\t\tNSDictionary nonDefaultOptions = AjaxUpdateContainer.removeDefaultOptions(options);\n\t\t\tonClickBuffer.append(\"AUL.\");\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"updateFunc\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tonClickBuffer.append(\"update\");\n\t\t\t}\n\t\t\tonClickBuffer.append(\"('\");\n\t\t\tonClickBuffer.append(updateContainerID);\n\t\t\tonClickBuffer.append(\"', \");\n\t\t\tAjaxOptions.appendToBuffer(nonDefaultOptions, onClickBuffer, context);\n\t\t\tonClickBuffer.append(\", '\");\n\t\t\tonClickBuffer.append(context.contextID());\n\t\t\tonClickBuffer.append('.');\n\t\t\tonClickBuffer.append(context.elementID());\n\t\t\tonClickBuffer.append(\"'\");\n\t\t\t// if (generateFunctionWrapper) {\n\t\t\t// onClickBuffer.append(\", additionalParams\");\n\t\t\t// }\n\t\t\tonClickBuffer.append(\")\");\n\t\t\tonClickBuffer.append(\";\");\n\t\t}\n\t\telse {\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"function(additionalParams) {\");\n\t\t\t}\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"if (\");\n\t\t\t\tonClickBuffer.append(onClickBefore);\n\t\t\t\tonClickBuffer.append(\") {\");\n\t\t\t}\n\n\t\t\tString actionUrl = null;\n\t\t\tif (directActionNameAssociation != null) {\n\t\t\t\tactionUrl = context.directActionURLForActionNamed((String) directActionNameAssociation.valueInComponent(component), ERXComponentUtilities.queryParametersInComponent(associations(), component)).replaceAll(\"&amp;\", \"&\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactionUrl = AjaxUtils.ajaxComponentActionUrl(context);\n\t\t\t}\n\n\t\t\tactionUrl = \"'\" + actionUrl + \"'\";\n\t\t\tif (functionName != null) {\n\t\t\t\tactionUrl = actionUrl + \".addQueryParameters(additionalParams)\";\n\t\t\t}\n\n\t\t\tif (function != null) {\n\t\t\t\tonClickBuffer.append(\"return \" + function + \"(\" + actionUrl + \")\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (replaceID == null) {\n\t\t\t\t\tif (updateContainerID == null) {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Request(\" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + updateContainerID + \"', \" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + replaceID + \"', \" + actionUrl + \", \");\n\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onClick != null) {\n\t\t\t\tonClickBuffer.append(\";\");\n\t\t\t\tonClickBuffer.append(onClick);\n\t\t\t}\n\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\t\t}\n\n\t\treturn onClickBuffer.toString();\n\t}","commit_id":"62b25182111d25c61b5c3d76f02ed42c2510eb50","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String onClick(WOContext context, boolean generateFunctionWrapper) {\n\t\tWOComponent component = context.component();\n\t\tNSDictionary options = createAjaxOptions(component);\n\t\tStringBuffer onClickBuffer = new StringBuffer();\n\n\t\tString onClick = (String) valueForBinding(\"onClick\", context.component());\n\t\tString onClickBefore = (String) valueForBinding(\"onClickBefore\", context.component());\n\t\tString updateContainerID = (String) valueForBinding(\"updateContainerID\", context.component());\n\t\tString functionName = (String) valueForBinding(\"functionName\", component);\n\t\tString function = (String) valueForBinding(\"function\", context.component());\n\t\tString replaceID = (String) valueForBinding(\"replaceID\", context.component());\n\t\tWOAssociation directActionNameAssociation = (WOAssociation) associations().valueForKey(\"directActionName\");\n\t\tif (updateContainerID != null && directActionNameAssociation == null && replaceID == null && functionName != null && function == null && onClick == null && onClickBefore == null) {\n\t\t\tNSDictionary nonDefaultOptions = AjaxUpdateContainer.removeDefaultOptions(options);\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"AUL.updateFunc('\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tonClickBuffer.append(\"AUL.update('\");\n\t\t\t}\n\t\t\tonClickBuffer.append(updateContainerID);\n\t\t\tonClickBuffer.append(\"', \");\n\t\t\tAjaxOptions.appendToBuffer(nonDefaultOptions, onClickBuffer, context);\n\t\t\tonClickBuffer.append(\", '\");\n\t\t\tonClickBuffer.append(context.contextID());\n\t\t\tonClickBuffer.append('.');\n\t\t\tonClickBuffer.append(context.elementID());\n\t\t\tonClickBuffer.append(\"'\");\n\t\t\tif (!generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\", additionalParams\");\n\t\t\t}\n\t\t\tonClickBuffer.append(\");\");\n\t\t}\n\t\telse {\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"function(additionalParams) {\");\n\t\t\t}\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"if (\");\n\t\t\t\tonClickBuffer.append(onClickBefore);\n\t\t\t\tonClickBuffer.append(\") {\");\n\t\t\t}\n\t\n\t\t\tString actionUrl = null;\n\t\t\tif (directActionNameAssociation != null) {\n\t\t\t\tactionUrl = context.directActionURLForActionNamed((String) directActionNameAssociation.valueInComponent(component), ERXComponentUtilities.queryParametersInComponent(associations(), component)).replaceAll(\"&amp;\", \"&\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactionUrl = AjaxUtils.ajaxComponentActionUrl(context);\n\t\t\t}\n\n\t\t\tactionUrl = \"'\" + actionUrl + \"'\";\n\t\t\tif (functionName != null) {\n\t\t\t\tactionUrl = actionUrl + \".addQueryParameters(additionalParams)\";\n\t\t\t}\n\t\n\t\t\tif (function != null) {\n\t\t\t\tonClickBuffer.append(\"return \" + function + \"(\" + actionUrl + \")\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (replaceID == null) {\n\t\t\t\t\tif (updateContainerID == null) {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Request(\" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + updateContainerID + \"', \" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + replaceID + \"', \" + actionUrl + \", \");\n\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (onClick != null) {\n\t\t\t\tonClickBuffer.append(\";\");\n\t\t\t\tonClickBuffer.append(onClick);\n\t\t\t}\n\t\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn onClickBuffer.toString();\n\t}","id":71781,"modified_method":"public String onClick(WOContext context, boolean generateFunctionWrapper) {\n\t\tWOComponent component = context.component();\n\t\tNSDictionary options = createAjaxOptions(component);\n\t\tStringBuffer onClickBuffer = new StringBuffer();\n\n\t\tString onClick = (String) valueForBinding(\"onClick\", component);\n\t\tString onClickBefore = (String) valueForBinding(\"onClickBefore\", component);\n\t\tString updateContainerID = (String) valueForBinding(\"updateContainerID\", component);\n\t\tString functionName = (String) valueForBinding(\"functionName\", component);\n\t\tString function = (String) valueForBinding(\"function\", component);\n\t\tString replaceID = (String) valueForBinding(\"replaceID\", component);\n\t\tWOAssociation directActionNameAssociation = (WOAssociation) associations().valueForKey(\"directActionName\");\n\t\tif (updateContainerID != null && directActionNameAssociation == null && replaceID == null && function == null && onClick == null && onClickBefore == null) {\n\t\t\tNSDictionary nonDefaultOptions = AjaxUpdateContainer.removeDefaultOptions(options);\n\t\t\tonClickBuffer.append(\"AUL.\");\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"updateFunc\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tonClickBuffer.append(\"update\");\n\t\t\t}\n\t\t\tonClickBuffer.append(\"('\");\n\t\t\tonClickBuffer.append(updateContainerID);\n\t\t\tonClickBuffer.append(\"', '\");\n\t\t\tonClickBuffer.append(context.contextID());\n\t\t\tonClickBuffer.append('.');\n\t\t\tonClickBuffer.append(context.elementID());\n\t\t\tonClickBuffer.append(\"', \");\n\t\t\tAjaxOptions.appendToBuffer(nonDefaultOptions, onClickBuffer, context);\n\t\t\t// if (generateFunctionWrapper) {\n\t\t\t// onClickBuffer.append(\", additionalParams\");\n\t\t\t// }\n\t\t\tonClickBuffer.append(\")\");\n\t\t\tonClickBuffer.append(\";\");\n\t\t}\n\t\telse {\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"function(additionalParams) {\");\n\t\t\t}\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"if (\");\n\t\t\t\tonClickBuffer.append(onClickBefore);\n\t\t\t\tonClickBuffer.append(\") {\");\n\t\t\t}\n\n\t\t\tString actionUrl = null;\n\t\t\tif (directActionNameAssociation != null) {\n\t\t\t\tactionUrl = context.directActionURLForActionNamed((String) directActionNameAssociation.valueInComponent(component), ERXComponentUtilities.queryParametersInComponent(associations(), component)).replaceAll(\"&amp;\", \"&\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactionUrl = AjaxUtils.ajaxComponentActionUrl(context);\n\t\t\t}\n\n\t\t\tactionUrl = \"'\" + actionUrl + \"'\";\n\t\t\tif (functionName != null) {\n\t\t\t\tactionUrl = actionUrl + \".addQueryParameters(additionalParams)\";\n\t\t\t}\n\n\t\t\tif (function != null) {\n\t\t\t\tonClickBuffer.append(\"return \" + function + \"(\" + actionUrl + \")\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (replaceID == null) {\n\t\t\t\t\tif (updateContainerID == null) {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Request(\" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + updateContainerID + \"', \" + actionUrl + \", \");\n\t\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tonClickBuffer.append(\"new Ajax.Updater('\" + replaceID + \"', \" + actionUrl + \", \");\n\t\t\t\t\tAjaxOptions.appendToBuffer(options, onClickBuffer, context);\n\t\t\t\t\tonClickBuffer.append(\")\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (onClick != null) {\n\t\t\t\tonClickBuffer.append(\";\");\n\t\t\t\tonClickBuffer.append(onClick);\n\t\t\t}\n\n\t\t\tif (onClickBefore != null) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\n\t\t\tif (generateFunctionWrapper) {\n\t\t\t\tonClickBuffer.append(\"}\");\n\t\t\t}\n\t\t}\n\n\t\treturn onClickBuffer.toString();\n\t}","commit_id":"b659d5902403c6ef77fb5938e4341ca8d4e2f8a4","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void testUnregisterProcessor() throws Exception {\n        // JMX tests dont work well on AIX CI servers (hangs them)\n        if (isPlatform(\"aix\")) {\n            return;\n        }\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        Set<ObjectName> set = mbeanServer.queryNames(new ObjectName(\"*:type=processors,*\"), null);\n        assertEquals(1, set.size());\n\n        ObjectName on = set.iterator().next();\n\n        assertTrue(\"Should be registered\", mbeanServer.isRegistered(on));\n        String id = (String) mbeanServer.getAttribute(on, \"CamelId\");\n        assertEquals(\"camel-1\", id);\n\n        String routeId = (String) mbeanServer.getAttribute(on, \"RouteId\");\n        assertEquals(\"route1\", routeId);\n    }","id":71782,"modified_method":"public void testUnregisterProcessor() throws Exception {\n        // JMX tests dont work well on AIX CI servers (hangs them)\n        if (isPlatform(\"aix\")) {\n            return;\n        }\n\n        MBeanServer mbeanServer = getMBeanServer();\n\n        Set<ObjectName> set = mbeanServer.queryNames(new ObjectName(\"*:type=processors,*\"), null);\n        assertEquals(2, set.size());\n\n        ObjectName on = set.iterator().next();\n\n        assertTrue(\"Should be registered\", mbeanServer.isRegistered(on));\n        String id = (String) mbeanServer.getAttribute(on, \"CamelId\");\n        assertEquals(\"camel-1\", id);\n\n        String routeId = (String) mbeanServer.getAttribute(on, \"RouteId\");\n        assertEquals(\"route1\", routeId);\n    }","commit_id":"5bd61ab558812ef9847dec9547b73ac80ca4d65a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getHeaderName(), \"headerName\", this);\n        return ProcessorBuilder.removeHeader(getHeaderName());\n    }","id":71783,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getHeaderName(), \"headerName\", this);\n        return new RemoveHeaderProcessor(getHeaderName());\n    }","commit_id":"5bd61ab558812ef9847dec9547b73ac80ca4d65a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPattern(), \"patterns\", this);\n        if (getExcludePatterns() != null) {\n            return ProcessorBuilder.removeHeaders(getPattern(), getExcludePatterns());\n        } else if (getExcludePattern() != null) {\n            return ProcessorBuilder.removeHeaders(getPattern(), getExcludePattern());\n        } else {\n            return ProcessorBuilder.removeHeaders(getPattern());\n        }\n    }","id":71784,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPattern(), \"patterns\", this);\n        if (getExcludePatterns() != null) {\n            return new RemoveHeadersProcessor(getPattern(), getExcludePatterns());\n        } else if (getExcludePattern() != null) {\n            return new RemoveHeadersProcessor(getPattern(), new String[]{getExcludePattern()});\n        } else {\n            return new RemoveHeadersProcessor(getPattern(), null);\n        }\n    }","commit_id":"5bd61ab558812ef9847dec9547b73ac80ca4d65a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPattern(), \"patterns\", this);\n        if (getExcludePatterns() != null) {\n            return ProcessorBuilder.removeProperties(getPattern(), getExcludePatterns());\n        } else if (getExcludePattern() != null) {\n            return ProcessorBuilder.removeProperties(getPattern(), getExcludePattern());\n        } else {\n            return ProcessorBuilder.removeProperties(getPattern());\n        }\n    }","id":71785,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPattern(), \"patterns\", this);\n        if (getExcludePatterns() != null) {\n            return new RemovePropertiesProcessor(getPattern(), getExcludePatterns());\n        } else if (getExcludePattern() != null) {\n            return new RemovePropertiesProcessor(getPattern(), new String[]{getExcludePattern()});\n        } else {\n            return new RemovePropertiesProcessor(getPattern(), null);\n        }\n    }","commit_id":"5bd61ab558812ef9847dec9547b73ac80ca4d65a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPropertyName(), \"propertyName\", this);\n        return ProcessorBuilder.removeProperty(getPropertyName());\n    }","id":71786,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPropertyName(), \"propertyName\", this);\n        return new RemovePropertyProcessor(getPropertyName());\n    }","commit_id":"5bd61ab558812ef9847dec9547b73ac80ca4d65a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(headerName, \"headerName\");\n        Expression expr = getExpression().createExpression(routeContext);\n        return ProcessorBuilder.setHeader(getHeaderName(), expr);\n    }","id":71787,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(headerName, \"headerName\");\n        Expression expr = getExpression().createExpression(routeContext);\n        return new SetHeaderProcessor(getHeaderName(), expr);\n    }","commit_id":"5bd61ab558812ef9847dec9547b73ac80ca4d65a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPropertyName(), \"propertyName\", this);\n        Expression expr = getExpression().createExpression(routeContext);\n        return ProcessorBuilder.setProperty(getPropertyName(), expr);\n    }","id":71788,"modified_method":"@Override\n    public Processor createProcessor(RouteContext routeContext) throws Exception {\n        ObjectHelper.notNull(getPropertyName(), \"propertyName\", this);\n        Expression expr = getExpression().createExpression(routeContext);\n        return new SetPropertyProcessor(getPropertyName(), expr);\n    }","commit_id":"5bd61ab558812ef9847dec9547b73ac80ca4d65a","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public List<ImageStoreVO> findByScope(ZoneScope scope) {\n        SearchCriteria<ImageStoreVO> sc = createSearchCriteria();\n        sc.addAnd(\"role\", SearchCriteria.Op.EQ, DataStoreRole.Image);\n        SearchCriteria<ImageStoreVO> scc = createSearchCriteria();\n        scc.addOr(\"scope\", SearchCriteria.Op.EQ, ScopeType.REGION);\n        scc.addOr(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n        sc.addAnd(\"scope\", SearchCriteria.Op.SC, scc);\n        return listBy(sc);\n    }","id":71789,"modified_method":"@Override\n    public List<ImageStoreVO> findByScope(ZoneScope scope) {\n        SearchCriteria<ImageStoreVO> sc = createSearchCriteria();\n        sc.addAnd(\"role\", SearchCriteria.Op.EQ, DataStoreRole.Image);\n        if (scope.getScopeId() != null) {\n            SearchCriteria<ImageStoreVO> scc = createSearchCriteria();\n            scc.addOr(\"scope\", SearchCriteria.Op.EQ, ScopeType.REGION);\n            scc.addOr(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n            sc.addAnd(\"scope\", SearchCriteria.Op.SC, scc);\n        }\n        // we should return all image stores if cross-zone scope is passed (scopeId = null)\n        return listBy(sc);\n    }","commit_id":"ff735b4d8190f89ae70de63cbef6049465dfd36a","url":"https://github.com/apache/cloudstack"},{"original_method":"@Override\n    public List<ImageStoreVO> findImageCacheByScope(ZoneScope scope) {\n        SearchCriteria<ImageStoreVO> sc = createSearchCriteria();\n        sc.addAnd(\"role\", SearchCriteria.Op.EQ, DataStoreRole.ImageCache);\n        sc.addAnd(\"scope\", SearchCriteria.Op.EQ, ScopeType.ZONE);\n        sc.addAnd(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n        return listBy(sc);\n    }","id":71790,"modified_method":"@Override\n    public List<ImageStoreVO> findImageCacheByScope(ZoneScope scope) {\n        SearchCriteria<ImageStoreVO> sc = createSearchCriteria();\n        sc.addAnd(\"role\", SearchCriteria.Op.EQ, DataStoreRole.ImageCache);\n        if (scope.getScopeId() != null) {\n            sc.addAnd(\"scope\", SearchCriteria.Op.EQ, ScopeType.ZONE);\n            sc.addAnd(\"dcId\", SearchCriteria.Op.EQ, scope.getScopeId());\n        }\n        return listBy(sc);\n    }","commit_id":"b9378ae5ad6e1b92d4954ec3228853e1a9b08e40","url":"https://github.com/apache/cloudstack"},{"original_method":"private void stopServing() throws IOException {\n    mDataServer.close();\n    mThriftServer.stop();\n    mThriftServerSocket.close();\n    mWorkerMetricsSystem.stop();\n    try {\n      mWebServer.shutdownWebServer();\n    } catch (Exception e) {\n      LOG.error(\"Failed to stop web server\", e);\n    }\n    mWorkerMetricsSystem.stop();\n\n    // TODO(binfan): investigate why we need to close dataserver again. There used to be a comment\n    // saying the reason to stop and close again is due to some issues in Thrift.\n    while (!mDataServer.isClosed()) {\n      mDataServer.close();\n      CommonUtils.sleepMs(100);\n    }\n  }","id":71791,"modified_method":"private void stopServing() throws IOException {\n    mDataServer.close();\n    mThriftServer.stop();\n    mThriftServerSocket.close();\n    try {\n      mWebServer.shutdownWebServer();\n    } catch (Exception e) {\n      LOG.error(\"Failed to stop web server\", e);\n    }\n    mWorkerMetricsSystem.stop();\n  }","commit_id":"f50a4888924a1d69e1e7bfcaa46bd0fb1f9d1964","url":"https://github.com/amplab/tachyon"},{"original_method":"protected LineageMasterClient getLineageMasterClient() {\n    return new LineageMasterClient(mLocalAlluxioClusterResource.get().getMaster().getAddress());\n  }","id":71792,"modified_method":"private LineageMasterClient getLineageMasterClient() {\n    return new LineageMasterClient(mLocalAlluxioClusterResource.get().getMaster().getAddress());\n  }","commit_id":"f50a4888924a1d69e1e7bfcaa46bd0fb1f9d1964","url":"https://github.com/amplab/tachyon"},{"original_method":"protected FileSystemMasterClient getFileSystemMasterClient() {\n    return new FileSystemMasterClient(mLocalAlluxioClusterResource.get().getMaster().getAddress());\n  }","id":71793,"modified_method":"private FileSystemMasterClient getFileSystemMasterClient() {\n    return new FileSystemMasterClient(mLocalAlluxioClusterResource.get().getMaster().getAddress());\n  }","commit_id":"f50a4888924a1d69e1e7bfcaa46bd0fb1f9d1964","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void close() throws IOException {\n    int quietPeriodSecs =\n        Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD);\n    int timeoutSecs = Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_TIMEOUT);\n    // TODO(binfan): investigate when timeoutSecs is zero (e.g., set in integration tests), does\n    // this still complete successfully.\n    mChannelFuture.channel().close().awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    mBootstrap.group().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS);\n    mBootstrap.childGroup().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS);\n  }","id":71794,"modified_method":"@Override\n  public void close() throws IOException {\n    int quietPeriodSecs =\n        Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_QUIET_PERIOD);\n    int timeoutSecs = Configuration.getInt(PropertyKey.WORKER_NETWORK_NETTY_SHUTDOWN_TIMEOUT);\n    mChannelFuture.channel().close().awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    mBootstrap.group().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS)\n        .awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n    mBootstrap.childGroup().shutdownGracefully(quietPeriodSecs, timeoutSecs, TimeUnit.SECONDS)\n        .awaitUninterruptibly(timeoutSecs, TimeUnit.SECONDS);\n  }","commit_id":"f50a4888924a1d69e1e7bfcaa46bd0fb1f9d1964","url":"https://github.com/amplab/tachyon"},{"original_method":"private void useProxy(boolean ssl, int skipPosition, int skipBytes, int flipPosition, boolean intermediateChange) throws Exception {\n        NetworkErrorProxy p = new NetworkErrorProxy(proxyPort, LOCALHOST, port);\n        p.skipBytes(skipPosition, skipBytes);\n        p.flipByte(flipPosition);\n        p.run();\n\n        NodeStore store = SegmentNodeStoreBuilders.builder(storeS).build();\n        final StandbyServerSync serverSync = new StandbyServerSync(port, storeS, ssl);\n        serverSync.start();\n        addTestContent(store, \"server\");\n        storeS.flush();  // this speeds up the test a little bit...\n\n        StandbyClientSync clientSync = newStandbyClientSync(storeC, proxyPort, ssl);\n        clientSync.run();\n\n        try {\n            if (skipBytes > 0 || flipPosition >= 0) {\n                assertFalse(\"stores are not expected to be equal\", storeS.getHead().equals(storeC.getHead()));\n                assertEquals(storeC2.getHead(), storeC.getHead());\n\n                p.reset();\n                if (intermediateChange) {\n                    addTestContent(store, \"server2\");\n                    storeS.flush();\n                }\n                clientSync.run();\n            }\n            assertEquals(storeS.getHead(), storeC.getHead());\n        } finally {\n            serverSync.close();\n            clientSync.close();\n            p.close();\n        }\n    }","id":71795,"modified_method":"private void useProxy(boolean ssl, int skipPosition, int skipBytes, int flipPosition, boolean intermediateChange) throws Exception {\n        NodeStore store = SegmentNodeStoreBuilders.builder(storeS).build();\n        addTestContent(store, \"server\");\n        storeS.flush();  // this speeds up the test a little bit...\n\n        try (\n                NetworkErrorProxy p = new NetworkErrorProxy(proxyPort, LOCALHOST, port);\n                StandbyServerSync serverSync = new StandbyServerSync(port, storeS, ssl);\n                StandbyClientSync clientSync = newStandbyClientSync(storeC, proxyPort, ssl);\n        ) {\n            p.skipBytes(skipPosition, skipBytes);\n            p.flipByte(flipPosition);\n            p.run();\n\n            serverSync.start();\n\n            clientSync.run();\n\n            if (skipBytes > 0 || flipPosition >= 0) {\n                assertFalse(\"stores are not expected to be equal\", storeS.getHead().equals(storeC.getHead()));\n                assertEquals(storeC2.getHead(), storeC.getHead());\n\n                p.reset();\n                if (intermediateChange) {\n                    addTestContent(store, \"server2\");\n                    storeS.flush();\n                }\n                clientSync.run();\n            }\n\n            assertEquals(storeS.getHead(), storeC.getHead());\n        }\n    }","commit_id":"c4ba50cd5e20e8eab3c8bd88e386b7e7f7872637","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void close() throws InterruptedException {\n        channel.close().sync();\n        channel = null;\n\n        group.shutdownGracefully();\n        group = null;\n    }","id":71796,"modified_method":"@Override\n    public void close() throws InterruptedException {\n        if (channel.close().awaitUninterruptibly(1, TimeUnit.SECONDS)) {\n            log.debug(\"Channel closed\");\n        } else {\n            log.debug(\"Channel close timed out\");\n        }\n\n        channel = null;\n\n        if (group.shutdownGracefully().awaitUninterruptibly(1, TimeUnit.SECONDS)) {\n            log.debug(\"Group shut down\");\n        } else {\n            log.debug(\"Group shutdown timed out\");\n        }\n\n        group = null;\n    }","commit_id":"c4ba50cd5e20e8eab3c8bd88e386b7e7f7872637","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void stop() {\n        channelFuture.channel().disconnect();\n    }","id":71797,"modified_method":"public void stop() {\n        if (channelFuture.channel().disconnect().awaitUninterruptibly(1, TimeUnit.SECONDS)) {\n            log.debug(\"Channel disconnected\");\n        } else {\n            log.debug(\"Channel disconnect timed out\");\n        }\n    }","commit_id":"c4ba50cd5e20e8eab3c8bd88e386b7e7f7872637","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void close() {\n        stop();\n\n        if (bossGroup != null && !bossGroup.isShuttingDown()) {\n            bossGroup.shutdownGracefully(0, 1, TimeUnit.SECONDS).syncUninterruptibly();\n        }\n        if (workerGroup != null && !workerGroup.isShuttingDown()) {\n            workerGroup.shutdownGracefully(0, 1, TimeUnit.SECONDS).syncUninterruptibly();\n        }\n    }","id":71798,"modified_method":"@Override\n    public void close() {\n        stop();\n\n        if (shutDown(bossGroup)) {\n            log.debug(\"Boss group shut down\");\n        } else {\n            log.debug(\"Boss group shutdown timed out\");\n        }\n\n        if (shutDown(workerGroup)) {\n            log.debug(\"Worker group shut down\");\n        } else {\n            log.debug(\"Worker group shutdown timed out\");\n        }\n    }","commit_id":"c4ba50cd5e20e8eab3c8bd88e386b7e7f7872637","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void start() {\n        channelFuture = b.bind(port);\n\n        if (channelFuture.awaitUninterruptibly(10, TimeUnit.SECONDS)) {\n            onTimelyConnect();\n        } else {\n            onConnectTimeOut();\n        }\n    }","id":71799,"modified_method":"public void start() {\n        channelFuture = b.bind(port);\n\n        if (channelFuture.awaitUninterruptibly(1, TimeUnit.SECONDS)) {\n            onTimelyConnect();\n        } else {\n            onConnectTimeOut();\n        }\n    }","commit_id":"c4ba50cd5e20e8eab3c8bd88e386b7e7f7872637","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@NotNull\n  public Iterable<PyElement> iterateNames() {\n    PyElement ret = getAsNameElement();\n    if (ret == null) {\n      List<PyExpression> unwound_path = PyResolveUtil.unwindQualifiers(getImportReferenceExpression());\n      if ((unwound_path != null) && (unwound_path.size() > 0)) ret = unwound_path.get(0);\n    }\n    if (ret == null) {\n      return EmptyIterable.getInstance();\n    }\n    return Collections.singleton(ret);\n  }","id":71800,"modified_method":"@NotNull\n  public Iterable<PyElement> iterateNames() {\n    PyElement ret = getAsNameElement();\n    if (ret == null) {\n      final PyReferenceExpression importReference = getImportReferenceExpression();\n      if (importReference != null) {\n        final List<PyExpression> qualifiers = PyResolveUtil.unwindQualifiers(importReference);\n        if (qualifiers.size() > 0) {\n          ret = qualifiers.get(0);\n        }\n      }\n    }\n    if (ret == null) {\n      return EmptyIterable.getInstance();\n    }\n    return Collections.singleton(ret);\n  }","commit_id":"4bc4192342f117caa3e293395bc5329b71f5c3ff","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPyImportElement(PyImportElement node) {\n      final PyStatement statement = node.getContainingImportStatement();\n      if (!(statement instanceof PyFromImportStatement)) return;\n      checkReference(node.getImportReferenceExpression(), ((PyFromImportStatement)statement).getImportSource());\n    }","id":71801,"modified_method":"@Override\n    public void visitPyImportElement(PyImportElement node) {\n      final PyStatement statement = node.getContainingImportStatement();\n      if (!(statement instanceof PyFromImportStatement)) return;\n      final PyReferenceExpression importReferenceExpression = node.getImportReferenceExpression();\n      final PyReferenceExpression importSource = ((PyFromImportStatement)statement).getImportSource();\n      if (importReferenceExpression != null && importSource != null)\n        checkReference(importReferenceExpression, importSource);\n    }","commit_id":"3e576c2cb0aff622ddda9633a8dc611f0b9a3136","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiFile addImportViaElement(String refText,\n                                             AutoImportQuickFix fix,\n                                             Set<String> seenFileNames,\n                                             PsiFile existingImportFile,\n                                             PyImportElement importElement,\n                                             PsiElement source) {\n    PsiElement sourceFile = PyUtil.turnDirIntoInit(source);\n    if (sourceFile instanceof PyFileImpl) {\n      seenFileNames.add(importElement.getImportReferenceExpression().getReferencedName());\n      PyFileImpl importSourceFile = (PyFileImpl)sourceFile;\n      PsiElement res = importSourceFile.findExportedName(refText);\n      // allow importing from this source if it either declares the name itself or represents a higher-level package that reexports the name\n      if (res != null && !(res instanceof PyFile) && !(res instanceof PyImportElement) &&\n          PsiTreeUtil.isAncestor(source, res.getContainingFile(), false)) {\n        existingImportFile = importSourceFile;\n        fix.addImport(res, importSourceFile, importElement);\n      }\n    }\n    return existingImportFile;\n  }","id":71802,"modified_method":"private static PsiFile addImportViaElement(String refText,\n                                             AutoImportQuickFix fix,\n                                             Set<String> seenFileNames,\n                                             PsiFile existingImportFile,\n                                             PyImportElement importElement,\n                                             PsiElement source) {\n    PsiElement sourceFile = PyUtil.turnDirIntoInit(source);\n    if (sourceFile instanceof PyFileImpl) {\n      PyReferenceExpression importReferenceExpression = importElement.getImportReferenceExpression();\n      if (importReferenceExpression != null) {\n        seenFileNames.add(importReferenceExpression.getReferencedName());\n      }\n      PyFileImpl importSourceFile = (PyFileImpl)sourceFile;\n      PsiElement res = importSourceFile.findExportedName(refText);\n      // allow importing from this source if it either declares the name itself or represents a higher-level package that reexports the name\n      if (res != null && !(res instanceof PyFile) && !(res instanceof PyImportElement) &&\n          PsiTreeUtil.isAncestor(source, res.getContainingFile(), false)) {\n        existingImportFile = importSourceFile;\n        fix.addImport(res, importSourceFile, importElement);\n      }\n    }\n    return existingImportFile;\n  }","commit_id":"f8fdb0e10f7a683cb76635c2e5c04f8cc83746fb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player != null) {\n            Card c = player.getLibrary().removeFromTop(game);\n            player.getHand().add(c);\n            Cards cards = new CardsImpl();\n            cards.add(c);\n            player.revealCards(\"Top card from library\", cards, game);\n            player.loseLife(c.getManaCost().convertedManaCost(), game);\n        }\n        return true;\n    }","id":71803,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player != null && player.getLibrary().size() > 0) {\n            Card card = player.getLibrary().removeFromTop(game);\n            if (card != null) {\n                card.moveToZone(Zone.HAND, source.getId(), game, false);\n                player.loseLife(card.getManaCost().convertedManaCost(), game);\n                Cards cards = new CardsImpl();\n                cards.add(card);\n                player.revealCards(\"top card from library by Dark Confidant\", cards, game);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"1e8a0f92ed8c68116522af66bcae7e7bf2aba5ad","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        if (player != null && player.getLibrary().size() > 0) {\n            Card card = player.getLibrary().removeFromTop(game);\n            if (card != null) {\n                card.moveToZone(Zone.HAND, source.getId(), game, false);\n                player.loseLife(card.getManaCost().convertedManaCost(), game);\n                Cards cards = new CardsImpl();\n                cards.add(card);\n                player.revealCards(\"top card from library by Dark Confidant\", cards, game);\n                return true;\n            }\n        }\n        return false;\n    }","id":71804,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player player = game.getPlayer(source.getControllerId());\n        Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());\n        if (player != null && sourcePermanent != null) {\n            if (player.getLibrary().size() > 0) {\n                Card card = player.getLibrary().removeFromTop(game);\n                if (card != null) {\n                    Cards cards = new CardsImpl();\n                    cards.add(card);\n                    player.revealCards(sourcePermanent.getName(), cards, game);\n                    player.moveCardToHandWithInfo(card, source.getSourceId(), game, Zone.LIBRARY);\n                    player.loseLife(card.getManaCost().convertedManaCost(), game);\n\n                }\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"47af2cab757f5ca65af737cde416a0d0ad8e06ba","url":"https://github.com/magefree/mage"},{"original_method":"public DelverOfSecrets(UUID ownerId) {\r\n        super(ownerId, 51, \"Delver of Secrets\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{U}\");\r\n        this.expansionSetCode = \"ISD\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        this.canTransform = true;\r\n        this.secondSideCard = new InsectileAberration(ownerId);\r\n\r\n        // At the beginning of your upkeep, look at the top card of your library. You may reveal that card. If an instant or sorcery card is revealed this way, transform Delver of Secrets.\r\n        this.addAbility(new TransformAbility());\r\n        this.addAbility(new DelverOfSecretsAbility());\r\n    }","id":71805,"modified_method":"public DelverOfSecrets(UUID ownerId) {\r\n        super(ownerId, 51, \"Delver of Secrets\", Rarity.COMMON, new CardType[]{CardType.CREATURE}, \"{U}\");\r\n        this.expansionSetCode = \"ISD\";\r\n        this.subtype.add(\"Human\");\r\n        this.subtype.add(\"Wizard\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(1);\r\n\r\n        this.canTransform = true;\r\n        this.secondSideCard = new InsectileAberration(ownerId);\r\n\r\n        // At the beginning of your upkeep, look at the top card of your library. You may reveal that card. If an instant or sorcery card is revealed this way, transform Delver of Secrets.\r\n        this.addAbility(new TransformAbility());\r\n        this.addAbility(new BeginningOfUpkeepTriggeredAbility(new DelverOfSecretsEffect(), TargetController.YOU, false));\r\n    }","commit_id":"47af2cab757f5ca65af737cde416a0d0ad8e06ba","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(source.getSourceId());\n        if (permanent != null) {\n            if (permanent.canTransform()) {\n                // check not to transform twice the same side\n                if (permanent.isTransformed() != fromDayToNight) {\n                    if (withoutTrigger) {\n                        permanent.setTransformed(fromDayToNight);\n                    } else {\n                        permanent.transform(game);\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }","id":71806,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Permanent permanent = game.getPermanent(source.getSourceId());\n        if (permanent != null) {\n            if (permanent.canTransform()) {\n                // check not to transform twice the same side\n                if (permanent.isTransformed() != fromDayToNight) {\n                    if (withoutTrigger) {                        \n                        permanent.setTransformed(fromDayToNight);\n                    } else {\n                        permanent.transform(game);\n                    }\n                    if (fromDayToNight) {\n                        game.informPlayers(new StringBuilder(permanent.getName()).append(\" transforms into \").append(permanent.getSecondCardFace().getName()).toString());                    \n                    } else {\n                        game.informPlayers(new StringBuilder(permanent.getSecondCardFace().getName()).append(\" transforms into \").append(permanent.getName()).toString());                    \n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }","commit_id":"47af2cab757f5ca65af737cde416a0d0ad8e06ba","url":"https://github.com/magefree/mage"},{"original_method":"public AzoriusHerald(UUID ownerId) {\r\n        super(ownerId, 6, \"Azorius Herald\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\r\n        this.expansionSetCode = \"C13\";\r\n        this.subtype.add(\"Spirit\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Azorius Herald can't be blocked.\r\n        this.addAbility(new UnblockableAbility());\r\n        // When Azorius Herald enters the battlefield, you gain 4 life.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(4)));\r\n        // When Azorius Herald enters the battlefield, sacrifice it unless {U} was spent to cast it.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessConditionEffect(new ManaWasSpentCondition(ColoredManaSymbol.U)), false));\r\n\r\n    }","id":71807,"modified_method":"public AzoriusHerald(UUID ownerId) {\r\n        super(ownerId, 6, \"Azorius Herald\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{W}\");\r\n        this.expansionSetCode = \"C13\";\r\n        this.subtype.add(\"Spirit\");\r\n\r\n        this.color.setWhite(true);\r\n        this.power = new MageInt(2);\r\n        this.toughness = new MageInt(1);\r\n\r\n        // Azorius Herald can't be blocked.\r\n        this.addAbility(new UnblockableAbility());\r\n        // When Azorius Herald enters the battlefield, you gain 4 life.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new GainLifeEffect(4)));\r\n        // When Azorius Herald enters the battlefield, sacrifice it unless {U} was spent to cast it.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessConditionEffect(new ManaWasSpentCondition(ColoredManaSymbol.U)), false));\r\n        this.addWatcher(new ManaSpentToCastWatcher());        \r\n    }","commit_id":"d27540a50249879a0830ca2e3128df99171a8410","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        for (Player player : game.getPlayers().values()) {\r\n            if (player != null) {\r\n                final int amount = game.getBattlefield().getAllActivePermanents(new FilterAttackingCreature(), player.getId(), game).size();\r\n                player.loseLife(amount, game);\r\n            }\r\n        }\r\n        return true;\r\n    }","id":71808,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            for (UUID playerId : controller.getInRange()) {\r\n                final int amount = game.getBattlefield().getAllActivePermanents(new FilterAttackingCreature(), playerId, game).size();\r\n                if (amount > 0) {\r\n                    Player player = game.getPlayer(playerId);\r\n                    if (player != null) {\r\n                        player.loseLife(amount, game);\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"d27540a50249879a0830ca2e3128df99171a8410","url":"https://github.com/magefree/mage"},{"original_method":"public BatwingBrume(UUID ownerId) {\r\n        super(ownerId, 81, \"Batwing Brume\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{W/B}\");\r\n        this.expansionSetCode = \"EVE\";\r\n\r\n        this.color.setBlack(true);\r\n        this.color.setWhite(true);\r\n\r\n        // Prevent all combat damage that would be dealt this turn if {W} was spent to cast Batwing Brume. Each player loses 1 life for each attacking creature he or she controls if {B} was spent to cast Batwing Brume.\r\n        this.getSpellAbility().addEffect(new ConditionalContinousEffect(\r\n                new PreventAllDamageByAllEffect(Duration.EndOfTurn, true),\r\n                new ManaWasSpentCondition(ColoredManaSymbol.W), \"Prevent all combat damage that would be dealt this turn if {W} was spent to cast {this}\", true));\r\n        this.getSpellAbility().addEffect(new ConditionalOneShotEffect(\r\n                new BatwingBrumeEffect(),\r\n                new ManaWasSpentCondition(ColoredManaSymbol.W), \"Each player loses 1 life for each attacking creature he or she controls if {B} was spent to cast {this}\"));\r\n        this.addInfo(\"Info1\", \"<i>(Do both if {W}{B} was spent.)<i>\");\r\n\r\n    }","id":71809,"modified_method":"public BatwingBrume(UUID ownerId) {\r\n        super(ownerId, 81, \"Batwing Brume\", Rarity.UNCOMMON, new CardType[]{CardType.INSTANT}, \"{1}{W/B}\");\r\n        this.expansionSetCode = \"EVE\";\r\n\r\n        this.color.setBlack(true);\r\n        this.color.setWhite(true);\r\n\r\n        // Prevent all combat damage that would be dealt this turn if {W} was spent to cast Batwing Brume. Each player loses 1 life for each attacking creature he or she controls if {B} was spent to cast Batwing Brume.\r\n        Effect effect = new ConditionalReplacementEffect(new PreventAllDamageByAllEffect(Duration.EndOfTurn, true),\r\n                new ManaWasSpentCondition(ColoredManaSymbol.W), true);\r\n        effect.setText(\"Prevent all combat damage that would be dealt this turn if {W} was spent to cast {this}\");\r\n        this.getSpellAbility().addEffect(effect);\r\n        this.getSpellAbility().addEffect(new ConditionalOneShotEffect(\r\n                new BatwingBrumeEffect(),\r\n                new ManaWasSpentCondition(ColoredManaSymbol.B), \"Each player loses 1 life for each attacking creature he or she controls if {B} was spent to cast {this}\"));\r\n        this.addInfo(\"Info1\", \"<i>(Do both if {W}{B} was spent.)<i>\");\r\n\r\n    }","commit_id":"d27540a50249879a0830ca2e3128df99171a8410","url":"https://github.com/magefree/mage"},{"original_method":"public CourtHussar(UUID ownerId) {\r\n        super(ownerId, 43, \"Court Hussar\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{U}\");\r\n        this.expansionSetCode = \"CMD\";\r\n        this.subtype.add(\"Vedalken\");\r\n        this.subtype.add(\"Knight\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // Vigilance\r\n        this.addAbility(VigilanceAbility.getInstance());\r\n        // When Court Hussar enters the battlefield, look at the top three cards of your library, then put one of them into your hand and the rest on the bottom of your library in any order.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(\r\n                new LookLibraryAndPickControllerEffect(new StaticValue(3), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false),\r\n                false));\r\n        // When Court Hussar enters the battlefield, sacrifice it unless {W} was spent to cast it.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessConditionEffect(new ManaWasSpentCondition(ColoredManaSymbol.W)), false));\r\n    }","id":71810,"modified_method":"public CourtHussar(UUID ownerId) {\r\n        super(ownerId, 43, \"Court Hussar\", Rarity.UNCOMMON, new CardType[]{CardType.CREATURE}, \"{2}{U}\");\r\n        this.expansionSetCode = \"CMD\";\r\n        this.subtype.add(\"Vedalken\");\r\n        this.subtype.add(\"Knight\");\r\n\r\n        this.color.setBlue(true);\r\n        this.power = new MageInt(1);\r\n        this.toughness = new MageInt(3);\r\n\r\n        // Vigilance\r\n        this.addAbility(VigilanceAbility.getInstance());\r\n        // When Court Hussar enters the battlefield, look at the top three cards of your library, then put one of them into your hand and the rest on the bottom of your library in any order.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(\r\n                new LookLibraryAndPickControllerEffect(new StaticValue(3), false, new StaticValue(1), new FilterCard(), Zone.LIBRARY, false, false),\r\n                false));\r\n        // When Court Hussar enters the battlefield, sacrifice it unless {W} was spent to cast it.\r\n        this.addAbility(new EntersBattlefieldTriggeredAbility(new SacrificeSourceUnlessConditionEffect(new ManaWasSpentCondition(ColoredManaSymbol.W)), false));\r\n        this.addWatcher(new ManaSpentToCastWatcher());\r\n    }","commit_id":"d27540a50249879a0830ca2e3128df99171a8410","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        return (source.getManaCostsToPay().getPayment().getColor(coloredManaSymbol) > 0);\r\n    }","id":71811,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        if (source.getAbilityType().equals(AbilityType.SPELL)) {\r\n            return (source.getManaCostsToPay().getPayment().getColor(coloredManaSymbol) > 0);\r\n        }\r\n        ManaSpentToCastWatcher watcher = (ManaSpentToCastWatcher) game.getState().getWatchers().get(\"ManaSpentToCast\", source.getSourceId());\r\n        if (watcher != null) {\r\n            Mana payment = watcher.getAndResetLastPayment();\r\n            if (payment != null) {\r\n                return payment.getColor(coloredManaSymbol) > 0;\r\n            }\r\n        }\r\n        return false;\r\n    }","commit_id":"d27540a50249879a0830ca2e3128df99171a8410","url":"https://github.com/magefree/mage"},{"original_method":"static HighlightInfo checkUnrelatedDefaultMethods(@NotNull PsiClass aClass,\n                                                    @NotNull PsiIdentifier classIdentifier) {\n    final Map<? extends MethodSignature, Set<PsiMethod>> overrideEquivalent = PsiSuperMethodUtil.collectOverrideEquivalents(aClass);\n\n    final boolean isInterface = aClass.isInterface();\n    for (Set<PsiMethod> overrideEquivalentMethods : overrideEquivalent.values()) {\n      if (overrideEquivalentMethods.size() <= 1) continue;\n      List<PsiMethod> defaults = null;\n      List<PsiMethod> astracts = null;\n      boolean hasConcrete = false;\n      for (PsiMethod method : overrideEquivalentMethods) {\n        final boolean isDefault = method.hasModifierProperty(PsiModifier.DEFAULT);\n        final boolean isAbstract = method.hasModifierProperty(PsiModifier.ABSTRACT);\n        if (isDefault) {\n          if (defaults == null) defaults = new ArrayList<>(2);\n          defaults.add(method);\n        }\n        if (isAbstract) {\n          if (astracts == null) astracts = new ArrayList<>(2);\n          astracts.add(method);\n        }\n        hasConcrete |= !isDefault && !isAbstract;\n      }\n\n      if (!hasConcrete && defaults != null) {\n        final PsiMethod defaultMethod = defaults.get(0);\n        final PsiClass defaultMethodContainingClass = defaultMethod.getContainingClass();\n        if (defaultMethodContainingClass == null) continue;\n        final PsiMethod unrelatedMethod = astracts != null ? astracts.get(0) : defaults.get(1);\n        final PsiClass unrelatedMethodContainingClass = unrelatedMethod.getContainingClass();\n        if (unrelatedMethodContainingClass == null) continue;\n        if (!aClass.hasModifierProperty(PsiModifier.ABSTRACT) && !(aClass instanceof PsiTypeParameter) \n            && astracts != null && unrelatedMethodContainingClass.isInterface()) {\n          if (defaultMethodContainingClass.isInheritor(unrelatedMethodContainingClass, true) && \n              MethodSignatureUtil.isSubsignature(unrelatedMethod.getSignature(TypeConversionUtil.getSuperClassSubstitutor(unrelatedMethodContainingClass, defaultMethodContainingClass, PsiSubstitutor.EMPTY)), \n                                                 defaultMethod.getSignature(PsiSubstitutor.EMPTY))) {\n            continue;\n          }\n          final String key = aClass instanceof PsiEnumConstantInitializer ? \"enum.constant.should.implement.method\" : \"class.must.be.abstract\";\n          final String message = JavaErrorMessages.message(key, HighlightUtil.formatClass(aClass, false), JavaHighlightUtil.formatMethod(astracts.get(0)), \n                                                           HighlightUtil.formatClass(unrelatedMethodContainingClass, false));\n          final HighlightInfo info = HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(message).create();\n          QuickFixAction.registerQuickFixAction(info, QUICK_FIX_FACTORY.createImplementMethodsFix(aClass));\n          return info;\n        }\n        if (isInterface || astracts == null || unrelatedMethodContainingClass.isInterface()) {\n          if (defaultMethodContainingClass.isInheritor(unrelatedMethodContainingClass, true) || \n              unrelatedMethodContainingClass.isInheritor(defaultMethodContainingClass, true)) {\n            continue;\n          }\n          final String message = astracts != null ? \" inherits abstract and default for \" : \" inherits unrelated defaults for \";\n          final HighlightInfo info = HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(\n            HighlightUtil.formatClass(aClass) +\n            message +\n            JavaHighlightUtil.formatMethod(defaultMethod) +\n            \" from types \" +\n            HighlightUtil.formatClass(defaultMethodContainingClass) +\n            \" and \" +\n            HighlightUtil.formatClass(unrelatedMethodContainingClass))\n            .create();\n          QuickFixAction.registerQuickFixAction(info, QUICK_FIX_FACTORY.createImplementMethodsFix(aClass));\n          return info;\n        }\n      }\n    }\n    return null;\n  }","id":71812,"modified_method":"static HighlightInfo checkUnrelatedDefaultMethods(@NotNull PsiClass aClass,\n                                                    @NotNull PsiIdentifier classIdentifier) {\n    final Map<? extends MethodSignature, Set<PsiMethod>> overrideEquivalent = PsiSuperMethodUtil.collectOverrideEquivalents(aClass);\n\n    final boolean isInterface = aClass.isInterface();\n    for (Set<PsiMethod> overrideEquivalentMethods : overrideEquivalent.values()) {\n      if (overrideEquivalentMethods.size() <= 1) continue;\n      List<PsiMethod> defaults = null;\n      List<PsiMethod> abstracts = null;\n      boolean hasConcrete = false;\n      for (PsiMethod method : overrideEquivalentMethods) {\n        final boolean isDefault = method.hasModifierProperty(PsiModifier.DEFAULT);\n        final boolean isAbstract = method.hasModifierProperty(PsiModifier.ABSTRACT);\n        if (isDefault) {\n          if (defaults == null) defaults = new ArrayList<>(2);\n          defaults.add(method);\n        }\n        if (isAbstract) {\n          if (abstracts == null) abstracts = new ArrayList<>(2);\n          abstracts.add(method);\n        }\n        hasConcrete |= !isDefault && !isAbstract;\n      }\n\n      if (!hasConcrete && defaults != null) {\n        final PsiMethod defaultMethod = defaults.get(0);\n        final PsiClass defaultMethodContainingClass = defaultMethod.getContainingClass();\n        if (defaultMethodContainingClass == null) continue;\n        final PsiMethod unrelatedMethod = abstracts != null ? abstracts.get(0) : defaults.get(1);\n        final PsiClass unrelatedMethodContainingClass = unrelatedMethod.getContainingClass();\n        if (unrelatedMethodContainingClass == null) continue;\n        if (!aClass.hasModifierProperty(PsiModifier.ABSTRACT) && !(aClass instanceof PsiTypeParameter) \n            && abstracts != null && unrelatedMethodContainingClass.isInterface()) {\n          if (defaultMethodContainingClass.isInheritor(unrelatedMethodContainingClass, true) && \n              MethodSignatureUtil.isSubsignature(unrelatedMethod.getSignature(TypeConversionUtil.getSuperClassSubstitutor(unrelatedMethodContainingClass, defaultMethodContainingClass, PsiSubstitutor.EMPTY)), \n                                                 defaultMethod.getSignature(PsiSubstitutor.EMPTY))) {\n            continue;\n          }\n          final String key = aClass instanceof PsiEnumConstantInitializer ? \"enum.constant.should.implement.method\" : \"class.must.be.abstract\";\n          final String message = JavaErrorMessages.message(key, HighlightUtil.formatClass(aClass, false), JavaHighlightUtil.formatMethod(abstracts.get(0)),\n                                                           HighlightUtil.formatClass(unrelatedMethodContainingClass, false));\n          final HighlightInfo info = HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(message).create();\n          QuickFixAction.registerQuickFixAction(info, QUICK_FIX_FACTORY.createImplementMethodsFix(aClass));\n          return info;\n        }\n        if (isInterface || abstracts == null || unrelatedMethodContainingClass.isInterface()) {\n          final List<PsiClass> defaultContainingClasses = ContainerUtil.mapNotNull(defaults, PsiMethod::getContainingClass);\n          final String unrelatedDefaults = hasUnrelatedDefaults(defaultContainingClasses);\n          if (unrelatedDefaults == null &&\n              (abstracts == null || !hasNotOverriddenAbstract(defaultContainingClasses, unrelatedMethodContainingClass))) {\n            continue;\n          }\n\n          final String message = unrelatedDefaults != null ? \" inherits unrelated defaults for \" : \" inherits abstract and default for \";\n          final HighlightInfo info = HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(classIdentifier).descriptionAndTooltip(\n            HighlightUtil.formatClass(aClass) +\n            message +\n            JavaHighlightUtil.formatMethod(defaultMethod) + \" from types \" +\n            (unrelatedDefaults != null ? unrelatedDefaults\n                                       : HighlightUtil.formatClass(defaultMethodContainingClass) + \" and \" + HighlightUtil.formatClass(unrelatedMethodContainingClass)))\n            .create();\n          QuickFixAction.registerQuickFixAction(info, QUICK_FIX_FACTORY.createImplementMethodsFix(aClass));\n          return info;\n        }\n      }\n    }\n    return null;\n  }","commit_id":"0e3d077bfe09a3a9a83c544f0f09ffa26883326b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static HighlightInfo checkMemberReferencedBeforeConstructorCalled(PsiElement expression) {\n    if (expression.getParent() instanceof PsiJavaCodeReferenceElement) return null;\n    PsiClass referencedClass;\n    String resolvedName;\n    PsiType type;\n    if (expression instanceof PsiJavaCodeReferenceElement) {\n      PsiElement resolved = ((PsiJavaCodeReferenceElement)expression).advancedResolve(true).getElement();\n      // redirected ctr\n      if (PsiKeyword.THIS.equals(((PsiJavaCodeReferenceElement)expression).getReferenceName())\n          && resolved instanceof PsiMethod\n          && ((PsiMethod)resolved).isConstructor()) return null;\n      PsiElement qualifier = ((PsiJavaCodeReferenceElement)expression).getQualifier();\n      type = qualifier instanceof PsiExpression ? ((PsiExpression)qualifier).getType() : null;\n      referencedClass = PsiUtil.resolveClassInType(type);\n\n      boolean isSuperCall = isSuperMethodCall(expression.getParent());\n      if (resolved == null && isSuperCall) {\n        if (qualifier instanceof PsiReferenceExpression) {\n          resolved = ((PsiReferenceExpression)qualifier).resolve();\n          expression = qualifier;\n          type = ((PsiReferenceExpression)qualifier).getType();\n          referencedClass = PsiUtil.resolveClassInType(type);\n        }\n        else if (qualifier instanceof PsiThisExpression || qualifier == null) {\n          resolved = PsiTreeUtil.getParentOfType(expression, PsiMethod.class, true, PsiMember.class);\n          expression = qualifier == null ? expression : qualifier;\n          if (resolved instanceof PsiMethod) {\n            referencedClass = ((PsiMethod)resolved).getContainingClass();\n          }\n        }\n      }\n      if (resolved instanceof PsiField) {\n        PsiField referencedField = (PsiField)resolved;\n        if (referencedField.hasModifierProperty(PsiModifier.STATIC)) return null;\n        resolvedName = PsiFormatUtil.formatVariable(referencedField, PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME, PsiSubstitutor.EMPTY);\n        referencedClass = referencedField.getContainingClass();\n      }\n      else if (resolved instanceof PsiMethod) {\n        PsiMethod method = (PsiMethod)resolved;\n        if (method.hasModifierProperty(PsiModifier.STATIC)) return null;\n        PsiElement nameElement = expression instanceof PsiThisExpression ? expression : ((PsiJavaCodeReferenceElement)expression).getReferenceNameElement();\n        String name = nameElement == null ? null : nameElement.getText();\n        if (isSuperCall) {\n          if (referencedClass == null) return null;\n          if (qualifier == null) {\n            PsiClass superClass = referencedClass.getSuperClass();\n            if (superClass != null\n                && PsiUtil.isInnerClass(superClass)\n                && InheritanceUtil.isInheritorOrSelf(referencedClass, superClass.getContainingClass(), true)) {\n              // by default super() is considered this. - qualified\n              resolvedName = PsiKeyword.THIS;\n            }\n            else {\n              return null;\n            }\n          }\n          else {\n            resolvedName = qualifier.getText();\n          }\n        }\n        else if (PsiKeyword.THIS.equals(name))  {\n          resolvedName = PsiKeyword.THIS;\n        }\n        else {\n          resolvedName = PsiFormatUtil.formatMethod(method, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME, 0);\n          if (referencedClass == null) referencedClass = method.getContainingClass();\n        }\n      }\n      else if (resolved instanceof PsiClass) {\n        PsiClass aClass = (PsiClass)resolved;\n        if (aClass.hasModifierProperty(PsiModifier.STATIC)) return null;\n        referencedClass = aClass.getContainingClass();\n        if (referencedClass == null) return null;\n        resolvedName = PsiFormatUtil.formatClass(aClass, PsiFormatUtil.SHOW_NAME);\n      }\n      else {\n        return null;\n      }\n    }\n    else if (expression instanceof PsiThisExpression) {\n      type = ((PsiThisExpression)expression).getType();\n      referencedClass = PsiUtil.resolveClassInType(type);\n      resolvedName = referencedClass == null\n                     ? null\n                     : PsiFormatUtil.formatClass(referencedClass, PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME);\n    }\n    else {\n      return null;\n    }\n    if (referencedClass == null) return null;\n    return checkReferenceToOurInstanceInsideThisOrSuper(expression, referencedClass, resolvedName);\n  }","id":71813,"modified_method":"@Nullable\n  public static HighlightInfo checkMemberReferencedBeforeConstructorCalled(PsiElement expression) {\n    PsiClass referencedClass;\n    @NonNls String resolvedName;\n    PsiType type;\n    if (expression instanceof PsiJavaCodeReferenceElement) {\n      PsiElement resolved = ((PsiJavaCodeReferenceElement)expression).advancedResolve(true).getElement();\n      // redirected ctr\n      if (PsiKeyword.THIS.equals(((PsiJavaCodeReferenceElement)expression).getReferenceName())\n          && resolved instanceof PsiMethod\n          && ((PsiMethod)resolved).isConstructor()) return null;\n      PsiElement qualifier = ((PsiJavaCodeReferenceElement)expression).getQualifier();\n      type = qualifier instanceof PsiExpression ? ((PsiExpression)qualifier).getType() : null;\n      referencedClass = PsiUtil.resolveClassInType(type);\n\n      boolean isSuperCall = isSuperMethodCall(expression.getParent());\n      if (resolved == null && isSuperCall) {\n        if (qualifier instanceof PsiReferenceExpression) {\n          resolved = ((PsiReferenceExpression)qualifier).resolve();\n          expression = qualifier;\n          type = ((PsiReferenceExpression)qualifier).getType();\n          referencedClass = PsiUtil.resolveClassInType(type);\n        }\n        else if (qualifier instanceof PsiThisExpression || qualifier == null) {\n          resolved = PsiTreeUtil.getParentOfType(expression, PsiMethod.class, true, PsiMember.class);\n          expression = qualifier == null ? expression : qualifier;\n          if (resolved instanceof PsiMethod) {\n            referencedClass = ((PsiMethod)resolved).getContainingClass();\n          }\n        }\n      }\n      if (resolved instanceof PsiField) {\n        PsiField referencedField = (PsiField)resolved;\n        if (referencedField.hasModifierProperty(PsiModifier.STATIC)) return null;\n        resolvedName = PsiFormatUtil.formatVariable(referencedField, PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME, PsiSubstitutor.EMPTY);\n        referencedClass = referencedField.getContainingClass();\n      }\n      else if (resolved instanceof PsiMethod) {\n        PsiMethod method = (PsiMethod)resolved;\n        if (method.hasModifierProperty(PsiModifier.STATIC)) return null;\n        PsiElement nameElement = expression instanceof PsiThisExpression ? expression : ((PsiJavaCodeReferenceElement)expression).getReferenceNameElement();\n        String name = nameElement == null ? null : nameElement.getText();\n        if (isSuperCall) {\n          if (referencedClass == null) return null;\n          if (qualifier == null) {\n            PsiClass superClass = referencedClass.getSuperClass();\n            if (superClass != null\n                && PsiUtil.isInnerClass(superClass)\n                && InheritanceUtil.isInheritorOrSelf(referencedClass, superClass.getContainingClass(), true)) {\n              // by default super() is considered this. - qualified\n              resolvedName = PsiKeyword.THIS;\n            }\n            else {\n              return null;\n            }\n          }\n          else {\n            resolvedName = qualifier.getText();\n          }\n        }\n        else if (PsiKeyword.THIS.equals(name))  {\n          resolvedName = PsiKeyword.THIS;\n        }\n        else {\n          resolvedName = PsiFormatUtil.formatMethod(method, PsiSubstitutor.EMPTY, PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME, 0);\n          if (referencedClass == null) referencedClass = method.getContainingClass();\n        }\n      }\n      else if (resolved instanceof PsiClass) {\n        PsiClass aClass = (PsiClass)resolved;\n        if (aClass.hasModifierProperty(PsiModifier.STATIC)) return null;\n        referencedClass = aClass.getContainingClass();\n        if (referencedClass == null) return null;\n        resolvedName = PsiFormatUtil.formatClass(aClass, PsiFormatUtil.SHOW_NAME);\n      }\n      else {\n        return null;\n      }\n    }\n    else if (expression instanceof PsiThisExpression) {\n      PsiThisExpression thisExpression = (PsiThisExpression)expression;\n      type = thisExpression.getType();\n      referencedClass = PsiUtil.resolveClassInType(type);\n      if (thisExpression.getQualifier() != null) {\n        resolvedName = referencedClass == null\n                       ? null\n                       : PsiFormatUtil.formatClass(referencedClass, PsiFormatUtil.SHOW_CONTAINING_CLASS | PsiFormatUtil.SHOW_NAME) + \".this\";\n      }\n      else {\n        resolvedName = \"this\";\n      }\n    }\n    else {\n      return null;\n    }\n    if (referencedClass == null) return null;\n    return checkReferenceToOurInstanceInsideThisOrSuper(expression, referencedClass, resolvedName);\n  }","commit_id":"b532bb34e0001ce4586cfb1e9f4066624a05d370","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void shareFavourites() {\n\t\tif (favouritesAdapter.isEmpty()) {\n\t\t\tToast.makeText(getActivity(), R.string.no_fav_to_save, Toast.LENGTH_LONG).show();\n\t\t} else {\n\t\t\tfinal AsyncTask<Void, Void, GPXFile> exportTask = new AsyncTask<Void, Void, GPXFile>() {\n\t\t\t\t@Override\n\t\t\t\tprotected GPXFile doInBackground(Void... params) {\n\t\t\t\t\treturn helper.asGpxFile();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPreExecute() {\n\t\t\t\t\tshowProgressBar();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPostExecute(GPXFile gpxFile) {\n\t\t\t\t\thideProgressBar();\n\t\t\t\t\tFile dir = new File(getActivity().getCacheDir(), \"share\");\n\t\t\t\t\tif (!dir.exists()) {\n\t\t\t\t\t\tdir.mkdir();\n\t\t\t\t\t}\n\t\t\t\t\tFile src = helper.getExternalFile();\n\t\t\t\t\tFile dst = new File(dir, src.getName());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAlgorithms.fileCopy(src, dst);\n\t\t\t\t\t\tfinal Intent sendIntent = new Intent();\n\t\t\t\t\t\tsendIntent.setAction(Intent.ACTION_SEND);\n\t\t\t\t\t\tsendIntent.putExtra(Intent.EXTRA_TEXT, \"Content of the attached file Favourites.gpx:\\n\\n\\n\" + GPXUtilities.asString(gpxFile, getMyApplication()));\n\t\t\t\t\t\tsendIntent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.share_fav_subject));\n\t\t\t\t\t\tsendIntent.putExtra(Intent.EXTRA_STREAM,\n\t\t\t\t\t\t\t\tFileProvider.getUriForFile(getActivity(),\n\t\t\t\t\t\t\t\t\t\tgetActivity().getPackageName() + \".fileprovider\", dst));\n\t\t\t\t\t\tsendIntent.setType(\"text/plain\");\n\t\t\t\t\t\tstartActivity(sendIntent);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t//Toast.makeText(getActivity(), \"Error sharing favorites: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\texportTask.execute();\n\t\t}\n\t}","id":71814,"modified_method":"private void shareFavourites() {\n\t\tif (favouritesAdapter.isEmpty()) {\n\t\t\tToast.makeText(getActivity(), R.string.no_fav_to_save, Toast.LENGTH_LONG).show();\n\t\t} else {\n\t\t\tfinal AsyncTask<Void, Void, GPXFile> exportTask = new AsyncTask<Void, Void, GPXFile>() {\n\t\t\t\t@Override\n\t\t\t\tprotected GPXFile doInBackground(Void... params) {\n\t\t\t\t\treturn helper.asGpxFile();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPreExecute() {\n\t\t\t\t\tshowProgressBar();\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tprotected void onPostExecute(GPXFile gpxFile) {\n\t\t\t\t\thideProgressBar();\n\t\t\t\t\tFile dir = new File(getActivity().getCacheDir(), \"share\");\n\t\t\t\t\tif (!dir.exists()) {\n\t\t\t\t\t\tdir.mkdir();\n\t\t\t\t\t}\n\t\t\t\t\tFile src = helper.getExternalFile();\n\t\t\t\t\tFile dst = new File(dir, src.getName());\n\t\t\t\t\ttry {\n\t\t\t\t\t\tAlgorithms.fileCopy(src, dst);\n\t\t\t\t\t\tfinal Intent sendIntent = new Intent();\n\t\t\t\t\t\tsendIntent.setAction(Intent.ACTION_SEND);\n\t\t\t\t\t\tsendIntent.putExtra(Intent.EXTRA_TEXT, Html.fromHtml(generateHtmlPrint().toString()));\n\t\t\t\t\t\tsendIntent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.share_fav_subject));\n\t\t\t\t\t\tsendIntent.putExtra(Intent.EXTRA_STREAM,\n\t\t\t\t\t\t\t\tFileProvider.getUriForFile(getActivity(),\n\t\t\t\t\t\t\t\t\t\tgetActivity().getPackageName() + \".fileprovider\", dst));\n\t\t\t\t\t\tsendIntent.setType(\"text/plain\");\n\t\t\t\t\t\tstartActivity(sendIntent);\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t//Toast.makeText(getActivity(), \"Error sharing favorites: \" + e.getMessage(), Toast.LENGTH_LONG).show();\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\texportTask.execute();\n\t\t}\n\t}","commit_id":"07a73c38bdb2de479a60db98d487f9b859617a31","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public List<RouteDirectionInfo> getRouteDirections() {\n\t\tif(currentDirectionInfo < directions.size() - 1){\n\t\t\tif(cacheCurrentTextDirectionInfo != currentDirectionInfo) {\n\t\t\t\tcacheCurrentTextDirectionInfo = currentDirectionInfo;\n\t\t\t\tList<RouteDirectionInfo> list = currentDirectionInfo == 0 ? directions : \n\t\t\t\t\tdirections.subList(currentDirectionInfo + 1, directions.size());\n\t\t\t\tcacheAgreggatedDirections = new ArrayList<RouteDirectionInfo>();\n\t\t\t\tRouteDirectionInfo p = null;\n\t\t\t\tfor(RouteDirectionInfo i : list) {\n//\t\t\t\t\tif(p == null || !i.getTurnType().isSkipToSpeak() ||\n//\t\t\t\t\t\t\t(!Algorithms.objectEquals(p.getRef(), i.getRef()) &&\n//\t\t\t\t\t\t\t\t\t!Algorithms.objectEquals(p.getStreetName(), i.getStreetName()))) {\n\t\t\t\t\tif(i.getTurnType() != null && !i.getTurnType().isSkipToSpeak()) {\n\t\t\t\t\t\tp = new RouteDirectionInfo(i.getAverageSpeed(), i.getTurnType());\n\t\t\t\t\t\tp.routePointOffset = i.routePointOffset;\n\t\t\t\t\t\tp.routeEndPointOffset = i.routeEndPointOffset;\n\t\t\t\t\t\tp.setDestinationName(i.getDestinationName());\n\t\t\t\t\t\tp.setRef(i.getRef());\n\t\t\t\t\t\tp.setStreetName(i.getStreetName());\n\t\t\t\t\t\tp.setDescriptionRoute(i.getDescriptionRoutePart());\n\t\t\t\t\t\tcacheAgreggatedDirections.add(p);\n\t\t\t\t\t}\n\t\t\t\t\tfloat time = i.getExpectedTime() + p.getExpectedTime();\n\t\t\t\t\tp.distance += i.distance;\n\t\t\t\t\tp.setAverageSpeed(p.distance / time);\n\t\t\t\t\tp.afterLeftTime = i.afterLeftTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cacheAgreggatedDirections;\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","id":71815,"modified_method":"public List<RouteDirectionInfo> getRouteDirections() {\n\t\tif(currentDirectionInfo < directions.size() - 1){\n\t\t\tif(cacheCurrentTextDirectionInfo != currentDirectionInfo) {\n\t\t\t\tcacheCurrentTextDirectionInfo = currentDirectionInfo;\n\t\t\t\tList<RouteDirectionInfo> list = currentDirectionInfo == 0 ? directions : \n\t\t\t\t\tdirections.subList(currentDirectionInfo + 1, directions.size());\n\t\t\t\tcacheAgreggatedDirections = new ArrayList<RouteDirectionInfo>();\n\t\t\t\tRouteDirectionInfo p = null;\n\t\t\t\tfor(RouteDirectionInfo i : list) {\n//\t\t\t\t\tif(p == null || !i.getTurnType().isSkipToSpeak() ||\n//\t\t\t\t\t\t\t(!Algorithms.objectEquals(p.getRef(), i.getRef()) &&\n//\t\t\t\t\t\t\t\t\t!Algorithms.objectEquals(p.getStreetName(), i.getStreetName()))) {\n\t\t\t\t\tif(p == null || \n\t\t\t\t\t\t\t(i.getTurnType() != null && !i.getTurnType().isSkipToSpeak())) {\n\t\t\t\t\t\tp = new RouteDirectionInfo(i.getAverageSpeed(), i.getTurnType());\n\t\t\t\t\t\tp.routePointOffset = i.routePointOffset;\n\t\t\t\t\t\tp.routeEndPointOffset = i.routeEndPointOffset;\n\t\t\t\t\t\tp.setDestinationName(i.getDestinationName());\n\t\t\t\t\t\tp.setRef(i.getRef());\n\t\t\t\t\t\tp.setStreetName(i.getStreetName());\n\t\t\t\t\t\tp.setDescriptionRoute(i.getDescriptionRoutePart());\n\t\t\t\t\t\tcacheAgreggatedDirections.add(p);\n\t\t\t\t\t}\n\t\t\t\t\tfloat time = i.getExpectedTime() + p.getExpectedTime();\n\t\t\t\t\tp.distance += i.distance;\n\t\t\t\t\tp.setAverageSpeed(p.distance / time);\n\t\t\t\t\tp.afterLeftTime = i.afterLeftTime;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cacheAgreggatedDirections;\n\t\t}\n\t\treturn Collections.emptyList();\n\t}","commit_id":"07a73c38bdb2de479a60db98d487f9b859617a31","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tif (item.getItemId() == SAVE) {\n\t\t\tMapActivityActions.createSaveDirections(ShowRouteInfoActivity.this, helper).show();\n\t\t\treturn true;\n\t\t}\n        if (item.getItemId() == SHARE) {\n              final GPXFile gpx = helper.generateGPXFileWithRoute();\n\n              final Intent sendIntent = new Intent();\n              sendIntent.setAction(Intent.ACTION_SEND);\n              sendIntent.putExtra(Intent.EXTRA_TEXT, GPXUtilities.asString(gpx, getMyApplication()));\n              sendIntent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.share_route_subject));\n              sendIntent.setType(\"application/gpx+xml\");\n              startActivity(sendIntent);\n            return true;\n        }\n        if (item.getItemId() == PRINT) {\n        \tprint();\n          return true;\n      }\n\n\t\treturn super.onOptionsItemSelected(item);\n\t}","id":71816,"modified_method":"@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tif (item.getItemId() == SAVE) {\n\t\t\tMapActivityActions.createSaveDirections(ShowRouteInfoActivity.this, helper).show();\n\t\t\treturn true;\n\t\t}\n\t\tif (item.getItemId() == SHARE) {\n\t\t\tfinal GPXFile gpx = helper.generateGPXFileWithRoute();\n\t\t\tfinal Uri fileUri = Uri.fromFile(new File(gpx.path));\n\t\t\tFile dir = new File(ShowRouteInfoActivity.this.getCacheDir(), \"share\");\n\t\t\tif (!dir.exists()) {\n\t\t\t\tdir.mkdir();\n\t\t\t}\n\t\t\tFile dst = new File(dir, \"route.gpx\");\n\t\t\ttry {\n\t\t\t\tFileWriter fw = new FileWriter(dst);\n\t\t\t\tGPXUtilities.writeGpx(fw, gpx, getMyApplication());\n\t\t\t\tfw.close();\n\t\t\t\tfinal Intent sendIntent = new Intent();\n\t\t\t\tsendIntent.setAction(Intent.ACTION_SEND);\n\t\t\t\tsendIntent.putExtra(Intent.EXTRA_TEXT, Html.fromHtml(generateHtml(((RouteInfoAdapter)getListAdapter()), \n\t\t\t\t\t\thelper.getGeneralRouteInformation()).toString()));\n\t\t\t\tsendIntent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.share_route_subject));\n\t\t\t\tsendIntent.putExtra(Intent.EXTRA_STREAM, fileUri);\n\t\t\t\tsendIntent.putExtra(\n\t\t\t\t\t\tIntent.EXTRA_STREAM,\n\t\t\t\t\t\tFileProvider.getUriForFile(ShowRouteInfoActivity.this,\n\t\t\t\t\t\t\t\tShowRouteInfoActivity.this.getPackageName() + \".fileprovider\", dst));\n\t\t\t\tsendIntent.setType(\"text/plain\");\n\t\t\t\tstartActivity(sendIntent);\n\t\t\t} catch (IOException e) {\n\t\t\t\t// Toast.makeText(getActivity(), \"Error sharing favorites: \" + e.getMessage(),\n\t\t\t\t// Toast.LENGTH_LONG).show();\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\tif (item.getItemId() == PRINT) {\n\t\t\tprint();\n\t\t\treturn true;\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}","commit_id":"07a73c38bdb2de479a60db98d487f9b859617a31","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private File generateRouteInfoHtml(RouteInfoAdapter routeInfo, String title) {\n\t\tFile file = null;\n\t\tif (routeInfo == null) {\n\t\t\treturn file;\n\t\t}\n\n\t\tfinal String FILE_NAME = \"route_info.html\";\n\t\tStringBuilder html = new StringBuilder();\n\t\thtml.append(\"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\");\n\t\thtml.append(\"<html xmlns=\\\"http://www.w3.org/1999/xhtml\\\" xml:lang=\\\"en\\\">\");\n\t\thtml.append(\"<head>\");\n\t\thtml.append(\"<title>Route info<\/title>\");\n\t\thtml.append(\"<meta http-equiv=\\\"Content-type\\\" content=\\\"text/html; charset=utf-8\\\" />\");\n\t\thtml.append(\"<style>\");\n\t\thtml.append(\"table, th, td {\");\n\t\thtml.append(\"border: 1px solid black;\");\n\t\thtml.append(\"border-collapse: collapse;}\");\n\t\thtml.append(\"th, td {\");\n\t\thtml.append(\"padding: 5px;}\");\n\t\thtml.append(\"<\/style>\");\n\t\thtml.append(\"<\/head>\");\n\t\thtml.append(\"<body>\");\n\n\t\tFileOutputStream fos = null;\n\t\ttry {\n\t\t\tif (!TextUtils.isEmpty(title)) {\n\t\t\t\thtml.append(\"<h1>\");\n\t\t\t\thtml.append(title);\n\t\t\t\thtml.append(\"<\/h1>\");\n\t\t\t}\n\t\t\thtml.append(\"<table style=\\\"width:100%\\\">\");\n\t\t\tfinal String NBSP = \"&nbsp;\";\n\t\t\tfinal String BR = \"<br>\";\n\t\t\tfor (int i = 0; i < routeInfo.getCount(); i++) {\n\t\t\t\tRouteDirectionInfo routeDirectionInfo = (RouteDirectionInfo) routeInfo\n\t\t\t\t\t\t.getItem(i);\n\t\t\t\thtml.append(\"<tr>\");\n\t\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\t\tsb.append(OsmAndFormatter.getFormattedDistance(\n\t\t\t\t\t\trouteDirectionInfo.distance, getMyApplication()));\n\t\t\t\tsb.append(\", \");\n\t\t\t\tsb.append(getTimeDescription(routeDirectionInfo));\n\t\t\t\tString distance = sb.toString().replaceAll(\"\\\\s\", NBSP);\n\t\t\t\thtml.append(\"<td>\");\n\t\t\t\thtml.append(distance);\n\t\t\t\thtml.append(\"<\/td>\");\n\t\t\t\tString description = routeDirectionInfo\n\t\t\t\t\t\t.getDescriptionRoutePart();\n\t\t\t\thtml.append(\"<td>\");\n\t\t\t\thtml.append(String.valueOf(i+1) + \". \" + description);\n\t\t\t\thtml.append(\"<\/td>\");\n\t\t\t\tRouteInfoAdapter.CumulativeInfo cumulativeInfo = routeInfo\n\t\t\t\t\t\t.getRouteDirectionCumulativeInfo(i);\n\t\t\t\thtml.append(\"<td>\");\n\t\t\t\tsb = new StringBuilder();\n\t\t\t\tsb.append(OsmAndFormatter.getFormattedDistance(\n\t\t\t\t\t\tcumulativeInfo.distance, getMyApplication()));\n\t\t\t\tsb.append(\" - \");\n\t\t\t\tsb.append(OsmAndFormatter.getFormattedDistance(\n\t\t\t\t\t\tcumulativeInfo.distance + routeDirectionInfo.distance,\n\t\t\t\t\t\tgetMyApplication()));\n\t\t\t\tsb.append(BR);\n\t\t\t\tsb.append(Algorithms.formatDuration(cumulativeInfo.time, getMyApplication().accessibilityEnabled()));\n\t\t\t\tsb.append(\" - \");\n\t\t\t\tsb.append(Algorithms.formatDuration(cumulativeInfo.time\n\t\t\t\t\t\t+ routeDirectionInfo.getExpectedTime(), getMyApplication().accessibilityEnabled()));\n\t\t\t\tString cumulativeTimeAndDistance = sb.toString().replaceAll(\"\\\\s\", NBSP);\n\t\t\t\thtml.append(cumulativeTimeAndDistance);\n\t\t\t\thtml.append(\"<\/td>\");\n\t\t\t\thtml.append(\"<\/tr>\");\n\t\t\t}\n\t\t\thtml.append(\"<\/table>\");\n\t\t\thtml.append(\"<\/body>\");\n\t\t\thtml.append(\"<\/html>\");\n\n\t\t\tfile = ((OsmandApplication) getApplication()).getAppPath(FILE_NAME);\n\t\t\tfos = new FileOutputStream(file);\n\t\t\tfos.write(html.toString().getBytes(\"UTF-8\"));\n\t\t\tfos.flush();\n\t\t} catch (IOException e) {\n\t\t\tfile = null;\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif (fos != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfos.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tfile = null;\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn file;\n\t}","id":71817,"modified_method":"private File generateRouteInfoHtml(RouteInfoAdapter routeInfo, String title) {\n\t\tFile file = null;\n\t\tif (routeInfo == null) {\n\t\t\treturn file;\n\t\t}\n\n\t\tfinal String FILE_NAME = \"route_info.html\";\n\t\tStringBuilder html = generateHtmlPrint(routeInfo, title);\n\t\tFileOutputStream fos = null;\n\t\ttry {\n\t\t\tfile = ((OsmandApplication) getApplication()).getAppPath(FILE_NAME);\n\t\t\tfos = new FileOutputStream(file);\n\t\t\tfos.write(html.toString().getBytes(\"UTF-8\"));\n\t\t\tfos.flush();\n\t\t} catch (IOException e) {\n\t\t\tfile = null;\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif (fos != null) {\n\t\t\t\ttry {\n\t\t\t\t\tfos.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tfile = null;\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn file;\n\t}","commit_id":"07a73c38bdb2de479a60db98d487f9b859617a31","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n\t * Start the ChatScreen passing our settings\n\t */\n\tprivate void connect() {\n\t\ttry {\n\t\t\t\n\t\t\tFile ff = getDir(\"storage\", Context.MODE_WORLD_READABLE);\n\t\t\tLog.i(TAG,\"getDir = \" + ff.getAbsolutePath());\n\t\t\t\n\t\t\tUserConfiguration.setUserConfigurationDirectory( ff.getAbsolutePath() );\n\t\t\t\n\t\t\tEditText etNamespace = (EditText) findViewById(R.id.etNamespace);\n\t\t\tEditText etHandle = (EditText) findViewById(R.id.etHandle);\n\n\t\t\tString handle = etHandle.getText().toString();\n\t\t\tUserConfiguration.setUserName( handle );\n\n\t\t\tIntent i = new Intent(this, ChatScreen.class);\n\t\t\ti.putExtra(\"namespace\", etNamespace.getText().toString());\n\t\t\ti.putExtra(\"handle\", handle);\n\t\t\tthis.startActivity(i);\n\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Error with ContentName\", e);\n\t\t\treturn;\n\t\t}\n\t\t\n\t}","id":71818,"modified_method":"/**\n\t * Start the ChatScreen passing our settings\n\t */\n\tprivate void connect() {\n\t\ttry {\n\t\t\tFile ff = getDir(\"storage\", Context.MODE_WORLD_READABLE);\n\t\t\tLog.i(TAG,\"getDir = \" + ff.getAbsolutePath());\n\t\t\t\n\t\t\tUserConfiguration.setUserConfigurationDirectory( ff.getAbsolutePath() );\n\t\t\t\n\t\t\tString handle = _etHandle.getText().toString();\n\t\t\tUserConfiguration.setUserName( handle );\n\n\t\t\tIntent i = new Intent(this, ChatScreen.class);\n\t\t\ti.putExtra(PREF_NAMESPACE, _etNamespace.getText().toString());\n\t\t\ti.putExtra(PREF_HANDLE, handle);\n\t\t\ti.putExtra(PREF_REMOTEHOST, _etRemoteHost.getText().toString());\n\t\t\ti.putExtra(PREF_REMOTEPORT, _etRemotePort.getText().toString());\n\t\t\tthis.startActivity(i);\n\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"Error with ContentName\", e);\n\t\t\treturn;\n\t\t}\n\t\t\n\t}","commit_id":"7421d81d6ffe8e01ae4745e66b5077ea32b83cff","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/** Called when the activity is first created. */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.ccnchat_settings);\n\t\t\n\t\tString devid = \"Android\";\n\t\t\n\t\tLog.i(TAG, \"onCreate()\");\n\t\t\n\t\tButton button = (Button) findViewById(R.id.btnConnect);\n\t\tif( null != button )\n\t\t\tbutton.setOnClickListener(this);\n\t\telse\n\t\t\tLog.e(TAG, \"Could not find btnConect!\");\n\t\t\n\t\ttry {\n\t\t\tTelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\n\t\t\tString s = tm.getLine1Number();\n\t\t\tif ( null != s && s.length() > 0 )\n\t\t\t\tdevid = s;\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"TelephoneManager error\", e);\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tEditText etHandle = (EditText) findViewById(R.id.etHandle);\n\t\tetHandle.setText(devid);\t\t\n\t}","id":71819,"modified_method":"/** Called when the activity is first created. */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.ccnchat_settings);\n\t\t\n\t\tLog.i(TAG, \"onCreate()\");\n\t\t\n\t\tButton button = (Button) findViewById(R.id.btnConnect);\n\t\tif( null != button )\n\t\t\tbutton.setOnClickListener(this);\n\t\telse\n\t\t\tLog.e(TAG, \"Could not find btnConect!\");\n\n\t\t_etNamespace = (EditText) findViewById(R.id.etNamespace);\n\t\t_etHandle = (EditText) findViewById(R.id.etHandle);\n\t\t_etRemoteHost = (EditText) findViewById(R.id.etRemoteHost);\n\t\t_etRemotePort = (EditText) findViewById(R.id.etRemotePort);\n\t\t\n\n\n\t\ttry {\n\t\t\tTelephonyManager tm = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);\n\t\t\tString s = tm.getLine1Number();\n\t\t\tif ( null != s && s.length() > 0 )\n\t\t\t\tDEFAULT_HANDLE = s;\n\t\t\t\n\t\t} catch(Exception e) {\n\t\t\tLog.e(TAG, \"TelephoneManager error\", e);\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\t\n\t\trestorePreferences();\n\t}","commit_id":"7421d81d6ffe8e01ae4745e66b5077ea32b83cff","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/** Called when the activity is first created. */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.ccnchat_chat);\n\n\t\tEditText etPost = (EditText) findViewById(R.id.etPost);\n\t\tetPost.setEnabled(false);\n\t\tetPost.setOnKeyListener(this);\n\n\t\ttv = (TextView) findViewById(R.id.tvOutput);\n\t\t//tv.setMovementMethod(new ScrollingMovementMethod()); \n\t\ttv.setText(\"\");\n\t\tsv = (ScrollView) findViewById(R.id.svOutput);\n\n\t\tScreenOutput(\"Starting the CCN listen thread\\n\");\n\n\t\tIntent i = this.getIntent();\n\t\tString namespace = i.getStringExtra(\"namespace\");\n\t\tString username = i.getStringExtra(\"handle\");\n\n\t\t_worker = new ChatWorker(this, this);\n\t\t_worker.start(username, namespace);\n\n\t\t// Do these CCNx operations after we created ChatWorker\n\t\tScreenOutput(\"User name = \" + UserConfiguration.userName() + \"\\n\");\n\t\tScreenOutput(\"ccnDir    = \" + UserConfiguration.userConfigurationDirectory() + \"\\n\");\n\t\tScreenOutput(\"Waiting for CCN Services to become ready\\n\");\n\t}","id":71820,"modified_method":"/** Called when the activity is first created. */\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.ccnchat_chat);\n\n\t\tEditText etPost = (EditText) findViewById(R.id.etPost);\n\t\tetPost.setEnabled(false);\n\t\tetPost.setOnKeyListener(this);\n\n\t\ttv = (TextView) findViewById(R.id.tvOutput);\n\t\t//tv.setMovementMethod(new ScrollingMovementMethod()); \n\t\ttv.setText(\"\");\n\t\tsv = (ScrollView) findViewById(R.id.svOutput);\n\n\t\tScreenOutput(\"Starting the CCN listen thread\\n\");\n\n\t\tIntent i = this.getIntent();\n\t\tString namespace = i.getStringExtra(CcnxChatMain.PREF_NAMESPACE);\n\t\tString username = i.getStringExtra(CcnxChatMain.PREF_HANDLE);\n\t\tString remotehost = i.getStringExtra(CcnxChatMain.PREF_REMOTEHOST);\n\t\tString remoteport = i.getStringExtra(CcnxChatMain.PREF_REMOTEPORT);\n\n\t\t_worker = new ChatWorker(this, this);\n\t\t_worker.start(username, namespace, remotehost, remoteport);\n\n\t\t// Do these CCNx operations after we created ChatWorker\n\t\tScreenOutput(\"User name = \" + UserConfiguration.userName() + \"\\n\");\n\t\tScreenOutput(\"ccnDir    = \" + UserConfiguration.userConfigurationDirectory() + \"\\n\");\n\t\tScreenOutput(\"Waiting for CCN Services to become ready\\n\");\n\t}","commit_id":"7421d81d6ffe8e01ae4745e66b5077ea32b83cff","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Called by ChatWorker based on CCNx service state\n\t */\n\t@Override\n\tpublic void ccnxServices(boolean ok) {\n\t\tif ( ok ) {\n\t\t\trecv(\"CCN Services now ready -- let's chat!\");\n\t\t\t\n\t\t\t// activate the edit text by sending a Runnable to\n\t\t\t// the UI handler.\n\t\t\t_handler.post(\n\t\t\t\t\tnew Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tEditText etPost = (EditText) findViewById(R.id.etPost);\n\t\t\t\t\t\t\tetPost.setEnabled(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t);\n\t\t} else {\n\t\t\trecv(\"CCN Service error, cannot chat!\");\n\t\t}\n\t}","id":71821,"modified_method":"/**\n\t * Called by ChatWorker based on CCNx service state\n\t */\n\t@Override\n\tpublic void ccnxServices(boolean ok) {\n\t\tif ( ok ) {\n\t\t\trecv(\"CCN Services now ready -- let's chat!\\n\");\n\t\t\t\n\t\t\t// activate the edit text by sending a Runnable to\n\t\t\t// the UI handler.\n\t\t\t_handler.post(\n\t\t\t\t\tnew Runnable() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t\tEditText etPost = (EditText) findViewById(R.id.etPost);\n\t\t\t\t\t\t\tetPost.setEnabled(true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t);\n\t\t} else {\n\t\t\trecv(\"CCN Service error, cannot chat!\\n\");\n\t\t}\n\t}","commit_id":"7421d81d6ffe8e01ae4745e66b5077ea32b83cff","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Called from CCNxServiceControl\n\t */\n\t@Override\n\tpublic void newCCNxStatus(SERVICE_STATUS st) {\n\t\t// NOw pass on the status to the app\n\t\tif( null != _chatCallback ) {\n\t\t\tswitch(st) {\n\t\t\tcase START_ALL_DONE:\n\t\t\t\ttry {\n\t\t\t\t\tSimpleFaceControl.getInstance().openMulicastInterface();\n\t\t\t\t\t_chatCallback.ccnxServices(true);\n\t\t\t\t} catch (CCNDaemonException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t_chatCallback.ccnxServices(false);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase START_ALL_ERROR:\n\t\t\t\t_chatCallback.ccnxServices(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\n\t}","id":71822,"modified_method":"/**\n\t * Called from CCNxServiceControl\n\t */\n\t@Override\n\tpublic void newCCNxStatus(SERVICE_STATUS st) {\n\t\t// NOw pass on the status to the app\n\t\tif( null != _chatCallback ) {\n\t\t\tswitch(st) {\n\t\t\tcase START_ALL_DONE:\n\t\t\t\ttry {\n\t\t\t\t\t// If we specified a remote host, use it not multicast\n\t\t\t\t\tif( null != _remotehost && _remotehost.length() > 0 ) {\n\t\t\t\t\t\tSimpleFaceControl.getInstance().connectTcp(_remotehost, Integer.parseInt(_remoteport));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSimpleFaceControl.getInstance().openMulicastInterface();\n\t\t\t\t\t}\n\t\t\t\t\t_chatCallback.ccnxServices(true);\n\t\t\t\t} catch (CCNDaemonException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t_chatCallback.ccnxServices(false);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase START_ALL_ERROR:\n\t\t\t\t_chatCallback.ccnxServices(false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\t\n\t}","commit_id":"7421d81d6ffe8e01ae4745e66b5077ea32b83cff","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"/**\n\t * Start the worker thread, along with CCN services\n\t * @param username Your \"handle\" on the Chat\n\t * @param namespace The chat ccnx:/ namespace\n\t * @throws MalformedContentNameStringException \n\t */\n\tpublic synchronized void start(String username, String namespace) {\n\t\tif( false == _running ) {\n\t\t\ttry {\n\t\t\t\t_chat = new CCNChatNet(this, namespace);\n\t\t\t\t_running = true;\n\t\t\t\t_finished = false;\n\t\t\t\t_thd.start();\n\t\t\t} catch(Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":71823,"modified_method":"/**\n\t * Start the worker thread, along with CCN services\n\t * @param username Your \"handle\" on the Chat\n\t * @param namespace The chat ccnx:/ namespace\n\t * @throws MalformedContentNameStringException \n\t */\n\tpublic synchronized void start(String username, String namespace, String remotehost, String remoteport) {\n\t\tif( false == _running ) {\n\t\t\ttry {\n\t\t\t\t_remotehost = remotehost;\n\t\t\t\t_remoteport = remoteport;\n\t\t\t\t_chat = new CCNChatNet(this, namespace);\n\t\t\t\t_running = true;\n\t\t\t\t_finished = false;\n\t\t\t\t_thd.start();\n\t\t\t} catch(Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","commit_id":"7421d81d6ffe8e01ae4745e66b5077ea32b83cff","url":"https://github.com/ProjectCCNx/ccnx"},{"original_method":"private void addIdleTimeCounterRequest() {\n    if (ApplicationManager.getApplication().isUnitTestMode()) return;\n\n    myIdleTimeCounterAlarm.cancelAllRequests();\n    myLastActiveTime = System.currentTimeMillis();\n    myIdleTimeCounterAlarm.addRequest(new Runnable() {\n      public void run() {\n        myIdleTime += System.currentTimeMillis() - myLastActiveTime;\n        addIdleTimeCounterRequest();\n      }\n    }, 20000, ModalityState.NON_MODAL);\n  }","id":71824,"modified_method":"private void addIdleTimeCounterRequest() {\n    Application application = ApplicationManager.getApplication();\n    if (application != null && application.isUnitTestMode()) return;\n\n    myIdleTimeCounterAlarm.cancelAllRequests();\n    myLastActiveTime = System.currentTimeMillis();\n    myIdleTimeCounterAlarm.addRequest(new Runnable() {\n      public void run() {\n        myIdleTime += System.currentTimeMillis() - myLastActiveTime;\n        addIdleTimeCounterRequest();\n      }\n    }, 20000, ModalityState.NON_MODAL);\n  }","commit_id":"05ead7ca83b9806370945937a510e1c4655b5503","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void commandStarted(UndoConfirmationPolicy undoConfirmationPolicy, boolean recordOriginalReference) {\n    if (myCommandLevel == 0) {\n      myCurrentMerger = new CommandMerger(this, CommandProcessor.getInstance().isUndoTransparentActionInProgress());\n\n      if (recordOriginalReference && myProject != null) {\n        Editor editor = null;\n        if (ApplicationManager.getApplication().isUnitTestMode()) {\n          editor = PlatformDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());\n        }\n        else {\n          Component component = WindowManagerEx.getInstanceEx().getFocusedComponent(myProject);\n          if (component != null) {\n            editor = PlatformDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext(component));\n          }\n        }\n\n        if (editor != null) {\n          Document document = editor.getDocument();\n          VirtualFile file = FileDocumentManager.getInstance().getFile(document);\n          if (file != null && file.isValid()) {\n            myOriginatorReference = DocumentReferenceManager.getInstance().create(file);\n          }\n        }\n      }\n    }\n    LOG.assertTrue(myCurrentMerger != null, String.valueOf(myCommandLevel));\n    myCurrentMerger.setBeforeState(getCurrentState());\n    myCurrentMerger.mergeUndoConfirmationPolicy(undoConfirmationPolicy);\n\n    myCommandLevel++;\n\n  }","id":71825,"modified_method":"private void commandStarted(UndoConfirmationPolicy undoConfirmationPolicy, boolean recordOriginalReference) {\n    if (myCommandLevel == 0) {\n      myCurrentMerger = new CommandMerger(this, CommandProcessor.getInstance().isUndoTransparentActionInProgress());\n\n      if (recordOriginalReference && myProject != null) {\n        Editor editor = null;\n        final Application application = ApplicationManager.getApplication();\n        if (application.isUnitTestMode() || application.isHeadlessEnvironment()) {\n          editor = PlatformDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext());\n        }\n        else {\n          Component component = WindowManagerEx.getInstanceEx().getFocusedComponent(myProject);\n          if (component != null) {\n            editor = PlatformDataKeys.EDITOR.getData(DataManager.getInstance().getDataContext(component));\n          }\n        }\n\n        if (editor != null) {\n          Document document = editor.getDocument();\n          VirtualFile file = FileDocumentManager.getInstance().getFile(document);\n          if (file != null && file.isValid()) {\n            myOriginatorReference = DocumentReferenceManager.getInstance().create(file);\n          }\n        }\n      }\n    }\n    LOG.assertTrue(myCurrentMerger != null, String.valueOf(myCommandLevel));\n    myCurrentMerger.setBeforeState(getCurrentState());\n    myCurrentMerger.mergeUndoConfirmationPolicy(undoConfirmationPolicy);\n\n    myCommandLevel++;\n\n  }","commit_id":"3def71383b22cb9ba29b35aee85834e614d3e874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Fragment getEarliestBunchInInterval(final long earliestRevision, final long oldestRevision, final int desirableSize,\n                                             final boolean includeYoungest, final boolean includeOldest) throws SVNException {\n    if ((myEarliestRevisionWasAccessed) || ((oldestRevision == myYoungestRevision) && ((! includeYoungest) || (! includeOldest)))) {\n      return null;\n    }\n    final SVNRevision youngRevision = (earliestRevision == -1) ? SVNRevision.HEAD : SVNRevision.create(earliestRevision);\n\n    final Ref<List<CommittedChangeList>> refToList = new Ref<List<CommittedChangeList>>();\n    final Ref<SVNException> exceptionRef = new Ref<SVNException>();\n\n    final Runnable loader = new Runnable() {\n      public void run() {\n        try {\n          refToList.set(\n              myLoader.loadInterval(youngRevision, SVNRevision.create(oldestRevision), desirableSize, includeYoungest, includeOldest));\n        }\n        catch (SVNException e) {\n          exceptionRef.set(e);\n        }\n      }\n    };\n\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      loader.run();\n    } else {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        public void run() {\n          final ProgressIndicator ind = ProgressManager.getInstance().getProgressIndicator();\n          if (ind != null) {\n            ind.setText(SvnBundle.message(\"progress.live.provider.loading.revisions.details.text\"));\n          }\n          loader.run();\n        }\n      }, SvnBundle.message(\"progress.live.provider.loading.revisions.text\"), false, myVcs.getProject());\n    }\n\n    if (exceptionRef.get() != null) {\n      final SVNException e = exceptionRef.get();\n      if (SVNErrorCode.FS_NOT_FOUND.equals(e.getErrorMessage().getErrorCode())) {\n        // occurs when target URL is deleted in repository\n        // try to find latest existent revision. expensive ...\n        final LatestExistentSearcher searcher = new LatestExistentSearcher(oldestRevision, myYoungestRevision, (oldestRevision != 0),\n                                                                           myVcs, SVNURL.parseURIEncoded(myLocation.getURL()));\n        final long existent = searcher.getLatestExistent();\n        if ((existent == -1) || (existent == earliestRevision)) {\n          myEarliestRevisionWasAccessed = true;\n          return null;\n        }\n        return getEarliestBunchInInterval(existent, oldestRevision, includeYoungest ? desirableSize : (desirableSize + 1), true, includeOldest);\n      }\n      throw e;\n    }\n\n    final List<CommittedChangeList> list = refToList.get();\n    if (list.isEmpty()) {\n      myEarliestRevisionWasAccessed = (oldestRevision == 0);\n      return null;\n    }\n    myEarliestRevisionWasAccessed = (oldestRevision == 0) && ((list.size() + ((! includeOldest) ? 1 : 0) + ((! includeYoungest) ? 1 : 0)) < desirableSize);\n    return new Fragment(Origin.LIVE, list, true, true, null);\n  }","id":71826,"modified_method":"public Fragment getEarliestBunchInInterval(final long earliestRevision, final long oldestRevision, final int desirableSize,\n                                             final boolean includeYoungest, final boolean includeOldest) throws SVNException {\n    if ((myEarliestRevisionWasAccessed) || ((oldestRevision == myYoungestRevision) && ((! includeYoungest) || (! includeOldest)))) {\n      return null;\n    }\n    final SVNRevision youngRevision = (earliestRevision == -1) ? SVNRevision.HEAD : SVNRevision.create(earliestRevision);\n\n    final Ref<List<CommittedChangeList>> refToList = new Ref<List<CommittedChangeList>>();\n    final Ref<SVNException> exceptionRef = new Ref<SVNException>();\n\n    final Runnable loader = new Runnable() {\n      public void run() {\n        try {\n          refToList.set(\n              myLoader.loadInterval(youngRevision, SVNRevision.create(oldestRevision), desirableSize, includeYoungest, includeOldest));\n        }\n        catch (SVNException e) {\n          exceptionRef.set(e);\n        }\n      }\n    };\n\n    final Application application = ApplicationManager.getApplication();\n    if (application.isUnitTestMode() || ! application.isDispatchThread()) {\n      loader.run();\n    } else {\n      ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n        public void run() {\n          final ProgressIndicator ind = ProgressManager.getInstance().getProgressIndicator();\n          if (ind != null) {\n            ind.setText(SvnBundle.message(\"progress.live.provider.loading.revisions.details.text\"));\n          }\n          loader.run();\n        }\n      }, SvnBundle.message(\"progress.live.provider.loading.revisions.text\"), false, myVcs.getProject());\n    }\n\n    if (exceptionRef.get() != null) {\n      final SVNException e = exceptionRef.get();\n      if (SVNErrorCode.FS_NOT_FOUND.equals(e.getErrorMessage().getErrorCode())) {\n        // occurs when target URL is deleted in repository\n        // try to find latest existent revision. expensive ...\n        final LatestExistentSearcher searcher = new LatestExistentSearcher(oldestRevision, myYoungestRevision, (oldestRevision != 0),\n                                                                           myVcs, SVNURL.parseURIEncoded(myLocation.getURL()));\n        final long existent = searcher.getLatestExistent();\n        if ((existent == -1) || (existent == earliestRevision)) {\n          myEarliestRevisionWasAccessed = true;\n          return null;\n        }\n        return getEarliestBunchInInterval(existent, oldestRevision, includeYoungest ? desirableSize : (desirableSize + 1), true, includeOldest);\n      }\n      throw e;\n    }\n\n    final List<CommittedChangeList> list = refToList.get();\n    if (list.isEmpty()) {\n      myEarliestRevisionWasAccessed = (oldestRevision == 0);\n      return null;\n    }\n    myEarliestRevisionWasAccessed = (oldestRevision == 0) && ((list.size() + ((! includeOldest) ? 1 : 0) + ((! includeYoungest) ? 1 : 0)) < desirableSize);\n    return new Fragment(Origin.LIVE, list, true, true, null);\n  }","commit_id":"2bbb2a94325dd160283bffa7e2a1f6d862fe45f0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void runPostStartupActivities() {\n    ApplicationManager.getApplication().assertIsDispatchThread();\n    runActivities(myPostStartupActivities);\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      VirtualFileManager.getInstance().refresh(true);\n    }\n  }","id":71827,"modified_method":"public synchronized void runPostStartupActivities() {\n    final Application app = ApplicationManager.getApplication();\n    app.assertIsDispatchThread();\n    runActivities(myPostStartupActivities);\n\n    if (app.isUnitTestMode()) return;\n    VirtualFileManager.getInstance().refresh(!app.isHeadlessEnvironment());\n  }","commit_id":"97fec4ced9008b983478e38a1c953b2d3cfb742d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static DialogWrapperPeerFactory getInstance() {\n    return ServiceManager.getService(DialogWrapperPeerFactory.class);\n  }","id":71828,"modified_method":"public static DialogWrapperPeerFactory getInstance() {\n    if (ApplicationManager.getApplication() == null) {\n      try {\n        return (DialogWrapperPeerFactory)Class.forName(\"com.intellij.openapi.ui.impl.DialogWrapperPeerFactoryImpl\").newInstance();\n      }\n      catch (Exception e) {\n        throw new RuntimeException(\"Can't instantiate DialogWrapperPeerFactory\", e);\n      }\n    }\n\n    return ServiceManager.getService(DialogWrapperPeerFactory.class);\n  }","commit_id":"e84ceab99aa72894f3c20271fada1bf23b831cc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void show() {\n    LOG.assertTrue(EventQueue.isDispatchThread(), \"Access is allowed from event dispatch thread only\");\n\n    final AnCancelAction anCancelAction = new AnCancelAction();\n    final JRootPane rootPane = getRootPane();\n    anCancelAction.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0)), rootPane);\n    myDisposeActions.add(new Runnable() {\n      public void run() {\n        anCancelAction.unregisterCustomShortcutSet(rootPane);\n      }\n    });\n\n    if (!myCanBeParent && myWindowManager != null) {\n      myWindowManager.doNotSuggestAsParent(myDialog);\n    }\n\n    if (myDialog.isModal() && !isProgressDialog()) {\n      /* TODO: Temporarily disable due to J2EE dialogs. Lots of code to rewrite there.\n      if (ApplicationManager.getApplication() != null) { // [dsl] for license dialog\n        if (ApplicationManager.getApplication().getCurrentWriteAction(null) != null) {\n          LOG.error(\n            \"Showing of modal dialog is prohibited inside write-action, modalityState=\" + ModalityState.current());\n        }\n      }\n      */\n      ((CommandProcessorEx)CommandProcessor.getInstance()).enterModal();\n      LaterInvocator.enterModal(myDialog);\n    }\n\n    hidePopupsIfNeeded();\n\n    try {\n      myDialog.show();\n    }\n    finally {\n      if (myDialog.isModal() && !isProgressDialog()) {\n        ((CommandProcessorEx)CommandProcessor.getInstance()).leaveModal();\n        LaterInvocator.leaveModal(myDialog);\n      }\n    }\n  }","id":71829,"modified_method":"public void show() {\n    LOG.assertTrue(EventQueue.isDispatchThread(), \"Access is allowed from event dispatch thread only\");\n\n    final AnCancelAction anCancelAction = new AnCancelAction();\n    final JRootPane rootPane = getRootPane();\n    anCancelAction.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0)), rootPane);\n    myDisposeActions.add(new Runnable() {\n      public void run() {\n        anCancelAction.unregisterCustomShortcutSet(rootPane);\n      }\n    });\n\n    if (!myCanBeParent && myWindowManager != null) {\n      myWindowManager.doNotSuggestAsParent(myDialog);\n    }\n\n    final CommandProcessorEx commandProcessor = ApplicationManager.getApplication() != null ? (CommandProcessorEx)CommandProcessor.getInstance() : null;\n    final boolean appStarted = commandProcessor != null;\n    if (myDialog.isModal() && !isProgressDialog()) {\n      /* TODO: Temporarily disable due to J2EE dialogs. Lots of code to rewrite there.\n      if (ApplicationManager.getApplication() != null) { // [dsl] for license dialog\n        if (ApplicationManager.getApplication().getCurrentWriteAction(null) != null) {\n          LOG.error(\n            \"Showing of modal dialog is prohibited inside write-action, modalityState=\" + ModalityState.current());\n        }\n      }\n      */\n      if (appStarted) {\n        commandProcessor.enterModal();\n        LaterInvocator.enterModal(myDialog);\n      }\n    }\n\n    if (appStarted) {\n      hidePopupsIfNeeded();\n    }\n\n    try {\n      myDialog.show();\n    }\n    finally {\n      if (myDialog.isModal() && !isProgressDialog()) {\n        if (appStarted) {\n          commandProcessor.leaveModal();\n          LaterInvocator.leaveModal(myDialog);\n        }\n      }\n    }\n  }","commit_id":"e84ceab99aa72894f3c20271fada1bf23b831cc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FocusTrackback(@NotNull Object requestor, Window parent, boolean mustBeShown) {\n    myRequestorName = requestor.toString();\n    myParentWindow = parent;\n    myMustBeShown = mustBeShown;\n\n\n    if (ApplicationManager.getApplication().isUnitTestMode() || wrongOS()) return;\n\n    register(parent);\n\n    final List<FocusTrackback> stack = getStackForRoot(myRoot);\n    if (stack.indexOf(this) == 0) {\n      final KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n      setFocusOwner(manager.getPermanentFocusOwner());\n      if (getFocusOwner() == null) {\n        final Window window = manager.getActiveWindow();\n        if (window instanceof Provider) {\n          final FocusTrackback other = ((Provider)window).getFocusTrackback();\n          if (other != null) {\n            setFocusOwner(other.getFocusOwner());\n          }\n        }\n      }\n    } else {\n      setFocusOwner(stack.get(0).getFocusOwner());\n    }\n\n    if (stack.size() == 1 && getFocusOwner() == null) {\n      setFocusOwner(getFocusFor(myRoot));\n    } else if (stack.indexOf(this) == 0 && getFocusOwner() != null) {\n      setFocusFor(myRoot, getFocusOwner());\n    }\n  }","id":71830,"modified_method":"public FocusTrackback(@NotNull Object requestor, Window parent, boolean mustBeShown) {\n    myRequestorName = requestor.toString();\n    myParentWindow = parent;\n    myMustBeShown = mustBeShown;\n\n\n    final Application app = ApplicationManager.getApplication();\n    if (app == null || app.isUnitTestMode() || wrongOS()) return;\n\n    register(parent);\n\n    final List<FocusTrackback> stack = getStackForRoot(myRoot);\n    if (stack.indexOf(this) == 0) {\n      final KeyboardFocusManager manager = KeyboardFocusManager.getCurrentKeyboardFocusManager();\n      setFocusOwner(manager.getPermanentFocusOwner());\n      if (getFocusOwner() == null) {\n        final Window window = manager.getActiveWindow();\n        if (window instanceof Provider) {\n          final FocusTrackback other = ((Provider)window).getFocusTrackback();\n          if (other != null) {\n            setFocusOwner(other.getFocusOwner());\n          }\n        }\n      }\n    } else {\n      setFocusOwner(stack.get(0).getFocusOwner());\n    }\n\n    if (stack.size() == 1 && getFocusOwner() == null) {\n      setFocusOwner(getFocusFor(myRoot));\n    } else if (stack.indexOf(this) == 0 && getFocusOwner() != null) {\n      setFocusFor(myRoot, getFocusOwner());\n    }\n  }","commit_id":"e84ceab99aa72894f3c20271fada1bf23b831cc7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static IdeaPluginDescriptorImpl[] loadDescriptors() {\n    if (ClassloaderUtil.isLoadingOfExternalPluginsDisabled()) {\n      return IdeaPluginDescriptorImpl.EMPTY_ARRAY;\n    }\n\n    final List<IdeaPluginDescriptorImpl> result = new ArrayList<IdeaPluginDescriptorImpl>();\n\n    loadDescriptors(PathManager.getPluginsPath(), result);\n    if (!ApplicationManager.getApplication().isUnitTestMode()) {\n      loadDescriptors(PathManager.getPreinstalledPluginsPath(), result);\n    }\n\n    loadDescriptorsFromProperty(result);\n\n    loadDescriptorsFromClassPath(result);\n\n    IdeaPluginDescriptorImpl[] pluginDescriptors = result.toArray(new IdeaPluginDescriptorImpl[result.size()]);\n    try {\n      Arrays.sort(pluginDescriptors, new PluginDescriptorComparator(pluginDescriptors));\n    }\n    catch (Exception e) {\n      prepareLoadingPluginsErrorMessage(IdeBundle.message(\"error.plugins.were.not.loaded\", e.getMessage()));\n      getLogger().info(e);\n      pluginDescriptors = IdeaPluginDescriptorImpl.EMPTY_ARRAY;\n    }\n    return pluginDescriptors;\n  }","id":71831,"modified_method":"public static IdeaPluginDescriptorImpl[] loadDescriptors() {\n    if (ClassloaderUtil.isLoadingOfExternalPluginsDisabled()) {\n      return IdeaPluginDescriptorImpl.EMPTY_ARRAY;\n    }\n\n    final List<IdeaPluginDescriptorImpl> result = new ArrayList<IdeaPluginDescriptorImpl>();\n\n    loadDescriptors(PathManager.getPluginsPath(), result);\n    Application application = ApplicationManager.getApplication();\n    if (application == null || !application.isUnitTestMode()) {\n      loadDescriptors(PathManager.getPreinstalledPluginsPath(), result);\n    }\n\n    loadDescriptorsFromProperty(result);\n\n    loadDescriptorsFromClassPath(result);\n\n    IdeaPluginDescriptorImpl[] pluginDescriptors = result.toArray(new IdeaPluginDescriptorImpl[result.size()]);\n    try {\n      Arrays.sort(pluginDescriptors, new PluginDescriptorComparator(pluginDescriptors));\n    }\n    catch (Exception e) {\n      prepareLoadingPluginsErrorMessage(IdeBundle.message(\"error.plugins.were.not.loaded\", e.getMessage()));\n      getLogger().info(e);\n      pluginDescriptors = IdeaPluginDescriptorImpl.EMPTY_ARRAY;\n    }\n    return pluginDescriptors;\n  }","commit_id":"a8520647a004bbc5d99548957e81bf8c7878295b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int showDialog(Project project, String message, String title, String[] options, int defaultOptionIndex, Icon icon) {\n    if (ApplicationManager.getApplication().isUnitTestMode()) {\n      return ourTestImplementation.show(message);\n    }\n    else {\n      MessageDialog dialog = new MessageDialog(project, message, title, options, defaultOptionIndex, icon);\n      dialog.show();\n      return dialog.getExitCode();\n    }\n  }","id":71832,"modified_method":"public static int showDialog(Project project, String message, String title, String[] options, int defaultOptionIndex, Icon icon) {\n    final Application application = ApplicationManager.getApplication();\n    if (application.isUnitTestMode() || application.isHeadlessEnvironment()) {\n      return ourTestImplementation.show(message);\n    }\n    else {\n      MessageDialog dialog = new MessageDialog(project, message, title, options, defaultOptionIndex, icon);\n      dialog.show();\n      return dialog.getExitCode();\n    }\n  }","commit_id":"a5c6205ef3ce995f4829616d5cce4270c4ee3667","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean eatThisOrOthers(@NotNull Update update) {\n    if (myScheduledUpdates.containsKey(update)) {\n      return false;\n    }\n\n    final Update[] updates = myScheduledUpdates.keySet().toArray(new Update[myScheduledUpdates.size()]);\n    for (Update eachInQueue : updates) {\n      if (eachInQueue.canEat(update)) {\n        return true;\n      }\n      if (update.canEat(eachInQueue)) {\n        myScheduledUpdates.remove(eachInQueue);\n        eachInQueue.setRejected();\n      }\n    }\n    return false;\n  }","id":71833,"modified_method":"private boolean eatThisOrOthers(@NotNull Update update) {\n    Map<Update, Update> updates = myScheduledUpdates.get(update.getPriority());\n    if (updates != null && updates.containsKey(update)) {\n      return false;\n    }\n\n    for (Update eachInQueue : getAllScheduledUpdates()) {\n      if (eachInQueue.canEat(update)) {\n        return true;\n      }\n      if (update.canEat(eachInQueue)) {\n        myScheduledUpdates.get(eachInQueue.getPriority()).remove(eachInQueue);\n        eachInQueue.setRejected();\n      }\n    }\n    return false;\n  }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public MergingUpdateQueue(@NonNls @NotNull String name,\n                            int mergingTimeSpan,\n                            boolean isActive,\n                            @Nullable JComponent modalityStateComponent,\n                            @Nullable Disposable parent,\n                            @Nullable JComponent activationComponent,\n                            @NotNull Alarm.ThreadToUse thread) {\n    myMergingTimeSpan = mergingTimeSpan;\n    myModalityStateComponent = modalityStateComponent;\n    myName = name;\n    myPassThrough = ApplicationManager.getApplication().isUnitTestMode();\n    myExecuteInDispatchThread = thread == Alarm.ThreadToUse.SWING_THREAD;\n    myWaiterForMerge = createAlarm(thread, myExecuteInDispatchThread ? null : this);\n\n    if (isActive) {\n      showNotify();\n    }\n\n    if (parent != null) {\n      Disposer.register(parent, this);\n    }\n\n    if (activationComponent != null) {\n      setActivationComponent(activationComponent);\n    }\n  }","id":71834,"modified_method":"public MergingUpdateQueue(@NonNls @NotNull String name,\n                            int mergingTimeSpan,\n                            boolean isActive,\n                            @Nullable JComponent modalityStateComponent,\n                            @Nullable Disposable parent,\n                            @Nullable JComponent activationComponent,\n                            @NotNull Alarm.ThreadToUse thread) {\n    myMergingTimeSpan = mergingTimeSpan;\n    myModalityStateComponent = modalityStateComponent;\n    myName = name;\n    Application app = ApplicationManager.getApplication();\n    myPassThrough = app == null || app.isUnitTestMode();\n    myExecuteInDispatchThread = thread == Alarm.ThreadToUse.SWING_THREAD;\n    myWaiterForMerge = createAlarm(thread, myExecuteInDispatchThread ? null : this);\n\n    if (isActive) {\n      showNotify();\n    }\n\n    if (parent != null) {\n      Disposer.register(parent, this);\n    }\n\n    if (activationComponent != null) {\n      setActivationComponent(activationComponent);\n    }\n  }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String toString() {\n    synchronized (myScheduledUpdates) {\n      return myName + \" active=\" + myActive + \" scheduled=\" + myScheduledUpdates.size();\n    }\n  }","id":71835,"modified_method":"@SuppressWarnings({\"HardCodedStringLiteral\"})\n  public String toString() {\n    synchronized (myScheduledUpdates) {\n      return myName + \" active=\" + myActive + \" scheduled=\" + getAllScheduledUpdates().size();\n    }\n  }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void cancelAllUpdates() {\n    synchronized (myScheduledUpdates) {\n      Update[] updates = myScheduledUpdates.keySet().toArray(new Update[myScheduledUpdates.size()]);\n      for (Update each : updates) {\n        try {\n          each.setRejected();\n        }\n        catch (ProcessCanceledException ignored) {\n        }\n      }\n      myScheduledUpdates.clear();\n      finishActivity();\n    }\n  }","id":71836,"modified_method":"public void cancelAllUpdates() {\n    synchronized (myScheduledUpdates) {\n      for (Update each : getAllScheduledUpdates()) {\n        try {\n          each.setRejected();\n        }\n        catch (ProcessCanceledException ignored) {\n        }\n      }\n      myScheduledUpdates.clear();\n      finishActivity();\n    }\n  }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void flush(boolean invokeLaterIfNotDispatch) {\n    if (myFlushing) {\n      return;\n    }\n    if (!isModalityStateCorrect()) {\n      return;\n    }\n\n    myFlushing = true;\n    final Runnable toRun = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          final Update[] all;\n\n          synchronized (myScheduledUpdates) {\n            all = myScheduledUpdates.keySet().toArray(new Update[myScheduledUpdates.size()]);\n            myScheduledUpdates.clear();\n          }\n\n          for (Update each : all) {\n            each.setProcessed();\n          }\n\n          execute(all);\n        }\n        finally {\n          myFlushing = false;\n          if (isEmpty()) {\n            finishActivity();\n          }\n        }\n      }\n    };\n\n    if (myExecuteInDispatchThread && invokeLaterIfNotDispatch) {\n      UIUtil.invokeLaterIfNeeded(toRun);\n    }\n    else {\n      toRun.run();\n    }\n  }","id":71837,"modified_method":"public void flush(boolean invokeLaterIfNotDispatch) {\n    if (myFlushing) {\n      return;\n    }\n    if (!isModalityStateCorrect()) {\n      return;\n    }\n\n    myFlushing = true;\n    final Runnable toRun = new Runnable() {\n      @Override\n      public void run() {\n        try {\n          final List<Update> all;\n\n          synchronized (myScheduledUpdates) {\n            all = getAllScheduledUpdates();\n            myScheduledUpdates.clear();\n          }\n\n          for (Update each : all) {\n            each.setProcessed();\n          }\n\n          execute(all.toArray(new Update[all.size()]));\n        }\n        finally {\n          myFlushing = false;\n          if (isEmpty()) {\n            finishActivity();\n          }\n        }\n      }\n    };\n\n    if (myExecuteInDispatchThread && invokeLaterIfNotDispatch) {\n      UIUtil.invokeLaterIfNeeded(toRun);\n    }\n    else {\n      toRun.run();\n    }\n  }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void put(@NotNull Update update) {\n    final Update existing = myScheduledUpdates.remove(update);\n    if (existing != null && existing != update) {\n      existing.setProcessed();\n      existing.setRejected();\n    }\n    myScheduledUpdates.put(update, update);\n  }","id":71838,"modified_method":"private void put(@NotNull Update update) {\n    Map<Update, Update> updates = myScheduledUpdates.get(update.getPriority());\n    if (updates == null) {\n      myScheduledUpdates.put(update.getPriority(), updates = ContainerUtil.newLinkedHashMap());\n    }\n    final Update existing = updates.remove(update);\n    if (existing != null && existing != update) {\n      existing.setProcessed();\n      existing.setRejected();\n    }\n    updates.put(update, update);\n  }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"MyQueue() {\n      super(\"Test\", 400, false, null);\n      setPassThrough(false);\n    }","id":71839,"modified_method":"MyQueue() {\n      this(400);\n    }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getPriority() {\n    return myPriority;\n  }","id":71840,"modified_method":"public final int getPriority() {\n    return myPriority;\n  }","commit_id":"5c4640c9c0d109fd6dcc764b1398a4f653256597","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void resume() {\n    if (ApplicationManager.getApplication().isUnitTestMode()) return;\n\n    if (myCycleDuration == 0) {\n      myCurrentFrame = myTotalFrames - 1;\n      paint();\n      animationDone();\n    }\n    else if (myTicker == null) {\n      myTicker = scheduler.scheduleAtFixedRate(new Runnable() {\n        AtomicBoolean scheduled = new AtomicBoolean(false);\n\n        @Override\n        public void run() {\n          if (scheduled.compareAndSet(false, true)) {\n            SwingUtilities.invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                scheduled.set(false);\n                onTick();\n              }\n            });\n          }\n        }\n      }, 0, myCycleDuration * 1000 / myTotalFrames, TimeUnit.NANOSECONDS);\n    }\n  }","id":71841,"modified_method":"public void resume() {\n    final Application app = ApplicationManager.getApplication();\n    if (app == null || app.isUnitTestMode()) return;\n\n    if (myCycleDuration == 0) {\n      myCurrentFrame = myTotalFrames - 1;\n      paint();\n      animationDone();\n    }\n    else if (myTicker == null) {\n      myTicker = scheduler.scheduleAtFixedRate(new Runnable() {\n        AtomicBoolean scheduled = new AtomicBoolean(false);\n\n        @Override\n        public void run() {\n          if (scheduled.compareAndSet(false, true)) {\n            SwingUtilities.invokeLater(new Runnable() {\n              @Override\n              public void run() {\n                scheduled.set(false);\n                onTick();\n              }\n            });\n          }\n        }\n      }, 0, myCycleDuration * 1000 / myTotalFrames, TimeUnit.NANOSECONDS);\n    }\n  }","commit_id":"e54fe47d79aa9b76128a3456a715e482021bbc7f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void startMacScrollbarFadeout(boolean now) {\n    if (!isMacOverlayScrollbar()) return;\n\n    myMacScrollbarFadeTimer.cancelAllRequests();\n\n    if (now) {\n      if (!myMacScrollbarHidden && !myMacScrollbarFadeAnimator.isRunning()) {\n        myMacScrollbarFadeAnimator.resume();\n      }\n      return;\n    }\n\n    myMacScrollbarFadeAnimator.suspend();\n    myMacScrollbarFadeAnimator.reset();\n    myMacScrollbarHidden = false;\n    myMacScrollbarFadeLevel = 0;\n\n    JScrollBar sb = scrollbar; // concurrency in background editors initialization\n    if (sb != null) {\n      sb.repaint();\n\n      if (!myMouseOverScrollbar && !sb.getValueIsAdjusting() && !ApplicationManager.getApplication().isUnitTestMode()) {\n        myMacScrollbarFadeTimer.addRequest(new Runnable() {\n          @Override\n          public void run() {\n            myMacScrollbarFadeAnimator.resume();\n          }\n        }, 700, null);\n      }\n    }\n  }","id":71842,"modified_method":"private void startMacScrollbarFadeout(boolean now) {\n    if (!isMacOverlayScrollbar()) return;\n\n    myMacScrollbarFadeTimer.cancelAllRequests();\n\n    if (now) {\n      if (!myMacScrollbarHidden && !myMacScrollbarFadeAnimator.isRunning()) {\n        myMacScrollbarFadeAnimator.resume();\n      }\n      return;\n    }\n\n    myMacScrollbarFadeAnimator.suspend();\n    myMacScrollbarFadeAnimator.reset();\n    myMacScrollbarHidden = false;\n    myMacScrollbarFadeLevel = 0;\n\n    JScrollBar sb = scrollbar; // concurrency in background editors initialization\n    if (sb != null) {\n      sb.repaint();\n\n      Application application = ApplicationManager.getApplication();\n      if (!myMouseOverScrollbar && !sb.getValueIsAdjusting() && (application == null || !application.isUnitTestMode())) {\n        myMacScrollbarFadeTimer.addRequest(new Runnable() {\n          @Override\n          public void run() {\n            myMacScrollbarFadeAnimator.resume();\n          }\n        }, 700, null);\n      }\n    }\n  }","commit_id":"63fe567510d524dc3cef07818333472f46e90e4c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void readExternal(@NotNull Document document, @NotNull URL url) throws InvalidDataException, FileNotFoundException {\n    document = JDOMXIncluder.resolve(document, url.toExternalForm(), ApplicationManager.getApplication().isUnitTestMode());\n    Element rootElement = document.getRootElement();\n    internJDOMElement(rootElement);\n    readExternal(document.getRootElement());\n  }","id":71843,"modified_method":"public void readExternal(@NotNull Document document, @NotNull URL url) throws InvalidDataException, FileNotFoundException {\n    Application application = ApplicationManager.getApplication();\n    document = JDOMXIncluder.resolve(document, url.toExternalForm(), application != null && application.isUnitTestMode());\n    Element rootElement = document.getRootElement();\n    internJDOMElement(rootElement);\n    readExternal(document.getRootElement());\n  }","commit_id":"6fd05ee9a8107a5d3b0bb0f40252b06eb1b8c48c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * Configure the block storage backend based on the blockstoragemanager found in the DB.\n\t */\n\t@Override\n  public void fireLoad( ServiceConfiguration parent ) throws ServiceRegistrationException {  \t\n    try {\n      if ( parent.isVmLocal( ) ) {\n      \tLOG.info(\"Firing LOAD for local config: \" + parent.getName());\n        EntityTransaction tx = Entities.get( parent ); \n        try {\n          parent = Entities.merge( parent );\n          tx.commit( );\n        } catch ( Exception ex ) {\n          tx.rollback( );\n        }\n        String propertyBackend = ( ( StorageControllerConfiguration ) parent ).getBlockStorageManager( );\n        StorageManagers.getInstance( propertyBackend );\n      }\n    } catch ( Exception ex ) {\n      throw Exceptions.toUndeclared( ex );\n    }\n  }","id":71844,"modified_method":"/**\n\t * Configure the block storage backend based on the blockstoragemanager found in the DB.\n\t */\n\t@Override\n  public void fireLoad( ServiceConfiguration parent ) throws ServiceRegistrationException {  \t\n    try {\n      if ( parent.isVmLocal( ) ) {\n      \tLOG.info(\"Firing LOAD for local config: \" + parent.getName());\n        EntityTransaction tx = Entities.get( parent ); \n        try {\n        \tparent = Entities.merge( parent );\n        \t//Load the available backends from this SC into the DB entry\n        \t((StorageControllerConfiguration)parent).setAvailableBackends(Joiner.on(\",\").join(StorageManagers.list()));        \t\n        \ttx.commit( );\n        } catch ( Exception ex ) {\n        \tLOG.debug(\"Error merging parent transaction. Rolling back.\");\n          tx.rollback( );\n        }       \n       \n        String propertyBackend = ( ( StorageControllerConfiguration ) parent ).getBlockStorageManager( );\n        StorageManagers.getInstance( propertyBackend );\n      }\n    } catch ( Exception ex ) {\n      throw Exceptions.toUndeclared( ex );\n    }\n  }","commit_id":"3e609adfee3b7f3314f857fbc85dd572f4588d98","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\t\tpublic void fireChange(ConfigurableProperty t, String newValue) throws ConfigurablePropertyException {\n\t\t\tString existingValue = (String)t.getValue();\n\t\t\tif(existingValue != null && !\"<unset>\".equals(existingValue)) {\n\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot change extant storage backend configuration.\");\n\t\t\t}\n\t\t\telse if(!StorageManagers.contains(newValue)){\n\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot modify \" + t.getAlias() + \" new value is not a valid value.  \" +\n\t\t\t\t\t\t\"Legal values are: \" + Joiner.on( \",\" ).join( StorageManagers.list( ) ) );\n\t\t\t}\n\t\t}","id":71845,"modified_method":"@Override\n\t\tpublic void fireChange(ConfigurableProperty t, String newValue) throws ConfigurablePropertyException {\t\t\t\n\t\t\tString existingValue = (String)t.getValue();\n\t\t\tif(existingValue != null && !\"<unset>\".equals(existingValue)) {\n\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot change extant storage backend configuration. You must deregister all SCs in the partition before you can change the configuration value\");\n\t\t\t} else {\n\t\t\t\t//Try to figure out the partition name for the request\n\t\t\t\tString probablePartitionName = ((MultiDatabasePropertyEntry)t).getEntrySetName();\n\t\t\t\tif(probablePartitionName == null) {\n\t\t\t\t\tthrow new ConfigurablePropertyException(\"Could not determing partition name from property to check validity\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString[] parts = probablePartitionName.split(\"\\\\.\");\n\t\t\t\tif(parts == null || parts.length == 0) {\n\t\t\t\t\tthrow new ConfigurablePropertyException(\"Could not determing partition name from property to check validity: \" + probablePartitionName);\n\t\t\t\t}\n\t\t\t\tprobablePartitionName = parts[0];\n\t\t\t\t\n\t\t\t\t/*Look through the service configurations for each SC in the partition and see if the value is valid.\n\t\t\t\t * This step must work if we don't allow the user to change it once set.\n\t\t\t\t * The difficulty here is if 2 SCs are in an HA pair but have different backends installed (i.e. packages)\n\t\t\t\t * The implemented semantic is that if the proposed value is valid in either SC, then allow the change.\n\t\t\t\t*/\n\t\t\t\tList<ServiceConfiguration> scConfigs = null;\n\t\t\t\ttry {\n\t\t\t\t\tscConfigs = ServiceConfigurations.listPartition(Storage.class, probablePartitionName);\t\t\t\t\t\n\t\t\t\t} catch(NoSuchElementException e) {\n\t\t\t\t\tthrow new ConfigurablePropertyException(\"No Storage Controller configurations found for partition: \" + probablePartitionName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal String proposedValue = newValue;\t\t\t\t\n\t\t\t\tfinal Set<String> validEntries = Sets.newHashSet();\t\t\t\t\n\t\t\t\tEntityTransaction tx = Entities.get(StorageControllerConfiguration.class);\n\t\t\t\ttry {\n\t\t\t\t\tif(!Iterables.any(scConfigs, new Predicate<ServiceConfiguration>( ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean apply(ServiceConfiguration config) {\n\t\t\t\t\t\t\tif(config.isVmLocal()) {\n\t\t\t\t\t\t\t\t//Service is local, so add entries to the valid list (in case of HA configs)\n\t\t\t\t\t\t\t\t// and then check the local memory state\n\t\t\t\t\t\t\t\tvalidEntries.addAll(StorageManagers.list());\n\t\t\t\t\t\t\t\treturn StorageManagers.contains(proposedValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t//Remote SC, so check the db for the list of valid entries.\n\t\t\t\t\t\t\t\t\tStorageControllerConfiguration scConfig = Entities.uniqueResult((StorageControllerConfiguration)config);\n\t\t\t\t\t\t\t\t\tfor(String entry : Splitter.on(\",\").split(scConfig.getAvailableBackends())) {\n\t\t\t\t\t\t\t\t\t\tvalidEntries.add(entry);\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\treturn validEntries.contains(proposedValue);\n\t\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})) {\n\t\t\t\t\t\t//Nothing matched.\n\t\t\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot modify \" + t.getQualifiedName() + \".\" + t.getFieldName() + \" new value is not a valid value.  \" +\t\t\t\t\n\t\t\t\t\t\t\t\t\"Legal values are: \" + Joiner.on( \",\" ).join( validEntries) );\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\ttx.rollback();\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"3e609adfee3b7f3314f857fbc85dd572f4588d98","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@After\n    public void afterTest() throws Exception {\n        try {\n            streamer.stop();\n        }\n        catch (Exception e) {\n            // ignore if already stopped\n        }\n\n        dataStreamer.close();\n\n        grid().cache(null).clear();\n\n        broker.stop();\n        broker.deleteAllMessages();\n\n    }","id":71846,"modified_method":"/**\n     *\n     * @throws Exception\n     */\n    @After\n    public void afterTest() throws Exception {\n        try {\n            streamer.stop();\n        }\n        catch (Exception e) {\n            // ignore if already stopped\n        }\n\n        dataStreamer.close();\n\n        grid().cache(null).clear();\n\n        broker.stop();\n        broker.deleteAllMessages();\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"@Before @SuppressWarnings(\"unchecked\")\n    public void beforeTest() throws Exception {\n        grid().<Integer, String>getOrCreateCache(defaultCacheConfiguration());\n\n        // find an available local port\n        try (ServerSocket ss = new ServerSocket(0)) {\n            port = ss.getLocalPort();\n        }\n\n        // create the broker\n        broker = new BrokerService();\n        broker.setDeleteAllMessagesOnStartup(true);\n        broker.setPersistent(false);\n        broker.setPersistenceAdapter(null);\n        broker.setPersistenceFactory(null);\n\n        PolicyMap policyMap = new PolicyMap();\n        PolicyEntry policy = new PolicyEntry();\n        policy.setQueuePrefetch(1);\n        broker.setDestinationPolicy(policyMap);\n        broker.getDestinationPolicy().setDefaultEntry(policy);\n        broker.setSchedulerSupport(false);\n\n        // add the MQTT transport connector to the broker\n        broker.addConnector(\"mqtt://localhost:\" + port);\n        broker.setStartAsync(false);\n        broker.start(true);\n\n        // create the broker URL\n        brokerUrl = \"tcp://localhost:\" + port;\n\n        // create the client and connect\n        client = new MqttClient(brokerUrl, UUID.randomUUID().toString(), new MemoryPersistence());\n        client.connect();\n\n        // create mqtt streamer\n        dataStreamer = grid().dataStreamer(null);\n        streamer = createMqttStreamer(dataStreamer);\n    }","id":71847,"modified_method":"/**\n     *\n     * @throws Exception\n     */\n    @Before @SuppressWarnings(\"unchecked\")\n    public void beforeTest() throws Exception {\n        grid().<Integer, String>getOrCreateCache(defaultCacheConfiguration());\n\n        // find an available local port\n        try (ServerSocket ss = new ServerSocket(0)) {\n            port = ss.getLocalPort();\n        }\n\n        // create the broker\n        broker = new BrokerService();\n        broker.setDeleteAllMessagesOnStartup(true);\n        broker.setPersistent(false);\n        broker.setPersistenceAdapter(null);\n        broker.setPersistenceFactory(null);\n\n        PolicyMap policyMap = new PolicyMap();\n        PolicyEntry policy = new PolicyEntry();\n\n        policy.setQueuePrefetch(1);\n\n        broker.setDestinationPolicy(policyMap);\n        broker.getDestinationPolicy().setDefaultEntry(policy);\n        broker.setSchedulerSupport(false);\n\n        // add the MQTT transport connector to the broker\n        broker.addConnector(\"mqtt://localhost:\" + port);\n        broker.setStartAsync(false);\n        broker.start(true);\n\n        // create the broker URL\n        brokerUrl = \"tcp://localhost:\" + port;\n\n        // create the client and connect\n        client = new MqttClient(brokerUrl, UUID.randomUUID().toString(), new MemoryPersistence());\n\n        client.connect();\n\n        // create mqtt streamer\n        dataStreamer = grid().dataStreamer(null);\n\n        streamer = createMqttStreamer(dataStreamer);\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public String getClientId() {\n        return clientId;\n    }","id":71848,"modified_method":"/**\n     * Gets the client ID, either the one set by the user or the automatically generated one.\n     *\n     * @return The client ID.\n     */\n    public String getClientId() {\n        return clientId;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override public void messageArrived(String topic, MqttMessage message) throws Exception {\n        if (getMultipleTupleExtractor() != null) {\n            Map<K, V> entries = getMultipleTupleExtractor().extract(message);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Adding cache entries: \" + entries);\n            }\n            getStreamer().addData(entries);\n        }\n        else {\n            Map.Entry<K, V> entry = getSingleTupleExtractor().extract(message);\n            if (log.isTraceEnabled()) {\n                log.trace(\"Adding cache entry: \" + entry);\n            }\n            getStreamer().addData(entry);\n        }\n    }","id":71849,"modified_method":"/**\n     * Implements the {@link MqttCallback#messageArrived(String, MqttMessage)} to receive an MQTT message.\n     *\n     * {@inheritDoc}\n     */\n    @Override public void messageArrived(String topic, MqttMessage message) throws Exception {\n        if (getMultipleTupleExtractor() != null) {\n            Map<K, V> entries = getMultipleTupleExtractor().extract(message);\n\n            if (log.isTraceEnabled())\n                log.trace(\"Adding cache entries: \" + entries);\n\n            getStreamer().addData(entries);\n        }\n        else {\n            Map.Entry<K, V> entry = getSingleTupleExtractor().extract(message);\n\n            if (log.isTraceEnabled())\n                log.trace(\"Adding cache entry: \" + entry);\n\n            getStreamer().addData(entry);\n        }\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * Starts streamer.\n     *\n     * @throws IgniteException If failed.\n     */\n    public void start() throws IgniteException {\n        if (!stopped)\n            throw new IgniteException(\"Attempted to start an already started MQTT Streamer\");\n\n        // for simplicity, if these are null initialize to empty lists\n        topics = topics == null ? new ArrayList<String>() : topics;\n        qualitiesOfService = qualitiesOfService == null ? new ArrayList<Integer>() : qualitiesOfService;\n\n        try {\n            // parameter validations\n            A.notNull(getStreamer(), \"streamer\");\n            A.notNull(getIgnite(), \"ignite\");\n            A.ensure(!(getSingleTupleExtractor() == null && getMultipleTupleExtractor() == null), \"tuple extractor missing\");\n            A.ensure(getSingleTupleExtractor() == null || getMultipleTupleExtractor() == null, \"cannot provide \" +\n                \"both single and multiple tuple extractor\");\n            A.notNullOrEmpty(brokerUrl, \"broker URL\");\n\n            // if the client ID is empty, generate one\n            if (clientId == null || clientId.length() == 0) {\n                clientId = MqttClient.generateClientId();\n            }\n\n            // if we have both a single topic and a list of topics (but the list of topic is not of\n            // size 1 and == topic, as this would be a case of re-initialization), fail\n            if (topic != null && topic.length() > 0 && !topics.isEmpty() &&\n                topics.size() != 1 && !topics.get(0).equals(topic))\n                throw new IllegalArgumentException(\"Cannot specify both a single topic and a list at the same time\");\n\n            // same as above but for QoS\n            if (qualityOfService != null && !qualitiesOfService.isEmpty() && qualitiesOfService.size() != 1 &&\n                !qualitiesOfService.get(0).equals(qualityOfService)) {\n                throw new IllegalArgumentException(\"Cannot specify both a single QoS and a list at the same time\");\n            }\n\n            // Paho API requires disconnect timeout if providing a quiesce timeout and disconnecting forcibly\n            if (disconnectForcibly && disconnectQuiesceTimeout != null) {\n                A.notNull(disconnectForciblyTimeout, \"disconnect timeout cannot be null when disconnecting forcibly \" +\n                    \"with quiesce\");\n            }\n\n            // if we have multiple topics\n            if (!topics.isEmpty()) {\n                for (String t : topics)\n                    A.notNullOrEmpty(t, \"topic in list of topics\");\n\n                A.ensure(qualitiesOfService.isEmpty() || qualitiesOfService.size() == topics.size(), \"qualities of \" +\n                    \"service must be either empty or have the same size as topics list\");\n\n                cachedLogPrefix = \"[\" + Joiner.on(\",\").join(topics) + \"]\";\n            }\n            else {  // just the single topic\n                topics.add(topic);\n\n                if (qualityOfService != null)\n                    qualitiesOfService.add(qualityOfService);\n\n                cachedLogPrefix = \"[\" + topic + \"]\";\n            }\n\n            // create logger\n            log = getIgnite().log();\n\n            // create the mqtt client\n            if (persistence == null)\n                client = new MqttClient(brokerUrl, clientId);\n            else\n                client = new MqttClient(brokerUrl, clientId, persistence);\n\n            // set this as a callback\n            client.setCallback(this);\n\n            // set stopped to false, as the connection will start async\n            stopped = false;\n\n            // build retrier\n            Retryer<Boolean> retrier = RetryerBuilder.<Boolean>newBuilder()\n                .retryIfResult(new Predicate<Boolean>() {\n                    @Override public boolean apply(Boolean connected) {\n                        return !connected;\n                    }\n                })\n                .retryIfException().retryIfRuntimeException()\n                .withWaitStrategy(retryWaitStrategy)\n                .withStopStrategy(retryStopStrategy)\n                .build();\n\n            // create the connection retrier\n            connectionRetrier = new MqttConnectionRetrier(retrier);\n            connectionRetrier.connect();\n\n        }\n        catch (Throwable t) {\n            throw new IgniteException(\"Exception while initializing MqttStreamer\", t);\n        }\n\n    }","id":71850,"modified_method":"/**\n     * Starts streamer.\n     *\n     * @throws IgniteException If failed.\n     */\n    public void start() throws IgniteException {\n        if (!stopped)\n            throw new IgniteException(\"Attempted to start an already started MQTT Streamer\");\n\n        // for simplicity, if these are null initialize to empty lists\n        topics = topics == null ? new ArrayList<String>() : topics;\n\n        qualitiesOfService = qualitiesOfService == null ? new ArrayList<Integer>() : qualitiesOfService;\n\n        try {\n            Map<String, Object> logValues = new HashMap<>();\n\n            // parameter validations\n            A.notNull(getStreamer(), \"streamer\");\n            A.notNull(getIgnite(), \"ignite\");\n            A.ensure(!(getSingleTupleExtractor() == null && getMultipleTupleExtractor() == null), \"tuple extractor missing\");\n            A.ensure(getSingleTupleExtractor() == null || getMultipleTupleExtractor() == null, \"cannot provide \" +\n                \"both single and multiple tuple extractor\");\n            A.notNullOrEmpty(brokerUrl, \"broker URL\");\n\n            // if the client ID is empty, generate one\n            if (clientId == null || clientId.length() == 0)\n                clientId = MqttClient.generateClientId();\n\n            // if we have both a single topic and a list of topics (but the list of topic is not of\n            // size 1 and == topic, as this would be a case of re-initialization), fail\n            if (topic != null && topic.length() > 0 && !topics.isEmpty() &&\n                topics.size() != 1 && !topics.get(0).equals(topic))\n                throw new IllegalArgumentException(\"Cannot specify both a single topic and a list at the same time\");\n\n            // same as above but for QoS\n            if (qualityOfService != null && !qualitiesOfService.isEmpty() && qualitiesOfService.size() != 1 &&\n                !qualitiesOfService.get(0).equals(qualityOfService))\n                throw new IllegalArgumentException(\"Cannot specify both a single QoS and a list at the same time\");\n\n            // Paho API requires disconnect timeout if providing a quiesce timeout and disconnecting forcibly\n            if (disconnectForcibly && disconnectQuiesceTimeout != null)\n                A.notNull(disconnectForciblyTimeout, \"disconnect timeout cannot be null when disconnecting forcibly \" +\n                    \"with quiesce\");\n\n            // if we have multiple topics\n            if (!topics.isEmpty()) {\n                for (String t : topics)\n                    A.notNullOrEmpty(t, \"topic in list of topics\");\n\n                A.ensure(qualitiesOfService.isEmpty() || qualitiesOfService.size() == topics.size(), \"qualities of \" +\n                    \"service must be either empty or have the same size as topics list\");\n\n                logValues.put(\"topics\", topics);\n            }\n            else {  // just the single topic\n                topics.add(topic);\n\n                if (qualityOfService != null)\n                    qualitiesOfService.add(qualityOfService);\n\n                logValues.put(\"topic\", topic);\n            }\n\n            // finish building log values\n            logValues.put(\"brokerUrl\", brokerUrl);\n            logValues.put(\"clientId\", clientId);\n\n            // cache log values\n            cachedLogValues = \"[\" + Joiner.on(\", \").withKeyValueSeparator(\"=\").join(logValues) + \"]\";\n\n            // create logger\n            log = getIgnite().log();\n\n            // create the mqtt client\n            if (persistence == null)\n                client = new MqttClient(brokerUrl, clientId);\n            else\n                client = new MqttClient(brokerUrl, clientId, persistence);\n\n            // set this as a callback\n            client.setCallback(this);\n\n            // set stopped to false, as the connection will start async\n            stopped = false;\n\n            // build retrier\n            Retryer<Boolean> retrier = RetryerBuilder.<Boolean>newBuilder()\n                .retryIfResult(new Predicate<Boolean>() {\n                    @Override public boolean apply(Boolean connected) {\n                        return !connected;\n                    }\n                })\n                .retryIfException().retryIfRuntimeException()\n                .withWaitStrategy(retryWaitStrategy)\n                .withStopStrategy(retryStopStrategy)\n                .build();\n\n            // create the connection retrier\n            connectionRetrier = new MqttConnectionRetrier(retrier);\n\n            log.info(\"Starting MQTT Streamer \" + cachedLogValues);\n\n            // connect\n            connectionRetrier.connect();\n\n        }\n        catch (Throwable t) {\n            throw new IgniteException(\"Exception while initializing MqttStreamer\", t);\n        }\n\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public Integer getDisconnectQuiesceTimeout() {\n        return disconnectQuiesceTimeout;\n    }","id":71851,"modified_method":"/**\n     * Gets the disconnect quiesce timeout.\n     *\n     * @return The disconnect quiesce timeout.\n     */\n    public Integer getDisconnectQuiesceTimeout() {\n        return disconnectQuiesceTimeout;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public boolean isBlockUntilConnected() {\n        return blockUntilConnected;\n    }","id":71852,"modified_method":"public boolean isBlockUntilConnected() {\n        return blockUntilConnected;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public MqttClientPersistence getPersistence() {\n        return persistence;\n    }","id":71853,"modified_method":"/**\n     * Gets the currently set persistence mechanism.\n     *\n     * @return The persistence mechanism.\n     */\n    public MqttClientPersistence getPersistence() {\n        return persistence;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public String getBrokerUrl() {\n        return brokerUrl;\n    }","id":71854,"modified_method":"/**\n     * Gets the broker URL.\n     *\n     * @return The Broker URL.\n     */\n    public String getBrokerUrl() {\n        return brokerUrl;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public List<String> getTopics() {\n        return topics;\n    }","id":71855,"modified_method":"/**\n     * Gets the topics subscribed to.\n     *\n     * @return The topics subscribed to.\n     */\n    public List<String> getTopics() {\n        return topics;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public Integer getDisconnectForciblyTimeout() {\n        return disconnectForciblyTimeout;\n    }","id":71856,"modified_method":"/**\n     * Gets the timeout if disconnecting forcibly.\n     *\n     * @return Timeout.\n     */\n    public Integer getDisconnectForciblyTimeout() {\n        return disconnectForciblyTimeout;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override public void connectionLost(Throwable throwable) {\n        connected = false;\n\n        // if we have been stopped, we do not try to establish the connection again\n        if (stopped)\n            return;\n\n        log.warning(String.format(\"MQTT Connection to server %s was lost.\", brokerUrl), throwable);\n        connectionRetrier.connect();\n    }","id":71857,"modified_method":"/**\n     * Implements the {@link MqttCallback#connectionLost(Throwable)} callback method for the MQTT client to inform the\n     * streamer that the connection has been lost.\n     *\n     * {@inheritDoc}\n     */\n    @Override public void connectionLost(Throwable throwable) {\n        connected = false;\n\n        // if we have been stopped, we do not try to establish the connection again\n        if (stopped)\n            return;\n\n        log.warning(String.format(\"MQTT Connection to broker was lost [brokerUrl=%s, type=%s, err=%s]\", brokerUrl,\n            throwable.getClass(), throwable.getMessage()));\n\n        connectionRetrier.connect();\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public Integer getQualityOfService() {\n        return qualityOfService;\n    }","id":71858,"modified_method":"/**\n     * Gets the quality of service set by the user for a single topic consumption.\n     *\n     * @return The quality of service.\n     */\n    public Integer getQualityOfService() {\n        return qualityOfService;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n         * Method that is called by the streamer to ask us to (re-)connect.\n         */\n        public void connect() {\n            Callable<Boolean> callable = retrier.wrap(new Callable<Boolean>() {\n                @Override public Boolean call() throws Exception {\n                    // if we're already connected, return immediately\n                    if (connected)\n                        return true;\n\n                    if (stopped)\n                        return false;\n\n                    // connect to broker\n                    if (connectOptions == null)\n                        client.connect();\n                    else\n                        client.connect(connectOptions);\n\n                    // always use the multiple topics variant of the mqtt client; even if the user specified a single\n                    // topic and/or QoS, the initialization code would have placed it inside the 1..n structures\n                    if (qualitiesOfService.isEmpty())\n                        client.subscribe(topics.toArray(new String[0]));\n\n                    else {\n                        int[] qoses = new int[qualitiesOfService.size()];\n                        for (int i = 0; i < qualitiesOfService.size(); i++)\n                            qoses[i] = qualitiesOfService.get(i);\n\n                        client.subscribe(topics.toArray(new String[0]), qoses);\n                    }\n\n                    connected = true;\n                    return connected;\n                }\n            });\n\n            Future<Boolean> result = executor.submit(callable);\n\n            if (blockUntilConnected) {\n                try {\n                    result.get();\n                }\n                catch (Throwable e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }","id":71859,"modified_method":"/**\n         * Method called by the streamer to ask us to (re-)connect.\n         */\n        public void connect() {\n            Callable<Boolean> callable = retrier.wrap(new Callable<Boolean>() {\n                @Override public Boolean call() throws Exception {\n                    // if we're already connected, return immediately\n                    if (connected)\n                        return true;\n\n                    if (stopped)\n                        return false;\n\n                    // connect to broker\n                    if (connectOptions == null)\n                        client.connect();\n                    else\n                        client.connect(connectOptions);\n\n                    // always use the multiple topics variant of the mqtt client; even if the user specified a single\n                    // topic and/or QoS, the initialization code would have placed it inside the 1..n structures\n                    if (qualitiesOfService.isEmpty())\n                        client.subscribe(topics.toArray(new String[0]));\n\n                    else {\n                        int[] qoses = new int[qualitiesOfService.size()];\n\n                        for (int i = 0; i < qualitiesOfService.size(); i++)\n                            qoses[i] = qualitiesOfService.get(i);\n\n                        client.subscribe(topics.toArray(new String[0]), qoses);\n                    }\n\n                    log.info(\"MQTT Streamer (re-)connected and subscribed \" + cachedLogValues);\n\n                    connected = true;\n                    return connected;\n                }\n            });\n\n            Future<Boolean> result = executor.submit(callable);\n\n            if (blockUntilConnected) {\n                try {\n                    result.get();\n                }\n                catch (Throwable e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public List<Integer> getQualitiesOfService() {\n        return qualitiesOfService;\n    }","id":71860,"modified_method":"/**\n     * Gets the qualities of service for multiple topics.\n     *\n     * @return The qualities of service.\n     */\n    public List<Integer> getQualitiesOfService() {\n        return qualitiesOfService;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public WaitStrategy getRetryWaitStrategy() {\n        return retryWaitStrategy;\n    }","id":71861,"modified_method":"/**\n     * Gets the retry wait strategy.\n     *\n     * @return The retry wait strategy.\n     */\n    public WaitStrategy getRetryWaitStrategy() {\n        return retryWaitStrategy;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public boolean isDisconnectForcibly() {\n        return disconnectForcibly;\n    }","id":71862,"modified_method":"/**\n     * Gets whether this MQTT client will disconnect forcibly when shutting down.\n     *\n     * @return Whether to disconnect forcibly or not.\n     */\n    public boolean isDisconnectForcibly() {\n        return disconnectForcibly;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public String getTopic() {\n        return topic;\n    }","id":71863,"modified_method":"/**\n     * Gets the subscribed topic.\n     *\n     * @return The subscribed topic.\n     */\n    public String getTopic() {\n        return topic;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    @Override public void deliveryComplete(IMqttDeliveryToken token) {\n        // ignore, as we don't send messages\n    }","id":71864,"modified_method":"/**\n     * Empty implementation of {@link MqttCallback#deliveryComplete(IMqttDeliveryToken)}.\n     *\n     * Not required by the streamer as it doesn't produce messages.\n     *\n     * {@inheritDoc}\n     */\n    @Override public void deliveryComplete(IMqttDeliveryToken token) {\n        // ignore, as we don't send messages\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public StopStrategy getRetryStopStrategy() {\n        return retryStopStrategy;\n    }","id":71865,"modified_method":"/**\n     * Gets the retry stop strategy.\n     *\n     * @return The retry stop strategy.\n     */\n    public StopStrategy getRetryStopStrategy() {\n        return retryStopStrategy;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n     * @return\n     */\n    public MqttConnectOptions getConnectOptions() {\n        return connectOptions;\n    }","id":71866,"modified_method":"/**\n     * Gets the currently used MQTT client connect options.\n     *\n     * @return The MQTT client connect options.\n     */\n    public MqttConnectOptions getConnectOptions() {\n        return connectOptions;\n    }","commit_id":"cb0d432f358615b12a65eb62f4b03b70680b3575","url":"https://github.com/apache/ignite"},{"original_method":"/**\n\t * Configure the block storage backend based on the blockstoragemanager found in the DB.\n\t */\n\t@Override\n  public void fireLoad( ServiceConfiguration parent ) throws ServiceRegistrationException {  \t\n    try {\n      if ( parent.isVmLocal( ) ) {\n      \tLOG.info(\"Firing LOAD for local config: \" + parent.getName());\n        EntityTransaction tx = Entities.get( parent ); \n        try {\n          parent = Entities.merge( parent );\n          tx.commit( );\n        } catch ( Exception ex ) {\n          tx.rollback( );\n        }\n        String propertyBackend = ( ( StorageControllerConfiguration ) parent ).getBlockStorageManager( );\n        StorageManagers.getInstance( propertyBackend );\n      }\n    } catch ( Exception ex ) {\n      throw Exceptions.toUndeclared( ex );\n    }\n  }","id":71867,"modified_method":"/**\n\t * Configure the block storage backend based on the blockstoragemanager found in the DB.\n\t */\n\t@Override\n  public void fireLoad( ServiceConfiguration parent ) throws ServiceRegistrationException {  \t\n    try {\n      if ( parent.isVmLocal( ) ) {\n      \tLOG.info(\"Firing LOAD for local config: \" + parent.getName());\n        EntityTransaction tx = Entities.get( parent ); \n        try {\n        \tparent = Entities.merge( parent );\n        \t//Load the available backends from this SC into the DB entry\n        \t((StorageControllerConfiguration)parent).setAvailableBackends(Joiner.on(\",\").join(StorageManagers.list()));        \t\n        \ttx.commit( );\n        } catch ( Exception ex ) {\n        \tLOG.debug(\"Error merging parent transaction. Rolling back.\");\n          tx.rollback( );\n        }       \n       \n        String propertyBackend = ( ( StorageControllerConfiguration ) parent ).getBlockStorageManager( );\n        StorageManagers.getInstance( propertyBackend );\n      }\n    } catch ( Exception ex ) {\n      throw Exceptions.toUndeclared( ex );\n    }\n  }","commit_id":"78e9c0a61b643f19862d1dbf19f86d9c086ba610","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\t\tpublic void fireChange(ConfigurableProperty t, String newValue) throws ConfigurablePropertyException {\n\t\t\tString existingValue = (String)t.getValue();\n\t\t\tif(existingValue != null && !\"<unset>\".equals(existingValue)) {\n\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot change extant storage backend configuration.\");\n\t\t\t}\n\t\t\telse if(!StorageManagers.contains(newValue)){\n\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot modify \" + t.getAlias() + \" new value is not a valid value.  \" +\n\t\t\t\t\t\t\"Legal values are: \" + Joiner.on( \",\" ).join( StorageManagers.list( ) ) );\n\t\t\t}\n\t\t}","id":71868,"modified_method":"@Override\n\t\tpublic void fireChange(ConfigurableProperty t, String newValue) throws ConfigurablePropertyException {\t\t\t\n\t\t\tString existingValue = (String)t.getValue();\n\t\t\tif(existingValue != null && !\"<unset>\".equals(existingValue)) {\n\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot change extant storage backend configuration. You must deregister all SCs in the partition before you can change the configuration value\");\n\t\t\t} else {\n\t\t\t\t//Try to figure out the partition name for the request\n\t\t\t\tString probablePartitionName = ((MultiDatabasePropertyEntry)t).getEntrySetName();\n\t\t\t\tif(probablePartitionName == null) {\n\t\t\t\t\tthrow new ConfigurablePropertyException(\"Could not determing partition name from property to check validity\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tString[] parts = probablePartitionName.split(\"\\\\.\");\n\t\t\t\tif(parts == null || parts.length == 0) {\n\t\t\t\t\tthrow new ConfigurablePropertyException(\"Could not determing partition name from property to check validity: \" + probablePartitionName);\n\t\t\t\t}\n\t\t\t\tprobablePartitionName = parts[0];\n\t\t\t\t\n\t\t\t\t/*Look through the service configurations for each SC in the partition and see if the value is valid.\n\t\t\t\t * This step must work if we don't allow the user to change it once set.\n\t\t\t\t * The difficulty here is if 2 SCs are in an HA pair but have different backends installed (i.e. packages)\n\t\t\t\t * The implemented semantic is that if the proposed value is valid in either SC, then allow the change.\n\t\t\t\t*/\n\t\t\t\tList<ServiceConfiguration> scConfigs = null;\n\t\t\t\ttry {\n\t\t\t\t\tscConfigs = ServiceConfigurations.listPartition(Storage.class, probablePartitionName);\t\t\t\t\t\n\t\t\t\t} catch(NoSuchElementException e) {\n\t\t\t\t\tthrow new ConfigurablePropertyException(\"No Storage Controller configurations found for partition: \" + probablePartitionName);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal String proposedValue = newValue;\t\t\t\t\n\t\t\t\tfinal Set<String> validEntries = Sets.newHashSet();\t\t\t\t\n\t\t\t\tEntityTransaction tx = Entities.get(StorageControllerConfiguration.class);\n\t\t\t\ttry {\n\t\t\t\t\tif(!Iterables.any(scConfigs, new Predicate<ServiceConfiguration>( ) {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic boolean apply(ServiceConfiguration config) {\n\t\t\t\t\t\t\tif(config.isVmLocal()) {\n\t\t\t\t\t\t\t\t//Service is local, so add entries to the valid list (in case of HA configs)\n\t\t\t\t\t\t\t\t// and then check the local memory state\n\t\t\t\t\t\t\t\tvalidEntries.addAll(StorageManagers.list());\n\t\t\t\t\t\t\t\treturn StorageManagers.contains(proposedValue);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t//Remote SC, so check the db for the list of valid entries.\n\t\t\t\t\t\t\t\t\tStorageControllerConfiguration scConfig = Entities.uniqueResult((StorageControllerConfiguration)config);\n\t\t\t\t\t\t\t\t\tfor(String entry : Splitter.on(\",\").split(scConfig.getAvailableBackends())) {\n\t\t\t\t\t\t\t\t\t\tvalidEntries.add(entry);\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\treturn validEntries.contains(proposedValue);\n\t\t\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})) {\n\t\t\t\t\t\t//Nothing matched.\n\t\t\t\t\t\tthrow new ConfigurablePropertyException(\"Cannot modify \" + t.getQualifiedName() + \".\" + t.getFieldName() + \" new value is not a valid value.  \" +\t\t\t\t\n\t\t\t\t\t\t\t\t\"Legal values are: \" + Joiner.on( \",\" ).join( validEntries) );\n\t\t\t\t\t}\n\t\t\t\t} finally {\n\t\t\t\t\ttx.rollback();\n\t\t\t\t}\n\t\t\t}\n\t\t}","commit_id":"78e9c0a61b643f19862d1dbf19f86d9c086ba610","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"void setAnyLocalV6(boolean anyLocalV6) {\n        validateAnyLocalAllowed(Element.ANY_IPV6_ADDRESS);\n        this.anyLocalV6 = anyLocalV6;\n    }","id":71869,"modified_method":"void setAnyLocalV6(boolean anyLocalV6) {\n        if (anyLocalV6) {\n            validateAnyLocalAllowed(Element.ANY_IPV6_ADDRESS);\n        }\n        this.anyLocalV6 = anyLocalV6;\n    }","commit_id":"78a350a6d2282b6b801e00a872708d842485e4e8","url":"https://github.com/wildfly/wildfly"},{"original_method":"void setAnyLocal(boolean anyLocal) {\n        validateAnyLocalAllowed(Element.ANY_ADDRESS);\n        this.anyLocal = anyLocal;\n    }","id":71870,"modified_method":"void setAnyLocal(boolean anyLocal) {\n        if (anyLocal) {\n            validateAnyLocalAllowed(Element.ANY_ADDRESS);\n        }\n        this.anyLocal = anyLocal;\n    }","commit_id":"78a350a6d2282b6b801e00a872708d842485e4e8","url":"https://github.com/wildfly/wildfly"},{"original_method":"void setAnyLocalV4(boolean anyLocalV4) {\n        validateAnyLocalAllowed(Element.ANY_IPV4_ADDRESS);\n        this.anyLocalV4 = anyLocalV4;\n    }","id":71871,"modified_method":"void setAnyLocalV4(boolean anyLocalV4) {\n        if (anyLocalV4) {\n            validateAnyLocalAllowed(Element.ANY_IPV4_ADDRESS);\n        }\n        this.anyLocalV4 = anyLocalV4;\n    }","commit_id":"78a350a6d2282b6b801e00a872708d842485e4e8","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Set<String> parseInterfaces(final XMLExtendedStreamReader reader, final Set<String> names, final List<InterfaceAdd> list, boolean checkSpecified) throws XMLStreamException {\n        requireNoAttributes(reader);\n\n        final Map<Element, AbstractInterfaceCriteriaElement<?>> interfaceCriteria = new HashMap<Element, AbstractInterfaceCriteriaElement<?>>();\n\n        while (reader.nextTag() != END_ELEMENT) {\n            // Attributes\n            requireSingleAttribute(reader, Attribute.NAME.getLocalName());\n            final String name = reader.getAttributeValue(0);\n            if (! names.add(name)) {\n                throw new XMLStreamException(\"Duplicate interface declaration\", reader.getLocation());\n            }\n\n            // Content\n            // nested choices\n            if (reader.nextTag() == END_ELEMENT) {\n                if(checkSpecified == false) {\n                    // in the domain it does not need to be complete\n                    continue;\n                }\n                throw unexpectedEndElement(reader);\n            }\n            boolean first = true;\n            Element anyElement = null;\n            do {\n                if (Namespace.forUri(reader.getNamespaceURI()) != Namespace.DOMAIN_1_0) {\n                    throw unexpectedElement(reader);\n                }\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                    case ANY_ADDRESS:\n                    case ANY_IPV4_ADDRESS:\n                    case ANY_IPV6_ADDRESS: {\n                        if (! first || anyElement != null) {\n                            throw unexpectedElement(reader);\n                        }\n                        requireNoAttributes(reader);\n                        requireNoContent(reader);\n\n                        // no others allowed\n//                        if (reader.nextTag() != END_ELEMENT) {\n//                            throw unexpectedElement(reader);\n//                        }\n                        // The any element\n                        anyElement = element;\n                        break;\n                    } default: {\n                        if (anyElement != null) {\n                            throw unexpectedElement(reader);\n                        }\n                        switch (element) {\n                            case ANY:\n                            case NOT: {\n                                final CompoundCriteriaElement criteria = InterfaceParsingUtils.createCompoundCriteria(reader, element == Element.ANY);\n                                interfaceCriteria.put(element, criteria);\n                                break;\n                            } default: {\n                                final AbstractInterfaceCriteriaElement<?> criteria = InterfaceParsingUtils.parseSimpleInterfaceCriteria(reader, element);\n                                interfaceCriteria.put(element, criteria);\n                            }\n                        }\n                    }\n                }\n                first = false;\n            } while (reader.nextTag() != END_ELEMENT);\n            if (checkSpecified && anyElement == null && interfaceCriteria.isEmpty()) {\n                throw new XMLStreamException(\"Either an inet-address element or some other interface criteria element is required\", reader.getLocation());\n            }\n            // Domain interface update\n            list.add(new InterfaceAdd(name,\n                    anyElement == Element.ANY_IPV4_ADDRESS,\n                    anyElement == Element.ANY_IPV6_ADDRESS,\n                    anyElement == Element.ANY_ADDRESS,\n                    interfaceCriteria.values()));\n        }\n        return names;\n    }","id":71872,"modified_method":"static Set<String> parseInterfaces(final XMLExtendedStreamReader reader, final Set<String> names, final List<InterfaceAdd> list, boolean checkSpecified) throws XMLStreamException {\n        requireNoAttributes(reader);\n\n        while (reader.nextTag() != END_ELEMENT) {\n            // Attributes\n            requireSingleAttribute(reader, Attribute.NAME.getLocalName());\n            final String name = reader.getAttributeValue(0);\n            if (! names.add(name)) {\n                throw new XMLStreamException(\"Duplicate interface declaration\", reader.getLocation());\n            }\n\n            // Content\n            // nested choices\n            if (reader.nextTag() == END_ELEMENT) {\n                if(checkSpecified == false) {\n                    // in the domain it does not need to be complete\n                    continue;\n                }\n                throw unexpectedEndElement(reader);\n            }\n\n            final Map<Element, AbstractInterfaceCriteriaElement<?>> interfaceCriteria = new HashMap<Element, AbstractInterfaceCriteriaElement<?>>();\n            boolean first = true;\n            Element anyElement = null;\n            do {\n                if (Namespace.forUri(reader.getNamespaceURI()) != Namespace.DOMAIN_1_0) {\n                    throw unexpectedElement(reader);\n                }\n                final Element element = Element.forName(reader.getLocalName());\n                switch (element) {\n                    case ANY_ADDRESS:\n                    case ANY_IPV4_ADDRESS:\n                    case ANY_IPV6_ADDRESS: {\n                        if (! first || anyElement != null) {\n                            throw unexpectedElement(reader);\n                        }\n                        requireNoAttributes(reader);\n                        requireNoContent(reader);\n\n                        // no others allowed\n//                        if (reader.nextTag() != END_ELEMENT) {\n//                            throw unexpectedElement(reader);\n//                        }\n                        // The any element\n                        anyElement = element;\n                        break;\n                    } default: {\n                        if (anyElement != null) {\n                            throw unexpectedElement(reader);\n                        }\n                        switch (element) {\n                            case ANY:\n                            case NOT: {\n                                final CompoundCriteriaElement criteria = InterfaceParsingUtils.createCompoundCriteria(reader, element == Element.ANY);\n                                interfaceCriteria.put(element, criteria);\n                                break;\n                            } default: {\n                                final AbstractInterfaceCriteriaElement<?> criteria = InterfaceParsingUtils.parseSimpleInterfaceCriteria(reader, element);\n                                interfaceCriteria.put(element, criteria);\n                            }\n                        }\n                    }\n                }\n                first = false;\n            } while (reader.nextTag() != END_ELEMENT);\n            if (checkSpecified && anyElement == null && interfaceCriteria.isEmpty()) {\n                throw new XMLStreamException(\"Either an inet-address element or some other interface criteria element is required\", reader.getLocation());\n            }\n            // Domain interface update\n            list.add(new InterfaceAdd(name,\n                    anyElement == Element.ANY_IPV4_ADDRESS,\n                    anyElement == Element.ANY_IPV6_ADDRESS,\n                    anyElement == Element.ANY_ADDRESS,\n                    interfaceCriteria.values()));\n        }\n        return names;\n    }","commit_id":"78a350a6d2282b6b801e00a872708d842485e4e8","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n  public void start(CoprocessorEnvironment e) throws IOException {\n    if (e instanceof RegionCoprocessorEnvironment) {\n      RegionCoprocessorEnvironment env = (RegionCoprocessorEnvironment) e;\n      this.region = ((RegionCoprocessorEnvironment) e).getRegion();\n      String sysConfigTablePrefix\n        = new HBase94TableUtil().getSysConfigTablePrefix(env.getRegion().getTableDesc().getNameAsString());\n      this.state = new IncrementHandlerState(env.getConfiguration(), sysConfigTablePrefix);\n\n      HTableDescriptor tableDesc = env.getRegion().getTableDesc();\n      for (HColumnDescriptor columnDesc : tableDesc.getFamilies()) {\n        state.initFamily(columnDesc.getName(), convertFamilyValues(columnDesc.getValues()));\n      }\n    }\n  }","id":71873,"modified_method":"@Override\n  public void start(CoprocessorEnvironment e) throws IOException {\n    if (e instanceof RegionCoprocessorEnvironment) {\n      RegionCoprocessorEnvironment env = (RegionCoprocessorEnvironment) e;\n      this.region = ((RegionCoprocessorEnvironment) e).getRegion();\n      this.state = new IncrementHandlerState(env.getConfiguration(), env.getRegion().getTableDesc().getNameAsString(),\n                                             new HBase94TableUtil());\n\n      HTableDescriptor tableDesc = env.getRegion().getTableDesc();\n      for (HColumnDescriptor columnDesc : tableDesc.getFamilies()) {\n        state.initFamily(columnDesc.getName(), convertFamilyValues(columnDesc.getValues()));\n      }\n    }\n  }","commit_id":"49e5d924f402de06b162934dfe948d698ab2d01c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void start(CoprocessorEnvironment e) throws IOException {\n    if (e instanceof RegionCoprocessorEnvironment) {\n      RegionCoprocessorEnvironment env = (RegionCoprocessorEnvironment) e;\n      this.region = ((RegionCoprocessorEnvironment) e).getRegion();\n      String sysConfigTablePrefix\n        = new HBase96TableUtil().getSysConfigTablePrefix(env.getRegion().getTableDesc().getNameAsString());\n      this.state = new IncrementHandlerState(env.getConfiguration(), sysConfigTablePrefix);\n\n      HTableDescriptor tableDesc = env.getRegion().getTableDesc();\n      for (HColumnDescriptor columnDesc : tableDesc.getFamilies()) {\n        state.initFamily(columnDesc.getName(), convertFamilyValues(columnDesc.getValues()));\n      }\n    }\n  }","id":71874,"modified_method":"@Override\n  public void start(CoprocessorEnvironment e) throws IOException {\n    if (e instanceof RegionCoprocessorEnvironment) {\n      RegionCoprocessorEnvironment env = (RegionCoprocessorEnvironment) e;\n      this.region = ((RegionCoprocessorEnvironment) e).getRegion();\n      this.state = new IncrementHandlerState(env.getConfiguration(), env.getRegion().getTableDesc().getNameAsString(),\n                                             new HBase96TableUtil());\n\n      HTableDescriptor tableDesc = env.getRegion().getTableDesc();\n      for (HColumnDescriptor columnDesc : tableDesc.getFamilies()) {\n        state.initFamily(columnDesc.getName(), convertFamilyValues(columnDesc.getValues()));\n      }\n    }\n  }","commit_id":"49e5d924f402de06b162934dfe948d698ab2d01c","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public void start(CoprocessorEnvironment e) throws IOException {\n    if (e instanceof RegionCoprocessorEnvironment) {\n      RegionCoprocessorEnvironment env = (RegionCoprocessorEnvironment) e;\n      this.region = ((RegionCoprocessorEnvironment) e).getRegion();\n      String sysConfigTablePrefix\n        = new HBase98TableUtil().getSysConfigTablePrefix(env.getRegion().getTableDesc().getNameAsString());\n      this.state = new IncrementHandlerState(env.getConfiguration(), sysConfigTablePrefix);\n\n      HTableDescriptor tableDesc = env.getRegion().getTableDesc();\n      for (HColumnDescriptor columnDesc : tableDesc.getFamilies()) {\n        state.initFamily(columnDesc.getName(), convertFamilyValues(columnDesc.getValues()));\n      }\n    }\n  }","id":71875,"modified_method":"@Override\n  public void start(CoprocessorEnvironment e) throws IOException {\n    if (e instanceof RegionCoprocessorEnvironment) {\n      RegionCoprocessorEnvironment env = (RegionCoprocessorEnvironment) e;\n      this.region = ((RegionCoprocessorEnvironment) e).getRegion();\n      this.state = new IncrementHandlerState(env.getConfiguration(), env.getRegion().getTableDesc().getNameAsString(),\n                                             new HBase98TableUtil());\n\n      HTableDescriptor tableDesc = env.getRegion().getTableDesc();\n      for (HColumnDescriptor columnDesc : tableDesc.getFamilies()) {\n        state.initFamily(columnDesc.getName(), convertFamilyValues(columnDesc.getValues()));\n      }\n    }\n  }","commit_id":"49e5d924f402de06b162934dfe948d698ab2d01c","url":"https://github.com/caskdata/cdap"},{"original_method":"protected Supplier<TransactionStateCache> getTransactionStateCacheSupplier(String sysConfigTablePrefix,\n                                                                             Configuration conf) {\n    return new DefaultTransactionStateCacheSupplier(sysConfigTablePrefix, conf);\n  }","id":71876,"modified_method":"protected Supplier<TransactionStateCache> getTransactionStateCacheSupplier(String tableName,\n                                                                             Configuration conf) {\n    String sysConfigTablePrefix = tableUtil.getSysConfigTablePrefix(tableName);\n    return new DefaultTransactionStateCacheSupplier(sysConfigTablePrefix, conf);\n  }","commit_id":"49e5d924f402de06b162934dfe948d698ab2d01c","url":"https://github.com/caskdata/cdap"},{"original_method":"public IncrementHandlerState(Configuration conf, String sysConfigTablePrefix) {\n    this.conf = conf;\n    this.sysConfigTablePrefix = sysConfigTablePrefix;\n  }","id":71877,"modified_method":"public IncrementHandlerState(Configuration conf, String tableName, HBaseTableUtil tableUtil) {\n    this.conf = conf;\n    this.tableName = tableName;\n    this.tableUtil = tableUtil;\n  }","commit_id":"49e5d924f402de06b162934dfe948d698ab2d01c","url":"https://github.com/caskdata/cdap"},{"original_method":"public void initFamily(byte[] familyName, Map<byte[], byte[]> familyValues) {\n    String familyAsString = Bytes.toString(familyName);\n    byte[] transactionalConfig = familyValues.get(Bytes.toBytes(IncrementHandlerState.PROPERTY_TRANSACTIONAL));\n    boolean txnl = transactionalConfig == null || !\"false\".equals(Bytes.toString(transactionalConfig));\n    LOG.info(\"Family \" + familyAsString + \" is transactional: \" + txnl);\n    if (txnl) {\n      txnlFamilies.add(familyName);\n    }\n\n    // check for TTL configuration\n    byte[] columnTTL = familyValues.get(Bytes.toBytes(TxConstants.PROPERTY_TTL));\n    long ttl = 0;\n    if (columnTTL != null) {\n      try {\n        String stringTTL = Bytes.toString(columnTTL);\n        ttl = Long.parseLong(stringTTL);\n        LOG.info(\"Family \" + familyAsString + \" has TTL of \" + ttl);\n      } catch (NumberFormatException nfe) {\n        LOG.warn(\"Invalid TTL value configured for column family \" + familyAsString +\n            \", value = \" + Bytes.toStringBinary(columnTTL));\n      }\n    }\n    ttlByFamily.put(familyName, ttl);\n\n    // get the transaction state cache as soon as we have a transactional family\n    if (!txnlFamilies.isEmpty() && cache == null) {\n      Supplier<TransactionStateCache> cacheSupplier = getTransactionStateCacheSupplier(sysConfigTablePrefix, conf);\n      this.cache = cacheSupplier.get();\n    }\n  }","id":71878,"modified_method":"public void initFamily(byte[] familyName, Map<byte[], byte[]> familyValues) {\n    String familyAsString = Bytes.toString(familyName);\n    byte[] transactionalConfig = familyValues.get(Bytes.toBytes(IncrementHandlerState.PROPERTY_TRANSACTIONAL));\n    boolean txnl = transactionalConfig == null || !\"false\".equals(Bytes.toString(transactionalConfig));\n    LOG.info(\"Family \" + familyAsString + \" is transactional: \" + txnl);\n    if (txnl) {\n      txnlFamilies.add(familyName);\n    }\n\n    // check for TTL configuration\n    byte[] columnTTL = familyValues.get(Bytes.toBytes(TxConstants.PROPERTY_TTL));\n    long ttl = 0;\n    if (columnTTL != null) {\n      try {\n        String stringTTL = Bytes.toString(columnTTL);\n        ttl = Long.parseLong(stringTTL);\n        LOG.info(\"Family \" + familyAsString + \" has TTL of \" + ttl);\n      } catch (NumberFormatException nfe) {\n        LOG.warn(\"Invalid TTL value configured for column family \" + familyAsString +\n            \", value = \" + Bytes.toStringBinary(columnTTL));\n      }\n    }\n    ttlByFamily.put(familyName, ttl);\n\n    // get the transaction state cache as soon as we have a transactional family\n    if (!txnlFamilies.isEmpty() && cache == null) {\n      Supplier<TransactionStateCache> cacheSupplier = getTransactionStateCacheSupplier(tableName, conf);\n      this.cache = cacheSupplier.get();\n    }\n  }","commit_id":"49e5d924f402de06b162934dfe948d698ab2d01c","url":"https://github.com/caskdata/cdap"},{"original_method":"public void set (float r, float g, float b, float a) {\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\t\tthis.a = a;\r\n\t}","id":71879,"modified_method":"/** @return this Color for chaining */\r\n\tpublic Color set (float r, float g, float b, float a) {\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\t\tthis.a = a;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void sub (float r, float g, float b, float a) {\r\n\t\tthis.r -= r;\r\n\t\tthis.g -= g;\r\n\t\tthis.b -= b;\r\n\t\tthis.a -= a;\r\n\t\tclamp();\r\n\t}","id":71880,"modified_method":"/** @return this Color for chaining */\r\n\tpublic Color sub (float r, float g, float b, float a) {\r\n\t\tthis.r -= r;\r\n\t\tthis.g -= g;\r\n\t\tthis.b -= b;\r\n\t\tthis.a -= a;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Adds the given color to this color.\r\n\t * \r\n\t * @param color the color\r\n\t * @return this color */\r\n\tpublic Color add (Color color) {\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\t\tthis.a += color.a;\r\n\t\tclamp();\r\n\t\treturn this;\r\n\t}","id":71881,"modified_method":"/** Adds the given color to this color.\r\n\t * \r\n\t * @param color the color\r\n\t * @return this color */\r\n\tpublic Color add (Color color) {\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\t\tthis.a += color.a;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void mul (float r, float g, float b, float a) {\r\n\t\tthis.r *= r;\r\n\t\tthis.g *= g;\r\n\t\tthis.b *= b;\r\n\t\tthis.a *= a;\r\n\t\tclamp();\r\n\t}","id":71882,"modified_method":"/** @return this Color for chaining */\r\n\tpublic Color mul (float r, float g, float b, float a) {\r\n\t\tthis.r *= r;\r\n\t\tthis.g *= g;\r\n\t\tthis.b *= b;\r\n\t\tthis.a *= a;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void clamp () {\r\n\t\tif (r < 0)\r\n\t\t\tr = 0;\r\n\t\telse if (r > 1) r = 1;\r\n\r\n\t\tif (g < 0)\r\n\t\t\tg = 0;\r\n\t\telse if (g > 1) g = 1;\r\n\r\n\t\tif (b < 0)\r\n\t\t\tb = 0;\r\n\t\telse if (b > 1) b = 1;\r\n\r\n\t\tif (a < 0)\r\n\t\t\ta = 0;\r\n\t\telse if (a > 1) a = 1;\r\n\t}","id":71883,"modified_method":"/** @return this Color for chaining */\r\n\tpublic Color clamp () {\r\n\t\tif (r < 0)\r\n\t\t\tr = 0;\r\n\t\telse if (r > 1) r = 1;\r\n\r\n\t\tif (g < 0)\r\n\t\t\tg = 0;\r\n\t\telse if (g > 1) g = 1;\r\n\r\n\t\tif (b < 0)\r\n\t\t\tb = 0;\r\n\t\telse if (b > 1) b = 1;\r\n\r\n\t\tif (a < 0)\r\n\t\t\ta = 0;\r\n\t\telse if (a > 1) a = 1;\r\n\t\treturn this;\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Subtracts the given color from this color\r\n\t * \r\n\t * @param color the color\r\n\t * @return this color */\r\n\tpublic Color sub (Color color) {\r\n\t\tthis.r -= color.r;\r\n\t\tthis.g -= color.g;\r\n\t\tthis.b -= color.b;\r\n\t\tthis.a -= color.a;\r\n\t\tclamp();\r\n\t\treturn this;\r\n\t}","id":71884,"modified_method":"/** Subtracts the given color from this color\r\n\t * \r\n\t * @param color the color\r\n\t * @return this color */\r\n\tpublic Color sub (Color color) {\r\n\t\tthis.r -= color.r;\r\n\t\tthis.g -= color.g;\r\n\t\tthis.b -= color.b;\r\n\t\tthis.a -= color.a;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Multiplies all components of this Color with the given value.\r\n\t * \r\n\t * @param value the value\r\n\t * @return this color */\r\n\tpublic Color mul (float value) {\r\n\t\tthis.r *= value;\r\n\t\tthis.g *= value;\r\n\t\tthis.b *= value;\r\n\t\tthis.a *= value;\r\n\t\tclamp();\r\n\t\treturn this;\r\n\t}","id":71885,"modified_method":"/** Multiplies all components of this Color with the given value.\r\n\t * \r\n\t * @param value the value\r\n\t * @return this color */\r\n\tpublic Color mul (float value) {\r\n\t\tthis.r *= value;\r\n\t\tthis.g *= value;\r\n\t\tthis.b *= value;\r\n\t\tthis.a *= value;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Sets this color to the given color.\r\n\t * \r\n\t * @param color the Color */\r\n\tpublic Color set (Color color) {\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\t\tthis.a = color.a;\r\n\t\tclamp();\r\n\t\treturn this;\r\n\t}","id":71886,"modified_method":"/** Sets this color to the given color.\r\n\t * \r\n\t * @param color the Color */\r\n\tpublic Color set (Color color) {\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\t\tthis.a = color.a;\r\n\t\treturn this;\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Multiplies the this color and the given color\r\n\t * \r\n\t * @param color the color\r\n\t * @return this color. */\r\n\tpublic Color mul (Color color) {\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\t\tthis.a *= color.a;\r\n\t\tclamp();\r\n\t\treturn this;\r\n\t}","id":71887,"modified_method":"/** Multiplies the this color and the given color\r\n\t * \r\n\t * @param color the color\r\n\t * @return this color. */\r\n\tpublic Color mul (Color color) {\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\t\tthis.a *= color.a;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void add (float r, float g, float b, float a) {\r\n\t\tthis.r += r;\r\n\t\tthis.g += g;\r\n\t\tthis.b += b;\r\n\t\tthis.a += a;\r\n\t\tclamp();\r\n\t}","id":71888,"modified_method":"/** @return this Color for chaining */\r\n\tpublic Color add (float r, float g, float b, float a) {\r\n\t\tthis.r += r;\r\n\t\tthis.g += g;\r\n\t\tthis.b += b;\r\n\t\tthis.a += a;\r\n\t\treturn clamp();\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"/** Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The\r\n\t * {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or  {@link ShapeType#Line}.\r\n\t * @param x\r\n\t * @param y\r\n\t * @param width\r\n\t * @param height */\r\n\tpublic void rect(float x, float y, float width, float height, Color col1, Color col2, Color col3, Color col4){\r\n\t\tif (currType != ShapeType.Filled && currType != ShapeType.Line) \r\n\t\t\tthrow new GdxRuntimeException(\"Must call begin(ShapeType.Filled) or begin(ShapeType.Line)\");\r\n\t\t\r\n\t\tcheckDirty();\r\n\t\tcheckFlush(8);\r\n\t\t\r\n\t\tif(currType == ShapeType.Line){\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(col2.r, col2.g, col2.b, col2.a);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\r\n\t\t\trenderer.color(col2.r, col2.g, col2.b, col2.a);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(col4.r, col4.g, col4.b, col4.a);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\r\n\t\t\trenderer.color(col4.r, col4.g, col4.b, col4.a);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(col2.r, col2.g, col2.b, col2.a);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(col4.r, col4.g, col4.b, col4.a);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t}\r\n\t}","id":71889,"modified_method":"/** Draws a rectangle in the x/y plane. The x and y coordinate specify the bottom left corner of the rectangle. The\r\n\t * {@link ShapeType} passed to begin has to be {@link ShapeType#Filled} or  {@link ShapeType#Line}.\r\n\t * @param x\r\n\t * @param y\r\n\t * @param width\r\n\t * @param height \r\n\t * @param col1 The color at (x, y) \r\n\t * @param col2 The color at (x + width, y)\r\n\t * @param col3 The color at (x + width, y + height)\r\n\t * @param col4 The color at (x, y + height) */\r\n\tpublic void rect(float x, float y, float width, float height, Color col1, Color col2, Color col3, Color col4){\r\n\t\tif (currType != ShapeType.Filled && currType != ShapeType.Line) \r\n\t\t\tthrow new GdxRuntimeException(\"Must call begin(ShapeType.Filled) or begin(ShapeType.Line)\");\r\n\t\t\r\n\t\tcheckDirty();\r\n\t\tcheckFlush(8);\r\n\t\t\r\n\t\tif(currType == ShapeType.Line){\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(col2.r, col2.g, col2.b, col2.a);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\r\n\t\t\trenderer.color(col2.r, col2.g, col2.b, col2.a);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(col4.r, col4.g, col4.b, col4.a);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\r\n\t\t\trenderer.color(col4.r, col4.g, col4.b, col4.a);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t\trenderer.color(col2.r, col2.g, col2.b, col2.a);\r\n\t\t\trenderer.vertex(x + width, y, 0);\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\r\n\t\t\trenderer.color(col3.r, col3.g, col3.b, col3.a);\r\n\t\t\trenderer.vertex(x + width, y + height, 0);\r\n\t\t\trenderer.color(col4.r, col4.g, col4.b, col4.a);\r\n\t\t\trenderer.vertex(x, y + height, 0);\r\n\t\t\trenderer.color(col1.r, col1.g, col1.b, col1.a);\r\n\t\t\trenderer.vertex(x, y, 0);\r\n\t\t}\r\n\t}","commit_id":"6aa222f5768a9a05b8f3cf8dd97415654a129698","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        Task task;\n        for(long seqno=first_seqno; seqno <= last_seqno; seqno++) {\n            // each task needs its own retransmission interval, as they are stateful *and* mutable, so we *need* to copy !\n            task=new Task(seqno, RETRANSMIT_TIMEOUTS.copy(), cmd, sender);\n            msgs.putIfAbsent(seqno, task);\n            task.doSchedule(timer); // Entry adds itself to the timer\n        }\n\n    }","id":71890,"modified_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        Task new_task;\n        for(long seqno=first_seqno; seqno <= last_seqno; seqno++) {\n            // each task needs its own retransmission interval, as they are stateful *and* mutable, so we *need* to copy !\n            new_task=new Task(seqno, RETRANSMIT_TIMEOUTS.copy(), cmd, sender);\n            Task old_task=msgs.putIfAbsent(seqno, new_task);\n            if(old_task == null) // only schedule if we actually *added* the new task !\n                new_task.doSchedule(timer); // Entry adds itself to the timer\n        }\n\n    }","commit_id":"582b485f45a52b108d9349552624061ed570aafe","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void main(String[] args) {\n        Retransmitter xmitter;\n        Address sender;\n\n        try {\n            sender=new org.jgroups.stack.IpAddress(\"localhost\", 5555);\n            xmitter=new Retransmitter(sender, new MyXmitter());\n            xmitter.setRetransmitTimeouts(new StaticInterval(1000, 2000, 4000, 8000));\n\n            xmitter.add(1, 10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(1);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(2);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(4);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(3000);\n            xmitter.remove(3);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(1000);\n            xmitter.remove(10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(8);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(6);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(7);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(9);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(5);\n            System.out.println(\"retransmitter: \" + xmitter);\n        }\n        catch(Exception e) {\n            log.error(e);\n        }\n    }","id":71891,"modified_method":"public static void main(String[] args) {\n        Retransmitter xmitter;\n        Address sender;\n\n        try {\n            sender=new org.jgroups.stack.IpAddress(\"localhost\", 5555);\n            xmitter=new Retransmitter(sender, new MyXmitter());\n            xmitter.setRetransmitTimeouts(new StaticInterval(1000, 2000, 4000, 8000));\n\n            xmitter.add(1, 10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(1);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(2);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(4);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(3000);\n            xmitter.remove(3);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(1000);\n            xmitter.remove(10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(8);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(6);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(7);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(9);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(5);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.stop();\n        }\n        catch(Exception e) {\n            log.error(e);\n        }\n    }","commit_id":"b5a4f1528fe5392e902a2fb5dcdb75b063fa05ef","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n        synchronized(msgs) {\n            int size=size();\n            StringBuilder sb=new StringBuilder();\n            sb.append(size).append(\" messages to retransmit: \").append(msgs);\n            return sb.toString();\n        }\n    }","id":71892,"modified_method":"public String toString() {\n        int size=size();\n        StringBuilder sb=new StringBuilder();\n        sb.append(size).append(\" messages to retransmit: \").append(msgs.keySet());\n        return sb.toString();\n    }","commit_id":"b5a4f1528fe5392e902a2fb5dcdb75b063fa05ef","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Reset the retransmitter: clear all msgs and cancel all the\n     * respective tasks\n     */\n    public void reset() {\n        synchronized(msgs) {\n            for(Entry entry: msgs) {\n                entry.cancel();\n            }\n            msgs.clear();\n        }\n    }","id":71893,"modified_method":"/**\n     * Reset the retransmitter: clear all msgs and cancel all the\n     * respective tasks\n     */\n    public void reset() {\n        for(Task task: msgs.values())\n            task.cancel();\n        msgs.clear();\n    }","commit_id":"b5a4f1528fe5392e902a2fb5dcdb75b063fa05ef","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Remove the given sequence number from the list of seqnos eligible\n     * for retransmission. If there are no more seqno intervals in the\n     * respective entry, cancel the entry from the retransmission\n     * scheduler and remove it from the pending entries\n     */\n    public int remove(long seqno) {\n        Entry e;\n        int num_retransmits=-1;\n\n        synchronized(msgs) {\n            for(ListIterator<Entry> it=msgs.listIterator(); it.hasNext();) {\n                e=it.next();\n                if(seqno < e.low || seqno > e.high) continue;\n                e.remove(seqno);\n                if(e.low > e.high) {\n                    e.cancel();\n                    it.remove();\n                }\n                num_retransmits=e.getNumRetransmits();\n                break;\n            }\n        }\n\n        return num_retransmits;\n    }","id":71894,"modified_method":"/**\n     * Remove the given sequence number from the list of seqnos eligible\n     * for retransmission. If there are no more seqno intervals in the\n     * respective entry, cancel the entry from the retransmission\n     * scheduler and remove it from the pending entries\n     */\n    public int remove(long seqno) {\n        Task task=msgs.remove(seqno);\n        if(task != null) {\n            task.cancel();\n            return task.getNumRetransmits();\n        }\n        return -1;\n    }","commit_id":"b5a4f1528fe5392e902a2fb5dcdb75b063fa05ef","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Stop the rentransmition and clear all pending msgs.\n     * <p>\n     * If this retransmitter has been provided  an externally managed\n     * scheduler, then just clear all msgs and the associated tasks, else\n     * stop the scheduler. In this case the method blocks until the\n     * scheduler's thread is dead. Only the owner of the scheduler should\n     * stop it.\n     */\n    public void stop() {\n        // i. If retransmitter is owned, stop it else cancel all tasks\n        // ii. Clear all pending msgs\n        synchronized(msgs) {\n            if(retransmitter_owned) {\n                try {\n                    timer.stop();\n                }\n                catch(InterruptedException ex) {\n                    if(log.isErrorEnabled()) log.error(\"failed stopping retransmitter\", ex);\n                    Thread.currentThread().interrupt(); // set interrupt flag again\n                }\n            }\n            else {\n                for(Entry entry: msgs) {\n                    entry.cancel();\n                }\n            }\n            msgs.clear();\n        }\n    }","id":71895,"modified_method":"/**\n     * Stop the rentransmition and clear all pending msgs.\n     * <p>\n     * If this retransmitter has been provided  an externally managed\n     * scheduler, then just clear all msgs and the associated tasks, else\n     * stop the scheduler. In this case the method blocks until the\n     * scheduler's thread is dead. Only the owner of the scheduler should\n     * stop it.\n     */\n    public void stop() {\n        // i. If retransmitter is owned, stop it else cancel all tasks\n        // ii. Clear all pending msgs\n        if(retransmitter_owned) {\n            try {\n                timer.stop();\n            }\n            catch(InterruptedException ex) {\n                if(log.isErrorEnabled()) log.error(\"failed stopping retransmitter\", ex);\n                Thread.currentThread().interrupt(); // set interrupt flag again\n            }\n        }\n        else {\n            for(Task task: msgs.values())\n                task.cancel();\n        }\n        msgs.clear();\n    }","commit_id":"b5a4f1528fe5392e902a2fb5dcdb75b063fa05ef","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n        int size=0;\n        synchronized(msgs) {\n            for(Entry entry: msgs) {\n                size+=entry.size();\n            }\n        }\n        return size;\n    }","id":71896,"modified_method":"public int size() {\n        return msgs.size();\n    }","commit_id":"b5a4f1528fe5392e902a2fb5dcdb75b063fa05ef","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        // each entry needs its own retransmission interval, intervals are stateful *and* mutable, so we *need* to copy !\n        Entry entry=new Entry(first_seqno, last_seqno, RETRANSMIT_TIMEOUTS.copy());\n        synchronized(msgs) {\n            msgs.add(entry);\n        }\n        entry.doSchedule(timer); // Entry adds itself to the timer\n    }","id":71897,"modified_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        Task task;\n        for(long seqno=first_seqno; seqno <= last_seqno; seqno++) {\n            // each task needs its own retransmission interval, as they are stateful *and* mutable, so we *need* to copy !\n            task=new Task(seqno, RETRANSMIT_TIMEOUTS.copy(), cmd, sender);\n            msgs.putIfAbsent(seqno, task);\n            task.doSchedule(timer); // Entry adds itself to the timer\n        }\n\n    }","commit_id":"b5a4f1528fe5392e902a2fb5dcdb75b063fa05ef","url":"https://github.com/belaban/JGroups"},{"original_method":"public String toString() {\n        synchronized(msgs) {\n            int size=size();\n            StringBuilder sb=new StringBuilder();\n            sb.append(size).append(\" messages to retransmit: \").append(msgs);\n            return sb.toString();\n        }\n    }","id":71898,"modified_method":"public String toString() {\n        int size=size();\n        StringBuilder sb=new StringBuilder();\n        sb.append(size).append(\" messages to retransmit: \").append(msgs.keySet());\n        return sb.toString();\n    }","commit_id":"b73a2229e5a4958edc5c4ff541ebf93bc7ba45c5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Remove the given sequence number from the list of seqnos eligible\n     * for retransmission. If there are no more seqno intervals in the\n     * respective entry, cancel the entry from the retransmission\n     * scheduler and remove it from the pending entries\n     */\n    public int remove(long seqno) {\n        Entry e;\n        int num_retransmits=-1;\n\n        synchronized(msgs) {\n            for(ListIterator<Entry> it=msgs.listIterator(); it.hasNext();) {\n                e=it.next();\n                if(seqno < e.low || seqno > e.high) continue;\n                e.remove(seqno);\n                if(e.low > e.high) {\n                    e.cancel();\n                    it.remove();\n                }\n                num_retransmits=e.getNumRetransmits();\n                break;\n            }\n        }\n\n        return num_retransmits;\n    }","id":71899,"modified_method":"/**\n     * Remove the given sequence number from the list of seqnos eligible\n     * for retransmission. If there are no more seqno intervals in the\n     * respective entry, cancel the entry from the retransmission\n     * scheduler and remove it from the pending entries\n     */\n    public int remove(long seqno) {\n        Task task=msgs.remove(seqno);\n        if(task != null) {\n            task.cancel();\n            return task.getNumRetransmits();\n        }\n        return -1;\n    }","commit_id":"b73a2229e5a4958edc5c4ff541ebf93bc7ba45c5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Stop the rentransmition and clear all pending msgs.\n     * <p>\n     * If this retransmitter has been provided  an externally managed\n     * scheduler, then just clear all msgs and the associated tasks, else\n     * stop the scheduler. In this case the method blocks until the\n     * scheduler's thread is dead. Only the owner of the scheduler should\n     * stop it.\n     */\n    public void stop() {\n        // i. If retransmitter is owned, stop it else cancel all tasks\n        // ii. Clear all pending msgs\n        synchronized(msgs) {\n            if(retransmitter_owned) {\n                try {\n                    timer.stop();\n                }\n                catch(InterruptedException ex) {\n                    if(log.isErrorEnabled()) log.error(\"failed stopping retransmitter\", ex);\n                    Thread.currentThread().interrupt(); // set interrupt flag again\n                }\n            }\n            else {\n                for(Entry entry: msgs) {\n                    entry.cancel();\n                }\n            }\n            msgs.clear();\n        }\n    }","id":71900,"modified_method":"/**\n     * Stop the rentransmition and clear all pending msgs.\n     * <p>\n     * If this retransmitter has been provided  an externally managed\n     * scheduler, then just clear all msgs and the associated tasks, else\n     * stop the scheduler. In this case the method blocks until the\n     * scheduler's thread is dead. Only the owner of the scheduler should\n     * stop it.\n     */\n    public void stop() {\n        // i. If retransmitter is owned, stop it else cancel all tasks\n        // ii. Clear all pending msgs\n        if(retransmitter_owned) {\n            try {\n                timer.stop();\n            }\n            catch(InterruptedException ex) {\n                if(log.isErrorEnabled()) log.error(\"failed stopping retransmitter\", ex);\n                Thread.currentThread().interrupt(); // set interrupt flag again\n            }\n        }\n        else {\n            for(Task task: msgs.values())\n                task.cancel();\n        }\n        msgs.clear();\n    }","commit_id":"b73a2229e5a4958edc5c4ff541ebf93bc7ba45c5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        // each entry needs its own retransmission interval, intervals are stateful *and* mutable, so we *need* to copy !\n        Entry entry=new Entry(first_seqno, last_seqno, RETRANSMIT_TIMEOUTS.copy());\n        synchronized(msgs) {\n            msgs.add(entry);\n        }\n        entry.doSchedule(timer); // Entry adds itself to the timer\n    }","id":71901,"modified_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        Task task;\n        for(long seqno=first_seqno; seqno <= last_seqno; seqno++) {\n            // each task needs its own retransmission interval, as they are stateful *and* mutable, so we *need* to copy !\n            task=new Task(seqno, RETRANSMIT_TIMEOUTS.copy(), cmd, sender);\n            msgs.putIfAbsent(seqno, task);\n            task.doSchedule(timer); // Entry adds itself to the timer\n        }\n\n    }","commit_id":"b73a2229e5a4958edc5c4ff541ebf93bc7ba45c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public static void main(String[] args) {\n        Retransmitter xmitter;\n        Address sender;\n\n        try {\n            sender=new org.jgroups.stack.IpAddress(\"localhost\", 5555);\n            xmitter=new Retransmitter(sender, new MyXmitter());\n            xmitter.setRetransmitTimeouts(new StaticInterval(1000, 2000, 4000, 8000));\n\n            xmitter.add(1, 10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(1);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(2);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(4);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(3000);\n            xmitter.remove(3);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(1000);\n            xmitter.remove(10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(8);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(6);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(7);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(9);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(5);\n            System.out.println(\"retransmitter: \" + xmitter);\n        }\n        catch(Exception e) {\n            log.error(e);\n        }\n    }","id":71902,"modified_method":"public static void main(String[] args) {\n        Retransmitter xmitter;\n        Address sender;\n\n        try {\n            sender=new org.jgroups.stack.IpAddress(\"localhost\", 5555);\n            xmitter=new Retransmitter(sender, new MyXmitter());\n            xmitter.setRetransmitTimeouts(new StaticInterval(1000, 2000, 4000, 8000));\n\n            xmitter.add(1, 10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(1);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(2);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(4);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(3000);\n            xmitter.remove(3);\n            System.out.println(\"retransmitter: \" + xmitter);\n\n            Util.sleep(1000);\n            xmitter.remove(10);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(8);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(6);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(7);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(9);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.remove(5);\n            System.out.println(\"retransmitter: \" + xmitter);\n            xmitter.stop();\n        }\n        catch(Exception e) {\n            log.error(e);\n        }\n    }","commit_id":"b73a2229e5a4958edc5c4ff541ebf93bc7ba45c5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Reset the retransmitter: clear all msgs and cancel all the\n     * respective tasks\n     */\n    public void reset() {\n        synchronized(msgs) {\n            for(Entry entry: msgs) {\n                entry.cancel();\n            }\n            msgs.clear();\n        }\n    }","id":71903,"modified_method":"/**\n     * Reset the retransmitter: clear all msgs and cancel all the\n     * respective tasks\n     */\n    public void reset() {\n        for(Task task: msgs.values())\n            task.cancel();\n        msgs.clear();\n    }","commit_id":"b73a2229e5a4958edc5c4ff541ebf93bc7ba45c5","url":"https://github.com/belaban/JGroups"},{"original_method":"public int size() {\n        int size=0;\n        synchronized(msgs) {\n            for(Entry entry: msgs) {\n                size+=entry.size();\n            }\n        }\n        return size;\n    }","id":71904,"modified_method":"public int size() {\n        return msgs.size();\n    }","commit_id":"b73a2229e5a4958edc5c4ff541ebf93bc7ba45c5","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        Task task;\n        for(long seqno=first_seqno; seqno <= last_seqno; seqno++) {\n            // each task needs its own retransmission interval, as they are stateful *and* mutable, so we *need* to copy !\n            task=new Task(seqno, RETRANSMIT_TIMEOUTS.copy(), cmd, sender);\n            msgs.putIfAbsent(seqno, task);\n            task.doSchedule(timer); // Entry adds itself to the timer\n        }\n\n    }","id":71905,"modified_method":"/**\n     * Add the given range [first_seqno, last_seqno] in the list of\n     * entries eligible for retransmission. If first_seqno > last_seqno,\n     * then the range [last_seqno, first_seqno] is added instead\n     * <p>\n     * If retransmitter thread is suspended, wake it up\n     */\n    public void add(long first_seqno, long last_seqno) {\n        if(first_seqno > last_seqno) {\n            long tmp=first_seqno;\n            first_seqno=last_seqno;\n            last_seqno=tmp;\n        }\n\n        Task new_task;\n        for(long seqno=first_seqno; seqno <= last_seqno; seqno++) {\n            // each task needs its own retransmission interval, as they are stateful *and* mutable, so we *need* to copy !\n            new_task=new Task(seqno, RETRANSMIT_TIMEOUTS.copy(), cmd, sender);\n            Task old_task=msgs.putIfAbsent(seqno, new_task);\n            if(old_task == null) // only schedule if we actually *added* the new task !\n                new_task.doSchedule(timer); // Entry adds itself to the timer\n        }\n\n    }","commit_id":"cf71ed29658aab1f159d69cdc2b186087643d981","url":"https://github.com/belaban/JGroups"},{"original_method":"private int calculateAlignmentStartShift(Cigar oldCigar, Cigar newCigar) {\n        int shift = 0;\n\n        // Rewind to previous start (by counting everything that was already clipped in this read)\n        for (CigarElement cigarElement : oldCigar.getCigarElements()) {\n            if (!cigarElement.getOperator().consumesReferenceBases())\n                shift -= cigarElement.getLength();\n            else\n                break;\n        }\n\n        // Advance to new start (by counting everything new that has been clipped )\n        for (CigarElement cigarElement : newCigar.getCigarElements()) {\n            if (!cigarElement.getOperator().consumesReferenceBases())\n                shift += cigarElement.getLength();\n            else\n                break;\n        }\n\n        return shift;\n    }","id":71906,"modified_method":"private int calculateAlignmentStartShift(Cigar oldCigar, Cigar newCigar) {\n        int newShift = 0;\n        int oldShift = 0;\n        int deletionShift = 0;\n\n        for (CigarElement cigarElement : newCigar.getCigarElements()) {\n            if (cigarElement.getOperator() == CigarOperator.HARD_CLIP || cigarElement.getOperator() == CigarOperator.SOFT_CLIP)\n                newShift += cigarElement.getLength();\n            else\n                break;\n        }\n\n        for (CigarElement cigarElement : oldCigar.getCigarElements()) {\n            if (cigarElement.getOperator() == CigarOperator.HARD_CLIP || cigarElement.getOperator() == CigarOperator.SOFT_CLIP )\n                oldShift += Math.min(cigarElement.getLength(), newShift - oldShift);\n            else\n                break;\n        }\n\n        int basesClipped = 0;\n        for (CigarElement cigarElement : oldCigar.getCigarElements()) {\n            if (basesClipped > newShift)                                        // are we beyond the clipped region?\n                break;\n\n            else if (cigarElement.getOperator() == CigarOperator.DELETION)      // if this is a deletion, we have to adjust the starting shift\n                deletionShift += cigarElement.getLength();\n\n            else if (cigarElement.getOperator() != CigarOperator.INSERTION)     // if it's not an insertion or deletion, than it counts as hard clipped base.\n                basesClipped += cigarElement.getLength();\n        }\n\n        return newShift - oldShift + deletionShift;\n    }","commit_id":"4e9020c9f7bd6fc429090213ad06c9a6b46ecc70","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        final FieldRepr fieldRepr = (FieldRepr) o;\n\n        return name.equals(fieldRepr.name) && type.equals(fieldRepr.type);\n    }","id":71907,"modified_method":"@Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        final FieldRepr fieldRepr = (FieldRepr) o;\n\n        return name.equals(fieldRepr.name);\n    }","commit_id":"c167108e0eb14f788daf43dfb8e999803859b68c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public int hashCode() {\n        return 31 * name.hashCode() + type.hashCode();\n    }","id":71908,"modified_method":"@Override\n    public int hashCode() {\n        return 31 * name.hashCode();\n    }","commit_id":"c167108e0eb14f788daf43dfb8e999803859b68c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean differentiate(final Mappings delta, final Set<StringCache.S> removed, final Set<StringCache.S> compiledFiles, final Set<StringCache.S> affectedFiles, final Set<StringCache.S> safeFiles) {\n        if (removed != null) {\n            for (StringCache.S file : removed) {\n                affectAll(file, affectedFiles);\n            }\n        }\n\n        for (StringCache.S fileName : delta.sourceFileToClasses.keySet()) {\n            if (safeFiles.contains(fileName)) {\n                continue;\n            }\n\n            final Set<ClassRepr> classes = (Set<ClassRepr>) delta.sourceFileToClasses.foxyGet(fileName);\n            final Set<ClassRepr> pastClasses = (Set<ClassRepr>) sourceFileToClasses.foxyGet(fileName);\n            final Set<StringCache.S> dependants = (Set<StringCache.S>) fileToFileDependency.foxyGet(fileName);\n            final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n            final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n            final Map<UsageRepr.Usage, UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, UsageConstraint>();\n\n            final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n            for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n                final ClassRepr it = changed.fst;\n                final ClassRepr.Diff diff = (ClassRepr.Diff) changed.snd;\n\n                final int addedModifiers = diff.addedModifiers();\n                final int removedModifiers = diff.removedModifiers();\n\n                if ((diff.base() & Difference.SUPERCLASS) > 0) {\n                    affectSubclasses(it.name, affectedFiles);\n                    if (!diff.extendsAdded()) {\n                        affectedUsages.add(it.createUsage());\n                    }\n                }\n\n                if (!diff.interfaces().unchanged()) {\n                    if (!diff.interfaces().removed().isEmpty()) {\n                        affectedUsages.add(it.createUsage());\n                    }\n\n                    affectSubclasses(it.name, affectedFiles);\n                }\n\n                if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 ||\n                        (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n                    affectedUsages.add(it.createUsage());\n                }\n\n                if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n                    return false;\n                }\n\n                if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n                    final UsageRepr.Usage usage = it.createUsage();\n\n                    affectedUsages.add(usage);\n                    usageConstraints.put(usage, new InheritanceConstraint(it.name));\n                }\n\n                if (diff.packageLocalOn()) {\n                    final UsageRepr.Usage usage = it.createUsage();\n\n                    affectedUsages.add(usage);\n                    usageConstraints.put(usage, new PackageConstraint(it.getPackageName()));\n                }\n\n                if ((addedModifiers & Opcodes.ACC_FINAL) > 0 ||\n                        (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n                    affectedUsages.add(it.createUsage());\n                }\n\n                if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n                    affectedUsages.add(UsageRepr.createClassNewUsage(it.name));\n                }\n\n                if ((addedModifiers & Opcodes.ACC_STATIC) > 0 ||\n                        (removedModifiers & Opcodes.ACC_STATIC) > 0 ||\n                        (addedModifiers & Opcodes.ACC_ABSTRACT) > 0\n                        ) {\n                    affectedUsages.add(UsageRepr.createClassNewUsage(it.name));\n                }\n\n                if (it.isAnnotation()) {\n                    if (diff.retentionChanged()) {\n                        affectedUsages.add(it.createUsage());\n                    } else {\n                        final Collection<ElementType> removedtargets = diff.targets().removed();\n\n                        if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n                            return false;\n                        }\n\n                        if (!removedtargets.isEmpty()) {\n                            annotationQuery.add((UsageRepr.AnnotationUsage) UsageRepr.createAnnotationUsage(TypeRepr.createClassType(it.name), null, removedtargets));\n                        }\n\n                        for (MethodRepr m : diff.methods().added()) {\n                            if (!m.hasValue()) {\n                                affectedUsages.add(it.createUsage());\n                            }\n                        }\n                    }\n                }\n\n                for (MethodRepr m : diff.methods().removed()) {\n                    affectedUsages.add(m.createUsage(it.name));\n                }\n\n                for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n                    final MethodRepr m = mr.fst;\n                    final MethodRepr.Diff d = (MethodRepr.Diff) mr.snd;\n\n                    if (it.isAnnotation()) {\n                        if (d.defaultRemoved()) {\n                            final List<StringCache.S> l = new LinkedList<StringCache.S>();\n                            l.add(m.name);\n                            annotationQuery.add((UsageRepr.AnnotationUsage) UsageRepr.createAnnotationUsage(TypeRepr.createClassType(it.name), l, null));\n                        }\n                    } else if (d.base() != Difference.NONE) {\n                        // TODO!!\n                        if (d.base() == Difference.ACCESS && d.removedModifiers() == Opcodes.ACC_ABSTRACT) {\n\n                        } else {\n                            affectedUsages.add(mr.fst.createUsage(it.name));\n                        }\n                    }\n                }\n\n                final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n                for (FieldRepr f : diff.fields().removed()) {\n                    if ((f.access & mask) == mask) {\n                        return false;\n                    }\n\n                    affectedUsages.add(f.createUsage(it.name));\n                }\n\n                for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n                    final Difference d = f.snd;\n                    final FieldRepr field = f.fst;\n\n                    if ((field.access & mask) == mask) {\n                        if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n                            return false;\n                        }\n                    }\n\n                    if ((d.base() & Difference.ACCESS) > 0) {\n                        final Collection<StringCache.S> propagated = propagateFieldAccess(field.name, it.name);\n\n                        if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                            affectedUsages.add(field.createAssignUsage(it.name));\n                            for (StringCache.S p : propagated) {\n                                affectedUsages.add(field.createAssignUsage(p));\n                            }\n                        }\n\n                        if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                            (d.removedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                            affectedUsages.add(field.createUsage(it.name));\n                            for (StringCache.S p : propagated) {\n                                affectedUsages.add(field.createUsage(p));\n                            }\n                        }\n                    } else {\n                        if (d.base() != Difference.NONE) {\n                            affectedUsages.add(field.createUsage(it.name));\n                        }\n                    }\n                }\n            }\n\n            for (ClassRepr c : classDiff.removed()) {\n                affectedUsages.add(c.createUsage());\n            }\n\n            if (dependants != null) {\n                dependants.removeAll(compiledFiles);\n\n                filewise:\n                for (StringCache.S depFile : dependants) {\n                    if (affectedFiles.contains(depFile)) {\n                        continue filewise;\n                    }\n\n                    final UsageRepr.Cluster depCluster = sourceFileToUsages.get(depFile);\n                    final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n                    if (depUsages != null) {\n                        final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n                        usages.retainAll(affectedUsages);\n\n                        if (!usages.isEmpty()) {\n                            for (UsageRepr.Usage usage : usages) {\n                                final UsageConstraint constraint = usageConstraints.get(usage);\n\n                                if (constraint == null) {\n                                    affectedFiles.add(depFile);\n                                    continue filewise;\n                                } else {\n                                    final Set<StringCache.S> residenceClasses = depCluster.getResidence(usage);\n                                    for (StringCache.S residentName : residenceClasses) {\n                                        if (constraint.checkResidence(residentName)) {\n                                            affectedFiles.add(depFile);\n                                            continue filewise;\n                                        }\n                                    }\n\n                                }\n                            }\n                        }\n\n                        if (annotationQuery.size() > 0) {\n                            final Collection<UsageRepr.Usage> annotationUsages = sourceFileToAnnotationUsages.foxyGet(depFile);\n\n                            for (UsageRepr.Usage usage : annotationUsages) {\n                                for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                                    if (query.satisfies(usage)) {\n                                        affectedFiles.add(depFile);\n                                        continue filewise;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","id":71909,"modified_method":"public boolean differentiate(final Mappings delta, final Set<StringCache.S> removed, final Set<StringCache.S> compiledFiles, final Set<StringCache.S> affectedFiles, final Set<StringCache.S> safeFiles) {\n        if (removed != null) {\n            for (StringCache.S file : removed) {\n                affectAll(file, affectedFiles);\n            }\n        }\n\n        for (StringCache.S fileName : delta.sourceFileToClasses.keySet()) {\n            if (safeFiles.contains(fileName)) {\n                continue;\n            }\n\n            final Set<ClassRepr> classes = (Set<ClassRepr>) delta.sourceFileToClasses.foxyGet(fileName);\n            final Set<ClassRepr> pastClasses = (Set<ClassRepr>) sourceFileToClasses.foxyGet(fileName);\n            final Set<StringCache.S> dependants = (Set<StringCache.S>) fileToFileDependency.foxyGet(fileName);\n            final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n            final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n            final Map<UsageRepr.Usage, UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, UsageConstraint>();\n\n            final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n            for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n                final ClassRepr it = changed.fst;\n                final ClassRepr.Diff diff = (ClassRepr.Diff) changed.snd;\n\n                final int addedModifiers = diff.addedModifiers();\n                final int removedModifiers = diff.removedModifiers();\n\n                final boolean superClassChanged = (diff.base() & Difference.SUPERCLASS) > 0;\n                final boolean interfacesChanged = !diff.interfaces().unchanged();\n\n                if (superClassChanged || interfacesChanged) {\n                    final boolean extendsChanged = superClassChanged && !diff.extendsAdded();\n                    final boolean interfacesRemoved = interfacesChanged && !diff.interfaces().removed().isEmpty();\n\n                    affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, extendsChanged || interfacesRemoved);\n                }\n\n                if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 ||\n                        (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n                    affectedUsages.add(it.createUsage());\n                }\n\n                if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n                    return false;\n                }\n\n                if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n                    final UsageRepr.Usage usage = it.createUsage();\n\n                    affectedUsages.add(usage);\n                    usageConstraints.put(usage, new InheritanceConstraint(it.name));\n                }\n\n                if (diff.packageLocalOn()) {\n                    final UsageRepr.Usage usage = it.createUsage();\n\n                    affectedUsages.add(usage);\n                    usageConstraints.put(usage, new PackageConstraint(it.getPackageName()));\n                }\n\n                if ((addedModifiers & Opcodes.ACC_FINAL) > 0 ||\n                        (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n                    affectedUsages.add(it.createUsage());\n                }\n\n                if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n                    affectedUsages.add(UsageRepr.createClassNewUsage(it.name));\n                }\n\n                if ((addedModifiers & Opcodes.ACC_STATIC) > 0 ||\n                        (removedModifiers & Opcodes.ACC_STATIC) > 0 ||\n                        (addedModifiers & Opcodes.ACC_ABSTRACT) > 0\n                        ) {\n                    affectedUsages.add(UsageRepr.createClassNewUsage(it.name));\n                }\n\n                if (it.isAnnotation()) {\n                    if (diff.retentionChanged()) {\n                        affectedUsages.add(it.createUsage());\n                    } else {\n                        final Collection<ElementType> removedtargets = diff.targets().removed();\n\n                        if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n                            return false;\n                        }\n\n                        if (!removedtargets.isEmpty()) {\n                            annotationQuery.add((UsageRepr.AnnotationUsage) UsageRepr.createAnnotationUsage(TypeRepr.createClassType(it.name), null, removedtargets));\n                        }\n\n                        for (MethodRepr m : diff.methods().added()) {\n                            if (!m.hasValue()) {\n                                affectedUsages.add(it.createUsage());\n                            }\n                        }\n                    }\n                }\n\n                for (MethodRepr m : diff.methods().removed()) {\n                    affectedUsages.add(m.createUsage(it.name));\n                }\n\n                for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n                    final MethodRepr m = mr.fst;\n                    final MethodRepr.Diff d = (MethodRepr.Diff) mr.snd;\n\n                    if (it.isAnnotation()) {\n                        if (d.defaultRemoved()) {\n                            final List<StringCache.S> l = new LinkedList<StringCache.S>();\n                            l.add(m.name);\n                            annotationQuery.add((UsageRepr.AnnotationUsage) UsageRepr.createAnnotationUsage(TypeRepr.createClassType(it.name), l, null));\n                        }\n                    } else if (d.base() != Difference.NONE) {\n                        // TODO!!\n                        if (d.base() == Difference.ACCESS && d.removedModifiers() == Opcodes.ACC_ABSTRACT) {\n\n                        } else {\n                            affectedUsages.add(mr.fst.createUsage(it.name));\n                        }\n                    }\n                }\n\n                final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n                for (FieldRepr f : diff.fields().removed()) {\n                    if ((f.access & mask) == mask && f.hasValue()) {\n                        return false;\n                    }\n\n                    affectedUsages.add(f.createUsage(it.name));\n                }\n\n                for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n                    final Difference d = f.snd;\n                    final FieldRepr field = f.fst;\n\n                    if ((field.access & mask) == mask) {\n                        if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n                            return false;\n                        }\n                    }\n\n                    if (d.base() != Difference.NONE) {\n                        final Collection<StringCache.S> propagated = propagateFieldAccess(field.name, it.name);\n\n                        if ((d.base() & Difference.TYPE) > 0) {\n                            affectFieldUsages(field, propagated, field.createUsage(it.name), affectedUsages, dependants);\n                        } else if ((d.base() & Difference.ACCESS) > 0) {\n                            if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                                    (d.removedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                                affectFieldUsages(field, propagated, field.createUsage(it.name), affectedUsages, dependants);\n                            } else if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                                affectFieldUsages(field, propagated, field.createAssignUsage(it.name), affectedUsages, dependants);\n                            }\n                        }\n                    }\n                }\n            }\n\n            for (ClassRepr c : classDiff.removed()) {\n                affectedUsages.add(c.createUsage());\n            }\n\n            if (dependants != null) {\n                dependants.removeAll(compiledFiles);\n\n                filewise:\n                for (StringCache.S depFile : dependants) {\n                    if (affectedFiles.contains(depFile)) {\n                        continue filewise;\n                    }\n\n                    final UsageRepr.Cluster depCluster = sourceFileToUsages.get(depFile);\n                    final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n                    if (depUsages != null) {\n                        final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n                        usages.retainAll(affectedUsages);\n\n                        if (!usages.isEmpty()) {\n                            for (UsageRepr.Usage usage : usages) {\n                                final UsageConstraint constraint = usageConstraints.get(usage);\n\n                                if (constraint == null) {\n                                    affectedFiles.add(depFile);\n                                    continue filewise;\n                                } else {\n                                    final Set<StringCache.S> residenceClasses = depCluster.getResidence(usage);\n                                    for (StringCache.S residentName : residenceClasses) {\n                                        if (constraint.checkResidence(residentName)) {\n                                            affectedFiles.add(depFile);\n                                            continue filewise;\n                                        }\n                                    }\n\n                                }\n                            }\n                        }\n\n                        if (annotationQuery.size() > 0) {\n                            final Collection<UsageRepr.Usage> annotationUsages = sourceFileToAnnotationUsages.foxyGet(depFile);\n\n                            for (UsageRepr.Usage usage : annotationUsages) {\n                                for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                                    if (query.satisfies(usage)) {\n                                        affectedFiles.add(depFile);\n                                        continue filewise;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return true;\n    }","commit_id":"c167108e0eb14f788daf43dfb8e999803859b68c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void affectSubclasses(final StringCache.S className, final Set<StringCache.S> affectedFiles) {\n        affectedFiles.add(classToSourceFile.get(className));\n\n        final Collection<StringCache.S> directSubclasses = classToSubclasses.foxyGet(className);\n\n        if (directSubclasses != null) {\n            for (StringCache.S subClass : directSubclasses) {\n                affectSubclasses(subClass, affectedFiles);\n            }\n        }\n    }","id":71910,"modified_method":"private void affectSubclasses(final StringCache.S className, final Set<StringCache.S> affectedFiles, final Set<UsageRepr.Usage> affectedUsages, final Set<StringCache.S> dependants, final boolean usages) {\n        final StringCache.S fileName = classToSourceFile.get(className);\n\n        if (usages) {\n            affectedUsages.add(reprByName(className).createUsage());\n        }\n\n        dependants.addAll(fileToFileDependency.foxyGet(fileName));\n        affectedFiles.add(fileName);\n\n        final Collection<StringCache.S> directSubclasses = classToSubclasses.foxyGet(className);\n\n        if (directSubclasses != null) {\n            for (StringCache.S subClass : directSubclasses) {\n                affectSubclasses(subClass, affectedFiles, affectedUsages, dependants, usages);\n            }\n        }\n    }","commit_id":"c167108e0eb14f788daf43dfb8e999803859b68c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean differentiate(final Mappings delta,\n                               final Collection<String> removed,\n                               final Collection<File> filesToCompile,\n                               final Collection<File> compiledFiles,\n                               final Collection<File> affectedFiles) {\n    delta.compensateRemovedContent(filesToCompile);\n\n    final Util u = new Util(delta);\n    final Util self = new Util(this);\n    final Util o = new Util();\n\n    if (removed != null) {\n      for (String file : removed) {\n        final Collection<ClassRepr> classes = mySourceFileToClasses.get(myContext.get(file));\n\n        if (classes != null) {\n          for (ClassRepr c : classes) {\n            u.affectAll(c.name, affectedFiles);\n          }\n        }\n      }\n    }\n\n    for (DependencyContext.S fileName : delta.mySourceFileToClasses.keyCollection()) {\n      final Set<ClassRepr> classes = (Set<ClassRepr>)delta.mySourceFileToClasses.get(fileName);\n      final Set<ClassRepr> pastClasses = (Set<ClassRepr>)mySourceFileToClasses.get(fileName);\n      final Set<DependencyContext.S> dependants = new HashSet<DependencyContext.S>();\n\n      self.appendDependents(pastClasses, dependants);\n\n      final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n      final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n      final Map<UsageRepr.Usage, Util.UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, Util.UsageConstraint>();\n\n      final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n      for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n        final ClassRepr it = changed.first;\n        final ClassRepr.Diff diff = (ClassRepr.Diff)changed.second;\n\n        final int addedModifiers = diff.addedModifiers();\n        final int removedModifiers = diff.removedModifiers();\n\n        final boolean superClassChanged = (diff.base() & Difference.SUPERCLASS) > 0;\n        final boolean interfacesChanged = !diff.interfaces().unchanged();\n        final boolean signatureChanged = (diff.base() & Difference.SIGNATURE) > 0;\n\n        if (superClassChanged || interfacesChanged || signatureChanged) {\n          final boolean extendsChanged = superClassChanged && !diff.extendsAdded();\n          final boolean interfacesRemoved = interfacesChanged && !diff.interfaces().removed().isEmpty();\n\n          u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, extendsChanged || interfacesRemoved || signatureChanged);\n        }\n\n        if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n          return false;\n        }\n\n        if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n        }\n\n        if (diff.packageLocalOn()) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (removedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if (it.isAnnotation()) {\n          if (diff.retentionChanged()) {\n            affectedUsages.add(it.createUsage());\n          }\n          else {\n            final Collection<ElementType> removedtargets = diff.targets().removed();\n\n            if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n              return false;\n            }\n\n            if (!removedtargets.isEmpty()) {\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), null, removedtargets));\n            }\n\n            for (MethodRepr m : diff.methods().added()) {\n              if (!m.hasValue()) {\n                affectedUsages.add(it.createUsage());\n              }\n            }\n          }\n        }\n\n        for (MethodRepr m : diff.methods().added()) {\n          if ((it.access & Opcodes.ACC_INTERFACE) > 0 || (m.access & Opcodes.ACC_ABSTRACT) > 0) {\n            u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n          }\n        }\n\n        for (MethodRepr m : diff.methods().removed()) {\n          final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = u.findOverridenMethods(m, it);\n          final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n          if (overridenMethods.size() == 0) {\n            u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n          }\n\n          if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {\n            for (DependencyContext.S p : propagated) {\n              final ClassRepr s = u.reprByName(p);\n\n              if (s != null) {\n                final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = u.findOverridenMethods(m, s);\n\n                overridenInS.addAll(overridenMethods);\n\n                boolean allAbstract = true;\n                boolean visited = false;\n\n                for (Pair<MethodRepr, ClassRepr> pp : overridenInS) {\n                  if (pp.second.name.equals(it.name)) {\n                    continue;\n                  }\n\n                  visited = true;\n                  allAbstract = ((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((pp.second.access & Opcodes.ACC_INTERFACE) > 0);\n\n                  if (!allAbstract) {\n                    break;\n                  }\n                }\n\n                if (allAbstract && visited) {\n                  final DependencyContext.S source = myClassToSourceFile.get(p);\n\n                  if (source != null) {\n                    affectedFiles.add(new File(myContext.getValue(source)));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n          final MethodRepr m = mr.first;\n          final MethodRepr.Diff d = (MethodRepr.Diff)mr.second;\n          final boolean throwsChanged = (d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);\n\n          if (it.isAnnotation()) {\n            if (d.defaultRemoved()) {\n              final List<DependencyContext.S> l = new LinkedList<DependencyContext.S>();\n              l.add(m.name);\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null));\n            }\n          }\n          else if (d.base() != Difference.NONE || throwsChanged) {\n            if (d.packageLocalOn()) {\n              final UsageRepr.Usage usage = m.createUsage(myContext, it.name);\n\n              affectedUsages.add(usage);\n              usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n            }\n\n            final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {\n                u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n\n                if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n\n                if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {\n                  final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n                  u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n\n                  for (UsageRepr.Usage usage : usages) {\n                    if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                    else {\n                      usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n                    }\n                  }\n\n                  affectedUsages.addAll(usages);\n                }\n              }\n            }\n          }\n        }\n\n        final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n        for (FieldRepr f : diff.fields().added()) {\n          final boolean fPrivate = (f.access & Opcodes.ACC_PRIVATE) > 0;\n          final boolean fProtected = (f.access & Opcodes.ACC_PROTECTED) > 0;\n          final boolean fPublic = (f.access & Opcodes.ACC_PUBLIC) > 0;\n          final boolean fPLocal = !fPrivate && !fProtected && !fPublic;\n\n          if (!fPrivate) {\n            final Collection<DependencyContext.S> subClasses = myClassToSubclasses.get(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  if (r.isLocal) {\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                  else {\n                    final DependencyContext.S outerClass = r.outerClassName;\n\n                    if (u.fieldVisible(outerClass, f)) {\n                      affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                    }\n                  }\n                }\n\n                final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, subClass);\n                u.affectFieldUsages(f, propagated, f.createUsage(myContext, subClass), affectedUsages, dependants);\n\n                final Collection<DependencyContext.S> deps = myClassToClassDependency.get(subClass);\n\n                if (deps != null) {\n                  dependants.addAll(deps);\n                }\n              }\n            }\n          }\n\n          final Collection<Pair<FieldRepr, ClassRepr>> overriden = u.findOverridenFields(f, it);\n\n          for (Pair<FieldRepr, ClassRepr> p : overriden) {\n            final FieldRepr ff = p.first;\n            final ClassRepr cc = p.second;\n\n            final boolean ffPrivate = (ff.access & Opcodes.ACC_PRIVATE) > 0;\n            final boolean ffProtected = (ff.access & Opcodes.ACC_PROTECTED) > 0;\n            final boolean ffPublic = (ff.access & Opcodes.ACC_PUBLIC) > 0;\n            final boolean ffPLocal = !ffPrivate && !ffProtected && !ffPublic;\n\n            if (!ffPrivate) {\n              final Collection<DependencyContext.S> propagated = o.propagateFieldAccess(ff.name, cc.name);\n              final Set<UsageRepr.Usage> localUsages = new HashSet<UsageRepr.Usage>();\n\n              u.affectFieldUsages(ff, propagated, ff.createUsage(myContext, cc.name), localUsages, dependants);\n\n              if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected) || (fPLocal && ffPLocal)) {\n\n              }\n              else {\n                Util.UsageConstraint constaint;\n\n                if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {\n                  constaint = u.new NegationConstraint(u.new InheritanceConstraint(cc.name));\n                }\n                else if (ffPublic && ffPLocal) {\n                  constaint = u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName()));\n                }\n                else {\n                  constaint = u.new IntersectionConstraint(u.new NegationConstraint(u.new InheritanceConstraint(cc.name)),\n                                                           u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName())));\n                }\n\n                for (UsageRepr.Usage usage : localUsages) {\n                  usageConstraints.put(usage, constaint);\n                }\n              }\n\n              affectedUsages.addAll(localUsages);\n            }\n          }\n        }\n\n        for (FieldRepr f : diff.fields().removed()) {\n          if ((f.access & mask) == mask && f.hasValue()) {\n            return false;\n          }\n\n          final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, it.name);\n          u.affectFieldUsages(f, propagated, f.createUsage(myContext, it.name), affectedUsages, dependants);\n        }\n\n        for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n          final Difference d = f.second;\n          final FieldRepr field = f.first;\n\n          if ((field.access & mask) == mask) {\n            if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n              return false;\n            }\n          }\n\n          if (d.base() != Difference.NONE) {\n            final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(field.name, it.name);\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0) {\n              u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_VOLATILE) > 0) {\n                u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                  u.affectFieldUsages(field, propagated, field.createAssignUsage(myContext, it.name), affectedUsages, dependants);\n                }\n\n                if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {\n                  final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n                  u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), usages, dependants);\n\n                  for (UsageRepr.Usage usage : usages) {\n                    if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                    else {\n                      usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n                    }\n                  }\n\n                  affectedUsages.addAll(usages);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      for (ClassRepr c : classDiff.removed()) {\n        affectedUsages.add(c.createUsage());\n      }\n\n      for (ClassRepr c : classDiff.added()) {\n        final Collection<DependencyContext.S> depClasses = myClassToClassDependency.get(c.name);\n\n        if (depClasses != null) {\n          for (DependencyContext.S depClass : depClasses) {\n            final DependencyContext.S fName = myClassToSourceFile.get(depClass);\n\n            if (fName != null) {\n              affectedFiles.add(new File(myContext.getValue(fName)));\n            }\n          }\n        }\n      }\n\n      if (dependants != null) {\n        final Set<DependencyContext.S> dependentFiles = new HashSet<DependencyContext.S>();\n\n        for (DependencyContext.S depClass : dependants) {\n          final DependencyContext.S file = myClassToSourceFile.get(depClass);\n\n          if (file != null) {\n            dependentFiles.add(file);\n          }\n        }\n\n        filewise:\n        for (DependencyContext.S depFile : dependentFiles) {\n          final File theFile = new File(myContext.getValue(depFile));\n\n          if (affectedFiles.contains(theFile) || compiledFiles.contains(theFile)) {\n            continue filewise;\n          }\n\n          final UsageRepr.Cluster depCluster = mySourceFileToUsages.get(depFile);\n          final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n          if (depUsages != null) {\n            final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n            usages.retainAll(affectedUsages);\n\n            if (!usages.isEmpty()) {\n              for (UsageRepr.Usage usage : usages) {\n                final Util.UsageConstraint constraint = usageConstraints.get(usage);\n\n                if (constraint == null) {\n                  affectedFiles.add(theFile);\n                  continue filewise;\n                }\n                else {\n                  final Set<DependencyContext.S> residenceClasses = depCluster.getResidence(usage);\n                  for (DependencyContext.S residentName : residenceClasses) {\n                    if (constraint.checkResidence(residentName)) {\n                      affectedFiles.add(theFile);\n                      continue filewise;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (annotationQuery.size() > 0) {\n              final Collection<UsageRepr.Usage> annotationUsages = mySourceFileToAnnotationUsages.get(depFile);\n\n              for (UsageRepr.Usage usage : annotationUsages) {\n                for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                  if (query.satisfies(usage)) {\n                    affectedFiles.add(theFile);\n                    continue filewise;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","id":71911,"modified_method":"public boolean differentiate(final Mappings delta,\n                               final Collection<String> removed,\n                               final Collection<File> filesToCompile,\n                               final Collection<File> compiledFiles,\n                               final Collection<File> affectedFiles) {\n    delta.compensateRemovedContent(filesToCompile);\n\n    final Util u = new Util(delta);\n    final Util self = new Util(this);\n    final Util o = new Util();\n\n    if (removed != null) {\n      for (String file : removed) {\n        final Collection<ClassRepr> classes = mySourceFileToClasses.get(myContext.get(file));\n\n        if (classes != null) {\n          for (ClassRepr c : classes) {\n            u.affectAll(c.name, affectedFiles);\n          }\n        }\n      }\n    }\n\n    for (DependencyContext.S fileName : delta.mySourceFileToClasses.keyCollection()) {\n      final Set<ClassRepr> classes = (Set<ClassRepr>)delta.mySourceFileToClasses.get(fileName);\n      final Set<ClassRepr> pastClasses = (Set<ClassRepr>)mySourceFileToClasses.get(fileName);\n      final Set<DependencyContext.S> dependants = new HashSet<DependencyContext.S>();\n\n      self.appendDependents(pastClasses, dependants);\n\n      final Set<UsageRepr.Usage> affectedUsages = new HashSet<UsageRepr.Usage>();\n      final Set<UsageRepr.AnnotationUsage> annotationQuery = new HashSet<UsageRepr.AnnotationUsage>();\n      final Map<UsageRepr.Usage, Util.UsageConstraint> usageConstraints = new HashMap<UsageRepr.Usage, Util.UsageConstraint>();\n\n      final Difference.Specifier<ClassRepr> classDiff = Difference.make(pastClasses, classes);\n\n      for (Pair<ClassRepr, Difference> changed : classDiff.changed()) {\n        final ClassRepr it = changed.first;\n        final ClassRepr.Diff diff = (ClassRepr.Diff)changed.second;\n\n        final int addedModifiers = diff.addedModifiers();\n        final int removedModifiers = diff.removedModifiers();\n\n        final boolean superClassChanged = (diff.base() & Difference.SUPERCLASS) > 0;\n        final boolean interfacesChanged = !diff.interfaces().unchanged();\n        final boolean signatureChanged = (diff.base() & Difference.SIGNATURE) > 0;\n\n        if (superClassChanged || interfacesChanged || signatureChanged) {\n          final boolean extendsChanged = superClassChanged && !diff.extendsAdded();\n          final boolean interfacesRemoved = interfacesChanged && !diff.interfaces().removed().isEmpty();\n\n          u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, extendsChanged || interfacesRemoved || signatureChanged);\n        }\n\n        if ((diff.addedModifiers() & Opcodes.ACC_INTERFACE) > 0 || (diff.removedModifiers() & Opcodes.ACC_INTERFACE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if (it.isAnnotation() && it.policy == RetentionPolicy.SOURCE) {\n          return false;\n        }\n\n        if ((addedModifiers & Opcodes.ACC_PROTECTED) > 0) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n        }\n\n        if (diff.packageLocalOn()) {\n          final UsageRepr.Usage usage = it.createUsage();\n\n          affectedUsages.add(usage);\n          usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_FINAL) > 0 || (addedModifiers & Opcodes.ACC_PRIVATE) > 0) {\n          affectedUsages.add(it.createUsage());\n        }\n\n        if ((addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if ((addedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (removedModifiers & Opcodes.ACC_STATIC) > 0 ||\n            (addedModifiers & Opcodes.ACC_ABSTRACT) > 0) {\n          affectedUsages.add(UsageRepr.createClassNewUsage(myContext, it.name));\n        }\n\n        if (it.isAnnotation()) {\n          if (diff.retentionChanged()) {\n            affectedUsages.add(it.createUsage());\n          }\n          else {\n            final Collection<ElementType> removedtargets = diff.targets().removed();\n\n            if (removedtargets.contains(ElementType.LOCAL_VARIABLE)) {\n              return false;\n            }\n\n            if (!removedtargets.isEmpty()) {\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), null, removedtargets));\n            }\n\n            for (MethodRepr m : diff.methods().added()) {\n              if (!m.hasValue()) {\n                affectedUsages.add(it.createUsage());\n              }\n            }\n          }\n        }\n\n        for (MethodRepr m : diff.methods().added()) {\n          if ((it.access & Opcodes.ACC_INTERFACE) > 0 || (m.access & Opcodes.ACC_ABSTRACT) > 0) {\n            u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n          }\n        }\n\n        for (MethodRepr m : diff.methods().removed()) {\n          final Collection<Pair<MethodRepr, ClassRepr>> overridenMethods = u.findOverridenMethods(m, it);\n          final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n          if (overridenMethods.size() == 0) {\n            u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n          }\n\n          if ((m.access & Opcodes.ACC_ABSTRACT) == 0) {\n            for (DependencyContext.S p : propagated) {\n              final ClassRepr s = u.reprByName(p);\n\n              if (s != null) {\n                final Collection<Pair<MethodRepr, ClassRepr>> overridenInS = u.findOverridenMethods(m, s);\n\n                overridenInS.addAll(overridenMethods);\n\n                boolean allAbstract = true;\n                boolean visited = false;\n\n                for (Pair<MethodRepr, ClassRepr> pp : overridenInS) {\n                  if (pp.second.name.equals(it.name)) {\n                    continue;\n                  }\n\n                  visited = true;\n                  allAbstract = ((pp.first.access & Opcodes.ACC_ABSTRACT) > 0) || ((pp.second.access & Opcodes.ACC_INTERFACE) > 0);\n\n                  if (!allAbstract) {\n                    break;\n                  }\n                }\n\n                if (allAbstract && visited) {\n                  final DependencyContext.S source = myClassToSourceFile.get(p);\n\n                  if (source != null) {\n                    affectedFiles.add(new File(myContext.getValue(source)));\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        for (Pair<MethodRepr, Difference> mr : diff.methods().changed()) {\n          final MethodRepr m = mr.first;\n          final MethodRepr.Diff d = (MethodRepr.Diff)mr.second;\n          final boolean throwsChanged = (d.exceptions().added().size() > 0) || (d.exceptions().changed().size() > 0);\n\n          if (it.isAnnotation()) {\n            if (d.defaultRemoved()) {\n              final List<DependencyContext.S> l = new LinkedList<DependencyContext.S>();\n              l.add(m.name);\n              annotationQuery.add((UsageRepr.AnnotationUsage)UsageRepr\n                .createAnnotationUsage(myContext, TypeRepr.createClassType(myContext, it.name), l, null));\n            }\n          }\n          else if (d.base() != Difference.NONE || throwsChanged) {\n            final Collection<DependencyContext.S> propagated = u.propagateMethodAccess(m.name, it.name);\n\n            if (d.packageLocalOn()) {\n              final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n\n              for (UsageRepr.Usage usage : usages) {\n                usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n              }\n\n              affectedUsages.addAll(usages);\n            }\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0 || throwsChanged) {\n              u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0) {\n                u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), affectedUsages, dependants);\n\n                if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_PUBLIC) > 0 ||\n                    (d.addedModifiers() & Opcodes.ACC_ABSTRACT) > 0) {\n                  u.affectSubclasses(it.name, affectedFiles, affectedUsages, dependants, false);\n                }\n\n                if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0 && !((d.removedModifiers() & Opcodes.ACC_PRIVATE) > 0)) {\n                  final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n                  u.affectMethodUsages(m, propagated, m.createUsage(myContext, it.name), usages, dependants);\n\n                  for (UsageRepr.Usage usage : usages) {\n                    usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                  }\n\n                  affectedUsages.addAll(usages);\n                }\n              }\n            }\n          }\n        }\n\n        final int mask = Opcodes.ACC_STATIC | Opcodes.ACC_FINAL;\n\n        for (FieldRepr f : diff.fields().added()) {\n          final boolean fPrivate = (f.access & Opcodes.ACC_PRIVATE) > 0;\n          final boolean fProtected = (f.access & Opcodes.ACC_PROTECTED) > 0;\n          final boolean fPublic = (f.access & Opcodes.ACC_PUBLIC) > 0;\n          final boolean fPLocal = !fPrivate && !fProtected && !fPublic;\n\n          if (!fPrivate) {\n            final Collection<DependencyContext.S> subClasses = myClassToSubclasses.get(it.name);\n\n            if (subClasses != null) {\n              for (final DependencyContext.S subClass : subClasses) {\n                final ClassRepr r = u.reprByName(subClass);\n                final DependencyContext.S sourceFileName = myClassToSourceFile.get(subClass);\n\n                if (r != null && sourceFileName != null) {\n                  if (r.isLocal) {\n                    affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                  }\n                  else {\n                    final DependencyContext.S outerClass = r.outerClassName;\n\n                    if (u.fieldVisible(outerClass, f)) {\n                      affectedFiles.add(new File(myContext.getValue(sourceFileName)));\n                    }\n                  }\n                }\n\n                final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, subClass);\n                u.affectFieldUsages(f, propagated, f.createUsage(myContext, subClass), affectedUsages, dependants);\n\n                final Collection<DependencyContext.S> deps = myClassToClassDependency.get(subClass);\n\n                if (deps != null) {\n                  dependants.addAll(deps);\n                }\n              }\n            }\n          }\n\n          final Collection<Pair<FieldRepr, ClassRepr>> overriden = u.findOverridenFields(f, it);\n\n          for (Pair<FieldRepr, ClassRepr> p : overriden) {\n            final FieldRepr ff = p.first;\n            final ClassRepr cc = p.second;\n\n            final boolean ffPrivate = (ff.access & Opcodes.ACC_PRIVATE) > 0;\n            final boolean ffProtected = (ff.access & Opcodes.ACC_PROTECTED) > 0;\n            final boolean ffPublic = (ff.access & Opcodes.ACC_PUBLIC) > 0;\n            final boolean ffPLocal = !ffPrivate && !ffProtected && !ffPublic;\n\n            if (!ffPrivate) {\n              final Collection<DependencyContext.S> propagated = o.propagateFieldAccess(ff.name, cc.name);\n              final Set<UsageRepr.Usage> localUsages = new HashSet<UsageRepr.Usage>();\n\n              u.affectFieldUsages(ff, propagated, ff.createUsage(myContext, cc.name), localUsages, dependants);\n\n              if (fPrivate || (fPublic && (ffPublic || ffPLocal)) || (fProtected && ffProtected) || (fPLocal && ffPLocal)) {\n\n              }\n              else {\n                Util.UsageConstraint constaint;\n\n                if ((ffProtected && fPublic) || (fProtected && ffPublic) || (ffPLocal && fProtected)) {\n                  constaint = u.new NegationConstraint(u.new InheritanceConstraint(cc.name));\n                }\n                else if (ffPublic && ffPLocal) {\n                  constaint = u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName()));\n                }\n                else {\n                  constaint = u.new IntersectionConstraint(u.new NegationConstraint(u.new InheritanceConstraint(cc.name)),\n                                                           u.new NegationConstraint(u.new PackageConstraint(cc.getPackageName())));\n                }\n\n                for (UsageRepr.Usage usage : localUsages) {\n                  usageConstraints.put(usage, constaint);\n                }\n              }\n\n              affectedUsages.addAll(localUsages);\n            }\n          }\n        }\n\n        for (FieldRepr f : diff.fields().removed()) {\n          if ((f.access & mask) == mask && f.hasValue()) {\n            return false;\n          }\n\n          final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(f.name, it.name);\n          u.affectFieldUsages(f, propagated, f.createUsage(myContext, it.name), affectedUsages, dependants);\n        }\n\n        for (Pair<FieldRepr, Difference> f : diff.fields().changed()) {\n          final Difference d = f.second;\n          final FieldRepr field = f.first;\n\n          if ((field.access & mask) == mask) {\n            if ((d.base() & Difference.ACCESS) > 0 || (d.base() & Difference.VALUE) > 0) {\n              return false;\n            }\n          }\n\n          if (d.base() != Difference.NONE) {\n            final Collection<DependencyContext.S> propagated = u.propagateFieldAccess(field.name, it.name);\n\n            if ((d.base() & Difference.TYPE) > 0 || (d.base() & Difference.SIGNATURE) > 0) {\n              u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n            }\n            else if ((d.base() & Difference.ACCESS) > 0) {\n              if ((d.addedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.removedModifiers() & Opcodes.ACC_STATIC) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_PRIVATE) > 0 ||\n                  (d.addedModifiers() & Opcodes.ACC_VOLATILE) > 0) {\n                u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), affectedUsages, dependants);\n              }\n              else {\n                if ((d.addedModifiers() & Opcodes.ACC_FINAL) > 0) {\n                  u.affectFieldUsages(field, propagated, field.createAssignUsage(myContext, it.name), affectedUsages, dependants);\n                }\n\n                if ((d.removedModifiers() & Opcodes.ACC_PUBLIC) > 0) {\n                  final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>();\n                  u.affectFieldUsages(field, propagated, field.createUsage(myContext, it.name), usages, dependants);\n\n                  for (UsageRepr.Usage usage : usages) {\n                    if ((d.addedModifiers() & Opcodes.ACC_PROTECTED) > 0) {\n                      usageConstraints.put(usage, u.new InheritanceConstraint(it.name));\n                    }\n                    else {\n                      usageConstraints.put(usage, u.new PackageConstraint(it.getPackageName()));\n                    }\n                  }\n\n                  affectedUsages.addAll(usages);\n                }\n              }\n            }\n          }\n        }\n      }\n\n      for (ClassRepr c : classDiff.removed()) {\n        affectedUsages.add(c.createUsage());\n      }\n\n      for (ClassRepr c : classDiff.added()) {\n        final Collection<DependencyContext.S> depClasses = myClassToClassDependency.get(c.name);\n\n        if (depClasses != null) {\n          for (DependencyContext.S depClass : depClasses) {\n            final DependencyContext.S fName = myClassToSourceFile.get(depClass);\n\n            if (fName != null) {\n              affectedFiles.add(new File(myContext.getValue(fName)));\n            }\n          }\n        }\n      }\n\n      if (dependants != null) {\n        final Set<DependencyContext.S> dependentFiles = new HashSet<DependencyContext.S>();\n\n        for (DependencyContext.S depClass : dependants) {\n          final DependencyContext.S file = myClassToSourceFile.get(depClass);\n\n          if (file != null) {\n            dependentFiles.add(file);\n          }\n        }\n\n        dependentFiles.removeAll(compiledFiles);\n\n        filewise:\n        for (DependencyContext.S depFile : dependentFiles) {\n          if (affectedFiles.contains(new File(myContext.getValue(depFile)))) {\n            continue filewise;\n          }\n\n          final UsageRepr.Cluster depCluster = mySourceFileToUsages.get(depFile);\n          final Set<UsageRepr.Usage> depUsages = depCluster.getUsages();\n\n          if (depUsages != null) {\n            final Set<UsageRepr.Usage> usages = new HashSet<UsageRepr.Usage>(depUsages);\n\n            usages.retainAll(affectedUsages);\n\n            if (!usages.isEmpty()) {\n              for (UsageRepr.Usage usage : usages) {\n                final Util.UsageConstraint constraint = usageConstraints.get(usage);\n\n                if (constraint == null) {\n                  affectedFiles.add(new File(myContext.getValue(depFile)));\n                  continue filewise;\n                }\n                else {\n                  final Set<DependencyContext.S> residenceClasses = depCluster.getResidence(usage);\n                  for (DependencyContext.S residentName : residenceClasses) {\n                    if (constraint.checkResidence(residentName)) {\n                      affectedFiles.add(new File(myContext.getValue(depFile)));\n                      continue filewise;\n                    }\n                  }\n\n                }\n              }\n            }\n\n            if (annotationQuery.size() > 0) {\n              final Collection<UsageRepr.Usage> annotationUsages = mySourceFileToAnnotationUsages.get(depFile);\n\n              for (UsageRepr.Usage usage : annotationUsages) {\n                for (UsageRepr.AnnotationUsage query : annotationQuery) {\n                  if (query.satisfies(usage)) {\n                    affectedFiles.add(new File(myContext.getValue(depFile)));\n                    continue filewise;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"d3c583fffabd37f382d695d4d7be0c7921469c35","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private static VirtualFile getVcsRootForLibraryFile(@NotNull Project project, @NotNull VirtualFile file) {\n    ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(project);\n    // for a file inside .jar/.zip consider the .jar/.zip file itself\n    VirtualFile root = vcsManager.getVcsRootFor(VfsUtilCore.getVirtualFileForJar(file));\n    if (root != null) {\n      return root;\n    }\n    \n    // for other libs which don't have jars inside the project dir (such as JDK) take the owner module of the lib\n    List<OrderEntry> entries = ProjectRootManager.getInstance(project).getFileIndex().getOrderEntriesForFile(file);\n    Set<VirtualFile> libraryRoots = new HashSet<VirtualFile>();\n    for (OrderEntry entry : entries) {\n      if (entry instanceof LibraryOrderEntry || entry instanceof JdkOrderEntry) {\n        libraryRoots.add(vcsManager.getVcsRootFor(entry.getOwnerModule().getModuleFile()));\n      }\n    }\n\n    if (libraryRoots.size() == 0) {\n      return null;\n    }\n\n    // if the lib is used in several modules, take the top module\n    // (for modules of the same level we can't guess anything => take the first one)\n    Iterator<VirtualFile> libIterator = libraryRoots.iterator();\n    VirtualFile topLibraryRoot = libIterator.next();\n    while (libIterator.hasNext()) {\n      VirtualFile libRoot = libIterator.next();\n      if (VfsUtilCore.isAncestor(libRoot, topLibraryRoot, true)) {\n        topLibraryRoot = libRoot;\n      }\n    }\n    return topLibraryRoot;\n  }","id":71912,"modified_method":"@Nullable\n  private static VirtualFile getVcsRootForLibraryFile(@NotNull Project project, @NotNull VirtualFile file) {\n    ProjectLevelVcsManager vcsManager = ProjectLevelVcsManager.getInstance(project);\n    // for a file inside .jar/.zip consider the .jar/.zip file itself\n    VirtualFile root = vcsManager.getVcsRootFor(VfsUtilCore.getVirtualFileForJar(file));\n    if (root != null) {\n      return root;\n    }\n    \n    // for other libs which don't have jars inside the project dir (such as JDK) take the owner module of the lib\n    List<OrderEntry> entries = ProjectRootManager.getInstance(project).getFileIndex().getOrderEntriesForFile(file);\n    Set<VirtualFile> libraryRoots = new HashSet<VirtualFile>();\n    for (OrderEntry entry : entries) {\n      if (entry instanceof LibraryOrderEntry || entry instanceof JdkOrderEntry) {\n        VirtualFile moduleRoot = vcsManager.getVcsRootFor(entry.getOwnerModule().getModuleFile());\n        if (moduleRoot != null) {\n          libraryRoots.add(moduleRoot);\n        }\n      }\n    }\n\n    if (libraryRoots.size() == 0) {\n      return null;\n    }\n\n    // if the lib is used in several modules, take the top module\n    // (for modules of the same level we can't guess anything => take the first one)\n    Iterator<VirtualFile> libIterator = libraryRoots.iterator();\n    VirtualFile topLibraryRoot = libIterator.next();\n    while (libIterator.hasNext()) {\n      VirtualFile libRoot = libIterator.next();\n      if (VfsUtilCore.isAncestor(libRoot, topLibraryRoot, true)) {\n        topLibraryRoot = libRoot;\n      }\n    }\n    return topLibraryRoot;\n  }","commit_id":"27777b76b889270f4842a7388dc24af575767399","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void performDeletion( final List<FilePath> filesToDelete) {\n    final ArrayList<HgFile> deletes = new ArrayList<HgFile>();\n    for (FilePath file : filesToDelete) {\n      if (file.isDirectory()) {\n        continue;\n      }\n\n      deletes.add(new HgFile(VcsUtil.getVcsRootFor(myProject, file), file));\n    }\n\n    if (!deletes.isEmpty()) {\n      new HgRemoveCommand(myProject).execute(deletes);\n    }\n\n    for (HgFile file : deletes) {\n      dirtyScopeManager.fileDirty(file.toFilePath());\n    }\n  }","id":71913,"modified_method":"@Override\n  protected void performDeletion( final List<FilePath> filesToDelete) {\n    final ArrayList<HgFile> deletes = new ArrayList<HgFile>();\n    for (FilePath file : filesToDelete) {\n      if (file.isDirectory()) {\n        continue;\n      }\n\n      VirtualFile root = VcsUtil.getVcsRootFor(myProject, file);\n      if (root != null) {\n        deletes.add(new HgFile(root, file));\n      }\n    }\n\n    if (!deletes.isEmpty()) {\n      new HgRemoveCommand(myProject).execute(deletes);\n    }\n\n    for (HgFile file : deletes) {\n      dirtyScopeManager.fileDirty(file.toFilePath());\n    }\n  }","commit_id":"6760118a46f0897d06c0c8b153d3b9d9da386bab","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Dependency createMavenDependency(ModuleDependency dependency, String name, String type, String scope, String classifier,\n            Set<Configuration> configurations) {\n        Dependency mavenDependency =  new Dependency();\n        mavenDependency.setGroupId(dependency.getGroup());\n        if (dependency instanceof ProjectDependency) {\n            mavenDependency.setArtifactId(determineProjectDependencyArtifactId((ProjectDependency) dependency));\n        } else {\n            mavenDependency.setArtifactId(name);\n        }\n        mavenDependency.setVersion(mapToMavenSyntax(dependency.getVersion()));\n        mavenDependency.setType(type);\n        mavenDependency.setScope(scope);\n        mavenDependency.setClassifier(classifier);\n        mavenDependency.setExclusions(getExclusions(dependency, configurations));\n        return mavenDependency;\n    }","id":71914,"modified_method":"private Dependency createMavenDependency(ModuleDependency dependency, String name, String type, String scope, String classifier,\n            Set<Configuration> configurations) {\n        Dependency mavenDependency =  new Dependency();\n        mavenDependency.setGroupId(dependency.getGroup());\n        if (dependency instanceof ProjectDependency) {\n            ProjectDependency projectDependency = (ProjectDependency) dependency;\n            mavenDependency.setArtifactId(determineProjectDependencyArtifactId(projectDependency));\n            final String artifactId = determineProjectDependencyArtifactId((ProjectDependency) dependency);\n            PublishArtifactSet configurationArtifacts = projectDependency.getProjectConfiguration().getArtifacts();\n            if (configurationArtifacts.size() > 0) {\n                Object[] matchingArtifacts = configurationArtifacts.matching(new Spec<PublishArtifact>() {\n                    public boolean isSatisfiedBy(PublishArtifact element) {\n                        return element.getName().equals(artifactId);\n                    }\n                }).toArray();\n\n                PublishArtifact artifactToPublish;\n                if (matchingArtifacts.length > 0) {\n                    artifactToPublish = (PublishArtifact) matchingArtifacts[0];\n                    if (artifactToPublish.getClassifier() != null) {\n                        classifier = artifactToPublish.getClassifier();\n                    }\n                }\n            }\n        } else {\n            mavenDependency.setArtifactId(name);\n        }\n        mavenDependency.setVersion(mapToMavenSyntax(dependency.getVersion()));\n        mavenDependency.setType(type);\n        mavenDependency.setScope(scope);\n        mavenDependency.setClassifier(classifier);\n        mavenDependency.setExclusions(getExclusions(dependency, configurations));\n        return mavenDependency;\n    }","commit_id":"6edc5100bc8312fba289a30dfeca3f948ef14762","url":"https://github.com/gradle/gradle"},{"original_method":"public Exchange createExchange(Message message, Destination replyDestination) {\n        Exchange exchange = new DefaultExchange(endpoint, endpoint.getExchangePattern());\n        exchange.setProperty(Exchange.BINDING, getBinding());\n        exchange.setIn(new JmsMessage(message));\n\n        // lets set to an InOut if we have some kind of reply-to destination\n        if (replyDestination != null && !disableReplyTo) {\n            exchange.setProperty(JmsConstants.JMS_REPLY_DESTINATION, replyDestination);\n            // only change pattern if not already out capable\n            if (!exchange.getPattern().isOutCapable()) {\n                exchange.setPattern(ExchangePattern.InOut);\n            }\n        }\n        return exchange;\n    }","id":71915,"modified_method":"public Exchange createExchange(Message message, Destination replyDestination) {\n        Exchange exchange = new DefaultExchange(endpoint, endpoint.getExchangePattern());\n        exchange.setProperty(Exchange.BINDING, getBinding());\n        exchange.setIn(new JmsMessage(message));\n\n        // lets set to an InOut if we have some kind of reply-to destination\n        if (replyDestination != null && !disableReplyTo) {\n            // only change pattern if not already out capable\n            if (!exchange.getPattern().isOutCapable()) {\n                exchange.setPattern(ExchangePattern.InOut);\n            }\n        }\n        return exchange;\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"direct:start\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\"Hello World\");\n                        // use our custom JMSReplyTo to decide where the reply should be sent\n                        exchange.getOut().setHeader(JmsConstants.JMS_REPLY_DESTINATION, \"myReplyQueue\");\n                    }\n                // must preserve QoS so Camel will send JMSReplyTo even if message is inOnly\n                }).to(\"activemq:queue:in?preserveMessageQos=true\");\n\n                from(\"activemq:queue:myReplyQueue\").to(\"mock:result\");\n            }\n        };\n    }","id":71916,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"direct:start\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setBody(\"Hello World\");\n                        // set the JMSReplyTo to force sending the reply here\n                        exchange.getOut().setHeader(\"JMSReplyTo\", \"myReplyQueue\");\n                    }\n                // must preserve QoS so Camel will send JMSReplyTo even if message is inOnly\n                }).to(\"activemq:queue:in?preserveMessageQos=true\");\n\n                from(\"activemq:queue:myReplyQueue\").to(\"mock:result\");\n            }\n        };\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"protected void processInOnly(final Exchange exchange) {\n        final org.apache.camel.Message in = exchange.getIn();\n\n        String destinationName = endpoint.getDestinationName();\n        Destination destination = exchange.getProperty(JmsConstants.JMS_DESTINATION, Destination.class);\n        if (destination == null) {\n            destination = endpoint.getDestination();\n        }\n        if (destination != null) {\n            // prefer to use destination over destination name\n            destinationName = null;\n        }\n\n        // we must honor these special flags to preverse QoS\n        if (!endpoint.isPreserveMessageQos() && !endpoint.isExplicitQosEnabled()) {\n            Object replyTo = exchange.getIn().getHeader(\"JMSReplyTo\");\n            if (replyTo != null) {\n                // we are routing an existing JmsMessage, origin from another JMS endpoint\n                // then we need to remove the existing JMSReplyTo\n                // as we are not out capable and thus do not expect a reply, and therefore\n                // the consumer of this message we send should not return a reply\n                String to = destinationName != null ? destinationName : \"\" + destination;\n                LOG.warn(\"Disabling JMSReplyTo as this Exchange is not OUT capable with JMSReplyTo: \" + replyTo\n                        + \" for destination: \" + to + \". Use preserveMessageQos=true to force Camel to keep the JMSReplyTo.\"\n                        + \" Exchange: \" + exchange);\n                exchange.getIn().setHeader(\"JMSReplyTo\", null);\n            }\n        }\n\n        MessageCreator messageCreator = new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                return endpoint.getBinding().makeJmsMessage(exchange, in, session, null);\n            }\n        };\n\n        doSend(false, destinationName, destination, messageCreator, null);\n\n        // after sending then set the OUT message id to the JMSMessageID so its identical\n        setMessageId(exchange);\n    }","id":71917,"modified_method":"protected void processInOnly(final Exchange exchange) {\n        final org.apache.camel.Message in = exchange.getIn();\n\n        String destinationName = in.getHeader(JmsConstants.JMS_DESTINATION_NAME, String.class);\n        // remove the header so it wont be propagated\n        in.removeHeader(JmsConstants.JMS_DESTINATION_NAME);\n        if (destinationName == null) {\n            destinationName = endpoint.getDestinationName();\n        }\n\n        Destination destination = in.getHeader(JmsConstants.JMS_DESTINATION, Destination.class);\n        // remove the header so it wont be propagated\n        in.removeHeader(JmsConstants.JMS_DESTINATION);\n        if (destination == null) {\n            destination = endpoint.getDestination();\n        }\n        if (destination != null) {\n            // prefer to use destination over destination name\n            destinationName = null;\n        }\n\n        // we must honor these special flags to preverse QoS\n        if (!endpoint.isPreserveMessageQos() && !endpoint.isExplicitQosEnabled()) {\n            Object replyTo = exchange.getIn().getHeader(\"JMSReplyTo\");\n            if (replyTo != null) {\n                // we are routing an existing JmsMessage, origin from another JMS endpoint\n                // then we need to remove the existing JMSReplyTo\n                // as we are not out capable and thus do not expect a reply, and therefore\n                // the consumer of this message we send should not return a reply\n                String to = destinationName != null ? destinationName : \"\" + destination;\n                LOG.warn(\"Disabling JMSReplyTo as this Exchange is not OUT capable with JMSReplyTo: \" + replyTo\n                        + \" for destination: \" + to + \". Use preserveMessageQos=true to force Camel to keep the JMSReplyTo.\"\n                        + \" Exchange: \" + exchange);\n                exchange.getIn().setHeader(\"JMSReplyTo\", null);\n            }\n        }\n\n        MessageCreator messageCreator = new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                return endpoint.getBinding().makeJmsMessage(exchange, in, session, null);\n            }\n        };\n\n        doSend(false, destinationName, destination, messageCreator, null);\n\n        // after sending then set the OUT message id to the JMSMessageID so its identical\n        setMessageId(exchange);\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"protected void processInOut(final Exchange exchange) {\n        final org.apache.camel.Message in = exchange.getIn();\n\n        String destinationName = endpoint.getDestinationName();\n        Destination destination = exchange.getProperty(JmsConstants.JMS_DESTINATION, Destination.class);\n        if (destination == null) {\n            destination = endpoint.getDestination();\n        }\n        if (destination != null) {\n            // prefer to use destination over destination name\n            destinationName = null;\n        }\n\n        testAndSetRequestor();\n\n        // note due to JMS transaction semantics we cannot use a single transaction\n        // for sending the request and receiving the response\n        final Destination replyTo = requestor.getReplyTo();\n\n        if (replyTo == null) {\n            throw new RuntimeExchangeException(\"Failed to resolve replyTo destination\", exchange);\n        }\n\n        final boolean msgIdAsCorrId = endpoint.getConfiguration().isUseMessageIDAsCorrelationID();\n        String correlationId = in.getHeader(\"JMSCorrelationID\", String.class);\n\n        if (correlationId == null && !msgIdAsCorrId) {\n            in.setHeader(\"JMSCorrelationID\", getUuidGenerator().generateId());\n        }\n\n        final ValueHolder<FutureTask> futureHolder = new ValueHolder<FutureTask>();\n        final DeferredMessageSentCallback callback = msgIdAsCorrId ? deferredRequestReplyMap.createDeferredMessageSentCallback() : null;\n\n        MessageCreator messageCreator = new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);\n                message.setJMSReplyTo(replyTo);\n                requestor.setReplyToSelectorHeader(in, message);\n\n                FutureTask future;\n                future = (!msgIdAsCorrId)\n                        ? requestor.getReceiveFuture(message.getJMSCorrelationID(), endpoint.getConfiguration().getRequestTimeout())\n                        : requestor.getReceiveFuture(callback);\n\n                futureHolder.set(future);\n                return message;\n            }\n        };\n\n        doSend(true, destinationName, destination, messageCreator, callback);\n\n        // after sending then set the OUT message id to the JMSMessageID so its identical\n        setMessageId(exchange);\n\n        // lets wait and return the response\n        long requestTimeout = endpoint.getConfiguration().getRequestTimeout();\n        try {\n            Message message = null;\n            try {\n                if (requestTimeout < 0) {\n                    message = (Message)futureHolder.get().get();\n                } else {\n                    message = (Message)futureHolder.get().get(requestTimeout, TimeUnit.MILLISECONDS);\n                }\n            } catch (InterruptedException e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Future interrupted: \" + e, e);\n                }\n            } catch (TimeoutException e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Future timed out: \" + e, e);\n                }\n            }\n            if (message != null) {\n                // the response can be an exception\n                JmsMessage response = new JmsMessage(message, endpoint.getBinding());\n                Object body = response.getBody();\n\n                if (endpoint.isTransferException() && body instanceof Exception) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Reply recieved. Setting reply as Exception: \" + body);\n                    }\n                    // we got an exception back and endpoint was configued to transfer exception\n                    // therefore set response as exception\n                    exchange.setException((Exception) body);\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Reply recieved. Setting reply as OUT message: \" + body);\n                    }\n                    // regular response\n                    exchange.setOut(response);\n                }\n\n                // correlation\n                if (correlationId != null) {\n                    message.setJMSCorrelationID(correlationId);\n                    exchange.getOut().setHeader(\"JMSCorrelationID\", correlationId);\n                }\n            } else {\n                // no response, so lets set a timed out exception\n                exchange.setException(new ExchangeTimedOutException(exchange, requestTimeout));\n            }\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n    }","id":71918,"modified_method":"protected void processInOut(final Exchange exchange) {\n        final org.apache.camel.Message in = exchange.getIn();\n\n        String destinationName = in.getHeader(JmsConstants.JMS_DESTINATION_NAME, String.class);\n        // remove the header so it wont be propagated\n        in.removeHeader(JmsConstants.JMS_DESTINATION_NAME);\n        if (destinationName == null) {\n            destinationName = endpoint.getDestinationName();\n        }\n\n        Destination destination = in.getHeader(JmsConstants.JMS_DESTINATION, Destination.class);\n        // remove the header so it wont be propagated\n        in.removeHeader(JmsConstants.JMS_DESTINATION);\n        if (destination == null) {\n            destination = endpoint.getDestination();\n        }\n        if (destination != null) {\n            // prefer to use destination over destination name\n            destinationName = null;\n        }\n\n        testAndSetRequestor();\n\n        // note due to JMS transaction semantics we cannot use a single transaction\n        // for sending the request and receiving the response\n        final Destination replyTo = requestor.getReplyTo();\n\n        if (replyTo == null) {\n            throw new RuntimeExchangeException(\"Failed to resolve replyTo destination\", exchange);\n        }\n\n        final boolean msgIdAsCorrId = endpoint.getConfiguration().isUseMessageIDAsCorrelationID();\n        String correlationId = in.getHeader(\"JMSCorrelationID\", String.class);\n\n        if (correlationId == null && !msgIdAsCorrId) {\n            in.setHeader(\"JMSCorrelationID\", getUuidGenerator().generateId());\n        }\n\n        final ValueHolder<FutureTask> futureHolder = new ValueHolder<FutureTask>();\n        final DeferredMessageSentCallback callback = msgIdAsCorrId ? deferredRequestReplyMap.createDeferredMessageSentCallback() : null;\n\n        MessageCreator messageCreator = new MessageCreator() {\n            public Message createMessage(Session session) throws JMSException {\n                Message message = endpoint.getBinding().makeJmsMessage(exchange, in, session, null);\n                message.setJMSReplyTo(replyTo);\n                requestor.setReplyToSelectorHeader(in, message);\n\n                FutureTask future;\n                future = (!msgIdAsCorrId)\n                        ? requestor.getReceiveFuture(message.getJMSCorrelationID(), endpoint.getConfiguration().getRequestTimeout())\n                        : requestor.getReceiveFuture(callback);\n\n                futureHolder.set(future);\n                return message;\n            }\n        };\n\n        doSend(true, destinationName, destination, messageCreator, callback);\n\n        // after sending then set the OUT message id to the JMSMessageID so its identical\n        setMessageId(exchange);\n\n        // lets wait and return the response\n        long requestTimeout = endpoint.getConfiguration().getRequestTimeout();\n        try {\n            Message message = null;\n            try {\n                if (requestTimeout < 0) {\n                    message = (Message)futureHolder.get().get();\n                } else {\n                    message = (Message)futureHolder.get().get(requestTimeout, TimeUnit.MILLISECONDS);\n                }\n            } catch (InterruptedException e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Future interrupted: \" + e, e);\n                }\n            } catch (TimeoutException e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Future timed out: \" + e, e);\n                }\n            }\n            if (message != null) {\n                // the response can be an exception\n                JmsMessage response = new JmsMessage(message, endpoint.getBinding());\n                Object body = response.getBody();\n\n                if (endpoint.isTransferException() && body instanceof Exception) {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Reply recieved. Setting reply as Exception: \" + body);\n                    }\n                    // we got an exception back and endpoint was configued to transfer exception\n                    // therefore set response as exception\n                    exchange.setException((Exception) body);\n                } else {\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Reply recieved. Setting reply as OUT message: \" + body);\n                    }\n                    // regular response\n                    exchange.setOut(response);\n                }\n\n                // correlation\n                if (correlationId != null) {\n                    message.setJMSCorrelationID(correlationId);\n                    exchange.getOut().setHeader(\"JMSCorrelationID\", correlationId);\n                }\n            } else {\n                // no response, so lets set a timed out exception\n                exchange.setException(new ExchangeTimedOutException(exchange, requestTimeout));\n            }\n        } catch (Exception e) {\n            exchange.setException(e);\n        }\n\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testInOnlyJMSDestination() throws Exception {\n        Destination queue = new ActiveMQQueue(\"foo\");\n        \n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(\"JMSDestination\").isNotNull();\n\n        // must use a property for JMSDestination to send it somewhere else\n        template.sendBodyAndProperty(\"activemq:queue:bar\", \"Hello World\", \"JMSDestination\", queue);\n\n        assertMockEndpointsSatisfied();\n\n        assertEquals(\"queue://foo\", mock.getReceivedExchanges().get(0).getIn().getHeader(\"JMSDestination\", Destination.class).toString());\n    }","id":71919,"modified_method":"@Test\n    public void testInOnlyJMSDestination() throws Exception {\n        Destination queue = new ActiveMQQueue(\"foo\");\n\n        MockEndpoint mock = getMockEndpoint(\"mock:result\");\n        mock.expectedMessageCount(1);\n        mock.message(0).header(\"JMSDestination\").isNotNull();\n\n        template.sendBodyAndHeader(\"activemq:queue:bar\", \"Hello World\", JmsConstants.JMS_DESTINATION, queue);\n\n        assertMockEndpointsSatisfied();\n\n        assertEquals(\"queue://foo\", mock.getReceivedExchanges().get(0).getIn().getHeader(\"JMSDestination\", Destination.class).toString());\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                // set the MEP to InOptionalOut as we might not be able to send a reply\n                from(getQueueEndpointName()).setExchangePattern(ExchangePattern.InOptionalOut).process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        Message in = exchange.getIn();\n                        assertEquals(\"Hello World\", in.getBody());\n\n                        replyDestination = in.getHeader(JmsConstants.JMS_REPLY_DESTINATION, Destination.class);\n                        cid = in.getHeader(\"JMSCorrelationID\", String.class);\n\n                        LOG.debug(\"ReplyDestination: \" + replyDestination);\n                        LOG.debug(\"JMSCorrelationID: \" + cid);\n\n                        LOG.debug(\"Ahh I cannot send a reply. Someone else must do it.\");\n                        latch.countDown();\n                    }\n                }).to(\"mock:result\");\n            }\n        };\n    }","id":71920,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                // set the MEP to InOptionalOut as we might not be able to send a reply\n                from(getQueueEndpointName()).setExchangePattern(ExchangePattern.InOptionalOut).process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        Message in = exchange.getIn();\n                        assertEquals(\"Hello World\", in.getBody());\n\n                        replyDestination = in.getHeader(\"JMSReplyTo\", Destination.class);\n                        cid = in.getHeader(\"JMSCorrelationID\", String.class);\n\n                        LOG.debug(\"ReplyDestination: \" + replyDestination);\n                        LOG.debug(\"JMSCorrelationID: \" + cid);\n\n                        LOG.debug(\"Ahh I cannot send a reply. Someone else must do it.\");\n                        latch.countDown();\n                    }\n                }).to(\"mock:result\");\n            }\n        };\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"public void run() {\n            try {\n                LOG.debug(\"Wating for latch\");\n                latch.await();\n\n                // wait 1 sec after latch before sending he late replay\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                // ignore\n            }\n\n            LOG.debug(\"Sending late reply\");\n            // use some dummy queue as we override this with the property: JmsConstants.JMS_DESTINATION\n            template.send(\"activemq:dummy\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.setPattern(ExchangePattern.InOnly);\n                    exchange.setProperty(JmsConstants.JMS_DESTINATION, replyDestination);\n                    \n                    Message in = exchange.getIn();\n                    in.setBody(expectedBody);\n                    in.setHeader(\"JMSCorrelationID\", cid);\n                }\n            });\n        }","id":71921,"modified_method":"public void run() {\n            try {\n                LOG.debug(\"Wating for latch\");\n                latch.await();\n\n                // wait 1 sec after latch before sending he late replay\n                Thread.sleep(1000);\n            } catch (Exception e) {\n                // ignore\n            }\n\n            LOG.debug(\"Sending late reply\");\n            // use some dummy queue as we override this with the property: JmsConstants.JMS_DESTINATION\n            template.send(\"activemq:dummy\", new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.setPattern(ExchangePattern.InOnly);\n\n                    Message in = exchange.getIn();\n                    in.setBody(expectedBody);\n                    in.setHeader(JmsConstants.JMS_DESTINATION, replyDestination);\n                    in.setHeader(\"JMSCorrelationID\", cid);\n                }\n            });\n        }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"activemq:queue:hello?useVersion102=true\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getIn().setBody(\"Bye World\");\n                        // the reply destination is set as a property on the exchange while we process it\n                        assertNotNull(exchange.getProperty(JmsConstants.JMS_REPLY_DESTINATION));\n                    }\n                }).to(\"mock:result\");\n            }\n        };\n    }","id":71922,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"activemq:queue:hello?useVersion102=true\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getIn().setBody(\"Bye World\");\n                        assertNotNull(exchange.getIn().getHeader(\"JMSReplyTo\"));\n                    }\n                }).to(\"mock:result\");\n            }\n        };\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"activemq:queue:hello\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getIn().setBody(\"Bye World\");\n                        // the reply destination is set as a property on the exchange while we process it\n                        assertNotNull(exchange.getProperty(JmsConstants.JMS_REPLY_DESTINATION));\n                    }\n                }).to(\"mock:result\");\n            }\n        };\n    }","id":71923,"modified_method":"protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() throws Exception {\n                from(\"activemq:queue:hello\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getIn().setBody(\"Bye World\");\n                        assertNotNull(exchange.getIn().getHeader(\"JMSReplyTo\"));\n                    }\n                }).to(\"mock:result\");\n            }\n        };\n    }","commit_id":"796ce87bf5b8b4648fe458e5003d90ed2713dde4","url":"https://github.com/apache/camel"},{"original_method":"@Nullable\n  private static SVNURL initRoot(final Project project, final String urlString) throws SVNException {\n    final Ref<SVNURL> result = new Ref<SVNURL>();\n    final Ref<SVNException> excRef = new Ref<SVNException>();\n\n    ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n      public void run() {\n        SVNRepository repos = null;\n        try {\n          repos = SvnVcs.getInstance(project).getSvnKitManager().createRepository(urlString);\n          result.set(repos.getRepositoryRoot(true));\n        } catch (SVNException e) {\n          excRef.set(e);\n        } finally {\n          if (repos != null) {\n            repos.closeSession();\n          }\n        }\n      }\n    }, \"Detecting repository root\", true, project);\n    if (! excRef.isNull()) {\n      throw excRef.get();\n    }\n    return result.get();\n  }","id":71924,"modified_method":"@Nullable\n  private static SVNURL initRoot(final Project project, final SVNURL url) throws SVNException {\n    final Ref<SVNURL> result = new Ref<SVNURL>();\n    final Ref<SVNException> excRef = new Ref<SVNException>();\n\n    ProgressManager.getInstance().runProcessWithProgressSynchronously(new Runnable() {\n      public void run() {\n        SVNRepository repos = null;\n        try {\n          repos = SvnVcs.getInstance(project).getSvnKitManager().createRepository(url);\n          result.set(repos.getRepositoryRoot(true));\n        }\n        catch (SVNException e) {\n          excRef.set(e);\n        }\n        finally {\n          if (repos != null) {\n            repos.closeSession();\n          }\n        }\n      }\n    }, \"Detecting repository root\", true, project);\n    if (! excRef.isNull()) {\n      throw excRef.get();\n    }\n    return result.get();\n  }","commit_id":"1a79f0f3b36302093be87d855bdd5bf8b5566d0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String selectLocation(Project project, String url) {\n    try {\n      SVNURL.parseURIEncoded(url);\n      final SVNURL svnurl = initRoot(project, url);\n      if (svnurl == null) {\n        Messages.showErrorDialog(project, \"Can not detect repository root for URL: \" + url,\n                                 SvnBundle.message(\"dialog.title.select.repository.location\"));\n        return null;\n      }\n      SelectLocationDialog dialog = new SelectLocationDialog(project, svnurl, null, null, true);\n      dialog.show();\n      if (!dialog.isOK()) return null;\n      return dialog.getSelectedURL();\n    } catch (SVNException e) {\n      Messages.showErrorDialog(project, e.getMessage(), SvnBundle.message(\"dialog.title.select.repository.location\"));\n      return null;\n    }\n  }","id":71925,"modified_method":"@Nullable\n  public static String selectLocation(Project project, String url) {\n    SelectLocationDialog dialog = openDialog(project, url, null, null, true, null);\n\n    return dialog == null || !dialog.isOK() ? null : dialog.getSelectedURL();\n  }","commit_id":"1a79f0f3b36302093be87d855bdd5bf8b5566d0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static String selectCopyDestination(Project project, String url, String dstLabel, String dstName, boolean showFiles) {\n    try {\n      SVNURL.parseURIEncoded(url);\n      final SVNURL svnurl = initRoot(project, url);\n      SelectLocationDialog dialog = new SelectLocationDialog(project, svnurl, dstLabel, dstName, showFiles);\n      dialog.show();\n      if (!dialog.isOK()) return null;\n\n      final String result = dialog.getSelectedURL();\n      final String name = dialog.getDestinationName();\n      return SVNPathUtil.append(result, name);\n    } catch (SVNException e) {\n      Messages.showErrorDialog(project, SvnBundle.message(\"select.location.invalid.url.message\", url),\n                               SvnBundle.message(\"dialog.title.select.repository.location\"));\n      return null;\n    }\n  }","id":71926,"modified_method":"@Nullable\n  public static String selectCopyDestination(Project project, String url, String dstLabel, String dstName, boolean showFiles) {\n    SelectLocationDialog dialog =\n      openDialog(project, url, dstLabel, dstName, showFiles, SvnBundle.message(\"select.location.invalid.url.message\", url));\n\n    return dialog == null || !dialog.isOK() ? null : SVNPathUtil.append(dialog.getSelectedURL(), dialog.getDestinationName());\n  }","commit_id":"1a79f0f3b36302093be87d855bdd5bf8b5566d0e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    @SuppressWarnings(\"unchecked\")\n    public void testHistogram() throws Exception {\n        final AbsoluteRange range = AbsoluteRange.create(new DateTime(2015, 1, 1, 0, 0), new DateTime(2015, 1, 2, 0, 0));\n        HistogramResult h = searches.histogram(\"*\", Searches.DateHistogramInterval.HOUR, range);\n\n        assertThat(h.getInterval()).isEqualTo(Searches.DateHistogramInterval.HOUR);\n        assertThat(h.getHistogramBoundaries()).isEqualTo(range);\n        assertThat(h.getResults())\n                .hasSize(5)\n                .containsEntry(new DateTime(2015, 1, 1, 1, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 2, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 3, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 4, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 5, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L);\n    }","id":71927,"modified_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    @SuppressWarnings(\"unchecked\")\n    public void testHistogram() throws Exception {\n        final AbsoluteRange range = AbsoluteRange.create(new DateTime(2015, 1, 1, 0, 0).withZone(UTC), new DateTime(2015, 1, 2, 0, 0).withZone(UTC));\n        HistogramResult h = searches.histogram(\"*\", Searches.DateHistogramInterval.HOUR, range);\n\n        assertThat(h.getInterval()).isEqualTo(Searches.DateHistogramInterval.HOUR);\n        assertThat(h.getHistogramBoundaries()).isEqualTo(range);\n        assertThat(h.getResults())\n                .hasSize(5)\n                .containsEntry(new DateTime(2015, 1, 1, 1, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 2, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 3, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 4, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 5, 0, UTC).getMillis() / 1000L, 2L);\n    }","commit_id":"6c446c12e6af98373127cb4ae22de9e733879ac9","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    @SuppressWarnings(\"unchecked\")\n    public void testHistogramWithNonExistingIndex() throws Exception {\n        final SortedSet<IndexRange> indexRanges = ImmutableSortedSet\n                .orderedBy(IndexRange.COMPARATOR)\n                .add(MongoIndexRange.create(INDEX_NAME,\n                        new DateTime(0L, DateTimeZone.UTC),\n                        new DateTime(2015, 1, 1, 0, 0, DateTimeZone.UTC),\n                        DateTime.now(DateTimeZone.UTC),\n                        0))\n                .add(MongoIndexRange.create(\"does-not-exist\",\n                        new DateTime(0L, DateTimeZone.UTC),\n                        new DateTime(2015, 1, 1, 0, 0, DateTimeZone.UTC),\n                        DateTime.now(DateTimeZone.UTC),\n                        0))\n                .build();\n        when(indexRangeService.find(any(DateTime.class), any(DateTime.class))).thenReturn(indexRanges);\n\n        final AbsoluteRange range = AbsoluteRange.create(new DateTime(2015, 1, 1, 0, 0), new DateTime(2015, 1, 2, 0, 0));\n        HistogramResult h = searches.histogram(\"*\", Searches.DateHistogramInterval.HOUR, range);\n\n        assertThat(h.getInterval()).isEqualTo(Searches.DateHistogramInterval.HOUR);\n        assertThat(h.getHistogramBoundaries()).isEqualTo(range);\n        assertThat(h.getResults())\n                .hasSize(5)\n                .containsEntry(new DateTime(2015, 1, 1, 1, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 2, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 3, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 4, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 5, 0, DateTimeZone.UTC).getMillis() / 1000L, 2L);\n    }","id":71928,"modified_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    @SuppressWarnings(\"unchecked\")\n    public void testHistogramWithNonExistingIndex() throws Exception {\n        final SortedSet<IndexRange> indexRanges = ImmutableSortedSet\n                .orderedBy(IndexRange.COMPARATOR)\n                .add(MongoIndexRange.create(INDEX_NAME,\n                        new DateTime(0L, UTC),\n                        new DateTime(2015, 1, 1, 0, 0, UTC),\n                        DateTime.now(UTC),\n                        0))\n                .add(MongoIndexRange.create(\"does-not-exist\",\n                        new DateTime(0L, UTC),\n                        new DateTime(2015, 1, 1, 0, 0, UTC),\n                        DateTime.now(UTC),\n                        0))\n                .build();\n        when(indexRangeService.find(any(DateTime.class), any(DateTime.class))).thenReturn(indexRanges);\n\n        final AbsoluteRange range = AbsoluteRange.create(new DateTime(2015, 1, 1, 0, 0).withZone(UTC), new DateTime(2015, 1, 2, 0, 0).withZone(UTC));\n        HistogramResult h = searches.histogram(\"*\", Searches.DateHistogramInterval.HOUR, range);\n\n        assertThat(h.getInterval()).isEqualTo(Searches.DateHistogramInterval.HOUR);\n        assertThat(h.getHistogramBoundaries()).isEqualTo(range);\n        assertThat(h.getResults())\n                .hasSize(5)\n                .containsEntry(new DateTime(2015, 1, 1, 1, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 2, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 3, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 4, 0, UTC).getMillis() / 1000L, 2L)\n                .containsEntry(new DateTime(2015, 1, 1, 5, 0, UTC).getMillis() / 1000L, 2L);\n    }","commit_id":"6c446c12e6af98373127cb4ae22de9e733879ac9","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    @SuppressWarnings(\"unchecked\")\n    public void testFieldHistogram() throws Exception {\n        final AbsoluteRange range = AbsoluteRange.create(new DateTime(2015, 1, 1, 0, 0), new DateTime(2015, 1, 2, 0, 0));\n        HistogramResult h = searches.fieldHistogram(\"*\", \"n\", Searches.DateHistogramInterval.HOUR, null, range, false);\n\n        assertThat(h.getInterval()).isEqualTo(Searches.DateHistogramInterval.HOUR);\n        assertThat(h.getHistogramBoundaries()).isEqualTo(range);\n        assertThat(h.getResults()).hasSize(5);\n        assertThat((Map<String, Number>) h.getResults().get(new DateTime(2015, 1, 1, 1, 0, DateTimeZone.UTC).getMillis() / 1000L))\n                .containsEntry(\"total_count\", 2L)\n                .containsEntry(\"total\", 0.0);\n        assertThat((Map<String, Number>) h.getResults().get(new DateTime(2015, 1, 1, 2, 0, DateTimeZone.UTC).getMillis() / 1000L))\n                .containsEntry(\"total_count\", 2L)\n                .containsEntry(\"total\", 4.0)\n                .containsEntry(\"mean\", 2.0);\n    }","id":71929,"modified_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    @SuppressWarnings(\"unchecked\")\n    public void testFieldHistogram() throws Exception {\n        final AbsoluteRange range = AbsoluteRange.create(new DateTime(2015, 1, 1, 0, 0).withZone(UTC), new DateTime(2015, 1, 2, 0, 0).withZone(UTC));\n        HistogramResult h = searches.fieldHistogram(\"*\", \"n\", Searches.DateHistogramInterval.HOUR, null, range, false);\n\n        assertThat(h.getInterval()).isEqualTo(Searches.DateHistogramInterval.HOUR);\n        assertThat(h.getHistogramBoundaries()).isEqualTo(range);\n        assertThat(h.getResults()).hasSize(5);\n        assertThat((Map<String, Number>) h.getResults().get(new DateTime(2015, 1, 1, 1, 0, UTC).getMillis() / 1000L))\n                .containsEntry(\"total_count\", 2L)\n                .containsEntry(\"total\", 0.0);\n        assertThat((Map<String, Number>) h.getResults().get(new DateTime(2015, 1, 1, 2, 0, UTC).getMillis() / 1000L))\n                .containsEntry(\"total_count\", 2L)\n                .containsEntry(\"total\", 4.0)\n                .containsEntry(\"mean\", 2.0);\n    }","commit_id":"6c446c12e6af98373127cb4ae22de9e733879ac9","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void testTermsWithNonExistingIndex() throws Exception {\n        final SortedSet<IndexRange> indexRanges = ImmutableSortedSet\n                .orderedBy(IndexRange.COMPARATOR)\n                .add(MongoIndexRange.create(INDEX_NAME,\n                        new DateTime(0L, DateTimeZone.UTC),\n                        new DateTime(2015, 1, 1, 0, 0, DateTimeZone.UTC),\n                        DateTime.now(DateTimeZone.UTC),\n                        0))\n                .add(MongoIndexRange.create(\"does-not-exist\",\n                        new DateTime(0L, DateTimeZone.UTC),\n                        new DateTime(2015, 1, 1, 0, 0, DateTimeZone.UTC),\n                        DateTime.now(DateTimeZone.UTC),\n                        0))\n                .build();\n        when(indexRangeService.find(any(DateTime.class), any(DateTime.class))).thenReturn(indexRanges);\n\n        TermsResult result = searches.terms(\"n\", 25, \"*\", AbsoluteRange.create(\n                new DateTime(2015, 1, 1, 0, 0),\n                new DateTime(2015, 1, 2, 0, 0)));\n\n        assertThat(result.getTotal()).isEqualTo(10L);\n        assertThat(result.getMissing()).isEqualTo(2L);\n        assertThat(result.getTerms())\n                .hasSize(4)\n                .containsEntry(\"1\", 2L)\n                .containsEntry(\"2\", 2L)\n                .containsEntry(\"3\", 3L)\n                .containsEntry(\"4\", 1L);\n    }","id":71930,"modified_method":"@Test\n    @UsingDataSet(loadStrategy = LoadStrategyEnum.CLEAN_INSERT)\n    public void testTermsWithNonExistingIndex() throws Exception {\n        final SortedSet<IndexRange> indexRanges = ImmutableSortedSet\n                .orderedBy(IndexRange.COMPARATOR)\n                .add(MongoIndexRange.create(INDEX_NAME,\n                        new DateTime(0L, UTC),\n                        new DateTime(2015, 1, 1, 0, 0, UTC),\n                        DateTime.now(UTC),\n                        0))\n                .add(MongoIndexRange.create(\"does-not-exist\",\n                        new DateTime(0L, UTC),\n                        new DateTime(2015, 1, 1, 0, 0, UTC),\n                        DateTime.now(UTC),\n                        0))\n                .build();\n        when(indexRangeService.find(any(DateTime.class), any(DateTime.class))).thenReturn(indexRanges);\n\n        TermsResult result = searches.terms(\"n\", 25, \"*\", AbsoluteRange.create(\n                new DateTime(2015, 1, 1, 0, 0),\n                new DateTime(2015, 1, 2, 0, 0)));\n\n        assertThat(result.getTotal()).isEqualTo(10L);\n        assertThat(result.getMissing()).isEqualTo(2L);\n        assertThat(result.getTerms())\n                .hasSize(4)\n                .containsEntry(\"1\", 2L)\n                .containsEntry(\"2\", 2L)\n                .containsEntry(\"3\", 3L)\n                .containsEntry(\"4\", 1L);\n    }","commit_id":"6c446c12e6af98373127cb4ae22de9e733879ac9","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"/**\n     * Removes an object from the list of all cached objects,\n     * no matter what position it has inside the list.\n     *\n     * @param theCacheObject the object being removed from the list of all cached objects\n     * @return a reference to the object that was removed\n     */\n    public synchronized I_CmsFlexLruCacheObject remove( I_CmsFlexLruCacheObject theCacheObject ) {\n        if (!this.isCached(theCacheObject)) {\n            // this object was never ever before added to the cache\n            return null;\n        }\n        \n        // set the list pointers correct\n        if (theCacheObject.getNextLruObject()==null) {\n            // remove the object from the head pos.\n            I_CmsFlexLruCacheObject newHead = theCacheObject.getPreviousLruObject();\n            newHead.setNextLruObject( null );\n            this.m_ListHead = newHead;\n        }\n        else if (theCacheObject.getPreviousLruObject()==null) {\n            // remove the object from the tail pos.\n            I_CmsFlexLruCacheObject newTail = theCacheObject.getNextLruObject();\n            newTail.setPreviousLruObject( null );\n            this.m_ListTail = newTail;\n        }\n        else {\n            // remove the object from within the list\n            theCacheObject.getPreviousLruObject().setNextLruObject( theCacheObject.getNextLruObject() );\n            theCacheObject.getNextLruObject().setPreviousLruObject( theCacheObject.getPreviousLruObject() );\n        }\n        \n        // update cache stats. and notify the cached object\n        this.decreaseCache( theCacheObject );\n        \n        return theCacheObject;\n    }","id":71931,"modified_method":"/**\n     * Removes an object from the list of all cached objects,\n     * no matter what position it has inside the list.\n     *\n     * @param theCacheObject the object being removed from the list of all cached objects\n     * @return a reference to the object that was removed\n     */\n    public synchronized I_CmsFlexLruCacheObject remove( I_CmsFlexLruCacheObject theCacheObject ) {\n        if (!this.isCached(theCacheObject)) {\n            // theCacheObject is null or not inside the cache\n            return null;\n        }\n        \n        // set the list pointers correct\n        if (theCacheObject.getNextLruObject()==null) {\n            // remove the object from the head pos.\n            I_CmsFlexLruCacheObject newHead = theCacheObject.getPreviousLruObject();\n            \n            if (newHead!=null) {\n                // if newHead is null, theCacheObject \n                // was the only object in the cache\n                newHead.setNextLruObject( null );\n            }\n            \n            this.m_ListHead = newHead;\n        }\n        else if (theCacheObject.getPreviousLruObject()==null) {\n            // remove the object from the tail pos.\n            I_CmsFlexLruCacheObject newTail = theCacheObject.getNextLruObject();\n            \n            if (newTail!=null) {\n                // if newTail is null, theCacheObject \n                // was the only object in the cache                \n                newTail.setPreviousLruObject( null );\n            }\n            \n            this.m_ListTail = newTail;\n        }\n        else {\n            // remove the object from within the list\n            theCacheObject.getPreviousLruObject().setNextLruObject( theCacheObject.getNextLruObject() );\n            theCacheObject.getNextLruObject().setPreviousLruObject( theCacheObject.getPreviousLruObject() );\n        }\n        \n        // update cache stats. and notify the cached object\n        this.decreaseCache( theCacheObject );\n        \n        return theCacheObject;\n    }","commit_id":"9fbba7bbd6cf0d30addf3c8a7e416b4be17f2ef5","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * Touch an existing object in this cache, in the sense that it's \"last-recently-used\" state\n     * is updated.<p>\n     *\n     * @param theCacheObject the object being touched\n     * @return true if an object was found and touched\n     */\n    public synchronized boolean touch(I_CmsLruCacheObject theCacheObject) {\n        if (!isCached(theCacheObject)) return false;\n        \n        // only objects with cache costs < the max. allowed object cache costs can be cached!\n        if ((m_maxObjectCosts!=-1) && (theCacheObject.getLruCacheCosts()>m_maxObjectCosts)) {\n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(\"Attempt to cache objects with cache costs \" + theCacheObject.getLruCacheCosts() + \" which is bigger than the max. allowed costs \" + this.m_maxObjectCosts);\n            }\n            remove(theCacheObject);\n            return false;\n        }\n                \n        // set the list pointers correct\n        I_CmsLruCacheObject nextObj;\n        I_CmsLruCacheObject prevObj;\n        if ((nextObj = theCacheObject.getNextLruObject()) == null) {\n            // case 1: the object is already at the head pos.\n            return true;\n        } else if ((prevObj = theCacheObject.getPreviousLruObject()) == null) {\n            // case 2: the object at the tail pos., remove it from the tail to put it to the front as the new head\n            I_CmsLruCacheObject newTail = nextObj;\n            newTail.setPreviousLruObject(null);\n            m_listTail = newTail;\n        } else {\n            // case 3: the object is somewhere within the list, remove it to put it the front as the new head\n            prevObj.setNextLruObject(nextObj);\n            nextObj.setPreviousLruObject(prevObj);\n        }\n        \n        // set the touched object as the new head in the linked list:\n        I_CmsLruCacheObject oldHead = this.m_listHead;\n        oldHead.setNextLruObject(theCacheObject);\n        theCacheObject.setNextLruObject(null);\n        theCacheObject.setPreviousLruObject(oldHead);\n        this.m_listHead = theCacheObject;\n        \n        return true;\n    }","id":71932,"modified_method":"/**\n     * Touch an existing object in this cache, in the sense that it's \"last-recently-used\" state\n     * is updated.<p>\n     *\n     * @param theCacheObject the object being touched\n     * @return true if an object was found and touched\n     */\n    public synchronized boolean touch(I_CmsLruCacheObject theCacheObject) {\n        if (!isCached(theCacheObject)) return false;\n        \n        // only objects with cache costs < the max. allowed object cache costs can be cached!\n        if ((m_maxObjectCosts!=-1) && (theCacheObject.getLruCacheCosts()>m_maxObjectCosts)) {\n            if (OpenCms.getLog(this).isInfoEnabled()) {\n                OpenCms.getLog(this).info(\"Attempt to cache objects with cache costs \" + theCacheObject.getLruCacheCosts() + \" which is bigger than the max. allowed costs \" + this.m_maxObjectCosts);\n            }\n            remove(theCacheObject);\n            return false;\n        }\n                \n        // set the list pointers correct\n        I_CmsLruCacheObject nextObj;\n        I_CmsLruCacheObject prevObj;\n        if ((nextObj = theCacheObject.getNextLruObject()) == null) {\n            // case 1: the object is already at the head pos.\n            return true;\n        } else if ((prevObj = theCacheObject.getPreviousLruObject()) == null) {\n            // case 2: the object at the tail pos., remove it from the tail to put it to the front as the new head\n            I_CmsLruCacheObject newTail = nextObj;\n            newTail.setPreviousLruObject(null);\n            m_listTail = newTail;\n        } else {\n            // case 3: the object is somewhere within the list, remove it to put it the front as the new head\n            prevObj.setNextLruObject(nextObj);\n            nextObj.setPreviousLruObject(prevObj);\n        }\n        \n        // set the touched object as the new head in the linked list:\n        I_CmsLruCacheObject oldHead = this.m_listHead;\n        if (oldHead != null) {\n            oldHead.setNextLruObject(theCacheObject);\n            theCacheObject.setNextLruObject(null);\n            theCacheObject.setPreviousLruObject(oldHead);\n        }\n        this.m_listHead = theCacheObject;\n        \n        return true;\n    }","commit_id":"6ae0598beeaa887bd2458534ee1473f2fc297624","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public Datum map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        GenomeLoc cur = context.getLocation();\n\n        if ( verbose && showSkipped ) {\n            for ( int i = 0; i < context.getSkippedBases(); i++ ) {\n                out.printf(\"%s: skipped%n\", GenomeLocParser.incPos(cur, i - context.getSkippedBases()));\n            }\n        }\n\n        long nRodsHere = 0;\n        long nTotalBases = 0;\n\n        if ( ref == null ) {\n            // we're getting the last skipped update\n            if ( verbose )\n                out.printf(\"Last position was %s: skipping %d bases%n\",\n                        context.getLocation(), context.getSkippedBases() );\n            nRodsHere = -1; // don't update this\n            nTotalBases = context.getSkippedBases();\n        } else {\n            Collection<ReferenceOrderedDatum> rods = new LinkedList<ReferenceOrderedDatum>();\n            for ( ReferenceOrderedDatum rod : tracker.getBoundRods() ) {\n                //System.out.printf(\"Considering rod %s%n\", rod);\n                if ( rod.getLocation().getStart() == context.getLocation().getStart() && ! rod.getName().equals(\"interval\") ) {\n                    // only consider the first element\n                    //System.out.printf(\"adding it%n\");\n                    rods.add(rod);\n                }\n            }\n\n            nRodsHere = rods.size();\n\n            if ( nRodsHere > 0 ) {\n                if ( verbose ) {\n                    List<String> names = new ArrayList<String>();\n                    for ( ReferenceOrderedDatum rod : rods ) {\n                        names.add(rod.getName());\n                    }\n\n                    //System.out.printf(\"context is %s\", context.getSkippedBases());\n                    out.printf(\"At %s: found %d rod(s) [%s] after skipping %d bases%n\",\n                            context.getLocation(), nRodsHere, Utils.join(\",\", names), context.getSkippedBases() );\n                }\n            }\n\n            nTotalBases = context.getSkippedBases() + 1;\n        }\n\n        return new Datum(nRodsHere, context.getSkippedBases(), nTotalBases);\n    }","id":71933,"modified_method":"public Datum map(RefMetaDataTracker tracker, ReferenceContext ref, AlignmentContext context) {\n        GenomeLoc cur = context.getLocation();\n\n        if ( verbose && showSkipped ) {\n            for ( int i = 0; i < context.getSkippedBases(); i++ ) {\n                out.printf(\"%s: skipped%n\", GenomeLocParser.incPos(cur, i - context.getSkippedBases()));\n            }\n        }\n\n        long nRodsHere = 0;\n        long nTotalBases = 0;\n\n        if ( ref == null ) {\n            // we're getting the last skipped update\n            if ( verbose )\n                out.printf(\"Last position was %s: skipping %d bases%n\",\n                        context.getLocation(), context.getSkippedBases() );\n            nRodsHere = -1; // don't update this\n            nTotalBases = context.getSkippedBases();\n        } else {\n            Collection<RODRecordList<ReferenceOrderedDatum>> rods = new LinkedList<RODRecordList<ReferenceOrderedDatum>>();\n            for ( RODRecordList<ReferenceOrderedDatum> rod : tracker.getBoundRodTracks() ) {\n                //System.out.printf(\"Considering rod %s%n\", rod);\n                if ( rod.getLocation().getStart() == context.getLocation().getStart() && ! rod.getName().equals(\"interval\") ) {\n                    // only consider the first element\n                    //System.out.printf(\"adding it%n\");\n                    rods.add(rod);\n                }\n            }\n\n            nRodsHere = rods.size();\n\n            if ( nRodsHere > 0 ) {\n                if ( verbose ) {\n                    List<String> names = new ArrayList<String>();\n                    for ( RODRecordList<ReferenceOrderedDatum> rod : rods ) {\n                        names.add(rod.getName());\n                    }\n\n                    //System.out.printf(\"context is %s\", context.getSkippedBases());\n                    out.printf(\"At %s: found %d rod(s) [%s] after skipping %d bases%n\",\n                            context.getLocation(), nRodsHere, Utils.join(\",\", names), context.getSkippedBases() );\n                }\n            }\n\n            nTotalBases = context.getSkippedBases() + 1;\n        }\n\n        return new Datum(nRodsHere, context.getSkippedBases(), nTotalBases);\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new view of reference-ordered data.\n     * @param provider\n     */\n    public ManagingReferenceOrderedView( ShardDataProvider provider ) {\n        //this.provider = provider;\n        for( ReferenceOrderedDataSource dataSource: provider.getReferenceOrderedData() )\n            states.add( new ReferenceOrderedDataState( dataSource, (RODIterator)dataSource.seek(provider.getShard()) ) );\n\n        provider.register(this);\n    }","id":71934,"modified_method":"/**\n     * Create a new view of reference-ordered data.\n     * @param provider\n     */\n    public ManagingReferenceOrderedView( ShardDataProvider provider ) {\n        //this.provider = provider;\n        for( ReferenceOrderedDataSource dataSource: provider.getReferenceOrderedData() )\n            states.add( new ReferenceOrderedDataState( dataSource, (SeekableRODIterator)dataSource.seek(provider.getShard()) ) );\n\n        provider.register(this);\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ReferenceOrderedDataState( ReferenceOrderedDataSource dataSource, RODIterator iterator ) {\n            this.dataSource = dataSource;\n            this.iterator = iterator;\n        }","id":71935,"modified_method":"public ReferenceOrderedDataState( ReferenceOrderedDataSource dataSource, SeekableRODIterator iterator ) {\n            this.dataSource = dataSource;\n            this.iterator = iterator;\n        }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Binds the reference ordered datum ROD to name at this site.  Should be used only but the traversal\n     * system to provide access to RODs in a structured way to the walkers.\n     *\n     * @param name\n     * @param rod\n     */\n    public void bind(final String name, ReferenceOrderedDatum rod) {\n        //logger.debug(String.format(\"Binding %s to %s\", name, rod));\n        map.put(canonicalName(name), rod);\n    }","id":71936,"modified_method":"/**\n     * Finds the reference metadata track named 'name' and returns all ROD records from that track associated\n     * with the current site as a RODRecordList collection object. If no data track with specified name is available,\n     * returns defaultValue wrapped as RODRecordList object. NOTE: if defaultValue is null, it will be wrapped up\n     * with track name set to 'name' and location set to null; otherwise the wrapper object will have name and\n     * location set to defaultValue.getName() and defaultValue.getLocation(), respectively (use caution,\n     * defaultValue.getLocation() may be not equal to what RODRecordList's location would be expected to be otherwise:\n     * for instance, on locus traversal, location is usually expected to be a single base we are currently looking at,\n     * regardless of the presence of \"extended\" RODs overlapping with that location).\n     * @param name\n     * @param defaultValue\n     * @return\n     */\n    public RODRecordList<ReferenceOrderedDatum> getTrackData(final String name, ReferenceOrderedDatum defaultValue) {\n        //logger.debug(String.format(\"Lookup %s%n\", name));\n        final String luName = canonicalName(name);\n        if ( map.containsKey(luName) )\n            return map.get(luName);\n        else {\n\n            if ( defaultValue == null ) {\n                return new RODRecordList<ReferenceOrderedDatum>(luName, Collections.singletonList(defaultValue), null);\n            } else {\n                return new RODRecordList<ReferenceOrderedDatum>(defaultValue.getName(),\n                                                                Collections.singletonList(defaultValue),\n                                                                defaultValue.getLocation());\n            }\n        }\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Get all of the RODs at the current site\n     *\n     * @return\n     */\n    public Collection<ReferenceOrderedDatum> getBoundRods() {\n        LinkedList<ReferenceOrderedDatum> bound = new LinkedList<ReferenceOrderedDatum>();\n        \n        for ( ReferenceOrderedDatum value : map.values() ) {\n            if ( value != null )\n            bound.add(value);\n        }\n\n        return bound;\n    }","id":71937,"modified_method":"public Collection<ReferenceOrderedDatum> getBoundRodRecords() {\n        LinkedList<ReferenceOrderedDatum> bound = new LinkedList<ReferenceOrderedDatum>();\n\n        for ( RODRecordList<ReferenceOrderedDatum> valueList : map.values() ) {\n            for ( ReferenceOrderedDatum value : valueList ) {\n                if ( value != null )\n                bound.add(value);\n            }\n        }\n\n        return bound;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Finds the reference meta data named name, if it exists, otherwise returns the defaultValue\n     *\n     * @param name\n     * @param defaultValue\n     * @return\n     */\n    public ReferenceOrderedDatum lookup(final String name, ReferenceOrderedDatum defaultValue) {\n        //logger.debug(String.format(\"Lookup %s%n\", name));\n        final String luName = canonicalName(name);\n        if ( map.containsKey(luName) )\n            return map.get(luName);\n        else\n            return defaultValue;\n    }","id":71938,"modified_method":"/**\n     * Finds the reference meta data named name, if it exists, otherwise returns the defaultValue.\n     * This is a legacy method that works with \"singleton\" tracks, in which a single ROD record can be associated\n     * with any given site. If track provides multiple records associated with a site, this method will return\n     * the first one.\n     * @param name\n     * @param defaultValue\n     * @return\n     */\n    @Deprecated\n    public ReferenceOrderedDatum lookup(final String name, ReferenceOrderedDatum defaultValue) {\n        //logger.debug(String.format(\"Lookup %s%n\", name));\n        final String luName = canonicalName(name);\n        if ( map.containsKey(luName) ) {\n            RODRecordList<ReferenceOrderedDatum> value = map.get(luName) ;\n            if ( value != null ) {\n                List<ReferenceOrderedDatum> l = value.getRecords();\n                if ( l != null & l.size() > 0 ) return value.getRecords().get(0);\n            }\n        } \n        return defaultValue;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Get all of the RODs at the current site\n     * \n     * @return\n     */\n    public Collection<ReferenceOrderedDatum> getAllRods() {\n        return map.values();\n    }","id":71939,"modified_method":"/**\n     * Get all of the RODs at the current site. The collection is \"flattened\": for any track that has multiple records\n     * at the current site, they all will be added to the list as separate elements.\n     * \n     * @return\n     */\n    public Collection<ReferenceOrderedDatum> getAllRods() {\n        List<ReferenceOrderedDatum> l = new ArrayList<ReferenceOrderedDatum>();\n        for ( RODRecordList<ReferenceOrderedDatum> rl : map.values() ) {\n            if ( rl == null ) continue; // how do we get null value stored for a track? shouldn't the track be missing from the map alltogether?\n            l.addAll(rl.getRecords());\n        }\n        return l;\n\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ReferenceOrderedData(final String name, File file, Class<ROD> type ) {\n        this.file = file;\n        this.type = type;\n        this.name = name;\n        this.header = initializeROD(name, file, type);\n        this.fieldDelimiter = newROD(name, type).delimiterRegex();\n    }","id":71940,"modified_method":"public ReferenceOrderedData(final String name, File file, Class<ROD> type ) {\n        this.file = file;\n        this.type = type;\n        this.name = name;\n//        this.header = initializeROD(name, file, type);\n//        this.fieldDelimiter = newROD(name, type).delimiterRegex();\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public ArrayList<ReferenceOrderedDatum> readAll() {\n        ArrayList<ReferenceOrderedDatum> elts = new ArrayList<ReferenceOrderedDatum>();\n        for (ReferenceOrderedDatum rec : this) {\n            elts.add(rec);\n        }\n        elts.trimToSize();\n        return elts;\n    }","id":71941,"modified_method":"public ArrayList<ReferenceOrderedDatum> readAll() {\n        ArrayList<ReferenceOrderedDatum> elts = new ArrayList<ReferenceOrderedDatum>();\n        for ( RODRecordList<ROD> l : this ) {\n            for (ReferenceOrderedDatum rec : l) {\n                elts.add(rec);\n            }\n        }\n        elts.trimToSize();\n        return elts;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public RODIterator<ROD> iterator() {\n        Iterator<ROD> it;\n        try {\n            Method m = type.getDeclaredMethod(\"createIterator\", String.class, java.io.File.class);\n            it = (Iterator<ROD>) m.invoke(null, name, file);\n        } catch (java.lang.NoSuchMethodException e) {\n            it = new SimpleRODIterator();\n        } catch (java.lang.NullPointerException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.SecurityException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.IllegalAccessException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.IllegalArgumentException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.reflect.InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n        return new RODIterator<ROD>(it);\n    }","id":71942,"modified_method":"public SeekableRODIterator<ROD> iterator() {\n        Iterator<ROD> it;\n        try {\n            Method m = type.getDeclaredMethod(\"createIterator\", String.class, java.io.File.class);\n            it = (Iterator<ROD>) m.invoke(null, name, file);\n        } catch (java.lang.NoSuchMethodException e) {\n            it = new RODRecordIterator(file,name,type);\n        } catch (java.lang.NullPointerException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.SecurityException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.IllegalAccessException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.IllegalArgumentException e) {\n            throw new RuntimeException(e);\n        } catch (java.lang.reflect.InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n  //      return new RODIterator<ROD>(it);\n        return new SeekableRODIterator(it);\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean validateFile() throws Exception {\n        ReferenceOrderedDatum last = null;\n        for (ReferenceOrderedDatum rec : this) {\n            if (last != null && last.compareTo(rec) == 1) {\n                // It's out of order\n                throw new Exception(\"Out of order elements at \\n\" + last.toString() + \"\\n\" + rec.toString());\n            }\n            last = rec;\n        }\n        return true;\n    }","id":71943,"modified_method":"public boolean validateFile() throws Exception {\n        ReferenceOrderedDatum last = null;\n        for ( RODRecordList<ROD> l : this ) {\n            for (ReferenceOrderedDatum rec : l) {\n                if (last != null && last.compareTo(rec) > 1) {\n                    // It's out of order\n                    throw new Exception(\"Out of order elements at \\n\" + last.toString() + \"\\n\" + rec.toString());\n                }\n                last = rec;\n            }\n        }\n        return true;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void testMe() {\n        for (ReferenceOrderedDatum rec : this) {\n            System.out.println(rec.toString());\n\n            RodGenotypeChipAsGFF gff = (RodGenotypeChipAsGFF) rec;\n            String[] keys = {\"LENGTH\", \"ALT\", \"FOBARBAR\"};\n            for (String key : keys) {\n                System.out.printf(\"  -> %s is (%s)%n\", key, gff.containsAttribute(key) ? gff.getAttribute(key) : \"none\");\n            }\n        }\n        System.exit(1);\n    }","id":71944,"modified_method":"public void testMe() {\n        for (RODRecordList<ROD> rec : this) {\n            System.out.println(rec.getRecords().get(0).toString());\n\n            RodGenotypeChipAsGFF gff = (RodGenotypeChipAsGFF) rec.getRecords().get(0);\n            String[] keys = {\"LENGTH\", \"ALT\", \"FOBARBAR\"};\n            for (String key : keys) {\n                System.out.printf(\"  -> %s is (%s)%n\", key, gff.containsAttribute(key) ? gff.getAttribute(key) : \"none\");\n            }\n        }\n        System.exit(1);\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCreateSingleIterator() {\n        ResourcePool iteratorPool = new ReferenceOrderedDataPool(rod);\n        RODIterator iterator = (RODIterator)iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        TabularROD datum = (TabularROD)iterator.next();\n\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());        \n    }","id":71945,"modified_method":"@Test\n    public void testCreateSingleIterator() {\n        ResourcePool iteratorPool = new ReferenceOrderedDataPool(rod);\n        SeekableRODIterator iterator = (SeekableRODIterator)iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        TabularROD datum = (TabularROD)iterator.next().getRecords().get(0);\n\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());        \n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testIteratorCreation() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod);\n        RODIterator iterator = (RODIterator)iteratorPool.iterator( new MappedStreamSegment(testSite3) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        TabularROD datum = (TabularROD)iterator.seekForward(testSite3);\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        iteratorPool.release(iterator);\n\n        // Create another iterator after the current iterator.\n        iterator = iteratorPool.iterator(new MappedStreamSegment(testSite1) );\n\n        // Make sure that the previously acquired iterator was reused.\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());\n\n        datum = (TabularROD)iterator.next();\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 2, iteratorPool.numAvailableIterators());\n    }","id":71946,"modified_method":"@Test\n    public void testIteratorCreation() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod);\n        SeekableRODIterator iterator = iteratorPool.iterator( new MappedStreamSegment(testSite3) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        TabularROD datum = (TabularROD)iterator.seekForward(testSite3).getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        iteratorPool.release(iterator);\n\n        // Create another iterator after the current iterator.\n        iterator = iteratorPool.iterator(new MappedStreamSegment(testSite1) );\n\n        // Make sure that the previously acquired iterator was reused.\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());\n\n        datum = (TabularROD)iterator.next().getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 2, iteratorPool.numAvailableIterators());\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCreateMultipleIterators() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod);\n        RODIterator iterator1 = iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        // Create a new iterator at position 2.\n        RODIterator iterator2 = iteratorPool.iterator( new MappedStreamSegment(testSite2) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        // Test out-of-order access: first iterator2, then iterator1.\n        // Ugh...first call to a region needs to be a seek. \n        TabularROD datum = (TabularROD)iterator2.seekForward(testSite2);\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        datum = (TabularROD)iterator1.next();\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        // Advance iterator2, and make sure both iterator's contents are still correct.\n        datum = (TabularROD)iterator2.next();\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        datum = (TabularROD)iterator1.next();\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        // Cleanup, and make sure the number of iterators dies appropriately.\n        iteratorPool.release(iterator1);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());\n\n        iteratorPool.release(iterator2);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 2, iteratorPool.numAvailableIterators());        \n    }","id":71947,"modified_method":"@Test\n    public void testCreateMultipleIterators() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod);\n        SeekableRODIterator iterator1 = iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        // Create a new iterator at position 2.\n        SeekableRODIterator iterator2 = iteratorPool.iterator( new MappedStreamSegment(testSite2) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        // Test out-of-order access: first iterator2, then iterator1.\n        // Ugh...first call to a region needs to be a seek. \n        TabularROD datum = (TabularROD)iterator2.seekForward(testSite2).getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        datum = (TabularROD)iterator1.next().getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        // Advance iterator2, and make sure both iterator's contents are still correct.\n        datum = (TabularROD)iterator2.next().getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        datum = (TabularROD)iterator1.next().getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite2));\n        assertTrue(datum.get(\"COL1\").equals(\"C\"));\n        assertTrue(datum.get(\"COL2\").equals(\"D\"));\n        assertTrue(datum.get(\"COL3\").equals(\"E\"));\n\n        // Cleanup, and make sure the number of iterators dies appropriately.\n        iteratorPool.release(iterator1);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());\n\n        iteratorPool.release(iterator2);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 2, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 2, iteratorPool.numAvailableIterators());        \n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testIteratorConservation() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod);\n        RODIterator iterator = (RODIterator)iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        TabularROD datum = (TabularROD)iterator.next();\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        // Create another iterator after the current iterator.\n        iterator = iteratorPool.iterator( new MappedStreamSegment(testSite3) );\n\n        // Make sure that the previously acquired iterator was reused.\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        datum = (TabularROD)iterator.seekForward(testSite3);\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());\n    }","id":71948,"modified_method":"@Test\n    public void testIteratorConservation() {\n        ReferenceOrderedDataPool iteratorPool = new ReferenceOrderedDataPool(rod);\n        SeekableRODIterator iterator = iteratorPool.iterator( new MappedStreamSegment(testSite1) );\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        TabularROD datum = (TabularROD)iterator.next().getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite1));\n        assertTrue(datum.get(\"COL1\").equals(\"A\"));\n        assertTrue(datum.get(\"COL2\").equals(\"B\"));\n        assertTrue(datum.get(\"COL3\").equals(\"C\"));\n\n        iteratorPool.release(iterator);\n\n        // Create another iterator after the current iterator.\n        iterator = iteratorPool.iterator( new MappedStreamSegment(testSite3) );\n\n        // Make sure that the previously acquired iterator was reused.\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 0, iteratorPool.numAvailableIterators());\n\n        datum = (TabularROD)iterator.seekForward(testSite3).getRecords().get(0);\n        assertTrue(datum.getLocation().equals(testSite3));\n        assertTrue(datum.get(\"COL1\").equals(\"F\"));\n        assertTrue(datum.get(\"COL2\").equals(\"G\"));\n        assertTrue(datum.get(\"COL3\").equals(\"H\"));\n\n        iteratorPool.release(iterator);\n\n        Assert.assertEquals(\"Number of iterators in the pool is incorrect\", 1, iteratorPool.numIterators());\n        Assert.assertEquals(\"Number of available iterators in the pool is incorrect\", 1, iteratorPool.numAvailableIterators());\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Seek to the specified position and return an iterator through the data.\n     * @param shard Shard that points to the selected position.\n     * @return Iterator through the data.\n     */\n    public Iterator seek( Shard shard ) {\n        RODIterator iterator = iteratorPool.iterator( new MappedStreamSegment(shard.getGenomeLoc()) );\n        return iterator;\n    }","id":71949,"modified_method":"/**\n     * Seek to the specified position and return an iterator through the data.\n     * @param shard Shard that points to the selected position.\n     * @return Iterator through the data.\n     */\n    public Iterator seek( Shard shard ) {\n        SeekableRODIterator iterator = iteratorPool.iterator( new MappedStreamSegment(shard.getGenomeLoc()) );\n        return iterator;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Don't worry about closing the resource; let the file handles expire naturally for the moment.\n     */\n    public void closeResource(  RODIterator resource ) {\n        \n    }","id":71950,"modified_method":"/**\n     * Don't worry about closing the resource; let the file handles expire naturally for the moment.\n     */\n    public void closeResource(  SeekableRODIterator resource ) {\n        \n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new iterator from the existing reference-ordered data.  This new iterator is expected\n     * to be completely independent of any other iterator.\n     * @return The newly created resource.\n     */\n    public RODIterator createNewResource() {\n        return rod.iterator();\n    }","id":71951,"modified_method":"/**\n     * Create a new iterator from the existing reference-ordered data.  This new iterator is expected\n     * to be completely independent of any other iterator.\n     * @return The newly created resource.\n     */\n    public SeekableRODIterator createNewResource() {\n        return rod.iterator();\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Finds the best existing ROD iterator from the pool.  In this case, the best existing ROD is defined as\n     * the first one encountered that is at or before the given position.\n     * @param segment @{inheritedDoc}\n     * @param resources @{inheritedDoc}\n     * @return @{inheritedDoc}\n     */\n    public RODIterator selectBestExistingResource( DataStreamSegment segment, List<RODIterator> resources ) {\n        if( !(segment instanceof MappedStreamSegment) )\n            throw new StingException(\"Reference-ordered data cannot utilitize unmapped segments.\");\n\n        GenomeLoc position = ((MappedStreamSegment)segment).locus;\n\n        for( RODIterator iterator: resources ) {\n            if( (iterator.position() == null && iterator.hasNext()) ||\n                (iterator.position() != null && iterator.position().isBefore(position)) )\n                return iterator;\n        }\n        return null;\n    }","id":71952,"modified_method":"/**\n     * Finds the best existing ROD iterator from the pool.  In this case, the best existing ROD is defined as\n     * the first one encountered that is at or before the given position.\n     * @param segment @{inheritedDoc}\n     * @param resources @{inheritedDoc}\n     * @return @{inheritedDoc}\n     */\n    public SeekableRODIterator selectBestExistingResource( DataStreamSegment segment, List<SeekableRODIterator> resources ) {\n        if( !(segment instanceof MappedStreamSegment) )\n            throw new StingException(\"Reference-ordered data cannot utilitize unmapped segments.\");\n\n        GenomeLoc position = ((MappedStreamSegment)segment).locus;\n\n        for( SeekableRODIterator iterator: resources ) {\n            if( (iterator.position() == null && iterator.hasNext()) ||\n                (iterator.position() != null && iterator.position().isBefore(position)) )\n                return iterator;\n        }\n        return null;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Close the specified iterator, returning it to the pool.\n     * @param iterator Iterator to close.\n     */\n    public void close( RODIterator iterator ) {\n        this.iteratorPool.release(iterator);        \n    }","id":71953,"modified_method":"/**\n     * Close the specified iterator, returning it to the pool.\n     * @param iterator Iterator to close.\n     */\n    public void close( SeekableRODIterator iterator ) {\n        this.iteratorPool.release(iterator);        \n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * In this case, the iterator is the resource.  Pass it through.\n     */\n    public RODIterator createIteratorFromResource( DataStreamSegment segment, RODIterator resource ) {\n        return resource;\n    }","id":71954,"modified_method":"/**\n     * In this case, the iterator is the resource.  Pass it through.\n     */\n    public SeekableRODIterator createIteratorFromResource( DataStreamSegment segment, SeekableRODIterator resource ) {\n        return resource;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new view of reference-ordered data.\n     *\n     * @param provider\n     */\n    public RodLocusView( ShardDataProvider provider ) {\n        super(provider);\n\n        GenomeLoc loc = provider.getShard().getGenomeLoc();\n\n        List<Iterator<ReferenceOrderedDatum>> iterators = new LinkedList<Iterator<ReferenceOrderedDatum>>();\n        for( ReferenceOrderedDataSource dataSource: provider.getReferenceOrderedData() ) {\n            if ( DEBUG ) System.out.printf(\"Shard is %s%n\", loc);\n            RODIterator it = (RODIterator)dataSource.seek(provider.getShard());\n            ReferenceOrderedDatum x = it.seekForward(loc);\n\n            // we need to special case the interval so we don't always think there's a rod at the first location\n            if ( dataSource.getName().equals(INTERVAL_ROD_NAME) ) {\n                if ( interval != null )\n                    throw new RuntimeException(\"BUG: interval local variable already assigned \" + interval);\n                interval = x;\n            } else {\n                iterators.add( (Iterator<ReferenceOrderedDatum>)it );\n            }\n        }\n\n        rodQueue = new MergingIterator<ReferenceOrderedDatum>(iterators);\n    }","id":71955,"modified_method":"/**\n     * Create a new view of reference-ordered data.\n     *\n     * @param provider\n     */\n    public RodLocusView( ShardDataProvider provider ) {\n        super(provider);\n\n        GenomeLoc loc = provider.getShard().getGenomeLoc();\n\n        List< Iterator<RODRecordList<ReferenceOrderedDatum>> > iterators = new LinkedList< Iterator<RODRecordList<ReferenceOrderedDatum>> >();\n        for( ReferenceOrderedDataSource dataSource: provider.getReferenceOrderedData() ) {\n            if ( DEBUG ) System.out.printf(\"Shard is %s%n\", loc);\n            SeekableRODIterator it = (SeekableRODIterator)dataSource.seek(provider.getShard());\n            RODRecordList<ReferenceOrderedDatum> x = it.seekForward(loc);\n\n            // we need to special case the interval so we don't always think there's a rod at the first location\n            if ( dataSource.getName().equals(INTERVAL_ROD_NAME) ) {\n                if ( interval != null )\n                    throw new RuntimeException(\"BUG: interval local variable already assigned \" + interval);\n                interval = x;\n            } else {\n                iterators.add( it );\n            }\n        }\n\n        rodQueue = new MergingIterator<RODRecordList<ReferenceOrderedDatum>>(iterators);\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Returns the next covered locus context in the shard.\n     * @return Next covered locus context in the shard.\n     * @throw NoSuchElementException if no such element exists.\n     */\n    public AlignmentContext next() {\n        if ( DEBUG ) System.out.printf(\"In RodLocusView.next()...%n\");\n        ReferenceOrderedDatum datum = rodQueue.next();\n        if ( DEBUG ) System.out.printf(\"In RodLocusView.next(); datum = %s...%n\", datum.getLocation());\n\n        if ( DEBUG ) System.out.printf(\"In RodLocusView.next(): creating tracker...%n\");\n\n        // Update the tracker here for use\n        Collection<ReferenceOrderedDatum> allRODsHere = getSpanningRods(datum);\n        tracker = createTracker(allRODsHere);\n\n        GenomeLoc rodSite = datum.getLocation();\n        GenomeLoc site = GenomeLocParser.createGenomeLoc( rodSite.getContigIndex(), rodSite.getStart(), rodSite.getStart());\n\n        if ( DEBUG ) System.out.printf(\"rodLocusView.next() is at %s%n\", site);\n\n        // calculate the number of skipped bases, and update lastLoc so we can do that again in the next()\n        long skippedBases = getSkippedBases( rodSite );\n        lastLoc = site;\n        return new AlignmentContext(site, new ArrayList<SAMRecord>(), new ArrayList<Integer>(), skippedBases);\n    }","id":71956,"modified_method":"/**\n     * Returns the next covered locus context in the shard.\n     * @return Next covered locus context in the shard.\n     * @throw NoSuchElementException if no such element exists.\n     */\n    public AlignmentContext next() {\n        if ( DEBUG ) System.out.printf(\"In RodLocusView.next()...%n\");\n        RODRecordList<ReferenceOrderedDatum> datum = rodQueue.next();\n        if ( DEBUG ) System.out.printf(\"In RodLocusView.next(); datum = %s...%n\", datum.getLocation());\n\n        if ( DEBUG ) System.out.printf(\"In RodLocusView.next(): creating tracker...%n\");\n\n        // Update the tracker here for use\n        Collection<RODRecordList<ReferenceOrderedDatum>> allTracksHere = getSpanningTracks(datum);\n        tracker = createTracker(allTracksHere);\n\n        GenomeLoc rodSite = datum.getLocation();\n        GenomeLoc site = GenomeLocParser.createGenomeLoc( rodSite.getContigIndex(), rodSite.getStart(), rodSite.getStart());\n\n        if ( DEBUG ) System.out.printf(\"rodLocusView.next() is at %s%n\", site);\n\n        // calculate the number of skipped bases, and update lastLoc so we can do that again in the next()\n        long skippedBases = getSkippedBases( rodSite );\n        lastLoc = site;\n        return new AlignmentContext(site, new ArrayList<SAMRecord>(), new ArrayList<Integer>(), skippedBases);\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"private Collection<ReferenceOrderedDatum> getSpanningRods(ReferenceOrderedDatum marker) {\n        return rodQueue.allElementsLTE(marker);\n    }","id":71957,"modified_method":"private Collection<RODRecordList<ReferenceOrderedDatum>> getSpanningTracks(ReferenceOrderedDatum marker) {\n        RODRecordList<ReferenceOrderedDatum> wrapper = new RODRecordList<ReferenceOrderedDatum>(marker.getName(),Collections.singletonList(marker));\n        return rodQueue.allElementsLTE(wrapper);\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"private RefMetaDataTracker createTracker( Collection<ReferenceOrderedDatum> allRodsHere ) {\n        RefMetaDataTracker t = new RefMetaDataTracker();\n        for ( ReferenceOrderedDatum element : allRodsHere ) {\n            if ( ! t.hasROD(element.getName()) )\n                t.bind(element.getName(), element);\n        }\n\n        // special case the interval again -- add it into the ROD\n        if ( interval != null ) { t.bind(interval.getName(), interval); }\n\n        return t;\n    }","id":71958,"modified_method":"private RefMetaDataTracker createTracker( Collection<RODRecordList<ReferenceOrderedDatum>> allTracksHere ) {\n        RefMetaDataTracker t = new RefMetaDataTracker();\n        for ( RODRecordList<ReferenceOrderedDatum> track : allTracksHere ) {\n            if ( ! t.hasROD(track.getName()) )\n                t.bind(track.getName(), track);\n        }\n\n        // special case the interval again -- add it into the ROD\n        if ( interval != null ) { t.bind(interval.getName(), interval); }\n\n        return t;\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public boolean hasNext() {\n        if ( ! rodQueue.hasNext() )\n            return false;\n        else {\n            ReferenceOrderedDatum peeked = rodQueue.peek();\n            return ! peeked.getLocation().isPast(shard.getGenomeLoc());\n        }\n    }","id":71959,"modified_method":"public boolean hasNext() {\n        if ( ! rodQueue.hasNext() )\n            return false;\n        else {\n            RODRecordList<ReferenceOrderedDatum> peeked = rodQueue.peek();\n            return ! peeked.getLocation().isPast(shard.getGenomeLoc());\n        }\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void test3() {\n        logger.warn(\"Executing test3\");\n        TabularROD one = (TabularROD)iter.next();\n        TabularROD two = (TabularROD)iter.next();\n        TabularROD three = (TabularROD)iter.next();\n        assertTrue(three.size() == 4);\n        assertTrue(three.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 30)));\n        assertTrue(three.get(\"COL1\").equals(\"F\"));\n        assertTrue(three.get(\"COL2\").equals(\"G\"));\n        assertTrue(three.get(\"COL3\").equals(\"H\"));\n    }","id":71960,"modified_method":"@Test\n    public void test3() {\n        logger.warn(\"Executing test3\");\n        RODRecordList<TabularROD> oneList = iter.next();\n        RODRecordList<TabularROD> twoList = iter.next();\n        RODRecordList<TabularROD> threeList = iter.next();\n        TabularROD one = oneList.getRecords().get(0);\n        TabularROD two = twoList.getRecords().get(0);\n        TabularROD three = threeList.getRecords().get(0);\n        assertTrue(three.size() == 4);\n        assertTrue(three.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 30)));\n        assertTrue(three.get(\"COL1\").equals(\"F\"));\n        assertTrue(three.get(\"COL2\").equals(\"G\"));\n        assertTrue(three.get(\"COL3\").equals(\"H\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testToString() {\n        logger.warn(\"Executing testToString\");\n        TabularROD one = (TabularROD)iter.next();\n        assertTrue(one.toString().equals(\"chrM:10\\tA\\tB\\tC\"));\n    }","id":71961,"modified_method":"@Test\n    public void testToString() {\n        logger.warn(\"Executing testToString\");\n        RODRecordList<TabularROD> oneList = iter.next();\n        TabularROD one = oneList.getRecords().get(0);\n        assertTrue(one.toString().equals(\"chrM:10\\tA\\tB\\tC\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void test2() {\n        logger.warn(\"Executing test2\");\n        TabularROD one = (TabularROD)iter.next();\n        TabularROD two = (TabularROD)iter.next();\n        assertTrue(two.size() == 4);\n        assertTrue(two.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 20)));\n        assertTrue(two.get(\"COL1\").equals(\"C\"));\n        assertTrue(two.get(\"COL2\").equals(\"D\"));\n        assertTrue(two.get(\"COL3\").equals(\"E\"));\n    }","id":71962,"modified_method":"@Test\n    public void test2() {\n        logger.warn(\"Executing test2\");\n        RODRecordList<TabularROD> oneList = iter.next();\n        RODRecordList<TabularROD> twoList = iter.next();\n        TabularROD one = oneList.getRecords().get(0);\n        TabularROD two = twoList.getRecords().get(0);\n        assertTrue(two.size() == 4);\n        assertTrue(two.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 20)));\n        assertTrue(two.get(\"COL1\").equals(\"C\"));\n        assertTrue(two.get(\"COL2\").equals(\"D\"));\n        assertTrue(two.get(\"COL3\").equals(\"E\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void test1() {\n        logger.warn(\"Executing test1\");\n        TabularROD one = (TabularROD)iter.next();\n        assertTrue(one.size() == 4);\n        assertTrue(one.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 10)));\n        assertTrue(one.get(\"COL1\").equals(\"A\"));\n        assertTrue(one.get(\"COL2\").equals(\"B\"));        \n        assertTrue(one.get(\"COL3\").equals(\"C\"));\n    }","id":71963,"modified_method":"@Test\n    public void test1() {\n        logger.warn(\"Executing test1\");\n        RODRecordList<TabularROD> oneList = iter.next();\n        TabularROD one = oneList.getRecords().get(0);\n        assertTrue(one.size() == 4);\n        assertTrue(one.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 10)));\n        assertTrue(one.get(\"COL1\").equals(\"A\"));\n        assertTrue(one.get(\"COL2\").equals(\"B\"));        \n        assertTrue(one.get(\"COL3\").equals(\"C\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testCreationAndWriting() throws FileNotFoundException {\n        logger.warn(\"Executing testCreationAndWriting\");\n\n        File outputFile = new File(testDir + \"testTabularRodOutputTemp.dat\");\n        PrintStream out = new PrintStream(new FileOutputStream(outputFile));\n\n        ArrayList<String> header = new ArrayList<String>(Arrays.asList(\"HEADER\", \"col1\", \"col2\", \"col3\"));\n        out.println(TabularROD.commentString(\"Hello, created from test\"));\n        out.println(TabularROD.commentString(\"\"));\n        out.println(TabularROD.headerString(header));\n\n        String rowData = String.format(\"%d %d %d\", 1, 2, 3);\n        TabularROD row = new TabularROD(\"myName\", header, GenomeLocParser.createGenomeLoc(\"chrM\", 1), rowData.split(\" \"));\n        out.println(row.toString());\n\n        rowData = String.format(\"%d %d %d\", 3, 4, 5);\n        row = new TabularROD(\"myName\", header, GenomeLocParser.createGenomeLoc(\"chrM\", 2), rowData.split(\" \"));\n        out.println(row.toString());\n\n        ReferenceOrderedData ROD_commas = new ReferenceOrderedData(\"tableTest\", outputFile, TabularROD.class);\n        RODIterator iter_commas = ROD_commas.iterator();\n\n        TabularROD one = (TabularROD)iter_commas.next();\n        assertTrue(one.size() == 4);\n        assertTrue(one.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 1)));\n        assertTrue(one.get(\"col1\").equals(\"1\"));\n        assertTrue(one.get(\"col2\").equals(\"2\"));\n        assertTrue(one.get(\"col3\").equals(\"3\"));\n\n        TabularROD two = (TabularROD)iter_commas.next();\n        assertTrue(two.size() == 4);\n        assertTrue(two.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 2)));\n        assertTrue(two.get(\"col1\").equals(\"3\"));\n        assertTrue(two.get(\"col2\").equals(\"4\"));\n        assertTrue(two.get(\"col3\").equals(\"5\"));\n    }","id":71964,"modified_method":"@Test\n    public void testCreationAndWriting() throws FileNotFoundException {\n        logger.warn(\"Executing testCreationAndWriting\");\n\n        File outputFile = new File(testDir + \"testTabularRodOutputTemp.dat\");\n        PrintStream out = new PrintStream(new FileOutputStream(outputFile));\n\n        ArrayList<String> header = new ArrayList<String>(Arrays.asList(\"HEADER\", \"col1\", \"col2\", \"col3\"));\n        out.println(TabularROD.commentString(\"Hello, created from test\"));\n        out.println(TabularROD.commentString(\"\"));\n        out.println(TabularROD.headerString(header));\n\n        String rowData = String.format(\"%d %d %d\", 1, 2, 3);\n        TabularROD row = new TabularROD(\"myName\", header, GenomeLocParser.createGenomeLoc(\"chrM\", 1), rowData.split(\" \"));\n        out.println(row.toString());\n\n        rowData = String.format(\"%d %d %d\", 3, 4, 5);\n        row = new TabularROD(\"myName\", header, GenomeLocParser.createGenomeLoc(\"chrM\", 2), rowData.split(\" \"));\n        out.println(row.toString());\n\n        ReferenceOrderedData ROD_commas = new ReferenceOrderedData(\"tableTest\", outputFile, TabularROD.class);\n        SeekableRODIterator<TabularROD> iter_commas = ROD_commas.iterator();\n\n        RODRecordList<TabularROD> oneList = iter_commas.next();\n        TabularROD one = oneList.getRecords().get(0);\n        assertTrue(one.size() == 4);\n        assertTrue(one.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 1)));\n        assertTrue(one.get(\"col1\").equals(\"1\"));\n        assertTrue(one.get(\"col2\").equals(\"2\"));\n        assertTrue(one.get(\"col3\").equals(\"3\"));\n\n        RODRecordList<TabularROD> twoList = iter_commas.next();\n        TabularROD two = twoList.getRecords().get(0);\n        assertTrue(two.size() == 4);\n        assertTrue(two.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 2)));\n        assertTrue(two.get(\"col1\").equals(\"3\"));\n        assertTrue(two.get(\"col2\").equals(\"4\"));\n        assertTrue(two.get(\"col3\").equals(\"5\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test (expected = RuntimeException.class)\n    public void testDelim1() {\n        File file2 = new File(testDir + \"TabularDataTest2.dat\");        \n        ReferenceOrderedData ROD_commas = new ReferenceOrderedData(\"tableTest\", file2, TabularROD.class);\n        RODIterator iter_commas = ROD_commas.iterator();\n\n        logger.warn(\"Executing testDelim1\");\n        TabularROD one2 = (TabularROD)iter_commas.next();\n        assertTrue(one2.size() == 5);\n        assertTrue(one2.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 10)));\n        assertTrue(one2.get(\"COL1\").equals(\"A\"));\n        assertTrue(one2.get(\"COL2\").equals(\"B\"));\n        assertTrue(one2.get(\"COL3\").equals(\"C\"));\n        assertTrue(one2.get(\"COL4\").equals(\"1\"));\n    }","id":71965,"modified_method":"@Test (expected = RuntimeException.class)\n    public void testDelim1() {\n        File file2 = new File(testDir + \"TabularDataTest2.dat\");        \n        ReferenceOrderedData ROD_commas = new ReferenceOrderedData(\"tableTest\", file2, TabularROD.class);\n        SeekableRODIterator<TabularROD> iter_commas = ROD_commas.iterator();\n\n        logger.warn(\"Executing testDelim1\");\n        RODRecordList<TabularROD> one2List = iter_commas.next();\n        TabularROD one2 = one2List.getRecords().get(0);\n        assertTrue(one2.size() == 5);\n        assertTrue(one2.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 10)));\n        assertTrue(one2.get(\"COL1\").equals(\"A\"));\n        assertTrue(one2.get(\"COL2\").equals(\"B\"));\n        assertTrue(one2.get(\"COL3\").equals(\"C\"));\n        assertTrue(one2.get(\"COL4\").equals(\"1\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testDone() {\n        logger.warn(\"Executing testDone\");\n        TabularROD one = (TabularROD)iter.next();\n        TabularROD two = (TabularROD)iter.next();\n        TabularROD three = (TabularROD)iter.next();\n        assertTrue(!iter.hasNext());\n    }","id":71966,"modified_method":"@Test\n    public void testDone() {\n        logger.warn(\"Executing testDone\");\n        RODRecordList<TabularROD> oneList = iter.next();\n        RODRecordList<TabularROD> twoList = iter.next();\n        RODRecordList<TabularROD> threeList = iter.next();\n        TabularROD one = oneList.getRecords().get(0);\n        TabularROD two = twoList.getRecords().get(0);\n        TabularROD three = threeList.getRecords().get(0);\n        assertTrue(!iter.hasNext());\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testDelim2() {\n        TabularROD.setDelimiter(\",\",\",\");\n        File file2 = new File(testDir + \"TabularDataTest2.dat\");\n        ReferenceOrderedData ROD_commas = new ReferenceOrderedData(\"tableTest\", file2, TabularROD.class);\n        RODIterator iter_commas = ROD_commas.iterator();\n\n        logger.warn(\"Executing testDelim1\");\n        TabularROD one2 = (TabularROD)iter_commas.next();\n        assertTrue(one2.size() == 5);\n        assertTrue(one2.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 10)));\n        assertTrue(one2.get(\"COL1\").equals(\"A\"));\n        assertTrue(one2.get(\"COL2\").equals(\"B\"));\n        assertTrue(one2.get(\"COL3\").equals(\"C\"));\n        assertTrue(one2.get(\"COL4\").equals(\"1\"));\n    }","id":71967,"modified_method":"@Test\n    public void testDelim2() {\n        TabularROD.setDelimiter(\",\",\",\");\n        File file2 = new File(testDir + \"TabularDataTest2.dat\");\n        ReferenceOrderedData ROD_commas = new ReferenceOrderedData(\"tableTest\", file2, TabularROD.class);\n        SeekableRODIterator<TabularROD> iter_commas = ROD_commas.iterator();\n\n        logger.warn(\"Executing testDelim1\");\n        RODRecordList<TabularROD> one2List = iter_commas.next();\n        TabularROD one2 = one2List.getRecords().get(0);\n        assertTrue(one2.size() == 5);\n        assertTrue(one2.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 10)));\n        assertTrue(one2.get(\"COL1\").equals(\"A\"));\n        assertTrue(one2.get(\"COL2\").equals(\"B\"));\n        assertTrue(one2.get(\"COL3\").equals(\"C\"));\n        assertTrue(one2.get(\"COL4\").equals(\"1\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testSeek() {\n        logger.warn(\"Executing testSeek\");\n        TabularROD two = (TabularROD)iter.seekForward(GenomeLocParser.createGenomeLoc(\"chrM\", 20));\n        assertTrue(two.size() == 4);\n        assertTrue(two.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 20)));\n        assertTrue(two.get(\"COL1\").equals(\"C\"));\n        assertTrue(two.get(\"COL2\").equals(\"D\"));\n        assertTrue(two.get(\"COL3\").equals(\"E\"));\n    }","id":71968,"modified_method":"@Test\n    public void testSeek() {\n        logger.warn(\"Executing testSeek\");\n        RODRecordList<TabularROD> twoList = iter.seekForward(GenomeLocParser.createGenomeLoc(\"chrM\", 20));\n        TabularROD two = twoList.getRecords().get(0);\n        assertTrue(two.size() == 4);\n        assertTrue(two.getLocation().equals(GenomeLocParser.createGenomeLoc(\"chrM\", 20)));\n        assertTrue(two.get(\"COL1\").equals(\"C\"));\n        assertTrue(two.get(\"COL2\").equals(\"D\"));\n        assertTrue(two.get(\"COL3\").equals(\"E\"));\n    }","commit_id":"a6bd5095937212687fd2c8de3700ea5e15af1fe7","url":"https://github.com/broadgsa/gatk"},{"original_method":"public void deploy( File source, Artifact artifact, ArtifactRepository deploymentRepository,\n                        ArtifactRepository localRepository )\n        throws ArtifactDeploymentException\n    {\n        DefaultRepositorySystemSession session =\n            new DefaultRepositorySystemSession( legacySupport.getRepositorySession() );\n        session.setLocalRepositoryManager( LegacyLocalRepositoryManager.wrap( localRepository, repoSystem ) );\n\n        DeployRequest request = new DeployRequest();\n\n        org.sonatype.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact( artifact );\n        mainArtifact = mainArtifact.setFile( source );\n        request.addArtifact( mainArtifact );\n\n        String versionKey = artifact.getGroupId() + ':' + artifact.getArtifactId();\n        String snapshotKey = null;\n        if ( artifact.isSnapshot() )\n        {\n            snapshotKey = versionKey + ':' + artifact.getBaseVersion();\n            request.addMetadata( relatedMetadata.get( snapshotKey ) );\n        }\n        request.addMetadata( relatedMetadata.get( versionKey ) );\n\n        for ( ArtifactMetadata metadata : artifact.getMetadataList() )\n        {\n            if ( metadata instanceof ProjectArtifactMetadata )\n            {\n                org.sonatype.aether.artifact.Artifact pomArtifact = new SubArtifact( mainArtifact, \"\", \"pom\" );\n                pomArtifact = pomArtifact.setFile( ( (ProjectArtifactMetadata) metadata ).getFile() );\n                request.addArtifact( pomArtifact );\n            }\n            else if ( metadata instanceof SnapshotArtifactRepositoryMetadata\n                || metadata instanceof ArtifactRepositoryMetadata )\n            {\n                // eaten, handled by repo system\n            }\n            else\n            {\n                request.addMetadata( new MetadataBridge( metadata ) );\n            }\n        }\n\n        RemoteRepository remoteRepo = RepositoryUtils.toRepo( deploymentRepository );\n        /*\n         * NOTE: This provides backward-compat with maven-deploy-plugin:2.4 which bypasses the repository factory when\n         * using an alternative deployment location.\n         */\n        if ( deploymentRepository instanceof DefaultArtifactRepository\n            && deploymentRepository.getAuthentication() == null )\n        {\n            remoteRepo.setAuthentication( session.getAuthenticationSelector().getAuthentication( remoteRepo ) );\n            remoteRepo.setProxy( session.getProxySelector().getProxy( remoteRepo ) );\n        }\n        request.setRepository( remoteRepo );\n\n        DeployResult result;\n        try\n        {\n            result = repoSystem.deploy( session, request );\n        }\n        catch ( DeploymentException e )\n        {\n            throw new ArtifactDeploymentException( e.getMessage(), e );\n        }\n\n        for ( Object metadata : result.getMetadata() )\n        {\n            if ( metadata.getClass().getName().endsWith( \".internal.VersionsMetadata\" ) )\n            {\n                relatedMetadata.put( versionKey, (MergeableMetadata) metadata );\n            }\n            if ( snapshotKey != null && metadata.getClass().getName().endsWith( \".internal.RemoteSnapshotMetadata\" ) )\n            {\n                relatedMetadata.put( snapshotKey, (MergeableMetadata) metadata );\n            }\n        }\n\n        artifact.setResolvedVersion( result.getArtifacts().iterator().next().getVersion() );\n    }","id":71969,"modified_method":"public void deploy( File source, Artifact artifact, ArtifactRepository deploymentRepository,\n                        ArtifactRepository localRepository )\n        throws ArtifactDeploymentException\n    {\n        RepositorySystemSession session =\n            LegacyLocalRepositoryManager.overlay( localRepository, legacySupport.getRepositorySession(), repoSystem );\n\n        DeployRequest request = new DeployRequest();\n\n        org.sonatype.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact( artifact );\n        mainArtifact = mainArtifact.setFile( source );\n        request.addArtifact( mainArtifact );\n\n        String versionKey = artifact.getGroupId() + ':' + artifact.getArtifactId();\n        String snapshotKey = null;\n        if ( artifact.isSnapshot() )\n        {\n            snapshotKey = versionKey + ':' + artifact.getBaseVersion();\n            request.addMetadata( relatedMetadata.get( snapshotKey ) );\n        }\n        request.addMetadata( relatedMetadata.get( versionKey ) );\n\n        for ( ArtifactMetadata metadata : artifact.getMetadataList() )\n        {\n            if ( metadata instanceof ProjectArtifactMetadata )\n            {\n                org.sonatype.aether.artifact.Artifact pomArtifact = new SubArtifact( mainArtifact, \"\", \"pom\" );\n                pomArtifact = pomArtifact.setFile( ( (ProjectArtifactMetadata) metadata ).getFile() );\n                request.addArtifact( pomArtifact );\n            }\n            else if ( metadata instanceof SnapshotArtifactRepositoryMetadata\n                || metadata instanceof ArtifactRepositoryMetadata )\n            {\n                // eaten, handled by repo system\n            }\n            else\n            {\n                request.addMetadata( new MetadataBridge( metadata ) );\n            }\n        }\n\n        RemoteRepository remoteRepo = RepositoryUtils.toRepo( deploymentRepository );\n        /*\n         * NOTE: This provides backward-compat with maven-deploy-plugin:2.4 which bypasses the repository factory when\n         * using an alternative deployment location.\n         */\n        if ( deploymentRepository instanceof DefaultArtifactRepository\n            && deploymentRepository.getAuthentication() == null )\n        {\n            remoteRepo.setAuthentication( session.getAuthenticationSelector().getAuthentication( remoteRepo ) );\n            remoteRepo.setProxy( session.getProxySelector().getProxy( remoteRepo ) );\n        }\n        request.setRepository( remoteRepo );\n\n        DeployResult result;\n        try\n        {\n            result = repoSystem.deploy( session, request );\n        }\n        catch ( DeploymentException e )\n        {\n            throw new ArtifactDeploymentException( e.getMessage(), e );\n        }\n\n        for ( Object metadata : result.getMetadata() )\n        {\n            if ( metadata.getClass().getName().endsWith( \".internal.VersionsMetadata\" ) )\n            {\n                relatedMetadata.put( versionKey, (MergeableMetadata) metadata );\n            }\n            if ( snapshotKey != null && metadata.getClass().getName().endsWith( \".internal.RemoteSnapshotMetadata\" ) )\n            {\n                relatedMetadata.put( snapshotKey, (MergeableMetadata) metadata );\n            }\n        }\n\n        artifact.setResolvedVersion( result.getArtifacts().iterator().next().getVersion() );\n    }","commit_id":"ed12e0a541096523449996195663d0762fff2e05","url":"https://github.com/apache/maven"},{"original_method":"public void install( File source, Artifact artifact, ArtifactRepository localRepository )\n        throws ArtifactInstallationException\n    {\n        DefaultRepositorySystemSession session =\n            new DefaultRepositorySystemSession( legacySupport.getRepositorySession() );\n        session.setLocalRepositoryManager( LegacyLocalRepositoryManager.wrap( localRepository, repoSystem ) );\n\n        InstallRequest request = new InstallRequest();\n\n        org.sonatype.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact( artifact );\n        mainArtifact = mainArtifact.setFile( source );\n        request.addArtifact( mainArtifact );\n\n        for ( ArtifactMetadata metadata : artifact.getMetadataList() )\n        {\n            if ( metadata instanceof ProjectArtifactMetadata )\n            {\n                org.sonatype.aether.artifact.Artifact pomArtifact = new SubArtifact( mainArtifact, \"\", \"pom\" );\n                pomArtifact = pomArtifact.setFile( ( (ProjectArtifactMetadata) metadata ).getFile() );\n                request.addArtifact( pomArtifact );\n            }\n            else if ( metadata instanceof SnapshotArtifactRepositoryMetadata\n                || metadata instanceof ArtifactRepositoryMetadata )\n            {\n                // eaten, handled by repo system\n            }\n            else\n            {\n                request.addMetadata( new MetadataBridge( metadata ) );\n            }\n        }\n\n        try\n        {\n            repoSystem.install( session, request );\n        }\n        catch ( InstallationException e )\n        {\n            throw new ArtifactInstallationException( e.getMessage(), e );\n        }\n\n        /*\n         * NOTE: Not used by Maven core, only here to provide backward-compat with plugins like the Install Plugin.\n         */\n\n        if ( artifact.isSnapshot() )\n        {\n            Snapshot snapshot = new Snapshot();\n            snapshot.setLocalCopy( true );\n            artifact.addMetadata( new SnapshotArtifactRepositoryMetadata( artifact, snapshot ) );\n        }\n\n        Versioning versioning = new Versioning();\n        versioning.updateTimestamp();\n        versioning.addVersion( artifact.getBaseVersion() );\n        if ( artifact.isRelease() )\n        {\n            versioning.setRelease( artifact.getBaseVersion() );\n        }\n        artifact.addMetadata( new ArtifactRepositoryMetadata( artifact, versioning ) );\n    }","id":71970,"modified_method":"public void install( File source, Artifact artifact, ArtifactRepository localRepository )\n        throws ArtifactInstallationException\n    {\n        RepositorySystemSession session =\n            LegacyLocalRepositoryManager.overlay( localRepository, legacySupport.getRepositorySession(), repoSystem );\n\n        InstallRequest request = new InstallRequest();\n\n        org.sonatype.aether.artifact.Artifact mainArtifact = RepositoryUtils.toArtifact( artifact );\n        mainArtifact = mainArtifact.setFile( source );\n        request.addArtifact( mainArtifact );\n\n        for ( ArtifactMetadata metadata : artifact.getMetadataList() )\n        {\n            if ( metadata instanceof ProjectArtifactMetadata )\n            {\n                org.sonatype.aether.artifact.Artifact pomArtifact = new SubArtifact( mainArtifact, \"\", \"pom\" );\n                pomArtifact = pomArtifact.setFile( ( (ProjectArtifactMetadata) metadata ).getFile() );\n                request.addArtifact( pomArtifact );\n            }\n            else if ( metadata instanceof SnapshotArtifactRepositoryMetadata\n                || metadata instanceof ArtifactRepositoryMetadata )\n            {\n                // eaten, handled by repo system\n            }\n            else\n            {\n                request.addMetadata( new MetadataBridge( metadata ) );\n            }\n        }\n\n        try\n        {\n            repoSystem.install( session, request );\n        }\n        catch ( InstallationException e )\n        {\n            throw new ArtifactInstallationException( e.getMessage(), e );\n        }\n\n        /*\n         * NOTE: Not used by Maven core, only here to provide backward-compat with plugins like the Install Plugin.\n         */\n\n        if ( artifact.isSnapshot() )\n        {\n            Snapshot snapshot = new Snapshot();\n            snapshot.setLocalCopy( true );\n            artifact.addMetadata( new SnapshotArtifactRepositoryMetadata( artifact, snapshot ) );\n        }\n\n        Versioning versioning = new Versioning();\n        versioning.updateTimestamp();\n        versioning.addVersion( artifact.getBaseVersion() );\n        if ( artifact.isRelease() )\n        {\n            versioning.setRelease( artifact.getBaseVersion() );\n        }\n        artifact.addMetadata( new ArtifactRepositoryMetadata( artifact, versioning ) );\n    }","commit_id":"ed12e0a541096523449996195663d0762fff2e05","url":"https://github.com/apache/maven"},{"original_method":"private RepositorySystemSession getSession( ArtifactRepository localRepository )\n    {\n        MavenSession mavenSession = legacySupport.getSession();\n        DefaultRepositorySystemSession session;\n        if ( mavenSession != null )\n        {\n            session = new DefaultRepositorySystemSession( mavenSession.getRepositorySession() );\n        }\n        else\n        {\n            session = new DefaultRepositorySystemSession();\n        }\n        if ( localRepository != null && localRepository.getBasedir() != null )\n        {\n            session.setLocalRepositoryManager( LegacyLocalRepositoryManager.wrap( localRepository, repoSystem ) );\n        }\n        return session;\n    }","id":71971,"modified_method":"private RepositorySystemSession getSession( ArtifactRepository localRepository )\n    {\n        return LegacyLocalRepositoryManager.overlay( localRepository, legacySupport.getRepositorySession(), repoSystem );\n    }","commit_id":"ed12e0a541096523449996195663d0762fff2e05","url":"https://github.com/apache/maven"},{"original_method":"public InternalConfig( ProjectBuildingRequest request, ReactorModelPool modelPool, ReactorModelCache modelCache )\n        {\n            this.request = request;\n            this.modelPool = modelPool;\n            this.modelCache = modelCache;\n            session = request.getRepositorySession();\n            repositories = RepositoryUtils.toRepos( request.getRemoteRepositories() );\n        }","id":71972,"modified_method":"public InternalConfig( ProjectBuildingRequest request, ReactorModelPool modelPool, ReactorModelCache modelCache )\n        {\n            this.request = request;\n            this.modelPool = modelPool;\n            this.modelCache = modelCache;\n            session =\n                LegacyLocalRepositoryManager.overlay( request.getLocalRepository(), request.getRepositorySession(),\n                                                      repoSystem );\n            repositories = RepositoryUtils.toRepos( request.getRemoteRepositories() );\n        }","commit_id":"ed12e0a541096523449996195663d0762fff2e05","url":"https://github.com/apache/maven"},{"original_method":"@Override\n    public PsiJetObjectStub deserialize(StubInputStream dataStream, StubElement parentStub) throws IOException {\n        StringRef name = dataStream.readName();\n        StringRef fqNameStr = dataStream.readName();\n        FqName fqName = new FqName(fqNameStr.toString());\n\n        return new PsiJetObjectStubImpl(JetStubElementTypes.OBJECT_DECLARATION, parentStub, name, fqName);\n    }","id":71973,"modified_method":"@Override\n    public PsiJetObjectStub deserialize(StubInputStream dataStream, StubElement parentStub) throws IOException {\n        StringRef name = dataStream.readName();\n        StringRef fqNameStr = dataStream.readName();\n        FqName fqName = fqNameStr != null ? new FqName(fqNameStr.toString()) : null;\n\n        return new PsiJetObjectStubImpl(JetStubElementTypes.OBJECT_DECLARATION, parentStub, name, fqName);\n    }","commit_id":"72271cbdd4b40f1248c28df4ec726603fabc1b0d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public PsiJetObjectStub createStub(@NotNull JetObjectDeclaration psi, @NotNull StubElement parentStub) {\n        String name = psi.getName();\n        assert name != null;\n\n        FqName fqName = psi.getFqName();\n        assert fqName != null;\n\n        return new PsiJetObjectStubImpl(JetStubElementTypes.OBJECT_DECLARATION, parentStub, name, fqName);\n    }","id":71974,"modified_method":"@Override\n    public PsiJetObjectStub createStub(@NotNull JetObjectDeclaration psi, @NotNull StubElement parentStub) {\n        String name = psi.getName();\n        assert name != null;\n\n        FqName fqName = psi.getFqName();\n        return new PsiJetObjectStubImpl(JetStubElementTypes.OBJECT_DECLARATION, parentStub, name, fqName);\n    }","commit_id":"72271cbdd4b40f1248c28df4ec726603fabc1b0d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void serialize(PsiJetObjectStub stub, StubOutputStream dataStream) throws IOException {\n        dataStream.writeName(stub.getName());\n        dataStream.writeName(stub.getFQName().toString());\n    }","id":71975,"modified_method":"@Override\n    public void serialize(PsiJetObjectStub stub, StubOutputStream dataStream) throws IOException {\n        dataStream.writeName(stub.getName());\n        FqName fqName = stub.getFQName();\n        dataStream.writeName(fqName != null ? fqName.toString() : null);\n    }","commit_id":"72271cbdd4b40f1248c28df4ec726603fabc1b0d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n\n        builder.append(\"PsiJetObjectStubImpl[\");\n        builder.append(\"name=\").append(getName());\n        builder.append(\" fqName=\").append(getFQName().toString());\n        builder.append(\"]\");\n\n        return builder.toString();\n    }","id":71976,"modified_method":"@Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n\n        builder.append(\"PsiJetObjectStubImpl[\");\n        builder.append(\"name=\").append(getName());\n\n        builder.append(\" fqName=\").append(fqName != null ? fqName.toString() : \"null\");\n        builder.append(\"]\");\n\n        return builder.toString();\n    }","commit_id":"72271cbdd4b40f1248c28df4ec726603fabc1b0d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void indexObject(PsiJetObjectStub stub, IndexSink sink) {\n        String name = stub.getName();\n        assert name != null;\n\n        sink.occurrence(JetIndexKeys.SHORT_NAME_KEY, name);\n        sink.occurrence(JetIndexKeys.FQN_KEY, stub.getFQName().toString());\n    }","id":71977,"modified_method":"@Override\n    public void indexObject(PsiJetObjectStub stub, IndexSink sink) {\n        String name = stub.getName();\n        assert name != null;\n\n        sink.occurrence(JetIndexKeys.SHORT_NAME_KEY, name);\n\n        FqName fqName = stub.getFQName();\n        if (fqName != null) {\n            sink.occurrence(JetIndexKeys.FQN_KEY, fqName.toString());\n        }\n    }","commit_id":"72271cbdd4b40f1248c28df4ec726603fabc1b0d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public Type mapType(JetType jetType, @Nullable BothSignatureWriter signatureVisitor, @NotNull MapTypeMode kind) {\n        Type known = null;\n        ClassifierDescriptor classifier = jetType.getConstructor().getDeclarationDescriptor();\n\n        if (mapBuiltinsToJava) {\n            if (classifier instanceof ClassDescriptor) {\n                known = KotlinToJavaTypesMap.getInstance().getJavaAnalog(jetType);\n            }\n        }\n\n        if (known != null) {\n            if (kind == MapTypeMode.VALUE) {\n                return mapKnownAsmType(jetType, known, signatureVisitor);\n            }\n            else if (kind == MapTypeMode.TYPE_PARAMETER) {\n                return mapKnownAsmType(jetType, boxType(known), signatureVisitor);\n            }\n            else if (kind == MapTypeMode.TRAIT_IMPL) {\n                throw new IllegalStateException(\"TRAIT_IMPL is not possible for \" + jetType);\n            }\n            else if (kind == MapTypeMode.IMPL) {\n                //noinspection ConstantConditions\n                if (mapBuiltinsToJava) {\n                    // TODO: enable and fix tests\n                    //throw new IllegalStateException(\"must not map known type to IMPL when not compiling builtins: \" + jetType);\n                }\n                return mapKnownAsmType(jetType, known, signatureVisitor);\n            }\n            else {\n                throw new IllegalStateException(\"unknown kind: \" + kind);\n            }\n        }\n\n        final TypeConstructor constructor = jetType.getConstructor();\n        if (constructor instanceof IntersectionTypeConstructor) {\n            jetType = CommonSupertypes.commonSupertype(new ArrayList<JetType>(constructor.getSupertypes()));\n        }\n        DeclarationDescriptor descriptor = jetType.getConstructor().getDeclarationDescriptor();\n\n        if (descriptor == null) {\n            throw new UnsupportedOperationException(\"no descriptor for type constructor of \" + jetType);\n        }\n\n        if (ErrorUtils.isError(descriptor)) {\n            if (classBuilderMode != ClassBuilderMode.SIGNATURES) {\n                throw new IllegalStateException(\"error types are not allowed when classBuilderMode = \" + classBuilderMode);\n            }\n            Type asmType = Type.getObjectType(\"error/NonExistentClass\");\n            if (signatureVisitor != null) {\n                writeSimpleType(signatureVisitor, asmType, true);\n            }\n            checkValidType(asmType);\n            return asmType;\n        }\n\n        if (descriptor instanceof ClassDescriptor\n            && JetStandardLibraryNames.ARRAY.is((ClassDescriptor) descriptor)\n            && mapBuiltinsToJava) {\n            if (jetType.getArguments().size() != 1) {\n                throw new UnsupportedOperationException(\"arrays must have one type argument\");\n            }\n            JetType memberType = jetType.getArguments().get(0).getType();\n\n            if (signatureVisitor != null) {\n                signatureVisitor.writeArrayType(jetType.isNullable());\n                mapType(memberType, signatureVisitor, MapTypeMode.TYPE_PARAMETER);\n                signatureVisitor.writeArrayEnd();\n            }\n\n            Type r;\n            if (!isGenericsArray(jetType)) {\n                r = Type.getType(\"[\" + boxType(mapType(memberType, kind)).getDescriptor());\n            }\n            else {\n                r = ARRAY_GENERIC_TYPE;\n            }\n            checkValidType(r);\n            return r;\n        }\n\n        if (JetStandardClasses.getAny().equals(descriptor)) {\n            if (signatureVisitor != null) {\n                writeSimpleType(signatureVisitor, TYPE_OBJECT, jetType.isNullable());\n            }\n            checkValidType(TYPE_OBJECT);\n            return TYPE_OBJECT;\n        }\n\n        if (descriptor instanceof ClassDescriptor) {\n            JvmClassName name = getJvmClassName((ClassDescriptor) descriptor);\n            Type asmType = Type.getObjectType(name.getInternalName() + (kind == MapTypeMode.TRAIT_IMPL ? JvmAbi.TRAIT_IMPL_SUFFIX : \"\"));\n            boolean forceReal = KotlinToJavaTypesMap.isForceReal(name);\n\n            writeGenericType(jetType, signatureVisitor, asmType, forceReal);\n\n            checkValidType(asmType);\n            return asmType;\n        }\n\n        if (descriptor instanceof TypeParameterDescriptor) {\n\n            Type type = mapType(((TypeParameterDescriptor) descriptor).getUpperBoundsAsType(), kind);\n            if (signatureVisitor != null) {\n                TypeParameterDescriptor typeParameterDescriptor =\n                        (TypeParameterDescriptor) jetType.getConstructor().getDeclarationDescriptor();\n                assert typeParameterDescriptor != null;\n                signatureVisitor.writeTypeVariable(typeParameterDescriptor.getName(), jetType.isNullable(), type);\n            }\n            checkValidType(type);\n            return type;\n        }\n\n        throw new UnsupportedOperationException(\"Unknown type \" + jetType);\n    }","id":71978,"modified_method":"@NotNull\n    public Type mapType(JetType jetType, @Nullable BothSignatureWriter signatureVisitor, @NotNull MapTypeMode kind) {\n        Type known = null;\n        ClassifierDescriptor classifier = jetType.getConstructor().getDeclarationDescriptor();\n\n        if (mapBuiltinsToJava) {\n            if (classifier instanceof ClassDescriptor) {\n                known = KotlinToJavaTypesMap.getInstance().getJavaAnalog(jetType);\n            }\n        }\n\n        if (known != null) {\n            if (kind == MapTypeMode.VALUE) {\n                return mapKnownAsmType(jetType, known, signatureVisitor);\n            }\n            else if (kind == MapTypeMode.TYPE_PARAMETER) {\n                return mapKnownAsmType(jetType, boxType(known), signatureVisitor);\n            }\n            else if (kind == MapTypeMode.TRAIT_IMPL) {\n                throw new IllegalStateException(\"TRAIT_IMPL is not possible for \" + jetType);\n            }\n            else if (kind == MapTypeMode.IMPL) {\n                //noinspection ConstantConditions\n                if (mapBuiltinsToJava) {\n                    // TODO: enable and fix tests\n                    //throw new IllegalStateException(\"must not map known type to IMPL when not compiling builtins: \" + jetType);\n                }\n                return mapKnownAsmType(jetType, known, signatureVisitor);\n            }\n            else {\n                throw new IllegalStateException(\"unknown kind: \" + kind);\n            }\n        }\n\n        final TypeConstructor constructor = jetType.getConstructor();\n        if (constructor instanceof IntersectionTypeConstructor) {\n            jetType = CommonSupertypes.commonSupertype(new ArrayList<JetType>(constructor.getSupertypes()));\n        }\n        DeclarationDescriptor descriptor = jetType.getConstructor().getDeclarationDescriptor();\n\n        if (descriptor == null) {\n            throw new UnsupportedOperationException(\"no descriptor for type constructor of \" + jetType);\n        }\n\n        if (ErrorUtils.isError(descriptor)) {\n            if (classBuilderMode != ClassBuilderMode.SIGNATURES) {\n                throw new IllegalStateException(\"error types are not allowed when classBuilderMode = \" + classBuilderMode);\n            }\n            Type asmType = Type.getObjectType(\"error/NonExistentClass\");\n            if (signatureVisitor != null) {\n                writeSimpleType(signatureVisitor, asmType, true);\n            }\n            checkValidType(asmType);\n            return asmType;\n        }\n\n        if (descriptor instanceof ClassDescriptor\n            && JetStandardLibraryNames.ARRAY.is((ClassDescriptor) descriptor)\n            && mapBuiltinsToJava) {\n            if (jetType.getArguments().size() != 1) {\n                throw new UnsupportedOperationException(\"arrays must have one type argument\");\n            }\n            JetType memberType = jetType.getArguments().get(0).getType();\n\n            if (signatureVisitor != null) {\n                signatureVisitor.writeArrayType(jetType.isNullable());\n                mapType(memberType, signatureVisitor, MapTypeMode.TYPE_PARAMETER);\n                signatureVisitor.writeArrayEnd();\n            }\n\n            Type r;\n            if (!isGenericsArray(jetType)) {\n                r = Type.getType(\"[\" + boxType(mapType(memberType, kind)).getDescriptor());\n            }\n            else {\n                r = ARRAY_GENERIC_TYPE;\n            }\n            checkValidType(r);\n            return r;\n        }\n\n        if (descriptor instanceof ClassDescriptor) {\n            JvmClassName name = getJvmClassName((ClassDescriptor) descriptor);\n            Type asmType = Type.getObjectType(name.getInternalName() + (kind == MapTypeMode.TRAIT_IMPL ? JvmAbi.TRAIT_IMPL_SUFFIX : \"\"));\n            boolean forceReal = KotlinToJavaTypesMap.getInstance().isForceReal(name);\n\n            writeGenericType(jetType, signatureVisitor, asmType, forceReal);\n\n            checkValidType(asmType);\n            return asmType;\n        }\n\n        if (descriptor instanceof TypeParameterDescriptor) {\n\n            Type type = mapType(((TypeParameterDescriptor) descriptor).getUpperBoundsAsType(), kind);\n            if (signatureVisitor != null) {\n                TypeParameterDescriptor typeParameterDescriptor =\n                        (TypeParameterDescriptor) jetType.getConstructor().getDeclarationDescriptor();\n                assert typeParameterDescriptor != null;\n                signatureVisitor.writeTypeVariable(typeParameterDescriptor.getName(), jetType.isNullable(), type);\n            }\n            checkValidType(type);\n            return type;\n        }\n\n        throw new UnsupportedOperationException(\"Unknown type \" + jetType);\n    }","commit_id":"65ea9dddea74a69b6fc02e53b0977b696c266f17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static boolean isForceReal(JvmClassName className) {\n        return JvmPrimitiveType.getByWrapperClass(className) != null\n               || className.getFqName().getFqName().equals(\"java.lang.String\")\n               || className.getFqName().getFqName().equals(\"java.lang.CharSequence\")\n               || className.getFqName().getFqName().equals(\"java.lang.Object\")\n               || className.getFqName().getFqName().equals(\"java.lang.Number\")\n               || className.getFqName().getFqName().equals(\"java.lang.Enum\")\n               || className.getFqName().getFqName().equals(\"java.lang.Comparable\");\n    }","id":71979,"modified_method":"public boolean isForceReal(JvmClassName className) {\n        return JvmPrimitiveType.getByWrapperClass(className) != null\n               || asmTypeNames.contains(className.getFqName().getFqName());\n    }","commit_id":"65ea9dddea74a69b6fc02e53b0977b696c266f17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void register(@NotNull ClassName className, @NotNull Type nonNullType, @NotNull Type nullableType) {\n        asmTypes.put(new SpecialTypeKey(className.getFqName().toUnsafe(), true), nullableType);\n        asmTypes.put(new SpecialTypeKey(className.getFqName().toUnsafe(), false), nonNullType);\n    }","id":71980,"modified_method":"private void registerNullable(@NotNull ClassName className, @NotNull Type nullableType) {\n        asmNullableTypes.put(className.getFqName().toUnsafe(), nullableType);\n    }","commit_id":"65ea9dddea74a69b6fc02e53b0977b696c266f17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void register(@NotNull ClassName className, @NotNull Type type) {\n        register(className, type, type);\n    }","id":71981,"modified_method":"private void register(@NotNull ClassName className, @NotNull Type type) {\n        asmTypeNames.add(type.getClassName());\n        asmTypes.put(className.getFqName().toUnsafe(), type);\n    }","commit_id":"65ea9dddea74a69b6fc02e53b0977b696c266f17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void init() {\n        register(NOTHING, TYPE_NOTHING);\n\n        for (JvmPrimitiveType jvmPrimitiveType : JvmPrimitiveType.values()) {\n            PrimitiveType primitiveType = jvmPrimitiveType.getPrimitiveType();\n            register(primitiveType.getClassName(), jvmPrimitiveType.getAsmType(), jvmPrimitiveType.getWrapper().getAsmType());\n        }\n\n        register(NUMBER, JL_NUMBER_TYPE);\n        register(STRING, JL_STRING_TYPE);\n        register(CHAR_SEQUENCE, JL_CHAR_SEQUENCE_TYPE);\n        register(THROWABLE, TYPE_THROWABLE);\n        register(COMPARABLE, JL_COMPARABLE_TYPE);\n        register(ENUM, JL_ENUM_TYPE);\n        register(ITERABLE, JL_ITERABLE_TYPE);\n        register(ITERATOR, JL_ITERATOR_TYPE);\n        register(MUTABLE_ITERABLE, JL_ITERABLE_TYPE);\n        register(MUTABLE_ITERATOR, JL_ITERATOR_TYPE);\n\n        for (JvmPrimitiveType jvmPrimitiveType : JvmPrimitiveType.values()) {\n            PrimitiveType primitiveType = jvmPrimitiveType.getPrimitiveType();\n            register(primitiveType.getArrayClassName(), jvmPrimitiveType.getAsmArrayType());\n        }\n    }","id":71982,"modified_method":"public void init() {\n        register(NOTHING, TYPE_NOTHING);\n\n        for (JvmPrimitiveType jvmPrimitiveType : JvmPrimitiveType.values()) {\n            ClassName className = jvmPrimitiveType.getPrimitiveType().getClassName();\n\n            register(className, jvmPrimitiveType.getAsmType());\n            registerNullable(className, jvmPrimitiveType.getWrapper().getAsmType());\n        }\n\n        register(ANY, TYPE_OBJECT);\n        register(NUMBER, JL_NUMBER_TYPE);\n        register(STRING, JL_STRING_TYPE);\n        register(CHAR_SEQUENCE, JL_CHAR_SEQUENCE_TYPE);\n        register(THROWABLE, TYPE_THROWABLE);\n        register(COMPARABLE, JL_COMPARABLE_TYPE);\n        register(ENUM, JL_ENUM_TYPE);\n        register(ITERABLE, JL_ITERABLE_TYPE);\n        register(ITERATOR, JL_ITERATOR_TYPE);\n        register(MUTABLE_ITERABLE, JL_ITERABLE_TYPE);\n        register(MUTABLE_ITERATOR, JL_ITERATOR_TYPE);\n\n        for (JvmPrimitiveType jvmPrimitiveType : JvmPrimitiveType.values()) {\n            PrimitiveType primitiveType = jvmPrimitiveType.getPrimitiveType();\n            register(primitiveType.getArrayClassName(), jvmPrimitiveType.getAsmArrayType());\n        }\n    }","commit_id":"65ea9dddea74a69b6fc02e53b0977b696c266f17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    public Type getJavaAnalog(@NotNull JetType jetType) {\n        ClassifierDescriptor classifier = jetType.getConstructor().getDeclarationDescriptor();\n        assert classifier != null;\n        return asmTypes.get(new SpecialTypeKey(DescriptorUtils.getFQName(classifier), jetType.isNullable()));\n    }","id":71983,"modified_method":"@Nullable\n    public Type getJavaAnalog(@NotNull JetType jetType) {\n        ClassifierDescriptor classifier = jetType.getConstructor().getDeclarationDescriptor();\n        assert classifier != null;\n        FqNameUnsafe className = DescriptorUtils.getFQName(classifier);\n        if (jetType.isNullable()) {\n            Type nullableType = asmNullableTypes.get(className);\n            if (nullableType != null) {\n                return nullableType;\n            }\n        }\n        return asmTypes.get(className);\n    }","commit_id":"65ea9dddea74a69b6fc02e53b0977b696c266f17","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static void registerStrutsDomPresentation() {\n    // <struts>\n    ElementPresentationManager.registerIcon(StrutsRoot.class, StrutsIcons.STRUTS_CONFIG_FILE_ICON);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        return o instanceof StrutsRoot ? ((StrutsRoot) o).getRoot().getFile().getName() : null;\n      }\n    });\n\n    // <exception-mapping>\n    ElementPresentationManager.registerIcon(ExceptionMapping.class, StrutsIcons.EXCEPTION_MAPPING);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (o instanceof ExceptionMapping) {\n          final PsiClass exceptionClass = ((ExceptionMapping) o).getExceptionClass().getValue();\n          if (exceptionClass != null) {\n            return exceptionClass.getName();\n          }\n          return ((ExceptionMapping) o).getName().getStringValue();\n        }\n        return null;\n      }\n    });\n\n    // global <exception-mapping>\n    ElementPresentationManager.registerIcon(GlobalExceptionMapping.class, StrutsIcons.GLOBAL_EXCEPTION_MAPPING);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (o instanceof GlobalExceptionMapping) {\n          final PsiClass exceptionClass = ((GlobalExceptionMapping) o).getExceptionClass().getValue();\n          if (exceptionClass != null) {\n            return exceptionClass.getName();\n          }\n          return ((GlobalExceptionMapping) o).getName().getStringValue();\n        }\n        return null;\n      }\n    });\n\n    // <interceptor-ref>\n    ElementPresentationManager.registerIconProvider(new NullableFunction<Object, Icon>() {\n      public Icon fun(final Object o) {\n        if (o instanceof InterceptorRef) {\n          final InterceptorOrStackBase interceptorOrStackBase = ((InterceptorRef) o).getName().getValue();\n          if (interceptorOrStackBase instanceof Interceptor) {\n            return StrutsIcons.INTERCEPTOR;\n          } else if (interceptorOrStackBase instanceof InterceptorStack) {\n            return StrutsIcons.INTERCEPTOR_STACK;\n          }\n        }\n        return null;\n      }\n    });\n\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        return o instanceof InterceptorRef ? ((InterceptorRef) o).getName().getStringValue() : null;\n      }\n    });\n\n    ElementPresentationManager.registerIcon(DefaultInterceptorRef.class, StrutsIcons.DEFAULT_INTERCEPTOR_REF);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        return o instanceof DefaultInterceptorRef ? ((DefaultInterceptorRef) o).getName().getStringValue() : null;\n      }\n    });\n\n    // <include>\n    ElementPresentationManager.registerIcon(Include.class, StrutsIcons.INCLUDE);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        return o instanceof Include ? ((Include) o).getFile().getStringValue() : null;\n      }\n    });\n\n    // <result>\n    ElementPresentationManager.registerIcon(Result.class, StrutsIcons.RESULT);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (o instanceof Result) {\n          final String resultName = ((Result) o).getName().getStringValue();\n          return resultName != null ? resultName : \"success\";\n        }\n        return null;\n      }\n    });\n\n    // <global-result>\n    ElementPresentationManager.registerIcon(GlobalResult.class, StrutsIcons.GLOBAL_RESULT);\n    TypeNameManager.registerTypeName(GlobalResult.class, \"global result\");\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (o instanceof GlobalResult) {\n          final String globalResultName = ((GlobalResult) o).getName().getStringValue();\n          return globalResultName != null ? globalResultName : \"success\";\n        }\n        return null;\n      }\n    });\n\n    // <default-action-ref>\n    ElementPresentationManager.registerIcon(DefaultActionRef.class, StrutsIcons.DEFAULT_ACTION_REF);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (o instanceof DefaultActionRef) {\n          return ((DefaultActionRef) o).getName().getStringValue();\n        }\n        return null;\n      }\n    });\n\n    // <default-class-ref>\n    ElementPresentationManager.registerIcon(DefaultClassRef.class, StrutsIcons.DEFAULT_CLASS_REF);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (o instanceof DefaultClassRef) {\n          return ((DefaultClassRef) o).getDefaultClass().getStringValue();\n        }\n        return null;\n      }\n    });\n\n    ElementPresentationManager.registerIcon(Action.class, StrutsIcons.ACTION);\n    ElementPresentationManager.registerIcon(Bean.class, StrutsIcons.BEAN);\n    ElementPresentationManager.registerIcon(Constant.class, Icons.PARAMETER_ICON);\n    ElementPresentationManager.registerIcon(Interceptor.class, StrutsIcons.INTERCEPTOR);\n    ElementPresentationManager.registerIcon(InterceptorStack.class, StrutsIcons.INTERCEPTOR_STACK);\n    ElementPresentationManager.registerIcon(Param.class, StrutsIcons.PARAM);\n    ElementPresentationManager.registerIcon(ResultType.class, StrutsIcons.RESULT_TYPE);\n    ElementPresentationManager.registerIcon(StrutsPackage.class, StrutsIcons.PACKAGE);\n  }","id":71984,"modified_method":"private static void registerStrutsDomPresentation() {\n    // <struts>\n    ElementPresentationManager.registerIcon(StrutsRoot.class, StrutsIcons.STRUTS_CONFIG_FILE_ICON);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<StrutsRoot>(StrutsRoot.class) {\n      protected String getDisplayName(final StrutsRoot strutsRoot) {\n        return strutsRoot.getRoot().getFile().getName();\n      }\n    });\n\n    // <exception-mapping>\n    ElementPresentationManager.registerIcon(ExceptionMapping.class, StrutsIcons.EXCEPTION_MAPPING);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<ExceptionMapping>(ExceptionMapping.class) {\n      protected String getDisplayName(final ExceptionMapping exceptionMapping) {\n        final PsiClass exceptionClass = exceptionMapping.getExceptionClass().getValue();\n        if (exceptionClass != null) {\n          return exceptionClass.getName();\n        }\n        return exceptionMapping.getName().getStringValue();\n      }\n    });\n\n    // global <exception-mapping>\n    ElementPresentationManager.registerIcon(GlobalExceptionMapping.class, StrutsIcons.GLOBAL_EXCEPTION_MAPPING);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<GlobalExceptionMapping>(GlobalExceptionMapping.class) {\n      protected String getDisplayName(final GlobalExceptionMapping globalExceptionMapping) {\n        final PsiClass exceptionClass = globalExceptionMapping.getExceptionClass().getValue();\n        if (exceptionClass != null) {\n          return exceptionClass.getName();\n        }\n        return globalExceptionMapping.getName().getStringValue();\n      }\n    });\n\n    // <interceptor-ref>\n    ElementPresentationManager.registerIconProvider(new NullableFunction<Object, Icon>() {\n      public Icon fun(final Object o) {\n        if (o instanceof InterceptorRef) {\n          final InterceptorOrStackBase interceptorOrStackBase = ((InterceptorRef) o).getName().getValue();\n          if (interceptorOrStackBase instanceof Interceptor) {\n            return StrutsIcons.INTERCEPTOR;\n          } else if (interceptorOrStackBase instanceof InterceptorStack) {\n            return StrutsIcons.INTERCEPTOR_STACK;\n          }\n        }\n        return null;\n      }\n    });\n\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<InterceptorRef>(InterceptorRef.class) {\n      protected String getDisplayName(final InterceptorRef interceptorRef) {\n        return interceptorRef.getName().getStringValue();\n      }\n    });\n\n    ElementPresentationManager.registerIcon(DefaultInterceptorRef.class, StrutsIcons.DEFAULT_INTERCEPTOR_REF);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<DefaultInterceptorRef>(DefaultInterceptorRef.class) {\n      protected String getDisplayName(final DefaultInterceptorRef defaultInterceptorRef) {\n        return defaultInterceptorRef.getName().getStringValue();\n      }\n    });\n\n    // <include>\n    ElementPresentationManager.registerIcon(Include.class, StrutsIcons.INCLUDE);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<Include>(Include.class) {\n      protected String getDisplayName(final Include include) {\n        return include.getFile().getStringValue();\n      }\n    });\n\n    // <result>\n    ElementPresentationManager.registerIcon(Result.class, StrutsIcons.RESULT);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<Result>(Result.class) {\n      protected String getDisplayName(final Result result) {\n        final String resultName = result.getName().getStringValue();\n        return resultName != null ? resultName : \"success\";\n      }\n    });\n\n    // <global-result>\n    ElementPresentationManager.registerIcon(GlobalResult.class, StrutsIcons.GLOBAL_RESULT);\n    TypeNameManager.registerTypeName(GlobalResult.class, \"global result\");\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<GlobalResult>(GlobalResult.class) {\n      protected String getDisplayName(final GlobalResult globalResult) {\n        final String globalResultName = globalResult.getName().getStringValue();\n        return globalResultName != null ? globalResultName : \"success\";\n      }\n    });\n\n    // <default-action-ref>\n    ElementPresentationManager.registerIcon(DefaultActionRef.class, StrutsIcons.DEFAULT_ACTION_REF);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<DefaultActionRef>(DefaultActionRef.class) {\n      protected String getDisplayName(final DefaultActionRef defaultActionRef) {\n        return defaultActionRef.getName().getStringValue();\n      }\n    });\n\n    // <default-class-ref>\n    ElementPresentationManager.registerIcon(DefaultClassRef.class, StrutsIcons.DEFAULT_CLASS_REF);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<DefaultClassRef>(DefaultClassRef.class) {\n      protected String getDisplayName(final DefaultClassRef defaultClassRef) {\n        return defaultClassRef.getDefaultClass().getStringValue();\n      }\n    });\n\n    ElementPresentationManager.registerIcon(Action.class, StrutsIcons.ACTION);\n    ElementPresentationManager.registerIcon(Bean.class, StrutsIcons.BEAN);\n    ElementPresentationManager.registerIcon(Constant.class, Icons.PARAMETER_ICON);\n    ElementPresentationManager.registerIcon(Interceptor.class, StrutsIcons.INTERCEPTOR);\n    ElementPresentationManager.registerIcon(InterceptorStack.class, StrutsIcons.INTERCEPTOR_STACK);\n    ElementPresentationManager.registerIcon(Param.class, StrutsIcons.PARAM);\n    ElementPresentationManager.registerIcon(ResultType.class, StrutsIcons.RESULT_TYPE);\n    ElementPresentationManager.registerIcon(StrutsPackage.class, StrutsIcons.PACKAGE);\n  }","commit_id":"4d505e8a4e1f26efa83b7433de3e24e128633b62","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private static void registerValidationDomPresentation() {\n    ElementPresentationManager.registerIcon(ValidatorConfig.class, StrutsIcons.VALIDATOR);\n\n    ElementPresentationManager.registerIcon(Validators.class, StrutsIcons.VALIDATION_CONFIG_FILE_ICON);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        return o instanceof Validators ? ((Validators) o).getRoot().getFile().getName() : null;\n      }\n    });\n\n    // <field>\n    ElementPresentationManager.registerIcon(Field.class, Icons.FIELD_ICON);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        return o instanceof Field ? ((Field) o).getName().getStringValue() : null;\n      }\n    });\n\n    // <field-validator>\n    ElementPresentationManager.registerIcon(FieldValidator.class, StrutsIcons.VALIDATOR);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (!(o instanceof FieldValidator)) {\n          return null;\n        }\n        final ValidatorConfig validatorConfig = ((FieldValidator) o).getType().getValue();\n        return validatorConfig != null ? validatorConfig.getName().getStringValue() : null;\n      }\n    });\n\n    // <message>\n    ElementPresentationManager.registerIcon(Message.class, StrutsIcons.MESSAGE);\n    ElementPresentationManager.registerNameProvider(new NullableFunction<Object, String>() {\n      public String fun(final Object o) {\n        if (!(o instanceof Message)) {\n          return null;\n        }\n\n        final Message message = (Message) o;\n        final String key = message.getKey().getStringValue();\n        return !StringUtil.isEmpty(key) ? key : message.getValue();\n      }\n    });\n  }","id":71985,"modified_method":"private static void registerValidationDomPresentation() {\n    ElementPresentationManager.registerIcon(ValidatorConfig.class, StrutsIcons.VALIDATOR);\n\n    ElementPresentationManager.registerIcon(Validators.class, StrutsIcons.VALIDATION_CONFIG_FILE_ICON);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<Validators>(Validators.class) {\n      protected String getDisplayName(final Validators validators) {\n        return validators.getRoot().getFile().getName();\n      }\n    });\n\n    // <field>\n    ElementPresentationManager.registerIcon(Field.class, Icons.FIELD_ICON);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<Field>(Field.class) {\n      protected String getDisplayName(final Field field) {\n        return field.getName().getStringValue();\n      }\n    });\n\n    // <field-validator>\n    ElementPresentationManager.registerIcon(FieldValidator.class, StrutsIcons.VALIDATOR);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<FieldValidator>(FieldValidator.class) {\n      protected String getDisplayName(final FieldValidator fieldValidator) {\n        final ValidatorConfig validatorConfig = fieldValidator.getType().getValue();\n        return validatorConfig != null ? validatorConfig.getName().getStringValue() : null;\n      }\n    });\n\n    // <message>\n    ElementPresentationManager.registerIcon(Message.class, StrutsIcons.MESSAGE);\n    ElementPresentationManager.registerNameProvider(new TypedNameProvider<Message>(Message.class) {\n      protected String getDisplayName(final Message message) {\n        final String key = message.getKey().getStringValue();\n        return StringUtil.isNotEmpty(key) ? key : message.getValue();\n      }\n    });\n  }","commit_id":"4d505e8a4e1f26efa83b7433de3e24e128633b62","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public void setPasswordEncryptors(\n\t\tList<PasswordEncryptor> passwordEncryptors) {\n\n\t\tfor (PasswordEncryptor passwordEncryptor : passwordEncryptors) {\n\t\t\tString[] supportedAlgorithmTypes =\n\t\t\t\tpasswordEncryptor.getSupportedAlgorithmTypes();\n\n\t\t\tfor (String supportedAlgorithmType : supportedAlgorithmTypes) {\n\t\t\t\t_passwordEncryptors.put(\n\t\t\t\t\tsupportedAlgorithmType, passwordEncryptor);\n\t\t\t}\n\t\t}\n\t}","id":71986,"modified_method":"public void setPasswordEncryptors(\n\t\tList<PasswordEncryptor> passwordEncryptors) {\n\n\t\tfor (PasswordEncryptor passwordEncryptor : passwordEncryptors) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Registering \" + passwordEncryptor);\n\t\t\t}\n\n\t\t\tString[] supportedAlgorithmTypes =\n\t\t\t\tpasswordEncryptor.getSupportedAlgorithmTypes();\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Registering \" + StringUtil.merge(supportedAlgorithmTypes) +\n\t\t\t\t\t\t\" for \" + passwordEncryptor.getClass().getName());\n\t\t\t}\n\n\t\t\tfor (String supportedAlgorithmType : supportedAlgorithmTypes) {\n\t\t\t\t_passwordEncryptors.put(\n\t\t\t\t\tsupportedAlgorithmType, passwordEncryptor);\n\t\t\t}\n\n\t\t}\n\t}","commit_id":"d12c61e98102b5073d6befbd9e1761fed9ee9545","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String doEncrypt(\n\t\t\tString algorithm, String clearTextPassword,\n\t\t\tString currentEncryptedPassword)\n\t\tthrows PwdEncryptorException {\n\n\t\tif (Validator.isNull(algorithm)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Must specify an encryption algorithm.\");\n\t\t}\n\n\t\tPasswordEncryptor passwordEncryptor = null;\n\n\t\tif (algorithm.startsWith(PasswordEncryptorUtil.TYPE_BCRYPT)) {\n\t\t\tpasswordEncryptor = _passwordEncryptors.get(\n\t\t\t\tPasswordEncryptorUtil.TYPE_BCRYPT);\n\t\t}\n\t\telse if (algorithm.startsWith(PasswordEncryptorUtil.TYPE_PBKDF2)) {\n\t\t\tpasswordEncryptor = _passwordEncryptors.get(\n\t\t\t\tPasswordEncryptorUtil.TYPE_PBKDF2);\n\t\t}\n\t\telse {\n\t\t\tpasswordEncryptor = _passwordEncryptors.get(algorithm);\n\t\t}\n\n\t\tif (passwordEncryptor == null) {\n\t\t\tpasswordEncryptor = _defaultPasswordEncryptor;\n\t\t}\n\n\t\treturn passwordEncryptor.encrypt(\n\t\t\talgorithm, clearTextPassword, currentEncryptedPassword);\n\t}","id":71987,"modified_method":"@Override\n\tprotected String doEncrypt(\n\t\t\tString algorithm, String clearTextPassword,\n\t\t\tString currentEncryptedPassword)\n\t\tthrows PwdEncryptorException {\n\n\t\tif (Validator.isNull(algorithm)) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\"Must specify an encryption algorithm.\");\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\"Searching passwordEncryptor for \" + algorithm);\n\t\t}\n\n\t\tPasswordEncryptor passwordEncryptor = null;\n\n\t\tif (algorithm.startsWith(PasswordEncryptorUtil.TYPE_BCRYPT)) {\n\t\t\tpasswordEncryptor = _passwordEncryptors.get(\n\t\t\t\tPasswordEncryptorUtil.TYPE_BCRYPT);\n\t\t}\n\t\telse if (algorithm.startsWith(PasswordEncryptorUtil.TYPE_PBKDF2)) {\n\t\t\tpasswordEncryptor = _passwordEncryptors.get(\n\t\t\t\tPasswordEncryptorUtil.TYPE_PBKDF2);\n\t\t}\n\t\telse {\n\t\t\tpasswordEncryptor = _passwordEncryptors.get(algorithm);\n\t\t}\n\n\t\tif (passwordEncryptor == null) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"No passwordEncryptor found for \" + algorithm +\n\t\t\t\t\t\t\", using default\");\n\t\t\t}\n\n\t\t\tpasswordEncryptor = _defaultPasswordEncryptor;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Found \" + passwordEncryptor.getClass().getName() +\n\t\t\t\t\t\" to encrypt password using \" + algorithm);\n\t\t}\n\n\t\treturn passwordEncryptor.encrypt(\n\t\t\talgorithm, clearTextPassword, currentEncryptedPassword);\n\t}","commit_id":"d12c61e98102b5073d6befbd9e1761fed9ee9545","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected String doEncrypt(\n\t\t\tString algorithm, String clearTextPassword,\n\t\t\tString currentEncryptedPassword)\n\t\tthrows PwdEncryptorException {\n\n\t\tif (Validator.isNull(\n\t\t\t\tPropsValues.PASSWORDS_ENCRYPTION_ALGORITHM_LEGACY)) {\n\n\t\t\treturn _parentPasswordEncryptor.encrypt(\n\t\t\t\talgorithm, clearTextPassword, currentEncryptedPassword);\n\t\t}\n\n\t\tboolean prependAlgorithm = true;\n\n\t\tif (Validator.isNotNull(currentEncryptedPassword) &&\n\t\t\t(currentEncryptedPassword.charAt(0) != CharPool.OPEN_CURLY_BRACE)) {\n\n\t\t\talgorithm = PropsValues.PASSWORDS_ENCRYPTION_ALGORITHM_LEGACY;\n\n\t\t\tprependAlgorithm = false;\n\t\t}\n\t\telse if (Validator.isNotNull(currentEncryptedPassword) &&\n\t\t\t(currentEncryptedPassword.charAt(0) == CharPool.OPEN_CURLY_BRACE)) {\n\n\t\t\tint endPos = currentEncryptedPassword.indexOf(\n\t\t\t\tCharPool.CLOSE_CURLY_BRACE);\n\n\t\t\tif (endPos > 0) {\n\t\t\t\talgorithm = currentEncryptedPassword.substring(1, endPos);\n\n\t\t\t\tcurrentEncryptedPassword = currentEncryptedPassword.substring(\n\t\t\t\t\tendPos + 1);\n\t\t\t}\n\t\t}\n\n\t\tString encryptedPassword = _parentPasswordEncryptor.encrypt(\n\t\t\talgorithm, clearTextPassword, currentEncryptedPassword);\n\n\t\tif (!prependAlgorithm) {\n\t\t\treturn encryptedPassword;\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder(4);\n\n\t\tresult.append(StringPool.OPEN_CURLY_BRACE);\n\n\t\tresult.append(getAlgorithmName(algorithm));\n\n\t\tresult.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\tresult.append(encryptedPassword);\n\n\t\treturn result.toString();\n\t}","id":71988,"modified_method":"@Override\n\tprotected String doEncrypt(\n\t\t\tString algorithm, String clearTextPassword,\n\t\t\tString currentEncryptedPassword)\n\t\tthrows PwdEncryptorException {\n\n\t\tif (Validator.isNull(\n\t\t\t\tPropsValues.PASSWORDS_ENCRYPTION_ALGORITHM_LEGACY)) {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Skipping passwords upgrade scheme, \" +\n\t\t\t\t\t\tPropsKeys.PASSWORDS_ENCRYPTION_ALGORITHM_LEGACY +\n\t\t\t\t\t\t\t\" is null.\");\n\t\t\t}\n\n\t\t\treturn _parentPasswordEncryptor.encrypt(\n\t\t\t\talgorithm, clearTextPassword, currentEncryptedPassword);\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tboolean isCEPNull = Validator.isNull(currentEncryptedPassword);\n\n\t\t\t_log.debug(\n\t\t\t\t\"Using legacy detection scheme for algorithm \" + algorithm +\n\t\t\t\t\t\" with current password \" +\n\t\t\t\t\t\t(isCEPNull? \"empty\" : \"provided\"));\n\t\t}\n\n\t\tboolean prependAlgorithm = true;\n\n\t\tif (Validator.isNotNull(currentEncryptedPassword) &&\n\t\t\t(currentEncryptedPassword.charAt(0) != CharPool.OPEN_CURLY_BRACE)) {\n\n\t\t\talgorithm = PropsValues.PASSWORDS_ENCRYPTION_ALGORITHM_LEGACY;\n\n\t\t\tprependAlgorithm = false;\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\"Using legacy algorithm \" + algorithm);\n\t\t\t}\n\t\t}\n\t\telse if (Validator.isNotNull(currentEncryptedPassword) &&\n\t\t\t(currentEncryptedPassword.charAt(0) == CharPool.OPEN_CURLY_BRACE)) {\n\n\t\t\tint endPos = currentEncryptedPassword.indexOf(\n\t\t\t\tCharPool.CLOSE_CURLY_BRACE);\n\n\t\t\tif (endPos > 0) {\n\t\t\t\talgorithm = currentEncryptedPassword.substring(1, endPos);\n\n\t\t\t\tcurrentEncryptedPassword = currentEncryptedPassword.substring(\n\t\t\t\t\tendPos + 1);\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Upgraded password, using new algorithm \" + algorithm);\n\t\t\t}\n\t\t}\n\n\t\tString encryptedPassword = _parentPasswordEncryptor.encrypt(\n\t\t\talgorithm, clearTextPassword, currentEncryptedPassword);\n\n\t\tif (!prependAlgorithm) {\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Generated password without algorithm prefix using \" +\n\t\t\t\t\t\talgorithm);\n\t\t\t}\n\n\t\t\treturn encryptedPassword;\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\t_log.debug(\n\t\t\t\t\"Generated password with algorithm prefix using \" + algorithm);\n\t\t}\n\n\t\tStringBuilder result = new StringBuilder(4);\n\n\t\tresult.append(StringPool.OPEN_CURLY_BRACE);\n\n\t\tresult.append(getAlgorithmName(algorithm));\n\n\t\tresult.append(StringPool.CLOSE_CURLY_BRACE);\n\n\t\tresult.append(encryptedPassword);\n\n\t\treturn result.toString();\n\t}","commit_id":"d12c61e98102b5073d6befbd9e1761fed9ee9545","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static String encrypt(\n\t\t\tString clearTextPassword, String currentEncryptedPassword)\n\t\tthrows PwdEncryptorException {\n\n\t\treturn encrypt(\n\t\t\tPASSWORDS_ENCRYPTION_ALGORITHM, clearTextPassword,\n\t\t\tcurrentEncryptedPassword);\n\t}","id":71989,"modified_method":"public static String encrypt(\n\t\t\tString clearTextPassword, String currentEncryptedPassword)\n\t\tthrows PwdEncryptorException {\n\n\t\tlong clock = 0;\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tclock = System.currentTimeMillis();\n\t\t}\n\n\t\tString encryptedPassword = encrypt(\n\t\t\tPASSWORDS_ENCRYPTION_ALGORITHM, clearTextPassword,\n\t\t\tcurrentEncryptedPassword);\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tclock = System.currentTimeMillis() - clock;\n\t\t\t_log.debug(\"Password encrypted in \" + clock + \"ms.\");\n\t\t}\n\n\t\treturn encryptedPassword;\n\t}","commit_id":"d12c61e98102b5073d6befbd9e1761fed9ee9545","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static RecordScannable getRecordScannable(Configuration conf) throws IOException {\n    RecordScannable recordScannable = instantiate(conf);\n\n    if (recordScannable instanceof TransactionAware) {\n      Transaction tx = ConfigurationUtil.get(conf, Constants.Explore.TX_QUERY_KEY, TxnCodec.INSTANCE);\n        ((TransactionAware) recordScannable).startTx(tx);\n    }\n\n    return recordScannable;\n  }","id":71990,"modified_method":"/**\n   * Returns a RecordScannable. The returned object will have to be closed by the caller.\n   *\n   * @param conf Configuration that contains RecordScannable name to load, Reactor and HBase configuration.\n   * @return RecordScannable.\n   * @throws IOException\n   */\n  public static RecordScannable getRecordScannable(Configuration conf) throws IOException {\n    RecordScannable recordScannable = instantiate(conf);\n\n    if (recordScannable instanceof TransactionAware) {\n      Transaction tx = ConfigurationUtil.get(conf, Constants.Explore.TX_QUERY_KEY, TxnCodec.INSTANCE);\n        ((TransactionAware) recordScannable).startTx(tx);\n    }\n\n    return recordScannable;\n  }","commit_id":"4435daf1f72ba06f2439fdc79a6108ea40bf82e8","url":"https://github.com/caskdata/cdap"},{"original_method":"public static Type getRecordScannableType(Configuration conf) throws IOException {\n    return instantiate(conf).getRecordType();\n  }","id":71991,"modified_method":"/**\n   * Returns record type of the RecordScannable.\n   *\n   * @param conf Configuration that contains RecordScannable name to load, Reactor and HBase configuration.\n   * @return Record type of RecordScannable.\n   * @throws IOException\n   */\n  public static Type getRecordScannableType(Configuration conf) throws IOException {\n    RecordScannable<?> recordScannable = instantiate(conf);\n    Type type = recordScannable.getRecordType();\n    recordScannable.close();\n    return type;\n  }","commit_id":"4435daf1f72ba06f2439fdc79a6108ea40bf82e8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public InputSplit[] getSplits(JobConf jobConf, int numSplits) throws IOException {\n\n    RecordScannable recordScannable = DatasetAccessor.getRecordScannable(jobConf);\n\n    Job job = new Job(jobConf);\n    JobContext jobContext = ShimLoader.getHadoopShims().newJobContext(job);\n    // TODO: figure out the significance of table paths - REACTOR-277\n    Path[] tablePaths = FileInputFormat.getInputPaths(jobContext);\n\n    List<Split> dsSplits = recordScannable.getSplits();\n    InputSplit[] inputSplits = new InputSplit[dsSplits.size()];\n    for (int i = 0; i < dsSplits.size(); i++) {\n      inputSplits[i] = new DatasetInputSplit(dsSplits.get(i), tablePaths[0]);\n    }\n    return inputSplits;\n  }","id":71992,"modified_method":"@Override\n  public InputSplit[] getSplits(JobConf jobConf, int numSplits) throws IOException {\n\n    RecordScannable recordScannable = DatasetAccessor.getRecordScannable(jobConf);\n\n    Job job = new Job(jobConf);\n    JobContext jobContext = ShimLoader.getHadoopShims().newJobContext(job);\n    // TODO: figure out the significance of table paths - REACTOR-277\n    Path[] tablePaths = FileInputFormat.getInputPaths(jobContext);\n\n    List<Split> dsSplits = recordScannable.getSplits();\n    recordScannable.close();\n\n    InputSplit[] inputSplits = new InputSplit[dsSplits.size()];\n    for (int i = 0; i < dsSplits.size(); i++) {\n      inputSplits[i] = new DatasetInputSplit(dsSplits.get(i), tablePaths[0]);\n    }\n    return inputSplits;\n  }","commit_id":"4435daf1f72ba06f2439fdc79a6108ea40bf82e8","url":"https://github.com/caskdata/cdap"},{"original_method":"@Override\n  public RecordReader<Void, ObjectWritable> getRecordReader(final InputSplit split, JobConf jobConf, Reporter reporter)\n    throws IOException {\n\n    final RecordScannable recordScannable = DatasetAccessor.getRecordScannable(jobConf);\n\n    if (!(split instanceof DatasetInputSplit)) {\n      throw new IOException(\"Invalid type for InputSplit: \" + split.getClass().getName());\n    }\n    final DatasetInputSplit datasetInputSplit = (DatasetInputSplit) split;\n\n    final RecordScanner recordScanner = recordScannable.createSplitRecordScanner(\n        new Split() {\n          @Override\n          public long getLength() {\n            try {\n              return split.getLength();\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n    );\n\n    return new RecordReader<Void, ObjectWritable>() {\n      private final AtomicBoolean initialized = new AtomicBoolean(false);\n\n      private void initialize() throws IOException {\n        try {\n          recordScanner.initialize(datasetInputSplit.getDataSetSplit());\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          throw new IOException(\"Interrupted while initializing reader\", ie);\n        }\n        initialized.set(true);\n      }\n\n      @Override\n      public boolean next(Void key, ObjectWritable value) throws IOException {\n        if (!initialized.get()) {\n          initialize();\n        }\n\n        try {\n          boolean retVal = recordScanner.nextRecord();\n          if (retVal) {\n            value.set(recordScanner.getCurrentRecord());\n          }\n          return retVal;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new IOException(e);\n        }\n      }\n\n      @Override\n      public Void createKey() {\n        return null;\n      }\n\n      @Override\n      public ObjectWritable createValue() {\n        return new ObjectWritable();\n      }\n\n      @Override\n      public long getPos() throws IOException {\n        // Not required.\n        return 0;\n      }\n\n      @Override\n      public void close() throws IOException {\n        recordScanner.close();\n      }\n\n      @Override\n      public float getProgress() throws IOException {\n        try {\n          return recordScanner.getProgress();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new IOException(e);\n        }\n      }\n    };\n  }","id":71993,"modified_method":"@Override\n  public RecordReader<Void, ObjectWritable> getRecordReader(final InputSplit split, JobConf jobConf, Reporter reporter)\n    throws IOException {\n\n    final RecordScannable recordScannable = DatasetAccessor.getRecordScannable(jobConf);\n\n    if (!(split instanceof DatasetInputSplit)) {\n      throw new IOException(\"Invalid type for InputSplit: \" + split.getClass().getName());\n    }\n    final DatasetInputSplit datasetInputSplit = (DatasetInputSplit) split;\n\n    final RecordScanner recordScanner = recordScannable.createSplitRecordScanner(\n        new Split() {\n          @Override\n          public long getLength() {\n            try {\n              return split.getLength();\n            } catch (IOException e) {\n              throw new RuntimeException(e);\n            }\n          }\n        }\n    );\n\n    return new RecordReader<Void, ObjectWritable>() {\n      private final AtomicBoolean initialized = new AtomicBoolean(false);\n\n      private void initialize() throws IOException {\n        try {\n          recordScanner.initialize(datasetInputSplit.getDataSetSplit());\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n          throw new IOException(\"Interrupted while initializing reader\", ie);\n        }\n        initialized.set(true);\n      }\n\n      @Override\n      public boolean next(Void key, ObjectWritable value) throws IOException {\n        if (!initialized.get()) {\n          initialize();\n        }\n\n        try {\n          boolean retVal = recordScanner.nextRecord();\n          if (retVal) {\n            value.set(recordScanner.getCurrentRecord());\n          }\n          return retVal;\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new IOException(e);\n        }\n      }\n\n      @Override\n      public Void createKey() {\n        return null;\n      }\n\n      @Override\n      public ObjectWritable createValue() {\n        return new ObjectWritable();\n      }\n\n      @Override\n      public long getPos() throws IOException {\n        // Not required.\n        return 0;\n      }\n\n      @Override\n      public void close() throws IOException {\n        recordScanner.close();\n        recordScannable.close();\n      }\n\n      @Override\n      public float getProgress() throws IOException {\n        try {\n          return recordScanner.getProgress();\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new IOException(e);\n        }\n      }\n    };\n  }","commit_id":"4435daf1f72ba06f2439fdc79a6108ea40bf82e8","url":"https://github.com/caskdata/cdap"},{"original_method":"public boolean isSuppressedFor(final PsiElement element) {\n    return SuppressManager.getInstance().isSuppressedFor(element, getID()) || SuppressManager.getInstance().isSuppressedFor(element, getAlternativeID());\n  }","id":71994,"modified_method":"public boolean isSuppressedFor(final PsiElement element) {\n    final SuppressManager manager = SuppressManager.getInstance();\n    return manager.isSuppressedFor(element, getID()) || manager.isSuppressedFor(element, getAlternativeID());\n  }","commit_id":"1eef8f0897613bd03f3fa417c65a408c9b9cb88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InspectionProfileEntry instantiateTool() {\n    try {\n      return instantiate(implementationClass, ApplicationManager.getApplication().getPicoContainer());\n    }\n    catch (ClassNotFoundException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":71995,"modified_method":"public InspectionProfileEntry instantiateTool() {\n    try {\n      final InspectionProfileEntry entry = instantiate(implementationClass, ApplicationManager.getApplication().getPicoContainer());\n      entry.myNameProvider = this;\n      return entry;\n    }\n    catch (ClassNotFoundException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"1eef8f0897613bd03f3fa417c65a408c9b9cb88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * DO NOT OVERRIDE this method.\n   *\n   * @see InspectionEP#shortName\n   */\n  @NonNls @NotNull\n  public String getShortName() {\n    return getShortName(getClass().getSimpleName());\n  }","id":71996,"modified_method":"/**\n   * DO NOT OVERRIDE this method.\n   *\n   * @see InspectionEP#shortName\n   */\n  @NonNls @NotNull\n  public String getShortName() {\n    if (myNameProvider != null) {\n      final String name = myNameProvider.getShortName();\n      if (name != null) {\n        return name;\n      }\n    }\n    return getShortName(getClass().getSimpleName());\n  }","commit_id":"1eef8f0897613bd03f3fa417c65a408c9b9cb88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @see InspectionEP#groupDisplayName\n   * @see InspectionEP#groupKey\n   * @see InspectionEP#groupBundle\n   */\n  @Nls @NotNull\n  public String getGroupDisplayName() {\n    LOG.error(getClass() + \": group display name should be overridden or configured via XML \" + getClass());\n    return \"\";\n  }","id":71997,"modified_method":"/**\n   * @see InspectionEP#groupDisplayName\n   * @see InspectionEP#groupKey\n   * @see InspectionEP#groupBundle\n   */\n  @Nls @NotNull\n  public String getGroupDisplayName() {\n    if (myNameProvider != null) {\n      final String name = myNameProvider.getGroupDisplayName();\n      if (name != null) {\n        return name;\n      }\n    }\n    LOG.error(getClass() + \": group display name should be overridden or configured via XML \" + getClass());\n    return \"\";\n  }","commit_id":"1eef8f0897613bd03f3fa417c65a408c9b9cb88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * @see InspectionEP#displayName\n   * @see InspectionEP#key\n   * @see InspectionEP#bundle\n   */\n  @Nls @NotNull\n  public String getDisplayName() {\n    LOG.error(getClass() + \": display name should be overridden or configured via XML \" + getClass());\n    return \"\";\n  }","id":71998,"modified_method":"/**\n   * @see InspectionEP#displayName\n   * @see InspectionEP#key\n   * @see InspectionEP#bundle\n   */\n  @Nls @NotNull\n  public String getDisplayName() {\n    if (myNameProvider != null) {\n      final String name = myNameProvider.getDisplayName();\n      if (name != null) {\n        return name;\n      }\n    }\n    LOG.error(getClass() + \": display name should be overridden or configured via XML \" + getClass());\n    return \"\";\n  }","commit_id":"1eef8f0897613bd03f3fa417c65a408c9b9cb88d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NonNls\n  @Nullable\n  public String getAlternativeID() {\n    return null;\n  }","id":71999,"modified_method":"@NonNls\n  @Nullable\n  public String getAlternativeID() {\n    if (myNameProvider instanceof LocalDefaultNameProvider) {\n      return ((LocalDefaultNameProvider)myNameProvider).getAlternativeID();\n    }\n    return null;\n  }","commit_id":"1eef8f0897613bd03f3fa417c65a408c9b9cb88d","url":"https://github.com/JetBrains/intellij-community"}]