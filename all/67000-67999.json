[{"original_method":"private EditorCell createConstant_vc3gub_f0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \">\");\n    editorCell.setCellId(\"Constant_vc3gub_f0\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","id":67000,"modified_method":"private EditorCell createConstant_vc3gub_b0d0(EditorContext editorContext, SNode node) {\n    EditorCell_Constant editorCell = new EditorCell_Constant(editorContext, node, \">\");\n    editorCell.setCellId(\"Constant_vc3gub_b0d0\");\n    XmlSS_StyleSheet.getXmlTagPunctuation(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_LEFT, true);\n    }\n    editorCell.setDefaultText(\"\");\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean renderingCondition_vc3gub_a3a(SNode node, EditorContext editorContext, IScope scope) {\n    return XmlElement_Behavior.call_isMultiline_8886258982030574875(node);\n  }","id":67001,"modified_method":"private static boolean renderingCondition_vc3gub_a3a(SNode node, EditorContext editorContext, IScope scope) {\n    return ListSequence.fromList(SLinkOperations.getTargets(node, \"content\", true)).isEmpty() && SPropertyOperations.getBoolean(node, \"shortEmptyNotation\");\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_vc3gub_a0d0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a0d0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.INDENT_LAYOUT_INDENT, true);\n    }\n    editorCell.addEditorCell(this.createConstant_vc3gub_a0a3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_vc3gub_b0a3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_vc3gub_c0a3a(editorContext, node));\n    return editorCell;\n  }","id":67002,"modified_method":"private EditorCell createCollection_vc3gub_a0a0d0(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_vc3gub_a0a0d0\");\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.SELECTABLE, false);\n      style.set(StyleAttributes.INDENT_LAYOUT_INDENT, true);\n    }\n    editorCell.addEditorCell(this.createConstant_vc3gub_a0a0a3a(editorContext, node));\n    editorCell.addEditorCell(this.createRefNodeList_vc3gub_b0a0a3a(editorContext, node));\n    editorCell.addEditorCell(this.createConstant_vc3gub_c0a0a3a(editorContext, node));\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createEditorCell(EditorContext editorContext, SNode node) {\n    return this.createProperty_qyzwn3_a(editorContext, node);\n  }","id":67003,"modified_method":"public EditorCell createEditorCell(EditorContext editorContext, SNode node) {\n    return this.createAlternation_qyzwn3_a(editorContext, node);\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createProperty_qyzwn3_a(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"text\");\n    provider.setNoTargetText(\"\");\n    provider.setAllowsEmptyTarget(true);\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_text\");\n    XmlSS_StyleSheet.getXmlAttributeValue(editorCell).apply(editorCell);\n    editorCell.addKeyMap(new XmlTextValue_text());\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","id":67004,"modified_method":"private EditorCell createProperty_qyzwn3_a0(EditorContext editorContext, SNode node) {\n    CellProviderWithRole provider = new PropertyCellProvider(node, editorContext);\n    provider.setRole(\"text\");\n    provider.setNoTargetText(\"\");\n    provider.setAllowsEmptyTarget(true);\n    EditorCell editorCell;\n    editorCell = provider.createEditorCell(editorContext);\n    editorCell.setCellId(\"property_text\");\n    XmlSS_StyleSheet.getXmlAttributeValue(editorCell).apply(editorCell);\n    {\n      Style style = editorCell.getStyle();\n      style.set(StyleAttributes.PUNCTUATION_RIGHT, true);\n    }\n    editorCell.addKeyMap(new XmlTextValue_text());\n    editorCell.setSubstituteInfo(provider.createDefaultSubstituteInfo());\n    SNode attributeConcept = provider.getRoleAttribute();\n    Class attributeKind = provider.getRoleAttributeClass();\n    if (attributeConcept != null) {\n      IOperationContext opContext = editorContext.getOperationContext();\n      EditorManager manager = EditorManager.getInstanceFromContext(opContext);\n      return manager.createRoleAttributeCell(editorContext, attributeConcept, attributeKind, editorCell);\n    } else\n    return editorCell;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean virtual_onNewLine_6999033275467469862(SNode thisNode) {\n    return SNodeOperations.isInstanceOf(SNodeOperations.getPrevSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\") && SConceptPropertyOperations.getBoolean(SNodeOperations.cast(SNodeOperations.getPrevSibling(thisNode), \"jetbrains.mps.core.xml.structure.XmlContent\"), \"textLike\");\n  }","id":67005,"modified_method":"public static boolean virtual_onNewLine_6999033275467469862(SNode thisNode) {\n    SNode left = SNodeOperations.getPrevSibling(thisNode);\n    if (SNodeOperations.isInstanceOf(left, \"jetbrains.mps.core.xml.structure.XmlContent\")) {\n      SNode leftContent = SNodeOperations.cast(left, \"jetbrains.mps.core.xml.structure.XmlContent\");\n      return SConceptPropertyOperations.getBoolean(leftContent, \"textLike\") || StringUtils.isEmpty(SPropertyOperations.getString(thisNode, \"value\")) && (SNodeOperations.getNextSibling(thisNode) == null);\n    }\n    return false;\n  }","commit_id":"b7ed9ebb491adb455784fbe3eb0da58164f3a193","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void addAttributeSelection(List<TextRange> result, HighlighterIterator i) {\n    result.add(new TextRange(i.getStart(), i.getEnd()));\n    if (i.getTokenType() == XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {\n      boolean hasQuotes=true;\n\n      // Check quote before value\n      i.retreat();\n      if (!i.atEnd()) {\n        final IElementType tokenType = i.getTokenType();\n        if (tokenType != XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n          hasQuotes = false;\n        }\n      }\n      i.advance();\n\n      // Check quote after value\n      i.advance();\n      if (!i.atEnd()) {\n        final IElementType tokenType = i.getTokenType();\n        if (tokenType != XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n          hasQuotes = false;\n        }\n      }\n      i.retreat();\n\n      if (hasQuotes) result.add(new TextRange(i.getStart() - 1, i.getEnd() + 1));\n    }\n\n    while (!i.atEnd() && i.getTokenType() != XmlTokenType.XML_NAME) { i.retreat(); }\n    if (i.atEnd()) return;\n    i.retreat();\n\n    IElementType tokenType = i.getTokenType();\n    i.advance();\n    if(tokenType == XmlTokenType.XML_START_TAG_START) {\n      return;\n    }\n    int start = i.getStart();\n\n    while (!i.atEnd() &&\n           i.getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN &&\n           i.getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER\n           ) { i.advance(); }\n    if (i.atEnd()) return;\n\n    int end = i.getEnd();\n\n    if (i.getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) i.advance();\n    if (!i.atEnd() && i.getTokenType() == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n      end = i.getEnd();\n    }\n    \n    result.add(new TextRange(start, end));\n  }","id":67006,"modified_method":"private static void addAttributeSelection(List<TextRange> result, HighlighterIterator i) {\n    result.add(new TextRange(i.getStart(), i.getEnd()));\n    if (i.getTokenType() == XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {\n\n      // Check quote before value\n      i.retreat();\n      boolean hasQuotes = true;\n      if (!i.atEnd()) {\n        final IElementType tokenType = i.getTokenType();\n        if (tokenType != XmlTokenType.XML_ATTRIBUTE_VALUE_START_DELIMITER) {\n          hasQuotes = false;\n        }\n      }\n      i.advance();\n\n      // Check quote after value\n      i.advance();\n      if (!i.atEnd()) {\n        final IElementType tokenType = i.getTokenType();\n        if (tokenType != XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n          hasQuotes = false;\n        }\n      }\n      i.retreat();\n\n      if (hasQuotes) result.add(new TextRange(i.getStart() - 1, i.getEnd() + 1));\n    }\n\n    while (!i.atEnd() && i.getTokenType() != XmlTokenType.XML_NAME) { i.retreat(); }\n    if (i.atEnd()) return;\n    i.retreat();\n\n    IElementType tokenType = i.getTokenType();\n    i.advance();\n    if(tokenType == XmlTokenType.XML_START_TAG_START) {\n      return;\n    }\n    int start = i.getStart();\n\n    while (!i.atEnd() &&\n           i.getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN &&\n           i.getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER\n           ) { i.advance(); }\n    if (i.atEnd()) return;\n\n    int end = i.getEnd();\n\n    if (i.getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) i.advance();\n    if (!i.atEnd() && i.getTokenType() == XmlTokenType.XML_ATTRIBUTE_VALUE_END_DELIMITER) {\n      end = i.getEnd();\n    }\n    \n    result.add(new TextRange(start, end));\n  }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void addTagSelection(CharSequence editorText, int cursorOffset, FileType fileType, EditorHighlighter highlighter, List<TextRange> result) {\n    HighlighterIterator i;\n    int start = cursorOffset;\n\n    while (true) {\n      if (start < 0) return;\n      i = highlighter.createIterator(start);\n      if (i.atEnd()) return;\n\n      while (true) {\n        if (i.getTokenType() ==  XmlTokenType.XML_START_TAG_START) break;\n        i.retreat();\n        if (i.atEnd()) return;\n      }\n\n      start = i.getStart();\n      final boolean matched = BraceMatchingUtil.matchBrace(editorText, fileType, i, true);\n\n      if (matched) {\n        final int tagEnd = i.getEnd();\n        result.add(new TextRange(start, tagEnd));\n\n        HighlighterIterator j = highlighter.createIterator(start);\n        while (!j.atEnd() && j.getTokenType() != XmlTokenType.XML_TAG_END) j.advance();\n        while (!i.atEnd() && i.getTokenType() != XmlTokenType.XML_END_TAG_START) i.retreat();\n\n        if (!i.atEnd() && !j.atEnd()) {\n          result.add(new TextRange(j.getEnd(), i.getStart()));\n        }\n        if (!j.atEnd()) {\n          result.add(new TextRange(start, j.getEnd()));\n        }\n        if (!i.atEnd()) {\n          result.add(new TextRange(i.getStart(),tagEnd));\n        }\n      }\n\n      start--;\n    }\n  }","id":67007,"modified_method":"private static void addTagSelection(CharSequence editorText, int cursorOffset, FileType fileType, EditorHighlighter highlighter, List<TextRange> result) {\n    int start = cursorOffset;\n\n    while (true) {\n      if (start < 0) return;\n      HighlighterIterator i = highlighter.createIterator(start);\n      if (i.atEnd()) return;\n\n      while (true) {\n        if (i.getTokenType() ==  XmlTokenType.XML_START_TAG_START) break;\n        i.retreat();\n        if (i.atEnd()) return;\n      }\n\n      start = i.getStart();\n      final boolean matched = BraceMatchingUtil.matchBrace(editorText, fileType, i, true);\n\n      if (matched) {\n        final int tagEnd = i.getEnd();\n        result.add(new TextRange(start, tagEnd));\n\n        HighlighterIterator j = highlighter.createIterator(start);\n        while (!j.atEnd() && j.getTokenType() != XmlTokenType.XML_TAG_END) j.advance();\n        while (!i.atEnd() && i.getTokenType() != XmlTokenType.XML_END_TAG_START) i.retreat();\n\n        if (!i.atEnd() && !j.atEnd()) {\n          result.add(new TextRange(j.getEnd(), i.getStart()));\n        }\n        if (!j.atEnd()) {\n          result.add(new TextRange(start, j.getEnd()));\n        }\n        if (!i.atEnd()) {\n          result.add(new TextRange(i.getStart(),tagEnd));\n        }\n      }\n\n      start--;\n    }\n  }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean canSelect(PsiElement e) {\n      return e instanceof PsiJavaToken && !(e instanceof PsiKeyword);\n    }","id":67008,"modified_method":"public boolean canSelect(PsiElement e) {\n      return e instanceof PsiJavaToken && !(e instanceof PsiKeyword) && !(e.getParent()instanceof PsiCodeBlock);\n    }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n      List<TextRange> result = new ArrayList<TextRange>();\n\n      PsiElement[] children = e.getChildren();\n\n      int start = 0;\n      int end = 0;\n\n      for (PsiElement child : children) {\n        if (child instanceof PsiJavaToken) {\n          PsiJavaToken token = (PsiJavaToken)child;\n\n          if (token.getTokenType() == JavaTokenType.LPARENTH) {\n            start = token.getTextOffset() + 1;\n          }\n          if (token.getTokenType() == JavaTokenType.RPARENTH) {\n            end = token.getTextOffset();\n          }\n        }\n      }\n\n      result.add(new TextRange(start, end));\n      return result;\n    }","id":67009,"modified_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n\n      PsiElement[] children = e.getChildren();\n\n      int start = 0;\n      int end = 0;\n\n      for (PsiElement child : children) {\n        if (child instanceof PsiJavaToken) {\n          PsiJavaToken token = (PsiJavaToken)child;\n\n          if (token.getTokenType() == JavaTokenType.LPARENTH) {\n            start = token.getTextOffset() + 1;\n          }\n          if (token.getTokenType() == JavaTokenType.RPARENTH) {\n            end = token.getTextOffset();\n          }\n        }\n      }\n\n      List<TextRange> result = new ArrayList<TextRange>();\n      result.add(new TextRange(start, end));\n      return result;\n    }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n        List<TextRange> result = new ArrayList<TextRange>();\n        final PsiElement statement = e;\n        PsiElement caseStart = statement;\n        PsiElement caseEnd = statement;\n        \n        if (statement instanceof PsiSwitchLabelStatement ||\n            statement instanceof PsiSwitchStatement) {\n          return result;\n        }\n        \n        PsiElement sibling;\n        \n        sibling = statement.getPrevSibling();\n        while(sibling != null && !(sibling instanceof PsiSwitchLabelStatement)) {\n          if (!(sibling instanceof PsiWhiteSpace)) caseStart = sibling;\n          sibling = sibling.getPrevSibling();\n        }\n        \n        sibling = statement.getNextSibling();\n        while(sibling != null && !(sibling instanceof PsiSwitchLabelStatement)) {\n          if (!(sibling instanceof PsiWhiteSpace) &&\n              !(sibling instanceof PsiJavaToken) // end of switch\n             ) {\n            caseEnd = sibling;\n          }\n          sibling = sibling.getNextSibling();\n        }\n\n        final Document document = editor.getDocument();\n        final int startOffset = document.getLineStartOffset(document.getLineNumber(caseStart.getTextOffset()));\n        final int endOffset = document.getLineEndOffset(document.getLineNumber(caseEnd.getTextOffset() + caseEnd.getTextLength())) + 1;\n        \n        result.add(new TextRange(startOffset,endOffset));\n        return result;\n      }","id":67010,"modified_method":"public List<TextRange> select(PsiElement statement, CharSequence editorText, int cursorOffset, Editor editor) {\n        List<TextRange> result = new ArrayList<TextRange>();\n        PsiElement caseStart = statement;\n        PsiElement caseEnd = statement;\n        \n        if (statement instanceof PsiSwitchLabelStatement ||\n            statement instanceof PsiSwitchStatement) {\n          return result;\n        }\n\n        PsiElement sibling = statement.getPrevSibling();\n        while(sibling != null && !(sibling instanceof PsiSwitchLabelStatement)) {\n          if (!(sibling instanceof PsiWhiteSpace)) caseStart = sibling;\n          sibling = sibling.getPrevSibling();\n        }\n        \n        sibling = statement.getNextSibling();\n        while(sibling != null && !(sibling instanceof PsiSwitchLabelStatement)) {\n          if (!(sibling instanceof PsiWhiteSpace) &&\n              !(sibling instanceof PsiJavaToken) // end of switch\n             ) {\n            caseEnd = sibling;\n          }\n          sibling = sibling.getNextSibling();\n        }\n\n        final Document document = editor.getDocument();\n        final int startOffset = document.getLineStartOffset(document.getLineNumber(caseStart.getTextOffset()));\n        final int endOffset = document.getLineEndOffset(document.getLineNumber(caseEnd.getTextOffset() + caseEnd.getTextLength())) + 1;\n        \n        result.add(new TextRange(startOffset,endOffset));\n        return result;\n      }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n      List<TextRange> result = new ArrayList<TextRange>(1);\n      PsiElement[] children = e.getChildren();\n\n      PsiElement first = null;\n      PsiElement last = null;\n      for (PsiElement child : children) {\n        if (child instanceof XmlToken) {\n          XmlToken token = (XmlToken)child;\n          if (token.getTokenType() == XmlTokenType.XML_TAG_END) {\n            last = token;\n            break;\n          }\n          if (token.getTokenType() == XmlTokenType.XML_ELEMENT_DECL_START ||\n              token.getTokenType() == XmlTokenType.XML_ATTLIST_DECL_START\n             ) {\n            first = token;\n          }\n        }\n      }\n\n      if (first != null && last != null) {\n        result.addAll(expandToWholeLine(editorText,\n                                        new TextRange(first.getTextRange().getStartOffset(),\n                                                      last.getTextRange().getEndOffset() + 1),\n                                        false));\n      }\n\n      return result;\n    }","id":67011,"modified_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n      PsiElement[] children = e.getChildren();\n\n      PsiElement first = null;\n      PsiElement last = null;\n      for (PsiElement child : children) {\n        if (child instanceof XmlToken) {\n          XmlToken token = (XmlToken)child;\n          if (token.getTokenType() == XmlTokenType.XML_TAG_END) {\n            last = token;\n            break;\n          }\n          if (token.getTokenType() == XmlTokenType.XML_ELEMENT_DECL_START ||\n              token.getTokenType() == XmlTokenType.XML_ATTLIST_DECL_START\n             ) {\n            first = token;\n          }\n        }\n      }\n\n      List<TextRange> result = new ArrayList<TextRange>(1);\n      if (first != null && last != null) {\n        result.addAll(expandToWholeLine(editorText,\n                                        new TextRange(first.getTextRange().getStartOffset(),\n                                                      last.getTextRange().getEndOffset() + 1),\n                                        false));\n      }\n\n      return result;\n    }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n      List<TextRange> result = new ArrayList<TextRange>();\n\n      final TextRange originalRange = e.getTextRange();\n      List<TextRange> ranges = expandToWholeLine(editorText, originalRange, true);\n\n      if (ranges.size() == 1 && ranges.contains(originalRange)) {\n        ranges = expandToWholeLine(editorText, originalRange, false);\n      }\n\n      result.addAll(ranges);\n      return result;\n    }","id":67012,"modified_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n\n      final TextRange originalRange = e.getTextRange();\n      List<TextRange> ranges = expandToWholeLine(editorText, originalRange, true);\n\n      if (ranges.size() == 1 && ranges.contains(originalRange)) {\n        ranges = expandToWholeLine(editorText, originalRange, false);\n      }\n\n      List<TextRange> result = new ArrayList<TextRange>();\n      result.addAll(ranges);\n      return result;\n    }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean isDocCommentElement(PsiElement element) {\n    return element instanceof PsiDocTag;\n  }","id":67013,"modified_method":"private static boolean isDocCommentElement(PsiElement element) {\n    return element instanceof PsiDocTag;\n  }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n      List<TextRange> result = new ArrayList<TextRange>();\n\n      PsiElement endElement = e;\n\n      while (endElement.getNextSibling() != null && endElement instanceof PsiJavaCodeReferenceElement) {\n        endElement = endElement.getNextSibling();\n      }\n\n      if (!(endElement instanceof PsiJavaCodeReferenceElement) &&\n          !(endElement.getPrevSibling() instanceof PsiReferenceExpression && endElement instanceof PsiExpressionList)) {\n        endElement = endElement.getPrevSibling();\n      }\n\n      PsiElement element = e;\n      while (element instanceof PsiJavaCodeReferenceElement) {\n        PsiElement firstChild = element.getFirstChild();\n\n        PsiElement referenceName = ((PsiJavaCodeReferenceElement)element).getReferenceNameElement();\n        if (referenceName != null) {\n          result.addAll(expandToWholeLine(editorText, new TextRange(referenceName.getTextRange().getStartOffset(),\n                                                                    endElement.getTextRange().getEndOffset())));\n          if (endElement instanceof PsiJavaCodeReferenceElement) {\n            final PsiElement endReferenceName = ((PsiJavaCodeReferenceElement)endElement).getReferenceNameElement();\n            if (endReferenceName != null) {\n              result.addAll(expandToWholeLine(editorText, new TextRange(referenceName.getTextRange().getStartOffset(),\n                                                                        endReferenceName.getTextRange().getEndOffset())));\n            }\n          }\n\n        }\n\n        element = firstChild;\n      }\n\n//      if (element instanceof PsiMethodCallExpression) {\n      result.addAll(expandToWholeLine(editorText, new TextRange(element.getTextRange().getStartOffset(),\n                                                                endElement.getTextRange().getEndOffset())));\n//      }\n\n      if (!(e.getParent() instanceof PsiJavaCodeReferenceElement)) {\n        if (e.getNextSibling() instanceof PsiJavaToken ||\n            e.getNextSibling() instanceof PsiWhiteSpace ||\n            e.getNextSibling() instanceof PsiExpressionList) {\n          result.addAll(super.select(e, editorText, cursorOffset, editor));\n        }\n      }\n\n      return result;\n    }","id":67014,"modified_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n\n      PsiElement endElement = e;\n\n      while (endElement.getNextSibling() != null && endElement instanceof PsiJavaCodeReferenceElement) {\n        endElement = endElement.getNextSibling();\n      }\n\n      if (!(endElement instanceof PsiJavaCodeReferenceElement) &&\n          !(endElement.getPrevSibling() instanceof PsiReferenceExpression && endElement instanceof PsiExpressionList)) {\n        endElement = endElement.getPrevSibling();\n      }\n\n      PsiElement element = e;\n      List<TextRange> result = new ArrayList<TextRange>();\n      while (element instanceof PsiJavaCodeReferenceElement) {\n        PsiElement firstChild = element.getFirstChild();\n\n        PsiElement referenceName = ((PsiJavaCodeReferenceElement)element).getReferenceNameElement();\n        if (referenceName != null) {\n          result.addAll(expandToWholeLine(editorText, new TextRange(referenceName.getTextRange().getStartOffset(),\n                                                                    endElement.getTextRange().getEndOffset())));\n          if (endElement instanceof PsiJavaCodeReferenceElement) {\n            final PsiElement endReferenceName = ((PsiJavaCodeReferenceElement)endElement).getReferenceNameElement();\n            if (endReferenceName != null) {\n              result.addAll(expandToWholeLine(editorText, new TextRange(referenceName.getTextRange().getStartOffset(),\n                                                                        endReferenceName.getTextRange().getEndOffset())));\n            }\n          }\n\n        }\n\n        element = firstChild;\n      }\n\n//      if (element instanceof PsiMethodCallExpression) {\n      result.addAll(expandToWholeLine(editorText, new TextRange(element.getTextRange().getStartOffset(),\n                                                                endElement.getTextRange().getEndOffset())));\n//      }\n\n      if (!(e.getParent() instanceof PsiJavaCodeReferenceElement)) {\n        if (e.getNextSibling() instanceof PsiJavaToken ||\n            e.getNextSibling() instanceof PsiWhiteSpace ||\n            e.getNextSibling() instanceof PsiExpressionList) {\n          result.addAll(super.select(e, editorText, cursorOffset, editor));\n        }\n      }\n\n      return result;\n    }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n      List<TextRange> result = new ArrayList<TextRange>();\n      int start = cursorOffset;\n      while (start > 0 && editorText.charAt(start - 1) != '\\n' && editorText.charAt(start - 1) != '\\r') start--;\n\n      int end = cursorOffset;\n      while (end < editorText.length() && editorText.charAt(end) != '\\n' && editorText.charAt(end) != '\\r') end++;\n\n      final TextRange range = new TextRange(start, end);\n      if (!e.getParent().getTextRange().contains(range)) return null;\n      result.add(range);\n      return result;\n    }","id":67015,"modified_method":"public List<TextRange> select(PsiElement e, CharSequence editorText, int cursorOffset, Editor editor) {\n      int start = cursorOffset;\n      while (start > 0 && editorText.charAt(start - 1) != '\\n' && editorText.charAt(start - 1) != '\\r') start--;\n\n      int end = cursorOffset;\n      while (end < editorText.length() && editorText.charAt(end) != '\\n' && editorText.charAt(end) != '\\r') end++;\n\n      final TextRange range = new TextRange(start, end);\n      if (!e.getParent().getTextRange().contains(range)) return null;\n      List<TextRange> result = new ArrayList<TextRange>();\n      result.add(range);\n      return result;\n    }","commit_id":"d661c4e9ef08dee8477f7494a82058316f1d00f2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      super.visitMethod(method);\n      final PsiAnnotation annotation =\n        AnnotationUtil.findAnnotation(method, \"org.junit.Test\");\n      if (annotation == null) {\n        return;\n      }\n      final PsiAnnotationParameterList parameterList =\n        annotation.getParameterList();\n      final PsiNameValuePair[] attributes = parameterList.getAttributes();\n      PsiAnnotationMemberValue value = null;\n      for (PsiNameValuePair attribute : attributes) {\n        if (\"expected\".equals(attribute.getName())) {\n          value = attribute.getValue();\n          break;\n        }\n      }\n      if (!(value instanceof PsiClassObjectAccessExpression)) {\n        return;\n      }\n      final PsiCodeBlock body = method.getBody();\n      if (body == null) {\n        return;\n      }\n      final PsiClassObjectAccessExpression classObjectAccessExpression =\n        (PsiClassObjectAccessExpression)value;\n      final PsiTypeElement operand =\n        classObjectAccessExpression.getOperand();\n      final PsiType type = operand.getType();\n      if (!(type instanceof PsiClassType)) {\n        return;\n      }\n      final PsiClassType classType = (PsiClassType)type;\n      final PsiClass aClass = classType.resolve();\n      if (InheritanceUtil.isInheritor(aClass,\n                                      CommonClassNames.JAVA_LANG_RUNTIME_EXCEPTION)) {\n        return;\n      }\n      final Set<PsiClassType> exceptionsThrown =\n        ExceptionUtils.calculateExceptionsThrown(body);\n      if (exceptionsThrown.contains(classType)) {\n        return;\n      }\n      registerError(operand, method);\n    }","id":67016,"modified_method":"@Override\n    public void visitMethod(PsiMethod method) {\n      super.visitMethod(method);\n      final PsiAnnotation annotation = AnnotationUtil.findAnnotation(method, \"org.junit.Test\");\n      if (annotation == null) {\n        return;\n      }\n      final PsiAnnotationParameterList parameterList = annotation.getParameterList();\n      final PsiNameValuePair[] attributes = parameterList.getAttributes();\n      PsiAnnotationMemberValue value = null;\n      for (PsiNameValuePair attribute : attributes) {\n        if (\"expected\".equals(attribute.getName())) {\n          value = attribute.getValue();\n          break;\n        }\n      }\n      if (!(value instanceof PsiClassObjectAccessExpression)) {\n        return;\n      }\n      final PsiCodeBlock body = method.getBody();\n      if (body == null) {\n        return;\n      }\n      final PsiClassObjectAccessExpression classObjectAccessExpression = (PsiClassObjectAccessExpression)value;\n      final PsiTypeElement operand = classObjectAccessExpression.getOperand();\n      final PsiType type = operand.getType();\n      if (!(type instanceof PsiClassType)) {\n        return;\n      }\n      final PsiClassType classType = (PsiClassType)type;\n      final PsiClass aClass = classType.resolve();\n      if (InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_RUNTIME_EXCEPTION) ||\n        InheritanceUtil.isInheritor(aClass, CommonClassNames.JAVA_LANG_ERROR)) {\n        return;\n      }\n      final Set<PsiClassType> exceptionsThrown = ExceptionUtils.calculateExceptionsThrown(body);\n      if (exceptionsThrown.contains(classType)) {\n        return;\n      }\n      registerError(operand, method);\n    }","commit_id":"224a1b3e0b6b339cfafe149cd18ec677e986dd34","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isPartOf(PsiClass elementClass, PsiClass containingClass) {\n    if (containingClass == null) return false;\n    if (elementClass.equals(containingClass) || elementClass.isInheritor(containingClass, true)) {\n      return true;\n    } else {\n      return false;\n    }\n  }","id":67017,"modified_method":"private static boolean isPartOf(PsiClass elementClass, PsiClass containingClass) {\n    if (containingClass == null) return false;\n    if (elementClass.equals(containingClass) || elementClass.isInheritor(containingClass, true)) {\n      return true;\n    } else {\n      return PsiTreeUtil.isAncestor(containingClass, elementClass, true);\n    }\n  }","commit_id":"0936ad00fd3e7d1d33e8fb3ff384aa6b05e9df0a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static MultiMap<PsiElement, String> checkConflicts(final MemberInfoBase<? extends PsiMember>[] infos,\n                                                            @NotNull final PsiClass subclass,\n                                                            @Nullable PsiClass superClass,\n                                                            @NotNull final PsiPackage targetPackage,\n                                                            @NotNull PsiDirectory targetDirectory,\n                                                            final InterfaceContainmentVerifier interfaceContainmentVerifier,\n                                                            boolean movedMembers2Super) {\n    final Set<PsiMember> movedMembers = new HashSet<PsiMember>();\n    final Set<PsiMethod> abstractMethods = new HashSet<PsiMethod>();\n    final boolean isInterfaceTarget;\n    final PsiElement targetRepresentativeElement;\n    if (superClass != null) {\n      isInterfaceTarget = superClass.isInterface();\n      targetRepresentativeElement = superClass;\n    }\n    else {\n      isInterfaceTarget = false;\n      targetRepresentativeElement = targetDirectory;\n    }\n    for (MemberInfoBase<? extends PsiMember> info : infos) {\n      PsiMember member = info.getMember();\n      if (member instanceof PsiMethod) {\n        if (!info.isToAbstract()) {\n          movedMembers.add(member);\n        }\n        else {\n          abstractMethods.add((PsiMethod)member);\n        }\n      }\n      else {\n        movedMembers.add(member);\n      }\n    }\n    final MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>();\n    final Set<PsiMethod> abstrMethods = new HashSet<PsiMethod>(abstractMethods);\n    if (superClass != null) {\n      for (PsiMethod method : subclass.getMethods()) {\n        if (!movedMembers.contains(method) && !method.hasModifierProperty(PsiModifier.PRIVATE)) {\n          if (method.findSuperMethods(superClass).length > 0) {\n            abstrMethods.add(method);\n          }\n        }\n      }\n\n      if (newAbstractMethodInSuper(infos)) {\n        final PsiAnnotation annotation = AnnotationUtil.findAnnotation(superClass, CommonClassNames.JAVA_LANG_FUNCTIONAL_INTERFACE);\n        if (annotation != null) {\n          conflicts.putValue(annotation, RefactoringBundle.message(\"functional.interface.broken\"));\n        } else {\n          final PsiFunctionalExpression functionalExpression = FunctionalExpressionSearch.search(superClass).findFirst();\n          if (functionalExpression != null) {\n            conflicts.putValue(functionalExpression, RefactoringBundle.message(\"functional.interface.broken\"));\n          }\n        }\n      }\n    }\n    RefactoringConflictsUtil.analyzeAccessibilityConflicts(movedMembers, superClass, conflicts, VisibilityUtil.ESCALATE_VISIBILITY, targetRepresentativeElement, abstrMethods);\n    if (superClass != null) {\n      if (movedMembers2Super) {\n        checkSuperclassMembers(superClass, infos, conflicts);\n        if (isInterfaceTarget) {\n          checkInterfaceTarget(infos, conflicts);\n        }\n      } else {\n        final String qualifiedName = superClass.getQualifiedName();\n        assert qualifiedName != null;\n        if (superClass.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) {\n          if (!Comparing.strEqual(StringUtil.getPackageName(qualifiedName), targetPackage.getQualifiedName())) {\n            conflicts.putValue(superClass, RefactoringUIUtil.getDescription(superClass, true) + \" won't be accessible from \" +RefactoringUIUtil.getDescription(targetPackage, true));\n          }\n        }\n      }\n    }\n    // check if moved methods use other members in the classes between Subclass and Superclass\n    List<PsiElement> checkModuleConflictsList = new ArrayList<PsiElement>();\n    for (PsiMember member : movedMembers) {\n      if (member instanceof PsiMethod || member instanceof PsiClass && !(member instanceof PsiCompiledElement)) {\n        ClassMemberReferencesVisitor visitor =\n          movedMembers2Super? new ConflictingUsagesOfSubClassMembers(member, movedMembers, abstractMethods, subclass, superClass,\n                                                 superClass != null ? null : targetPackage, conflicts,\n                                                 interfaceContainmentVerifier)\n                            : new ConflictingUsagesOfSuperClassMembers(member, subclass, targetPackage, movedMembers, conflicts);\n        member.accept(visitor);\n      }\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, member);\n    }\n    for (final PsiMethod method : abstractMethods) {\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, method.getParameterList());\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, method.getReturnTypeElement());\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, method.getTypeParameterList());\n    }\n    RefactoringConflictsUtil.analyzeModuleConflicts(subclass.getProject(), checkModuleConflictsList,\n                                           new UsageInfo[0], targetRepresentativeElement, conflicts);\n    final String fqName = subclass.getQualifiedName();\n    final String packageName;\n    if (fqName != null) {\n      packageName = StringUtil.getPackageName(fqName);\n    } else {\n      final PsiFile psiFile = PsiTreeUtil.getParentOfType(subclass, PsiFile.class);\n      if (psiFile instanceof PsiClassOwner) {\n        packageName = ((PsiClassOwner)psiFile).getPackageName();\n      } else {\n        packageName = null;\n      }\n    }\n    final boolean toDifferentPackage = !Comparing.strEqual(targetPackage.getQualifiedName(), packageName);\n    for (final PsiMethod abstractMethod : abstractMethods) {\n      abstractMethod.accept(new ClassMemberReferencesVisitor(subclass) {\n        @Override\n        protected void visitClassMemberReferenceElement(PsiMember classMember, PsiJavaCodeReferenceElement classMemberReference) {\n          if (classMember != null && willBeMoved(classMember, movedMembers)) {\n            boolean isAccessible = false;\n            if (classMember.hasModifierProperty(PsiModifier.PRIVATE)) {\n              isAccessible = true;\n            }\n            else if (classMember.hasModifierProperty(PsiModifier.PACKAGE_LOCAL) &&\n                     toDifferentPackage) {\n              isAccessible = true;\n            }\n            if (isAccessible) {\n              String message = RefactoringUIUtil.getDescription(abstractMethod, false) +\n                               \" uses \" +\n                               RefactoringUIUtil.getDescription(classMember, true) +\n                               \" which won't be accessible from the subclass.\";\n              message = CommonRefactoringUtil.capitalize(message);\n              conflicts.putValue(classMember, message);\n            }\n          }\n        }\n      });\n      if (abstractMethod.hasModifierProperty(PsiModifier.PACKAGE_LOCAL) && toDifferentPackage) {\n        if (!isInterfaceTarget) {\n          String message = \"Can't make \" + RefactoringUIUtil.getDescription(abstractMethod, false) +\n                           \" abstract as it won't be accessible from the subclass.\";\n          message = CommonRefactoringUtil.capitalize(message);\n          conflicts.putValue(abstractMethod, message);\n        }\n      }\n    }\n    return conflicts;\n  }","id":67018,"modified_method":"public static MultiMap<PsiElement, String> checkConflicts(final MemberInfoBase<? extends PsiMember>[] infos,\n                                                            @NotNull final PsiClass subclass,\n                                                            @Nullable PsiClass superClass,\n                                                            @NotNull final PsiPackage targetPackage,\n                                                            @NotNull PsiDirectory targetDirectory,\n                                                            final InterfaceContainmentVerifier interfaceContainmentVerifier,\n                                                            boolean movedMembers2Super) {\n    final Set<PsiMember> movedMembers = new HashSet<PsiMember>();\n    final Set<PsiMethod> abstractMethods = new HashSet<PsiMethod>();\n    final boolean isInterfaceTarget;\n    final PsiElement targetRepresentativeElement;\n    if (superClass != null) {\n      isInterfaceTarget = superClass.isInterface();\n      targetRepresentativeElement = superClass;\n    }\n    else {\n      isInterfaceTarget = false;\n      targetRepresentativeElement = targetDirectory;\n    }\n    for (MemberInfoBase<? extends PsiMember> info : infos) {\n      PsiMember member = info.getMember();\n      if (member instanceof PsiMethod) {\n        if (!info.isToAbstract()) {\n          movedMembers.add(member);\n        }\n        else {\n          abstractMethods.add((PsiMethod)member);\n        }\n      }\n      else {\n        movedMembers.add(member);\n      }\n    }\n    final MultiMap<PsiElement, String> conflicts = new MultiMap<PsiElement, String>();\n    final Set<PsiMethod> abstrMethods = new HashSet<PsiMethod>(abstractMethods);\n    if (superClass != null) {\n      for (PsiMethod method : subclass.getMethods()) {\n        if (!movedMembers.contains(method) && !method.hasModifierProperty(PsiModifier.PRIVATE)) {\n          if (method.findSuperMethods(superClass).length > 0) {\n            abstrMethods.add(method);\n          }\n        }\n      }\n\n      if (newAbstractMethodInSuper(infos)) {\n        final PsiAnnotation annotation = AnnotationUtil.findAnnotation(superClass, CommonClassNames.JAVA_LANG_FUNCTIONAL_INTERFACE);\n        if (annotation != null) {\n          conflicts.putValue(annotation, RefactoringBundle.message(\"functional.interface.broken\"));\n        } else {\n          final PsiFunctionalExpression functionalExpression = FunctionalExpressionSearch.search(superClass).findFirst();\n          if (functionalExpression != null) {\n            conflicts.putValue(functionalExpression, RefactoringBundle.message(\"functional.interface.broken\"));\n          }\n        }\n      }\n    }\n    RefactoringConflictsUtil.analyzeAccessibilityConflicts(movedMembers, superClass, conflicts, VisibilityUtil.ESCALATE_VISIBILITY, targetRepresentativeElement, abstrMethods);\n    if (superClass != null) {\n      if (movedMembers2Super) {\n        checkSuperclassMembers(superClass, infos, conflicts);\n        if (isInterfaceTarget) {\n          checkInterfaceTarget(infos, conflicts);\n        }\n      } else {\n        final String qualifiedName = superClass.getQualifiedName();\n        assert qualifiedName != null;\n        if (superClass.hasModifierProperty(PsiModifier.PACKAGE_LOCAL)) {\n          if (!Comparing.strEqual(StringUtil.getPackageName(qualifiedName), targetPackage.getQualifiedName())) {\n            conflicts.putValue(superClass, RefactoringUIUtil.getDescription(superClass, true) + \" won't be accessible from \" +RefactoringUIUtil.getDescription(targetPackage, true));\n          }\n        }\n      }\n    }\n    // check if moved methods use other members in the classes between Subclass and Superclass\n    List<PsiElement> checkModuleConflictsList = new ArrayList<PsiElement>();\n    for (PsiMember member : movedMembers) {\n      if (member instanceof PsiMethod || member instanceof PsiClass && !(member instanceof PsiCompiledElement)) {\n        ClassMemberReferencesVisitor visitor =\n          movedMembers2Super? new ConflictingUsagesOfSubClassMembers(member, movedMembers, abstractMethods, subclass, superClass,\n                                                 superClass != null ? null : targetPackage, conflicts,\n                                                 interfaceContainmentVerifier)\n                            : new ConflictingUsagesOfSuperClassMembers(member, subclass, targetPackage, movedMembers, conflicts);\n        member.accept(visitor);\n      }\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, member);\n    }\n    for (final PsiMethod method : abstractMethods) {\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, method.getParameterList());\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, method.getReturnTypeElement());\n      ContainerUtil.addIfNotNull(checkModuleConflictsList, method.getTypeParameterList());\n    }\n    RefactoringConflictsUtil.analyzeModuleConflicts(subclass.getProject(), checkModuleConflictsList,\n                                           new UsageInfo[0], targetRepresentativeElement, conflicts);\n\n    final PsiFile psiFile = PsiTreeUtil.getParentOfType(subclass, PsiClassOwner.class);\n    final boolean toDifferentPackage = !Comparing.strEqual(targetPackage.getQualifiedName(),\n                                                           psiFile != null ? ((PsiClassOwner)psiFile).getPackageName() : null);\n    for (final PsiMethod abstractMethod : abstractMethods) {\n      abstractMethod.accept(new ClassMemberReferencesVisitor(subclass) {\n        @Override\n        protected void visitClassMemberReferenceElement(PsiMember classMember, PsiJavaCodeReferenceElement classMemberReference) {\n          if (classMember != null && willBeMoved(classMember, movedMembers)) {\n            boolean isAccessible = false;\n            if (classMember.hasModifierProperty(PsiModifier.PRIVATE)) {\n              isAccessible = true;\n            }\n            else if (classMember.hasModifierProperty(PsiModifier.PACKAGE_LOCAL) &&\n                     toDifferentPackage) {\n              isAccessible = true;\n            }\n            if (isAccessible) {\n              String message = RefactoringUIUtil.getDescription(abstractMethod, false) +\n                               \" uses \" +\n                               RefactoringUIUtil.getDescription(classMember, true) +\n                               \" which won't be accessible from the subclass.\";\n              message = CommonRefactoringUtil.capitalize(message);\n              conflicts.putValue(classMember, message);\n            }\n          }\n        }\n      });\n      if (abstractMethod.hasModifierProperty(PsiModifier.PACKAGE_LOCAL) && toDifferentPackage) {\n        if (!isInterfaceTarget) {\n          String message = \"Can't make \" + RefactoringUIUtil.getDescription(abstractMethod, false) +\n                           \" abstract as it won't be accessible from the subclass.\";\n          message = CommonRefactoringUtil.capitalize(message);\n          conflicts.putValue(abstractMethod, message);\n        }\n      }\n    }\n    return conflicts;\n  }","commit_id":"0936ad00fd3e7d1d33e8fb3ff384aa6b05e9df0a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest(final boolean checkMembersMovedCount,\n                      String conflictMessage,\n                      RefactoringTestUtil.MemberDescriptor... membersToFind) {\n    final MultiMap<PsiElement, String> conflictsMap = new MultiMap<>();\n    configureByFile(BASE_PATH + getTestName(false) + \".java\");\n    PsiElement elementAt = getFile().findElementAt(getEditor().getCaretModel().getOffset());\n    final PsiClass sourceClass = PsiTreeUtil.getParentOfType(elementAt, PsiClass.class);\n    assertNotNull(sourceClass);\n\n    PsiClass targetClass = sourceClass.getSuperClass();\n    assertNotNull(targetClass);\n    if (!targetClass.isWritable()) {\n      final PsiClass[] interfaces = sourceClass.getInterfaces();\n      assertEquals(1, interfaces.length);\n      assertTrue(interfaces[0].isWritable());\n      targetClass = interfaces[0];\n    }\n    final MemberInfo[] infos = RefactoringTestUtil.findMembers(sourceClass, membersToFind);\n\n    final int[] countMoved = {0};\n    final MoveMemberListener listener = (aClass, member) -> {\n      assertEquals(sourceClass, aClass);\n      countMoved[0]++;\n    };\n    JavaRefactoringListenerManager.getInstance(getProject()).addMoveMembersListener(listener);\n    final PsiDirectory targetDirectory = targetClass.getContainingFile().getContainingDirectory();\n    final PsiPackage targetPackage = targetDirectory != null ? JavaDirectoryService.getInstance().getPackage(targetDirectory) : null;\n    conflictsMap.putAllValues(\n      PullUpConflictsUtil\n        .checkConflicts(infos, sourceClass, targetClass, targetPackage, targetDirectory,\n                        psiMethod -> PullUpProcessor.checkedInterfacesContain(Arrays.asList(infos), psiMethod))\n    );\n    final PullUpProcessor helper = new PullUpProcessor(sourceClass, targetClass, infos, new DocCommentPolicy(DocCommentPolicy.ASIS));\n    helper.run();\n    UIUtil.dispatchAllInvocationEvents();\n    JavaRefactoringListenerManager.getInstance(getProject()).removeMoveMembersListener(listener);\n\n    if (conflictMessage != null && conflictsMap.isEmpty()) {\n      fail(\"Conflict was not detected\");\n    }\n\n    if (conflictMessage == null && !conflictsMap.isEmpty()) {\n      fail(conflictsMap.values().iterator().next());\n    }\n\n    if (conflictMessage != null && !IGNORE_CONFLICTS.equals(conflictMessage)) {\n      assertEquals(conflictMessage, conflictsMap.values().iterator().next());\n      return;\n    }\n\n    if (checkMembersMovedCount) {\n      assertEquals(countMoved[0], membersToFind.length);\n    }\n    checkResultByFile(BASE_PATH + getTestName(false) + \"_after.java\");\n  }","id":67019,"modified_method":"private void doTest(final boolean checkMembersMovedCount,\n                      String conflictMessage,\n                      RefactoringTestUtil.MemberDescriptor... membersToFind) {\n    final MultiMap<PsiElement, String> conflictsMap = new MultiMap<>();\n    configureByFile(BASE_PATH + getTestName(false) + \".java\");\n    PsiElement elementAt = getFile().findElementAt(getEditor().getCaretModel().getOffset());\n    final PsiClass sourceClass = PsiTreeUtil.getParentOfType(elementAt, PsiClass.class);\n    assertNotNull(sourceClass);\n\n    PsiClass targetClass = sourceClass.getSuperClass();\n    assertNotNull(targetClass);\n    if (!targetClass.isWritable()) {\n      final PsiClass[] interfaces = sourceClass.getInterfaces();\n      assertEquals(1, interfaces.length);\n      assertTrue(interfaces[0].isWritable());\n      targetClass = interfaces[0];\n    }\n    final MemberInfo[] infos = RefactoringTestUtil.findMembers(sourceClass, membersToFind);\n\n    final int[] countMoved = {0};\n    final MoveMemberListener listener = (aClass, member) -> {\n      assertEquals(sourceClass, aClass);\n      countMoved[0]++;\n    };\n    JavaRefactoringListenerManager.getInstance(getProject()).addMoveMembersListener(listener);\n    final PsiDirectory targetDirectory = targetClass.getContainingFile().getContainingDirectory();\n    final PsiPackage targetPackage = targetDirectory != null ? JavaDirectoryService.getInstance().getPackage(targetDirectory) : null;\n    conflictsMap.putAllValues(\n      PullUpConflictsUtil\n        .checkConflicts(infos, sourceClass, targetClass, targetPackage, targetDirectory,\n                        psiMethod -> PullUpProcessor.checkedInterfacesContain(Arrays.asList(infos), psiMethod))\n    );\n    final PullUpProcessor helper = new PullUpProcessor(sourceClass, targetClass, infos, new DocCommentPolicy(DocCommentPolicy.ASIS));\n    helper.run();\n    UIUtil.dispatchAllInvocationEvents();\n    JavaRefactoringListenerManager.getInstance(getProject()).removeMoveMembersListener(listener);\n\n    if (conflictMessage != null && conflictsMap.isEmpty()) {\n      fail(\"Conflict was not detected\");\n    }\n\n    if (conflictMessage == null && !conflictsMap.isEmpty()) {\n      fail(conflictsMap.values().iterator().next());\n    }\n\n    if (conflictMessage != null && !IGNORE_CONFLICTS.equals(conflictMessage)) {\n      TreeSet<String> conflicts = new TreeSet<>(conflictsMap.values());\n      assertEquals(conflictMessage, conflicts.iterator().next());\n      return;\n    }\n\n    if (checkMembersMovedCount) {\n      assertEquals(countMoved[0], membersToFind.length);\n    }\n    checkResultByFile(BASE_PATH + getTestName(false) + \"_after.java\");\n  }","commit_id":"0936ad00fd3e7d1d33e8fb3ff384aa6b05e9df0a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Checks whether given element is below the given superClass in class hierarchy.\n   * @param superClass\n   * @return\n   * @param subClass\n   * @param member\n   */\n  public static boolean isMemberBetween(PsiClass superClass, PsiClass subClass, PsiMember member) {\n    PsiClass elementClass = null;\n    if (member instanceof PsiField || member instanceof PsiMethod) {\n      elementClass = member.getContainingClass();\n    }\n\n    if (elementClass == null) return false;\n    if (superClass != null) {\n      return !superClass.getManager().areElementsEquivalent(superClass, elementClass) &&\n             elementClass.isInheritor(superClass, true);\n    }\n    else {\n      return subClass.getManager().areElementsEquivalent(subClass, elementClass);\n    }\n  }","id":67020,"modified_method":"/**\n   * Checks whether given element is below the given superClass in class hierarchy.\n   * @param superClass\n   * @return\n   * @param subClass\n   * @param member\n   */\n  public static boolean isMemberBetween(PsiClass superClass, PsiClass subClass, PsiMember member) {\n    PsiClass elementClass = null;\n    if (member instanceof PsiField || member instanceof PsiMethod) {\n      elementClass = member.getContainingClass();\n    }\n\n    if (elementClass == null) return false;\n    if (superClass != null) {\n      if (elementClass.isInheritor(superClass, true)) {\n        return !superClass.getManager().areElementsEquivalent(superClass, elementClass);\n      }\n      return PsiTreeUtil.isAncestor(elementClass, subClass, false) && !PsiTreeUtil.isAncestor(elementClass, superClass, false);\n    }\n    else {\n      return subClass.getManager().areElementsEquivalent(subClass, elementClass);\n    }\n  }","commit_id":"0936ad00fd3e7d1d33e8fb3ff384aa6b05e9df0a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public CandidateInfo resolveConflict(List<CandidateInfo> conflicts){\n    final int size = conflicts.size();\n    if(size == 1){\n      return conflicts.get(0);\n    }\n    if (size == 0) {\n      return null;\n    }\n    final CandidateInfo[] uncheckedResult = conflicts.toArray(new CandidateInfo[size]);\n    CandidateInfo currentResult = uncheckedResult[0];\n\n    PsiElement currentElement = currentResult.getElement();\n    if(currentElement instanceof PsiField){\n      for (int i = 1; i < uncheckedResult.length; i++) {\n        final CandidateInfo candidate = uncheckedResult[i];\n        final PsiElement otherElement = candidate.getElement();\n        if (otherElement == null) continue;\n\n        if (!(otherElement instanceof PsiField)) {\n          if (otherElement instanceof PsiLocalVariable) {\n            return candidate;\n          }\n          else {\n            if (!currentResult.isAccessible()) return candidate;\n            conflicts.remove(candidate);\n            continue;\n          }\n        }\n\n        final PsiClass newClass = ((PsiField)otherElement).getContainingClass();\n        final PsiClass oldClass = ((PsiField)currentElement).getContainingClass();\n\n        final PsiElement scope = currentResult.getCurrentFileResolveScope();\n        Boolean oldClassIsInheritor = null;\n        if (newClass.isInheritor(oldClass, true)) {\n          if (!(scope instanceof PsiClass) ||\n              scope.equals(oldClass) ||\n              scope.equals(newClass) ||\n              !((PsiClass)scope).isInheritorDeep(oldClass, newClass)) {\n            // candidate is better\n            conflicts.remove(currentResult);\n            currentResult = candidate;\n            currentElement = currentResult.getElement();\n            continue;\n          }\n        }\n        else if (oldClassIsInheritor = oldClass.isInheritor(newClass, true)) {\n          if (!(scope instanceof PsiClass) ||\n              scope.equals(oldClass) ||\n              scope.equals(newClass) ||\n              !((PsiClass)scope).isInheritorDeep(newClass, oldClass)) {\n            // candidate is worse\n            conflicts.remove(candidate);\n            continue;\n          }\n        }\n\n        if (!candidate.isAccessible()) {\n          conflicts.remove(candidate);\n          continue;\n        }\n        if (!currentResult.isAccessible()) {\n          conflicts.remove(currentResult);\n          currentResult = candidate;\n          currentElement = currentResult.getElement();\n          continue;\n        }\n\n        //This test should go last\n        if (otherElement == currentElement) {\n          conflicts.remove(candidate);\n          continue;\n        }\n\n        if (oldClassIsInheritor == null) {\n          oldClassIsInheritor = oldClass.isInheritor(newClass, true);\n        }\n        if (oldClassIsInheritor) {\n          // both fields are accessible\n          // field in derived hides field in base\n          conflicts.remove(candidate);\n          continue;\n        }\n        return null;\n      }\n    }\n    return currentResult;\n  }","id":67021,"modified_method":"@Override\n  public CandidateInfo resolveConflict(List<CandidateInfo> conflicts){\n    final int size = conflicts.size();\n    if(size == 1){\n      return conflicts.get(0);\n    }\n    if (size == 0) {\n      return null;\n    }\n    final CandidateInfo[] uncheckedResult = conflicts.toArray(new CandidateInfo[size]);\n    CandidateInfo currentResult = uncheckedResult[0];\n\n    PsiElement currentElement = currentResult.getElement();\n    if(currentElement instanceof PsiField){\n      for (int i = 1; i < uncheckedResult.length; i++) {\n        final CandidateInfo candidate = uncheckedResult[i];\n        final PsiElement otherElement = candidate.getElement();\n        if (otherElement == null) continue;\n\n        if (!(otherElement instanceof PsiField)) {\n          if (otherElement instanceof PsiLocalVariable) {\n            return candidate;\n          }\n          else {\n            if (!currentResult.isAccessible()) return candidate;\n            conflicts.remove(candidate);\n            continue;\n          }\n        }\n\n        final PsiClass newClass = ((PsiField)otherElement).getContainingClass();\n        final PsiClass oldClass = ((PsiField)currentElement).getContainingClass();\n\n        final PsiElement scope = currentResult.getCurrentFileResolveScope();\n        Boolean oldClassIsInheritor = null;\n        if (newClass != null && oldClass != null) {\n          if (newClass.isInheritor(oldClass, true)) {\n            if (!(scope instanceof PsiClass) ||\n                scope.equals(oldClass) ||\n                scope.equals(newClass) ||\n                !((PsiClass)scope).isInheritorDeep(oldClass, newClass)) {\n              // candidate is better\n              conflicts.remove(currentResult);\n              currentResult = candidate;\n              currentElement = currentResult.getElement();\n              continue;\n            }\n          }\n          else if (oldClassIsInheritor = oldClass.isInheritor(newClass, true)) {\n            if (!(scope instanceof PsiClass) ||\n                scope.equals(oldClass) ||\n                scope.equals(newClass) ||\n                !((PsiClass)scope).isInheritorDeep(newClass, oldClass)) {\n              // candidate is worse\n              conflicts.remove(candidate);\n              continue;\n            }\n          }\n        }\n\n        if (!candidate.isAccessible()) {\n          conflicts.remove(candidate);\n          continue;\n        }\n        if (!currentResult.isAccessible()) {\n          conflicts.remove(currentResult);\n          currentResult = candidate;\n          currentElement = currentResult.getElement();\n          continue;\n        }\n\n        //This test should go last\n        if (otherElement == currentElement) {\n          conflicts.remove(candidate);\n          continue;\n        }\n\n        if (oldClassIsInheritor == null) {\n          oldClassIsInheritor = oldClass != null && newClass != null && oldClass.isInheritor(newClass, true);\n        }\n        if (oldClassIsInheritor) {\n          // both fields are accessible\n          // field in derived hides field in base\n          conflicts.remove(candidate);\n          continue;\n        }\n        return null;\n      }\n    }\n    return currentResult;\n  }","commit_id":"527ce9d6a148e9e81baa145fb1b0e9cc53d2505f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void completeReference(CompletionParameters parameters, final CompletionResultSet result, GrReferenceElement reference) {\n    PsiElement position = parameters.getPosition();\n\n    final InheritorsHolder inheritors = new InheritorsHolder(position, result);\n    if (GroovySmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      GroovySmartCompletionContributor.generateInheritorVariants(parameters, result.getPrefixMatcher(), inheritors);\n    }\n\n    final int invocationCount = parameters.getInvocationCount();\n    final boolean secondCompletionInvoked = CodeInsightSettings.getInstance().AUTOCOMPLETE_ON_CODE_COMPLETION ? invocationCount > 0 : invocationCount > 1;\n\n    final String prefix = result.getPrefixMatcher().getPrefix();\n    final boolean skipAccessors = !secondCompletionInvoked && !prefix.startsWith(GET_PREFIX) &&\n                                  !prefix.startsWith(SET_PREFIX) &&\n                                  !prefix.startsWith(IS_PREFIX);\n\n\n    result.restartCompletionOnPrefixChange(GET_PREFIX);\n    result.restartCompletionOnPrefixChange(SET_PREFIX);\n    result.restartCompletionOnPrefixChange(IS_PREFIX);\n    final Map<PsiModifierListOwner, LookupElement> staticMembers = hashMap();\n    reference.processVariants(new Consumer<Object>() {\n      public void consume(Object element) {\n        if (element instanceof PsiClass && inheritors.alreadyProcessed((PsiClass)element)) {\n          return;\n        }\n        if (element instanceof LookupElement && inheritors.alreadyProcessed((LookupElement)element)) {\n          return;\n        }\n\n        final LookupElement lookupElement = element instanceof PsiClass\n                                            ? GroovyCompletionUtil.createClassLookupItem((PsiClass)element)\n                                            : GroovyCompletionUtil.getLookupElement(element);\n        Object object = lookupElement.getObject();\n        PsiSubstitutor substitutor = null;\n        if (object instanceof GroovyResolveResult) {\n          substitutor = ((GroovyResolveResult)object).getSubstitutor();\n          object = ((GroovyResolveResult)object).getElement();\n        }\n\n        //skip default groovy methods\n        if (!secondCompletionInvoked &&\n            object instanceof GrGdkMethod &&\n            GroovyCompletionUtil.skipDefGroovyMethod((GrGdkMethod)object, substitutor)) {\n          showInfo();\n          return;\n        }\n\n        //skip operator methods\n        if (!secondCompletionInvoked &&\n            object instanceof PsiMethod &&\n            GroovyCompletionUtil.OPERATOR_METHOD_NAMES.contains(((PsiMethod)object).getName())) {\n          if (!checkForIterator((PsiMethod)object)) {\n            showInfo();\n            return;\n          }\n        }\n\n        //skip accessors if there is no get, set, is prefix\n        if (skipAccessors && object instanceof PsiMethod && GroovyPropertyUtils.isSimplePropertyAccessor((PsiMethod)object)) {\n          showInfo();\n          return;\n        }\n\n        if ((object instanceof PsiMethod || object instanceof PsiField) &&\n            ((PsiModifierListOwner)object).hasModifierProperty(PsiModifier.STATIC)) {\n          if (lookupElement.getLookupString().equals(((PsiMember)object).getName())) {\n            staticMembers.put((PsiModifierListOwner)object, lookupElement);\n            return;\n          }\n        }\n        result.addElement(lookupElement);\n      }\n    });\n\n    if (reference.getQualifier() == null) {\n      completeStaticMembers(position).processMembersOfRegisteredClasses(null, new PairConsumer<PsiMember, PsiClass>() {\n        @Override\n        public void consume(PsiMember member, PsiClass psiClass) {\n          if (member instanceof GrAccessorMethod) {\n            member = ((GrAccessorMethod)member).getProperty();\n          }\n          final String name = member.getName();\n          if (name == null || !result.getPrefixMatcher().prefixMatches(name)) {\n            staticMembers.remove(member);\n            return;\n          }\n          staticMembers.put(member, new JavaGlobalMemberLookupElement(member, psiClass, QUALIFIED_METHOD_INSERT_HANDLER, STATIC_IMPORT_INSERT_HANDLER, true));\n\n        }\n      });\n\n      final String s = result.getPrefixMatcher().getPrefix();\n      if (!StringUtil.isEmpty(s) && Character.isUpperCase(s.charAt(0))) {\n        addAllClasses(parameters, result, inheritors);\n      }\n    }\n    result.addAllElements(staticMembers.values());\n  }","id":67022,"modified_method":"private static void completeReference(CompletionParameters parameters, final CompletionResultSet result, GrReferenceElement reference) {\n    PsiElement position = parameters.getPosition();\n\n    final InheritorsHolder inheritors = new InheritorsHolder(position, result);\n    if (GroovySmartCompletionContributor.AFTER_NEW.accepts(position)) {\n      GroovySmartCompletionContributor.generateInheritorVariants(parameters, result.getPrefixMatcher(), inheritors);\n    }\n\n    final int invocationCount = parameters.getInvocationCount();\n    final boolean secondCompletionInvoked = CodeInsightSettings.getInstance().AUTOCOMPLETE_ON_CODE_COMPLETION ? invocationCount > 0 : invocationCount > 1;\n\n    final String prefix = result.getPrefixMatcher().getPrefix();\n    final boolean skipAccessors = !secondCompletionInvoked && !prefix.startsWith(GET_PREFIX) &&\n                                  !prefix.startsWith(SET_PREFIX) &&\n                                  !prefix.startsWith(IS_PREFIX);\n\n\n    result.restartCompletionOnPrefixChange(GET_PREFIX);\n    result.restartCompletionOnPrefixChange(SET_PREFIX);\n    result.restartCompletionOnPrefixChange(IS_PREFIX);\n    final Map<PsiModifierListOwner, LookupElement> staticMembers = hashMap();\n    final PsiElement qualifier = reference.getQualifier();\n    final PsiType qualifierType;\n    if (qualifier instanceof GrExpression) {\n      qualifierType = ((GrExpression)qualifier).getType();\n    }\n    else {\n      qualifierType = null;\n    }\n    reference.processVariants(new Consumer<Object>() {\n      public void consume(Object element) {\n        if (element instanceof PsiClass && inheritors.alreadyProcessed((PsiClass)element)) {\n          return;\n        }\n        if (element instanceof LookupElement && inheritors.alreadyProcessed((LookupElement)element)) {\n          return;\n        }\n\n        final LookupElement lookupElement = element instanceof PsiClass\n                                            ? GroovyCompletionUtil.createClassLookupItem((PsiClass)element)\n                                            : GroovyCompletionUtil.getLookupElement(element);\n        Object object = lookupElement.getObject();\n        PsiSubstitutor substitutor = null;\n        if (object instanceof GroovyResolveResult) {\n          substitutor = ((GroovyResolveResult)object).getSubstitutor();\n          object = ((GroovyResolveResult)object).getElement();\n        }\n\n        //skip default groovy methods\n        if (!secondCompletionInvoked &&\n            object instanceof GrGdkMethod &&\n            GroovyCompletionUtil.skipDefGroovyMethod((GrGdkMethod)object, substitutor, qualifierType)) {\n          showInfo();\n          return;\n        }\n\n        //skip operator methods\n        if (!secondCompletionInvoked &&\n            object instanceof PsiMethod &&\n            GroovyCompletionUtil.OPERATOR_METHOD_NAMES.contains(((PsiMethod)object).getName())) {\n          if (!checkForIterator((PsiMethod)object)) {\n            showInfo();\n            return;\n          }\n        }\n\n        //skip accessors if there is no get, set, is prefix\n        if (skipAccessors && object instanceof PsiMethod && GroovyPropertyUtils.isSimplePropertyAccessor((PsiMethod)object)) {\n          showInfo();\n          return;\n        }\n\n        if ((object instanceof PsiMethod || object instanceof PsiField) &&\n            ((PsiModifierListOwner)object).hasModifierProperty(PsiModifier.STATIC)) {\n          if (lookupElement.getLookupString().equals(((PsiMember)object).getName())) {\n            staticMembers.put((PsiModifierListOwner)object, lookupElement);\n            return;\n          }\n        }\n        result.addElement(lookupElement);\n      }\n    });\n\n    if (qualifier == null) {\n      completeStaticMembers(position).processMembersOfRegisteredClasses(null, new PairConsumer<PsiMember, PsiClass>() {\n        @Override\n        public void consume(PsiMember member, PsiClass psiClass) {\n          if (member instanceof GrAccessorMethod) {\n            member = ((GrAccessorMethod)member).getProperty();\n          }\n          final String name = member.getName();\n          if (name == null || !result.getPrefixMatcher().prefixMatches(name)) {\n            staticMembers.remove(member);\n            return;\n          }\n          staticMembers.put(member, new JavaGlobalMemberLookupElement(member, psiClass, QUALIFIED_METHOD_INSERT_HANDLER, STATIC_IMPORT_INSERT_HANDLER, true));\n\n        }\n      });\n\n      final String s = result.getPrefixMatcher().getPrefix();\n      if (!StringUtil.isEmpty(s) && Character.isUpperCase(s.charAt(0))) {\n        addAllClasses(parameters, result, inheritors);\n      }\n    }\n    result.addAllElements(staticMembers.values());\n  }","commit_id":"6a3598a859d6a5585038d1988b5cf1e53baaf9ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean skipDefGroovyMethod(GrGdkMethod gdkMethod, PsiSubstitutor substitutor) {\n    String name = gdkMethod.getStaticMethod().getName();\n\n    final PsiType baseType = gdkMethod.getStaticMethod().getParameterList().getParameters()[0].getType();\n    if (!TypeConversionUtil.erasure(baseType).equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) return false;\n\n    final PsiType type = substitutor != null ? substitutor.substitute(baseType) : baseType;\n\n    if (COLLECTION_METHOD_NAMES.contains(name)) {\n      return !(type instanceof PsiArrayType) && !InheritanceUtil.isInheritor(type, CommonClassNames.JAVA_LANG_ITERABLE);\n    }\n    if (\"with\".equals(name)) return false;\n\n    return true;\n  }","id":67023,"modified_method":"public static boolean skipDefGroovyMethod(GrGdkMethod gdkMethod, PsiSubstitutor substitutor, @Nullable PsiType type) {\n    if (type == null) return false;\n    String name = gdkMethod.getStaticMethod().getName();\n\n    final PsiType baseType = gdkMethod.getStaticMethod().getParameterList().getParameters()[0].getType();\n    if (!TypeConversionUtil.erasure(baseType).equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) return false;\n\n    final PsiType substituted = substitutor != null ? substitutor.substitute(baseType) : baseType;\n\n    if (COLLECTION_METHOD_NAMES.contains(name)) {\n      return !(type instanceof PsiArrayType ||\n               InheritanceUtil.isInheritor(type, CommonClassNames.JAVA_LANG_ITERABLE) ||\n               substituted instanceof PsiArrayType ||\n               InheritanceUtil.isInheritor(substituted, CommonClassNames.JAVA_LANG_ITERABLE));\n    }\n    if (\"with\".equals(name)) return false;\n\n    return true;\n  }","commit_id":"6a3598a859d6a5585038d1988b5cf1e53baaf9ea","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ClassResolverProcessor(String className, PsiElement place) {\n    myClassName = className;\n    myPlace = place;\n    final PsiFile file = myPlace.getContainingFile();\n    if (file instanceof JavaCodeFragment) {\n      if (((JavaCodeFragment)file).getVisibilityChecker() != null) myPlace = null;\n    }\n    if (place instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression expression = (PsiReferenceExpression)place;\n      final PsiExpression qualifierExpression = expression.getQualifierExpression();\n      if (qualifierExpression != null) {\n        final PsiType type = qualifierExpression.getType();\n        if (type instanceof PsiClassType) {\n          myAccessClass = ((PsiClassType)type).resolve();\n        }\n      }\n    }\n  }","id":67024,"modified_method":"public ClassResolverProcessor(String className, PsiElement place) {\n    myClassName = className;\n    final PsiFile file = place.getContainingFile();\n    if (file instanceof JavaCodeFragment) {\n      if (((JavaCodeFragment)file).getVisibilityChecker() != null) place = null;\n    }\n    myPlace = place;\n    if (place instanceof PsiReferenceExpression) {\n      final PsiReferenceExpression expression = (PsiReferenceExpression)place;\n      final PsiExpression qualifierExpression = expression.getQualifierExpression();\n      if (qualifierExpression != null) {\n        final PsiType type = qualifierExpression.getType();\n        if (type instanceof PsiClassType) {\n          myAccessClass = ((PsiClassType)type).resolve();\n        }\n      }\n    }\n  }","commit_id":"028ee2d46a2efa60186d752c6efdada95405b429","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JavaResolveResult[] getResult(){\n    if(myCachedResult == null){\n      final SmartList<CandidateInfo> conflicts = super.getResults();\n      for (PsiConflictResolver resolver : myResolvers) {\n        CandidateInfo candidate = resolver.resolveConflict(conflicts);\n        if (candidate != null) {\n          conflicts.clear();\n          conflicts.add(candidate);\n          break;\n        }\n      }\n      myCachedResult = conflicts.toArray(new JavaResolveResult[conflicts.size()]);\n    }\n\n    return myCachedResult;\n  }","id":67025,"modified_method":"public JavaResolveResult[] getResult(){\n    if(myCachedResult == null){\n      final SmartList<CandidateInfo> conflicts = getResults();\n      for (PsiConflictResolver resolver : myResolvers) {\n        CandidateInfo candidate = resolver.resolveConflict(conflicts);\n        if (candidate != null) {\n          conflicts.clear();\n          conflicts.add(candidate);\n          break;\n        }\n      }\n      myCachedResult = conflicts.toArray(new JavaResolveResult[conflicts.size()]);\n    }\n\n    return myCachedResult;\n  }","commit_id":"028ee2d46a2efa60186d752c6efdada95405b429","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void handleEvent(Event event, Object associated){\n    if(event == JavaScopeProcessorEvent.CHANGE_LEVEL && myName != null){\n      myCachedResult = getResult();\n    }\n  }","id":67026,"modified_method":"public void handleEvent(Event event, Object associated){\n    if(event == JavaScopeProcessorEvent.CHANGE_LEVEL && myName != null){\n      getResult();\n    }\n  }","commit_id":"028ee2d46a2efa60186d752c6efdada95405b429","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public CandidateInfo resolveConflict(List<CandidateInfo> conflicts){\n    final int size = conflicts.size();\n    if(size == 1){\n      return conflicts.get(0);\n    }\n    if(size > 0){\n      final CandidateInfo[] uncheckedResult = conflicts.toArray(new CandidateInfo[size]);\n      CandidateInfo currentResult = uncheckedResult[0];\n\n      PsiElement currentElement = currentResult.getElement();\n      if(currentElement instanceof PsiField){\n        for (int i = 1; i < uncheckedResult.length; i++) {\n          final CandidateInfo candidate = uncheckedResult[i];\n          final PsiElement otherElement = candidate.getElement();\n          if (otherElement == null) continue;\n\n          if (!(otherElement instanceof PsiField)) {\n            if (otherElement instanceof PsiLocalVariable) {\n              return candidate;\n            }\n            else {\n              if (!currentResult.isAccessible()) return candidate;\n              conflicts.remove(candidate);\n              continue;\n            }\n          }\n\n          final PsiClass newClass = ((PsiField)otherElement).getContainingClass();\n          final PsiClass oldClass = ((PsiField)currentElement).getContainingClass();\n\n          final PsiElement scope = currentResult.getCurrentFileResolveScope();\n          if (newClass.isInheritor(oldClass, true)) {\n            if (!(scope instanceof PsiClass) ||\n                scope.equals(oldClass) ||\n                scope.equals(newClass) ||\n                !((PsiClass)scope).isInheritorDeep(oldClass, newClass)) {\n              // candidate is better\n              conflicts.remove(currentResult);\n              currentResult = candidate;\n              currentElement = currentResult.getElement();\n              continue;\n            }\n          }\n          else if (oldClass.isInheritor(newClass, true)) {\n            if (!(scope instanceof PsiClass) ||\n                scope.equals(oldClass) ||\n                scope.equals(newClass) ||\n                !((PsiClass)scope).isInheritorDeep(newClass, oldClass)) {\n              // candidate is worse\n              conflicts.remove(candidate);\n              continue;\n            }\n          }\n\n          if (!candidate.isAccessible()) {\n            conflicts.remove(candidate);\n            continue;\n          }\n          if (!currentResult.isAccessible()) {\n            conflicts.remove(currentResult);\n            currentResult = candidate;\n            currentElement = currentResult.getElement();\n            continue;\n          }\n\n          //This test should go last\n          if (otherElement == currentElement) {\n            conflicts.remove(candidate);\n            continue;\n          }\n\n          return null;\n        }\n      }\n      return currentResult;\n    }\n    return null;\n  }","id":67027,"modified_method":"public CandidateInfo resolveConflict(List<CandidateInfo> conflicts){\n    final int size = conflicts.size();\n    if(size == 1){\n      return conflicts.get(0);\n    }\n    if (size == 0) {\n      return null;\n    }\n    final CandidateInfo[] uncheckedResult = conflicts.toArray(new CandidateInfo[size]);\n    CandidateInfo currentResult = uncheckedResult[0];\n\n    PsiElement currentElement = currentResult.getElement();\n    if(currentElement instanceof PsiField){\n      for (int i = 1; i < uncheckedResult.length; i++) {\n        final CandidateInfo candidate = uncheckedResult[i];\n        final PsiElement otherElement = candidate.getElement();\n        if (otherElement == null) continue;\n\n        if (!(otherElement instanceof PsiField)) {\n          if (otherElement instanceof PsiLocalVariable) {\n            return candidate;\n          }\n          else {\n            if (!currentResult.isAccessible()) return candidate;\n            conflicts.remove(candidate);\n            continue;\n          }\n        }\n\n        final PsiClass newClass = ((PsiField)otherElement).getContainingClass();\n        final PsiClass oldClass = ((PsiField)currentElement).getContainingClass();\n\n        final PsiElement scope = currentResult.getCurrentFileResolveScope();\n        Boolean oldClassIsInheritor = null;\n        if (newClass.isInheritor(oldClass, true)) {\n          if (!(scope instanceof PsiClass) ||\n              scope.equals(oldClass) ||\n              scope.equals(newClass) ||\n              !((PsiClass)scope).isInheritorDeep(oldClass, newClass)) {\n            // candidate is better\n            conflicts.remove(currentResult);\n            currentResult = candidate;\n            currentElement = currentResult.getElement();\n            continue;\n          }\n        }\n        else if (oldClassIsInheritor = oldClass.isInheritor(newClass, true)) {\n          if (!(scope instanceof PsiClass) ||\n              scope.equals(oldClass) ||\n              scope.equals(newClass) ||\n              !((PsiClass)scope).isInheritorDeep(newClass, oldClass)) {\n            // candidate is worse\n            conflicts.remove(candidate);\n            continue;\n          }\n        }\n\n        if (!candidate.isAccessible()) {\n          conflicts.remove(candidate);\n          continue;\n        }\n        if (!currentResult.isAccessible()) {\n          conflicts.remove(currentResult);\n          currentResult = candidate;\n          currentElement = currentResult.getElement();\n          continue;\n        }\n\n        //This test should go last\n        if (otherElement == currentElement) {\n          conflicts.remove(candidate);\n          continue;\n        }\n\n        if (oldClassIsInheritor == null) {\n          oldClassIsInheritor = oldClass.isInheritor(newClass, true);\n        }\n        if (oldClassIsInheritor) {\n          // both fields are accessible\n          // field in derived hides field in base\n          conflicts.remove(candidate);\n          continue;\n        }\n        return null;\n      }\n    }\n    return currentResult;\n  }","commit_id":"028ee2d46a2efa60186d752c6efdada95405b429","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void add(PsiElement element, PsiSubstitutor substitutor) {\n    final boolean staticProblem = myStaticScopeFlag && !((PsiModifierListOwner)element).hasModifierProperty(PsiModifier.STATIC);\n    super.add(new CandidateInfo(element, substitutor, myPlace, myAccessClass, staticProblem, myCurrentFileContext));\n  }","id":67028,"modified_method":"public void add(PsiElement element, PsiSubstitutor substitutor) {\n    final boolean staticProblem = myStaticScopeFlag && !((PsiModifierListOwner)element).hasModifierProperty(PsiModifier.STATIC);\n    add(new CandidateInfo(element, substitutor, myPlace, myAccessClass, staticProblem, myCurrentFileContext));\n  }","commit_id":"028ee2d46a2efa60186d752c6efdada95405b429","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof PsiTypeElement)) {\n      return false;\n    }\n    final PsiElement parent = element.getParent();\n    if (!(parent instanceof PsiVariable)) {\n      return false;\n    }\n    final PsiVariable variable = (PsiVariable)parent;\n    final PsiExpression initializer = variable.getInitializer();\n    if (!(initializer instanceof PsiNewExpression)) {\n      return false;\n    }\n    final PsiType type = variable.getType();\n    if (!(type instanceof PsiClassType)) {\n      return false;\n    }\n    final PsiType initializerType = initializer.getType();\n    if (!(initializerType instanceof PsiClassType)) {\n      return false;\n    }\n    final PsiClassType initializerClassType = (PsiClassType)initializerType;\n    final PsiClass initializerClass = initializerClassType.resolve();\n    if (initializerClass == null) {\n      return false;\n    }\n    final PsiClassType classType = (PsiClassType)type;\n    final PsiClass variableClass = classType.resolve();\n    if (variableClass == null) {\n      return false;\n    }\n    return initializerClass.isInheritor(variableClass, true);\n  }","id":67029,"modified_method":"@Override\n  public boolean satisfiedBy(PsiElement element) {\n    if (!(element instanceof PsiTypeElement)) {\n      return false;\n    }\n    final PsiElement parent = element.getParent();\n    if (!(parent instanceof PsiVariable)) {\n      return false;\n    }\n    final PsiVariable variable = (PsiVariable)parent;\n    final PsiExpression initializer = variable.getInitializer();\n    if (!(initializer instanceof PsiNewExpression)) {\n      return false;\n    }\n    final PsiType type = variable.getType();\n    if (!(type instanceof PsiClassType)) {\n      return false;\n    }\n    final PsiType initializerType = initializer.getType();\n    if (!(initializerType instanceof PsiClassType)) {\n      return false;\n    }\n    final PsiClassType initializerClassType = (PsiClassType)initializerType;\n    PsiClass initializerClass = initializerClassType.resolve();\n    if (initializerClass instanceof PsiAnonymousClass) {\n      initializerClass = initializerClass.getSuperClass();\n    }\n    if (initializerClass == null) {\n      return false;\n    }\n    final PsiClassType classType = (PsiClassType)type;\n    final PsiClass variableClass = classType.resolve();\n    if (variableClass == null) {\n      return false;\n    }\n    if (variableClass.equals(initializerClass)) {\n      return false;\n    }\n    if (!initializerClass.isInheritor(variableClass, true)) {\n      return false;\n    }\n    return true;\n  }","commit_id":"e65779a8fb9bcc90ddea4ecfe83251516f5799e9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Test\n    public void testRebindOneSimple() throws Exception {\n        TestEntity c1 = origApp.addChild(EntitySpec.create(TestEntity.class));\n        Entities.manage(c1);\n        AbstractEntity c1r = Entities.deproxy(c1);\n        \n        doPartialRebindOfIds(c1.getId());\n        \n        BrooklynObject c2 = origManagementContext.lookup(c1.getId());\n        AbstractEntity c2r = Entities.deproxy((Entity)c2);\n        \n        Assert.assertTrue(c2 == c1, \"Proxy instance should be the same: \"+c1+\" / \"+c2);\n        Assert.assertFalse(c2r == c1r, \"Real instance should NOT be the same: \"+c1r+\" / \"+c2r);\n    }","id":67030,"modified_method":"@Test\n    public void testRebindChildSimple() throws Exception {\n        TestEntity c1 = origApp.addChild(EntitySpec.create(TestEntity.class));\n        Entities.manage(c1);\n        AbstractEntity c1r = Entities.deproxy(c1);\n        \n        doPartialRebindOfIds(c1.getId());\n        \n        BrooklynObject c2 = origManagementContext.lookup(c1.getId());\n        AbstractEntity c2r = Entities.deproxy((Entity)c2);\n        \n        Assert.assertTrue(c2 == c1, \"Proxy instance should be the same: \"+c1+\" / \"+c2);\n        Assert.assertFalse(c2r == c1r, \"Real instance should NOT be the same: \"+c1r+\" / \"+c2r);\n    }","commit_id":"35142c8049d3068775f448d6c48edeb365f53bfa","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@SuppressWarnings(\"deprecation\")\n    public void onManagementStopping(ManagementTransitionInfo info) {\n        synchronized (this) {\n            if (managementContext != info.getManagementContext()) {\n                throw new IllegalStateException(\"Has different management context: \"+managementContext+\"; expected \"+info.getManagementContext());\n            }\n            Stopwatch startTime = Stopwatch.createStarted();\n            while (!managementFailed.get() && nonDeploymentManagementContext!=null && \n                    nonDeploymentManagementContext.getMode()==NonDeploymentManagementContextMode.MANAGEMENT_STARTING) {\n                // still becoming managed\n                try {\n                    if (startTime.elapsed(TimeUnit.SECONDS) > 30) {\n                        // emergency fix, 30s timeout for management starting\n                        log.error(\"Management stopping event \"+info+\" in \"+this+\" timed out waiting for start; proceeding to stopping\");\n                        break;\n                    }\n                    wait(100);\n                } catch (InterruptedException e) {\n                    Exceptions.propagate(e);\n                }\n            }\n            if (nonDeploymentManagementContext==null) {\n                nonDeploymentManagementContext = new NonDeploymentManagementContext(entity, NonDeploymentManagementContextMode.MANAGEMENT_STOPPING);\n            } else {\n                // already stopped? or not started?\n                nonDeploymentManagementContext.setMode(NonDeploymentManagementContext.NonDeploymentManagementContextMode.MANAGEMENT_STOPPING);\n            }\n        }\n        // TODO custom stopping activities\n        // TODO framework stopping events - no more sensors, executions, etc\n        // (elaborate or remove ^^^ ? -AH, Sept 2014)\n        \n        if (!isReadOnly() && info.getMode().isDestroying()) {\n            // if we support remote parent of local child, the following call will need to be properly remoted\n            if (entity.getParent()!=null) entity.getParent().removeChild(entity.getProxyIfAvailable());\n        }\n        // new subscriptions will be queued / not allowed\n        nonDeploymentManagementContext.getSubscriptionManager().stopDelegatingForSubscribing();\n        // new publications will be queued / not allowed\n        nonDeploymentManagementContext.getSubscriptionManager().stopDelegatingForPublishing();\n        \n        if (!isReadOnly()) {\n            entity.onManagementNoLongerMaster();\n            entity.onManagementStopped();\n        }\n    }","id":67031,"modified_method":"@SuppressWarnings(\"deprecation\")\n    public void onManagementStopping(ManagementTransitionInfo info) {\n        synchronized (this) {\n            if (managementContext != info.getManagementContext()) {\n                throw new IllegalStateException(\"onManagementStopping encountered different management context for \"+entity+\n                    (!wasDeployed() ? \" (wasn't deployed)\" : !isDeployed() ? \" (no longer deployed)\" : \"\")+\n                    \": \"+managementContext+\"; expected \"+info.getManagementContext());\n            }\n            Stopwatch startTime = Stopwatch.createStarted();\n            while (!managementFailed.get() && nonDeploymentManagementContext!=null && \n                    nonDeploymentManagementContext.getMode()==NonDeploymentManagementContextMode.MANAGEMENT_STARTING) {\n                // still becoming managed\n                try {\n                    if (startTime.elapsed(TimeUnit.SECONDS) > 30) {\n                        // emergency fix, 30s timeout for management starting\n                        log.error(\"Management stopping event \"+info+\" in \"+this+\" timed out waiting for start; proceeding to stopping\");\n                        break;\n                    }\n                    wait(100);\n                } catch (InterruptedException e) {\n                    Exceptions.propagate(e);\n                }\n            }\n            if (nonDeploymentManagementContext==null) {\n                nonDeploymentManagementContext = new NonDeploymentManagementContext(entity, NonDeploymentManagementContextMode.MANAGEMENT_STOPPING);\n            } else {\n                // already stopped? or not started?\n                nonDeploymentManagementContext.setMode(NonDeploymentManagementContext.NonDeploymentManagementContextMode.MANAGEMENT_STOPPING);\n            }\n        }\n        // TODO custom stopping activities\n        // TODO framework stopping events - no more sensors, executions, etc\n        // (elaborate or remove ^^^ ? -AH, Sept 2014)\n        \n        if (!isReadOnly() && info.getMode().isDestroying()) {\n            // if we support remote parent of local child, the following call will need to be properly remoted\n            if (entity.getParent()!=null) entity.getParent().removeChild(entity.getProxyIfAvailable());\n        }\n        // new subscriptions will be queued / not allowed\n        nonDeploymentManagementContext.getSubscriptionManager().stopDelegatingForSubscribing();\n        // new publications will be queued / not allowed\n        nonDeploymentManagementContext.getSubscriptionManager().stopDelegatingForPublishing();\n        \n        if (!isReadOnly()) {\n            entity.onManagementNoLongerMaster();\n            entity.onManagementStopped();\n        }\n    }","commit_id":"35142c8049d3068775f448d6c48edeb365f53bfa","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public void testLocationsStillManagedCorrectlyAfterDoublePromotion() throws NoMachinesAvailableException {\n        HighAvailabilityManagerImpl ha = (HighAvailabilityManagerImpl) managementContext.getHighAvailabilityManager();\n        ha.start(HighAvailabilityMode.MASTER);\n        \n        TestApplication app = TestApplication.Factory.newManagedInstanceForTests(managementContext);\n        \n        LocalhostMachineProvisioningLocation l = app.newLocalhostProvisioningLocation();\n        l.setConfig(TestEntity.CONF_NAME, \"sample1\");\n        Assert.assertEquals(l.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        \n        SshMachineLocation l2 = l.obtain();\n        Assert.assertEquals(l2.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        Assert.assertNotNull(l2.getParent(), \"Parent not set after dodgy promoteToMaster\");\n        Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), \"sample1\");\n\n        TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));\n        log.info(\"Entities managed are: \"+managementContext.getEntityManager().getEntities());\n        Collection<Location> le = entity.getLocations();\n        log.info(\"Locs at entity are: \"+le);\n        Collection<Location> lm = managementContext.getLocationManager().getLocations();\n        log.info(\"Locs managed are: \"+lm);\n        log.info(\"            objs: \"+identities(lm));\n        \n        managementContext.getRebindManager().forcePersistNow(true, null);\n        log.info(\"DODGY extra promoteToMaster\");\n        ha.promoteToMaster();\n        \n        log.info(\"Entities managed are: \"+managementContext.getEntityManager().getEntities());\n        Collection<Location> lle = entity.getLocations();\n        log.info(\"Locs at entity(old) are: \"+lle);\n        log.info(\"                   objs: \"+identities(lle));\n        \n        // assert what's in the location manager is accurate\n        Collection<Location> llmm = managementContext.getLocationManager().getLocations();\n        log.info(\"Locs managed are: \"+llmm);\n        log.info(\"            objs: \"+identities(llmm));\n        Assert.assertEquals(llmm, lm);\n        SshMachineLocation ll2a = Iterables.getOnlyElement(Iterables.filter(llmm, SshMachineLocation.class));\n        Assert.assertEquals(ll2a.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        Assert.assertNotNull(ll2a.getParent(), \"Parent not set after dodgy promoteToMaster\");\n        Assert.assertEquals(ll2a.getParent().getConfig(TestEntity.CONF_NAME), \"sample1\");\n        \n        // and what's in the location manager is accurate\n        Entity ee = (Entity)managementContext.lookup(entity.getId());\n        Collection<Location> llee = ee.getLocations();\n        log.info(\"Locs at entity(lookup) are: \"+llee);\n        log.info(\"                      objs: \"+identities(llee));\n        SshMachineLocation ll2b = Iterables.getOnlyElement(Iterables.filter(llee, SshMachineLocation.class));\n        Assert.assertEquals(ll2b.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        Assert.assertNotNull(ll2b.getParent(), \"Parent not set after dodgy promoteToMaster\");\n        Assert.assertEquals(ll2b.getParent().getConfig(TestEntity.CONF_NAME), \"sample1\");\n        \n    }","id":67032,"modified_method":"public void testLocationsStillManagedCorrectlyAfterDoublePromotion() throws NoMachinesAvailableException {\n        HighAvailabilityManagerImpl ha = (HighAvailabilityManagerImpl) managementContext.getHighAvailabilityManager();\n        ha.start(HighAvailabilityMode.MASTER);\n        \n        TestApplication app = TestApplication.Factory.newManagedInstanceForTests(managementContext);\n        \n        LocalhostMachineProvisioningLocation l = app.newLocalhostProvisioningLocation();\n        l.setConfig(TestEntity.CONF_NAME, \"sample1\");\n        Assert.assertEquals(l.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        \n        SshMachineLocation l2 = l.obtain();\n        Assert.assertEquals(l2.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        Assert.assertNotNull(l2.getParent(), \"Parent not set after dodgy promoteToMaster\");\n        Assert.assertEquals(l2.getParent().getConfig(TestEntity.CONF_NAME), \"sample1\");\n\n        TestEntity entity = app.createAndManageChild(EntitySpec.create(TestEntity.class).location(l).location(l2));\n        log.info(\"Entities managed are: \"+managementContext.getEntityManager().getEntities());\n        Collection<Location> le = entity.getLocations();\n        log.info(\"Locs at entity are: \"+le);\n        Collection<Location> lm = managementContext.getLocationManager().getLocations();\n        log.info(\"Locs managed are: \"+lm);\n        log.info(\"            objs: \"+identities(lm));\n        Assert.assertNotNull(entity.getManagementSupport().getManagementContext());\n        Assert.assertNotNull( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().getManagementContext());\n        Assert.assertTrue( ((EntityInternal)app.getChildren().iterator().next()).getManagementSupport().isDeployed());\n        checkEntitiesHealthy(app, entity);\n        \n        managementContext.getRebindManager().forcePersistNow(true, null);\n        log.info(\"Test deliberately doing unnecessary extra promoteToMaster\");\n        ha.promoteToMaster();\n        \n        log.info(\"Entities managed are: \"+managementContext.getEntityManager().getEntities());\n        Collection<Location> lle = entity.getLocations();\n        log.info(\"Locs at entity(old) are: \"+lle);\n        log.info(\"                   objs: \"+identities(lle));\n        // check entities -- the initial-full promotion previously re-created items, \n        // and plugged them in as children, but only managed the roots\n        checkEntitiesHealthy(app, entity);\n        \n        // assert what's in the location manager is accurate\n        Collection<Location> llmm = managementContext.getLocationManager().getLocations();\n        log.info(\"Locs managed are: \"+llmm);\n        log.info(\"            objs: \"+identities(llmm));\n        Assert.assertEquals(llmm, lm);\n        SshMachineLocation ll2a = Iterables.getOnlyElement(Iterables.filter(llmm, SshMachineLocation.class));\n        Assert.assertEquals(ll2a.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        Assert.assertNotNull(ll2a.getParent(), \"Parent not set after dodgy promoteToMaster\");\n        Assert.assertEquals(ll2a.getParent().getConfig(TestEntity.CONF_NAME), \"sample1\");\n        \n        // and what's in the location manager is accurate\n        Entity ee = (Entity)managementContext.lookup(entity.getId());\n        Collection<Location> llee = ee.getLocations();\n        log.info(\"Locs at entity(lookup) are: \"+llee);\n        log.info(\"                      objs: \"+identities(llee));\n        SshMachineLocation ll2b = Iterables.getOnlyElement(Iterables.filter(llee, SshMachineLocation.class));\n        Assert.assertEquals(ll2b.getConfig(TestEntity.CONF_NAME), \"sample1\");\n        Assert.assertNotNull(ll2b.getParent(), \"Parent not set after dodgy promoteToMaster\");\n        Assert.assertEquals(ll2b.getParent().getConfig(TestEntity.CONF_NAME), \"sample1\");\n        \n    }","commit_id":"35142c8049d3068775f448d6c48edeb365f53bfa","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"/**\n     * Constructs a new-style entity (fails if no no-arg constructor).\n     * Sets the entity's id and proxy.\n     * <p>\n     * As {@link #constructEntity(Class, EntitySpec)} but when no spec is used.\n     */\n    // TODO would it be cleaner to have callers just create a spec? and deprecate this?\n    public <T extends Entity> T constructEntity(Class<T> clazz, Iterable<Class<?>> interfaces, String entityId) {\n        if (!isNewStyle(clazz)) {\n            throw new IllegalStateException(\"Cannot construct old-style entity \"+clazz);\n        }\n        checkNotNull(entityId, \"entityId\");\n        checkState(interfaces != null && !Iterables.isEmpty(interfaces), \"must have at least one interface for entity %s:%s\", clazz, entityId);\n        \n        T entity = constructEntityImpl(clazz, ImmutableMap.<String, Object>of(), entityId);\n        if (((AbstractEntity)entity).getProxy() == null) ((AbstractEntity)entity).setProxy(createEntityProxy(interfaces, entity));\n        return entity;\n    }","id":67033,"modified_method":"/**\n     * Constructs a new-style entity (fails if no no-arg constructor).\n     * Sets the entity's id and proxy.\n     * <p>\n     * As {@link #constructEntity(Class, EntitySpec)} but when no spec is used.\n     */\n    // TODO would it be cleaner to have callers just create a spec? and deprecate this?\n    public <T extends Entity> T constructEntity(Class<T> clazz, Iterable<Class<?>> interfaces, String entityId) {\n        if (!isNewStyle(clazz)) {\n            throw new IllegalStateException(\"Cannot construct old-style entity \"+clazz);\n        }\n        checkNotNull(entityId, \"entityId\");\n        checkState(interfaces != null && !Iterables.isEmpty(interfaces), \"must have at least one interface for entity %s:%s\", clazz, entityId);\n        \n        T entity = constructEntityImpl(clazz, ImmutableMap.<String, Object>of(), entityId);\n        if (((AbstractEntity)entity).getProxy() == null) {\n            Entity proxy = managementContext.getEntityManager().getEntity(entity.getId());\n            if (proxy==null) {\n                // normal case, proxy does not exist\n                proxy = createEntityProxy(interfaces, entity);\n            } else {\n                // only if rebinding to existing; don't create a new proxy, then we have proxy explosion\n                // but callers must be careful that the entity's proxy does not yet point to it\n            }\n            ((AbstractEntity)entity).setProxy(proxy);\n        }\n        return entity;\n    }","commit_id":"35142c8049d3068775f448d6c48edeb365f53bfa","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static byte[] URLtoByteArray(\n\t\t\tString location, Cookie[] cookies, boolean post)\n\t\tthrows IOException {\n\n\t\tbyte[] byteArray = null;\n\n\t\tHttpMethod method = null;\n\n\t\ttry {\n\t\t\tHttpClient client =\n\t\t\t\tnew HttpClient(new SimpleHttpConnectionManager());\n\n\t\t\tif (location == null) {\n\t\t\t\treturn byteArray;\n\t\t\t}\n\t\t\telse if (!location.startsWith(HTTP_WITH_SLASH) &&\n\t\t\t\t\t !location.startsWith(HTTPS_WITH_SLASH)) {\n\n\t\t\t\tlocation = HTTP_WITH_SLASH + location;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfig = new HostConfiguration();\n\n\t\t\thostConfig.setHost(new URI(location));\n\n\t\t\tif (Validator.isNotNull(PROXY_HOST) && PROXY_PORT > 0) {\n\t\t\t\thostConfig.setProxy(PROXY_HOST, PROXY_PORT);\n\t\t\t}\n\n\t\t\tclient.setHostConfiguration(hostConfig);\n\t\t\tclient.setConnectionTimeout(TIMEOUT);\n\t\t\tclient.setTimeout(TIMEOUT);\n\n\t\t\tif (cookies != null && cookies.length > 0) {\n\t\t\t\tHttpState state = new HttpState();\n\n\t\t\t\tstate.addCookies(cookies);\n\t\t\t\tstate.setCookiePolicy(CookiePolicy.COMPATIBILITY);\n\n\t\t\t\tclient.setState(state);\n\t\t\t}\n\n\t\t\tif (post) {\n\t\t\t\tmethod = new PostMethod(location);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmethod = new GetMethod(location);\n\t\t\t}\n\n\t\t\tmethod.setFollowRedirects(true);\n\n\t\t\tclient.executeMethod(method);\n\n\t\t\tHeader locationHeader = method.getResponseHeader(\"location\");\n\t\t\tif (locationHeader != null) {\n\t\t\t\treturn URLtoByteArray(locationHeader.getValue(), cookies, post);\n\t\t\t}\n\n\t\t\tInputStream is = method.getResponseBodyAsStream();\n\n\t\t\tif (is != null) {\n\t\t\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\t\t\t\tbyte[] bytes = new byte[512];\n\n\t\t\t\tfor (int i = is.read(bytes, 0, 512); i != -1;\n\t\t\t\t\t\ti = is.read(bytes, 0, 512)) {\n\n\t\t\t\t\tbuffer.write(bytes, 0, i);\n\t\t\t\t}\n\n\t\t\t\tbyteArray = buffer.toByteArray();\n\n\t\t\t\tis.close();\n\t\t\t\tbuffer.close();\n\t\t\t}\n\n\t\t\treturn byteArray;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (method != null) {\n\t\t\t\t\tmethod.releaseConnection();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","id":67034,"modified_method":"public static byte[] URLtoByteArray(\n\t\t\tString location, Cookie[] cookies, boolean post)\n\t\tthrows IOException {\n\n\t\tbyte[] byteArray = null;\n\n\t\tHttpMethod method = null;\n\n\t\ttry {\n\t\t\tHttpClient client =\n\t\t\t\tnew HttpClient(new SimpleHttpConnectionManager());\n\n\t\t\tif (location == null) {\n\t\t\t\treturn byteArray;\n\t\t\t}\n\t\t\telse if (!location.startsWith(HTTP_WITH_SLASH) &&\n\t\t\t\t\t !location.startsWith(HTTPS_WITH_SLASH)) {\n\n\t\t\t\tlocation = HTTP_WITH_SLASH + location;\n\t\t\t}\n\n\t\t\tHostConfiguration hostConfig = new HostConfiguration();\n\n\t\t\thostConfig.setHost(new URI(location));\n\n\t\t\tif (Validator.isNotNull(PROXY_HOST) && PROXY_PORT > 0) {\n\t\t\t\thostConfig.setProxy(PROXY_HOST, PROXY_PORT);\n\n\t\t\t\tif (Validator.isNotNull(PROXY_USERNAME)) {\n\t\t\t\t\tclient.getState().setProxyCredentials(\n\t\t\t\t\t\tnew AuthScope(PROXY_HOST, PROXY_PORT, null),\n\t\t\t\t\t\tnew UsernamePasswordCredentials(\n\t\t\t\t\t\t\tPROXY_USERNAME, PROXY_PASSWORD));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tclient.setHostConfiguration(hostConfig);\n\t\t\tclient.setConnectionTimeout(TIMEOUT);\n\t\t\tclient.setTimeout(TIMEOUT);\n\n\t\t\tif (cookies != null && cookies.length > 0) {\n\t\t\t\tHttpState state = new HttpState();\n\n\t\t\t\tstate.addCookies(cookies);\n\t\t\t\tstate.setCookiePolicy(CookiePolicy.COMPATIBILITY);\n\n\t\t\t\tclient.setState(state);\n\t\t\t}\n\n\t\t\tif (post) {\n\t\t\t\tmethod = new PostMethod(location);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmethod = new GetMethod(location);\n\t\t\t}\n\n\t\t\tmethod.setFollowRedirects(true);\n\n\t\t\tclient.executeMethod(method);\n\n\t\t\tHeader locationHeader = method.getResponseHeader(\"location\");\n\t\t\tif (locationHeader != null) {\n\t\t\t\treturn URLtoByteArray(locationHeader.getValue(), cookies, post);\n\t\t\t}\n\n\t\t\tInputStream is = method.getResponseBodyAsStream();\n\n\t\t\tif (is != null) {\n\t\t\t\tByteArrayOutputStream buffer = new ByteArrayOutputStream();\n\t\t\t\tbyte[] bytes = new byte[512];\n\n\t\t\t\tfor (int i = is.read(bytes, 0, 512); i != -1;\n\t\t\t\t\t\ti = is.read(bytes, 0, 512)) {\n\n\t\t\t\t\tbuffer.write(bytes, 0, i);\n\t\t\t\t}\n\n\t\t\t\tbyteArray = buffer.toByteArray();\n\n\t\t\t\tis.close();\n\t\t\t\tbuffer.close();\n\t\t\t}\n\n\t\t\treturn byteArray;\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tif (method != null) {\n\t\t\t\t\tmethod.releaseConnection();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}","commit_id":"2b7f424390284aa5def81a3e4ab26f3fa2f7f28e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void postRegister(Boolean registrationDone) {\n\t\ttry {\n\t\t\tif (getComponent().getStatistics() != null) {\n\t\t\t\tstatsName = new ObjectName(objectName.getDomain()\n\t\t\t\t\t\t+ \":type=statistics,name=\" + getName());\n\t\t\t\t// deregister the old version to avoid an\n\t\t\t\t// InstanceAlreadyExistsException\n\t\t\t\t// query by full jmx object name, no query given\n\t\t\t\tif (this.server.queryNames(statsName, null).size() != 0) {\n\t\t\t\t\tthis.server.unregisterMBean(statsName);\n\t\t\t\t}\n\t\t\t\tthis.server.registerMBean(new ComponentStats(getComponent()\n\t\t\t\t\t\t.getStatistics()), this.statsName);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(\"Error post-registering the MBean\", e);\n\t\t}\n\t}","id":67035,"modified_method":"public void postRegister(Boolean registrationDone) {\n\t\ttry {\n\t\t\tif (getComponent().getStatistics() != null) {\n\t\t\t\tstatsName = new ObjectName(objectName.getDomain()\n\t\t\t\t\t\t+ \":type=statistics,name=\" + getName());\n                // unregister old version if exists\n                if (this.server.isRegistered(statsName)) {\n                \tthis.server.unregisterMBean(statsName);\n                }\n\t\t\t\tthis.server.registerMBean(new ComponentStats(getComponent()\n\t\t\t\t\t\t.getStatistics()), this.statsName);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(\"Error post-registering the MBean\", e);\n\t\t}\n\t}","commit_id":"9ca775ee88a73fb8bac0d51dfc379a98c00a3ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void preDeregister() throws Exception\n    {\n    }","id":67036,"modified_method":"public void preDeregister() throws Exception\n    {\n        try {\n            if (this.server.isRegistered(statsName)) {\n                this.server.unregisterMBean(statsName);\n            }\n        } catch(Exception ex) {\n            LOGGER.error(\"Error unregistering ComponentService child \" + statsName.getCanonicalName(),\n                        ex);\n        }\n    }","commit_id":"9ca775ee88a73fb8bac0d51dfc379a98c00a3ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void postDeregister()\n    {\n    }","id":67037,"modified_method":"public void postDeregister()\n    {\n        try\n        {\n            if (this.server.isRegistered(inboundName)) {\n                this.server.unregisterMBean(inboundName);\n            }\n        } catch(Exception ex)\n        {\n            LOGGER.error(\"Error unregistering ComponentStats child \" + inboundName.getCanonicalName(),\n                        ex);\n        }\n        try\n        {\n            if (this.server.isRegistered(outboundName)) {\n                this.server.unregisterMBean(outboundName);\n            }\n        } catch(Exception ex)\n        {\n            LOGGER.error(\"Error unregistering ComponentStats child \" + inboundName.getCanonicalName(),\n                        ex);\n        }\n    }","commit_id":"9ca775ee88a73fb8bac0d51dfc379a98c00a3ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void postRegister(Boolean registrationDone)\n    {\n        try {\n            RouterStatistics is = this.statistics.getInboundRouterStat();\n            if (is != null) {\n                inboundName = new ObjectName(name.toString() + \",router=inbound\");\n                // unregister old version if exists\n                if (this.server.queryNames(inboundName, null).size() != 0) {\n                \tthis.server.unregisterMBean(inboundName);\n                }\n                this.server.registerMBean(new RouterStats(is), this.inboundName);\n            }\n            RouterStatistics os = this.statistics.getOutboundRouterStat();\n            if (os != null) {\n                outboundName = new ObjectName(name.toString() + \",router=outbound\");\n                // unregister old version if exists\n                if (this.server.queryNames(outboundName, null).size() != 0) {\n                \tthis.server.unregisterMBean(outboundName);\n                }\n                this.server.registerMBean(new RouterStats(os), this.outboundName);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error post-registering MBean\", e);\n        }\n    }","id":67038,"modified_method":"public void postRegister(Boolean registrationDone)\n    {\n        try {\n            RouterStatistics is = this.statistics.getInboundRouterStat();\n            if (is != null) {\n                inboundName = new ObjectName(name.toString() + \",router=inbound\");\n                // unregister old version if exists\n                if (this.server.isRegistered(inboundName)) {\n                \tthis.server.unregisterMBean(inboundName);\n                }\n                this.server.registerMBean(new RouterStats(is), this.inboundName);\n            }\n            RouterStatistics os = this.statistics.getOutboundRouterStat();\n            if (os != null) {\n                outboundName = new ObjectName(name.toString() + \",router=outbound\");\n                // unregister old version if exists\n                if (this.server.isRegistered(outboundName)) {\n                \tthis.server.unregisterMBean(outboundName);\n                }\n                this.server.registerMBean(new RouterStats(os), this.outboundName);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error post-registering MBean\", e);\n        }\n    }","commit_id":"9ca775ee88a73fb8bac0d51dfc379a98c00a3ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void postRegister(Boolean registrationDone) {\n\t\ttry {\n\t\t\tif (getComponent().getStatistics() != null) {\n\t\t\t\tstatsName = new ObjectName(objectName.getDomain()\n\t\t\t\t\t\t+ \":type=statistics,name=\" + getName());\n\t\t\t\t// deregister the old version to avoid an\n\t\t\t\t// InstanceAlreadyExistsException\n\t\t\t\t// query by full jmx object name, no query given\n\t\t\t\tif (this.server.queryNames(statsName, null).size() != 0) {\n\t\t\t\t\tthis.server.unregisterMBean(statsName);\n\t\t\t\t}\n\t\t\t\tthis.server.registerMBean(new ComponentStats(getComponent()\n\t\t\t\t\t\t.getStatistics()), this.statsName);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(\"Error post-registering the MBean\", e);\n\t\t}\n\t}","id":67039,"modified_method":"public void postRegister(Boolean registrationDone) {\n\t\ttry {\n\t\t\tif (getComponent().getStatistics() != null) {\n\t\t\t\tstatsName = new ObjectName(objectName.getDomain()\n\t\t\t\t\t\t+ \":type=statistics,name=\" + getName());\n                // unregister old version if exists\n                if (this.server.isRegistered(statsName)) {\n                \tthis.server.unregisterMBean(statsName);\n                }\n\t\t\t\tthis.server.registerMBean(new ComponentStats(getComponent()\n\t\t\t\t\t\t.getStatistics()), this.statsName);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLOGGER.error(\"Error post-registering the MBean\", e);\n\t\t}\n\t}","commit_id":"db739e5ec24cb078620d3ab30ab1de0d3495c270","url":"https://github.com/mulesoft/mule"},{"original_method":"public void preDeregister() throws Exception\n    {\n    }","id":67040,"modified_method":"public void preDeregister() throws Exception\n    {\n        try {\n            if (this.server.isRegistered(statsName)) {\n                this.server.unregisterMBean(statsName);\n            }\n        } catch(Exception ex) {\n            LOGGER.error(\"Error unregistering ComponentService child \" + statsName.getCanonicalName(),\n                        ex);\n        }\n    }","commit_id":"db739e5ec24cb078620d3ab30ab1de0d3495c270","url":"https://github.com/mulesoft/mule"},{"original_method":"public void postDeregister()\n    {\n    }","id":67041,"modified_method":"public void postDeregister()\n    {\n        try\n        {\n            if (this.server.isRegistered(inboundName)) {\n                this.server.unregisterMBean(inboundName);\n            }\n        } catch(Exception ex)\n        {\n            LOGGER.error(\"Error unregistering ComponentStats child \" + inboundName.getCanonicalName(),\n                        ex);\n        }\n        try\n        {\n            if (this.server.isRegistered(outboundName)) {\n                this.server.unregisterMBean(outboundName);\n            }\n        } catch(Exception ex)\n        {\n            LOGGER.error(\"Error unregistering ComponentStats child \" + inboundName.getCanonicalName(),\n                        ex);\n        }\n    }","commit_id":"db739e5ec24cb078620d3ab30ab1de0d3495c270","url":"https://github.com/mulesoft/mule"},{"original_method":"public void postRegister(Boolean registrationDone)\n    {\n        try {\n            RouterStatistics is = this.statistics.getInboundRouterStat();\n            if (is != null) {\n                inboundName = new ObjectName(name.toString() + \",router=inbound\");\n                // unregister old version if exists\n                if (this.server.queryNames(inboundName, null).size() != 0) {\n                \tthis.server.unregisterMBean(inboundName);\n                }\n                this.server.registerMBean(new RouterStats(is), this.inboundName);\n            }\n            RouterStatistics os = this.statistics.getOutboundRouterStat();\n            if (os != null) {\n                outboundName = new ObjectName(name.toString() + \",router=outbound\");\n                // unregister old version if exists\n                if (this.server.queryNames(outboundName, null).size() != 0) {\n                \tthis.server.unregisterMBean(outboundName);\n                }\n                this.server.registerMBean(new RouterStats(os), this.outboundName);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error post-registering MBean\", e);\n        }\n    }","id":67042,"modified_method":"public void postRegister(Boolean registrationDone)\n    {\n        try {\n            RouterStatistics is = this.statistics.getInboundRouterStat();\n            if (is != null) {\n                inboundName = new ObjectName(name.toString() + \",router=inbound\");\n                // unregister old version if exists\n                if (this.server.isRegistered(inboundName)) {\n                \tthis.server.unregisterMBean(inboundName);\n                }\n                this.server.registerMBean(new RouterStats(is), this.inboundName);\n            }\n            RouterStatistics os = this.statistics.getOutboundRouterStat();\n            if (os != null) {\n                outboundName = new ObjectName(name.toString() + \",router=outbound\");\n                // unregister old version if exists\n                if (this.server.isRegistered(outboundName)) {\n                \tthis.server.unregisterMBean(outboundName);\n                }\n                this.server.registerMBean(new RouterStats(os), this.outboundName);\n            }\n        } catch (Exception e) {\n            LOGGER.error(\"Error post-registering MBean\", e);\n        }\n    }","commit_id":"db739e5ec24cb078620d3ab30ab1de0d3495c270","url":"https://github.com/mulesoft/mule"},{"original_method":"public AcademyElite(UUID ownerId) {\n        super(ownerId, 20, \"Academy Elite\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{3}{U}\");\n        this.expansionSetCode = \"CNS\";\n        this.subtype.add(\"Human\");\n        this.subtype.add(\"Wizard\");\n        this.color.setBlue(true);\n        this.power = new MageInt(0);\n        this.toughness = new MageInt(0);\n\n        // Academy Elite enters the battlefield with X +1/+1 counters on it, where X is the number of instant and\n        // sorcery cards in all graveyards.\n        this.addAbility(new EntersBattlefieldAbility(new AcademyEliteEffect1(), \" with X +1/+1 counters on it, where X is the number of instant and sorcery cards in all graveyards\"));\n\n        // {2}{U}, Remove a +1/+1 counter from Academy Elite: Draw a card, then discard a card.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(1, 1, false), new ManaCostsImpl<>(\"{2}{U}\"));\n        ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance(1)));\n        ability.addTarget(new TargetCreatureOrPlayer());\n        this.addAbility(ability);\n    }","id":67043,"modified_method":"public AcademyElite(UUID ownerId) {\n        super(ownerId, 20, \"Academy Elite\", Rarity.RARE, new CardType[]{CardType.CREATURE}, \"{3}{U}\");\n        this.expansionSetCode = \"CNS\";\n        this.subtype.add(\"Human\");\n        this.subtype.add(\"Wizard\");\n        this.color.setBlue(true);\n        this.power = new MageInt(0);\n        this.toughness = new MageInt(0);\n\n        // Academy Elite enters the battlefield with X +1/+1 counters on it, where X is the number of instant and\n        // sorcery cards in all graveyards.\n        this.addAbility(new EntersBattlefieldAbility(new AcademyEliteEffect1(), \"with X +1/+1 counters on it, where X is the number of instant and sorcery cards in all graveyards\"));\n\n        // {2}{U}, Remove a +1/+1 counter from Academy Elite: Draw a card, then discard a card.\n        Ability ability = new SimpleActivatedAbility(Zone.BATTLEFIELD, new DrawDiscardControllerEffect(1, 1, false), new ManaCostsImpl(\"{2}{U}\"));\n        ability.addCost(new RemoveCountersSourceCost(CounterType.P1P1.createInstance(1)));\n        this.addAbility(ability);\n    }","commit_id":"aff9eb4c337385029c00963c82fc91c443361087","url":"https://github.com/magefree/mage"},{"original_method":"public AcquireEffect() {\n        super(Outcome.Benefit);\n        staticText = \"Search target opponent's library for an artifact card and put that card onto the battlefield under your control. Then that player shuffles his or her library\";\n    }","id":67044,"modified_method":"public AcquireEffect() {\n        super(Outcome.PutCardInPlay);\n        staticText = \"Search target opponent's library for an artifact card and put that card onto the battlefield under your control. Then that player shuffles his or her library\";\n    }","commit_id":"aff9eb4c337385029c00963c82fc91c443361087","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        boolean applied = false;\n        Player opponent = game.getPlayer(source.getFirstTarget());\n        Player you = game.getPlayer(source.getControllerId());\n        if (opponent != null && you != null) {\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\n            you.searchLibrary(target, game, opponent.getId());\n            Card targetCard = game.getCard(target.getFirstTarget());\n            if (targetCard != null) {\n                applied = you.putOntoBattlefieldWithInfo(targetCard, game, Zone.LIBRARY, source.getSourceId());\n            }\n            opponent.shuffleLibrary(game);\n        }\n        return applied;\n    }","id":67045,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Player opponent = game.getPlayer(source.getFirstTarget());\n        Player controller = game.getPlayer(source.getControllerId());\n        if (opponent != null && controller != null) {\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\n            controller.searchLibrary(target, game, opponent.getId());\n            Card targetCard = game.getCard(target.getFirstTarget());\n            if (targetCard != null) {\n                controller.putOntoBattlefieldWithInfo(targetCard, game, Zone.LIBRARY, source.getSourceId());\n            }\n            opponent.shuffleLibrary(game);\n            return true;\n        }\n        return false;\n    }","commit_id":"aff9eb4c337385029c00963c82fc91c443361087","url":"https://github.com/magefree/mage"},{"original_method":"public Annex(UUID ownerId) {\n        super(ownerId, 63, \"Annex\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{U}{U}\");\n        this.expansionSetCode = \"ONS\";\n        this.subtype.add(\"Aura\");\n\n        this.color.setBlue(true);\n\n        // Enchant land\n        TargetPermanent auraTarget = new TargetLandPermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.AddAbility));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n\n        // You control enchanted land.\n        Ability controlAbility = new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect());\n        this.addAbility(controlAbility);\n    }","id":67046,"modified_method":"public Annex(UUID ownerId) {\n        super(ownerId, 63, \"Annex\", Rarity.UNCOMMON, new CardType[]{CardType.ENCHANTMENT}, \"{2}{U}{U}\");\n        this.expansionSetCode = \"ONS\";\n        this.subtype.add(\"Aura\");\n\n        this.color.setBlue(true);\n\n        // Enchant land\n        TargetPermanent auraTarget = new TargetLandPermanent();\n        this.getSpellAbility().addTarget(auraTarget);\n        this.getSpellAbility().addEffect(new AttachEffect(Outcome.GainControl));\n        Ability ability = new EnchantAbility(auraTarget.getTargetName());\n        this.addAbility(ability);\n\n        // You control enchanted land.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new ControlEnchantedEffect()));\n    }","commit_id":"aff9eb4c337385029c00963c82fc91c443361087","url":"https://github.com/magefree/mage"},{"original_method":"public ScytheOfTheWretched(UUID ownerId) {\n        super(ownerId, 239, \"Scythe of the Wretched\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{2}\");\n        this.expansionSetCode = \"MRD\";\n        this.subtype.add(\"Equipment\");\n\n        // Equipped creature gets +2/+2.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2, Duration.WhileOnBattlefield)));\n        // Whenever a creature dealt damage by equipped creature this turn dies, return that card to the battlefield under your control. Attach Scythe of the Wretched to that creature.\n        this.addAbility(new ScytheOfTheWretchedAbility());\n        // Equip {4}\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(4)));\n    }","id":67047,"modified_method":"public ScytheOfTheWretched(UUID ownerId) {\n        super(ownerId, 239, \"Scythe of the Wretched\", Rarity.RARE, new CardType[]{CardType.ARTIFACT}, \"{2}\");\n        this.expansionSetCode = \"MRD\";\n        this.subtype.add(\"Equipment\");\n\n        // Equipped creature gets +2/+2.\n        this.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD, new BoostEquippedEffect(2, 2, Duration.WhileOnBattlefield)));\n\n        // Whenever a creature dealt damage by equipped creature this turn dies, return that card to the battlefield under your control. Attach Scythe of the Wretched to that creature.\n        this.addAbility(new ScytheOfTheWretchedTriggeredAbility());\n\n        // Equip {4}\n        this.addAbility(new EquipAbility(Outcome.AddAbility, new GenericManaCost(4)));\n    }","commit_id":"3d3e51a822feb3a3428304400ba6e61c343082f8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(getTargetPointer().getFirst(game, source));\n        if(card != null) {\n            Zone currentZone = game.getState().getZone(card.getId());\n            Player player = game.getPlayer(source.getControllerId());\n            if(player != null && player.putOntoBattlefieldWithInfo(card, game, currentZone, source.getSourceId())) {\n                return true;\n            }\n        }\n\n        return false;\n    }","id":67048,"modified_method":"@Override\n    public boolean apply(Game game, Ability source) {\n        Card card = game.getCard(getTargetPointer().getFirst(game, source));\n        Player controller = game.getPlayer(source.getControllerId());\n        if (card != null && controller != null) {\n            Zone currentZone = game.getState().getZone(card.getId());\n            controller.putOntoBattlefieldWithInfo(card, game, currentZone, source.getSourceId());\n            return true;\n        }\n\n        return false;\n    }","commit_id":"3d3e51a822feb3a3428304400ba6e61c343082f8","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        boolean applied = false;\r\n        Player you = game.getPlayer(source.getControllerId());\r\n        if (you != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\r\n            target.setNotTarget(true);\r\n            you.searchLibrary(target, game);\r\n            Card targetCard = game.getCard(target.getFirstTarget());\r\n            if (targetCard == null) {\r\n                applied = false;\r\n            } else{\r\n                applied = you.putOntoBattlefieldWithInfo(targetCard, game, Zone.LIBRARY, source.getSourceId());\r\n                you.shuffleLibrary(game);\r\n            }\r\n        }\r\n        return applied;\r\n    }","id":67049,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            TargetCardInLibrary target = new TargetCardInLibrary(filter);\r\n            target.setNotTarget(true);\r\n            controller.searchLibrary(target, game);\r\n            Card targetCard = game.getCard(target.getFirstTarget());\r\n            if (targetCard != null) {\r\n                controller.putOntoBattlefieldWithInfo(targetCard, game, Zone.LIBRARY, source.getSourceId());\r\n            }\r\n            controller.shuffleLibrary(game);\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"a4087b5e4d690ce133fd3318cefc78255d3912fa","url":"https://github.com/magefree/mage"},{"original_method":"public void addInequation(IWrapper subType, IWrapper supertype, ErrorInfo errorInfo, boolean isWeak, boolean solveOnlyConcrete) {\n    IWrapper subtypeRepresentator = getRepresentatorWrapper(subType);\n    IWrapper supertypeRepresentator = getRepresentatorWrapper(supertype);\n\n    if (PREPARE_TYPES) {\n      if (subType == subtypeRepresentator && subType != null && subType.isConcrete()) {\n        subtypeRepresentator.setNode(prepareType(subtypeRepresentator.getNode()));\n      }\n      if (supertype == supertypeRepresentator && supertype != null && supertype.isConcrete()) {\n        supertypeRepresentator.setNode(prepareType(supertypeRepresentator.getNode()));\n      }\n    }\n\n    // no equation needed\n    if (NodeWrapper.fromWrapper(subtypeRepresentator) == NodeWrapper.fromWrapper(supertypeRepresentator)) return;\n\n    // if one of them is a var\n    RuntimeTypeVariable varSubtype = subtypeRepresentator == null ? null : subtypeRepresentator.getVariable();\n    RuntimeTypeVariable varSupertype = supertypeRepresentator == null ? null : supertypeRepresentator.getVariable();\n    Set<SNodePointer> vars = myNonConcreteVars.get(subtypeRepresentator);\n    boolean hasNonConcreteVars = vars != null && !vars.isEmpty() && solveOnlyConcrete;\n\n    if (varSubtype != null || hasNonConcreteVars || varSupertype != null) {\n      if (isWeak) {\n        addSubtyping(subtypeRepresentator, supertypeRepresentator, errorInfo);\n      } else {\n        addStrongSubtyping(subtypeRepresentator, supertypeRepresentator, errorInfo);\n      }\n      return;\n    }\n\n    //expand, if contains some vars.\n    if (subtypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper subtypeNodeWrapper = (NodeWrapper) subtypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.createNodeWrapper(CopyUtil.copy(subtypeNodeWrapper.getNode(), typesModel));\n      subtypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n    if (supertypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper supertypeNodeWrapper = (NodeWrapper) supertypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.createNodeWrapper(CopyUtil.copy(supertypeNodeWrapper.getNode(), typesModel));\n      supertypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n\n    //elimination rules:\n    if (subtypeRepresentator instanceof NodeWrapper && supertypeRepresentator instanceof NodeWrapper) {\n      SNode node1 = subtypeRepresentator.getNode();\n      SNode node2 = supertypeRepresentator.getNode();\n      Set<InequationReplacementRule_Runtime> inequationReplacementRules = myTypeChecker.getRulesManager().getReplacementRules(node1, node2);\n      for (InequationReplacementRule_Runtime inequationReplacementRule : inequationReplacementRules) {\n        inequationReplacementRule.processInequation(node1, node2, errorInfo);\n        return;\n      }\n    }\n\n    // if subtyping\n    if (myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, errorInfo, isWeak)) {\n      return;\n    }\n\n    if (errorInfo.getErrorString() != null) {\n      myTypeChecker.reportTypeError(errorInfo.getNodeWithError(), errorInfo.getErrorString());\n      return;\n    }\n    String strongString = isWeak ? \"\" : \" strong\";\n    IErrorReporter errorReporter =\n      new EquationErrorReporter(this, \"type \", subtypeRepresentator,\n        \" is not a\" + strongString + \" subtype of \", supertypeRepresentator, \"\", errorInfo.getRuleModel(), errorInfo.getRuleId());\n    myTypeChecker.reportTypeError(errorInfo.getNodeWithError(), errorReporter);\n\n    //4debug\n    // myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, errorInfo, isWeak);\n  }","id":67050,"modified_method":"public void addInequation(IWrapper subType, IWrapper supertype, ErrorInfo errorInfo, boolean isWeak, boolean solveOnlyConcrete) {\n    IWrapper subtypeRepresentator = getRepresentatorWrapper(subType);\n    IWrapper supertypeRepresentator = getRepresentatorWrapper(supertype);\n\n    if (PREPARE_TYPES) {\n      if (subType == subtypeRepresentator && subType != null && subType.isConcrete()) {\n        subtypeRepresentator = NodeWrapper.createNodeWrapper(prepareType(subtypeRepresentator.getNode()));\n      }\n      if (supertype == supertypeRepresentator && supertype != null && supertype.isConcrete()) {\n        supertypeRepresentator = NodeWrapper.createNodeWrapper(prepareType(supertypeRepresentator.getNode()));\n      }\n    }\n\n    // no equation needed\n    if (NodeWrapper.fromWrapper(subtypeRepresentator) == NodeWrapper.fromWrapper(supertypeRepresentator)) return;\n\n    // if one of them is a var\n    RuntimeTypeVariable varSubtype = subtypeRepresentator == null ? null : subtypeRepresentator.getVariable();\n    RuntimeTypeVariable varSupertype = supertypeRepresentator == null ? null : supertypeRepresentator.getVariable();\n    Set<SNodePointer> vars = myNonConcreteVars.get(subtypeRepresentator);\n    boolean hasNonConcreteVars = vars != null && !vars.isEmpty() && solveOnlyConcrete;\n\n    if (varSubtype != null || hasNonConcreteVars || varSupertype != null) {\n      if (isWeak) {\n        addSubtyping(subtypeRepresentator, supertypeRepresentator, errorInfo);\n      } else {\n        addStrongSubtyping(subtypeRepresentator, supertypeRepresentator, errorInfo);\n      }\n      return;\n    }\n\n    //expand, if contains some vars.\n    if (subtypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper subtypeNodeWrapper = (NodeWrapper) subtypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.createNodeWrapper(CopyUtil.copy(subtypeNodeWrapper.getNode(), typesModel));\n      subtypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n    if (supertypeRepresentator instanceof NodeWrapper) {\n      NodeWrapper supertypeNodeWrapper = (NodeWrapper) supertypeRepresentator;\n      SModel typesModel = myTypeChecker.getRuntimeTypesModel();\n      NodeWrapper representatorCopy = NodeWrapper.createNodeWrapper(CopyUtil.copy(supertypeNodeWrapper.getNode(), typesModel));\n      supertypeRepresentator = expandWrapper(null, representatorCopy, typesModel);\n    }\n\n    //elimination rules:\n    if (subtypeRepresentator instanceof NodeWrapper && supertypeRepresentator instanceof NodeWrapper) {\n      SNode node1 = subtypeRepresentator.getNode();\n      SNode node2 = supertypeRepresentator.getNode();\n      Set<InequationReplacementRule_Runtime> inequationReplacementRules = myTypeChecker.getRulesManager().getReplacementRules(node1, node2);\n      for (InequationReplacementRule_Runtime inequationReplacementRule : inequationReplacementRules) {\n        inequationReplacementRule.processInequation(node1, node2, errorInfo);\n        return;\n      }\n    }\n\n    // if subtyping\n    if (myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, errorInfo, isWeak)) {\n      return;\n    }\n\n    if (errorInfo.getErrorString() != null) {\n      myTypeChecker.reportTypeError(errorInfo.getNodeWithError(), errorInfo.getErrorString());\n      return;\n    }\n    String strongString = isWeak ? \"\" : \" strong\";\n    IErrorReporter errorReporter =\n      new EquationErrorReporter(this, \"type \", subtypeRepresentator,\n        \" is not a\" + strongString + \" subtype of \", supertypeRepresentator, \"\", errorInfo.getRuleModel(), errorInfo.getRuleId());\n    myTypeChecker.reportTypeError(errorInfo.getNodeWithError(), errorReporter);\n\n    //4debug\n    // myTypeChecker.getSubtypingManager().isSubtype(subtypeRepresentator, supertypeRepresentator, this, errorInfo, isWeak);\n  }","commit_id":"d69c39ef3944c2bdd4cc51d7e9a867f737a5c31d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void addEquation(IWrapper lhs, IWrapper rhs, ErrorInfo errorInfo) {\n    IWrapper lhsRepresentator = getRepresentatorWrapper(lhs);\n    IWrapper rhsRepresentator = getRepresentatorWrapper(rhs);\n    if (PREPARE_TYPES) {\n      if (lhs == lhsRepresentator && lhs != null && lhs.isConcrete()) {\n        lhsRepresentator.setNode(prepareType(lhsRepresentator.getNode()));\n      }\n      if (rhs == rhsRepresentator && rhs != null && rhs.isConcrete()) {\n        rhsRepresentator.setNode(prepareType(rhsRepresentator.getNode()));\n      }\n    }\n\n    // no equation needed\n    if (EqualUtil.equals(rhsRepresentator, lhsRepresentator)) return;\n    if (rhsRepresentator == null || lhsRepresentator == null) return;\n\n    // add var to type's multieq\n    RuntimeTypeVariable varRhs = rhsRepresentator.getVariable();\n    RuntimeTypeVariable varLhs = lhsRepresentator.getVariable();\n    if (varRhs != null) {\n      processEquation(rhsRepresentator, lhsRepresentator, errorInfo);\n      return;\n    } else {\n      if (varLhs != null) {\n        processEquation(lhsRepresentator, rhsRepresentator, errorInfo);\n        return;\n      }\n    }\n\n    // solve equation\n    if (!compareWrappers(rhsRepresentator, lhsRepresentator, errorInfo)) {\n      IErrorReporter errorReporter;\n      SNode nodeWithError = errorInfo == null ? null : errorInfo.getNodeWithError();\n      if (errorInfo != null && errorInfo.getErrorString() != null) {\n        errorReporter = new SimpleErrorReporter(errorInfo.getErrorString(), errorInfo.getRuleModel(), errorInfo.getRuleId());\n      } else {\n        String ruleModel = errorInfo == null ? null : errorInfo.getRuleModel();\n        String ruleId = errorInfo == null ? null : errorInfo.getRuleId();\n        errorReporter =\n          new EquationErrorReporter(this, \"incompatible types: \",\n            rhsRepresentator, \" and \", lhsRepresentator, \"\", ruleModel, ruleId);\n      }\n      processErrorEquation(lhsRepresentator, rhsRepresentator, errorReporter, nodeWithError);\n      return;\n    }\n  }","id":67051,"modified_method":"public void addEquation(IWrapper lhs, IWrapper rhs, ErrorInfo errorInfo) {\n    IWrapper lhsRepresentator = getRepresentatorWrapper(lhs);\n    IWrapper rhsRepresentator = getRepresentatorWrapper(rhs);\n    if (PREPARE_TYPES) {\n      if (lhs == lhsRepresentator && lhs != null && lhs.isConcrete()) {\n        lhsRepresentator = NodeWrapper.createNodeWrapper(prepareType(lhsRepresentator.getNode()));\n      }\n      if (rhs == rhsRepresentator && rhs != null && rhs.isConcrete()) {\n        rhsRepresentator = NodeWrapper.createNodeWrapper(prepareType(rhsRepresentator.getNode()));\n      }\n    }\n\n    // no equation needed\n    if (EqualUtil.equals(rhsRepresentator, lhsRepresentator)) return;\n    if (rhsRepresentator == null || lhsRepresentator == null) return;\n\n    // add var to type's multieq\n    RuntimeTypeVariable varRhs = rhsRepresentator.getVariable();\n    RuntimeTypeVariable varLhs = lhsRepresentator.getVariable();\n    if (varRhs != null) {\n      processEquation(rhsRepresentator, lhsRepresentator, errorInfo);\n      return;\n    } else {\n      if (varLhs != null) {\n        processEquation(lhsRepresentator, rhsRepresentator, errorInfo);\n        return;\n      }\n    }\n\n    // solve equation\n    if (!compareWrappers(rhsRepresentator, lhsRepresentator, errorInfo)) {\n      IErrorReporter errorReporter;\n      SNode nodeWithError = errorInfo == null ? null : errorInfo.getNodeWithError();\n      if (errorInfo != null && errorInfo.getErrorString() != null) {\n        errorReporter = new SimpleErrorReporter(errorInfo.getErrorString(), errorInfo.getRuleModel(), errorInfo.getRuleId());\n      } else {\n        String ruleModel = errorInfo == null ? null : errorInfo.getRuleModel();\n        String ruleId = errorInfo == null ? null : errorInfo.getRuleId();\n        errorReporter =\n          new EquationErrorReporter(this, \"incompatible types: \",\n            rhsRepresentator, \" and \", lhsRepresentator, \"\", ruleModel, ruleId);\n      }\n      processErrorEquation(lhsRepresentator, rhsRepresentator, errorReporter, nodeWithError);\n      return;\n    }\n  }","commit_id":"d69c39ef3944c2bdd4cc51d7e9a867f737a5c31d","url":"https://github.com/JetBrains/MPS"},{"original_method":"public SNode getRegisteredVariable(SNode node) {\n    return myRegisteredVariables.get(node);\n  }","id":67052,"modified_method":"public SNode getRegisteredVariable(SNode node) {\n    SNode var = myRegisteredVariables.get(node);\n    if (var == null) {\n      var = registerVariable(node);\n    }\n    return var;\n  }","commit_id":"d69c39ef3944c2bdd4cc51d7e9a867f737a5c31d","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() != null) {\n            return; // only run for top-level deployments\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n\n        addAnnotations(deploymentUnit, CdiAnnotations.BUILT_IN_SCOPES);\n        // EE7 built-in scopes\n        addAnnotation(deploymentUnit, new AnnotationType(TransactionScoped.class));\n        addAnnotation(deploymentUnit, new AnnotationType(VIEW_SCOPED_NAME, true));\n        addAnnotation(deploymentUnit, new AnnotationType(FLOW_SCOPED_NAME, true));\n\n        addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, CdiAnnotations.NORM_SCOPE.getDotName()));\n        addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, CdiAnnotations.SCOPE));\n    }","id":67053,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() != null) {\n            return; // only run for top-level deployments\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n\n        // CDI built-in normal scopes plus @Dependent\n        addAnnotations(deploymentUnit, CdiAnnotations.BEAN_DEFINING_ANNOTATIONS);\n        // CDI @Model stereotype\n        addAnnotation(deploymentUnit, new AnnotationType(CdiAnnotations.MODEL.getDotName(), false));\n        // EE7 built-in normal scopes and stereotypes\n        addAnnotation(deploymentUnit, new AnnotationType(TransactionScoped.class));\n        addAnnotation(deploymentUnit, new AnnotationType(VIEW_SCOPED_NAME, true));\n        addAnnotation(deploymentUnit, new AnnotationType(FLOW_SCOPED_NAME, true));\n\n        for (AnnotationType annotationType : CdiAnnotations.BEAN_DEFINING_META_ANNOTATIONS) {\n            addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, annotationType.getName()));\n        }\n    }","commit_id":"4597a824a38a366ff48a6579a0a4d1d507ae2b59","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() != null) {\n            return; // only run for top-level deployments\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n\n        addAnnotations(deploymentUnit, CdiAnnotations.BUILT_IN_SCOPES);\n        // EE7 built-in scopes\n        addAnnotation(deploymentUnit, new AnnotationType(TransactionScoped.class));\n        addAnnotation(deploymentUnit, new AnnotationType(VIEW_SCOPED_NAME, true));\n        addAnnotation(deploymentUnit, new AnnotationType(FLOW_SCOPED_NAME, true));\n\n        addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, CdiAnnotations.NORM_SCOPE.getDotName()));\n        addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, CdiAnnotations.SCOPE));\n    }","id":67054,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        if (deploymentUnit.getParent() != null) {\n            return; // only run for top-level deployments\n        }\n\n        final CompositeIndex index = deploymentUnit.getAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX);\n\n        // CDI built-in normal scopes plus @Dependent\n        addAnnotations(deploymentUnit, CdiAnnotations.BEAN_DEFINING_ANNOTATIONS);\n        // CDI @Model stereotype\n        addAnnotation(deploymentUnit, new AnnotationType(CdiAnnotations.MODEL.getDotName(), false));\n        // EE7 built-in normal scopes and stereotypes\n        addAnnotation(deploymentUnit, new AnnotationType(TransactionScoped.class));\n        addAnnotation(deploymentUnit, new AnnotationType(VIEW_SCOPED_NAME, true));\n        addAnnotation(deploymentUnit, new AnnotationType(FLOW_SCOPED_NAME, true));\n\n        for (AnnotationType annotationType : CdiAnnotations.BEAN_DEFINING_META_ANNOTATIONS) {\n            addAnnotations(deploymentUnit, getAnnotationsAnnotatedWith(index, annotationType.getName()));\n        }\n    }","commit_id":"f8dc8bfb575dcdad605b3a368911e3c5519c0f6f","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Bits put( long value, int steps )\n    {\n        int lowLongIndex = writePosition >> 6; // /64\n        int lowBitInLong = writePosition%64;\n        int lowBitsAvailable = 64-lowBitInLong;\n        long lowValueMask = rightOverflowMask( Math.min( lowBitsAvailable, steps ) );\n        longs[lowLongIndex] |= ((((long)value)&lowValueMask) << lowBitInLong);\n        if ( steps > lowBitsAvailable )\n        {   // High bits\n            long highValueMask = rightOverflowMask( steps-lowBitsAvailable );\n            longs[lowLongIndex+1] |= (((long)value) >>> lowBitsAvailable)&highValueMask;\n        }\n        writePosition += steps;\n        return this;\n    }","id":67055,"modified_method":"public Bits put( long value, int steps )\n    {\n        int lowLongIndex = writePosition >> 6; // /64\n        int lowBitInLong = writePosition%64;\n        int lowBitsAvailable = 64-lowBitInLong;\n        long lowValueMask = rightOverflowMask( Math.min( lowBitsAvailable, steps ) );\n        longs[lowLongIndex] |= (((value)&lowValueMask) << lowBitInLong);\n        if ( steps > lowBitsAvailable )\n        {   // High bits\n            long highValueMask = rightOverflowMask( steps-lowBitsAvailable );\n            longs[lowLongIndex+1] |= ((value) >>> lowBitsAvailable)&highValueMask;\n        }\n        writePosition += steps;\n        return this;\n    }","commit_id":"d08e52ed8aa9e4b4d826eccb20a14b3fbcbaf3f0","url":"https://github.com/neo4j/neo4j"},{"original_method":"static boolean tryInlineInNodeRecord( NodeRecord node, long[] ids, Collection<DynamicRecord> changedDynamicRecords )\n    {\n        // We reserve the high header bit for future extensions of the format of the in-lined label bits\n        // i.e. the 0-valued high header bit can allow for 0-7 in-lined labels in the bit-packed format.\n        if ( ids.length > 7 )\n        {\n            return false;\n        }\n\n        byte bitsPerLabel = (byte) (ids.length > 0 ? (LABEL_BITS / ids.length) : LABEL_BITS);\n        long limit = 1L << bitsPerLabel;\n        Bits bits = bits( 5 );\n        for ( long id : ids )\n        {\n            if ( highestOneBit( id ) < limit )\n            {\n                bits.put( id, bitsPerLabel );\n            }\n            else\n            {\n                return false;\n            }\n        }\n        node.setLabelField( combineLabelCountAndLabelStorage( (byte) ids.length, bits.getLongs()[0] ),\n                            changedDynamicRecords );\n        return true;\n    }","id":67056,"modified_method":"static boolean tryInlineInNodeRecord( NodeRecord node, long[] ids, Collection<DynamicRecord> changedDynamicRecords )\n    {\n        // We reserve the high header bit for future extensions of the format of the in-lined label bits\n        // i.e. the 0-valued high header bit can allow for 0-7 in-lined labels in the bit-packed format.\n        if ( ids.length > 7 )\n        {\n            return false;\n        }\n\n        byte bitsPerLabel = (byte) (ids.length > 0 ? (LABEL_BITS / ids.length) : LABEL_BITS);\n        Bits bits = bits( 5 );\n        if ( !inlineValues( ids, bitsPerLabel, bits ) )\n        {\n            return false;\n        }\n        node.setLabelField( combineLabelCountAndLabelStorage( (byte) ids.length, bits.getLongs()[0] ),\n                            changedDynamicRecords );\n        return true;\n    }","commit_id":"d08e52ed8aa9e4b4d826eccb20a14b3fbcbaf3f0","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    protected Object process( long ticket, List<InputNode> batch )\n    {\n        BatchingPropertyRecordAccess propertyRecords = new BatchingPropertyRecordAccess();\n        List<NodeRecord> nodeRecords = new ArrayList<>( batch.size() );\n        for ( InputNode batchNode : batch )\n        {\n            // TODO Should we have this piece of logic (below) that creates a node with its properties and labels\n            // in a service as well, that the old BatchInserter as well as perhaps NeoStoreTransaction could use?\n            // Node itself\n            long nodeId = idGenerator.generate( batchNode.id() );\n            idMapper.put( batchNode.id(), nodeId );\n            NodeRecord nodeRecord = new NodeRecord( nodeId, false,\n                    NO_NEXT_RELATIONSHIP.intValue(), NO_NEXT_PROPERTY.intValue() );\n            nodeRecord.setInUse( true );\n            nodeRecords.add( nodeRecord );\n\n            // Properties\n            long nextProp;\n            if ( batchNode.hasFirstPropertyId() )\n            {\n                nextProp = batchNode.firstPropertyId();\n            }\n            else\n            {\n                nextProp = propertyCreator.createPropertyChain( nodeRecord, propertyKeysAndValues(\n                        batchNode.properties(), propertyKeyHolder, propertyCreator ), propertyRecords );\n            }\n            nodeRecord.setNextProp( nextProp );\n\n            // Labels\n            if ( batchNode.hasLabelField() )\n            {\n                nodeRecord.setLabelField( batchNode.labelField(), Collections.<DynamicRecord>emptyList() );\n            }\n            else\n            {\n                long[] labels = Utils.labelNamesToIds( labelHolder, batchNode.labels() );\n                InlineNodeLabels.put( nodeRecord, labels, null, nodeStore.getDynamicLabelStore() );\n            }\n        }\n        return new RecordBatch<>( nodeRecords, propertyRecords.records() );\n    }","id":67057,"modified_method":"@Override\n    protected Object process( long ticket, List<InputNode> batch )\n    {\n        BatchingPropertyRecordAccess propertyRecords = new BatchingPropertyRecordAccess();\n        List<NodeRecord> nodeRecords = new ArrayList<>( batch.size() );\n        for ( InputNode batchNode : batch )\n        {\n            // TODO Should we have this piece of logic (below) that creates a node with its properties and labels\n            // in a service as well, that the old BatchInserter as well as perhaps NeoStoreTransaction could use?\n            // Node itself\n            long nodeId = idGenerator.generate( batchNode.id() );\n            idMapper.put( batchNode.id(), nodeId );\n            NodeRecord nodeRecord = new NodeRecord( nodeId, false,\n                    NO_NEXT_RELATIONSHIP.intValue(), NO_NEXT_PROPERTY.intValue() );\n            nodeRecord.setInUse( true );\n            nodeRecords.add( nodeRecord );\n\n            // Properties\n            long nextProp;\n            if ( batchNode.hasFirstPropertyId() )\n            {\n                nextProp = batchNode.firstPropertyId();\n            }\n            else\n            {\n                nextProp = propertyCreator.createPropertyChain( nodeRecord, propertyKeysAndValues(\n                        batchNode.properties(), propertyKeyHolder, propertyCreator ), propertyRecords );\n            }\n            nodeRecord.setNextProp( nextProp );\n\n            // Labels\n            if ( batchNode.hasLabelField() )\n            {\n                nodeRecord.setLabelField( batchNode.labelField(), Collections.<DynamicRecord>emptyList() );\n            }\n            else\n            {\n                long[] labels = labelHolder.getOrCreateIds( batchNode.labels() );\n                InlineNodeLabels.put( nodeRecord, labels, null, nodeStore.getDynamicLabelStore() );\n            }\n        }\n        return new RecordBatch<>( nodeRecords, propertyRecords.records() );\n    }","commit_id":"d08e52ed8aa9e4b4d826eccb20a14b3fbcbaf3f0","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    public void doImport( Input input ) throws IOException\n    {\n        logger.info( \"Import starting\" );\n\n        long startTime = currentTimeMillis();\n        try ( BatchingNeoStore neoStore = new BatchingNeoStore( fileSystem, storeDir, config,\n                writeMonitor, logging, monitors, writerFactory ) )\n        {\n            // Some temporary caches and indexes in the import\n            final IdMapping idMapping = input.idMapping();\n            final IdMapper idMapper = idMapping.idMapper();\n            final IdGenerator idGenerator = idMapping.idGenerator();\n            final NodeRelationshipLink nodeRelationshipLink =\n                    new NodeRelationshipLinkImpl( LongArrayFactory.AUTO, config.denseNodeThreshold() );\n            final ResourceIterable<InputNode> nodes = input.nodes();\n            final ResourceIterable<InputRelationship> relationships = input.relationships();\n\n            // Stage 1 -- nodes, properties, labels\n            final NodeStage nodeStage = new NodeStage( nodes, idMapper, idGenerator, neoStore );\n\n            // Stage 2 -- calculate dense node threshold\n            final CalculateDenseNodesStage calculateDenseNodesStage =\n                    new CalculateDenseNodesStage( relationships, nodeRelationshipLink, idMapper );\n\n            // Execute stages 1 and 2 in parallel or sequentially?\n            if ( idMapper.needsPreparation() )\n            {   // The id mapper of choice needs preparation in order to get ids from it,\n                // So we need to execute the node stage first as it fills the id mapper and prepares it in the end,\n                // before executing any stage that needs ids from the id mapper, for example calc dense node stage.\n                executeStages( nodeStage );\n                executeStages( calculateDenseNodesStage );\n            }\n            else\n            {   // The id mapper of choice doesn't need any preparation, so we can go ahead and execute\n                // the node and calc dende node stages in parallel.\n                executeStages( nodeStage, calculateDenseNodesStage );\n            }\n\n            // Stage 3 -- relationships, properties\n            final RelationshipStage relationshipStage =\n                    new RelationshipStage( relationships, idMapper, neoStore, nodeRelationshipLink );\n\n            // execute stage 3\n            executeStages( relationshipStage );\n\n            // Switch to reverse updating mode\n            writerFactory.awaitEverythingWritten();\n            neoStore.switchToUpdateMode();\n\n            // Stage 4 -- set node nextRel fields\n            final NodeFirstRelationshipStage nodeFirstRelationshipStage =\n                    new NodeFirstRelationshipStage( neoStore, nodeRelationshipLink );\n\n            // execute stage 4\n            executeStages( nodeFirstRelationshipStage );\n\n            nodeRelationshipLink.clearRelationships();\n\n            // Stage 5 -- link relationship chains together\n            final RelationshipLinkbackStage relationshipLinkbackStage =\n                    new RelationshipLinkbackStage( neoStore, nodeRelationshipLink );\n\n            // execute stage 5\n            executeStages( relationshipLinkbackStage );\n\n            executionMonitor.done( currentTimeMillis() - startTime );\n        }\n        catch ( Throwable t )\n        {\n            logger.error( \"Error during import\", t );\n            throw Exceptions.launderedException( IOException.class, t );\n        }\n        finally\n        {\n            writerFactory.shutdown();\n        }\n\n        // TODO add import starts to this log message\n        logger.info( \"Import completed\" );\n    }","id":67058,"modified_method":"@Override\n    public void doImport( Input input ) throws IOException\n    {\n        logger.info( \"Import starting\" );\n\n        long startTime = currentTimeMillis();\n        try ( BatchingNeoStore neoStore = new BatchingNeoStore( fileSystem, storeDir, config,\n                writeMonitor, logging, monitors, writerFactory ) )\n        {\n            // Some temporary caches and indexes in the import\n            final IdMapping idMapping = input.idMapping();\n            IdMapper idMapper = idMapping.idMapper();\n            IdGenerator idGenerator = idMapping.idGenerator();\n            NodeRelationshipLink nodeRelationshipLink =\n                    new NodeRelationshipLinkImpl( LongArrayFactory.AUTO, config.denseNodeThreshold() );\n            final ResourceIterable<InputNode> nodes = input.nodes();\n            final ResourceIterable<InputRelationship> relationships = input.relationships();\n\n            // Stage 1 -- nodes, properties, labels\n            final NodeStage nodeStage = new NodeStage( nodes, idMapper, idGenerator, neoStore );\n\n            // Stage 2 -- calculate dense node threshold\n            final CalculateDenseNodesStage calculateDenseNodesStage =\n                    new CalculateDenseNodesStage( relationships, nodeRelationshipLink, idMapper );\n\n            // Execute stages 1 and 2 in parallel or sequentially?\n            if ( idMapper.needsPreparation() )\n            {   // The id mapper of choice needs preparation in order to get ids from it,\n                // So we need to execute the node stage first as it fills the id mapper and prepares it in the end,\n                // before executing any stage that needs ids from the id mapper, for example calc dense node stage.\n                executeStages( nodeStage );\n                executeStages( calculateDenseNodesStage );\n            }\n            else\n            {   // The id mapper of choice doesn't need any preparation, so we can go ahead and execute\n                // the node and calc dende node stages in parallel.\n                executeStages( nodeStage, calculateDenseNodesStage );\n            }\n\n            // Stage 3 -- relationships, properties\n            final RelationshipStage relationshipStage =\n                    new RelationshipStage( relationships, idMapper, neoStore, nodeRelationshipLink );\n\n            // execute stage 3\n            executeStages( relationshipStage );\n\n            // Switch to reverse updating mode\n            writerFactory.awaitEverythingWritten();\n            neoStore.switchToUpdateMode();\n            // Release IdMapper references since they are no longer needed, and so can be collected\n            idMapper = null;\n            idGenerator = null;\n\n            // Stage 4 -- set node nextRel fields\n            final NodeFirstRelationshipStage nodeFirstRelationshipStage =\n                    new NodeFirstRelationshipStage( neoStore, nodeRelationshipLink );\n\n            // execute stage 4\n            executeStages( nodeFirstRelationshipStage );\n\n            nodeRelationshipLink.clearRelationships();\n\n            // Stage 5 -- link relationship chains together\n            final RelationshipLinkbackStage relationshipLinkbackStage =\n                    new RelationshipLinkbackStage( neoStore, nodeRelationshipLink );\n\n            // execute stage 5\n            executeStages( relationshipLinkbackStage );\n\n            // Counts stages. The reason we're doing this as separate stages is that they require\n            // as much, and different, memory as the node/relationship encoding stages\n            // TODO OK so opportunity here: if we spot that there's at least as much memory available\n            // as our current node --> relationship cache has allocated we can execute these count stages\n            // in parallel with the link-back stages, or rather piggy-back on that processing directly.\n\n            // Release this potentially really big piece of cached data\n            nodeRelationshipLink = null;\n\n            // Stage 6 -- count nodes per label and labels per node\n            NodeLabelsCache countsCache = new NodeLabelsCache( LongArrayFactory.AUTO,\n                    neoStore.getLabelRepository().getHighId() );\n            final NodeCountsStage nodeCountsStage = new NodeCountsStage( neoStore, countsCache );\n            executeStages( nodeCountsStage );\n\n            // Stage 7 -- count label-[type]->label\n            final RelationshipCountsStage relationshipCountsStage = new RelationshipCountsStage( neoStore, countsCache );\n            executeStages( relationshipCountsStage );\n\n            executionMonitor.done( currentTimeMillis() - startTime );\n        }\n        catch ( Throwable t )\n        {\n            logger.error( \"Error during import\", t );\n            throw Exceptions.launderedException( IOException.class, t );\n        }\n        finally\n        {\n            writerFactory.shutdown();\n        }\n\n        // TODO add import starts to this log message\n        logger.info( \"Import completed\" );\n    }","commit_id":"d08e52ed8aa9e4b4d826eccb20a14b3fbcbaf3f0","url":"https://github.com/neo4j/neo4j"},{"original_method":"private void calculdateAvailableValuesAndTypes() {\n        if (annotatedMethod.getParameterTypes().length == 1) {\n            Class<?> type = annotatedMethod.getParameterTypes()[0];\n            //we don't want support for \"--flag true\" syntax\n            if (type == Boolean.class || type == Boolean.TYPE) {\n                argumentType = Void.TYPE;\n            }else{\n                argumentType = type;\n            }\n            availableValues = new ArrayList<String>();\n        } else {\n            // TODO deal correctly with annotated methods\n            // with multiple parameters\n            availableValues = Collections.EMPTY_LIST;\n            argumentType = Void.TYPE;\n        }\n    }","id":67059,"modified_method":"private void calculdateAvailableValuesAndTypes() {\n        availableValues = new ArrayList<String>();\n        if (annotatedMethod.getParameterTypes().length == 1) {\n            Class<?> type = annotatedMethod.getParameterTypes()[0];\n            //we don't want to support \"--flag true\" syntax\n            if (type == Boolean.class || type == Boolean.TYPE) {\n                argumentType = Void.TYPE;\n            }else{\n                argumentType = type;\n                if(argumentType.isEnum()){\n                    final Enum[] enumConstants = (Enum[]) argumentType.getEnumConstants();\n                    for (Enum enumConstant : enumConstants) {\n                        availableValues.add(enumConstant.name());\n                    }\n                }\n            }\n        } else {\n            argumentType = Void.TYPE;\n        }\n    }","commit_id":"9e9d6c41dc10824ebdfc75b3bb1ed7c47808dae6","url":"https://github.com/gradle/gradle"},{"original_method":"private void indentForOptionDescription(StyledTextOutput output, String optionString) {\n        output.text(INDENT).text(INDENT);\n        for (int i = 0; i < optionString.length(); i++) {\n            output.append(' ');\n        }\n    }","id":67060,"modified_method":"private LinePrefixingStyledTextOutput createIndentedOutput(StyledTextOutput output, String prefix) {\n        return new LinePrefixingStyledTextOutput(output, prefix);\n    }","commit_id":"9e9d6c41dc10824ebdfc75b3bb1ed7c47808dae6","url":"https://github.com/gradle/gradle"},{"original_method":"private void printTaskDescription(StyledTextOutput output, List<Task> tasks) {\n        int differentDescriptionsCount = differentDescriptions(tasks);\n        output.text(differentDescriptionsCount > 1 ? \"Descriptions\" : \"Description\").println();\n        if (differentDescriptionsCount == 1) {\n            // all tasks have the same description\n            final Task task = tasks.iterator().next();\n            output.text(INDENT).println(task.getDescription() == null ? \"-\" : task.getDescription());\n        } else {\n            for (Task task : tasks) {\n                output.text(INDENT).withStyle(UserInput).text(String.format(\"(%s) \", task.getPath()));\n                output.println(task.getDescription() == null ? \"-\" : task.getDescription());\n            }\n        }\n    }","id":67061,"modified_method":"private void printTaskDescription(StyledTextOutput output, List<Task> tasks) {\n        int differentDescriptionsCount = differentDescriptions(tasks);\n        final LinePrefixingStyledTextOutput descriptorOutput = createIndentedOutput(output, INDENT);\n        descriptorOutput.println(differentDescriptionsCount > 1 ? \"Descriptions\" : \"Description\");\n        if (differentDescriptionsCount == 1) {\n            // all tasks have the same description\n            final Task task = tasks.iterator().next();\n            descriptorOutput.println(task.getDescription() == null ? \"-\" : task.getDescription());\n        } else {\n            for (Task task : tasks) {\n                descriptorOutput.withStyle(UserInput).text(String.format(\"(%s) \", task.getPath()));\n                descriptorOutput.println(task.getDescription() == null ? \"-\" : task.getDescription());\n            }\n        }\n    }","commit_id":"9e9d6c41dc10824ebdfc75b3bb1ed7c47808dae6","url":"https://github.com/gradle/gradle"},{"original_method":"private void printlnCommandlineOptions(StyledTextOutput output, Class clazz) {\n        final List<CommandLineOptionDescriptor> commandLineOptions = commandLineOptionReader.getCommandLineOptions(clazz);\n        if (!commandLineOptions.isEmpty()) {\n            output.println();\n            output.text(\"Options\").println();\n        }\n        final Iterator<CommandLineOptionDescriptor> optionsIterator = commandLineOptions.iterator();\n        while (optionsIterator.hasNext()) {\n            final CommandLineOptionDescriptor descriptor = optionsIterator.next();\n            final String optionString = String.format(\"--%s\", descriptor.getOption().options()[0]);\n            output.text(INDENT).withStyle(UserInput).text(optionString);\n            output.text(INDENT).println(descriptor.getOption().description());\n\n            final Class availableValuesType = descriptor.getArgumentType();\n            if (availableValuesType.isEnum()) {\n                final Object[] enumConstants = availableValuesType.getEnumConstants();\n                indentForOptionDescription(output, optionString);\n                output.text(\"Takes an enum value of type (\").withStyle(UserInput).text(availableValuesType.getName()).println(\").\");\n                indentForOptionDescription(output, optionString);\n                output.println(\"Available values are:\");\n                for (Object enumConstant : enumConstants) {\n                    indentForOptionDescription(output, optionString);\n                    output.text(INDENT);\n                    output.withStyle(UserInput).println(enumConstant);\n                }\n            }\n            if (optionsIterator.hasNext()) {\n                output.println();\n            }\n        }\n    }","id":67062,"modified_method":"private void printlnCommandlineOptions(StyledTextOutput output, Class clazz) {\n        final List<CommandLineOptionDescriptor> commandLineOptions = commandLineOptionReader.getCommandLineOptions(clazz);\n        if (!commandLineOptions.isEmpty()) {\n            output.println();\n            output.text(\"Options\").println();\n        }\n        final Iterator<CommandLineOptionDescriptor> optionsIterator = commandLineOptions.iterator();\n        while (optionsIterator.hasNext()) {\n            final CommandLineOptionDescriptor descriptor = optionsIterator.next();\n            final String optionString = String.format(\"--%s\", descriptor.getOption().options()[0]);\n            output.text(INDENT).withStyle(UserInput).text(optionString);\n            output.text(INDENT).text(descriptor.getOption().description());\n            final List<String> availableValues = descriptor.getAvailableValues();\n            if (!availableValues.isEmpty()) {\n                //indentForOptionDescription\n                final int optionDescriptionOffset = 2 * INDENT.length() + optionString.length();\n                final LinePrefixingStyledTextOutput prefixedOutput = createIndentedOutput(output, optionDescriptionOffset);\n                prefixedOutput.println();\n                prefixedOutput.println(\"Available values are:\");\n                for (String value : availableValues) {\n                    prefixedOutput.text(INDENT);\n                    prefixedOutput.withStyle(UserInput).println(value);\n                }\n            } else {\n                output.println();\n            }\n            if (optionsIterator.hasNext()) {\n                output.println();\n            }\n        }\n    }","commit_id":"9e9d6c41dc10824ebdfc75b3bb1ed7c47808dae6","url":"https://github.com/gradle/gradle"},{"original_method":"public void print(StyledTextOutput output) {\n        final List<Task> tasks = CollectionUtils.sort(selection.getTasks());\n\n        output.text(\"Detailed task information for \").withStyle(UserInput).println(taskPath);\n        final ListMultimap<Class, Task> classListMap = groupTasksByType(tasks);\n\n        final Set<Class> classes = classListMap.keySet();\n        boolean multipleClasses = classes.size() > 1;\n        final List<Class> sortedClasses = CollectionUtils.sort(classes, new Comparator<Class>() {\n            public int compare(Class o1, Class o2) {\n                return o1.getSimpleName().compareTo(o2.getSimpleName());\n            }\n        });\n        for (Class clazz : sortedClasses) {\n            output.println();\n            final List<Task> tasksByType = classListMap.get(clazz);\n            output.text(tasksByType.size() > 1 ? \"Paths\" : \"Path\").println();\n            for (Task task : tasksByType) {\n                output.text(INDENT).withStyle(UserInput).println(task.getPath());\n            }\n            output.println();\n            output.text(\"Type\").println();\n            output.text(INDENT).withStyle(UserInput).text(clazz.getSimpleName());\n            output.println(String.format(\" (%s)\", clazz.getName()));\n\n            printlnCommandlineOptions(output, clazz);\n\n            output.println();\n            printTaskDescription(output, tasksByType);\n            output.println();\n            if (multipleClasses) {\n                output.println(\"----------------------\");\n            }\n        }\n    }","id":67063,"modified_method":"public void print(StyledTextOutput output) {\n        final List<Task> tasks = CollectionUtils.sort(selection.getTasks());\n\n        output.text(\"Detailed task information for \").withStyle(UserInput).println(taskPath);\n        final ListMultimap<Class, Task> classListMap = groupTasksByType(tasks);\n\n        final Set<Class> classes = classListMap.keySet();\n        boolean multipleClasses = classes.size() > 1;\n        final List<Class> sortedClasses = CollectionUtils.sort(classes, new Comparator<Class>() {\n            public int compare(Class o1, Class o2) {\n                return o1.getSimpleName().compareTo(o2.getSimpleName());\n            }\n        });\n        for (Class clazz : sortedClasses) {\n            output.println();\n            final List<Task> tasksByType = classListMap.get(clazz);\n            final LinePrefixingStyledTextOutput pathOutput = createIndentedOutput(output, INDENT);\n            pathOutput.println(tasksByType.size() > 1 ? \"Paths\" : \"Path\");\n            for (Task task : tasksByType) {\n                pathOutput.withStyle(UserInput).println(task.getPath());\n            }\n            output.println();\n            final LinePrefixingStyledTextOutput typeOutput = createIndentedOutput(output, INDENT);\n            typeOutput.println(\"Type\");\n            typeOutput.withStyle(UserInput).text(clazz.getSimpleName());\n            typeOutput.println(String.format(\" (%s)\", clazz.getName()));\n\n            printlnCommandlineOptions(output, clazz);\n\n            output.println();\n            printTaskDescription(output, tasksByType);\n            output.println();\n            if (multipleClasses) {\n                output.println(\"----------------------\");\n            }\n        }\n    }","commit_id":"9e9d6c41dc10824ebdfc75b3bb1ed7c47808dae6","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        // force processing synchronously using different api\n        if (endpoint.isSynchronous()) {\n            try {\n                process(exchange);\n            } catch (Throwable e) {\n                exchange.setException(e);\n            }\n            callback.done(true);\n            return true;\n        }\n\n        try {\n            ProducerRecord record = createRecorder(exchange);\n            kafkaProducer.send(record, new KafkaProducerCallBack(exchange, callback));\n            // Finishing the processing in an async way\n            return false;\n        } catch (Exception ex) {\n            // Just set the exception back to the client\n            exchange.setException(ex);\n            callback.done(true);\n            return true;\n        }\n    }","id":67064,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean process(Exchange exchange, AsyncCallback callback) {\n        try {\n            if (endpoint.isSynchronous()) {\n                // force process using synchronous call on kafka\n                process(exchange);\n            } else {\n                ProducerRecord record = createRecorder(exchange);\n                kafkaProducer.send(record, new KafkaProducerCallBack(exchange, callback));\n                // return false to process asynchronous\n                return false;\n            }\n        } catch (Exception ex) {\n            exchange.setException(ex);\n        }\n\n        callback.done(true);\n        return true;\n    }","commit_id":"d9f7fdabfe4491b71862687c0684dfdfbf936da1","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doStart() throws Exception {\n        Properties props = getProps();\n        if (kafkaProducer == null) {\n            kafkaProducer = new org.apache.kafka.clients.producer.KafkaProducer(props);\n        }\n\n        // if we are in asynchronous mode we need a worker pool\n        if (!endpoint.isSynchronous() && workerPool == null) {\n            workerPool = endpoint.createProducerExecutor();\n        }\n    }","id":67065,"modified_method":"@Override\n    protected void doStart() throws Exception {\n        Properties props = getProps();\n        if (kafkaProducer == null) {\n            kafkaProducer = new org.apache.kafka.clients.producer.KafkaProducer(props);\n        }\n\n        // if we are in asynchronous mode we need a worker pool\n        if (!endpoint.isSynchronous() && workerPool == null) {\n            workerPool = endpoint.createProducerExecutor();\n            // we create a thread pool so we should also shut it down\n            shutdownWorkerPool = true;\n        }\n    }","commit_id":"d9f7fdabfe4491b71862687c0684dfdfbf936da1","url":"https://github.com/apache/camel"},{"original_method":"@Test (timeout=30000)\n  public void testChangeTable() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testChangeTable\");\n    hdt.setRegionReplication(NB_SERVERS);\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTable table = HTU.createTable(hdt, new byte[][]{f}, HTU.getConfiguration());\n\n    // basic test: it should work.\n    Put p = new Put(row);\n    p.add(f, row, row);\n    table.put(p);\n\n    Get g = new Get(row);\n    Result r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    // Add a CF, it should work.\n    HTableDescriptor bHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    HColumnDescriptor hcd = new HColumnDescriptor(row);\n    hdt.addFamily(hcd);\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.getHBaseAdmin().modifyTable(hdt.getTableName(), hdt);\n    HTU.getHBaseAdmin().enableTable(hdt.getTableName());\n    HTableDescriptor nHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    p = new Put(row);\n    p.add(row, row, row);\n    table.put(p);\n\n    g = new Get(row);\n    r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    try {\n      SlowMeCopro.cdl.set(new CountDownLatch(1));\n      g = new Get(row);\n      g.setConsistency(Consistency.TIMELINE);\n      r = table.get(g);\n      Assert.assertTrue(r.isStale());\n    } finally {\n      SlowMeCopro.cdl.get().countDown();\n      SlowMeCopro.sleepTime.set(0);\n    }\n\n    HTU.getHBaseCluster().stopMaster(0);\n    HBaseAdmin admin = new HBaseAdmin(HTU.getConfiguration());\n    try {\n      nHdt = admin.getTableDescriptor(hdt.getTableName());\n      Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n      admin.disableTable(hdt.getTableName());\n      admin.deleteTable(hdt.getTableName());\n      HTU.getHBaseCluster().startMaster();\n    } finally {\n      if (admin != null) admin.close();\n    }\n  }","id":67066,"modified_method":"@Test (timeout=30000)\n  public void testChangeTable() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testChangeTable\");\n    hdt.setRegionReplication(NB_SERVERS);\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTable table = HTU.createTable(hdt, new byte[][]{f}, HTU.getConfiguration());\n\n    // basic test: it should work.\n    Put p = new Put(row);\n    p.add(f, row, row);\n    table.put(p);\n\n    Get g = new Get(row);\n    Result r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    // Add a CF, it should work.\n    HTableDescriptor bHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    HColumnDescriptor hcd = new HColumnDescriptor(row);\n    hdt.addFamily(hcd);\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.getHBaseAdmin().modifyTable(hdt.getTableName(), hdt);\n    HTU.getHBaseAdmin().enableTable(hdt.getTableName());\n    HTableDescriptor nHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    p = new Put(row);\n    p.add(row, row, row);\n    table.put(p);\n\n    g = new Get(row);\n    r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    try {\n      SlowMeCopro.cdl.set(new CountDownLatch(1));\n      g = new Get(row);\n      g.setConsistency(Consistency.TIMELINE);\n      r = table.get(g);\n      Assert.assertTrue(r.isStale());\n    } finally {\n      SlowMeCopro.cdl.get().countDown();\n      SlowMeCopro.sleepTime.set(0);\n    }\n\n    HTU.getHBaseCluster().stopMaster(0);\n    HBaseAdmin admin = new HBaseAdmin(HTU.getConfiguration());\n    nHdt =admin.getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    admin.disableTable(hdt.getTableName());\n    admin.deleteTable(hdt.getTableName());\n    HTU.getHBaseCluster().startMaster();\n    admin.close();\n  }","commit_id":"3455065a75784d38fec348bd413c61dd316208f9","url":"https://github.com/apache/hbase"},{"original_method":"@Test (timeout=30000)\n  public void testReplicaAndReplication() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testReplicaAndReplication\");\n    hdt.setRegionReplication(NB_SERVERS);\n\n    HColumnDescriptor fam = new HColumnDescriptor(row);\n    fam.setScope(HConstants.REPLICATION_SCOPE_GLOBAL);\n    hdt.addFamily(fam);\n\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTU.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    Configuration conf2 = HBaseConfiguration.create(HTU.getConfiguration());\n    conf2.set(HConstants.HBASE_CLIENT_INSTANCE_ID, String.valueOf(-1));\n    conf2.set(HConstants.ZOOKEEPER_ZNODE_PARENT, \"/2\");\n    MiniZooKeeperCluster miniZK = HTU.getZkCluster();\n    HBaseTestingUtility HTU2 = new HBaseTestingUtility(conf2);\n    HTU2.setZkCluster(miniZK);\n    HTU2.startMiniCluster(NB_SERVERS);\n    LOG.info(\"Setup second Zk\");\n    HTU2.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    ReplicationAdmin admin = new ReplicationAdmin(HTU.getConfiguration());\n    try {\n      admin.addPeer(\"2\", HTU2.getClusterKey());\n    } finally {\n      if (admin != null) admin.close();\n    }\n\n    Put p = new Put(row);\n    p.add(row, row, row);\n    final HTable table = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    try {\n      table.put(p);\n      HTU.getHBaseAdmin().flush(table.getTableName());\n      LOG.info(\"Put & flush done on the first cluster. Now doing a get on the same cluster.\");\n\n      Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n        @Override\n        public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    } finally {\n      if (table != null) table.close();\n    }\n    LOG.info(\"stale get on the first cluster done. Now for the second.\");\n\n    final HTable table2 = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    try {\n      Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n        @Override\n        public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table2.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    } finally {\n      if (table2 != null) table2.close();\n    }\n\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.deleteTable(hdt.getTableName());\n\n    HTU2.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU2.deleteTable(hdt.getTableName());\n\n    HTU2.shutdownMiniCluster();\n  }","id":67067,"modified_method":"@Test (timeout=30000)\n  public void testReplicaAndReplication() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testReplicaAndReplication\");\n    hdt.setRegionReplication(NB_SERVERS);\n\n    HColumnDescriptor fam = new HColumnDescriptor(row);\n    fam.setScope(HConstants.REPLICATION_SCOPE_GLOBAL);\n    hdt.addFamily(fam);\n\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTU.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    Configuration conf2 = HBaseConfiguration.create(HTU.getConfiguration());\n    conf2.set(HConstants.HBASE_CLIENT_INSTANCE_ID, String.valueOf(-1));\n    conf2.set(HConstants.ZOOKEEPER_ZNODE_PARENT, \"/2\");\n    MiniZooKeeperCluster miniZK = HTU.getZkCluster();\n\n    HTU2 = new HBaseTestingUtility(conf2);\n    HTU2.setZkCluster(miniZK);\n    HTU2.startMiniCluster(NB_SERVERS);\n    LOG.info(\"Setup second Zk\");\n    HTU2.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    ReplicationAdmin admin = new ReplicationAdmin(HTU.getConfiguration());\n    admin.addPeer(\"2\", HTU2.getClusterKey());\n    admin.close();\n\n    Put p = new Put(row);\n    p.add(row, row, row);\n    final HTable table = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    table.put(p);\n\n    HTU.getHBaseAdmin().flush(table.getTableName());\n    LOG.info(\"Put & flush done on the first cluster. Now doing a get on the same cluster.\");\n\n    Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    table.close();\n    LOG.info(\"stale get on the first cluster done. Now for the second.\");\n\n    final HTable table2 = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table2.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    table2.close();\n\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.deleteTable(hdt.getTableName());\n\n    HTU2.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU2.deleteTable(hdt.getTableName());\n\n    // We shutdown HTU2 minicluster later, in afterClass(), as shutting down\n    // the minicluster has negative impact of deleting all HConnections in JVM.\n  }","commit_id":"3455065a75784d38fec348bd413c61dd316208f9","url":"https://github.com/apache/hbase"},{"original_method":"@AfterClass\n  public static void afterClass() throws Exception {\n    HTU.shutdownMiniCluster();\n  }","id":67068,"modified_method":"@AfterClass\n  public static void afterClass() throws Exception {\n    HTU2.shutdownMiniCluster();\n    HTU.shutdownMiniCluster();\n  }","commit_id":"3455065a75784d38fec348bd413c61dd316208f9","url":"https://github.com/apache/hbase"},{"original_method":"@Test (timeout=30000)\n  public void testChangeTable() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testChangeTable\");\n    hdt.setRegionReplication(NB_SERVERS);\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTable table = HTU.createTable(hdt, new byte[][]{f}, HTU.getConfiguration());\n\n    // basic test: it should work.\n    Put p = new Put(row);\n    p.add(f, row, row);\n    table.put(p);\n\n    Get g = new Get(row);\n    Result r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    // Add a CF, it should work.\n    HTableDescriptor bHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    HColumnDescriptor hcd = new HColumnDescriptor(row);\n    hdt.addFamily(hcd);\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.getHBaseAdmin().modifyTable(hdt.getTableName(), hdt);\n    HTU.getHBaseAdmin().enableTable(hdt.getTableName());\n    HTableDescriptor nHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    p = new Put(row);\n    p.add(row, row, row);\n    table.put(p);\n\n    g = new Get(row);\n    r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    try {\n      SlowMeCopro.cdl.set(new CountDownLatch(1));\n      g = new Get(row);\n      g.setConsistency(Consistency.TIMELINE);\n      r = table.get(g);\n      Assert.assertTrue(r.isStale());\n    } finally {\n      SlowMeCopro.cdl.get().countDown();\n      SlowMeCopro.sleepTime.set(0);\n    }\n\n    HTU.getHBaseCluster().stopMaster(0);\n    HBaseAdmin admin = new HBaseAdmin(HTU.getConfiguration());\n    try {\n      nHdt = admin.getTableDescriptor(hdt.getTableName());\n      Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n      admin.disableTable(hdt.getTableName());\n      admin.deleteTable(hdt.getTableName());\n      HTU.getHBaseCluster().startMaster();\n    } finally {\n      if (admin != null) admin.close();\n    }\n  }","id":67069,"modified_method":"@Test (timeout=30000)\n  public void testChangeTable() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testChangeTable\");\n    hdt.setRegionReplication(NB_SERVERS);\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTable table = HTU.createTable(hdt, new byte[][]{f}, HTU.getConfiguration());\n\n    // basic test: it should work.\n    Put p = new Put(row);\n    p.add(f, row, row);\n    table.put(p);\n\n    Get g = new Get(row);\n    Result r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    // Add a CF, it should work.\n    HTableDescriptor bHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    HColumnDescriptor hcd = new HColumnDescriptor(row);\n    hdt.addFamily(hcd);\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.getHBaseAdmin().modifyTable(hdt.getTableName(), hdt);\n    HTU.getHBaseAdmin().enableTable(hdt.getTableName());\n    HTableDescriptor nHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    p = new Put(row);\n    p.add(row, row, row);\n    table.put(p);\n\n    g = new Get(row);\n    r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    try {\n      SlowMeCopro.cdl.set(new CountDownLatch(1));\n      g = new Get(row);\n      g.setConsistency(Consistency.TIMELINE);\n      r = table.get(g);\n      Assert.assertTrue(r.isStale());\n    } finally {\n      SlowMeCopro.cdl.get().countDown();\n      SlowMeCopro.sleepTime.set(0);\n    }\n\n    HTU.getHBaseCluster().stopMaster(0);\n    HBaseAdmin admin = new HBaseAdmin(HTU.getConfiguration());\n    nHdt =admin.getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    admin.disableTable(hdt.getTableName());\n    admin.deleteTable(hdt.getTableName());\n    HTU.getHBaseCluster().startMaster();\n  }","commit_id":"688877606b10d80e4dede3c30deb4e922ad09a5a","url":"https://github.com/apache/hbase"},{"original_method":"@Test (timeout=30000)\n  public void testReplicaAndReplication() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testReplicaAndReplication\");\n    hdt.setRegionReplication(NB_SERVERS);\n\n    HColumnDescriptor fam = new HColumnDescriptor(row);\n    fam.setScope(HConstants.REPLICATION_SCOPE_GLOBAL);\n    hdt.addFamily(fam);\n\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTU.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    Configuration conf2 = HBaseConfiguration.create(HTU.getConfiguration());\n    conf2.set(HConstants.HBASE_CLIENT_INSTANCE_ID, String.valueOf(-1));\n    conf2.set(HConstants.ZOOKEEPER_ZNODE_PARENT, \"/2\");\n    MiniZooKeeperCluster miniZK = HTU.getZkCluster();\n    HBaseTestingUtility HTU2 = new HBaseTestingUtility(conf2);\n    HTU2.setZkCluster(miniZK);\n    HTU2.startMiniCluster(NB_SERVERS);\n    LOG.info(\"Setup second Zk\");\n    HTU2.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    ReplicationAdmin admin = new ReplicationAdmin(HTU.getConfiguration());\n    try {\n      admin.addPeer(\"2\", HTU2.getClusterKey());\n    } finally {\n      if (admin != null) admin.close();\n    }\n\n    Put p = new Put(row);\n    p.add(row, row, row);\n    final HTable table = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    try {\n      table.put(p);\n      HTU.getHBaseAdmin().flush(table.getTableName());\n      LOG.info(\"Put & flush done on the first cluster. Now doing a get on the same cluster.\");\n\n      Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n        @Override\n        public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    } finally {\n      if (table != null) table.close();\n    }\n    LOG.info(\"stale get on the first cluster done. Now for the second.\");\n\n    final HTable table2 = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    try {\n      Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n        @Override\n        public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table2.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    } finally {\n      if (table2 != null) table2.close();\n    }\n\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.deleteTable(hdt.getTableName());\n\n    HTU2.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU2.deleteTable(hdt.getTableName());\n\n    HTU2.shutdownMiniCluster();\n  }","id":67070,"modified_method":"@Test (timeout=30000)\n  public void testReplicaAndReplication() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testReplicaAndReplication\");\n    hdt.setRegionReplication(NB_SERVERS);\n\n    HColumnDescriptor fam = new HColumnDescriptor(row);\n    fam.setScope(HConstants.REPLICATION_SCOPE_GLOBAL);\n    hdt.addFamily(fam);\n\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTU.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    Configuration conf2 = HBaseConfiguration.create(HTU.getConfiguration());\n    conf2.set(HConstants.HBASE_CLIENT_INSTANCE_ID, String.valueOf(-1));\n    conf2.set(HConstants.ZOOKEEPER_ZNODE_PARENT, \"/2\");\n    MiniZooKeeperCluster miniZK = HTU.getZkCluster();\n\n    HTU2 = new HBaseTestingUtility(conf2);\n    HTU2.setZkCluster(miniZK);\n    HTU2.startMiniCluster(NB_SERVERS);\n    LOG.info(\"Setup second Zk\");\n    HTU2.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    ReplicationAdmin admin = new ReplicationAdmin(HTU.getConfiguration());\n    admin.addPeer(\"2\", HTU2.getClusterKey());\n\n    Put p = new Put(row);\n    p.add(row, row, row);\n    final HTable table = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    table.put(p);\n\n    HTU.getHBaseAdmin().flush(table.getTableName());\n    LOG.info(\"Put & flush done on the first cluster. Now doing a get on the same cluster.\");\n\n    Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }      }\n    });\n\n    LOG.info(\"stale get on the first cluster done. Now for the second.\");\n\n    final HTable table2 = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table2.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }      }\n    });\n\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.deleteTable(hdt.getTableName());\n\n    HTU2.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU2.deleteTable(hdt.getTableName());\n\n    // We shutdown HTU2 minicluster later, in afterClass(), as shutting down\n    // the minicluster has negative impact of deleting all HConnections in JVM.\n  }","commit_id":"688877606b10d80e4dede3c30deb4e922ad09a5a","url":"https://github.com/apache/hbase"},{"original_method":"@AfterClass\n  public static void afterClass() throws Exception {\n    HTU.shutdownMiniCluster();\n  }","id":67071,"modified_method":"@AfterClass\n  public static void afterClass() throws Exception {\n    HTU2.shutdownMiniCluster();\n    HTU.shutdownMiniCluster();\n  }","commit_id":"688877606b10d80e4dede3c30deb4e922ad09a5a","url":"https://github.com/apache/hbase"},{"original_method":"@AfterClass\n  public static void afterClass() throws Exception {\n    HTU2.shutdownMiniCluster();\n    HTU.shutdownMiniCluster();\n  }","id":67072,"modified_method":"@AfterClass\n  public static void afterClass() throws Exception {\n    HTU.shutdownMiniCluster();\n  }","commit_id":"782b1456f240ad2fc95555b0f464e6a7e0c1e685","url":"https://github.com/apache/hbase"},{"original_method":"@Test (timeout=30000)\n  public void testChangeTable() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testChangeTable\");\n    hdt.setRegionReplication(NB_SERVERS);\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTable table = HTU.createTable(hdt, new byte[][]{f}, HTU.getConfiguration());\n\n    // basic test: it should work.\n    Put p = new Put(row);\n    p.add(f, row, row);\n    table.put(p);\n\n    Get g = new Get(row);\n    Result r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    // Add a CF, it should work.\n    HTableDescriptor bHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    HColumnDescriptor hcd = new HColumnDescriptor(row);\n    hdt.addFamily(hcd);\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.getHBaseAdmin().modifyTable(hdt.getTableName(), hdt);\n    HTU.getHBaseAdmin().enableTable(hdt.getTableName());\n    HTableDescriptor nHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    p = new Put(row);\n    p.add(row, row, row);\n    table.put(p);\n\n    g = new Get(row);\n    r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    try {\n      SlowMeCopro.cdl.set(new CountDownLatch(1));\n      g = new Get(row);\n      g.setConsistency(Consistency.TIMELINE);\n      r = table.get(g);\n      Assert.assertTrue(r.isStale());\n    } finally {\n      SlowMeCopro.cdl.get().countDown();\n      SlowMeCopro.sleepTime.set(0);\n    }\n\n    HTU.getHBaseCluster().stopMaster(0);\n    HBaseAdmin admin = new HBaseAdmin(HTU.getConfiguration());\n    nHdt =admin.getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    admin.disableTable(hdt.getTableName());\n    admin.deleteTable(hdt.getTableName());\n    HTU.getHBaseCluster().startMaster();\n  }","id":67073,"modified_method":"@Test (timeout=30000)\n  public void testChangeTable() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testChangeTable\");\n    hdt.setRegionReplication(NB_SERVERS);\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTable table = HTU.createTable(hdt, new byte[][]{f}, HTU.getConfiguration());\n\n    // basic test: it should work.\n    Put p = new Put(row);\n    p.add(f, row, row);\n    table.put(p);\n\n    Get g = new Get(row);\n    Result r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    // Add a CF, it should work.\n    HTableDescriptor bHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    HColumnDescriptor hcd = new HColumnDescriptor(row);\n    hdt.addFamily(hcd);\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.getHBaseAdmin().modifyTable(hdt.getTableName(), hdt);\n    HTU.getHBaseAdmin().enableTable(hdt.getTableName());\n    HTableDescriptor nHdt = HTU.getHBaseAdmin().getTableDescriptor(hdt.getTableName());\n    Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n    p = new Put(row);\n    p.add(row, row, row);\n    table.put(p);\n\n    g = new Get(row);\n    r = table.get(g);\n    Assert.assertFalse(r.isStale());\n\n    try {\n      SlowMeCopro.cdl.set(new CountDownLatch(1));\n      g = new Get(row);\n      g.setConsistency(Consistency.TIMELINE);\n      r = table.get(g);\n      Assert.assertTrue(r.isStale());\n    } finally {\n      SlowMeCopro.cdl.get().countDown();\n      SlowMeCopro.sleepTime.set(0);\n    }\n\n    HTU.getHBaseCluster().stopMaster(0);\n    HBaseAdmin admin = new HBaseAdmin(HTU.getConfiguration());\n    try {\n      nHdt = admin.getTableDescriptor(hdt.getTableName());\n      Assert.assertEquals(\"fams=\" + Arrays.toString(nHdt.getColumnFamilies()),\n        bHdt.getColumnFamilies().length + 1, nHdt.getColumnFamilies().length);\n\n      admin.disableTable(hdt.getTableName());\n      admin.deleteTable(hdt.getTableName());\n      HTU.getHBaseCluster().startMaster();\n    } finally {\n      if (admin != null) admin.close();\n    }\n  }","commit_id":"782b1456f240ad2fc95555b0f464e6a7e0c1e685","url":"https://github.com/apache/hbase"},{"original_method":"@Test (timeout=30000)\n  public void testReplicaAndReplication() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testReplicaAndReplication\");\n    hdt.setRegionReplication(NB_SERVERS);\n\n    HColumnDescriptor fam = new HColumnDescriptor(row);\n    fam.setScope(HConstants.REPLICATION_SCOPE_GLOBAL);\n    hdt.addFamily(fam);\n\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTU.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    Configuration conf2 = HBaseConfiguration.create(HTU.getConfiguration());\n    conf2.set(HConstants.HBASE_CLIENT_INSTANCE_ID, String.valueOf(-1));\n    conf2.set(HConstants.ZOOKEEPER_ZNODE_PARENT, \"/2\");\n    MiniZooKeeperCluster miniZK = HTU.getZkCluster();\n\n    HTU2 = new HBaseTestingUtility(conf2);\n    HTU2.setZkCluster(miniZK);\n    HTU2.startMiniCluster(NB_SERVERS);\n    LOG.info(\"Setup second Zk\");\n    HTU2.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    ReplicationAdmin admin = new ReplicationAdmin(HTU.getConfiguration());\n    admin.addPeer(\"2\", HTU2.getClusterKey());\n\n    Put p = new Put(row);\n    p.add(row, row, row);\n    final HTable table = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    table.put(p);\n\n    HTU.getHBaseAdmin().flush(table.getTableName());\n    LOG.info(\"Put & flush done on the first cluster. Now doing a get on the same cluster.\");\n\n    Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }      }\n    });\n\n    LOG.info(\"stale get on the first cluster done. Now for the second.\");\n\n    final HTable table2 = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n      @Override\n      public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table2.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }      }\n    });\n\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.deleteTable(hdt.getTableName());\n\n    HTU2.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU2.deleteTable(hdt.getTableName());\n\n    // We shutdown HTU2 minicluster later, in afterClass(), as shutting down\n    // the minicluster has negative impact of deleting all HConnections in JVM.\n  }","id":67074,"modified_method":"@Test (timeout=30000)\n  public void testReplicaAndReplication() throws Exception {\n    HTableDescriptor hdt = HTU.createTableDescriptor(\"testReplicaAndReplication\");\n    hdt.setRegionReplication(NB_SERVERS);\n\n    HColumnDescriptor fam = new HColumnDescriptor(row);\n    fam.setScope(HConstants.REPLICATION_SCOPE_GLOBAL);\n    hdt.addFamily(fam);\n\n    hdt.addCoprocessor(SlowMeCopro.class.getName());\n    HTU.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    Configuration conf2 = HBaseConfiguration.create(HTU.getConfiguration());\n    conf2.set(HConstants.HBASE_CLIENT_INSTANCE_ID, String.valueOf(-1));\n    conf2.set(HConstants.ZOOKEEPER_ZNODE_PARENT, \"/2\");\n    MiniZooKeeperCluster miniZK = HTU.getZkCluster();\n    HBaseTestingUtility HTU2 = new HBaseTestingUtility(conf2);\n    HTU2.setZkCluster(miniZK);\n    HTU2.startMiniCluster(NB_SERVERS);\n    LOG.info(\"Setup second Zk\");\n    HTU2.getHBaseAdmin().createTable(hdt, HBaseTestingUtility.KEYS_FOR_HBA_CREATE_TABLE);\n\n    ReplicationAdmin admin = new ReplicationAdmin(HTU.getConfiguration());\n    try {\n      admin.addPeer(\"2\", HTU2.getClusterKey());\n    } finally {\n      if (admin != null) admin.close();\n    }\n\n    Put p = new Put(row);\n    p.add(row, row, row);\n    final HTable table = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    try {\n      table.put(p);\n      HTU.getHBaseAdmin().flush(table.getTableName());\n      LOG.info(\"Put & flush done on the first cluster. Now doing a get on the same cluster.\");\n\n      Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n        @Override\n        public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    } finally {\n      if (table != null) table.close();\n    }\n    LOG.info(\"stale get on the first cluster done. Now for the second.\");\n\n    final HTable table2 = new HTable(HTU.getConfiguration(), hdt.getTableName());\n    try {\n      Waiter.waitFor(HTU.getConfiguration(), 1000, new Waiter.Predicate<Exception>() {\n        @Override\n        public boolean evaluate() throws Exception {\n        try {\n          SlowMeCopro.cdl.set(new CountDownLatch(1));\n          Get g = new Get(row);\n          g.setConsistency(Consistency.TIMELINE);\n          Result r = table2.get(g);\n          Assert.assertTrue(r.isStale());\n          return  !r.isEmpty();\n        } finally {\n          SlowMeCopro.cdl.get().countDown();\n          SlowMeCopro.sleepTime.set(0);\n        }\n      }});\n    } finally {\n      if (table2 != null) table2.close();\n    }\n\n    HTU.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU.deleteTable(hdt.getTableName());\n\n    HTU2.getHBaseAdmin().disableTable(hdt.getTableName());\n    HTU2.deleteTable(hdt.getTableName());\n\n    HTU2.shutdownMiniCluster();\n  }","commit_id":"782b1456f240ad2fc95555b0f464e6a7e0c1e685","url":"https://github.com/apache/hbase"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public DataLinkInterface findByNodeIdAndIfIndex(final Integer nodeId, final Integer ifIndex) {\n        final CriteriaBuilder builder = new CriteriaBuilder(DataLinkInterface.class);\n        builder.alias(\"node\", \"node\", JoinType.LEFT_JOIN);\n        builder.eq(\"node.id\", nodeId);\n        builder.eq(\"ifIndex\", ifIndex);\n\n        final List<DataLinkInterface> interfaces = findMatching(builder.toCriteria());\n        if (interfaces.size() > 0) {\n            return interfaces.get(0);\n        }\n        return null;\n    }","id":67075,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public Collection<DataLinkInterface> findByNodeIdAndIfIndex(final Integer nodeId, final Integer ifIndex) {\n        return find(\"from DataLinkInterface as dli where dli.node.id = ? and dli.ifIndex = ?\", nodeId,ifIndex);\n    }","commit_id":"92d18e2c3755770f52c7edd1df141ab9c1c7ca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void updateForInterface(final int nodeid, final String ipAddr, final int ifIndex, final StatusType action)  {\n        if (!(ipAddr == null || ipAddr.length() == 0 || \"0.0.0.0\".equals(ipAddr))) {\n            m_atInterfaceDao.setStatusForNodeAndIp(nodeid, ipAddr, action);\n        }\n        if (ifIndex > -1) {\n            m_atInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, action);\n            m_stpInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, action);\n            m_ipRouteInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, action);\n            m_dataLinkInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, getLinkd().getSource(), action);\n        }\n    }","id":67076,"modified_method":"@Override\n    public void updateForInterface(final int nodeid, final String ipAddr, final int ifIndex, final StatusType action)  {\n        if (!(ipAddr == null || ipAddr.length() == 0 || \"0.0.0.0\".equals(ipAddr))) {\n            m_atInterfaceDao.setStatusForNodeAndIp(nodeid, ipAddr, action);\n        }\n        if (ifIndex > -1) {\n            m_atInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, action);\n            m_stpInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, action);\n            m_ipRouteInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, action);\n            for (String packageName: getLinkd().getActivePackages())\n                m_dataLinkInterfaceDao.setStatusForNodeAndIfIndex(nodeid, ifIndex, getLinkd().getSource()+\"/\"+packageName, action);\n        }\n    }","commit_id":"92d18e2c3755770f52c7edd1df141ab9c1c7ca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public void update(final int nodeid, final StatusType action) {\n        m_vlanDao.setStatusForNode(nodeid, action);\n        m_atInterfaceDao.setStatusForNode(nodeid, action);\n        m_ipRouteInterfaceDao.setStatusForNode(nodeid, action);\n        m_stpNodeDao.setStatusForNode(nodeid, action);\n        m_stpInterfaceDao.setStatusForNode(nodeid, action);\n        m_dataLinkInterfaceDao.setStatusForNode(nodeid, getLinkd().getSource(), action);\n    }","id":67077,"modified_method":"@Override\n    public void update(final int nodeid, final StatusType action) {\n        m_vlanDao.setStatusForNode(nodeid, action);\n        m_atInterfaceDao.setStatusForNode(nodeid, action);\n        m_ipRouteInterfaceDao.setStatusForNode(nodeid, action);\n        m_stpNodeDao.setStatusForNode(nodeid, action);\n        m_stpInterfaceDao.setStatusForNode(nodeid, action);\n        for (String packageName: getLinkd().getActivePackages())\n            m_dataLinkInterfaceDao.setStatusForNode(nodeid, getLinkd().getSource()+\"/\"+packageName, action);\n    }","commit_id":"92d18e2c3755770f52c7edd1df141ab9c1c7ca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    @Transactional\n    public void storeDiscoveryLink(final DiscoveryLink discoveryLink)\n    {\n        final Date now = new Date();\n        String source = getLinkd().getName()+\"/\"+discoveryLink.getPackageName();\n\n        for (final NodeToNodeLink lk : discoveryLink.getLinks()) {\n            DataLinkInterface iface = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(Integer.valueOf(lk.getNodeId()),\n                                                                                    Integer.valueOf(lk.getIfindex()));\n            if (iface == null) {\n                \n                final OnmsNode onmsNode = m_nodeDao.get(lk.getNodeId());\n                iface = new DataLinkInterface(\n                                              onmsNode,\n                                              lk.getIfindex(),\n                                              lk.getNodeparentid(),\n                                              lk.getParentifindex(),\n                                              StatusType.ACTIVE,\n                                              now);\n                iface.setSource(source);\n            } else {\n                iface.setNodeParentId(lk.getNodeparentid());\n                iface.setParentIfIndex(lk.getParentifindex());\n                iface.setSource(source);\n                iface.setStatus(StatusType.ACTIVE);\n                iface.setLastPollTime(now);\n            }\n            DataLinkInterface reversiface = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(Integer.valueOf(lk.getNodeparentid()),\n                                                                                          Integer.valueOf(lk.getParentifindex()));\n            if (reversiface != null && reversiface.getNodeParentId().intValue() == lk.getNodeId() &&\n                    reversiface.getParentIfIndex().intValue() == lk.getIfindex()) {\n                LOG.debug(\"storeDiscoveryLink: Deleting found reverse interface for {} on link {}.\", reversiface,lk);\n                m_dataLinkInterfaceDao.delete(reversiface);\n            }\n                \n            m_dataLinkInterfaceDao.saveOrUpdate(iface);\n        }\n\n        // FIXME remove this is you use mac address in DiscoveryLink memory\n        for (final MacToNodeLink lkm : discoveryLink.getMacLinks()) {\n            final Collection<OnmsAtInterface> atInterfaces = m_atInterfaceDao.findByMacAddress(lkm.getMacAddress());\n            if (atInterfaces.size() == 0) {\n                LOG.debug(\"storeDiscoveryLink: No nodeid found on DB for mac address {} on link. Skipping.\", lkm.getMacAddress());\n                continue;\n            }\n            if (atInterfaces.size() > 1) {\n                LOG.debug(\"storeDiscoveryLink: More than one atInterface returned for the mac address {}. Duplicated ip/mac address. Skipping \", lkm.getMacAddress());\n                continue;\n            }\n            final OnmsAtInterface atInterface = atInterfaces.iterator().next();\n            if (!m_linkd.isInterfaceInPackage(atInterface.getIpAddress(),\n                                              discoveryLink.getPackageName())) {\n                LOG.debug(\"storeDiscoveryLink: IP address {} not found on package {}.  Skipping.\", atInterface.getIpAddress(),discoveryLink.getPackageName());\n                continue;\n            }\n\n            final OnmsNode atInterfaceNode = atInterface.getNode();\n            \n            DataLinkInterface dli = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(atInterfaceNode.getId(),\n                                                                                  atInterface.getIfIndex());\n            if (dli == null) {\n                dli = new DataLinkInterface(\n                                            atInterfaceNode,\n                                            atInterface.getIfIndex(),\n                                            lkm.getNodeparentid(),\n                                            lkm.getParentifindex(),\n                                            StatusType.ACTIVE,\n                                            now);\n                dli.setSource(source);\n            } else {\n                dli.setNodeParentId(lkm.getNodeparentid());\n                dli.setParentIfIndex(lkm.getParentifindex());\n                dli.setStatus(StatusType.ACTIVE);\n                dli.setLastPollTime(now);\n                dli.setSource(source);\n            }\n            m_dataLinkInterfaceDao.saveOrUpdate(dli);\n            LOG.debug(\"storeDiscoveryLink: Storing {}\", dli);\n        }\n        m_dataLinkInterfaceDao.deactivateIfOlderThan(now,source);\n        m_dataLinkInterfaceDao.deleteIfOlderThan(new Date(now.getTime()-3*discoveryLink.getSnmpPollInterval()),source);\n        m_dataLinkInterfaceDao.flush();\n    }","id":67078,"modified_method":"@Override\n    @Transactional\n    public void storeDiscoveryLink(final DiscoveryLink discoveryLink)\n    {\n        final Date now = new Date();\n        String source = getLinkd().getName()+\"/\"+discoveryLink.getPackageName();\n\n        for (final NodeToNodeLink lk : discoveryLink.getLinks()) {\n            \n            LOG.debug(\"storeDiscoveryLink: parsing link {}.\",lk);\n            DataLinkInterface link = getDatabaseLink(m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(Integer.valueOf(lk.getNodeId()),\n                                                                                       Integer.valueOf(lk.getIfindex())),lk.getNodeparentid(),lk.getParentifindex());\n\n            if (link == null) {\n                LOG.info(\"storeDiscoveryLink: no found interface on database for link {}. Creating a new one\",lk);\n                final OnmsNode onmsNode = m_nodeDao.get(lk.getNodeId());\n                link = new DataLinkInterface(\n                                          onmsNode,\n                                          lk.getIfindex(),\n                                          lk.getNodeparentid(),\n                                          lk.getParentifindex(),\n                                          StatusType.ACTIVE,\n                                          now);\n            } else {\n                link.setStatus(StatusType.ACTIVE);\n                link.setLastPollTime(now);\n            }\n            link.setSource(source);\n\n            DataLinkInterface reverselink = getDatabaseLink(m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(Integer.valueOf(lk.getNodeparentid()),\n                                                                                                          Integer.valueOf(lk.getParentifindex())), lk.getNodeId(), lk.getIfindex());\n            if (reverselink != null ) {\n                LOG.info(\"storeDiscoveryLink: Deleting found reverse link {}.\", reverselink);\n                m_dataLinkInterfaceDao.delete(reverselink);\n            }\n            LOG.debug(\"storeDiscoveryLink: Storing {}\", link);\n            m_dataLinkInterfaceDao.saveOrUpdate(link);\n        }\n\n        // FIXME remove this is you use mac address in DiscoveryLink memory\n        LOG.debug(\"storeDiscoveryLink: Parsing mac address links\");\n        for (final MacToNodeLink lkm : discoveryLink.getMacLinks()) {\n            final Collection<OnmsAtInterface> atInterfaces = m_atInterfaceDao.findByMacAddress(lkm.getMacAddress());\n            if (atInterfaces.size() == 0) {\n                LOG.debug(\"storeDiscoveryLink: No nodeid found on DB for mac address {} on link. Skipping.\", lkm.getMacAddress());\n                continue;\n            }\n            if (atInterfaces.size() > 1) {\n                LOG.debug(\"storeDiscoveryLink: More than one atInterface returned for the mac address {}. Duplicated ip/mac address. Skipping \", lkm.getMacAddress());\n                continue;\n            }\n            final OnmsAtInterface atInterface = atInterfaces.iterator().next();\n            if (!m_linkd.isInterfaceInPackage(atInterface.getIpAddress(),\n                                              discoveryLink.getPackageName())) {\n                LOG.debug(\"storeDiscoveryLink: IP address {} not found on package {}.  Skipping.\", atInterface.getIpAddress(),discoveryLink.getPackageName());\n                continue;\n            }\n\n            DataLinkInterface link = getDatabaseLink(m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(atInterface.getNode().getId(),\n                                                                                                  atInterface.getIfIndex()), lkm.getNodeparentid(), lkm.getParentifindex());\n            if (link == null) {\n                link = new DataLinkInterface(\n                                            atInterface.getNode(),\n                                            atInterface.getIfIndex(),\n                                            lkm.getNodeparentid(),\n                                            lkm.getParentifindex(),\n                                            StatusType.ACTIVE,\n                                            now);\n            } else {\n                link.setStatus(StatusType.ACTIVE);\n                link.setLastPollTime(now);\n            }\n            link.setSource(source);\n            LOG.debug(\"storeDiscoveryLink: Storing {}\", link);\n            m_dataLinkInterfaceDao.saveOrUpdate(link);\n        }\n        m_dataLinkInterfaceDao.deactivateIfOlderThan(now,source);\n        m_dataLinkInterfaceDao.deleteIfOlderThan(new Date(now.getTime()-3*discoveryLink.getSnmpPollInterval()),source);\n        m_dataLinkInterfaceDao.flush();\n    }","commit_id":"92d18e2c3755770f52c7edd1df141ab9c1c7ca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Override\n    public DataLinkInterface findByNodeIdAndIfIndex(final Integer nodeId, final Integer ifIndex) {\n        final CriteriaBuilder builder = new CriteriaBuilder(DataLinkInterface.class);\n        builder.alias(\"node\", \"node\", JoinType.LEFT_JOIN);\n        builder.eq(\"node.id\", nodeId);\n        builder.eq(\"ifIndex\", ifIndex);\n\n        final List<DataLinkInterface> interfaces = findMatching(builder.toCriteria());\n        if (interfaces.size() > 0) {\n            return interfaces.get(0);\n        }\n        return null;\n    }","id":67079,"modified_method":"@Override\n    public Collection<DataLinkInterface> findByNodeIdAndIfIndex(final Integer nodeId, final Integer ifIndex) {\n        final CriteriaBuilder builder = new CriteriaBuilder(DataLinkInterface.class);\n        builder.alias(\"node\", \"node\", JoinType.LEFT_JOIN);\n        builder.eq(\"node.id\", nodeId);\n        builder.eq(\"ifIndex\", ifIndex);\n\n        return findMatching(builder.toCriteria());\n    }","commit_id":"92d18e2c3755770f52c7edd1df141ab9c1c7ca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host = FROH_IP, port = 161, resource = \"classpath:linkd/nms0001/\" + FROH_NAME + \"-\"+FROH_IP + \"-walk.txt\"),\n            @JUnitSnmpAgent(host = OEDIPUS_IP, port = 161, resource = \"classpath:linkd/nms0001/\" + OEDIPUS_NAME + \"-\"+OEDIPUS_IP + \"-walk.txt\"),\n            @JUnitSnmpAgent(host = SIEGFRIE_IP, port = 161, resource = \"classpath:linkd/nms0001/\" + SIEGFRIE_NAME + \"-\"+SIEGFRIE_IP + \"-walk.txt\")\n    })\n    public void testNetwork17216Links() throws Exception {\n        \n        m_nodeDao.save(getFroh());\n        m_nodeDao.save(getOedipus());\n        m_nodeDao.save(getSiegFrie());\n        m_nodeDao.flush();\n\n        Package example1 = m_linkdConfig.getPackage(\"example1\");\n        example1.setUseBridgeDiscovery(false);\n        example1.setUseIpRouteDiscovery(false);\n        example1.setEnableVlanDiscovery(false);\n        example1.setUseOspfDiscovery(false);\n        example1.setUseLldpDiscovery(false);\n        \n        example1.setSaveStpInterfaceTable(false);\n        example1.setSaveRouteTable(false);\n        example1.setSaveStpNodeTable(false);\n\n        final OnmsNode froh = m_nodeDao.findByForeignId(\"linkd\", FROH_NAME);\n        final OnmsNode oedipus = m_nodeDao.findByForeignId(\"linkd\", OEDIPUS_NAME);\n        final OnmsNode siegfrie = m_nodeDao.findByForeignId(\"linkd\", SIEGFRIE_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(froh.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(oedipus.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(siegfrie.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(froh.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(oedipus.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(siegfrie.getId()));\n       \n        assertEquals(0,m_dataLinkInterfaceDao.countAll());\n        \n        final Collection<LinkableNode> nodes = m_linkd.getLinkableNodesOnPackage(\"example1\");\n\n        assertEquals(3, nodes.size());\n        \n        for (LinkableNode node: nodes) {\n            assertEquals(2, node.getIsisInterfaces().size());\n            switch(node.getNodeId()) {\n                case 1: assertEquals(FROH_ISIS_SYS_ID, node.getIsisSysId());\n                break;\n                case 2: assertEquals(OEDIPUS_ISIS_SYS_ID, node.getIsisSysId());\n                break;\n                case 3: assertEquals(SIEGFRIE_ISIS_SYS_ID, node.getIsisSysId());\n                break;\n                default: assertEquals(-1, node.getNodeId());\n                break;\n            }\n        }        \n        \n        assertTrue(m_linkd.runSingleLinkDiscovery(\"example1\"));\n\n        assertEquals(3,m_dataLinkInterfaceDao.countAll());\n        final List<DataLinkInterface> datalinkinterfaces = m_dataLinkInterfaceDao.findAll();\n\n        int start=getStartPoint(datalinkinterfaces);\n\n        /*\n         * \n         * These are the links among the following nodes discovered using \n         * only the isis protocol\n         * froh:ae1.0(599):10.1.3.6/30       <-->    oedipus:ae1.0(578):10.1.3.5/30\n         * froh:ae2.0(600):10.1.3.2/30       <-->    siegfrie:ae2.0(552):10.1.3.1/30\n         * oedipus:ae0.0(575):10.1.0.10/30   <-->    siegfrie:ae0.0(533):10.1.0.9/30\n         * \n         */\n        for (final DataLinkInterface datalinkinterface: datalinkinterfaces) {\n            \n            Integer linkid = datalinkinterface.getId();\n            if ( linkid == start) {\n                checkLink(froh, oedipus, 599, 578, datalinkinterface);\n            } else if (linkid == start+1 ) {\n                checkLink(froh, siegfrie, 600, 552, datalinkinterface);\n            } else if (linkid == start+2) {\n                checkLink(oedipus, siegfrie, 575, 533, datalinkinterface);\n            } else {\n                // error\n                checkLink(froh,froh,-1,-1,datalinkinterface);\n            } \n            \n        }\n        \n        DataLinkInterface iface = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(froh.getId(), Integer.valueOf(599));\n        iface.setNodeParentId(oedipus.getId());\n        iface.setParentIfIndex(578);\n        iface.setStatus(StatusType.ACTIVE);\n        iface.setLastPollTime(new Date());\n        m_dataLinkInterfaceDao.saveOrUpdate(iface);\n        \n        assertEquals(3, m_dataLinkInterfaceDao.countAll());\n    }","id":67080,"modified_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host = FROH_IP, port = 161, resource = \"classpath:linkd/nms0001/\" + FROH_NAME + \"-\"+FROH_IP + \"-walk.txt\"),\n            @JUnitSnmpAgent(host = OEDIPUS_IP, port = 161, resource = \"classpath:linkd/nms0001/\" + OEDIPUS_NAME + \"-\"+OEDIPUS_IP + \"-walk.txt\"),\n            @JUnitSnmpAgent(host = SIEGFRIE_IP, port = 161, resource = \"classpath:linkd/nms0001/\" + SIEGFRIE_NAME + \"-\"+SIEGFRIE_IP + \"-walk.txt\")\n    })\n    public void testNetwork17216Links() throws Exception {\n        \n        m_nodeDao.save(getFroh());\n        m_nodeDao.save(getOedipus());\n        m_nodeDao.save(getSiegFrie());\n        m_nodeDao.flush();\n\n        Package example1 = m_linkdConfig.getPackage(\"example1\");\n        example1.setUseBridgeDiscovery(false);\n        example1.setUseIpRouteDiscovery(false);\n        example1.setEnableVlanDiscovery(false);\n        example1.setUseOspfDiscovery(false);\n        example1.setUseLldpDiscovery(false);\n        \n        example1.setSaveStpInterfaceTable(false);\n        example1.setSaveRouteTable(false);\n        example1.setSaveStpNodeTable(false);\n\n        final OnmsNode froh = m_nodeDao.findByForeignId(\"linkd\", FROH_NAME);\n        final OnmsNode oedipus = m_nodeDao.findByForeignId(\"linkd\", OEDIPUS_NAME);\n        final OnmsNode siegfrie = m_nodeDao.findByForeignId(\"linkd\", SIEGFRIE_NAME);\n        \n        assertTrue(m_linkd.scheduleNodeCollection(froh.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(oedipus.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(siegfrie.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(froh.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(oedipus.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(siegfrie.getId()));\n       \n        assertEquals(0,m_dataLinkInterfaceDao.countAll());\n        \n        final Collection<LinkableNode> nodes = m_linkd.getLinkableNodesOnPackage(\"example1\");\n\n        assertEquals(3, nodes.size());\n        \n        for (LinkableNode node: nodes) {\n            assertEquals(2, node.getIsisInterfaces().size());\n            switch(node.getNodeId()) {\n                case 1: assertEquals(FROH_ISIS_SYS_ID, node.getIsisSysId());\n                break;\n                case 2: assertEquals(OEDIPUS_ISIS_SYS_ID, node.getIsisSysId());\n                break;\n                case 3: assertEquals(SIEGFRIE_ISIS_SYS_ID, node.getIsisSysId());\n                break;\n                default: assertEquals(-1, node.getNodeId());\n                break;\n            }\n        }        \n        \n        assertTrue(m_linkd.runSingleLinkDiscovery(\"example1\"));\n\n        assertEquals(3,m_dataLinkInterfaceDao.countAll());\n        final List<DataLinkInterface> datalinkinterfaces = m_dataLinkInterfaceDao.findAll();\n\n        int start=getStartPoint(datalinkinterfaces);\n\n        /*\n         * \n         * These are the links among the following nodes discovered using \n         * only the isis protocol\n         * froh:ae1.0(599):10.1.3.6/30       <-->    oedipus:ae1.0(578):10.1.3.5/30\n         * froh:ae2.0(600):10.1.3.2/30       <-->    siegfrie:ae2.0(552):10.1.3.1/30\n         * oedipus:ae0.0(575):10.1.0.10/30   <-->    siegfrie:ae0.0(533):10.1.0.9/30\n         * \n         */\n        for (final DataLinkInterface datalinkinterface: datalinkinterfaces) {\n            \n            Integer linkid = datalinkinterface.getId();\n            if ( linkid == start) {\n                checkLink(froh, oedipus, 599, 578, datalinkinterface);\n            } else if (linkid == start+1 ) {\n                checkLink(froh, siegfrie, 600, 552, datalinkinterface);\n            } else if (linkid == start+2) {\n                checkLink(oedipus, siegfrie, 575, 533, datalinkinterface);\n            } else {\n                // error\n                checkLink(froh,froh,-1,-1,datalinkinterface);\n            } \n            \n        }\n        \n        DataLinkInterface iface = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(froh.getId(), Integer.valueOf(599)).iterator().next();\n        iface.setNodeParentId(oedipus.getId());\n        iface.setParentIfIndex(578);\n        iface.setStatus(StatusType.ACTIVE);\n        iface.setLastPollTime(new Date());\n        m_dataLinkInterfaceDao.saveOrUpdate(iface);\n        \n        assertEquals(3, m_dataLinkInterfaceDao.countAll());\n    }","commit_id":"92d18e2c3755770f52c7edd1df141ab9c1c7ca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=CISCO_WS_C2948_IP, port=161, resource=\"classpath:linkd/nms7467/\"+CISCO_WS_C2948_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=CISCO_C870_IP, port=161, resource=\"classpath:linkd/nms7467/\"+CISCO_C870_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=DARWIN_10_8_IP, port=161, resource=\"classpath:linkd/nms7467/\"+DARWIN_10_8_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=NETGEAR_SW_108_IP, port=161, resource=\"classpath:linkd/nms7467/\"+NETGEAR_SW_108_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=LINUX_UBUNTU_IP, port=161, resource=\"classpath:linkd/nms7467/\"+LINUX_UBUNTU_IP+\"-walk.txt\")\n    })\n    // mrgarrison:172.20.1.5:-1   -------- ciscoswitch:172.20.1.7:47 ---bridge\n    // workstation:172.20.1.101:-1-------- ciscoswitch:172.20.1.7:47 ---bridge\n    // mrmakay:172.20.1.1:3       -------- ciscoswitch:172.20.1.7:52 ---cdp\n    // mrmakay:172.20.1.1:13      -------- ciscoswitch:172.20.1.7:52 ---bridge \n    // mrmakay:172.20.1.1:12      -------- ciscoswitch:172.20.1.7:52 ---bridge \n    // linuxubuntu:172.20.1.14:4  -------- ciscoswitch:172.20.1.7:11 ---bridge\n    // ng108switch:172.20.1.8:8   -------- ciscoswitch:172.20.1.7:9  ---bridge\n    // mac:172.20.1.28:4          -------- ng108switch:172.20.1.8:1  ---bridge\n    public void testAllTogether() throws Exception {\n\n        Package example1 = m_linkdConfig.getPackage(\"example1\");\n        example1.setUseLldpDiscovery(false);\n        example1.setUseOspfDiscovery(false);\n        example1.setUseIsisDiscovery(false);\n        example1.setUseIpRouteDiscovery(false);\n        example1.setForceIpRouteDiscoveryOnEthernet(false);\n        example1.setSaveRouteTable(true);\n        example1.setUseCdpDiscovery(true);\n\n        m_nodeDao.save(getCiscoC870());\n        m_nodeDao.save(getCiscoWsC2948());\n        m_nodeDao.save(getNetGearSw108());\n        m_nodeDao.save(getDarwin108());       \n        m_nodeDao.save(getLinuxUbuntu());\n        m_nodeDao.save(getNodeWithoutSnmp(ACCESSPOINT_NAME, ACCESSPOINT_IP));\n        m_nodeDao.save(getNodeWithoutSnmp(WORKSTATION_NAME, WORKSTATION_IP));\n\n        m_nodeDao.flush();\n\n\n        final OnmsNode ciscorouter = m_nodeDao.findByForeignId(\"linkd\", CISCO_C870_NAME);\n        final OnmsNode ciscows = m_nodeDao.findByForeignId(\"linkd\", CISCO_WS_C2948_NAME);\n        final OnmsNode ngsw108 = m_nodeDao.findByForeignId(\"linkd\", NETGEAR_SW_108_NAME);\n        final OnmsNode mac = m_nodeDao.findByForeignId(\"linkd\", DARWIN_10_8_NAME);\n        final OnmsNode linux = m_nodeDao.findByForeignId(\"linkd\", LINUX_UBUNTU_NAME);\n        final OnmsNode ciscoap = m_nodeDao.findByForeignId(\"linkd\", ACCESSPOINT_NAME);\n        final OnmsNode workstation = m_nodeDao.findByForeignId(\"linkd\", WORKSTATION_NAME);\n\n\n        \n        assertEquals(7, m_nodeDao.countAll());\n\n        assertTrue(m_linkd.scheduleNodeCollection(ciscows.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(ciscorouter.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(ngsw108.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(mac.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(linux.getId()));\n        assertTrue(!m_linkd.scheduleNodeCollection(ciscoap.getId()));\n        assertTrue(!m_linkd.scheduleNodeCollection(workstation.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscorouter.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscows.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ngsw108.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(mac.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(linux.getId()));\n        \n        final Collection<LinkableNode> linkables = m_linkd.getLinkableNodes();\n        assertEquals(5, linkables.size());       \n\n        for (OnmsAtInterface onmsat: m_atInterfaceDao.findAll()) {\n            printAtInterface(onmsat);\n        }\n        assertEquals(0,m_dataLinkInterfaceDao.countAll());\n                                       \n        assertEquals(5, m_linkd.getLinkableNodesOnPackage(\"example1\").size());\n\n        assertTrue(m_linkd.runSingleLinkDiscovery(\"example1\"));\n\n        for (DataLinkInterface link: m_dataLinkInterfaceDao.findAll())\n            printLink(link);\n        assertEquals(8,m_dataLinkInterfaceDao.countAll());\n        \n        //\n        final DataLinkInterface mactongsw108link = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(mac.getId(),4);\n        \n        assertEquals(mac.getId(), mactongsw108link.getNode().getId());\n        assertEquals(4,mactongsw108link.getIfIndex().intValue());\n        assertEquals(ngsw108.getId(), mactongsw108link.getNodeParentId());\n        assertEquals(1, mactongsw108link.getParentIfIndex().intValue());        \n\n        final DataLinkInterface ngsw108linktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(ngsw108.getId(), 8);\n        \n        assertEquals(ngsw108.getId(), ngsw108linktociscows.getNode().getId());\n        assertEquals(8,ngsw108linktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), ngsw108linktociscows.getNodeParentId());\n        assertEquals(9, ngsw108linktociscows.getParentIfIndex().intValue());\n\n        final DataLinkInterface ciscorouterlinktociscows2 = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(ciscows.getId(), 52);\n        assertEquals(ciscows.getId(), ciscorouterlinktociscows2.getNode().getId());\n        assertEquals(52, ciscorouterlinktociscows2.getIfIndex().intValue());\n        assertEquals(ciscorouter.getId(), ciscorouterlinktociscows2.getNodeParentId());\n        assertEquals(3, ciscorouterlinktociscows2.getParentIfIndex().intValue());\n\n        final DataLinkInterface linuxubuntulinktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(linux.getId(), 4);\n        \n        assertEquals(linux.getId(), linuxubuntulinktociscows.getNode().getId());\n        assertEquals(4,linuxubuntulinktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), linuxubuntulinktociscows.getNodeParentId());\n        assertEquals(11, linuxubuntulinktociscows.getParentIfIndex().intValue());\n\n        final DataLinkInterface workstationlinktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(workstation.getId(), -1);\n        \n        assertEquals(workstation.getId(), workstationlinktociscows.getNode().getId());\n        assertEquals(-1,workstationlinktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), workstationlinktociscows.getNodeParentId());\n        assertEquals(47, workstationlinktociscows.getParentIfIndex().intValue());\n\n        final DataLinkInterface ciscoaplinktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(ciscoap.getId(), -1);\n        \n        assertEquals(ciscoap.getId(), ciscoaplinktociscows.getNode().getId());\n        assertEquals(-1, ciscoaplinktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), ciscoaplinktociscows.getNodeParentId());\n        assertEquals(47,ciscoaplinktociscows.getParentIfIndex().intValue());\n        \n\n        Thread.sleep(5000);\n\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscorouter.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscows.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ngsw108.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(mac.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(linux.getId()));\n\n        assertTrue(m_linkd.runSingleLinkDiscovery(\"example1\"));\n\n        assertEquals(8,m_dataLinkInterfaceDao.countAll());\n\n    }","id":67081,"modified_method":"@Test\n    @JUnitSnmpAgents(value={\n            @JUnitSnmpAgent(host=CISCO_WS_C2948_IP, port=161, resource=\"classpath:linkd/nms7467/\"+CISCO_WS_C2948_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=CISCO_C870_IP, port=161, resource=\"classpath:linkd/nms7467/\"+CISCO_C870_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=DARWIN_10_8_IP, port=161, resource=\"classpath:linkd/nms7467/\"+DARWIN_10_8_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=NETGEAR_SW_108_IP, port=161, resource=\"classpath:linkd/nms7467/\"+NETGEAR_SW_108_IP+\"-walk.txt\"),\n            @JUnitSnmpAgent(host=LINUX_UBUNTU_IP, port=161, resource=\"classpath:linkd/nms7467/\"+LINUX_UBUNTU_IP+\"-walk.txt\")\n    })\n    // mrgarrison:172.20.1.5:-1   -------- ciscoswitch:172.20.1.7:47 ---bridge\n    // workstation:172.20.1.101:-1-------- ciscoswitch:172.20.1.7:47 ---bridge\n    // mrmakay:172.20.1.1:3       -------- ciscoswitch:172.20.1.7:52 ---cdp\n    // mrmakay:172.20.1.1:13      -------- ciscoswitch:172.20.1.7:52 ---bridge \n    // mrmakay:172.20.1.1:12      -------- ciscoswitch:172.20.1.7:52 ---bridge \n    // linuxubuntu:172.20.1.14:4  -------- ciscoswitch:172.20.1.7:11 ---bridge\n    // ng108switch:172.20.1.8:8   -------- ciscoswitch:172.20.1.7:9  ---bridge\n    // mac:172.20.1.28:4          -------- ng108switch:172.20.1.8:1  ---bridge\n    public void testAllTogether() throws Exception {\n\n        Package example1 = m_linkdConfig.getPackage(\"example1\");\n        example1.setUseLldpDiscovery(false);\n        example1.setUseOspfDiscovery(false);\n        example1.setUseIsisDiscovery(false);\n        example1.setUseIpRouteDiscovery(false);\n        example1.setForceIpRouteDiscoveryOnEthernet(false);\n        example1.setSaveRouteTable(true);\n        example1.setUseCdpDiscovery(true);\n\n        m_nodeDao.save(getCiscoC870());\n        m_nodeDao.save(getCiscoWsC2948());\n        m_nodeDao.save(getNetGearSw108());\n        m_nodeDao.save(getDarwin108());       \n        m_nodeDao.save(getLinuxUbuntu());\n        m_nodeDao.save(getNodeWithoutSnmp(ACCESSPOINT_NAME, ACCESSPOINT_IP));\n        m_nodeDao.save(getNodeWithoutSnmp(WORKSTATION_NAME, WORKSTATION_IP));\n\n        m_nodeDao.flush();\n\n\n        final OnmsNode ciscorouter = m_nodeDao.findByForeignId(\"linkd\", CISCO_C870_NAME);\n        final OnmsNode ciscows = m_nodeDao.findByForeignId(\"linkd\", CISCO_WS_C2948_NAME);\n        final OnmsNode ngsw108 = m_nodeDao.findByForeignId(\"linkd\", NETGEAR_SW_108_NAME);\n        final OnmsNode mac = m_nodeDao.findByForeignId(\"linkd\", DARWIN_10_8_NAME);\n        final OnmsNode linux = m_nodeDao.findByForeignId(\"linkd\", LINUX_UBUNTU_NAME);\n        final OnmsNode ciscoap = m_nodeDao.findByForeignId(\"linkd\", ACCESSPOINT_NAME);\n        final OnmsNode workstation = m_nodeDao.findByForeignId(\"linkd\", WORKSTATION_NAME);\n\n\n        \n        assertEquals(7, m_nodeDao.countAll());\n\n        assertTrue(m_linkd.scheduleNodeCollection(ciscows.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(ciscorouter.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(ngsw108.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(mac.getId()));\n        assertTrue(m_linkd.scheduleNodeCollection(linux.getId()));\n        assertTrue(!m_linkd.scheduleNodeCollection(ciscoap.getId()));\n        assertTrue(!m_linkd.scheduleNodeCollection(workstation.getId()));\n\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscorouter.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscows.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ngsw108.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(mac.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(linux.getId()));\n        \n        final Collection<LinkableNode> linkables = m_linkd.getLinkableNodes();\n        assertEquals(5, linkables.size());       \n\n        for (OnmsAtInterface onmsat: m_atInterfaceDao.findAll()) {\n            printAtInterface(onmsat);\n        }\n        assertEquals(0,m_dataLinkInterfaceDao.countAll());\n                                       \n        assertEquals(5, m_linkd.getLinkableNodesOnPackage(\"example1\").size());\n\n        assertTrue(m_linkd.runSingleLinkDiscovery(\"example1\"));\n\n        for (DataLinkInterface link: m_dataLinkInterfaceDao.findAll())\n            printLink(link);\n        assertEquals(8,m_dataLinkInterfaceDao.countAll());\n        \n        //\n        final DataLinkInterface mactongsw108link = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(mac.getId(),4).iterator().next();\n        \n        assertEquals(mac.getId(), mactongsw108link.getNode().getId());\n        assertEquals(4,mactongsw108link.getIfIndex().intValue());\n        assertEquals(ngsw108.getId(), mactongsw108link.getNodeParentId());\n        assertEquals(1, mactongsw108link.getParentIfIndex().intValue());        \n\n        final DataLinkInterface ngsw108linktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(ngsw108.getId(), 8).iterator().next();\n        \n        assertEquals(ngsw108.getId(), ngsw108linktociscows.getNode().getId());\n        assertEquals(8,ngsw108linktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), ngsw108linktociscows.getNodeParentId());\n        assertEquals(9, ngsw108linktociscows.getParentIfIndex().intValue());\n\n        final DataLinkInterface ciscorouterlinktociscows2 = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(ciscows.getId(), 52).iterator().next();\n        assertEquals(ciscows.getId(), ciscorouterlinktociscows2.getNode().getId());\n        assertEquals(52, ciscorouterlinktociscows2.getIfIndex().intValue());\n        assertEquals(ciscorouter.getId(), ciscorouterlinktociscows2.getNodeParentId());\n        assertEquals(3, ciscorouterlinktociscows2.getParentIfIndex().intValue());\n\n        final DataLinkInterface linuxubuntulinktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(linux.getId(), 4).iterator().next();\n        \n        assertEquals(linux.getId(), linuxubuntulinktociscows.getNode().getId());\n        assertEquals(4,linuxubuntulinktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), linuxubuntulinktociscows.getNodeParentId());\n        assertEquals(11, linuxubuntulinktociscows.getParentIfIndex().intValue());\n\n        final DataLinkInterface workstationlinktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(workstation.getId(), -1).iterator().next();\n        \n        assertEquals(workstation.getId(), workstationlinktociscows.getNode().getId());\n        assertEquals(-1,workstationlinktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), workstationlinktociscows.getNodeParentId());\n        assertEquals(47, workstationlinktociscows.getParentIfIndex().intValue());\n\n        final DataLinkInterface ciscoaplinktociscows = m_dataLinkInterfaceDao.findByNodeIdAndIfIndex(ciscoap.getId(), -1).iterator().next();\n        \n        assertEquals(ciscoap.getId(), ciscoaplinktociscows.getNode().getId());\n        assertEquals(-1, ciscoaplinktociscows.getIfIndex().intValue());\n        assertEquals(ciscows.getId(), ciscoaplinktociscows.getNodeParentId());\n        assertEquals(47,ciscoaplinktociscows.getParentIfIndex().intValue());\n        \n\n        Thread.sleep(5000);\n\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscorouter.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ciscows.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(ngsw108.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(mac.getId()));\n        assertTrue(m_linkd.runSingleSnmpCollection(linux.getId()));\n\n        assertTrue(m_linkd.runSingleLinkDiscovery(\"example1\"));\n\n        assertEquals(8,m_dataLinkInterfaceDao.countAll());\n\n    }","commit_id":"92d18e2c3755770f52c7edd1df141ab9c1c7ca40","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EPackageDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getEPackageDescriptor());\n\t\t\t}\n\t\t};\n\t}","id":67082,"modified_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EPackageDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getEPackageDescriptor());\n\t\t\t}\n\t\t};\n\t\tsuperClassScope = new InverseReferenceCache<EClassDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EClassDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn source.getSuperClasses() != null ? Arrays.asList(source.getSuperClasses()) : new ArrayList<EClassDescriptor>(0);\n\t\t\t}\n\t\t};\n\t}","commit_id":"2d79178d7848bba8cf2c5611cb2d1f7701ea15ed","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void store(EClassDescriptor element) {\n\t\tsuper.store(element);\n\t\tePackageScope.put(element);\n\t}","id":67083,"modified_method":"@Override\n\tpublic void store(EClassDescriptor element) {\n\t\tsuper.store(element);\n\t\tePackageScope.put(element);\n\t\tsuperClassScope.put(element);\n\t}","commit_id":"2d79178d7848bba8cf2c5611cb2d1f7701ea15ed","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tprotected Collection<EClassDescriptor> scope() {\n\t\t\tCollection<EClassDescriptor> eClassesByEPackage = ePackageScope.lookup(ePackageDescriptor, ePackageQuery);\n\t\t\tif(eClassesByEPackage == null) {\n\t\t\t\treturn super.scope();\n\t\t\t}\n\t\t\treturn eClassesByEPackage;\n\t\t}","id":67084,"modified_method":"@Override\n\t\tprotected Collection<EClassDescriptor> scope() {\n\t\t\tCollection<EClassDescriptor> eClassesByEPackage = ePackageScope.lookup(ePackageDescriptor, ePackageQuery);\n\t\t\tCollection<EClassDescriptor> eClassesBySuperClass = superClassScope.lookup(superClassDescriptor, superClassQuery);\n\t\t\tCollection<EClassDescriptor> mergedScopes = mergeScopes(eClassesByEPackage, eClassesBySuperClass);\n\t\t\treturn (mergedScopes == null) ? super.scope() : mergedScopes;\n\t\t}","commit_id":"2d79178d7848bba8cf2c5611cb2d1f7701ea15ed","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void delete(EClassDescriptor element) {\n\t\tsuper.delete(element);\n\t\tePackageScope.remove(element);\n\t}","id":67085,"modified_method":"@Override\n\tpublic void delete(EClassDescriptor element) {\n\t\tsuper.delete(element);\n\t\tePackageScope.remove(element);\n\t\tsuperClassScope.remove(element);\n\t}","commit_id":"2d79178d7848bba8cf2c5611cb2d1f7701ea15ed","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean matches(EObjectDescriptor elementDescriptor) {\n\t\t\tif (matchesGlobbing(elementDescriptor.getFragment(), fragmentPattern)\n\t\t\t\t\t&& matchesGlobbing(elementDescriptor.getName(), namePattern)\n\t\t\t\t\t&& (typeDescriptor == null || typeDescriptor.equals(elementDescriptor.getEClassDescriptor()))) {\n\t\t\t\tif (userDataPatterns != null) {\n\t\t\t\t\tfor (Entry<String, String> userDataEntry : userDataPatterns.entrySet()) {\n\t\t\t\t\t\tif (!matchesGlobbing(elementDescriptor.getUserData(userDataEntry.getKey()), userDataEntry\n\t\t\t\t\t\t\t\t.getValue())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","id":67086,"modified_method":"public boolean matches(EObjectDescriptor elementDescriptor) {\n\t\t\tif (matchesGlobbing(elementDescriptor.getFragment(), fragmentPattern)\n\t\t\t\t\t&& matchesGlobbing(elementDescriptor.getName(), namePattern)) {\n\t\t\t\tif (userDataPatterns != null) {\n\t\t\t\t\tfor (Entry<String, String> userDataEntry : userDataPatterns.entrySet()) {\n\t\t\t\t\t\tif (!matchesGlobbing(elementDescriptor.getUserData(userDataEntry.getKey()), userDataEntry\n\t\t\t\t\t\t\t\t.getValue())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","commit_id":"2d79178d7848bba8cf2c5611cb2d1f7701ea15ed","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean tryIndexResource(IResource resource, boolean isDeleted) {\n\t\tif (resource instanceof IFile) {\n\t\t\tIFile file = (IFile) resource;\n\t\t\ttry {\n\t\t\t\tdeleteMarkers(file);\n\t\t\t\tSet<String> keySet = Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().keySet();\n\t\t\t\tif (keySet.contains(file.getFileExtension())) {\n\t\t\t\t\tURI resourceURI = URI.createPlatformResourceURI(resource.getFullPath().toString(), true);\n\t\t\t\t\tResource.Factory emfResourceFactory = Resource.Factory.Registry.INSTANCE.getFactory(resourceURI);\n\t\t\t\t\tif (emfResourceFactory != null) {\n\t\t\t\t\t\tif (isDeleted)\n\t\t\t\t\t\t\tindexBuilder.resourceChanged(resourceURI);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindexBuilder.resourceDeleted(resourceURI);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\taddMarker(file, e.getMessage(), 0, IMarker.SEVERITY_ERROR);\n\t\t\t\tEmfIndexUIPlugin.getDefault().getLog().log(\n\t\t\t\t\t\tnew Status(IStatus.ERROR, EmfIndexUIPlugin.PLUGIN_ID, \"Cannot index resource \"\n\t\t\t\t\t\t\t\t+ resource.getFullPath().toString(), e));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":67087,"modified_method":"protected boolean tryIndexResource(IResource resource, boolean isDeleted) {\n\t\tif (resource instanceof IFile) {\n\t\t\tIFile file = (IFile) resource;\n\t\t\ttry {\n\t\t\t\tdeleteMarkers(file);\n\t\t\t\tSet<String> keySet = Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().keySet();\n\t\t\t\tif (keySet.contains(file.getFileExtension())) {\n\t\t\t\t\tURI resourceURI = URI.createPlatformResourceURI(resource.getFullPath().toString(), true);\n\t\t\t\t\tResource.Factory emfResourceFactory = Resource.Factory.Registry.INSTANCE.getFactory(resourceURI);\n\t\t\t\t\tif (emfResourceFactory != null) {\n\t\t\t\t\t\tif (isDeleted)\n\t\t\t\t\t\t\tindexBuilder.resourceDeleted(resourceURI);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindexBuilder.resourceChanged(resourceURI);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\taddMarker(file, e.getMessage(), 0, IMarker.SEVERITY_ERROR);\n\t\t\t\tEmfIndexUIPlugin.getDefault().getLog().log(\n\t\t\t\t\t\tnew Status(IStatus.ERROR, EmfIndexUIPlugin.PLUGIN_ID, \"Cannot index resource \"\n\t\t\t\t\t\t\t\t+ resource.getFullPath().toString(), e));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"2d79178d7848bba8cf2c5611cb2d1f7701ea15ed","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testIntegration() throws Exception {\n\t\tecoreFeeder.index(EcorePackage.eINSTANCE, true);\n\t\tindexExampleResource();\n\t\tIterable<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\").executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tIterator<EObjectDescriptor> eObjectIterator = elementResult.iterator();\n\t\tEObjectDescriptor elementDescriptor = eObjectIterator.next();\n\t\tassertFalse(eObjectIterator.hasNext());\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), true);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tIterable<EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\").executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tIterator<EClassDescriptor> eClassIterator = typeResult.iterator();\n\t\tEClassDescriptor typeDescriptor0 = eClassIterator.next();\n\t\tassertFalse(eClassIterator.hasNext());\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\t\tEClassDescriptor[] superClasses = typeDescriptor0.getSuperClasses();\n\t\tassertNotNull(superClasses);\n\t\t// four super classes: EClassifier, ENamedElement, EModelElement and\n\t\t// EObject\n\t\tassertEquals(4, superClasses.length);\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tIterable<ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.iterator().hasNext());\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\t}","id":67088,"modified_method":"public void testIntegration() throws Exception {\n\t\tecoreFeeder.index(EcorePackage.eINSTANCE, true);\n\t\tindexExampleResource();\n\t\tIterable<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\").executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tIterator<EObjectDescriptor> eObjectIterator = elementResult.iterator();\n\t\tEObjectDescriptor elementDescriptor = eObjectIterator.next();\n\t\tassertFalse(eObjectIterator.hasNext());\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), true);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tIterable<EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\").executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tIterator<EClassDescriptor> eClassIterator = typeResult.iterator();\n\t\tEClassDescriptor typeDescriptor0 = eClassIterator.next();\n\t\tassertFalse(eClassIterator.hasNext());\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\t\tEClassDescriptor[] superClasses = typeDescriptor0.getSuperClasses();\n\t\tassertNotNull(superClasses);\n\t\t// four super classes: EClassifier, ENamedElement, EModelElement and\n\t\t// EObject\n\t\tassertEquals(4, superClasses.length);\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tIterable<ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.iterator().hasNext());\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\n\t\torg.eclipse.emf.index.EObjectDescriptor.Query objectQuery = index.eObjectDAO().createQuery();\n\t\tobjectQuery.eClass().name(\"EClassifier\").ePackage().nsURI(EcorePackage.eNS_URI);\n\t\tassertEquals(15, CollectionUtils.toList(objectQuery.executeListResult()).size());\n\n\t\tobjectQuery = index.eObjectDAO().createQuery();\n\t\tobjectQuery.eClass(index.eClassDAO().createQueryEClass(EcorePackage.eINSTANCE.getEClassifier()).executeSingleResult());\n\t\tassertEquals(15, CollectionUtils.toList(objectQuery.executeListResult()).size());\n\t}","commit_id":"2d79178d7848bba8cf2c5611cb2d1f7701ea15ed","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n    public JsNode visitLabeledExpression(\n            @NotNull JetLabeledExpression expression, TranslationContext context\n    ) {\n        JetExpression baseExpression = expression.getBaseExpression();\n        assert baseExpression != null;\n        JsScope scope = context.scope();\n        assert scope instanceof JsFunctionScope: \"Labeled statement is unexpected outside of function scope\";\n        JsName name = ((JsFunctionScope) scope).declareNameUnsafe(getReferencedName(expression.getTargetLabel()));\n        JsStatement baseStatement = Translation.translateAsStatement(baseExpression, context);\n        return new JsLabel(name, baseStatement).source(expression);\n    }","id":67089,"modified_method":"@Override\n    public JsNode visitLabeledExpression(\n            @NotNull JetLabeledExpression expression, TranslationContext context\n    ) {\n        JetExpression baseExpression = expression.getBaseExpression();\n        assert baseExpression != null;\n        JsScope scope = context.scope();\n        assert scope instanceof JsFunctionScope: \"Labeled statement is unexpected outside of function scope\";\n        JsFunctionScope functionScope = (JsFunctionScope) scope;\n        String labelIdent = getReferencedName(expression.getTargetLabel());\n        JsName labelName = functionScope.enterLabel(labelIdent);\n        JsStatement baseStatement = Translation.translateAsStatement(baseExpression, context);\n        functionScope.exitLabel();\n        return new JsLabel(labelName, baseStatement).source(expression);\n    }","commit_id":"1f87bea78f94b53251b74a063d4ab1ec6680ba53","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static JsNameRef getTargetLabel(JetExpressionWithLabel expression, TranslationContext context) {\n        JetSimpleNameExpression labelElement = expression.getTargetLabel();\n        if (labelElement == null) {\n            return null;\n        }\n        else {\n            JsName name = context.scope().findName(getReferencedName(labelElement));\n            assert name != null;\n            return name.makeRef();\n        }\n    }","id":67090,"modified_method":"private static JsNameRef getTargetLabel(JetExpressionWithLabel expression, TranslationContext context) {\n        JetSimpleNameExpression labelElement = expression.getTargetLabel();\n        if (labelElement == null) {\n            return null;\n        }\n\n        String labelIdent = getReferencedName(labelElement);\n        JsScope scope = context.scope();\n        assert scope instanceof JsFunctionScope: \"Labeled statement is unexpected outside of function scope\";\n        JsName labelName = ((JsFunctionScope) scope).findLabel(labelIdent);\n        assert labelName != null;\n        return labelName.makeRef();\n    }","commit_id":"1f87bea78f94b53251b74a063d4ab1ec6680ba53","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void endVisit(JsFunction function, JsContext context) {\n        super.endVisit(function, context);\n        removeUnusedLocalFunctionDeclarations(function);\n        processedFunctions.add(function);\n\n        assert inProcessFunctions.contains(function);\n        inProcessFunctions.remove(function);\n\n        inliningContexts.pop();\n    }","id":67091,"modified_method":"@Override\n    public void endVisit(JsFunction function, JsContext context) {\n        super.endVisit(function, context);\n        refreshLabelNames(getInliningContext().newNamingContext(), function);\n\n        removeUnusedLocalFunctionDeclarations(function);\n        processedFunctions.add(function);\n\n        assert inProcessFunctions.contains(function);\n        inProcessFunctions.remove(function);\n\n        inliningContexts.pop();\n    }","commit_id":"1f87bea78f94b53251b74a063d4ab1ec6680ba53","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JsScope(JsScope parent, @NotNull String description, @Nullable String scopeId) {\n        assert (parent != null);\n        this.scopeId = scopeId;\n        this.description = description;\n        this.parent = parent;\n    }","id":67092,"modified_method":"public JsScope(JsScope parent, @NotNull String description, @Nullable String scopeId) {\n        this.scopeId = scopeId;\n        this.description = description;\n        this.parent = parent;\n    }","commit_id":"1f87bea78f94b53251b74a063d4ab1ec6680ba53","url":"https://github.com/JetBrains/kotlin"},{"original_method":"/**\n     * During inlining names can be refreshed multiple times,\n     * so \"a\" becomes \"a_0\", then becomes \"a_0_0\"\n     * in case a_0 has been declared in calling scope.\n     *\n     * That's ugly. To resolve it, we rename\n     * clashing names with \"[_$]\\\\d+\" suffix,\n     * incrementing last number.\n     *\n     * Fresh name for \"a0\" should still be \"a0_0\".\n     */\n    @NotNull\n    private String getFreshIdent(@NotNull String suggestedIdent) {\n        char sep = '_';\n        String baseName = suggestedIdent;\n        int counter = 0;\n\n        Matcher matcher = FRESH_NAME_SUFFIX.matcher(suggestedIdent);\n        if (matcher.find()) {\n            String group = matcher.group();\n            baseName = matcher.replaceAll(\"\");\n            sep = group.charAt(0);\n            counter = Integer.valueOf(group.substring(1));\n        }\n\n        String freshName = suggestedIdent;\n        while (hasOwnName(freshName)) {\n            freshName = baseName + sep + counter++;\n        }\n\n        return freshName;\n    }","id":67093,"modified_method":"/**\n     * During inlining names can be refreshed multiple times,\n     * so \"a\" becomes \"a_0\", then becomes \"a_0_0\"\n     * in case a_0 has been declared in calling scope.\n     *\n     * That's ugly. To resolve it, we rename\n     * clashing names with \"[_$]\\\\d+\" suffix,\n     * incrementing last number.\n     *\n     * Fresh name for \"a0\" should still be \"a0_0\".\n     */\n    @NotNull\n    protected String getFreshIdent(@NotNull String suggestedIdent) {\n        char sep = '_';\n        String baseName = suggestedIdent;\n        int counter = 0;\n\n        Matcher matcher = FRESH_NAME_SUFFIX.matcher(suggestedIdent);\n        if (matcher.find()) {\n            String group = matcher.group();\n            baseName = matcher.replaceAll(\"\");\n            sep = group.charAt(0);\n            counter = Integer.valueOf(group.substring(1));\n        }\n\n        String freshName = suggestedIdent;\n        while (hasOwnName(freshName)) {\n            freshName = baseName + sep + counter++;\n        }\n\n        return freshName;\n    }","commit_id":"1f87bea78f94b53251b74a063d4ab1ec6680ba53","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n\tpublic void delete(EClassDescriptor element) {\n\t\tsuper.delete(element);\n\t\tePackageScope.remove(element);\n\t}","id":67094,"modified_method":"@Override\n\tpublic void delete(EClassDescriptor element) {\n\t\tsuper.delete(element);\n\t\tePackageScope.remove(element);\n\t\tsuperClassScope.remove(element);\n\t}","commit_id":"c9be9e36ded1eb67daff640393d01cdb1f4fc9f0","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tpublic void store(EClassDescriptor element) {\n\t\tsuper.store(element);\n\t\tePackageScope.put(element);\n\t}","id":67095,"modified_method":"@Override\n\tpublic void store(EClassDescriptor element) {\n\t\tsuper.store(element);\n\t\tePackageScope.put(element);\n\t\tsuperClassScope.put(element);\n\t}","commit_id":"c9be9e36ded1eb67daff640393d01cdb1f4fc9f0","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tprotected Collection<EClassDescriptor> scope() {\n\t\t\tCollection<EClassDescriptor> eClassesByEPackage = ePackageScope.lookup(ePackageDescriptor, ePackageQuery);\n\t\t\tif(eClassesByEPackage == null) {\n\t\t\t\treturn super.scope();\n\t\t\t}\n\t\t\treturn eClassesByEPackage;\n\t\t}","id":67096,"modified_method":"@Override\n\t\tprotected Collection<EClassDescriptor> scope() {\n\t\t\tCollection<EClassDescriptor> eClassesByEPackage = ePackageScope.lookup(ePackageDescriptor, ePackageQuery);\n\t\t\tCollection<EClassDescriptor> eClassesBySuperClass = superClassScope.lookup(superClassDescriptor, superClassQuery);\n\t\t\tCollection<EClassDescriptor> mergedScopes = mergeScopes(eClassesByEPackage, eClassesBySuperClass);\n\t\t\treturn (mergedScopes == null) ? super.scope() : mergedScopes;\n\t\t}","commit_id":"c9be9e36ded1eb67daff640393d01cdb1f4fc9f0","url":"https://github.com/eclipse/xtext"},{"original_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EPackageDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getEPackageDescriptor());\n\t\t\t}\n\t\t};\n\t}","id":67097,"modified_method":"public EClassDAOImpl(IIndexStore indexStore) {\n\t\tsuper(indexStore);\n\t\tePackageScope = new InverseReferenceCache<EPackageDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EPackageDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn Collections.singletonList(source.getEPackageDescriptor());\n\t\t\t}\n\t\t};\n\t\tsuperClassScope = new InverseReferenceCache<EClassDescriptor, EClassDescriptor>(){\n\t\t\t@Override\n\t\t\tprotected List<EClassDescriptor> targets(EClassDescriptor source) {\n\t\t\t\treturn source.getSuperClasses() != null ? Arrays.asList(source.getSuperClasses()) : new ArrayList<EClassDescriptor>(0);\n\t\t\t}\n\t\t};\n\t}","commit_id":"c9be9e36ded1eb67daff640393d01cdb1f4fc9f0","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean matches(EObjectDescriptor elementDescriptor) {\n\t\t\tif (matchesGlobbing(elementDescriptor.getFragment(), fragmentPattern)\n\t\t\t\t\t&& matchesGlobbing(elementDescriptor.getName(), namePattern)\n\t\t\t\t\t&& (typeDescriptor == null || typeDescriptor.equals(elementDescriptor.getEClassDescriptor()))) {\n\t\t\t\tif (userDataPatterns != null) {\n\t\t\t\t\tfor (Entry<String, String> userDataEntry : userDataPatterns.entrySet()) {\n\t\t\t\t\t\tif (!matchesGlobbing(elementDescriptor.getUserData(userDataEntry.getKey()), userDataEntry\n\t\t\t\t\t\t\t\t.getValue())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","id":67098,"modified_method":"public boolean matches(EObjectDescriptor elementDescriptor) {\n\t\t\tif (matchesGlobbing(elementDescriptor.getFragment(), fragmentPattern)\n\t\t\t\t\t&& matchesGlobbing(elementDescriptor.getName(), namePattern)) {\n\t\t\t\tif (userDataPatterns != null) {\n\t\t\t\t\tfor (Entry<String, String> userDataEntry : userDataPatterns.entrySet()) {\n\t\t\t\t\t\tif (!matchesGlobbing(elementDescriptor.getUserData(userDataEntry.getKey()), userDataEntry\n\t\t\t\t\t\t\t\t.getValue())) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}","commit_id":"c9be9e36ded1eb67daff640393d01cdb1f4fc9f0","url":"https://github.com/eclipse/xtext"},{"original_method":"protected boolean tryIndexResource(IResource resource, boolean isDeleted) {\n\t\tif (resource instanceof IFile) {\n\t\t\tIFile file = (IFile) resource;\n\t\t\ttry {\n\t\t\t\tdeleteMarkers(file);\n\t\t\t\tSet<String> keySet = Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().keySet();\n\t\t\t\tif (keySet.contains(file.getFileExtension())) {\n\t\t\t\t\tURI resourceURI = URI.createPlatformResourceURI(resource.getFullPath().toString(), true);\n\t\t\t\t\tResource.Factory emfResourceFactory = Resource.Factory.Registry.INSTANCE.getFactory(resourceURI);\n\t\t\t\t\tif (emfResourceFactory != null) {\n\t\t\t\t\t\tif (isDeleted)\n\t\t\t\t\t\t\tindexBuilder.resourceChanged(resourceURI);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindexBuilder.resourceDeleted(resourceURI);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\taddMarker(file, e.getMessage(), 0, IMarker.SEVERITY_ERROR);\n\t\t\t\tEmfIndexUIPlugin.getDefault().getLog().log(\n\t\t\t\t\t\tnew Status(IStatus.ERROR, EmfIndexUIPlugin.PLUGIN_ID, \"Cannot index resource \"\n\t\t\t\t\t\t\t\t+ resource.getFullPath().toString(), e));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":67099,"modified_method":"protected boolean tryIndexResource(IResource resource, boolean isDeleted) {\n\t\tif (resource instanceof IFile) {\n\t\t\tIFile file = (IFile) resource;\n\t\t\ttry {\n\t\t\t\tdeleteMarkers(file);\n\t\t\t\tSet<String> keySet = Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap().keySet();\n\t\t\t\tif (keySet.contains(file.getFileExtension())) {\n\t\t\t\t\tURI resourceURI = URI.createPlatformResourceURI(resource.getFullPath().toString(), true);\n\t\t\t\t\tResource.Factory emfResourceFactory = Resource.Factory.Registry.INSTANCE.getFactory(resourceURI);\n\t\t\t\t\tif (emfResourceFactory != null) {\n\t\t\t\t\t\tif (isDeleted)\n\t\t\t\t\t\t\tindexBuilder.resourceDeleted(resourceURI);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tindexBuilder.resourceChanged(resourceURI);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\taddMarker(file, e.getMessage(), 0, IMarker.SEVERITY_ERROR);\n\t\t\t\tEmfIndexUIPlugin.getDefault().getLog().log(\n\t\t\t\t\t\tnew Status(IStatus.ERROR, EmfIndexUIPlugin.PLUGIN_ID, \"Cannot index resource \"\n\t\t\t\t\t\t\t\t+ resource.getFullPath().toString(), e));\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","commit_id":"c9be9e36ded1eb67daff640393d01cdb1f4fc9f0","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testIntegration() throws Exception {\n\t\tecoreFeeder.index(EcorePackage.eINSTANCE, true);\n\t\tindexExampleResource();\n\t\tIterable<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\").executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tIterator<EObjectDescriptor> eObjectIterator = elementResult.iterator();\n\t\tEObjectDescriptor elementDescriptor = eObjectIterator.next();\n\t\tassertFalse(eObjectIterator.hasNext());\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), true);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tIterable<EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\").executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tIterator<EClassDescriptor> eClassIterator = typeResult.iterator();\n\t\tEClassDescriptor typeDescriptor0 = eClassIterator.next();\n\t\tassertFalse(eClassIterator.hasNext());\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\t\tEClassDescriptor[] superClasses = typeDescriptor0.getSuperClasses();\n\t\tassertNotNull(superClasses);\n\t\t// four super classes: EClassifier, ENamedElement, EModelElement and\n\t\t// EObject\n\t\tassertEquals(4, superClasses.length);\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tIterable<ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.iterator().hasNext());\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\t}","id":67100,"modified_method":"public void testIntegration() throws Exception {\n\t\tecoreFeeder.index(EcorePackage.eINSTANCE, true);\n\t\tindexExampleResource();\n\t\tIterable<EObjectDescriptor> elementResult = index.eObjectDAO().createQuery().name(\"Entity\").executeListResult();\n\t\tassertNotNull(elementResult);\n\t\tIterator<EObjectDescriptor> eObjectIterator = elementResult.iterator();\n\t\tEObjectDescriptor elementDescriptor = eObjectIterator.next();\n\t\tassertFalse(eObjectIterator.hasNext());\n\t\tEObject entityClass = resourceSet.getEObject(elementDescriptor.getFragmentURI(), true);\n\t\tassertNotNull(entityClass);\n\t\tassertTrue(entityClass instanceof EClass);\n\t\tassertEquals(\"Entity\", ((EClass) entityClass).getName());\n\n\t\tEClassDescriptor typeDescriptor = elementDescriptor.getEClassDescriptor();\n\t\tassertNotNull(typeDescriptor);\n\t\tIterable<EClassDescriptor> typeResult = index.eClassDAO().createQuery().name(\"EClass\").executeListResult();\n\t\tassertNotNull(typeResult);\n\t\tIterator<EClassDescriptor> eClassIterator = typeResult.iterator();\n\t\tEClassDescriptor typeDescriptor0 = eClassIterator.next();\n\t\tassertFalse(eClassIterator.hasNext());\n\t\tassertEquals(typeDescriptor, typeDescriptor0);\n\t\tEClassDescriptor[] superClasses = typeDescriptor0.getSuperClasses();\n\t\tassertNotNull(superClasses);\n\t\t// four super classes: EClassifier, ENamedElement, EModelElement and\n\t\t// EObject\n\t\tassertEquals(4, superClasses.length);\n\n\t\tQuery crossRefQuery = index.eCrossReferenceDAO().createQuery();\n\t\tcrossRefQuery.target().name(\"Feature\");\n\t\tIterable<ECrossReferenceDescriptor> crossRefDescriptors = crossRefQuery.executeListResult();\n\t\tassertNotNull(crossRefDescriptors);\n\t\tassertTrue(crossRefDescriptors.iterator().hasNext());\n\t\tfor (ECrossReferenceDescriptor crossRefDescriptor : crossRefDescriptors) {\n\t\t\tEObject source = resourceSet.getEObject(crossRefDescriptor.getSource().getFragmentURI(), false);\n\t\t\tassertNotNull(source);\n\t\t\tEObject target = resourceSet.getEObject(crossRefDescriptor.getTarget().getFragmentURI(), false);\n\t\t\tEStructuralFeature structuralFeature = source.eClass().getEStructuralFeature(\n\t\t\t\t\tcrossRefDescriptor.getReferenceName());\n\t\t\tassertTrue(structuralFeature instanceof EReference);\n\t\t\tif (structuralFeature.isMany()) {\n\t\t\t\tassertTrue(((List<?>) source.eGet(structuralFeature)).contains(target));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tassertEquals(target, source.eGet(structuralFeature));\n\t\t\t}\n\t\t}\n\n\t\torg.eclipse.emf.index.EObjectDescriptor.Query objectQuery = index.eObjectDAO().createQuery();\n\t\tobjectQuery.eClass().name(\"EClassifier\").ePackage().nsURI(EcorePackage.eNS_URI);\n\t\tassertEquals(15, CollectionUtils.toList(objectQuery.executeListResult()).size());\n\n\t\tobjectQuery = index.eObjectDAO().createQuery();\n\t\tobjectQuery.eClass(index.eClassDAO().createQueryEClass(EcorePackage.eINSTANCE.getEClassifier()).executeSingleResult());\n\t\tassertEquals(15, CollectionUtils.toList(objectQuery.executeListResult()).size());\n\t}","commit_id":"c9be9e36ded1eb67daff640393d01cdb1f4fc9f0","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @param grailsProperty\n\t * @param prop\n\t * @param mappings\n\t */\n\tprivate static void bindProperty(GrailsDomainClassProperty grailsProperty, Property prop, Mappings mappings) {\n\t\t// set the property name\n\t\tprop.setName( grailsProperty.getName() );\n\t\t\n\t\tprop.setInsertable(true);\n\t\tprop.setUpdateable(true);\n\t\tprop.setPropertyAccessorName( mappings.getDefaultAccess() );\n\t\tprop.setOptional( grailsProperty.isOptional() );\n\t\t// set to cascade all for the moment\n\t\tif(grailsProperty.isAssociation()) {\n            if(grailsProperty.isOneToMany()) {\n                if(!grailsProperty.isBidirectional()) {\n                    if(grailsProperty.isOwningSide())\n                        prop.setCascade(\"all\");\n                    else\n                        prop.setCascade(\"save-update\");\n                }\n                else if(grailsProperty.isBidirectional())\n                    prop.setCascade(\"all\");\n            }\n            else if(grailsProperty.isManyToMany()) {\n            \tif(grailsProperty.isOwningSide()) {\n            \t\tprop.setCascade(\"save-update\");\n            \t}\n            }\n            else if(grailsProperty.isManyToOne() || grailsProperty.isOneToOne()) {\n                GrailsDomainClass domainClass = grailsProperty.getDomainClass();\n\n                if(domainClass.isOwningClass(grailsProperty.getType())) {\n                    prop.setCascade(\"all\");\n                }\n                else {\n                    GrailsDomainClassProperty otherSide = grailsProperty.getOtherSide();\n                    if(otherSide != null && otherSide.isOneToMany()) {\n                        prop.setCascade(\"merge\");\n                    }\n                    else if(grailsProperty.isOwningSide()) {\n                        prop.setCascade(\"all\");\n                    }\n                }\n            }\n        }\n        else if( Map.class.isAssignableFrom(grailsProperty.getType())) {\n            prop.setCascade(\"all\");\n        }\n\n\n        if(LOG.isTraceEnabled())\n            LOG.trace( \"[GrailsDomainBinder] Set cascading strategy on property [\"+grailsProperty.getName()+\"] to [\"+prop.getCascade()+\"]\" );\n        // lazy to true\n\t\tprop.setLazy(true);\n\t\t\n\t}","id":67101,"modified_method":"/**\n     * Binds a property to Hibernate runtime meta model. Deals with cascade strategy based on the Grails domain model\n     *\n\t * @param grailsProperty The grails property instance\n\t * @param prop The Hibernate property\n\t * @param mappings The Hibernate mappings\n\t */\n\tprivate static void bindProperty(GrailsDomainClassProperty grailsProperty, Property prop, Mappings mappings) {\n\t\t// set the property name\n\t\tprop.setName( grailsProperty.getName() );\n\t\t\n\t\tprop.setInsertable(true);\n\t\tprop.setUpdateable(true);\n\t\tprop.setPropertyAccessorName( mappings.getDefaultAccess() );\n\t\tprop.setOptional( grailsProperty.isOptional() );\n\t\t// set to cascade all for the moment\n\t\tif(grailsProperty.isAssociation()) {\n\n            // for a one-to-many relationship we cascade all updates if it is the owning side\n            // otherwise we cascade only saves and updates\n            if(grailsProperty.isOneToMany()) {\n                if(grailsProperty.isOwningSide())\n                    prop.setCascade(CASCADE_ALL);\n                else\n                    prop.setCascade(CASCADE_SAVE_UPDATE);\n            }\n            // for many-to-many relationships we only cascade saves and updates from the owning side\n            else if(grailsProperty.isManyToMany()) {\n            \tif(grailsProperty.isOwningSide()) {\n            \t\tprop.setCascade(CASCADE_SAVE_UPDATE);\n            \t}\n            }\n            // in the case of a many-to-one which is implicitly bidirectional we check whether it is the\n            // owning side and if so cascade otherwise only merge to deal with transient or detached instances\n            else if(grailsProperty.isManyToOne()) {\n                GrailsDomainClass domainClass = grailsProperty.getDomainClass();\n\n                if(!domainClass.isOwningClass(grailsProperty.getType())) {\n                    prop.setCascade(CASCADE_ALL);\n                }\n                else {\n                    GrailsDomainClassProperty otherSide = grailsProperty.getOtherSide();\n                    if(otherSide != null && otherSide.isOneToMany()) {\n                        prop.setCascade(CASCADE_MERGE);\n                    }\n                    else if(grailsProperty.isOwningSide()) {\n                        prop.setCascade(CASCADE_ALL);\n                    }\n                }\n            }\n            // in a one-to-one we check if it is un-directional and the other side is an owning side and then cascade\n            // otherwise if is the ownside we cascade all\n            else if(grailsProperty.isOneToOne()) {\n                GrailsDomainClass domainClass = grailsProperty.getDomainClass();\n                if(!grailsProperty.isBidirectional() && domainClass.isOwningClass(grailsProperty.getType())) {\n                    prop.setCascade(CASCADE_ALL);\n                }\n                else if(grailsProperty.isOwningSide()) {\n                    prop.setCascade(CASCADE_ALL);\n                }\n            }\n        }\n        else if( Map.class.isAssignableFrom(grailsProperty.getType())) {\n            prop.setCascade(CASCADE_ALL);\n        }\n\n\n        if(LOG.isTraceEnabled())\n            LOG.trace( \"[GrailsDomainBinder] Set cascading strategy on property [\"+grailsProperty.getName()+\"] to [\"+prop.getCascade()+\"]\" );\n        // lazy to true\n\t\tprop.setLazy(true);\n\t\t\n\t}","commit_id":"960269ebb08407e1909dee13505d98764c0aed58","url":"https://github.com/grails/grails-core"},{"original_method":"/**\n\t * @param grailsProperty\n\t * @param prop\n\t * @param mappings\n\t */\n\tprivate static void bindProperty(GrailsDomainClassProperty grailsProperty, Property prop, Mappings mappings) {\n\t\t// set the property name\n\t\tprop.setName( grailsProperty.getName() );\n\t\t\n\t\tprop.setInsertable(true);\n\t\tprop.setUpdateable(true);\n\t\tprop.setPropertyAccessorName( mappings.getDefaultAccess() );\n\t\tprop.setOptional( grailsProperty.isOptional() );\n\t\t// set to cascade all for the moment\n\t\tif(grailsProperty.isAssociation()) {\n            if(grailsProperty.isOneToMany()) {\n                prop.setCascade(\"all\");\n            }\n            else if(grailsProperty.isManyToMany()) {\n            \tif(grailsProperty.isOwningSide()) {\n            \t\tprop.setCascade(\"save-update\");\n            \t}\n            }\n            else if(grailsProperty.isManyToOne() || grailsProperty.isOneToOne()) {\n                GrailsDomainClass domainClass = grailsProperty.getDomainClass();\n                if(domainClass.isOwningClass(grailsProperty.getType())) {\n                    prop.setCascade(\"merge\");\n                }\n                else {\n                    GrailsDomainClassProperty otherSide = grailsProperty.getOtherSide();\n                    if(otherSide != null && otherSide.isOneToMany()) {\n                        prop.setCascade(\"merge\");\n                    }\n                    else {\n                        prop.setCascade(\"all\");\n                    }\n                }\n            }\n        }\n        else if( Map.class.isAssignableFrom(grailsProperty.getType())) {\n            prop.setCascade(\"all\");\n        }\n\n\n        if(LOG.isTraceEnabled())\n            LOG.trace( \"[GrailsDomainBinder] Set cascading strategy on property [\"+grailsProperty.getName()+\"] to [\"+prop.getCascade()+\"]\" );\n        // lazy to true\n\t\tprop.setLazy(true);\n\t\t\n\t}","id":67102,"modified_method":"/**\n\t * @param grailsProperty\n\t * @param prop\n\t * @param mappings\n\t */\n\tprivate static void bindProperty(GrailsDomainClassProperty grailsProperty, Property prop, Mappings mappings) {\n\t\t// set the property name\n\t\tprop.setName( grailsProperty.getName() );\n\t\t\n\t\tprop.setInsertable(true);\n\t\tprop.setUpdateable(true);\n\t\tprop.setPropertyAccessorName( mappings.getDefaultAccess() );\n\t\tprop.setOptional( grailsProperty.isOptional() );\n\t\t// set to cascade all for the moment\n\t\tif(grailsProperty.isAssociation()) {\n            if(grailsProperty.isOneToMany()) {\n                if(!grailsProperty.isBidirectional() && grailsProperty.isOwningSide())\n                    prop.setCascade(\"save\");\n                else if(grailsProperty.isBidirectional())\n                    prop.setCascade(\"all\");\n            }\n            else if(grailsProperty.isManyToMany()) {\n            \tif(grailsProperty.isOwningSide()) {\n            \t\tprop.setCascade(\"save-update\");\n            \t}\n            }\n            else if(grailsProperty.isManyToOne() || grailsProperty.isOneToOne()) {\n                GrailsDomainClass domainClass = grailsProperty.getDomainClass();\n                if(domainClass.isOwningClass(grailsProperty.getType())) {\n                    prop.setCascade(\"merge\");\n                }\n                else {\n                    GrailsDomainClassProperty otherSide = grailsProperty.getOtherSide();\n                    if(otherSide != null && otherSide.isOneToMany()) {\n                        prop.setCascade(\"merge\");\n                    }\n                }\n            }\n        }\n        else if( Map.class.isAssignableFrom(grailsProperty.getType())) {\n            prop.setCascade(\"all\");\n        }\n\n\n        if(LOG.isTraceEnabled())\n            LOG.trace( \"[GrailsDomainBinder] Set cascading strategy on property [\"+grailsProperty.getName()+\"] to [\"+prop.getCascade()+\"]\" );\n        // lazy to true\n\t\tprop.setLazy(true);\n\t\t\n\t}","commit_id":"09c492171ef3ec4f83ac26244e4a5a18ed147a5f","url":"https://github.com/grails/grails-core"},{"original_method":"private void saveActiveMap() throws IOException {\n        LWMap map = tufts.vue.VUE.getActiveMap();\n        activeMapFile = map.getFile();\n        if(activeMapFile == null) {\n            String prefix = \"vueMap\";\n            String suffix = \".xml\";\n            activeMapFile  = File.createTempFile(prefix,suffix);\n        }\n        ActionUtil.marshallMap(activeMapFile, map);    \n    }","id":67103,"modified_method":"private void saveActiveMap() throws IOException {\n        LWMap map = tufts.vue.VUE.getActiveMap();\n        activeMapFile = map.getFile();\n        if(activeMapFile == null) {\n            String prefix = \"concept_map\";\n            String suffix = \".vue\";\n            activeMapFile  = File.createTempFile(prefix,suffix);\n        }\n        ActionUtil.marshallMap(activeMapFile, map);\n    }","commit_id":"7cae873f824915acb979e3da120afc9d1221eb56","url":"https://github.com/VUE/VUE"},{"original_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n       Iterator i = map.getChildIterator();\n       while(i.hasNext()) {\n           LWComponent component = (LWComponent) i.next();\n           if(component.hasResource()){\n               Resource resource = component.getResource();\n            //   if(resource.getType() == Resource.URL) {\n                   try {\n                        System.out.println(\"Resource = \"+resource.getSpec());\n                       // File file = new File(new URL(resource.getSpec()).getFile());\n                        File file = new File(new URL(resource.getSpec()).getFile());\n                        if(file.isFile()) {\n                            Vector row = new Vector();\n                            row.add(new Boolean(true));\n                            row.add(resource);\n                            row.add(new Long(file.length()));\n                            row.add(\"Ready\");\n                            vector.add(row);\n                        }\n                   }catch (Exception ex) {\n                       System.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n                   }\n              // }\n           }\n           if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n           }\n       }\n    }","id":67104,"modified_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n        Iterator i = map.getChildIterator();\n        while(i.hasNext()) {\n            LWComponent component = (LWComponent) i.next();\n            if(component.hasResource()){\n                Resource resource = component.getResource();\n                //   if(resource.getType() == Resource.URL) {\n                try {\n                    // File file = new File(new URL(resource.getSpec()).getFile());\n                    File file = new File(new URL(resource.getSpec()).getFile());\n                    if(file.isFile()) {\n                        Vector row = new Vector();\n                        row.add(new Boolean(true));\n                        row.add(resource);\n                        row.add(new Long(file.length()));\n                        row.add(\"Ready\");\n                        vector.add(row);\n                    }\n                }catch (Exception ex) {\n                    System.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n                }\n                // }\n            }\n            if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n            }\n        }\n    }","commit_id":"7cae873f824915acb979e3da120afc9d1221eb56","url":"https://github.com/VUE/VUE"},{"original_method":"private File createIMSCP() throws IOException,URISyntaxException {\n        \n        LWMap map = tufts.vue.VUE.getActiveMap();\n        IMSCP imscp = new IMSCP();\n        saveActiveMap();\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);        \n        Iterator i = resourceVector.iterator();       \n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n            File file = new File(r.getSpec());\n               \n           \n            //File file = new File((String)vector.elementAt(1));\n            if(file.isFile() && b.booleanValue()) {\n                 System.out.println(\"FileName = \"+file.getName()+\" index =\"+resourceVector.indexOf(vector));\n                 resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                 imscp.putEntry(IMSCP.RESOURCE_FILES+\"/\"+file.getName(),file);\n                 resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n            }    \n           \n        }   \n        imscp.closeZOS();\n        return imscp.getFile();\n        \n    }","id":67105,"modified_method":"private File createIMSCP() throws IOException,URISyntaxException {\n        \n        LWMap map = tufts.vue.VUE.getActiveMap();\n        IMSCP imscp = new IMSCP();\n        saveActiveMap();\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);\n        Iterator i = resourceVector.iterator();\n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n            File file = new File(new URL(r.getSpec()).getFile());\n            //File file = new File((String)vector.elementAt(1));\n            if(file.isFile() && b.booleanValue()) {\n                System.out.println(\"FileName = \"+file.getName()+\" index =\"+resourceVector.indexOf(vector));\n                resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                imscp.putEntry(IMSCP.RESOURCE_FILES+\"/\"+file.getName(),file);\n                resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n            }\n            \n        }\n        imscp.closeZOS();\n        return imscp.getFile();\n        \n    }","commit_id":"7cae873f824915acb979e3da120afc9d1221eb56","url":"https://github.com/VUE/VUE"},{"original_method":"public void publishCMap() {\n        try {\n            File savedCMap = createIMSCP();\n            Properties metadata  = VUE.getActiveMap().getMetadata();\n            String pid = getDR().ingest(savedCMap.getName(), \"obj-vue-concept-map-mc.xml\", savedCMap, metadata).getIdString();\n            JOptionPane.showMessageDialog(null, \"Map successfully exported. Asset ID for Map = \"+pid, \"Map Exported\",JOptionPane.INFORMATION_MESSAGE);\n            System.out.println(\"Exported Map: id = \"+pid);\n            this.dispose();\n        } catch (Exception ex) {\n             VueUtil.alert(null, \"Export Not Supported:\"+ex.getMessage(), \"Export Error\");\n             ex.printStackTrace();\n        }\n   \n    }","id":67106,"modified_method":"public void publishCMap() {\n        try {\n            File savedCMap = createIMSCP();\n            if(((DataSource)dataSourceComboBox.getSelectedItem()).getType() == DataSource.FILING_LOCAL) {\n                BufferedReader br = new BufferedReader(new FileReader(savedCMap));\n                BufferedWriter bw = new BufferedWriter(new FileWriter(ActionUtil.selectFile(\"IMSCP\",\"zip\")));\n                int fileLength = (int)savedCMap.length();\n                char bytes[] = new  char[fileLength];\n                while (br.read(bytes,0,fileLength) != -1)\n                    bw.write(bytes,0,fileLength);\n                if (br != null)\n                    br.close();\n                \n                if (bw != null)\n                    bw.close();\n            } else {\n                Properties metadata  = VUE.getActiveMap().getMetadata();\n                String pid = getDR().ingest(savedCMap.getName(), \"obj-vue-concept-map-mc.xml\", savedCMap, metadata).getIdString();\n                JOptionPane.showMessageDialog(VUE.getInstance(), \"Map successfully exported. Asset ID for Map = \"+pid, \"Map Exported\",JOptionPane.INFORMATION_MESSAGE);\n                System.out.println(\"Exported Map: id = \"+pid);\n                \n            }\n            \n            this.dispose();\n        } catch (Exception ex) {\n            VueUtil.alert(null, \"Export Not Supported:\"+ex.getMessage(), \"Export Error\");\n            ex.printStackTrace();\n        }\n        \n    }","commit_id":"7cae873f824915acb979e3da120afc9d1221eb56","url":"https://github.com/VUE/VUE"},{"original_method":"public void actionPerformed(ActionEvent e) {\n        if(e.getSource() == cancelButton) {   \n            this.dispose();\n        } \n        if(e.getSource() == finishButton) {\n            if(stage == 1) {\n                if(publishMapRButton.isSelected())\n                    publishMap();\n            }else {\n                if(publishCMapRButton.isSelected())\n                    publishCMap();\n                if(publishAllRButton.isSelected())\n                    publishAll();\n            }\n        }\n        if(e.getSource() == nextButton) {\n            this.getContentPane().remove(modeSelectionPanel);\n            if(stage == 1) {\n                setUpResourceSelectionPanel();\n                this.getContentPane().add(resourceSelectionPanel); \n                this.getContentPane().validate();\n            }\n            stage++;\n            \n        }\n        if(e.getSource() == backButton) {\n            this.getContentPane().remove(resourceSelectionPanel);\n            setUpModeSelectionPanel();\n            modeSelectionPanel.validate();\n            this.getContentPane().add(modeSelectionPanel); \n            this.getContentPane().validate();\n            stage--;\n        }\n            \n        if(e.getSource() == publishMapRButton) {\n            finishButton.setEnabled(true);\n            nextButton.setEnabled(false);\n            publishMode = PUBLISH_MAP;\n            informationArea.setText(PUBLISH_INFORMATION[PUBLISH_MAP]);\n        }\n        if(e.getSource() == publishCMapRButton || e.getSource() == publishAllRButton) {\n            finishButton.setEnabled(false);\n            nextButton.setEnabled(true);\n            publishMode = PUBLISH_CMAP;\n            informationArea.setText(PUBLISH_INFORMATION[PUBLISH_CMAP]);\n        }\n        if(e.getSource() == publishAllRButton) {\n            finishButton.setEnabled(false);\n            nextButton.setEnabled(true);\n            publishMode = PUBLISH_ALL;\n            informationArea.setText(PUBLISH_INFORMATION[PUBLISH_ALL]);\n        }\n        \n    }","id":67107,"modified_method":"public void actionPerformed(ActionEvent e) {\n        if(e.getSource() == cancelButton) {\n            this.dispose();\n        }\n        if(e.getSource() == finishButton) {\n            if(stage == 1) {\n                if(publishMapRButton.isSelected())\n                    publishMap();\n            }else {\n                if(publishCMapRButton.isSelected())\n                    publishCMap();\n                if(publishAllRButton.isSelected())\n                    publishAll();\n            }\n        }\n        if(e.getSource() == nextButton) {\n            this.getContentPane().remove(modeSelectionPanel);\n            if(stage == 1) {\n                setUpResourceSelectionPanel();\n                this.getContentPane().add(resourceSelectionPanel);\n                this.getContentPane().validate();\n            }\n            stage++;\n            \n        }\n        if(e.getSource() == backButton) {\n            this.getContentPane().remove(resourceSelectionPanel);\n            setUpModeSelectionPanel();\n            modeSelectionPanel.validate();\n            this.getContentPane().add(modeSelectionPanel);\n            this.getContentPane().validate();\n            stage--;\n        }\n        \n        if(e.getSource() == publishMapRButton) {\n            finishButton.setEnabled(true);\n            nextButton.setEnabled(false);\n            publishMode = PUBLISH_MAP;\n            updatePublishPanel();\n        }\n        if(e.getSource() == publishCMapRButton || e.getSource() == publishAllRButton) {\n            finishButton.setEnabled(false);\n            nextButton.setEnabled(true);\n            publishMode = PUBLISH_CMAP;\n            updatePublishPanel();\n        }\n        if(e.getSource() == publishAllRButton) {\n            finishButton.setEnabled(false);\n            nextButton.setEnabled(true);\n            publishMode = PUBLISH_ALL;\n            updatePublishPanel();\n        }\n        \n    }","commit_id":"7cae873f824915acb979e3da120afc9d1221eb56","url":"https://github.com/VUE/VUE"},{"original_method":"private void setUpModeSelectionPanel() {\n        Vector dataSourceVector = new Vector();\n        Iterator  i = DataSourceViewer.getPublishableDataSources();\n        while(i.hasNext())  \n            dataSourceVector.add(i.next());\n        \n        modeSelectionPanel = new JPanel();\n        GridBagLayout gridbag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n        modeSelectionPanel.setLayout(gridbag);\n        Insets defaultInsets = new Insets(2,9,2,2);\n        \n        ButtonGroup modeSelectionGroup = new ButtonGroup();\n        JLabel topLabel = new JLabel(\"Select the Export Mode\");\n        \n        //area for displaying information about publishing mode\n        informationArea = new JTextArea(\" The �Export� function allows a user to deposit a concept map into a registered digital repository. Select the different modes to learn more.\");\n        informationArea.setEditable(false);\n        informationArea.setLineWrap(true);\n        informationArea.setRows(4);\n        informationArea.setBorder(new LineBorder(Color.BLACK));\n        //informationArea.setBackground(Color.WHITE);\n        informationArea.setSize(WIDTH-50, HEIGHT/3);\n        \n        JLabel dsLabel = new JLabel(\"Where would you like to save the map:\");\n        dataSourceComboBox = new JComboBox(dataSourceVector);\n        \n        JPanel buttonPanel = new JPanel();\n        publishMapRButton = new JRadioButton(\"Export Map\");\n        publishCMapRButton = new JRadioButton(\"Export IMSCP Map\");\n        publishAllRButton = new JRadioButton(\"Export All\");\n        publishMapRButton.addActionListener(this);\n        publishCMapRButton.addActionListener(this);\n        publishAllRButton.addActionListener(this);\n        \n        modeSelectionGroup.add(publishMapRButton);\n        modeSelectionGroup.add(publishCMapRButton);\n        modeSelectionGroup.add(publishAllRButton);\n        buttonPanel.add(publishMapRButton);\n        buttonPanel.add(publishCMapRButton);\n        buttonPanel.add(publishAllRButton);\n       \n        JPanel bottomPanel = new JPanel();\n       // bottomPanel.setBorder(new LineBorder(Color.BLACK));\n        bottomPanel.add(nextButton);\n        bottomPanel.add(finishButton);\n        bottomPanel.add(cancelButton);\n       //bottomPanel.setSize(WIDTH/3, HEIGHT/10);\n         \n        \n        nextButton.setEnabled(false);\n        finishButton.setEnabled(false);\n        \n        c.gridy = 0;\n        c.gridx = 0;\n        c.gridwidth = 6;\n        c.anchor = GridBagConstraints.WEST;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(topLabel, c);\n        modeSelectionPanel.add(topLabel);\n        \n        c.gridy = 1;\n        c.insets = new Insets(2,0,2, 2);\n        gridbag.setConstraints(buttonPanel, c);\n        modeSelectionPanel.add(buttonPanel);\n        \n        c.gridy = 2;\n        c.gridwidth = 6;\n         c.insets = defaultInsets;\n        gridbag.setConstraints(informationArea, c);\n        modeSelectionPanel.add(informationArea);\n\n        c.gridy = 3;\n        c.gridwidth =2;\n        c.insets = new Insets(10,9,2, 2);\n        gridbag.setConstraints(dsLabel,c);\n        modeSelectionPanel.add(dsLabel);\n\n        c.gridy = 4;\n        c.gridwidth =2;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(dataSourceComboBox,c);\n        modeSelectionPanel.add(dataSourceComboBox);\n\n        c.gridy = 5;\n        c.gridx = 3;\n        c.gridwidth =3;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(bottomPanel, c);\n        modeSelectionPanel.add(bottomPanel);\n    }","id":67108,"modified_method":"private void setUpModeSelectionPanel() {\n        \n        modeSelectionPanel = new JPanel();\n        GridBagLayout gridbag = new GridBagLayout();\n        GridBagConstraints c = new GridBagConstraints();\n        modeSelectionPanel.setLayout(gridbag);\n        Insets defaultInsets = new Insets(2,9,2,2);\n        \n        ButtonGroup modeSelectionGroup = new ButtonGroup();\n        JLabel topLabel = new JLabel(\"Select the Export Mode\");\n        \n        //area for displaying information about publishing mode\n        informationArea = new JTextArea(\" The �Export� function allows a user to deposit a concept map into a registered digital repository. Select the different modes to learn more.\");\n        informationArea.setEditable(false);\n        informationArea.setLineWrap(true);\n        informationArea.setRows(4);\n        informationArea.setBorder(new LineBorder(Color.BLACK));\n        //informationArea.setBackground(Color.WHITE);\n        informationArea.setSize(WIDTH-50, HEIGHT/3);\n        \n        JLabel dsLabel = new JLabel(\"Where would you like to save the map:\");\n        dataSourceComboBox = new JComboBox(DataSourceViewer.getPublishableDataSources(Publisher.PUBLISH_ALL_MODES));\n        \n        JPanel buttonPanel = new JPanel();\n        publishMapRButton = new JRadioButton(\"Export Map\");\n        publishCMapRButton = new JRadioButton(\"Export IMSCP Map\");\n        publishAllRButton = new JRadioButton(\"Export All\");\n        publishMapRButton.addActionListener(this);\n        publishCMapRButton.addActionListener(this);\n        publishAllRButton.addActionListener(this);\n        \n        modeSelectionGroup.add(publishMapRButton);\n        modeSelectionGroup.add(publishCMapRButton);\n        modeSelectionGroup.add(publishAllRButton);\n        buttonPanel.add(publishMapRButton);\n        buttonPanel.add(publishCMapRButton);\n        buttonPanel.add(publishAllRButton);\n        \n        JPanel bottomPanel = new JPanel();\n        // bottomPanel.setBorder(new LineBorder(Color.BLACK));\n        bottomPanel.add(nextButton);\n        bottomPanel.add(finishButton);\n        bottomPanel.add(cancelButton);\n        //bottomPanel.setSize(WIDTH/3, HEIGHT/10);\n        \n        \n        nextButton.setEnabled(false);\n        finishButton.setEnabled(false);\n        \n        c.gridy = 0;\n        c.gridx = 0;\n        c.gridwidth = 6;\n        c.anchor = GridBagConstraints.WEST;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(topLabel, c);\n        modeSelectionPanel.add(topLabel);\n        \n        c.gridy = 1;\n        c.insets = new Insets(2,0,2, 2);\n        gridbag.setConstraints(buttonPanel, c);\n        modeSelectionPanel.add(buttonPanel);\n        \n        c.gridy = 2;\n        c.gridwidth = 6;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(informationArea, c);\n        modeSelectionPanel.add(informationArea);\n        \n        c.gridy = 3;\n        c.gridwidth =2;\n        c.insets = new Insets(10,9,2, 2);\n        gridbag.setConstraints(dsLabel,c);\n        modeSelectionPanel.add(dsLabel);\n        \n        c.gridy = 4;\n        c.gridwidth =2;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(dataSourceComboBox,c);\n        modeSelectionPanel.add(dataSourceComboBox);\n        \n        c.gridy = 5;\n        c.gridx = 3;\n        c.gridwidth =3;\n        c.anchor = GridBagConstraints.EAST;\n        c.insets = defaultInsets;\n        gridbag.setConstraints(bottomPanel, c);\n        modeSelectionPanel.add(bottomPanel);\n    }","commit_id":"7cae873f824915acb979e3da120afc9d1221eb56","url":"https://github.com/VUE/VUE"},{"original_method":"public VueFileFilter(String description)\n    {\n        super();\n        this.description = description;\n        \n        if (description.equals(\"jpeg\"))\n          extensions = jpeg;\n        \n        else if (description.equals(\"svg\"))\n          extensions = svg;\n        \n        else if (description.equals(\"pdf\"))\n          extensions = pdf;\n        \n        else if (description.equals(\"html\"))\n          extensions = html;\n        \n        else if (description.equals(\"imap\"))\n          extensions = imap;\n        \n        else if (description.equals(\"vue\") || description.equals(\"xml\")) {\n            extensions = vue;\n            description = \"VUE Files\";\n        }\n    }","id":67109,"modified_method":"public VueFileFilter(String description)\n    {\n        super();\n        this.description = description;\n        \n        if (description.equals(\"jpeg\"))\n          extensions = jpeg;\n        \n        else if (description.equals(\"svg\"))\n          extensions = svg;\n        \n        else if (description.equals(\"pdf\"))\n          extensions = pdf;\n        \n        else if (description.equals(\"html\"))\n          extensions = html;\n        \n        else if (description.equals(\"imap\"))\n          extensions = imap;\n        \n        else if (description.equals(\"vue\") || description.equals(\"xml\")) {\n            extensions = vue;\n            description = \"VUE Files\";\n        } else if (description.equals(\"zip\")) {\n            this.extensions = zip;\n        }\n    }","commit_id":"7cae873f824915acb979e3da120afc9d1221eb56","url":"https://github.com/VUE/VUE"},{"original_method":"public  void publishAll() {\n        try {\n            \n            Iterator i = resourceVector.iterator();\n            while(i.hasNext()) {\n                Vector vector = (Vector)i.next();\n                Resource r = (Resource)(vector.elementAt(1));\n                Boolean b = (Boolean)(vector.elementAt(0));\n               // File file = new File((String)vector.elementAt(1));\n                File file = new File(r.getSpec());\n                if(file.isFile() && b.booleanValue()) {\n                    resourceTable.getModel().setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                    String pid = getDR().ingest(file.getName(),\"obj-binary.xml\",file, r.getProperties()).getIdString();\n                    resourceTable.getModel().setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n                    VUE.getActiveMap().replaceResource(r,new AssetResource(getDR().getAsset(new tufts.oki.dr.fedora.PID(pid))));\n                    System.out.println(\"Resource = \" + r+ \" FileName = \"+file.getName()+\" pid =\"+pid+\" vector =\"+resourceVector.indexOf(vector)+\" table value= \"+resourceTable.getValueAt(resourceVector.indexOf(vector),STATUS_COL));\n                    \n                }\n              \n            }\n            publishMap();\n            System.out.println(\"Export All\");\n        } catch (Exception ex) {\n            VueUtil.alert(null, ex.getMessage(), \"Export Error\");\n            ex.printStackTrace();\n        }\n    }","id":67110,"modified_method":"public  void publishAll() {\n        try {\n            \n            Iterator i = resourceVector.iterator();\n            while(i.hasNext()) {\n                Vector vector = (Vector)i.next();\n                Resource r = (Resource)(vector.elementAt(1));\n                Boolean b = (Boolean)(vector.elementAt(0));\n               // File file = new File((String)vector.elementAt(1));\n                System.out.println(\"RESOURCE = \"+r.getSpec());\n                File file = new File(new URL(r.getSpec()).getFile());\n                if(file.isFile() && b.booleanValue()) {\n                    resourceTable.getModel().setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                    String pid = getDR().ingest(file.getName(),\"obj-binary.xml\",file, r.getProperties()).getIdString();\n                    resourceTable.getModel().setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n                    VUE.getActiveMap().replaceResource(r,new AssetResource(getDR().getAsset(new tufts.oki.dr.fedora.PID(pid))));\n                    System.out.println(\"Resource = \" + r+ \" FileName = \"+file.getName()+\" pid =\"+pid+\" vector =\"+resourceVector.indexOf(vector)+\" table value= \"+resourceTable.getValueAt(resourceVector.indexOf(vector),STATUS_COL));\n                    \n                }\n              \n            }\n            publishMap();\n            System.out.println(\"Export All\");\n        } catch (Exception ex) {\n            VueUtil.alert(null, ex.getMessage(), \"Export Error\");\n            ex.printStackTrace();\n        }\n    }","commit_id":"b188350e7c90ea71520ef8716685e73bd5155c39","url":"https://github.com/VUE/VUE"},{"original_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n       Iterator i = map.getChildIterator();\n       while(i.hasNext()) {\n           LWComponent component = (LWComponent) i.next();\n           if(component.hasResource()){\n               Resource resource = component.getResource();\n            //   if(resource.getType() == Resource.URL) {\n                   try {\n                        System.out.println(\"Resource = \"+resource.getSpec());\n                       // File file = new File(new URL(resource.getSpec()).getFile());\n                        File file = new File(resource.getSpec());\n                        if(file.isFile()) {\n                            Vector row = new Vector();\n                            row.add(new Boolean(true));\n                            row.add(resource);\n                            row.add(new Long(file.length()));\n                            row.add(\"Ready\");\n                            vector.add(row);\n                        }\n                   }catch (Exception ex) {\n                       System.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n                   }\n              // }\n           }\n           if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n           }\n       }\n    }","id":67111,"modified_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n       Iterator i = map.getChildIterator();\n       while(i.hasNext()) {\n           LWComponent component = (LWComponent) i.next();\n           if(component.hasResource()){\n               Resource resource = component.getResource();\n            //   if(resource.getType() == Resource.URL) {\n                   try {\n                        System.out.println(\"Resource = \"+resource.getSpec());\n                       // File file = new File(new URL(resource.getSpec()).getFile());\n                        File file = new File(new URL(resource.getSpec()).getFile());\n                        if(file.isFile()) {\n                            Vector row = new Vector();\n                            row.add(new Boolean(true));\n                            row.add(resource);\n                            row.add(new Long(file.length()));\n                            row.add(\"Ready\");\n                            vector.add(row);\n                        }\n                   }catch (Exception ex) {\n                       System.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n                   }\n              // }\n           }\n           if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n           }\n       }\n    }","commit_id":"b188350e7c90ea71520ef8716685e73bd5155c39","url":"https://github.com/VUE/VUE"},{"original_method":"public static File createIMSCP(Vector resourceVector) throws IOException,URISyntaxException,CloneNotSupportedException {\n        String IMSCPMetadata = \"\";\n        String IMSCPOrganization =\"\";\n        String IMSCPResources = \"\";\n        int resourceCount =2; //resourceIdentifier 1 is used for map\n        Properties props = tufts.vue.VUE.getActiveMap().getMetadata().asProperties();\n        IMSCPMetadata += getMetadataString(props);\n        IMSCPResources += getResourceTag(props, IMSCP.MAP_FILE,1);\n        IMSCPOrganization += \"<organization identifier=\\\"TOC1\\\" structure=\\\"hierarchical\\\">\";\n        IMSCPOrganization += \"<title>IMS Content Package of VUE Map<\/title> \";\n        IMSCPOrganization += \"<item identifier=\\\"ITEM1\\\" identifierref=\\\"RESOURCE1\\\">\";\n        IMSCPOrganization += \"<title> VUE Cocept Map<\/title>\";            \n        LWMap saveMap = (LWMap) tufts.vue.VUE.getActiveMap().clone();\n        IMSCP imscp = new IMSCP();\n        Iterator i = resourceVector.iterator();\n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n            File file = new File(r.getSpec());\n            //File file = new File((String)vector.elementAt(1));\n            if(file.isFile() && b.booleanValue()) {\n                System.out.println(\"FileName = \"+file.getName()+\" index =\"+resourceVector.indexOf(vector));\n                //resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                String entry = IMSCP.RESOURCE_FILES+File.separator+file.getName();\n                imscp.putEntry(entry,file);\n                IMSCPResources += getResourceTag(r.getProperties().asProperties(), entry,resourceCount);\n                IMSCPOrganization += getItemTag(\"ITEM\"+resourceCount, \"RESOURCE\"+resourceCount,\"Resource \"+resourceCount+\" in Concept Map\");\n                //resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n                replaceResource(saveMap,r,new MapResource(IMSCP.RESOURCE_FILES+File.separatorChar+file.getName()));\n                resourceCount++;\n            }\n        }\n        saveMap(saveMap);\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);\n        IMSCPOrganization +=\"<\/item>\";  \n        IMSCPOrganization +=\"<\/organization>\";  \n        IMSManifest = readRawManifest();\n        IMSManifest = IMSManifest.replaceAll(IMSCP_MANIFEST_METADATA, IMSCPMetadata).trim();\n        IMSManifest = IMSManifest.replaceAll(IMSCP_MANIFEST_ORGANIZATION, IMSCPOrganization);\n        IMSManifest = IMSManifest.replaceAll(IMSCP_MANIFEST_RESOURCES, IMSCPResources);\n          \n        File IMSManifestFile = File.createTempFile(\"imsmanifest\",\".xml\");\n        BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(IMSManifestFile));\n        fos.write(IMSManifest.getBytes());\n        fos.close();\n        imscp.putEntry(IMSCP.MANIFEST_FILE,IMSManifestFile);\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.closeZOS();\n        return imscp.getFile();\n    }","id":67112,"modified_method":"public static File createIMSCP(Vector resourceVector) throws IOException,URISyntaxException,CloneNotSupportedException {\n        String IMSCPMetadata = \"\";\n        String IMSCPOrganization =\"\";\n        String IMSCPResources = \"\";\n        int resourceCount =2; //resourceIdentifier 1 is used for map\n        Properties props = tufts.vue.VUE.getActiveMap().getMetadata().asProperties();\n        IMSCPMetadata += getMetadataString(props);\n        IMSCPResources += getResourceTag(props, IMSCP.MAP_FILE,1);\n        IMSCPOrganization += \"<organization identifier=\\\"TOC1\\\" structure=\\\"hierarchical\\\">\";\n        IMSCPOrganization += \"<title>IMS Content Package of VUE Map<\/title> \";\n        IMSCPOrganization += \"<item identifier=\\\"ITEM1\\\" identifierref=\\\"RESOURCE1\\\">\";\n        IMSCPOrganization += \"<title> VUE Cocept Map<\/title>\";            \n        LWMap saveMap = (LWMap) tufts.vue.VUE.getActiveMap().clone();\n        IMSCP imscp = new IMSCP();\n        Iterator i = resourceVector.iterator();\n        while(i.hasNext()) {\n            Vector vector = (Vector)i.next();\n            Resource r = (Resource)(vector.elementAt(1));\n            Boolean b = (Boolean)(vector.elementAt(0));\n            File file = new File(new URL(r.getSpec()).getFile());\n            //File file = new File((String)vector.elementAt(1));\n            if(b.booleanValue()) {\n                System.out.println(\"FileName = \"+file.getName()+\" index =\"+resourceVector.indexOf(vector));\n                //resourceTable.setValueAt(\"Processing\",resourceVector.indexOf(vector),STATUS_COL);\n                String entry = IMSCP.RESOURCE_FILES+File.separator+file.getName();\n                imscp.putEntry(entry,file);\n                IMSCPResources += getResourceTag(r.getProperties().asProperties(), entry,resourceCount);\n                IMSCPOrganization += getItemTag(\"ITEM\"+resourceCount, \"RESOURCE\"+resourceCount,\"Resource \"+resourceCount+\" in Concept Map\");\n                //resourceTable.setValueAt(\"Done\",resourceVector.indexOf(vector),STATUS_COL);\n                replaceResource(saveMap,r,new MapResource(IMSCP.RESOURCE_FILES+File.separatorChar+file.getName()));\n                resourceCount++;\n            }\n        }\n        saveMap(saveMap);\n        imscp.putEntry(IMSCP.MAP_FILE,activeMapFile);\n        IMSCPOrganization +=\"<\/item>\";  \n        IMSCPOrganization +=\"<\/organization>\";  \n        IMSManifest = readRawManifest();\n        IMSManifest = IMSManifest.replaceAll(IMSCP_MANIFEST_METADATA, IMSCPMetadata).trim();\n        IMSManifest = IMSManifest.replaceAll(IMSCP_MANIFEST_ORGANIZATION, IMSCPOrganization);\n        IMSManifest = IMSManifest.replaceAll(IMSCP_MANIFEST_RESOURCES, IMSCPResources);\n          \n        File IMSManifestFile = File.createTempFile(\"imsmanifest\",\".xml\");\n        BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream(IMSManifestFile));\n        fos.write(IMSManifest.getBytes());\n        fos.close();\n        imscp.putEntry(IMSCP.MANIFEST_FILE,IMSManifestFile);\n        System.out.println(\"Writing Active Map : \"+activeMapFile.getName());\n        imscp.closeZOS();\n        return imscp.getFile();\n    }","commit_id":"100011c7ccd37e1ee82b0bed7bafd7e820086bad","url":"https://github.com/VUE/VUE"},{"original_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n        Iterator i = map.getChildIterator();\n        while(i.hasNext()) {\n            LWComponent component = (LWComponent) i.next();\n            if(component.hasResource()){\n                Resource resource = component.getResource();\n                //   if(resource.getType() == Resource.URL) {\n                try {\n                    // File file = new File(new URL(resource.getSpec()).getFile());\n                   // System.out.println(\"LWComponent:\"+component.getLabel() + \"Resource: \"+resource.getSpec());\n                    \n                    File file = new File(resource.getSpec());\n                    if(file.isFile()) {\n                        Vector row = new Vector();\n                        row.add(new Boolean(true));\n                        row.add(resource);\n                        row.add(new Long(file.length()));\n                        row.add(\"Ready\");\n                        vector.add(row);\n                    }\n                }catch (Exception ex) {\n                    System.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n                    ex.printStackTrace();\n                }\n                // }\n            }\n            if(component instanceof LWContainer) {\n                setLocalResourceVector(vector,(LWContainer)component);\n            }\n        }\n    }","id":67113,"modified_method":"private void setLocalResourceVector(Vector vector,LWContainer map) {\n        Iterator i = map.getAllDescendents(LWComponent.ChildKind.PROPER).iterator();\n        while(i.hasNext()) {\n            LWComponent component = (LWComponent) i.next();\n            //System.out.println(\"Component:\"+component+\" has resource:\"+component.hasResource());\n            if(component.hasResource()){\n                Resource resource = component.getResource();\n                //   if(resource.getType() == Resource.URL) {\n                try {\n                    // File file = new File(new URL(resource.getSpec()).getFile());\n                    if(resource.getSpec().startsWith(FILE_PREFIX)) {\n                        File file = new File(new URL(resource.getSpec()).getFile());\n                        System.out.println(\"LWComponent:\"+component.getLabel() + \"Resource: \"+resource.getSpec()+\"File:\"+file+\" exists:\"+file.exists());\n                        Vector row = new Vector();\n                        row.add(new Boolean(true));\n                        row.add(resource);\n                        row.add(new Long(file.length()));\n                        row.add(\"Ready\");\n                        vector.add(row);\n                    }\n                }catch (Exception ex) {\n                    System.out.println(\"Publisher.setLocalResourceVector: Resource \"+resource.getSpec()+ ex);\n                    ex.printStackTrace();\n                }\n                \n            }\n            \n        }\n    }","commit_id":"100011c7ccd37e1ee82b0bed7bafd7e820086bad","url":"https://github.com/VUE/VUE"},{"original_method":"/**\n     * Replies true if the active data layer (edit layer) is drawable.\n     *\n     * @return true if the active data layer (edit layer) is drawable, false otherwise\n     */\n    public boolean isActiveLayerDrawable() {\n        layerLock.readLock().lock();\n        try {\n            return editLayer != null;\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67114,"modified_method":"/**\n     * Replies true if the active data layer (edit layer) is drawable.\n     *\n     * @return true if the active data layer (edit layer) is drawable, false otherwise\n     */\n    public boolean isActiveLayerDrawable() {\n        synchronized (layers) {\n            return editLayer != null;\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Sets the active layer to <code>layer<\/code>. If <code>layer<\/code> is an instance\n     * of {@link OsmDataLayer} also sets {@link #editLayer} to <code>layer<\/code>.\n     *\n     * @param layer the layer to be activate; must be one of the layers in the list of layers\n     * @throws IllegalArgumentException if layer is not in the lis of layers\n     */\n    public void setActiveLayer(Layer layer) {\n        layerLock.writeLock().lock();\n        layerLock.readLock().lock();\n        EnumSet<LayerListenerType> listenersToFire;\n        Layer oldActiveLayer = activeLayer;\n        OsmDataLayer oldEditLayer = editLayer;\n        try {\n            try {\n                listenersToFire = setActiveLayer(layer, true);\n            } finally {\n                layerLock.writeLock().unlock();\n            }\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n        } finally {\n            layerLock.readLock().unlock();\n        }\n        repaint();\n    }","id":67115,"modified_method":"/**\n     * Sets the active layer to <code>layer<\/code>. If <code>layer<\/code> is an instance\n     * of {@link OsmDataLayer} also sets {@link #editLayer} to <code>layer<\/code>.\n     *\n     * @param layer the layer to be activate; must be one of the layers in the list of layers\n     * @throws IllegalArgumentException if layer is not in the lis of layers\n     */\n    public void setActiveLayer(Layer layer) {\n        EnumSet<LayerListenerType> listenersToFire;\n\n        synchronized (layers) {\n            Layer oldActiveLayer = activeLayer;\n            OsmDataLayer oldEditLayer = editLayer;\n            listenersToFire = setActiveLayer(layer, true);\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n        }\n        repaint();\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Remove the layer from the mapview. If the layer was in the list before,\n     * an LayerChange event is fired.\n     * @param layer The layer to remove\n     */\n    public void removeLayer(Layer layer) {\n        EnumSet<LayerListenerType> listenersToFire = EnumSet.noneOf(LayerListenerType.class);\n        Layer oldActiveLayer = activeLayer;\n        OsmDataLayer oldEditLayer = editLayer;\n\n        layerLock.writeLock().lock();\n        layerLock.readLock().lock();\n        try {\n            try {\n                List<Layer> layersList = new ArrayList<>(layers);\n\n                if (!layersList.remove(layer))\n                    return;\n\n                listenersToFire = setEditLayer(layersList);\n\n                if (layer == activeLayer) {\n                    listenersToFire.addAll(setActiveLayer(determineNextActiveLayer(layersList), false));\n                }\n\n                if (layer instanceof OsmDataLayer) {\n                    ((OsmDataLayer) layer).removeLayerPropertyChangeListener(this);\n                }\n\n                layers.remove(layer);\n                Main.removeProjectionChangeListener(layer);\n\n            } finally {\n                layerLock.writeLock().unlock();\n            }\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n            fireLayerRemoved(layer);\n            layer.removePropertyChangeListener(this);\n            layer.destroy();\n            AudioPlayer.reset();\n        } finally {\n            layerLock.readLock().unlock();\n        }\n        repaint();\n    }","id":67116,"modified_method":"/**\n     * Remove the layer from the mapview. If the layer was in the list before,\n     * an LayerChange event is fired.\n     * @param layer The layer to remove\n     */\n    public void removeLayer(Layer layer) {\n        EnumSet<LayerListenerType> listenersToFire = EnumSet.noneOf(LayerListenerType.class);\n        Layer oldActiveLayer = activeLayer;\n        OsmDataLayer oldEditLayer = editLayer;\n\n        synchronized (layers) {\n            List<Layer> layersList = new ArrayList<>(layers);\n\n            if (!layersList.remove(layer))\n                return;\n\n            listenersToFire = setEditLayer(layersList);\n\n            if (layer == activeLayer) {\n                listenersToFire.addAll(setActiveLayer(determineNextActiveLayer(layersList), false));\n            }\n\n            if (layer instanceof OsmDataLayer) {\n                ((OsmDataLayer) layer).removeLayerPropertyChangeListener(this);\n            }\n\n            layers.remove(layer);\n            Main.removeProjectionChangeListener(layer);\n\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n            fireLayerRemoved(layer);\n            layer.removePropertyChangeListener(this);\n            layer.destroy();\n            AudioPlayer.reset();\n        }\n        repaint();\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void fireEditLayerChanged(OsmDataLayer oldLayer, OsmDataLayer newLayer) {\n        checkLayerLockNotHeld();\n        for (EditLayerChangeListener l : editLayerChangeListeners) {\n            l.editLayerChanged(oldLayer, newLayer);\n        }\n    }","id":67117,"modified_method":"protected void fireEditLayerChanged(OsmDataLayer oldLayer, OsmDataLayer newLayer) {\n        for (EditLayerChangeListener l : editLayerChangeListeners) {\n            l.editLayerChanged(oldLayer, newLayer);\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Replies the currently active layer\n     *\n     * @return the currently active layer (may be null)\n     */\n    public Layer getActiveLayer() {\n        layerLock.readLock().lock();\n        try {\n            return activeLayer;\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67118,"modified_method":"/**\n     * Replies the currently active layer\n     *\n     * @return the currently active layer (may be null)\n     */\n    public Layer getActiveLayer() {\n        synchronized (layers) {\n            return activeLayer;\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Calls the {@link LayerChangeListener#activeLayerChange(Layer, Layer)} method of all listeners.\n     *\n     * @param oldLayer The old layer\n     * @param newLayer The new active layer.\n     */\n    protected void fireActiveLayerChanged(Layer oldLayer, Layer newLayer) {\n        checkLayerLockNotHeld();\n        for (LayerChangeListener l : layerChangeListeners) {\n            l.activeLayerChange(oldLayer, newLayer);\n        }\n    }","id":67119,"modified_method":"/**\n     * Calls the {@link LayerChangeListener#activeLayerChange(Layer, Layer)} method of all listeners.\n     *\n     * @param oldLayer The old layer\n     * @param newLayer The new active layer.\n     */\n    protected void fireActiveLayerChanged(Layer oldLayer, Layer newLayer) {\n        for (LayerChangeListener l : layerChangeListeners) {\n            l.activeLayerChange(oldLayer, newLayer);\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    protected DataSet getCurrentDataSet() {\n        layerLock.readLock().lock();\n        try {\n            if (editLayer != null)\n                return editLayer.data;\n            else\n                return null;\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67120,"modified_method":"@Override\n    protected DataSet getCurrentDataSet() {\n        synchronized (layers) {\n            if (editLayer != null)\n                return editLayer.data;\n            else\n                return null;\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Replies the number of layers managed by this map view\n     *\n     * @return the number of layers managed by this map view\n     */\n    public int getNumLayers() {\n        layerLock.readLock().lock();\n        try {\n            return layers.size();\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67121,"modified_method":"/**\n     * Replies the number of layers managed by this map view\n     *\n     * @return the number of layers managed by this map view\n     */\n    public int getNumLayers() {\n        synchronized (layers) {\n            return layers.size();\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Replies true if the active data layer (edit layer) is visible.\n     *\n     * @return true if the active data layer (edit layer) is visible, false otherwise\n     */\n    public boolean isActiveLayerVisible() {\n        layerLock.readLock().lock();\n        try {\n            return isActiveLayerDrawable() && editLayer.isVisible();\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67122,"modified_method":"/**\n     * Replies true if the active data layer (edit layer) is visible.\n     *\n     * @return true if the active data layer (edit layer) is visible, false otherwise\n     */\n    public boolean isActiveLayerVisible() {\n        synchronized (layers) {\n            return isActiveLayerDrawable() && editLayer.isVisible();\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Creates a list of the visible layers in Z-Order, the layer with the lowest Z-Order\n     * first, layer with the highest Z-Order last.\n     * <p>\n     * The active data layer is pulled above all adjacent data layers.\n     *\n     * @return a list of the visible in Z-Order, the layer with the lowest Z-Order\n     * first, layer with the highest Z-Order last.\n     */\n    public List<Layer> getVisibleLayersInZOrder() {\n        layerLock.readLock().lock();\n        try {\n            List<Layer> ret = new ArrayList<>();\n            // This is set while we delay the addition of the active layer.\n            boolean activeLayerDelayed = false;\n            for (ListIterator<Layer> iterator = layers.listIterator(layers.size()); iterator.hasPrevious();) {\n                Layer l = iterator.previous();\n                if (!l.isVisible()) {\n                    // ignored\n                } else if (l == activeLayer && l instanceof OsmDataLayer) {\n                    // delay and add after the current block of OsmDataLayer\n                    activeLayerDelayed = true;\n                } else {\n                    if (activeLayerDelayed && !(l instanceof OsmDataLayer)) {\n                        // add active layer before the current one.\n                        ret.add(activeLayer);\n                        activeLayerDelayed = false;\n                    }\n                    // Add this layer now\n                    ret.add(l);\n                }\n            }\n            if (activeLayerDelayed) {\n                ret.add(activeLayer);\n            }\n            return ret;\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67123,"modified_method":"/**\n     * Creates a list of the visible layers in Z-Order, the layer with the lowest Z-Order\n     * first, layer with the highest Z-Order last.\n     * <p>\n     * The active data layer is pulled above all adjacent data layers.\n     *\n     * @return a list of the visible in Z-Order, the layer with the lowest Z-Order\n     * first, layer with the highest Z-Order last.\n     */\n    public List<Layer> getVisibleLayersInZOrder() {\n        synchronized (layers) {\n            List<Layer> ret = new ArrayList<>();\n            // This is set while we delay the addition of the active layer.\n            boolean activeLayerDelayed = false;\n            for (ListIterator<Layer> iterator = layers.listIterator(layers.size()); iterator.hasPrevious();) {\n                Layer l = iterator.previous();\n                if (!l.isVisible()) {\n                    // ignored\n                } else if (l == activeLayer && l instanceof OsmDataLayer) {\n                    // delay and add after the current block of OsmDataLayer\n                    activeLayerDelayed = true;\n                } else {\n                    if (activeLayerDelayed && !(l instanceof OsmDataLayer)) {\n                        // add active layer before the current one.\n                        ret.add(activeLayer);\n                        activeLayerDelayed = false;\n                    }\n                    // Add this layer now\n                    ret.add(l);\n                }\n            }\n            if (activeLayerDelayed) {\n                ret.add(activeLayer);\n            }\n            return ret;\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void fireLayerAdded(Layer newLayer) {\n        checkLayerLockNotHeld();\n        for (MapView.LayerChangeListener l : MapView.layerChangeListeners) {\n            l.layerAdded(newLayer);\n        }\n    }","id":67124,"modified_method":"protected void fireLayerAdded(Layer newLayer) {\n        for (MapView.LayerChangeListener l : MapView.layerChangeListeners) {\n            l.layerAdded(newLayer);\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Sets the title of the JOSM main window, adding a star if there are dirty layers.\n     * @see Main#parent\n     */\n    protected void refreshTitle() {\n        if (Main.parent != null) {\n            layerLock.readLock().lock();\n            try {\n                boolean dirty = editLayer != null &&\n                        (editLayer.requiresSaveToFile() || (editLayer.requiresUploadToServer() && !editLayer.isUploadDiscouraged()));\n                ((JFrame) Main.parent).setTitle((dirty ? \"* \" : \"\") + tr(\"Java OpenStreetMap Editor\"));\n                ((JFrame) Main.parent).getRootPane().putClientProperty(\"Window.documentModified\", dirty);\n            } finally {\n                layerLock.readLock().unlock();\n            }\n        }\n    }","id":67125,"modified_method":"/**\n     * Sets the title of the JOSM main window, adding a star if there are dirty layers.\n     * @see Main#parent\n     */\n    protected void refreshTitle() {\n        if (Main.parent != null) {\n            synchronized (layers) {\n                boolean dirty = editLayer != null &&\n                        (editLayer.requiresSaveToFile() || (editLayer.requiresUploadToServer() && !editLayer.isUploadDiscouraged()));\n                ((JFrame) Main.parent).setTitle((dirty ? \"* \" : \"\") + tr(\"Java OpenStreetMap Editor\"));\n                ((JFrame) Main.parent).getRootPane().putClientProperty(\"Window.documentModified\", dirty);\n            }\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Replies the current edit layer, if any\n     *\n     * @return the current edit layer. May be null.\n     */\n    public OsmDataLayer getEditLayer() {\n        layerLock.readLock().lock();\n        try {\n            return editLayer;\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67126,"modified_method":"/**\n     * Replies the current edit layer, if any\n     *\n     * @return the current edit layer. May be null.\n     */\n    public OsmDataLayer getEditLayer() {\n        synchronized (layers) {\n            return editLayer;\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @return An unmodifiable collection of all layers\n     */\n    public Collection<Layer> getAllLayers() {\n        layerLock.readLock().lock();\n        try {\n            return Collections.unmodifiableCollection(new ArrayList<>(layers));\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67127,"modified_method":"/**\n     * @return An unmodifiable collection of all layers\n     */\n    public Collection<Layer> getAllLayers() {\n        synchronized (layers) {\n            return Collections.unmodifiableCollection(new ArrayList<>(layers));\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"protected void fireLayerRemoved(Layer layer) {\n        checkLayerLockNotHeld();\n        for (MapView.LayerChangeListener l : MapView.layerChangeListeners) {\n            l.layerRemoved(layer);\n        }\n    }","id":67128,"modified_method":"protected void fireLayerRemoved(Layer layer) {\n        for (MapView.LayerChangeListener l : MapView.layerChangeListeners) {\n            l.layerRemoved(layer);\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * @return An unmodifiable ordered list of all layers\n     */\n    public List<Layer> getAllLayersAsList() {\n        layerLock.readLock().lock();\n        try {\n            return Collections.unmodifiableList(new ArrayList<>(layers));\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67129,"modified_method":"/**\n     * @return An unmodifiable ordered list of all layers\n     */\n    public List<Layer> getAllLayersAsList() {\n        synchronized (layers) {\n            return Collections.unmodifiableList(new ArrayList<>(layers));\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * replies true if the list of layers managed by this map view contain layer\n     *\n     * @param layer the layer\n     * @return true if the list of layers managed by this map view contain layer\n     */\n    public boolean hasLayer(Layer layer) {\n        layerLock.readLock().lock();\n        try {\n            return layers.contains(layer);\n        } finally {\n            layerLock.readLock().unlock();\n        }\n    }","id":67130,"modified_method":"/**\n     * replies true if the list of layers managed by this map view contain layer\n     *\n     * @param layer the layer\n     * @return true if the list of layers managed by this map view contain layer\n     */\n    public boolean hasLayer(Layer layer) {\n        synchronized (layers) {\n            return layers.contains(layer);\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Moves the layer to the given new position. No event is fired, but repaints\n     * according to the new Z-Order of the layers.\n     *\n     * @param layer     The layer to move\n     * @param pos       The new position of the layer\n     */\n    public void moveLayer(Layer layer, int pos) {\n        EnumSet<LayerListenerType> listenersToFire;\n        Layer oldActiveLayer = activeLayer;\n        OsmDataLayer oldEditLayer = editLayer;\n\n        layerLock.writeLock().lock();\n        layerLock.readLock().lock();\n        try {\n            try {\n                int curLayerPos = layers.indexOf(layer);\n                if (curLayerPos == -1)\n                    throw new IllegalArgumentException(tr(\"Layer not in list.\"));\n                if (pos == curLayerPos)\n                    return; // already in place.\n                layers.remove(curLayerPos);\n                if (pos >= layers.size()) {\n                    layers.add(layer);\n                } else {\n                    layers.add(pos, layer);\n                }\n                listenersToFire = setEditLayer(layers);\n            } finally {\n                layerLock.writeLock().unlock();\n            }\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n            AudioPlayer.reset();\n        } finally {\n            layerLock.readLock().unlock();\n        }\n        repaint();\n    }","id":67131,"modified_method":"/**\n     * Moves the layer to the given new position. No event is fired, but repaints\n     * according to the new Z-Order of the layers.\n     *\n     * @param layer     The layer to move\n     * @param pos       The new position of the layer\n     */\n    public void moveLayer(Layer layer, int pos) {\n        EnumSet<LayerListenerType> listenersToFire;\n        Layer oldActiveLayer = activeLayer;\n        OsmDataLayer oldEditLayer = editLayer;\n\n        synchronized (layers) {\n            int curLayerPos = layers.indexOf(layer);\n            if (curLayerPos == -1)\n                throw new IllegalArgumentException(tr(\"Layer not in list.\"));\n            if (pos == curLayerPos)\n                return; // already in place.\n            layers.remove(curLayerPos);\n            if (pos >= layers.size()) {\n                layers.add(layer);\n            } else {\n                layers.add(pos, layer);\n            }\n            listenersToFire = setEditLayer(layers);\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n            AudioPlayer.reset();\n        }\n        repaint();\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"public void destroy() {\n        Main.pref.removePreferenceChangeListener(this);\n        DataSet.removeSelectionListener(repaintSelectionChangedListener);\n        MultipolygonCache.getInstance().clear(this);\n        if (mapMover != null) {\n            mapMover.destroy();\n        }\n        layerLock.writeLock().lock();\n        try {\n            activeLayer = null;\n            changedLayer = null;\n            editLayer = null;\n            layers.clear();\n        } finally {\n            layerLock.writeLock().unlock();\n        }\n        nonChangedLayers.clear();\n        synchronized (temporaryLayers) {\n            temporaryLayers.clear();\n        }\n    }","id":67132,"modified_method":"public void destroy() {\n        Main.pref.removePreferenceChangeListener(this);\n        DataSet.removeSelectionListener(repaintSelectionChangedListener);\n        MultipolygonCache.getInstance().clear(this);\n        if (mapMover != null) {\n            mapMover.destroy();\n        }\n        synchronized (layers) {\n            activeLayer = null;\n            changedLayer = null;\n            editLayer = null;\n            layers.clear();\n            nonChangedLayers.clear();\n        }\n        synchronized (temporaryLayers) {\n            temporaryLayers.clear();\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Add a layer to the current MapView. The layer will be added at topmost\n     * position.\n     * @param layer The layer to add\n     */\n    public void addLayer(Layer layer) {\n        boolean isOsmDataLayer = layer instanceof OsmDataLayer;\n        EnumSet<LayerListenerType> listenersToFire = EnumSet.noneOf(LayerListenerType.class);\n        Layer oldActiveLayer = activeLayer;\n        OsmDataLayer oldEditLayer = editLayer;\n\n        layerLock.writeLock().lock();\n        layerLock.readLock().lock();\n        try {\n            try {\n                if (layer instanceof MarkerLayer && playHeadMarker == null) {\n                    playHeadMarker = PlayHeadMarker.create();\n                }\n\n                if (layer instanceof GpxLayer) {\n                    addGpxLayer((GpxLayer) layer);\n                } else if (layers.isEmpty()) {\n                    layers.add(layer);\n                } else if (layer.isBackgroundLayer()) {\n                    int i = 0;\n                    for (; i < layers.size(); i++) {\n                        if (layers.get(i).isBackgroundLayer()) {\n                            break;\n                        }\n                    }\n                    layers.add(i, layer);\n                } else {\n                    layers.add(0, layer);\n                }\n\n                if (isOsmDataLayer || oldActiveLayer == null) {\n                    // autoselect the new layer\n                    listenersToFire.addAll(setActiveLayer(layer, true));\n                }\n            } finally {\n                layerLock.writeLock().unlock();\n            }\n\n            fireLayerAdded(layer);\n            if (isOsmDataLayer) {\n                ((OsmDataLayer) layer).addLayerStateChangeListener(this);\n            }\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n            layer.addPropertyChangeListener(this);\n            Main.addProjectionChangeListener(layer);\n            AudioPlayer.reset();\n        } finally {\n            layerLock.readLock().unlock();\n        }\n        if (!listenersToFire.isEmpty()) {\n            repaint();\n        }\n    }","id":67133,"modified_method":"/**\n     * Add a layer to the current MapView. The layer will be added at topmost\n     * position.\n     * @param layer The layer to add\n     */\n    public void addLayer(Layer layer) {\n        boolean isOsmDataLayer = layer instanceof OsmDataLayer;\n        EnumSet<LayerListenerType> listenersToFire = EnumSet.noneOf(LayerListenerType.class);\n        Layer oldActiveLayer = activeLayer;\n        OsmDataLayer oldEditLayer = editLayer;\n\n        synchronized (layers) {\n            if (layer instanceof MarkerLayer && playHeadMarker == null) {\n                playHeadMarker = PlayHeadMarker.create();\n            }\n\n            if (layer instanceof GpxLayer) {\n                addGpxLayer((GpxLayer) layer);\n            } else if (layers.isEmpty()) {\n                layers.add(layer);\n            } else if (layer.isBackgroundLayer()) {\n                int i = 0;\n                for (; i < layers.size(); i++) {\n                    if (layers.get(i).isBackgroundLayer()) {\n                        break;\n                    }\n                }\n                layers.add(i, layer);\n            } else {\n                layers.add(0, layer);\n            }\n\n            if (isOsmDataLayer || oldActiveLayer == null) {\n                // autoselect the new layer\n                listenersToFire.addAll(setActiveLayer(layer, true));\n            }\n\n            fireLayerAdded(layer);\n            if (isOsmDataLayer) {\n                ((OsmDataLayer) layer).addLayerStateChangeListener(this);\n            }\n            onActiveEditLayerChanged(oldActiveLayer, oldEditLayer, listenersToFire);\n            layer.addPropertyChangeListener(this);\n            Main.addProjectionChangeListener(layer);\n            AudioPlayer.reset();\n        }\n        if (!listenersToFire.isEmpty()) {\n            repaint();\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Gets the index of the layer in the layer list.\n     * @param layer The layer to search for.\n     * @return The index in the list.\n     * @throws IllegalArgumentException if that layer does not belong to this view.\n     */\n    public int getLayerPos(Layer layer) {\n        int curLayerPos;\n        layerLock.readLock().lock();\n        try {\n            curLayerPos = layers.indexOf(layer);\n        } finally {\n            layerLock.readLock().unlock();\n        }\n        if (curLayerPos == -1)\n            throw new IllegalArgumentException(tr(\"Layer not in list.\"));\n        return curLayerPos;\n    }","id":67134,"modified_method":"/**\n     * Gets the index of the layer in the layer list.\n     * @param layer The layer to search for.\n     * @return The index in the list.\n     * @throws IllegalArgumentException if that layer does not belong to this view.\n     */\n    public int getLayerPos(Layer layer) {\n        int curLayerPos;\n        synchronized (layers) {\n            curLayerPos = layers.indexOf(layer);\n        }\n        if (curLayerPos == -1)\n            throw new IllegalArgumentException(tr(\"Layer not in list.\"));\n        return curLayerPos;\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"/**\n     * Adds a GPX layer. A GPX layer is added below the lowest data layer.\n     * <p>\n     * Does not call {@link #fireLayerAdded(Layer)}.\n     *\n     * @param layer the GPX layer\n     */\n    protected void addGpxLayer(GpxLayer layer) {\n        layerLock.writeLock().lock();\n        try {\n            if (layers.isEmpty()) {\n                layers.add(layer);\n                return;\n            }\n            for (int i = layers.size()-1; i >= 0; i--) {\n                if (layers.get(i) instanceof OsmDataLayer) {\n                    if (i == layers.size()-1) {\n                        layers.add(layer);\n                    } else {\n                        layers.add(i+1, layer);\n                    }\n                    return;\n                }\n            }\n            layers.add(0, layer);\n        } finally {\n            layerLock.writeLock().unlock();\n        }\n    }","id":67135,"modified_method":"/**\n     * Adds a GPX layer. A GPX layer is added below the lowest data layer.\n     * <p>\n     * Does not call {@link #fireLayerAdded(Layer)}.\n     *\n     * @param layer the GPX layer\n     */\n    protected void addGpxLayer(GpxLayer layer) {\n        synchronized (layers) {\n            if (layers.isEmpty()) {\n                layers.add(layer);\n                return;\n            }\n            for (int i = layers.size()-1; i >= 0; i--) {\n                if (layers.get(i) instanceof OsmDataLayer) {\n                    if (i == layers.size()-1) {\n                        layers.add(layer);\n                    } else {\n                        layers.add(i+1, layer);\n                    }\n                    return;\n                }\n            }\n            layers.add(0, layer);\n        }\n    }","commit_id":"f3f0ab13d3c24ceb75494616fb4fbb187dc1eac0","url":"https://github.com/openstreetmap/josm"},{"original_method":"public long getClassPK() {\n\t\tif (isFirstVersion() || isApproved()) {\n\t\t\treturn getResourcePrimKey();\n\t\t}\n\n\t\treturn getPrimaryKey();\n\t}","id":67136,"modified_method":"public long getClassPK() {\n\t\tif (isApproved()) {\n\t\t\treturn getResourcePrimKey();\n\t\t}\n\n\t\treturn getPrimaryKey();\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Article updateArticle(\n\t\t\tlong userId, long resourcePrimKey, String title, String content,\n\t\t\tString description, String dirName, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tint version = ArticleConstants.DEFAULT_VERSION;\n\t\tint status = WorkflowConstants.STATUS_DRAFT;\n\n\t\tvalidate(title, content);\n\n\t\tArticle oldArticle = getLatestArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tlong oldResourcePrimKey = oldArticle.getResourcePrimKey();\n\t\tlong oldGroupId = oldArticle.getGroupId();\n\t\tDate oldCreateDate = oldArticle.getCreateDate();\n\t\tlong oldRootResourcePrimKey = oldArticle.getRootResourcePrimKey();\n\t\tlong oldParentResourcePrimKey = oldArticle.getParentResourcePrimKey();\n\t\tint oldVersion = oldArticle.getVersion();\n\t\tdouble oldPriority = oldArticle.getPriority();\n\t\tint oldViewCount = oldArticle.getViewCount();\n\t\tint oldStatus = oldArticle.getStatus();\n\n\t\tArticle article = null;\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tlong articleId = counterLocalService.increment();\n\n\t\t\tarticle = articlePersistence.create(articleId);\n\t\t\tversion = oldVersion + 1;\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t\tversion = oldVersion;\n\t\t}\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tstatus = WorkflowConstants.STATUS_PENDING;\n\t\t}\n\n\t\tarticle.setResourcePrimKey(oldResourcePrimKey);\n\t\tarticle.setGroupId(oldGroupId);\n\t\tarticle.setCompanyId(user.getCompanyId());\n\t\tarticle.setUserId(user.getUserId());\n\t\tarticle.setUserName(user.getFullName());\n\t\tarticle.setCreateDate(oldCreateDate);\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tarticle.setRootResourcePrimKey(oldRootResourcePrimKey);\n\t\tarticle.setParentResourcePrimKey(oldParentResourcePrimKey);\n\t\tarticle.setVersion(version);\n\t\tarticle.setTitle(title);\n\t\tarticle.setContent(content);\n\t\tarticle.setDescription(description);\n\t\tarticle.setPriority(oldPriority);\n\t\tarticle.setViewCount(oldViewCount);\n\t\tarticle.setLatest(ArticleConstants.LATEST_VERSION);\n\t\tarticle.setStatus(status);\n\n\t\tarticlePersistence.update(article, false);\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\toldArticle.setLatest(ArticleConstants.LATEST_APPROVED);\n\n\t\t\tarticlePersistence.update(oldArticle, false);\n\t\t}\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getCommunityPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateArticleResources(\n\t\t\t\tarticle, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, article, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Attachments\n\n\t\tupdateAttachments(article, oldStatus, dirName);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), article.getGroupId(), userId,\n\t\t\tArticle.class.getName(), resourcePrimKey, article, serviceContext);\n\n\t\treturn article;\n\t}","id":67137,"modified_method":"public Article updateArticle(\n\t\t\tlong userId, long resourcePrimKey, String title, String content,\n\t\t\tString description, String dirName, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\t// Article\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tint version = ArticleConstants.DEFAULT_VERSION;\n\t\tint status = WorkflowConstants.STATUS_DRAFT;\n\n\t\tvalidate(title, content);\n\n\t\tArticle oldArticle = getLatestArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tlong oldResourcePrimKey = oldArticle.getResourcePrimKey();\n\t\tlong oldGroupId = oldArticle.getGroupId();\n\t\tDate oldCreateDate = oldArticle.getCreateDate();\n\t\tlong oldRootResourcePrimKey = oldArticle.getRootResourcePrimKey();\n\t\tlong oldParentResourcePrimKey = oldArticle.getParentResourcePrimKey();\n\t\tint oldVersion = oldArticle.getVersion();\n\t\tdouble oldPriority = oldArticle.getPriority();\n\t\tint oldViewCount = oldArticle.getViewCount();\n\t\tint oldStatus = oldArticle.getStatus();\n\n\t\tArticle article = null;\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tlong articleId = counterLocalService.increment();\n\n\t\t\tarticle = articlePersistence.create(articleId);\n\t\t\tversion = oldVersion + 1;\n\t\t}\n\t\telse {\n\t\t\tarticle = oldArticle;\n\t\t\tversion = oldVersion;\n\t\t}\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_PENDING) {\n\t\t\tstatus = WorkflowConstants.STATUS_PENDING;\n\t\t}\n\n\t\tarticle.setResourcePrimKey(oldResourcePrimKey);\n\t\tarticle.setGroupId(oldGroupId);\n\t\tarticle.setCompanyId(user.getCompanyId());\n\t\tarticle.setUserId(user.getUserId());\n\t\tarticle.setUserName(user.getFullName());\n\t\tarticle.setCreateDate(oldCreateDate);\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(null));\n\t\tarticle.setRootResourcePrimKey(oldRootResourcePrimKey);\n\t\tarticle.setParentResourcePrimKey(oldParentResourcePrimKey);\n\t\tarticle.setVersion(version);\n\t\tarticle.setTitle(title);\n\t\tarticle.setContent(content);\n\t\tarticle.setDescription(description);\n\t\tarticle.setPriority(oldPriority);\n\t\tarticle.setViewCount(oldViewCount);\n\t\tarticle.setLatest(ArticleConstants.LATEST_VERSION);\n\t\tarticle.setStatus(status);\n\n\t\tarticlePersistence.update(article, false);\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\toldArticle.setLatest(ArticleConstants.LATEST_APPROVED);\n\n\t\t\tarticlePersistence.update(oldArticle, false);\n\t\t}\n\n\t\t// Resources\n\n\t\tif ((serviceContext.getCommunityPermissions() != null) ||\n\t\t\t(serviceContext.getGuestPermissions() != null)) {\n\n\t\t\tupdateArticleResources(\n\t\t\t\tarticle, serviceContext.getCommunityPermissions(),\n\t\t\t\tserviceContext.getGuestPermissions());\n\t\t}\n\n\t\t// Asset\n\n\t\tupdateAsset(\n\t\t\tuserId, article, serviceContext.getAssetCategoryIds(),\n\t\t\tserviceContext.getAssetTagNames());\n\n\t\t// Attachments\n\n\t\tupdateAttachments(article, oldVersion, dirName);\n\n\t\t// Workflow\n\n\t\tWorkflowHandlerRegistryUtil.startWorkflowInstance(\n\t\t\tuser.getCompanyId(), article.getGroupId(), userId,\n\t\t\tArticle.class.getName(), resourcePrimKey, article, serviceContext);\n\n\t\treturn article;\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void updateAttachments(\n\t\t\tArticle article, int oldStatus, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (oldStatus == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tif (Validator.isNull(dirName)) {\n\t\t\t\tdirName = ArticleConstants.DIR_NAME_PREFIX +\n\t\t\t\t\tarticle.getResourcePrimKey();\n\t\t\t}\n\n\t\t\taddAttachments(article, dirName);\n\t\t}\n\t\telse {\n\t\t\tif (Validator.isNull(dirName)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdeleteAttachments(article, article.getClassPK());\n\n\t\t\taddAttachments(article, dirName);\n\t\t}\n\t}","id":67138,"modified_method":"protected void updateAttachments(\n\t\t\tArticle article, int oldVersion, String dirName)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (article.getVersion() > oldVersion) {\n\t\t\tString oldDirName =\n\t\t\t\tArticleConstants.DIR_NAME_PREFIX + article.getResourcePrimKey();\n\n\t\t\tif (Validator.isNull(dirName)) {\n\t\t\t\taddAttachments(article, oldDirName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\taddAttachments(article, dirName);\n\t\t\t}\n\t\t}\n\t\telse if (Validator.isNotNull(dirName)) {\n\t\t\tdeleteAttachments(article, article.getClassPK());\n\n\t\t\taddAttachments(article, dirName);\n\t\t}\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void deleteAssets(Article article)\n\t\tthrows PortalException, SystemException {\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tArticle.class.getName(), article.getResourcePrimKey());\n\n\t\tif (!article.isFirstVersion() && !article.isApproved()) {\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tArticle.class.getName(), article.getPrimaryKey());\n\t\t}\n\t}","id":67139,"modified_method":"protected void deleteAssets(Article article)\n\t\tthrows PortalException, SystemException {\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tArticle.class.getName(), article.getClassPK());\n\n\t\tif (!article.isApproved()) {\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tArticle.class.getName(), article.getResourcePrimKey());\n\t\t}\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected void deleteAttachments(Article article)\n\t\tthrows PortalException, SystemException {\n\n\t\tdeleteAttachments(article, article.getResourcePrimKey());\n\n\t\tif (!article.isFirstVersion() && !article.isApproved()) {\n\t\t\tdeleteAttachments(article, article.getPrimaryKey());\n\t\t}\n\t}","id":67140,"modified_method":"protected void deleteAttachments(Article article)\n\t\tthrows PortalException, SystemException {\n\n\t\tdeleteAttachments(article, article.getClassPK());\n\n\t\tif (!article.isApproved()) {\n\t\t\tdeleteAttachments(article, article.getResourcePrimKey());\n\t\t}\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public Article updateStatus(\n\t\t\tlong userId, long resourcePrimKey, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\t// Article\n\n\t\tArticle article = getLatestArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tarticle.setStatus(status);\n\t\tarticle.setStatusByUserId(user.getUserId());\n\t\tarticle.setStatusByUserName(user.getFullName());\n\t\tarticle.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tarticlePersistence.update(article, false);\n\n\t\tif (status != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn article;\n\t\t}\n\n\t\tif (!article.isFirstVersion()) {\n\t\t\tArticle oldArticle = articlePersistence.findByR_V(\n\t\t\t\tresourcePrimKey, article.getVersion() - 1);\n\n\t\t\toldArticle.setLatest(ArticleConstants.LATEST_ARCHIVED);\n\n\t\t\tarticlePersistence.update(oldArticle, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tif (!article.isFirstVersion()) {\n\t\t\tAssetEntry assetEntry = assetEntryLocalService.getEntry(\n\t\t\t\tArticle.class.getName(), article.getPrimaryKey());\n\n\t\t\tupdateAsset(\n\t\t\t\tuserId, article, assetEntry.getCategoryIds(),\n\t\t\t\tassetEntry.getTagNames());\n\n\t\t\tassetEntryLocalService.deleteEntry(\n\t\t\t\tArticle.class.getName(), article.getPrimaryKey());\n\t\t}\n\n\t\t// Social\n\n\t\tif (!article.isFirstVersion()) {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, article.getGroupId(), Article.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.UPDATE_ARTICLE,\n\t\t\t\tStringPool.BLANK, 0);\n\t\t}\n\t\telse {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, article.getGroupId(), Article.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.ADD_ARTICLE,\n\t\t\t\tStringPool.BLANK, 0);\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(Article.class);\n\n\t\tindexer.reindex(article);\n\n\t\t// Attachments\n\n\t\tif (!article.isFirstVersion()) {\n\t\t\tdeleteAttachments(article, article.getResourcePrimKey());\n\n\t\t\taddAttachments(\n\t\t\t\tarticle,\n\t\t\t\tArticleConstants.DIR_NAME_PREFIX + article.getPrimaryKey());\n\n\t\t\tdeleteAttachments(article, article.getPrimaryKey());\n\t\t}\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(article, serviceContext);\n\n\t\treturn article;\n\t}","id":67141,"modified_method":"public Article updateStatus(\n\t\t\tlong userId, long resourcePrimKey, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\t// Article\n\n\t\tArticle article = getLatestArticle(\n\t\t\tresourcePrimKey, WorkflowConstants.STATUS_ANY);\n\n\t\tarticle.setModifiedDate(serviceContext.getModifiedDate(now));\n\t\tarticle.setStatus(status);\n\t\tarticle.setStatusByUserId(user.getUserId());\n\t\tarticle.setStatusByUserName(user.getFullName());\n\t\tarticle.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tarticlePersistence.update(article, false);\n\n\t\tif (status != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn article;\n\t\t}\n\n\t\tif (!article.isFirstVersion()) {\n\t\t\tArticle oldArticle = articlePersistence.findByR_V(\n\t\t\t\tresourcePrimKey, article.getVersion() - 1);\n\n\t\t\toldArticle.setLatest(ArticleConstants.LATEST_ARCHIVED);\n\n\t\t\tarticlePersistence.update(oldArticle, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tAssetEntry assetEntry = assetEntryLocalService.getEntry(\n\t\t\tArticle.class.getName(), article.getPrimaryKey());\n\n\t\tupdateAsset(\n\t\t\tuserId, article, assetEntry.getCategoryIds(),\n\t\t\tassetEntry.getTagNames());\n\n\t\tassetEntryLocalService.deleteEntry(\n\t\t\tArticle.class.getName(), article.getPrimaryKey());\n\n\t\t// Social\n\n\t\tif (!article.isFirstVersion()) {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, article.getGroupId(), Article.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.UPDATE_ARTICLE,\n\t\t\t\tStringPool.BLANK, 0);\n\t\t}\n\t\telse {\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, article.getGroupId(), Article.class.getName(),\n\t\t\t\tresourcePrimKey, AdminActivityKeys.ADD_ARTICLE,\n\t\t\t\tStringPool.BLANK, 0);\n\t\t}\n\n\t\t// Indexer\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(Article.class);\n\n\t\tindexer.reindex(article);\n\n\t\t// Attachments\n\n\t\tdeleteAttachments(article, article.getResourcePrimKey());\n\n\t\tString dirName =\n\t\t\tArticleConstants.DIR_NAME_PREFIX + article.getPrimaryKey();\n\n\t\taddAttachments(article, dirName);\n\n\t\tdeleteAttachments(article, article.getPrimaryKey());\n\n\t\t// Subscriptions\n\n\t\tnotifySubscribers(article, serviceContext);\n\n\t\treturn article;\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"protected PortletURL getDisplayPortletURL(\n\t\t\tlong plid, HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tPortletURL portletURL = getArticleURL(plid, PORTLET_ID, request);\n\n\t\tportletURL.setWindowState(LiferayWindowState.MAXIMIZED);\n\n\t\tif (!_PORTLET_ADD_DEFAULT_RESOURCE_CHECK_ENABLED) {\n\t\t\treturn portletURL;\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"p_p_auth\", AuthTokenUtil.getToken(request, plid, PORTLET_ID));\n\n\t\treturn portletURL;\n\t}","id":67142,"modified_method":"protected PortletURL getDynamicPortletURL(\n\t\t\tlong plid, HttpServletRequest request)\n\t\tthrows Exception {\n\n\t\tPortletURL portletURL = getArticleURL(plid, PORTLET_ID, request);\n\n\t\tportletURL.setWindowState(LiferayWindowState.MAXIMIZED);\n\n\t\tif (!_PORTLET_ADD_DEFAULT_RESOURCE_CHECK_ENABLED) {\n\t\t\treturn portletURL;\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"p_p_auth\", AuthTokenUtil.getToken(request, plid, PORTLET_ID));\n\n\t\treturn portletURL;\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"public String execute(\n\t\t\tStrutsAction originalStrutsAction, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong plid = ParamUtil.getLong(request, \"plid\");\n\t\tlong resourcePrimKey = ParamUtil.getLong(request, \"resourcePrimKey\");\n\t\tboolean maximized = ParamUtil.getBoolean(request, \"maximized\");\n\n\t\tif (!isValidPlid(plid)) {\n\t\t\tplid = themeDisplay.getPlid();\n\t\t}\n\n\t\tPortletURL portletURL = null;\n\n\t\tArticle article = getArticle(resourcePrimKey);\n\n\t\tif (article == null) {\n\t\t\tportletURL = getDisplayPortletURL(plid, request);\n\t\t}\n\n\t\tif (portletURL == null) {\n\t\t\tportletURL = getArticleURL(plid, false, article, request);\n\t\t}\n\n\t\tif (portletURL == null) {\n\t\t\tportletURL = getArticleURL(plid, true, article, request);\n\t\t}\n\n\t\tif (portletURL == null) {\n\t\t\tportletURL = getDisplayPortletURL(plid, request);\n\t\t}\n\n\t\tif (maximized) {\n\t\t\tportletURL.setWindowState(LiferayWindowState.MAXIMIZED);\n\t\t}\n\n\t\tresponse.sendRedirect(portletURL.toString());\n\n\t\treturn null;\n\t}","id":67143,"modified_method":"public String execute(\n\t\t\tStrutsAction originalStrutsAction, HttpServletRequest request,\n\t\t\tHttpServletResponse response)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tlong plid = ParamUtil.getLong(request, \"plid\");\n\t\tlong resourcePrimKey = ParamUtil.getLong(request, \"resourcePrimKey\");\n\t\tboolean maximized = ParamUtil.getBoolean(request, \"maximized\");\n\n\t\tif (!isValidPlid(plid)) {\n\t\t\tplid = themeDisplay.getPlid();\n\t\t}\n\n\t\tPortletURL portletURL = null;\n\n\t\tArticle article = getArticle(resourcePrimKey);\n\n\t\tif (article == null) {\n\t\t\tportletURL = getDynamicPortletURL(plid, request);\n\t\t}\n\n\t\tif (portletURL == null) {\n\t\t\tportletURL = getArticleURL(plid, false, article, request);\n\t\t}\n\n\t\tif (portletURL == null) {\n\t\t\tportletURL = getArticleURL(plid, true, article, request);\n\t\t}\n\n\t\tif (portletURL == null) {\n\t\t\tportletURL = getDynamicPortletURL(plid, request);\n\t\t}\n\n\t\tif (maximized) {\n\t\t\tportletURL.setWindowState(LiferayWindowState.MAXIMIZED);\n\t\t}\n\n\t\tresponse.sendRedirect(portletURL.toString());\n\n\t\treturn null;\n\t}","commit_id":"866399c74076ac179d784925d2f27c3d60503445","url":"https://github.com/liferay/liferay-plugins"},{"original_method":"@Override\n  public void loadState(State state) {\n    myState.myShowDebugConsoleByDefault = state.myShowDebugConsoleByDefault;\n    myState.myShowSeparatorLine = state.myShowSeparatorLine;\n    myState.myPythonConsoleState = state.myPythonConsoleState;\n  }","id":67144,"modified_method":"@Override\n  public void loadState(State state) {\n    myState.myShowDebugConsoleByDefault = state.myShowDebugConsoleByDefault;\n    myState.myShowSeparatorLine = state.myShowSeparatorLine;\n    myState.myPythonConsoleState = state.myPythonConsoleState;\n    myState.myIpythonEnabled = state.myIpythonEnabled;\n  }","commit_id":"74aa6ccc51edebce4fa025b2ea8fc775d07a4d8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n      myShowDebugConsoleByDefault.setSelected(myOptionsProvider.isShowDebugConsoleByDefault());\n      myShowSeparatorLine.setSelected(myOptionsProvider.isShowSeparatorLine());\n    }","id":67145,"modified_method":"public void reset() {\n      myShowDebugConsoleByDefault.setSelected(myOptionsProvider.isShowDebugConsoleByDefault());\n      myShowSeparatorLine.setSelected(myOptionsProvider.isShowSeparatorLine());\n      myIpythonEnabledCheckbox.setSelected(myOptionsProvider.isIpythonEnabled());\n    }","commit_id":"74aa6ccc51edebce4fa025b2ea8fc775d07a4d8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void apply() {\n      myOptionsProvider.setShowDebugConsoleByDefault(myShowDebugConsoleByDefault.isSelected());\n      myOptionsProvider.setShowSeparatorLine(myShowSeparatorLine.isSelected());\n    }","id":67146,"modified_method":"public void apply() {\n      myOptionsProvider.setShowDebugConsoleByDefault(myShowDebugConsoleByDefault.isSelected());\n      myOptionsProvider.setShowSeparatorLine(myShowSeparatorLine.isSelected());\n      myOptionsProvider.setIpythonEnabled(myIpythonEnabledCheckbox.isSelected());\n    }","commit_id":"74aa6ccc51edebce4fa025b2ea8fc775d07a4d8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isModified() {\n      return myShowDebugConsoleByDefault.isSelected() != myOptionsProvider.isShowDebugConsoleByDefault() ||\n             myShowSeparatorLine.isSelected() != myOptionsProvider.isShowSeparatorLine();\n\n    }","id":67147,"modified_method":"public boolean isModified() {\n      return myShowDebugConsoleByDefault.isSelected() != myOptionsProvider.isShowDebugConsoleByDefault() ||\n             myShowSeparatorLine.isSelected() != myOptionsProvider.isShowSeparatorLine() ||\n             myIpythonEnabledCheckbox.isSelected()  != myOptionsProvider.isIpythonEnabled();\n\n    }","commit_id":"74aa6ccc51edebce4fa025b2ea8fc775d07a4d8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static PydevConsoleRunner runPythonConsole(Project project, Module contextModule) {\n    assert project != null : \"Project is null\";\n\n    Pair<Sdk, Module> sdkAndModule = findPythonSdkAndModule(project, contextModule);\n\n    Module module = sdkAndModule.second;\n    Sdk sdk = sdkAndModule.first;\n\n    assert sdk != null;\n\n    PathMappingSettings mappingSettings = getMappings(project, sdk);\n\n    String[] setupFragment;\n\n    PyConsoleOptions.PyConsoleSettings settingsProvider = PyConsoleOptions.getInstance(project).getPythonConsoleSettings();\n    Collection<String> pythonPath = PythonCommandLineState.collectPythonPath(module, settingsProvider.addContentRoots(),\n                                                                             settingsProvider.addSourceRoots());\n\n    if (mappingSettings != null) {\n      pythonPath = mappingSettings.convertToRemote(pythonPath);\n    }\n\n    String selfPathAppend = constructPythonPathCommand(pythonPath);\n\n    String customStartScript = settingsProvider.getCustomStartScript();\n\n    if (customStartScript.trim().length() > 0) {\n      selfPathAppend += \"\\n\" + customStartScript.trim();\n    }\n\n    String workingDir = settingsProvider.getWorkingDirectory();\n    if (StringUtil.isEmpty(workingDir)) {\n      if (module != null && ModuleRootManager.getInstance(module).getContentRoots().length > 0) {\n        workingDir = ModuleRootManager.getInstance(module).getContentRoots()[0].getPath();\n      }\n      else {\n        if (ModuleManager.getInstance(project).getModules().length > 0) {\n          VirtualFile[] roots = ModuleRootManager.getInstance(ModuleManager.getInstance(project).getModules()[0]).getContentRoots();\n          if (roots.length > 0) {\n            workingDir = roots[0].getPath();\n          }\n        }\n      }\n    }\n\n    if (mappingSettings != null) {\n      workingDir = mappingSettings.convertToRemote(workingDir);\n    }\n\n    BuildoutFacet facet = null;\n    if (module != null) {\n      facet = BuildoutFacet.getInstance(module);\n    }\n\n    if (facet != null) {\n      List<String> path = facet.getAdditionalPythonPath();\n      if (mappingSettings != null) {\n        path = mappingSettings.convertToRemote(path);\n      }\n      String prependStatement = facet.getPathPrependStatement(path);\n      setupFragment = new String[]{prependStatement, selfPathAppend};\n    }\n    else {\n      setupFragment = new String[]{selfPathAppend};\n    }\n\n    return PydevConsoleRunner\n      .createAndRun(project, sdk, PyConsoleType.PYTHON, workingDir, Maps.newHashMap(settingsProvider.getEnvs()), setupFragment);\n  }","id":67148,"modified_method":"@NotNull\n  public static PydevConsoleRunner runPythonConsole(Project project, Module contextModule) {\n    assert project != null : \"Project is null\";\n\n    Pair<Sdk, Module> sdkAndModule = findPythonSdkAndModule(project, contextModule);\n\n    Module module = sdkAndModule.second;\n    Sdk sdk = sdkAndModule.first;\n\n    assert sdk != null;\n\n    PathMappingSettings mappingSettings = getMappings(project, sdk);\n\n    String[] setupFragment;\n\n    PyConsoleOptions.PyConsoleSettings settingsProvider = PyConsoleOptions.getInstance(project).getPythonConsoleSettings();\n    Collection<String> pythonPath = PythonCommandLineState.collectPythonPath(module, settingsProvider.addContentRoots(),\n                                                                             settingsProvider.addSourceRoots());\n\n    if (mappingSettings != null) {\n      pythonPath = mappingSettings.convertToRemote(pythonPath);\n    }\n\n    String selfPathAppend = constructPythonPathCommand(pythonPath);\n\n    String customStartScript = settingsProvider.getCustomStartScript();\n\n    if (customStartScript.trim().length() > 0) {\n      selfPathAppend += \"\\n\" + customStartScript.trim();\n    }\n\n    String workingDir = settingsProvider.getWorkingDirectory();\n    if (StringUtil.isEmpty(workingDir)) {\n      if (module != null && ModuleRootManager.getInstance(module).getContentRoots().length > 0) {\n        workingDir = ModuleRootManager.getInstance(module).getContentRoots()[0].getPath();\n      }\n      else {\n        if (ModuleManager.getInstance(project).getModules().length > 0) {\n          VirtualFile[] roots = ModuleRootManager.getInstance(ModuleManager.getInstance(project).getModules()[0]).getContentRoots();\n          if (roots.length > 0) {\n            workingDir = roots[0].getPath();\n          }\n        }\n      }\n    }\n\n    if (mappingSettings != null) {\n      workingDir = mappingSettings.convertToRemote(workingDir);\n    }\n\n    BuildoutFacet facet = null;\n    if (module != null) {\n      facet = BuildoutFacet.getInstance(module);\n    }\n\n    if (facet != null) {\n      List<String> path = facet.getAdditionalPythonPath();\n      if (mappingSettings != null) {\n        path = mappingSettings.convertToRemote(path);\n      }\n      String prependStatement = facet.getPathPrependStatement(path);\n      setupFragment = new String[]{prependStatement, selfPathAppend};\n    }\n    else {\n      setupFragment = new String[]{selfPathAppend};\n    }\n\n    Map<String, String> envs  = Maps.newHashMap(settingsProvider.getEnvs());\n    String ipythonEnabled = PyConsoleOptions.getInstance(project).isIpythonEnabled() ? \"True\" : \"False\";\n    envs.put(PythonEnvUtil.IPYTHONENABLE, ipythonEnabled);\n\n    return PydevConsoleRunner\n      .createAndRun(project, sdk, PyConsoleType.PYTHON, workingDir, envs, setupFragment);\n  }","commit_id":"74aa6ccc51edebce4fa025b2ea8fc775d07a4d8b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String submit(final SystemJob job) {\n        final String jobClass = job.getClass().getCanonicalName();\n\n        job.setId(new UUID().toString());\n        jobs.put(job.getId(), job);\n        executor.submit(new Runnable() {\n            @Override\n            public void run() {\n                Stopwatch x = new Stopwatch().start();\n                job.execute();  // ... blocks until it finishes.\n                x.stop();\n\n                jobs.remove(job.getId());\n\n                String msg = \"SystemJob <\" + job.getId() + \"> [\" + jobClass + \"] finished in \" + x.elapsed(TimeUnit.MILLISECONDS) + \"ms.\";\n                LOG.info(msg);\n                server.getActivityWriter().write(new Activity(msg, SystemJobManager.class));\n            }\n        });\n\n        LOG.info(\"Submitted SystemJob <{}> [{}]\", job.getId(), jobClass);\n        return job.getId();\n    }","id":67149,"modified_method":"public String submit(final SystemJob job) {\n        final String jobClass = job.getClass().getCanonicalName();\n\n        job.setId(new UUID().toString());\n        jobs.put(job.getId(), job);\n        executor.submit(new Runnable() {\n            @Override\n            public void run() {\n                job.markStarted();\n\n                Stopwatch x = new Stopwatch().start();\n                job.execute();  // ... blocks until it finishes.\n                x.stop();\n\n                jobs.remove(job.getId());\n\n                String msg = \"SystemJob <\" + job.getId() + \"> [\" + jobClass + \"] finished in \" + x.elapsed(TimeUnit.MILLISECONDS) + \"ms.\";\n                LOG.info(msg);\n                server.getActivityWriter().write(new Activity(msg, SystemJobManager.class));\n            }\n        });\n\n        LOG.info(\"Submitted SystemJob <{}> [{}]\", job.getId(), jobClass);\n        return job.getId();\n    }","commit_id":"3dbd6771307fb5af294507f6bb3654be8c57aab3","url":"https://github.com/Graylog2/graylog2-server"},{"original_method":"public void startInBackground(final ApplicationSpec spec) {\n    LOG.info(\"Creating application instance for {}\", spec);\n\n    final AbstractApplication instance = new AbstractApplication() {\n    };\n\n    for (EntitySpec entitySpec : spec.getEntities()) {\n      try {\n        LOG.info(\"Creating instance for entity {}\", entitySpec.getType());\n        Class<Startable> clazz = (Class<Startable>) Class.forName(entitySpec.getType());\n\n        Constructor constructor = clazz.getConstructor(new Class[]{Map.class, brooklyn.entity.Entity.class});\n        // TODO parse & rebuild config map as needed\n        constructor.newInstance(Maps.newHashMap(entitySpec.getConfig()), instance);\n\n      } catch (Exception e) {\n        LOG.error(e, \"Failed to create instance for entity {}\", entitySpec);\n        throw Throwables.propagate(e);\n      }\n    }\n\n    LOG.info(\"Adding '{}' application to registry with status ACCEPTED\", spec.getName());\n    applications.put(spec.getName(), new Application(spec, Application.Status.ACCEPTED, instance));\n\n    // Start all the managed entities by asking the app instance to start in background\n    executorService.submit(new Runnable() {\n\n      Function<String, Location> buildLocationFromRef =\n          new Function<String, Location>() {\n            @Override\n            public Location apply(String ref) {\n              brooklyn.rest.api.Location location = locationStore.getByRef(ref);\n              if (location.getProvider().equals(\"localhost\")) {\n                return new LocalhostMachineProvisioningLocation();\n              }\n\n              Map<String, String> config = Maps.newHashMap();\n              config.put(\"provider\", location.getProvider());\n              config.put(\"identity\", location.getIdentity());\n              config.put(\"credential\", location.getCredential());\n              config.put(\"providerLocationId\", location.getLocation());\n\n              return new JcloudsLocation(config);\n            }\n          };\n\n      @Override\n      public void run() {\n        try {\n          transitionTo(spec.getName(), Application.Status.STARTING);\n          instance.start(newLinkedList(transform(spec.getLocations(), buildLocationFromRef)));\n          transitionTo(spec.getName(), Application.Status.RUNNING);\n\n        } catch (Exception e) {\n          LOG.error(e, \"Failed to start application instance {}\", instance);\n          transitionTo(spec.getName(), Application.Status.ERROR);\n\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n  }","id":67150,"modified_method":"public void startInBackground(final ApplicationSpec spec) {\n    LOG.info(\"Creating application instance for {}\", spec);\n\n    final AbstractApplication instance = new AbstractApplication() {\n    };\n\n    for (EntitySpec entitySpec : spec.getEntities()) {\n      try {\n        LOG.info(\"Creating instance for entity {}\", entitySpec.getType());\n        Class<Startable> clazz = (Class<Startable>) Class.forName(entitySpec.getType());\n\n        Constructor constructor = clazz.getConstructor(new Class[]{Map.class, brooklyn.entity.Entity.class});\n\n        // TODO parse & rebuild config map as needed\n        Map<String, String> config = Maps.newHashMap(entitySpec.getConfig());\n        config.put(\"displayName\", entitySpec.getName());\n\n        constructor.newInstance(config, instance);\n\n      } catch (Exception e) {\n        LOG.error(e, \"Failed to create instance for entity {}\", entitySpec);\n        throw Throwables.propagate(e);\n      }\n    }\n\n    LOG.info(\"Adding '{}' application to registry with status ACCEPTED\", spec.getName());\n    applications.put(spec.getName(), new Application(spec, Application.Status.ACCEPTED, instance));\n\n    // Start all the managed entities by asking the app instance to start in background\n    executorService.submit(new Runnable() {\n\n      Function<String, Location> buildLocationFromRef =\n          new Function<String, Location>() {\n            @Override\n            public Location apply(String ref) {\n              brooklyn.rest.api.Location location = locationStore.getByRef(ref);\n              if (location.getProvider().equals(\"localhost\")) {\n                return new LocalhostMachineProvisioningLocation();\n              }\n\n              Map<String, String> config = Maps.newHashMap();\n              config.put(\"provider\", location.getProvider());\n              config.put(\"identity\", location.getIdentity());\n              config.put(\"credential\", location.getCredential());\n              config.put(\"providerLocationId\", location.getLocation());\n\n              return new JcloudsLocation(config);\n            }\n          };\n\n      @Override\n      public void run() {\n        try {\n          transitionTo(spec.getName(), Application.Status.STARTING);\n          instance.start(newLinkedList(transform(spec.getLocations(), buildLocationFromRef)));\n          transitionTo(spec.getName(), Application.Status.RUNNING);\n\n        } catch (Exception e) {\n          LOG.error(e, \"Failed to start application instance {}\", instance);\n          transitionTo(spec.getName(), Application.Status.ERROR);\n\n          throw Throwables.propagate(e);\n        }\n      }\n    });\n  }","commit_id":"8d98a5ad52eaa8676e57d0a3ef8ec0193cc1fd43","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(dependsOnMethods = \"testListApplications\")\n  public void testDeleteApplication() throws TimeoutException, InterruptedException {\n    ClientResponse response = client().resource(\"/applications/redis\")\n        .delete(ClientResponse.class);\n\n    waitForPageNotFoundResponse(\"/applications/redis\");\n\n    assertEquals(response.getStatus(), Response.Status.ACCEPTED.getStatusCode());\n    assertEquals(manager.registry().size(), 0);\n  }","id":67151,"modified_method":"@Test(dependsOnMethods = {\"testReadAllSensors\", \"testListApplications\"})\n  public void testDeleteApplication() throws TimeoutException, InterruptedException {\n    ClientResponse response = client().resource(\"/applications/redis-app\")\n        .delete(ClientResponse.class);\n\n    waitForPageNotFoundResponse(\"/applications/redis-app\");\n\n    assertEquals(response.getStatus(), Response.Status.ACCEPTED.getStatusCode());\n    assertEquals(manager.registry().size(), 0);\n  }","commit_id":"8d98a5ad52eaa8676e57d0a3ef8ec0193cc1fd43","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test(dependsOnMethods = \"testDeployRedisApplication\")\n  public void testListSensors() {\n    Set<String> sensors = client().resource(\"/applications/redis/sensors\")\n        .get(new GenericType<Set<String>>() {\n        });\n    // fail(sensors.toString());\n  }","id":67152,"modified_method":"@Test(dependsOnMethods = \"testDeployRedisApplication\")\n  public void testListSensors() {\n    Map<String, Set<URI>> sensors = client().resource(\"/applications/redis-app/sensors\")\n        .get(new GenericType<Map<String, Set<URI>>>() {\n        });\n    assertTrue(sensors.containsKey(\"redis-ent\"));\n    assertTrue(sensors.get(\"redis-ent\").contains(\n        URI.create(\"/applications/redis-app/sensors/redis-ent/redis.uptime\")));\n  }","commit_id":"8d98a5ad52eaa8676e57d0a3ef8ec0193cc1fd43","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Test\n  public void testDeployRedisApplication() throws InterruptedException, TimeoutException {\n    ClientResponse response = client().resource(\"/applications\")\n        .post(ClientResponse.class, redisSpec);\n\n    assertEquals(manager.registry().size(), 1);\n    assertEquals(response.getLocation().getPath(), \"/applications/redis\");\n\n    waitForApplicationToBeRunning(response);\n  }","id":67153,"modified_method":"@Test\n  public void testDeployRedisApplication() throws InterruptedException, TimeoutException {\n    ClientResponse response = client().resource(\"/applications\")\n        .post(ClientResponse.class, redisSpec);\n\n    assertEquals(manager.registry().size(), 1);\n    assertEquals(response.getLocation().getPath(), \"/applications/redis-app\");\n\n    waitForApplicationToBeRunning(response);\n  }","commit_id":"8d98a5ad52eaa8676e57d0a3ef8ec0193cc1fd43","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/authentication\");\n    controller.setDescription(\"Check authentication credentials\");\n\n    defineValidateAction(controller);\n\n    controller.done();\n  }","id":67154,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/authentication\");\n    controller.setDescription(\"Check authentication credentials.\");\n\n    defineValidateAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context\n      .createController(ENDPOINT)\n      .setDescription(\"Compute Engine\");\n    for (CeWsAction action : actions) {\n      action.define(controller);\n    }\n    controller.done();\n  }","id":67155,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context\n      .createController(ENDPOINT)\n      .setDescription(\"Get information on Compute Engine tasks.\");\n    for (CeWsAction action : actions) {\n      action.define(controller);\n    }\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/components\")\n      .setSince(\"4.2\")\n      .setDescription(\"Components management\");\n\n    for (ComponentsWsAction action : actions) {\n      action.define(controller);\n    }\n    appAction.define(controller);\n    searchViewComponentsAction.define(controller);\n    defineSuggestionsAction(controller);\n\n    controller.done();\n  }","id":67156,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/components\")\n      .setSince(\"4.2\")\n      .setDescription(\"Get information about a component (file, directory, project, ...) and its ancestors or children.\");\n\n    for (ComponentsWsAction action : actions) {\n      action.define(controller);\n    }\n    appAction.define(controller);\n    searchViewComponentsAction.define(controller);\n    defineSuggestionsAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(ENDPOINT)\n      .setDescription(\"Custom measures management\")\n      .setSince(\"5.2\");\n\n    for (CustomMeasuresWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67157,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(ENDPOINT)\n      .setDescription(\"Manage custom measures for a project. See also api/metrics.\")\n      .setSince(\"5.2\");\n\n    for (CustomMeasuresWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/duplications\")\n      .setSince(\"4.4\")\n      .setDescription(\"Display duplications information\");\n    showAction.define(controller);\n    controller.done();\n  }","id":67158,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/duplications\")\n      .setSince(\"4.4\")\n      .setDescription(\"Get duplication information for a project.\");\n    showAction.define(controller);\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/events\");\n    controller.setDescription(\"Project's events management\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","id":67159,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/events\");\n    controller.setDescription(\"Manage project events.\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/favorites\");\n    controller.setDescription(\"User's favorites management\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","id":67160,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/favorites\");\n    controller.setDescription(\"Manage user favorites.\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/issue_filters\")\n      .setSince(\"4.2\")\n      .setDescription(\"Issue Filters management\");\n    for (IssueFilterWsAction action : actions) {\n      action.define(controller);\n    }\n    controller.done();\n  }","id":67161,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/issue_filters\")\n      .setSince(\"4.2\")\n      .setDescription(\"Get details on existing issue filters/saved issue searches.\");\n    for (IssueFilterWsAction action : actions) {\n      action.define(controller);\n    }\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(API_ENDPOINT);\n    controller.setDescription(\"Coding rule issues\");\n    controller.setSince(\"3.6\");\n    for (IssuesWsAction action : actions) {\n      action.define(controller);\n    }\n    defineRailsActions(controller);\n    controller.done();\n  }","id":67162,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(API_ENDPOINT);\n    controller.setDescription(\"Read and update issues.\");\n    controller.setSince(\"3.6\");\n    for (IssuesWsAction action : actions) {\n      action.define(controller);\n    }\n    defineRailsActions(controller);\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController languages = context.createController(\"api/languages\")\n      .setDescription(\"Programming languages\")\n      .setSince(\"5.1\");\n\n    list.define(languages);\n\n    languages.done();\n  }","id":67163,"modified_method":"@Override\n  public void define(Context context) {\n    NewController languages = context.createController(\"api/languages\")\n      .setDescription(\"Get the list of programming languages supported in this instance.\")\n      .setSince(\"5.1\");\n\n    list.define(languages);\n\n    languages.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(MeasuresWsParameters.CONTROLLER_MEASURES)\n      .setSince(\"5.4\")\n      .setDescription(\"Measures search\");\n\n    for (MeasuresWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67164,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(MeasuresWsParameters.CONTROLLER_MEASURES)\n      .setSince(\"5.4\")\n      .setDescription(\"Get components or children with specified measures.\");\n\n    for (MeasuresWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(ENDPOINT);\n    controller.setDescription(\"Metrics management\");\n    controller.setSince(\"2.6\");\n\n    for (MetricsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67165,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(ENDPOINT);\n    controller.setDescription(\"Get information on automatic metrics, and manage custom metrics. See also api/custom_measures.\");\n    controller.setSince(\"2.6\");\n\n    for (MetricsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(CONTROLLER);\n    controller.setDescription(\"Permissions management\");\n    controller.setSince(\"3.7\");\n\n    for (PermissionsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67166,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(CONTROLLER);\n    controller.setDescription(\"Manage permission templates, and the granting and revoking of permissions at the global and project levels.\");\n    controller.setSince(\"3.7\");\n\n    for (PermissionsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/plugins\");\n    controller.setDescription(\"Plugin management\")\n      .setSince(\"5.2\");\n\n    for (PluginsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67167,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/plugins\");\n    controller.setDescription(\"Manage the plugins on the server, including installing, uninstalling, and upgrading.\")\n      .setSince(\"5.2\");\n\n    for (PluginsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(ENDPOINT)\n      .setSince(\"2.10\")\n      .setDescription(\"Projects management\");\n\n    defineIndexAction(controller);\n    defineCreateAction(controller);\n\n    for (ProjectsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67168,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(ENDPOINT)\n      .setSince(\"2.10\")\n      .setDescription(\"Manage project existence.\");\n\n    defineIndexAction(controller);\n    defineCreateAction(controller);\n\n    for (ProjectsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/properties\");\n    controller.setDescription(\"Properties management\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","id":67169,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/properties\");\n    controller.setDescription(\"Manage global and project properties.\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/qualitygates\")\n      .setSince(\"4.3\")\n      .setDescription(\"This service manages quality gates, including conditions and project association\");\n\n    for (QGateWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67170,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/qualitygates\")\n      .setSince(\"4.3\")\n      .setDescription(\"Manage quality gates, including conditions and project association.\");\n\n    for (QGateWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(API_ENDPOINT)\n      .setDescription(\"Quality Profiles\")\n      .setSince(\"4.4\");\n\n    ruleActivationActions.define(controller);\n    bulkRuleActivationActions.define(controller);\n    projectAssociationActions.define(controller);\n    for(QProfileWsAction action: actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67171,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(API_ENDPOINT)\n      .setDescription(\"Manage quality profiles.\")\n      .setSince(\"4.4\");\n\n    ruleActivationActions.define(controller);\n    bulkRuleActivationActions.define(controller);\n    projectAssociationActions.define(controller);\n    for(QProfileWsAction action: actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/resources\")\n      .setDescription(\"Former components web service\")\n      .setSince(\"2.10\");\n\n    defineIndexAction(controller);\n    defineSearchAction(controller);\n\n    controller.done();\n  }","id":67172,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/resources\")\n      .setDescription(\"Former components web api. Deprecated since 5.4.\")\n      .setSince(\"2.10\");\n\n    defineIndexAction(controller);\n    defineSearchAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context\n      .createController(\"api/rules\")\n      .setDescription(\"Coding rules\");\n\n    for (RulesWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67173,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context\n      .createController(\"api/rules\")\n      .setDescription(\"Get and update some details of automatic rules, and manage custom rules.\");\n\n    for (RulesWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/sources\")\n      .setSince(\"4.2\")\n      .setDescription(\"Display sources information\");\n    for (SourcesWsAction action : actions) {\n      action.define(controller);\n    }\n    controller.done();\n  }","id":67174,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/sources\")\n      .setSince(\"4.2\")\n      .setDescription(\"Get details on source files. See also api/tests.\");\n    for (SourcesWsAction action : actions) {\n      action.define(controller);\n    }\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/system\");\n\n    for (SystemWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67175,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/system\")\n      .setDescription(\"Get system details, and perform some management actions, such as restarting, and initiating a database migration (as part of a system upgrade).\");\n\n    for (SystemWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/tests\")\n      .setSince(\"4.4\")\n      .setDescription(\"Tests management. Deprecated since 5.6\");\n\n    for (TestsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67176,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/tests\")\n      .setSince(\"4.4\")\n      .setDescription(\"Get details on test files. See also api/sources. Deprecated since 5.6.\");\n\n    for (TestsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/timemachine\")\n      .setDescription(\"Get a list of past measures\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n\n    controller.done();\n  }","id":67177,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/timemachine\")\n      .setDescription(\"Get project measure data from past analyses.\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/user_groups\")\n      .setDescription(\"User groups management\")\n      .setSince(\"5.2\");\n\n    for (UserGroupsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67178,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/user_groups\")\n      .setDescription(\"Manage user groups.\")\n      .setSince(\"5.2\");\n\n    for (UserGroupsWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/user_properties\");\n    controller.setDescription(\"User properties management\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","id":67179,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/user_properties\");\n    controller.setDescription(\"Manage user properties.\");\n    controller.setSince(\"2.6\");\n\n    defineIndexAction(controller);\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(CONTROLLER)\n      .setDescription(\"User token management. To enhance security, tokens can be used to take the place \" +\n        \"of user credentials in analysis configuration. A token can be revoked at any time.\")\n      .setSince(\"5.3\");\n\n    for (UserTokensWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67180,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(CONTROLLER)\n      .setDescription(\"List, create, and delete a user's access tokens.\")\n      .setSince(\"5.3\");\n\n    for (UserTokensWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/users\")\n      .setSince(\"3.6\")\n      .setDescription(\"Users management\");\n\n    for (UsersWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","id":67181,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/users\")\n      .setSince(\"3.6\")\n      .setDescription(\"Manage users.\");\n\n    for (UsersWsAction action : actions) {\n      action.define(controller);\n    }\n\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(final Context context) {\n    NewController controller = context\n      .createController(\"api/webservices\")\n      .setSince(\"4.2\")\n      .setDescription(\"List web services\");\n    defineList(context, controller);\n    defineResponseExample(context, controller);\n    controller.done();\n  }","id":67182,"modified_method":"@Override\n  public void define(final Context context) {\n    NewController controller = context\n      .createController(\"api/webservices\")\n      .setSince(\"4.2\")\n      .setDescription(\"Get information on the web api supported on this instance.\");\n    defineList(context, controller);\n    defineResponseExample(context, controller);\n    controller.done();\n  }","commit_id":"734dbe2e58c0f0e7cb771ce16a399241420980f9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/action_plans\");\n    controller.setDescription(\"Action plans\");\n\n    WebService.NewAction search = controller.createAction(\"search\")\n      .setDescription(\"Get a list of action plans. Requires Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"));\n    addProjectParam(search);\n\n    WebService.NewAction create = controller.createAction(\"create\")\n      .setDescription(\"Create an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addNameParam(create);\n    addDescriptionParam(create);\n    addDeadLineParam(create);\n    addProjectParam(create);\n\n    WebService.NewAction update = controller.createAction(\"update\")\n      .setDescription(\"Update an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(update);\n    addNameParam(update);\n    addDescriptionParam(update);\n    addDeadLineParam(update);\n\n    WebService.NewAction delete = controller.createAction(\"delete\")\n      .setDescription(\"Delete an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(delete);\n\n    WebService.NewAction open = controller.createAction(\"open\")\n      .setDescription(\"Open an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(open);\n\n    WebService.NewAction close = controller.createAction(\"close\")\n      .setDescription(\"Close an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(close);\n\n    controller.done();\n  }","id":67183,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/action_plans\");\n    controller.setDescription(\"Action plans management\");\n\n    WebService.NewAction search = controller.createAction(\"search\")\n      .setDescription(\"Get a list of action plans. Requires Browse permission on project\")\n      .setSince(\"3.6\")\n      .setHandler(RailsHandler.INSTANCE)\n      .setResponseExample(Resources.getResource(this.getClass(), \"example-search.json\"));\n    addProjectParam(search);\n\n    WebService.NewAction create = controller.createAction(\"create\")\n      .setDescription(\"Create an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addNameParam(create);\n    addDescriptionParam(create);\n    addDeadLineParam(create);\n    addProjectParam(create);\n\n    WebService.NewAction update = controller.createAction(\"update\")\n      .setDescription(\"Update an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(update);\n    addNameParam(update);\n    addDescriptionParam(update);\n    addDeadLineParam(update);\n\n    WebService.NewAction delete = controller.createAction(\"delete\")\n      .setDescription(\"Delete an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(delete);\n\n    WebService.NewAction open = controller.createAction(\"open\")\n      .setDescription(\"Open an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(open);\n\n    WebService.NewAction close = controller.createAction(\"close\")\n      .setDescription(\"Close an action plan. Requires Administer permission on project\")\n      .setSince(\"3.6\")\n      .setPost(true)\n      .setHandler(RailsHandler.INSTANCE);\n    addKeyParam(close);\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"activate_rule\")\n      .setHandler(this)\n      .setPost(true)\n      .setSince(\"4.4\");\n\n    action.createParam(\"profile_lang\")\n      .setRequired(true);\n\n    action.createParam(\"profile_name\")\n      .setRequired(true);\n\n    action.createParam(\"rule_repo\")\n      .setRequired(true);\n\n    action.createParam(\"rule_key\")\n      .setRequired(true);\n\n    action.createParam(\"severity\")\n      .setPossibleValues(Severity.ALL);\n\n    action.createParam(\"params\");\n  }","id":67184,"modified_method":"void define(WebService.NewController controller) {\n    WebService.NewAction action = controller\n      .createAction(\"activate_rule\")\n      .setDescription(\"Activate a rule on a Quality profile\")\n      .setHandler(this)\n      .setPost(true)\n      .setSince(\"4.4\");\n\n    action.createParam(\"profile_lang\")\n      .setDescription(\"Profile language\")\n      .setRequired(true)\n      .setExampleValue(\"java\");\n\n    action.createParam(\"profile_name\")\n      .setDescription(\"Profile name\")\n      .setRequired(true)\n      .setExampleValue(\"My profile\");\n\n    action.createParam(\"rule_repo\")\n      .setDescription(\"Rule repository\")\n      .setRequired(true)\n      .setExampleValue(\"squid\");\n\n    action.createParam(\"rule_key\")\n      .setDescription(\"Rule key\")\n      .setRequired(true)\n      .setExampleValue(\"AvoidCycles\");\n\n    action.createParam(\"severity\")\n      .setDescription(\"Severity\")\n      .setPossibleValues(Severity.ALL);\n\n    action.createParam(\"params\")\n      .setDescription(\"Parameters\");\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"batch\");\n    controller.createAction(\"index\")\n      .setInternal(true)\n      .setDescription(\"List the JAR files to be downloaded by source analyzer\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          index(response);\n        }\n      }).setResponseExample(getClass().getResource(\"example-batch-index.txt\"));\n    controller.createAction(\"file\")\n      .setInternal(true)\n      .setDescription(\"Download a JAR file required by source analyzer\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          file(request, response);\n        }\n      }).createParam(\"name\")\n        .setDescription(\"File name\")\n        .setExampleValue(\"batch-library-2.3.jar\");\n\n    controller.done();\n  }","id":67185,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"batch\")\n      .setSince(\"4.4\")\n      .setDescription(\"Get JAR files for batch\");\n    controller.createAction(\"index\")\n      .setInternal(true)\n      .setDescription(\"List the JAR files to be downloaded by source analyzer\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          index(response);\n        }\n      }).setResponseExample(getClass().getResource(\"example-batch-index.txt\"));\n    controller.createAction(\"file\")\n      .setInternal(true)\n      .setDescription(\"Download a JAR file required by source analyzer\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          file(request, response);\n        }\n      }).createParam(\"name\")\n        .setDescription(\"File name\")\n        .setExampleValue(\"batch-library-2.3.jar\");\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/issue_filters\")\n      .setSince(\"4.2\")\n      .setDescription(\"Issue Filters\");\n    appAction.define(controller);\n    showAction.define(controller);\n    favoritesAction.define(controller);\n    controller.done();\n  }","id":67186,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/issue_filters\")\n      .setSince(\"4.2\")\n      .setDescription(\"Issue Filters management\");\n    appAction.define(controller);\n    showAction.define(controller);\n    favoritesAction.define(controller);\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineResponseExample(final Context context, NewController controller) {\n    NewAction action = controller\n      .createAction(\"response_example\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) throws Exception {\n          Controller controller = context.controller(request.mandatoryParam(\"controller\"));\n          Action action = controller.action(request.mandatoryParam(\"action\"));\n          handleResponseExample(action, response);\n        }\n      });\n    action.createParam(\"controller\").setRequired(true);\n    action.createParam(\"action\").setRequired(true);\n  }","id":67187,"modified_method":"private void defineResponseExample(final Context context, NewController controller) {\n    NewAction action = controller\n      .createAction(\"response_example\")\n      .setDescription(\"Display web service response example\")\n      .setSince(\"4.4\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) throws Exception {\n          Controller controller = context.controller(request.mandatoryParam(\"controller\"));\n          Action action = controller.action(request.mandatoryParam(\"action\"));\n          handleResponseExample(action, response);\n        }\n      });\n    action.createParam(\"controller\")\n      .setRequired(true)\n      .setDescription(\"Controller of the web service\")\n      .setExampleValue(\"api/issues\");\n    action.createParam(\"action\")\n      .setRequired(true)\n      .setDescription(\"Action of the web service\")\n      .setExampleValue(\"search\");\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void defineList(final Context context, NewController controller) {\n    NewAction action = controller\n      .createAction(\"list\")\n      .setSince(\"4.2\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          handleList(context.controllers(), request, response);\n        }\n      });\n    action\n      .createParam(\"include_internals\")\n      .setDescription(\"Include web services that are implemented for internal use only. Their forward-compatibility is \" +\n        \"not assured\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"false\");\n  }","id":67188,"modified_method":"private void defineList(final Context context, NewController controller) {\n    NewAction action = controller\n      .createAction(\"list\")\n      .setSince(\"4.2\")\n      .setDescription(\"List web services\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          handleList(context.controllers(), request, response);\n        }\n      });\n    action\n      .createParam(\"include_internals\")\n      .setDescription(\"Include web services that are implemented for internal use only. Their forward-compatibility is \" +\n        \"not assured\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"false\");\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(final Context context) {\n    NewController controller = context\n      .createController(\"api/webservices\")\n      .setDescription(\"List web services\");\n    defineList(context, controller);\n    defineResponseExample(context, controller);\n    controller.done();\n  }","id":67189,"modified_method":"@Override\n  public void define(final Context context) {\n    NewController controller = context\n      .createController(\"api/webservices\")\n      .setSince(\"4.2\")\n      .setDescription(\"List web services\");\n    defineList(context, controller);\n    defineResponseExample(context, controller);\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_ws() throws Exception {\n    WsTester tester = new WsTester(ws);\n    WebService.Controller controller = tester.controller(\"api/webservices\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.path()).isEqualTo(\"api/webservices\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(2);\n\n    WebService.Action index = controller.action(\"list\");\n    assertThat(index).isNotNull();\n    assertThat(index.key()).isEqualTo(\"list\");\n    assertThat(index.handler()).isNotNull();\n    assertThat(index.since()).isEqualTo(\"4.2\");\n    assertThat(index.isPost()).isFalse();\n    assertThat(index.isInternal()).isFalse();\n\n    assertThat(controller.action(\"response_example\")).isNotNull();\n  }","id":67190,"modified_method":"@Test\n  public void define_ws() throws Exception {\n    WsTester tester = new WsTester(ws);\n    WebService.Controller controller = tester.controller(\"api/webservices\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.path()).isEqualTo(\"api/webservices\");\n    assertThat(controller.since()).isEqualTo(\"4.2\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(2);\n\n    WebService.Action index = controller.action(\"list\");\n    assertThat(index).isNotNull();\n    assertThat(index.key()).isEqualTo(\"list\");\n    assertThat(index.handler()).isNotNull();\n    assertThat(index.since()).isEqualTo(\"4.2\");\n    assertThat(index.isPost()).isFalse();\n    assertThat(index.isInternal()).isFalse();\n\n    assertThat(controller.action(\"response_example\")).isNotNull();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/profiles\")\n      .setDescription(\"Quality profiles management (implemented in Rails)\");\n\n    defineListAction(controller);\n    defineBackupAction(controller);\n    defineRestoreAction(controller);\n    defineDestroyAction(controller);\n    defineSetAsDefaultAction(controller);\n\n    controller.done();\n  }","id":67191,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/profiles\")\n      .setDescription(\"Former quality profiles web service\");\n\n    defineListAction(controller);\n    defineBackupAction(controller);\n    defineRestoreAction(controller);\n    defineDestroyAction(controller);\n    defineSetAsDefaultAction(controller);\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/resources\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n    defineSearchAction(controller);\n\n    controller.done();\n  }","id":67192,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/resources\")\n      .setDescription(\"Former components web service\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n    defineSearchAction(controller);\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_controller() throws Exception {\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNull();\n    assertThat(controller.actions()).hasSize(2);\n  }","id":67193,"modified_method":"@Test\n  public void define_controller() throws Exception {\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(2);\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/rule_tags\")\n      .setDescription(\"Rule tags\");\n\n    controller.createAction(\"list\")\n      .setDescription(\"List all available rule tags\")\n      .setSince(\"4.2\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          list(response);\n        }\n      });\n\n    controller.createAction(\"create\")\n      .setPost(true)\n      .setDescription(\"Create a new rule tag\")\n      .setSince(\"4.2\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          create(request, response);\n        }\n      })\n      .createParam(\"tag\").setDescription(\"Value of the new rule tag\");\n\n    controller.done();\n  }","id":67194,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/rule_tags\")\n      .setDescription(\"Rule tags management\");\n\n    controller.createAction(\"list\")\n      .setDescription(\"List all available rule tags\")\n      .setSince(\"4.2\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          list(response);\n        }\n      });\n\n    controller.createAction(\"create\")\n      .setPost(true)\n      .setDescription(\"Create a new rule tag\")\n      .setSince(\"4.2\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          create(request, response);\n        }\n      })\n      .createParam(\"tag\")\n      .setDescription(\"Value of the new rule tag\")\n      .setExampleValue(\"java8\");\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_ws() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/rule_tags\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.path()).isEqualTo(\"api/rule_tags\");\n    assertThat(controller.description()).isNotEmpty();\n\n    WebService.Action search = controller.action(\"list\");\n    assertThat(search).isNotNull();\n    assertThat(search.key()).isEqualTo(\"list\");\n    assertThat(search.handler()).isNotNull();\n    assertThat(search.since()).isEqualTo(\"4.2\");\n    assertThat(search.isPost()).isFalse();\n\n    WebService.Action create = controller.action(\"create\");\n    assertThat(create).isNotNull();\n    assertThat(create.key()).isEqualTo(\"create\");\n    assertThat(create.handler()).isNotNull();\n    assertThat(create.since()).isEqualTo(\"4.2\");\n    assertThat(create.isPost()).isTrue();\n    assertThat(create.params()).hasSize(1);\n    assertThat(create.param(\"tag\")).isNotNull();\n  }","id":67195,"modified_method":"@Test\n  public void define_ws() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/rule_tags\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.path()).isEqualTo(\"api/rule_tags\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(2);\n\n    WebService.Action search = controller.action(\"list\");\n    assertThat(search).isNotNull();\n    assertThat(search.key()).isEqualTo(\"list\");\n    assertThat(search.handler()).isNotNull();\n    assertThat(search.since()).isEqualTo(\"4.2\");\n    assertThat(search.isPost()).isFalse();\n\n    WebService.Action create = controller.action(\"create\");\n    assertThat(create).isNotNull();\n    assertThat(create.key()).isEqualTo(\"create\");\n    assertThat(create.handler()).isNotNull();\n    assertThat(create.since()).isEqualTo(\"4.2\");\n    assertThat(create.isPost()).isTrue();\n    assertThat(create.params()).hasSize(1);\n    assertThat(create.param(\"tag\")).isNotNull();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/server\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n    defineSetupAction(controller);\n\n    controller.done();\n  }","id":67196,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/server\")\n      .setDescription(\"Get system properties and upgrade db\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n    defineSetupAction(controller);\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_controller() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/server\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNull();\n    assertThat(controller.actions()).hasSize(2);\n  }","id":67197,"modified_method":"@Test\n  public void define_controller() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/server\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(2);\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/sources\");\n    showAction.define(controller);\n    scmAction.define(controller);\n    controller.done();\n  }","id":67198,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/sources\")\n      .setSince(\"4.2\")\n      .setDescription(\"Display sources information\");\n    showAction.define(controller);\n    scmAction.define(controller);\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_ws() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/sources\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.description()).isNull();\n\n    WebService.Action show = controller.action(\"show\");\n    assertThat(show).isNotNull();\n    assertThat(show.handler()).isSameAs(showAction);\n    assertThat(show.params()).hasSize(5);\n\n    WebService.Action scm = controller.action(\"scm\");\n    assertThat(scm).isNotNull();\n    assertThat(scm.handler()).isSameAs(scmAction);\n    assertThat(scm.params()).hasSize(4);\n  }","id":67199,"modified_method":"@Test\n  public void define_ws() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/sources\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"4.2\");\n    assertThat(controller.description()).isNotEmpty();\n\n    WebService.Action show = controller.action(\"show\");\n    assertThat(show).isNotNull();\n    assertThat(show.handler()).isSameAs(showAction);\n    assertThat(show.params()).hasSize(5);\n\n    WebService.Action scm = controller.action(\"scm\");\n    assertThat(scm).isNotNull();\n    assertThat(scm.handler()).isSameAs(scmAction);\n    assertThat(scm.params()).hasSize(4);\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/system\")\n      .setSince(\"4.3\");\n\n    restartHandler.define(controller);\n\n    controller.done();\n  }","id":67200,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/system\")\n      .setDescription(\"Restart server\")\n      .setSince(\"4.3\");\n\n    restartHandler.define(controller);\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define() throws Exception {\n    Platform platform = mock(Platform.class);\n    Settings settings = new Settings();\n    RestartHandler restartHandler = new RestartHandler(settings, platform, mock(System2.class));\n    SystemWs ws = new SystemWs(restartHandler);\n    WebService.Context context = new WebService.Context();\n\n    ws.define(context);\n\n    assertThat(context.controllers()).hasSize(1);\n    assertThat(context.controller(\"api/system\")).isNotNull();\n    assertThat(context.controller(\"api/system\").actions()).isNotEmpty();\n  }","id":67201,"modified_method":"@Test\n  public void define() throws Exception {\n    Platform platform = mock(Platform.class);\n    Settings settings = new Settings();\n    RestartHandler restartHandler = new RestartHandler(settings, platform, mock(System2.class));\n    SystemWs ws = new SystemWs(restartHandler);\n    WebService.Context context = new WebService.Context();\n\n    ws.define(context);\n\n    assertThat(context.controllers()).hasSize(1);\n    assertThat(context.controller(\"api/system\")).isNotNull();\n    assertThat(context.controller(\"api/system\").description()).isNotEmpty();\n    assertThat(context.controller(\"api/system\").since()).isEqualTo(\"4.3\");\n    assertThat(context.controller(\"api/system\").actions()).isNotEmpty();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/timemachine\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n\n    controller.done();\n  }","id":67202,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/timemachine\")\n      .setDescription(\"Get a list of past measures\")\n      .setSince(\"2.10\");\n\n    defineSystemAction(controller);\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_controller() throws Exception {\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNull();\n    assertThat(controller.actions()).hasSize(1);\n  }","id":67203,"modified_method":"@Test\n  public void define_controller() throws Exception {\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(1);\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/updatecenter\")\n      .setSince(\"2.10\");\n\n    defineInstalledPluginsAction(controller);\n\n    controller.done();\n  }","id":67204,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.createController(\"api/updatecenter\")\n      .setDescription(\"Get list of installed plugins\")\n      .setSince(\"2.10\");\n\n    defineInstalledPluginsAction(controller);\n\n    controller.done();\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_controller() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/updatecenter\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNull();\n    assertThat(controller.actions()).hasSize(1);\n  }","id":67205,"modified_method":"@Test\n  public void define_controller() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/updatecenter\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.since()).isEqualTo(\"2.10\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(1);\n  }","commit_id":"6052a6541e265922df07d6ec7fc4174fa730eef5","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n    public void testHelloWorld() throws Exception {\n        // start bundle\n        getInstalledBundle(name).start();\n\n        // must use the camel context from osgi\n        CamelContext ctx = getOsgiService(CamelContext.class, \"(camel.context.symbolicname=\" + name + \")\", 10000);\n\n        ProducerTemplate myTemplate = ctx.createProducerTemplate();\n        myTemplate.start();\n\n        // do our testing\n        MockEndpoint mock = ctx.getEndpoint(\"mock:result\", MockEndpoint.class);\n        mock.expectedMessageCount(1);\n\n        myTemplate.sendBodyAndHeader(\"file:target/foo\", \"Hello World\", Exchange.FILE_NAME, \"hello.txt\");\n\n        mock.assertIsSatisfied();\n\n        myTemplate.stop();\n    }","id":67206,"modified_method":"@Test\n    public void testHelloWorld() throws Exception {\n        // start bundle\n        getInstalledBundle(name).start();\n\n        // must use the camel context from osgi\n        CamelContext ctx = getOsgiService(CamelContext.class, \"(camel.context.symbolicname=\" + name + \")\"\n                + \"&&(camel.context.name=camel1)\", 10000);\n\n        ProducerTemplate myTemplate = ctx.createProducerTemplate();\n        myTemplate.start();\n\n        // do our testing\n        MockEndpoint mock = ctx.getEndpoint(\"mock:result\", MockEndpoint.class);\n        mock.expectedMessageCount(1);\n\n        myTemplate.sendBodyAndHeader(\"file:target/foo\", \"Hello World\", Exchange.FILE_NAME, \"hello.txt\");\n\n        mock.assertIsSatisfied();\n\n        myTemplate.stop();\n    }","commit_id":"5c54e3a3bff6bb5a068bffeb14abe1b8fed31ede","url":"https://github.com/apache/camel"},{"original_method":"public void notify(EventObject event) throws Exception {\n        if (event instanceof CamelContextStartedEvent) {\n            CamelContext context = ((CamelContextStartedEvent) event).getContext();\n\n            Properties props = new Properties();\n            props.put(CONTEXT_SYMBOLIC_NAME_PROPERTY, bundleContext.getBundle().getSymbolicName());\n            props.put(CONTEXT_VERSION_PROPERTY, getBundleVersion(bundleContext.getBundle()));\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Registering CamelContext [{}] in OSGi registry\", context.getName());\n            }\n            ServiceRegistration reg = bundleContext.registerService(CamelContext.class.getName(), context, props);\n            registrations.put(context, reg);\n        } else if (event instanceof CamelContextStoppingEvent) {\n            CamelContext context = ((CamelContextStoppingEvent) event).getContext();\n            ServiceRegistration reg = registrations.get(context);\n            if (reg != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Unregistering CamelContext [{}] from OSGi registry\", context.getName());\n                }\n                reg.unregister();\n            }\n        }\n    }","id":67207,"modified_method":"public void notify(EventObject event) throws Exception {\n        if (event instanceof CamelContextStartedEvent) {\n            CamelContext context = ((CamelContextStartedEvent) event).getContext();\n\n            Properties props = new Properties();\n            props.put(CONTEXT_SYMBOLIC_NAME_PROPERTY, bundleContext.getBundle().getSymbolicName());\n            props.put(CONTEXT_VERSION_PROPERTY, getBundleVersion(bundleContext.getBundle()));\n            props.put(CONTEXT_NAME_PROPERTY, context.getName());\n\n            log.debug(\"Registering CamelContext [{}] of in OSGi registry\", props);\n\n            ServiceRegistration reg = bundleContext.registerService(CamelContext.class.getName(), context, props);\n            registrations.put(context, reg);\n        } else if (event instanceof CamelContextStoppingEvent) {\n            CamelContext context = ((CamelContextStoppingEvent) event).getContext();\n            ServiceRegistration reg = registrations.get(context);\n            if (reg != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Unregistering CamelContext [{}] from OSGi registry\", context.getName());\n                }\n                reg.unregister();\n            }\n        }\n    }","commit_id":"5c54e3a3bff6bb5a068bffeb14abe1b8fed31ede","url":"https://github.com/apache/camel"},{"original_method":"@Override\r\n\tpublic void handleMessage(String pattern, String channel, String message) {\r\n//\t\tSystem.out.println(\"Checking message: \" + pattern + \" \" + channel + \" \" + message);\r\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.TO_MEETING_CHANNEL)) {\r\n//\t\t\tSystem.out.println(\"Meeting message: \" + channel + \" \" + message);\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof EndMeetingMessage) {\r\n\t\t\t\t\tEndMeetingMessage emm = (EndMeetingMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received end meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.endMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof CreateMeetingMessage) {\r\n\t\t\t\t\tCreateMeetingMessage emm = (CreateMeetingMessage) msg;\r\n\t\t\t\t\tbbbGW.createMeeting2(emm.id, emm.externalId, emm.name, emm.record, emm.voiceBridge, \r\n\t\t\t\t\t\t\t  emm.duration, emm.autoStartRecording, emm.allowStartStopRecording);\r\n\t\t\t\t} else if (msg instanceof RegisterUserMessage) {\r\n\t\t\t\t\tRegisterUserMessage emm = (RegisterUserMessage) msg;\r\n\t\t\t\t\tbbbGW.registerUser(emm.meetingID, emm.internalUserId, emm.fullname, emm.role, emm.externUserID, emm.authToken);\r\n\t\t\t\t} else if (msg instanceof DestroyMeetingMessage) {\r\n\t\t\t\t\tDestroyMeetingMessage emm = (DestroyMeetingMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received destroy meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.destroyMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof ValidateAuthTokenMessage) {\r\n\t\t\t\t\tValidateAuthTokenMessage emm = (ValidateAuthTokenMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received ValidateAuthTokenMessage token request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.validateAuthToken(emm.meetingId, emm.userId, emm.token, emm.replyTo);\r\n\t\t\t\t} else if (msg instanceof UserConnectedToGlobalAudio) {\r\n\t\t\t\t\tUserConnectedToGlobalAudio emm = (UserConnectedToGlobalAudio) msg;\r\n\t\t\t\t\tlog.debug(\"Received UserConnectedToGlobalAudio toekn request. user id [{}]\", emm.name);\r\n\t\t\t\t\tbbbGW.userConnectedToGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t} else if (msg instanceof UserDisconnectedFromGlobalAudio) {\r\n\t\t\t\t\tUserDisconnectedFromGlobalAudio emm = (UserDisconnectedFromGlobalAudio) msg;\r\n\t\t\t\t\tlog.debug(\"Received UserDisconnectedFromGlobalAudio toekn request. Meeting id [{}]\", emm.name);\r\n\t\t\t\t\tbbbGW.userDisconnectedFromGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (channel.equalsIgnoreCase(MessagingConstants.TO_SYSTEM_CHANNEL)) {\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof KeepAliveMessage) {\r\n\t\t\t\t\tKeepAliveMessage emm = (KeepAliveMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received KeepAliveMessage request. Meeting id [{}]\", emm.keepAliveId);\r\n\t\t\t\t\tbbbGW.isAliveAudit(emm.keepAliveId);\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":67208,"modified_method":"@Override\r\n\tpublic void handleMessage(String pattern, String channel, String message) {\r\n//\t\tSystem.out.println(\"Checking message: \" + pattern + \" \" + channel + \" \" + message);\r\n\t\tif (channel.equalsIgnoreCase(MessagingConstants.TO_MEETING_CHANNEL)) {\r\n//\t\t\tSystem.out.println(\"Meeting message: \" + channel + \" \" + message);\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof EndMeetingMessage) {\r\n\t\t\t\t\tEndMeetingMessage emm = (EndMeetingMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received end meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.endMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof CreateMeetingMessage) {\r\n\t\t\t\t\tCreateMeetingMessage emm = (CreateMeetingMessage) msg;\r\n\t\t\t\t\tbbbGW.createMeeting2(emm.id, emm.externalId, emm.name, emm.record, emm.voiceBridge, \r\n\t\t\t\t\t\t\t  emm.duration, emm.autoStartRecording, emm.allowStartStopRecording);\r\n\t\t\t\t} else if (msg instanceof RegisterUserMessage) {\r\n\t\t\t\t\tRegisterUserMessage emm = (RegisterUserMessage) msg;\r\n\t\t\t\t\tbbbGW.registerUser(emm.meetingID, emm.internalUserId, emm.fullname, emm.role, emm.externUserID, emm.authToken);\r\n\t\t\t\t} else if (msg instanceof DestroyMeetingMessage) {\r\n\t\t\t\t\tDestroyMeetingMessage emm = (DestroyMeetingMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received destroy meeting request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.destroyMeeting(emm.meetingId);\r\n\t\t\t\t} else if (msg instanceof ValidateAuthTokenMessage) {\r\n\t\t\t\t\tValidateAuthTokenMessage emm = (ValidateAuthTokenMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received ValidateAuthTokenMessage token request. Meeting id [{}]\", emm.meetingId);\r\n\t\t\t\t\tbbbGW.validateAuthToken(emm.meetingId, emm.userId, emm.token, emm.replyTo);\r\n\t\t\t\t} else if (msg instanceof UserConnectedToGlobalAudio) {\r\n\t\t\t\t\tUserConnectedToGlobalAudio emm = (UserConnectedToGlobalAudio) msg;\r\n\t\t\t\t\t\r\n\t\t\t\t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n\t\t\t\t\tlogData.put(\"voiceConf\", emm.voiceConf);\r\n\t\t\t\t\tlogData.put(\"userId\", emm.userid);\r\n\t\t\t\t\tlogData.put(\"username\", emm.name);\r\n\t\t\t\t\tlogData.put(\"event\", \"user_connected_to_global_audio\");\r\n\t\t\t\t\tlogData.put(\"description\", \"User connected to global audio.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tGson gson = new Gson();\r\n\t\t\t    String logStr =  gson.toJson(logData);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlog.info(\"User connected to global audio: data={}\", logStr);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbbbGW.userConnectedToGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t} else if (msg instanceof UserDisconnectedFromGlobalAudio) {\r\n\t\t\t\t\tUserDisconnectedFromGlobalAudio emm = (UserDisconnectedFromGlobalAudio) msg;\r\n\t\t\t\t\t\r\n\t\t\t\t\tMap<String, Object> logData = new HashMap<String, Object>();\r\n\t\t\t\t\tlogData.put(\"voiceConf\", emm.voiceConf);\r\n\t\t\t\t\tlogData.put(\"userId\", emm.userid);\r\n\t\t\t\t\tlogData.put(\"username\", emm.name);\r\n\t\t\t\t\tlogData.put(\"event\", \"user_disconnected_from_global_audio\");\r\n\t\t\t\t\tlogData.put(\"description\", \"User disconnected from global audio.\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tGson gson = new Gson();\r\n\t\t\t    String logStr =  gson.toJson(logData);\r\n\t\t\t\t\t\r\n\t\t\t\t\tlog.info(\"User disconnected from global audio: data={}\", logStr);\r\n\t\t\t\t\t\r\n\t\t\t\t\tbbbGW.userDisconnectedFromGlobalAudio(emm.voiceConf, emm.userid, emm.name);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (channel.equalsIgnoreCase(MessagingConstants.TO_SYSTEM_CHANNEL)) {\r\n\t\t\tIMessage msg = MessageFromJsonConverter.convert(message);\r\n\t\t\t\r\n\t\t\tif (msg != null) {\r\n\t\t\t\tif (msg instanceof KeepAliveMessage) {\r\n\t\t\t\t\tKeepAliveMessage emm = (KeepAliveMessage) msg;\r\n\t\t\t\t\tlog.debug(\"Received KeepAliveMessage request. Meeting id [{}]\", emm.keepAliveId);\r\n\t\t\t\t\tbbbGW.isAliveAudit(emm.keepAliveId);\t\t\t\t\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"d65fd73e682402f2322399f958159ef00973e477","url":"https://github.com/bigbluebutton/bigbluebutton"},{"original_method":"public void reset()\n    {\n        fin = false;\n        rsv1 = false;\n        rsv2 = false;\n        rsv3 = false;\n        opcode = null;\n        masked = false;\n        payloadLength = -1;\n        mask = null;\n    }","id":67209,"modified_method":"public void reset()\n    {\n        fin = false;\n        rsv1 = false;\n        rsv2 = false;\n        rsv3 = false;\n        opcode = null;\n        masked = false;\n        payloadLength = -1;\n        mask = null;\n        continuationIndex = 0;\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean parsePayload(ByteBuffer buffer)\n    {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":67210,"modified_method":"@Override\n    public boolean parsePayload(ByteBuffer buffer)\n    {\n        payloadLength = getFrame().getPayloadLength();\n        while (buffer.hasRemaining())\n        {\n            if (payload == null)\n            {\n                // TODO: buffer size limits\n                payload = ByteBuffer.allocate(payloadLength);\n            }\n\n            copyBuffer(buffer,payload,payload.remaining());\n\n            if (payload.position() >= payloadLength)\n            {\n                frame.setData(payload);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void reset()\n    {\n        super.reset();\n    }","id":67211,"modified_method":"@Override\n    public void reset()\n    {\n        super.reset();\n        payload = null;\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        StringBuilder msg = new StringBuilder();\n        msg.append(super.toString());\n        msg.append(\" statusCode=\").append(statusCode);\n        if (reason != null)\n        {\n            msg.append(\" reason=\\\"\").append(reason).append(\"\\\"\");\n        }\n\n        return msg.toString();\n    }","id":67212,"modified_method":"@Override\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"CloseFrame[\");\n        b.append(\"len=\").append(getPayloadLength());\n        b.append(\",statusCode=\").append(statusCode);\n        b.append(\",reason=\").append(reason);\n        b.append(\"]\");\n        return b.toString();\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Reset the frame and parser states\n     */\n    public void reset() {\n        // reset parser\n        state = State.PAYLOAD_LEN;\n        // reset frame\n        getFrame().reset();\n    }","id":67213,"modified_method":"/**\n     * Reset the frame and parser states\n     */\n    public void reset() {\n        // reset parser\n        state = State.PAYLOAD_LEN;\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Initialize the base framing values.\n     * \n     * @param fin\n     * @param rsv1\n     * @param rsv2\n     * @param rsv3\n     * @param opcode\n     */\n    public final void initFrame(boolean fin, boolean rsv1, boolean rsv2, boolean rsv3, OpCode opcode)\n    {\n        T frame = getFrame();\n        frame.setFin(fin);\n        frame.setRsv1(rsv1);\n        frame.setRsv2(rsv2);\n        frame.setRsv3(rsv3);\n        frame.setOpCode(opcode);\n    }","id":67214,"modified_method":"/**\n     * Initialize the base framing values.\n     * \n     * @param fin\n     * @param rsv1\n     * @param rsv2\n     * @param rsv3\n     * @param opcode\n     */\n    public final void initFrame(boolean fin, boolean rsv1, boolean rsv2, boolean rsv3, OpCode opcode)\n    {\n        T frame = newFrame();\n        frame.setFin(fin);\n        frame.setRsv1(rsv1);\n        frame.setRsv2(rsv2);\n        frame.setRsv3(rsv3);\n        frame.setOpCode(opcode);\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public Parser(WebSocketSettings settings)\n    {\n        /*\n         * TODO: Investigate addition of decompression factory similar to SPDY work in situation of negotiated deflate extension?\n         */\n\n        this.settings = settings;\n\n        reset();\n\n        parsers.put(OpCode.CONTINUATION,new ContinuationPayloadParser(settings));\n        parsers.put(OpCode.TEXT,new TextPayloadParser(settings));\n        parsers.put(OpCode.BINARY,new BinaryPayloadParser(settings));\n        parsers.put(OpCode.CLOSE,new ClosePayloadParser(settings));\n        parsers.put(OpCode.PING,new PingPayloadParser(settings));\n        parsers.put(OpCode.PONG,new PongPayloadParser(settings));\n    }","id":67215,"modified_method":"public Parser(WebSocketSettings settings)\n    {\n        /*\n         * TODO: Investigate addition of decompression factory similar to SPDY work in situation of negotiated deflate extension?\n         */\n\n        this.settings = settings;\n\n        reset();\n\n        parsers.put(OpCode.TEXT,new TextPayloadParser(settings));\n        parsers.put(OpCode.BINARY,new BinaryPayloadParser(settings));\n        parsers.put(OpCode.CLOSE,new ClosePayloadParser(settings));\n        parsers.put(OpCode.PING,new PingPayloadParser(settings));\n        parsers.put(OpCode.PONG,new PongPayloadParser(settings));\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void parse(ByteBuffer buffer)\n    {\n        try {\n            LOG.debug(\"Parsing {} bytes\",buffer.remaining());\n            while (buffer.hasRemaining())\n            {\n                switch (state)\n                {\n                    case FINOP:\n                    {\n                        // peek at byte\n                        byte b = buffer.get();\n                        boolean fin = ((b & 0x80) != 0);\n                        boolean rsv1 = ((b & 0x40) != 0);\n                        boolean rsv2 = ((b & 0x20) != 0);\n                        boolean rsv3 = ((b & 0x10) != 0);\n                        OpCode opcode = OpCode.from((byte)(b & 0x0F));\n\n                        if (opcode.isControlFrame() && !fin)\n                        {\n                            throw new WebSocketException(\"Fragmented Control Frame [\" + opcode.name() + \"]\");\n                        }\n\n                        if (parser == null)\n                        {\n                            // Establish specific type parser and hand off to them.\n                            parser = parsers.get(opcode);\n                            parser.reset();\n                            parser.initFrame(fin,rsv1,rsv2,rsv3,opcode);\n                        }\n\n                        state = State.BASE_FRAMING;\n                        break;\n                    }\n                    case BASE_FRAMING:\n                    {\n                        if (parser.parseBaseFraming(buffer))\n                        {\n                            state = State.PAYLOAD;\n                        }\n                        break;\n                    }\n                    case PAYLOAD:\n                    {\n                        if (parser.parsePayload(buffer))\n                        {\n                            notifyFrame(parser.getFrame());\n                            reset();\n                            state = State.FINOP;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        catch (WebSocketException e)\n        {\n            notifyWebSocketException(e);\n        } catch(Throwable t) {\n            notifyWebSocketException(new WebSocketException(t));\n        }\n        finally {\n            // Be sure to consume after exceptions\n            buffer.position(buffer.limit());\n        }\n    }","id":67216,"modified_method":"public void parse(ByteBuffer buffer)\n    {\n        try\n        {\n            LOG.debug(\"Parsing {} bytes\",buffer.remaining());\n            while (buffer.hasRemaining())\n            {\n                switch (state)\n                {\n                    case FINOP:\n                    {\n                        // peek at byte\n                        byte b = buffer.get();\n                        boolean fin = ((b & 0x80) != 0);\n                        boolean rsv1 = ((b & 0x40) != 0);\n                        boolean rsv2 = ((b & 0x20) != 0);\n                        boolean rsv3 = ((b & 0x10) != 0);\n                        OpCode opcode = OpCode.from((byte)(b & 0x0F));\n\n                        if (opcode.isControlFrame() && !fin)\n                        {\n                            throw new WebSocketException(\"Fragmented Control Frame [\" + opcode.name() + \"]\");\n                        }\n\n                        if (opcode == OpCode.CONTINUATION)\n                        {\n                            if (parser == null)\n                            {\n                                throw new WebSocketException(\"Fragment continuation frame without prior !FIN\");\n                            }\n\n                            currentContinuationIndex++;\n                        }\n\n                        if (parser == null)\n                        {\n                            // Establish specific type parser and hand off to them.\n                            parser = parsers.get(opcode);\n                        }\n                        parser.reset();\n                        parser.initFrame(fin,rsv1,rsv2,rsv3,opcode);\n                        parser.getFrame().setContinuationIndex(currentContinuationIndex);\n\n                        state = State.BASE_FRAMING;\n                        break;\n                    }\n                    case BASE_FRAMING:\n                    {\n                        if (parser.parseBaseFraming(buffer))\n                        {\n                            state = State.PAYLOAD;\n                        }\n                        break;\n                    }\n                    case PAYLOAD:\n                    {\n                        if (parser.parsePayload(buffer))\n                        {\n                            notifyFrame(parser.getFrame());\n                            parser.reset();\n                            if (parser.getFrame().isFin())\n                            {\n                                currentContinuationIndex = 0;\n                                reset();\n                            }\n                            state = State.FINOP;\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        catch (WebSocketException e)\n        {\n            notifyWebSocketException(e);\n        }\n        catch (Throwable t)\n        {\n            notifyWebSocketException(new WebSocketException(t));\n        }\n        finally\n        {\n            // Be sure to consume after exceptions\n            buffer.position(buffer.limit());\n        }\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        return String.format(\"%s ping, has-payload=%b\",super.toString(),hasPayload());\n    }","id":67217,"modified_method":"@Override\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"PingFrame[\");\n        b.append(\"len=\").append(getPayloadLength());\n        if (hasPayload())\n        {\n            b.append(\",payload=\");\n            b.append(BufferUtil.toSummaryString(getPayload()));\n        }\n        else\n        {\n            b.append(\",no-payload\");\n        }\n        b.append(\"]\");\n        return b.toString();\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testBasicPingParsing()\n    {\n        ByteBuffer buf = ByteBuffer.allocate(16);\n        buf.put(new byte[]\n                { (byte)0x89, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f });\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(PingFrame.class,1);\n        PingFrame ping = (PingFrame)capture.getFrames().get(0);\n        ByteBufferAssert.assertEquals(\"PingFrame.payload\",\"Hello\",ping.getPayload());\n    }","id":67218,"modified_method":"@Test\n    public void testBasicPingParsing()\n    {\n        Debug.enableDebugLogging(Parser.class);\n\n        ByteBuffer buf = ByteBuffer.allocate(16);\n        buf.put(new byte[]\n                { (byte)0x89, 0x05, 0x48, 0x65, 0x6c, 0x6c, 0x6f });\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(PingFrame.class,1);\n        PingFrame ping = (PingFrame)capture.getFrames().get(0);\n        ByteBufferAssert.assertEquals(\"PingFrame.payload\",\"Hello\",ping.getPayload());\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        return String.format(\"%s pong, payload=%s\",super.toString(), hasPayload());\n    }","id":67219,"modified_method":"@Override\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        b.append(\"PongFrame[\");\n        b.append(\"len=\").append(getPayloadLength());\n        if (hasPayload())\n        {\n            b.append(\",payload=\");\n            b.append(BufferUtil.toSummaryString(getPayload()));\n        }\n        else\n        {\n            b.append(\",no-payload\");\n        }\n        b.append(\"]\");\n        return b.toString();\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public boolean parsePayload(ByteBuffer buffer)\n    {\n        // TODO Auto-generated method stub\n        return false;\n    }","id":67220,"modified_method":"@Override\n    public boolean parsePayload(ByteBuffer buffer)\n    {\n        payloadLength = getFrame().getPayloadLength();\n        while (buffer.hasRemaining())\n        {\n            if (payload == null)\n            {\n                // TODO: buffer size limits\n                payload = ByteBuffer.allocate(payloadLength);\n            }\n\n            copyBuffer(buffer,payload,payload.remaining());\n\n            if (payload.position() >= payloadLength)\n            {\n                frame.setPayload(payload);\n                return true;\n            }\n        }\n        return false;\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public void reset()\n    {\n        super.reset();\n    }","id":67221,"modified_method":"@Override\n    public void reset()\n    {\n        super.reset();\n        payload = null;\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleMaskedPongRequest()\n    {\n        ByteBuffer buf = ByteBuffer.allocate(16);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // Unmasked Ping request\n        buf.put(new byte[]\n                { (byte)0x8a, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(PongFrame.class,1);\n\n        PongFrame pong = (PongFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"PongFrame.data\",pong.getPayload().toString(),is(\"Hello\"));\n    }","id":67222,"modified_method":"@Test\n    public void testSingleMaskedPongRequest()\n    {\n        ByteBuffer buf = ByteBuffer.allocate(16);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // Unmasked Ping request\n        buf.put(new byte[]\n                { (byte)0x8a, (byte)0x85, 0x37, (byte)0xfa, 0x21, 0x3d, 0x7f, (byte)0x9f, 0x4d, 0x51, 0x58 });\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(PongFrame.class,1);\n\n        PongFrame pong = (PongFrame)capture.getFrames().get(0);\n        ByteBufferAssert.assertEquals(\"PongFrame.payload\",\"Hello\",pong.getPayload());\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmasked64KByteBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        ByteBuffer buf = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64 Kbytes binary message in a single unmasked frame\n        buf.put(new byte[]\n                { (byte)0x82, 0x7F });\n        buf.putInt(dataSize);\n        for (int i = 0; i < dataSize; i++)\n        {\n            buf.put((byte)0x77);\n        }\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(BinaryFrame.class,1);\n\n        BinaryFrame bin = (BinaryFrame)capture.getFrames().get(0);\n        byte data[] = new byte[bin.getPayloadLength()];\n        bin.getData().get(data,0,dataSize);\n        Assert.assertThat(\"BinaryFrame.data\",data.length,is(dataSize));\n    }","id":67223,"modified_method":"@Test\n    public void testSingleUnmasked64KByteBinaryMessage()\n    {\n        int dataSize = 1024 * 64;\n\n        ByteBuffer buf = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 64 Kbytes binary message in a single unmasked frame\n        buf.put(new byte[]\n                { (byte)0x82, 0x7F });\n        buf.putInt(dataSize);\n        for (int i = 0; i < dataSize; i++)\n        {\n            buf.put((byte)0x77);\n        }\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(BinaryFrame.class,1);\n\n        BinaryFrame bin = (BinaryFrame)capture.getFrames().get(0);\n        bin.getData().flip();\n\n        Assert.assertThat(\"BinaryFrame.payloadLength\",bin.getPayloadLength(),is(dataSize));\n        ByteBufferAssert.assertSize(\"BinaryFrame.payload\",dataSize,bin.getData());\n\n        ByteBuffer data = bin.getData();\n        for (int i = dataSize; i > 0; i--)\n        {\n            Assert.assertThat(\"BinaryFrame.data[\" + i + \"]\",data.get(),is((byte)0x77));\n        }\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testFragmentedUnmaskedTextMessage()\n    {\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        ByteBuffer buf = ByteBuffer.allocate(16);\n\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // A fragmented unmasked text message (part 1 of 2 \"Hel\")\n        buf.put(new byte[]\n                { (byte)0x01, (byte)0x03, 0x48, (byte)0x65, 0x6c });\n        buf.flip();\n\n        // Parse #1\n        parser.parse(buf);\n\n        // part 2 of 2 \"lo\"\n        buf.flip();\n        buf.put(new byte[]\n                { (byte)0x80, 0x02, 0x6c, 0x6f });\n        buf.flip();\n\n        // Parse #2\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,2);\n\n        TextFrame txt = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame[0].data\",txt.getData().toString(),is(\"Hel\"));\n        txt = (TextFrame)capture.getFrames().get(1);\n        Assert.assertThat(\"TextFrame[1].data\",txt.getData().toString(),is(\"lo\"));\n    }","id":67224,"modified_method":"@Test\n    public void testFragmentedUnmaskedTextMessage()\n    {\n        Debug.enableDebugLogging(Parser.class);\n        Debug.enableDebugLogging(FrameParser.class);\n        Debug.enableDebugLogging(TextPayloadParser.class);\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n\n        ByteBuffer buf = ByteBuffer.allocate(16);\n\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // A fragmented unmasked text message (part 1 of 2 \"Hel\")\n        buf.put(new byte[]\n                { (byte)0x01, (byte)0x03, 0x48, (byte)0x65, 0x6c });\n        buf.flip();\n\n        // Parse #1\n        parser.parse(buf);\n\n        // part 2 of 2 \"lo\" (A continuation frame of the prior text message)\n        buf.flip();\n        buf.put(new byte[]\n                { (byte)0x80, 0x02, 0x6c, 0x6f });\n        buf.flip();\n\n        // Parse #2\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(TextFrame.class,2);\n\n        TextFrame txt = (TextFrame)capture.getFrames().get(0);\n        Assert.assertThat(\"TextFrame[0].data\",txt.getData().toString(),is(\"Hel\"));\n        txt = (TextFrame)capture.getFrames().get(1);\n        Assert.assertThat(\"TextFrame[1].data\",txt.getData().toString(),is(\"lo\"));\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        ByteBuffer buf = ByteBuffer.allocate(300);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        buf.put(new byte[]\n                { (byte)0x82, 0x7E });\n        buf.putShort((short)0x01_00);\n        for (int i = 0; i < 256; i++)\n        {\n            buf.put((byte)0x44);\n        }\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(BinaryFrame.class,1);\n\n        BinaryFrame bin = (BinaryFrame)capture.getFrames().get(0);\n        byte data[] = new byte[bin.getPayloadLength()];\n        bin.getData().get(data,0,256);\n        Assert.assertThat(\"BinaryFrame.data\",data.length,is(256));\n    }","id":67225,"modified_method":"@Test\n    public void testSingleUnmasked256ByteBinaryMessage()\n    {\n        int dataSize = 256;\n\n        ByteBuffer buf = ByteBuffer.allocate(dataSize + 10);\n        // Raw bytes as found in RFC 6455, Section 5.7 - Examples\n        // 256 bytes binary message in a single unmasked frame\n        buf.put(new byte[]\n                { (byte)0x82, 0x7E });\n        buf.putShort((short)0x01_00);\n        for (int i = 0; i < dataSize; i++)\n        {\n            buf.put((byte)0x44);\n        }\n        buf.flip();\n\n        Parser parser = new Parser();\n        FrameParseCapture capture = new FrameParseCapture();\n        parser.addListener(capture);\n        parser.parse(buf);\n\n        capture.assertNoErrors();\n        capture.assertHasFrame(BinaryFrame.class,1);\n\n        BinaryFrame bin = (BinaryFrame)capture.getFrames().get(0);\n        bin.getData().flip();\n\n        Assert.assertThat(\"BinaryFrame.payloadLength\",bin.getPayloadLength(),is(dataSize));\n        ByteBufferAssert.assertSize(\"BinaryFrame.payload\",dataSize,bin.getData());\n\n        ByteBuffer data = bin.getData();\n        for (int i = dataSize; i > 0; i--)\n        {\n            Assert.assertThat(\"BinaryFrame.data[\" + i + \"]\",data.get(),is((byte)0x44));\n        }\n    }","commit_id":"4fd00431d55e405ad88e5fc01b92c845d77b009d","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public ByteBuffer generate(int bufferSize, WebSocketFrame frame)\n    {\n        LOG.debug(String.format(\"Generate.Frame[opcode=%s,fin=%b,cont=%b,rsv1=%b,rsv2=%b,rsv3=%b,mask=%b,plength=%d]\",frame.getOpCode().toString(),\n                frame.isFin(),frame.isContinuation(),frame.isRsv1(),frame.isRsv2(),frame.isRsv3(),frame.isMasked(),frame.getPayloadLength()));\n\n        assertFrameValid(frame);\n\n        /*\n         * prepare the byte buffer to put frame into\n         */\n        ByteBuffer buffer = bufferPool.acquire(bufferSize,true);\n        BufferUtil.clearToFill(buffer);\n\n        /*\n         * start the generation process\n         */\n        byte b;\n\n        // Setup fin thru opcode\n        b = 0x00;\n        if (frame.isFin())\n        {\n            b |= 0x80; // 1000_0000\n        }\n        if (frame.isRsv1())\n        {\n            b |= 0x40; // 0100_0000\n        }\n        if (frame.isRsv2())\n        {\n            b |= 0x20; // 0010_0000\n        }\n        if (frame.isRsv3())\n        {\n            b |= 0x10;\n        }\n\n        byte opcode = frame.getOpCode().getCode();\n\n        if (frame.isContinuation())\n        {\n            // Continuations are not the same OPCODE\n            opcode = OpCode.CONTINUATION.getCode();\n        }\n\n        b |= opcode & 0x0F;\n\n        buffer.put(b);\n\n        // is masked\n        b = 0x00;\n        b |= (frame.isMasked()?0x80:0x00);\n\n        // payload lengths\n        int payloadLength = frame.getPayloadLength();\n\n        /*\n         * if length is over 65535 then its a 7 + 64 bit length\n         */\n        if (payloadLength > 0xFF_FF)\n        {\n            // we have a 64 bit length\n            b |= 0x7F;\n            buffer.put(b); // indicate 8 byte length\n            buffer.put((byte)0); //\n            buffer.put((byte)0); // anything over an\n            buffer.put((byte)0); // int is just\n            buffer.put((byte)0); // intsane!\n            buffer.put((byte)((payloadLength >> 24) & 0xFF));\n            buffer.put((byte)((payloadLength >> 16) & 0xFF));\n            buffer.put((byte)((payloadLength >> 8) & 0xFF));\n            buffer.put((byte)(payloadLength & 0xFF));\n        }\n        /*\n         * if payload is ge 126 we have a 7 + 16 bit length\n         */\n        else if (payloadLength >= 0x7E)\n        {\n            b |= 0x7E;\n            buffer.put(b); // indicate 2 byte length\n            buffer.put((byte)(payloadLength >> 8));\n            buffer.put((byte)(payloadLength & 0xFF));\n        }\n        /*\n         * we have a 7 bit length\n         */\n        else\n        {\n            b |= (payloadLength & 0x7F);\n            buffer.put(b);\n        }\n\n        // masking key\n        if (frame.isMasked())\n        {\n            buffer.put(frame.getMask());\n        }\n\n        // remember the position\n        int positionPrePayload = buffer.position();\n\n        // copy payload\n        if (frame.hasPayload())\n        {\n            buffer.put(frame.getPayload());\n        }\n\n        int positionPostPayload = buffer.position();\n\n        // mask it if needed\n        if (frame.isMasked())\n        {\n            // move back to remembered position.\n            int size = positionPostPayload - positionPrePayload;\n            byte[] mask = frame.getMask();\n            int pos;\n            for (int i = 0; i < size; i++)\n            {\n                pos = positionPrePayload + i;\n                // Mask each byte by its absolute position in the bytebuffer\n                buffer.put(pos,(byte)(buffer.get(pos) ^ mask[i % 4]));\n            }\n        }\n\n        return buffer;\n    }","id":67226,"modified_method":"public ByteBuffer generate(int bufferSize, WebSocketFrame frame)\n    {\n        if (LOG.isDebugEnabled())\n        {\n            LOG.debug(String.format(\n                    \"Generate.Frame[opcode=%s,fin=%b,cont=%b,rsv1=%b,rsv2=%b,rsv3=%b,mask=%b,plength=%d,payloadStart=%s,remaining=%d,position=%s]\",frame\n                    .getOpCode().toString(),frame.isFin(),frame.isContinuation(),frame.isRsv1(),frame.isRsv2(),frame.isRsv3(),frame.isMasked(),frame\n                    .getPayloadLength(),frame.getPayloadStart(),frame.remaining(),frame.position()));\n        }\n\n        /*\n         * prepare the byte buffer to put frame into\n         */\n        ByteBuffer buffer = bufferPool.acquire(bufferSize,true);\n        BufferUtil.clearToFill(buffer);\n\n        if (frame.remaining() == frame.getPayloadLength())\n        {\n            // we need a framing header\n            assertFrameValid(frame);\n\n            /*\n             * start the generation process\n             */\n            byte b;\n\n            // Setup fin thru opcode\n            b = 0x00;\n            if (frame.isFin())\n            {\n                b |= 0x80; // 1000_0000\n            }\n            if (frame.isRsv1())\n            {\n                b |= 0x40; // 0100_0000\n            }\n            if (frame.isRsv2())\n            {\n                b |= 0x20; // 0010_0000\n            }\n            if (frame.isRsv3())\n            {\n                b |= 0x10;\n            }\n\n            byte opcode = frame.getOpCode().getCode();\n\n            if (frame.isContinuation())\n            {\n                // Continuations are not the same OPCODE\n                opcode = OpCode.CONTINUATION.getCode();\n            }\n\n            b |= opcode & 0x0F;\n\n            buffer.put(b);\n\n            // is masked\n            b = 0x00;\n            b |= (frame.isMasked()?0x80:0x00);\n\n            // payload lengths\n            int payloadLength = frame.getPayloadLength();\n\n            /*\n             * if length is over 65535 then its a 7 + 64 bit length\n             */\n            if (payloadLength > 0xFF_FF)\n            {\n                // we have a 64 bit length\n                b |= 0x7F;\n                buffer.put(b); // indicate 8 byte length\n                buffer.put((byte)0); //\n                buffer.put((byte)0); // anything over an\n                buffer.put((byte)0); // int is just\n                buffer.put((byte)0); // intsane!\n                buffer.put((byte)((payloadLength >> 24) & 0xFF));\n                buffer.put((byte)((payloadLength >> 16) & 0xFF));\n                buffer.put((byte)((payloadLength >> 8) & 0xFF));\n                buffer.put((byte)(payloadLength & 0xFF));\n            }\n            /*\n             * if payload is ge 126 we have a 7 + 16 bit length\n             */\n            else if (payloadLength >= 0x7E)\n            {\n                b |= 0x7E;\n                buffer.put(b); // indicate 2 byte length\n                buffer.put((byte)(payloadLength >> 8));\n                buffer.put((byte)(payloadLength & 0xFF));\n            }\n            /*\n             * we have a 7 bit length\n             */\n            else\n            {\n                b |= (payloadLength & 0x7F);\n                buffer.put(b);\n            }\n\n            // masking key\n            if (frame.isMasked())\n            {\n                buffer.put(frame.getMask());\n            }\n        }\n\n        // copy payload\n        if (frame.hasPayload())\n        {\n            // remember the position\n            int maskingStartPosition = buffer.position();\n\n            // remember the offset within the frame payload (for working with\n            // windowed frames that don't split on 4 byte barriers)\n            int payloadOffset = frame.getPayload().position();\n            int payloadStart = frame.getPayloadStart();\n\n            // put as much as possible into the buffer\n            BufferUtil.put(frame.getPayload(),buffer);\n\n            // mask it if needed\n            if (frame.isMasked())\n            {\n                // move back to remembered position.\n                int size = buffer.position() - maskingStartPosition;\n                byte[] mask = frame.getMask();\n                byte b;\n                int posBuf;\n                int posFrame;\n                for (int i = 0; i < size; i++)\n                {\n                    posBuf = i + maskingStartPosition;\n                    posFrame = i + (payloadOffset - payloadStart);\n\n                    // get raw byte from buffer.\n                    b = buffer.get(posBuf);\n\n                    // mask, using offset information from frame windowing.\n                    b ^= mask[posFrame % 4];\n\n                    // Mask each byte by its absolute position in the bytebuffer\n                    buffer.put(posBuf,b);\n                }\n            }\n        }\n\n        BufferUtil.flipToFlush(buffer,0);\n        return buffer;\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Test\n    public void testWindowedGenerate()\n    {\n        byte payload[] = new byte[10240];\n        Arrays.fill(payload,(byte)0x44);\n\n        WebSocketFrame frame = WebSocketFrame.binary(payload);\n\n        int totalParts = 0;\n        int totalBytes = 0;\n        int windowSize = 1024;\n        int expectedHeaderSize = 4; // TODO: correct size\n        int expectedParts = (payload.length + expectedHeaderSize) / windowSize;\n\n        Generator generator = new UnitGenerator();\n\n        boolean done = false;\n        while (!done)\n        {\n            Assert.assertThat(\"Too many parts\",totalParts,lessThan(20));\n\n            ByteBuffer buf = generator.generate(windowSize,frame);\n\n            totalBytes += buf.remaining();\n            totalParts++;\n        }\n\n        Assert.assertThat(\"Created Parts\",totalParts,is(expectedParts));\n        Assert.assertThat(\"Created Bytes\",totalBytes,is(payload.length + expectedHeaderSize));\n    }","id":67227,"modified_method":"@Test\n    public void testWindowedGenerate()\n    {\n        byte payload[] = new byte[10240];\n        Arrays.fill(payload,(byte)0x44);\n\n        WebSocketFrame frame = WebSocketFrame.binary(payload);\n\n        int totalParts = 0;\n        int totalBytes = 0;\n        int windowSize = 1024;\n        int expectedHeaderSize = 4;\n        int expectedParts = (int)Math.ceil((double)(payload.length + expectedHeaderSize) / windowSize);\n\n        Generator generator = new UnitGenerator();\n\n        boolean done = false;\n        while (!done)\n        {\n            Assert.assertThat(\"Too many parts\",totalParts,lessThan(20));\n\n            ByteBuffer buf = generator.generate(windowSize,frame);\n            // System.out.printf(\"Generated buf.limit() = %,d%n\",buf.limit());\n\n            totalBytes += buf.remaining();\n            totalParts++;\n\n            done = (frame.remaining() <= 0);\n        }\n\n        Assert.assertThat(\"Created Parts\",totalParts,is(expectedParts));\n        Assert.assertThat(\"Created Bytes\",totalBytes,is(payload.length + expectedHeaderSize));\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        if (opcode != null)\n        {\n            b.append(opcode.name());\n        }\n        else\n        {\n            b.append(\"NO-OP\");\n        }\n        b.append('[');\n        b.append(\"len=\").append(getPayloadLength());\n        b.append(\",fin=\").append(fin);\n        b.append(\",masked=\").append(masked);\n        b.append(\",continuation=\").append(continuation);\n        b.append(']');\n        return b.toString();\n    }","id":67228,"modified_method":"@Override\n    public String toString()\n    {\n        StringBuilder b = new StringBuilder();\n        if (opcode != null)\n        {\n            b.append(opcode.name());\n        }\n        else\n        {\n            b.append(\"NO-OP\");\n        }\n        b.append('[');\n        b.append(\"len=\").append(payloadLength);\n        b.append(\",fin=\").append(fin);\n        b.append(\",masked=\").append(masked);\n        b.append(\",continuation=\").append(continuation);\n        b.append(']');\n        return b.toString();\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public ByteBuffer getPayload()\n    {\n        if (data != null)\n        {\n            return data.slice();\n        }\n        else\n        {\n            return null;\n        }\n    }","id":67229,"modified_method":"/**\n     * Get the payload ByteBuffer. possible null.\n     * <p>\n     * \n     * @return A {@link ByteBuffer#slice()} of the payload buffer (to prevent modification of the buffer state). Possibly null if no payload present.\n     *         <p>\n     *         Note: this method is exposed via the immutable {@link Frame#getPayload()} method.\n     */\n    @Override\n    public ByteBuffer getPayload()\n    {\n        if (data != null)\n        {\n            return data;\n        }\n        else\n        {\n            return null;\n        }\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Set the data and payload length.\n     * \n     * @param buf\n     *            the bytebuffer to set\n     */\n    public WebSocketFrame setPayload(byte buf[])\n    {\n        if (buf == null)\n        {\n            data = null;\n            return this;\n        }\n\n        if (opcode.isControlFrame())\n        {\n            if (buf.length > WebSocketFrame.MAX_CONTROL_PAYLOAD)\n            {\n                throw new ProtocolException(\"Control Payloads can not exceed 125 bytes in length.\");\n            }\n        }\n\n        int len = buf.length;\n        data = ByteBuffer.allocate(len);\n        BufferUtil.clearToFill(data);\n        data.put(buf,0,len);\n        BufferUtil.flipToFlush(data,0);\n        return this;\n    }","id":67230,"modified_method":"/**\n     * Set the data and payload length.\n     * \n     * @param buf\n     *            the bytebuffer to set\n     */\n    public WebSocketFrame setPayload(byte buf[])\n    {\n        if (buf == null)\n        {\n            data = null;\n            return this;\n        }\n\n        if (opcode.isControlFrame())\n        {\n            if (buf.length > WebSocketFrame.MAX_CONTROL_PAYLOAD)\n            {\n                throw new ProtocolException(\"Control Payloads can not exceed 125 bytes in length.\");\n            }\n        }\n\n        data = BufferUtil.toBuffer(buf);\n        payloadStart = data.position();\n        payloadLength = data.limit();\n        return this;\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Set the data payload.\n     * <p>\n     * The provided buffer will be used as is, no copying of bytes performed.\n     * <p>\n     * The provided buffer should be flipped and ready to READ from.\n     * \n     * @param buf\n     *            the bytebuffer to set\n     */\n    public WebSocketFrame setPayload(ByteBuffer buf)\n    {\n        if (buf == null)\n        {\n            data = null;\n            return this;\n        }\n\n        if (opcode.isControlFrame())\n        {\n            if (buf.remaining() > WebSocketFrame.MAX_CONTROL_PAYLOAD)\n            {\n                throw new ProtocolException(\"Control Payloads can not exceed 125 bytes in length.\");\n            }\n        }\n\n        data = buf.slice();\n        return this;\n    }","id":67231,"modified_method":"/**\n     * Set the data payload.\n     * <p>\n     * The provided buffer will be used as is, no copying of bytes performed.\n     * <p>\n     * The provided buffer should be flipped and ready to READ from.\n     * \n     * @param buf\n     *            the bytebuffer to set\n     */\n    public WebSocketFrame setPayload(ByteBuffer buf)\n    {\n        if (buf == null)\n        {\n            data = null;\n            return this;\n        }\n\n        if (opcode.isControlFrame())\n        {\n            if (buf.remaining() > WebSocketFrame.MAX_CONTROL_PAYLOAD)\n            {\n                throw new ProtocolException(\"Control Payloads can not exceed 125 bytes in length.\");\n            }\n        }\n\n        data = buf.slice();\n        payloadStart = data.position();\n        payloadLength = data.limit();\n        return this;\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void reset()\n    {\n        fin = true;\n        rsv1 = false;\n        rsv2 = false;\n        rsv3 = false;\n        opcode = null;\n        masked = false;\n        data = null;\n        mask = null;\n        continuationIndex = 0;\n        continuation = false;\n    }","id":67232,"modified_method":"public void reset()\n    {\n        fin = true;\n        rsv1 = false;\n        rsv2 = false;\n        rsv3 = false;\n        opcode = null;\n        masked = false;\n        data = null;\n        payloadLength = 0;\n        mask = null;\n        continuationIndex = 0;\n        continuation = false;\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public int remaining()\n    {\n        if (data == null)\n        {\n            return 0;\n        }\n        return data.remaining();\n    }","id":67233,"modified_method":"/**\n     * Get the number of bytes remaining to write out to the Network ByteBuffer.\n     * <p>\n     * Used by flow control, generator and window sizing.\n     * \n     * @return the number of bytes remaining in the payload data that has not yet been written out to Network ByteBuffers.\n     */\n    public int remaining()\n    {\n        if (data == null)\n        {\n            return 0;\n        }\n        return data.remaining();\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"/**\n     * Set the data and payload length.\n     * \n     * @param buf\n     *            the bytebuffer to set\n     */\n    public WebSocketFrame setPayload(byte buf[], int offset, int len)\n    {\n        if (buf == null)\n        {\n            data = null;\n            return this;\n        }\n\n        if (opcode.isControlFrame())\n        {\n            if (len > WebSocketFrame.MAX_CONTROL_PAYLOAD)\n            {\n                throw new ProtocolException(\"Control Payloads can not exceed 125 bytes in length.\");\n            }\n        }\n\n        data = ByteBuffer.allocate(len);\n        BufferUtil.clearToFill(data);\n        data.put(buf,0,len);\n        BufferUtil.flipToFlush(data,0);\n        return this;\n    }","id":67234,"modified_method":"/**\n     * Set the data and payload length.\n     * \n     * @param buf\n     *            the bytebuffer to set\n     */\n    public WebSocketFrame setPayload(byte buf[], int offset, int len)\n    {\n        if (buf == null)\n        {\n            data = null;\n            return this;\n        }\n\n        if (opcode.isControlFrame())\n        {\n            if (len > WebSocketFrame.MAX_CONTROL_PAYLOAD)\n            {\n                throw new ProtocolException(\"Control Payloads can not exceed 125 bytes in length.\");\n            }\n        }\n\n        data = BufferUtil.toBuffer(buf,offset,len);\n        payloadStart = data.position();\n        payloadLength = data.limit();\n        return this;\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"@Override\n    public int getPayloadLength()\n    {\n        if (data == null)\n        {\n            return 0;\n        }\n        return data.remaining();\n    }","id":67235,"modified_method":"@Override\n    public int getPayloadLength()\n    {\n        if (data == null)\n        {\n            return 0;\n        }\n        return payloadLength;\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public boolean hasPayload()\n    {\n        return ((data != null) && (data.remaining() > 0));\n    }","id":67236,"modified_method":"public boolean hasPayload()\n    {\n        return ((data != null) && (payloadLength > 0));\n    }","commit_id":"58e181f463ff244e8885778c10fe6ef1f3c39982","url":"https://github.com/eclipse/jetty.project"},{"original_method":"public void spellingError(SpellCheckEvent event) {\n\t\tList<String> suggestions = new ArrayList<String>();\n\n\t\tIterator<Word> itr = event.getSuggestions().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tWord word = itr.next();\n\n\t\t\tsuggestions.add(word.getWord());\n\t\t}\n\n\t\tint pos = event.getWordContextPosition();\n\n\t\tif (pos >= 0) {\n\t\t\tif ((pos == 0) ||\n\t\t\t\t((pos > 0) &&\n\t\t\t\t //(_text.charAt(pos - 1) != '<') &&\n\t\t\t\t (!_isInsideHtmlTag(pos)) &&\n\t\t\t\t (_text.charAt(pos - 1) != '&') &&\n\t\t\t\t (event.getInvalidWord().length() > 1))) {\n\n\t\t\t\t_invalidWords.add(\n\t\t\t\t\tnew InvalidWord(\n\t\t\t\t\t\tevent.getInvalidWord(), suggestions,\n\t\t\t\t\t\tevent.getWordContext(), pos));\n\t\t\t}\n\t\t}\n\t}","id":67237,"modified_method":"public void spellingError(SpellCheckEvent event) {\n\t\tList<String> suggestions = new ArrayList<String>();\n\t\tList<Word> words = (List<Word>)event.getSuggestions();\n\n\t\tfor(Word word : words) {\n\t\t\tsuggestions.add(word.getWord());\n\t\t}\n\n\t\tint pos = event.getWordContextPosition();\n\n\t\tif (pos >= 0) {\n\t\t\tif ((pos == 0) ||\n\t\t\t\t((pos > 0) &&\n\t\t\t\t //(_text.charAt(pos - 1) != '<') &&\n\t\t\t\t (!_isInsideHtmlTag(pos)) &&\n\t\t\t\t (_text.charAt(pos - 1) != '&') &&\n\t\t\t\t (event.getInvalidWord().length() > 1))) {\n\n\t\t\t\t_invalidWords.add(\n\t\t\t\t\tnew InvalidWord(\n\t\t\t\t\t\tevent.getInvalidWord(), suggestions,\n\t\t\t\t\t\tevent.getWordContext(), pos));\n\t\t\t}\n\t\t}\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _updateArrays() {\n\t\tList<String> keys = new ArrayList<String>();\n\t\tList<String> values = new ArrayList<String>();\n\n\t\tIterator<Map.Entry<String, String>> itr =\n\t\t\t_context.entrySet().iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tMap.Entry<String, String> entry = itr.next();\n\n\t\t\tString entryKey = entry.getKey();\n\t\t\tString entryValue = entry.getValue();\n\n\t\t\tkeys.add(\"${\" + entryKey + \"}\");\n\t\t\tvalues.add(entryValue);\n\t\t}\n\n\t\t_keys = keys.toArray(new String[keys.size()]);\n\t\t_values = values.toArray(new String[values.size()]);\n\t}","id":67238,"modified_method":"private void _updateArrays() {\n\t\tList<String> keys = new ArrayList<String>();\n\t\tList<String> values = new ArrayList<String>();\n\n\t\tfor (Map.Entry<String, String> entry : _context.entrySet()) {\n\t\t\tString entryKey = entry.getKey();\n\t\t\tString entryValue = entry.getValue();\n\n\t\t\tkeys.add(\"${\" + entryKey + \"}\");\n\t\t\tvalues.add(entryValue);\n\t\t}\n\n\t\t_keys = keys.toArray(new String[keys.size()]);\n\t\t_values = values.toArray(new String[values.size()]);\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler(_changedLines.size() * 2 + 3);\n\n\t\tsb.append(\"Line: \");\n\t\tsb.append(_lineNumber);\n\t\tsb.append(\"\\n\");\n\n\t\tIterator<String> itr = _changedLines.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tsb.append(itr.next());\n\n\t\t\tif (itr.hasNext()) {\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t}\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":67239,"modified_method":"@Override\n\tpublic String toString() {\n\t\tStringBundler sb = new StringBundler(_changedLines.size() * 2 + 3);\n\n\t\tsb.append(\"Line: \");\n\t\tsb.append(_lineNumber);\n\t\tsb.append(\"\\n\");\n\n\t\tfor(String changedLine : _changedLines) {\n\t\t\tsb.append(changedLine);\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\n\t\tif (!_changedLines.isEmpty()) {\n\t\t\tsb.setIndex(sb.index() - 1);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _toString(List<String> line) {\n\t\tif (line.isEmpty()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(line.size());\n\n\t\tIterator<String> itr = line.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tsb.append(itr.next());\n\t\t}\n\n\t\treturn sb.toString();\n\t}","id":67240,"modified_method":"private static String _toString(List<String> line) {\n\t\tif (line.isEmpty()) {\n\t\t\treturn StringPool.BLANK;\n\t\t}\n\n\t\tStringBundler sb = new StringBundler(line.size());\n\n\t\tfor (String lineElement : line) {\n\t\t\tsb.append(lineElement);\n\t\t}\n\n\t\treturn sb.toString();\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static boolean _lineDiff(\n\t\tList<DiffResult> sourceResults, List<DiffResult> targetResults,\n\t\tList<String> sourceStringList, List<String> targetStringList,\n\t\tString addedMarkerStart, String addedMarkerEnd,\n\t\tString deletedMarkerStart, String deletedMarkerEnd,\n\t\tint sourceChangedLine, int targetChangedLine, boolean aligned) {\n\n\t\tString source = sourceStringList.get(sourceChangedLine);\n\t\tString target = targetStringList.get(targetChangedLine);\n\n\t\t// Convert the lines to lists where each element are chars of the lines.\n\n\t\tList<String> sourceList = _toList(source);\n\t\tList<String> targetList = _toList(target);\n\n\t\tDiff diff = new Diff(sourceList, targetList);\n\n\t\tList<Difference> differences = diff.diff();\n\n\t\tIterator<Difference> itr = differences.iterator();\n\n\t\tint deletedChars = 0;\n\t\tint addedChars = 0;\n\n\t\t// The following while loop will calculate how many characters of\n\t\t// the source line need to be changed to be equals to the target line.\n\n\t\twhile (itr.hasNext() && !aligned) {\n\t\t\tDifference difference = itr.next();\n\n\t\t\tif (difference.getDeletedEnd() != Difference.NONE) {\n\t\t\t\tdeletedChars =\n\t\t\t\t\tdeletedChars +\n\t\t\t\t\t(difference.getDeletedEnd() -\n\t\t\t\t\t\tdifference.getDeletedStart() + 1);\n\t\t\t}\n\n\t\t\tif (difference.getAddedEnd() != Difference.NONE) {\n\t\t\t\taddedChars =\n\t\t\t\t\taddedChars +\n\t\t\t\t\t(difference.getAddedEnd() - difference.getAddedStart() + 1);\n\t\t\t}\n\t\t}\n\n\t\t// If a lot of changes were needed (more than half of the source line\n\t\t// length), consider this as not aligned yet.\n\n\t\tif ((deletedChars > (sourceList.size() / 2)) ||\n\t\t\t(addedChars > sourceList.size() / 2)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\titr = differences.iterator();\n\n\t\tboolean sourceChanged = false;\n\t\tboolean targetChanged = false;\n\n\t\t// Iterate over Differences between chars of these lines.\n\n\t\twhile (itr.hasNext()) {\n\t\t\tDifference difference = itr.next();\n\n\t\t\tif (difference.getAddedEnd() == Difference.NONE) {\n\n\t\t\t\t// Chars were deleted from source only.\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\tsourceList, deletedMarkerStart, deletedMarkerEnd,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tsourceChanged = true;\n\t\t\t}\n\t\t\telse if (difference.getDeletedEnd() == Difference.NONE) {\n\n\t\t\t\t// Chars were added to target only.\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\ttargetList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\n\t\t\t\ttargetChanged = true;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Chars were both deleted and added.\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\tsourceList, deletedMarkerStart, deletedMarkerEnd,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tsourceChanged = true;\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\ttargetList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\n\t\t\t\ttargetChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (sourceChanged) {\n\t\t\tDiffResult sourceResult = new DiffResult(\n\t\t\t\tsourceChangedLine, _toString(sourceList));\n\n\t\t\tsourceResults.add(sourceResult);\n\n\t\t\tif (!targetChanged) {\n\t\t\t\tDiffResult targetResult = new DiffResult(\n\t\t\t\t\ttargetChangedLine, target);\n\n\t\t\t\ttargetResults.add(targetResult);\n\t\t\t}\n\t\t}\n\n\t\tif (targetChanged) {\n\t\t\tif (!sourceChanged) {\n\t\t\t\tDiffResult sourceResult = new DiffResult(\n\t\t\t\t\tsourceChangedLine, source);\n\n\t\t\t\tsourceResults.add(sourceResult);\n\t\t\t}\n\n\t\t\tDiffResult targetResult = new DiffResult(\n\t\t\t\ttargetChangedLine, _toString(targetList));\n\n\t\t\ttargetResults.add(targetResult);\n\t\t}\n\n\t\treturn true;\n\t}","id":67241,"modified_method":"private static boolean _lineDiff(\n\t\tList<DiffResult> sourceResults, List<DiffResult> targetResults,\n\t\tList<String> sourceStringList, List<String> targetStringList,\n\t\tString addedMarkerStart, String addedMarkerEnd,\n\t\tString deletedMarkerStart, String deletedMarkerEnd,\n\t\tint sourceChangedLine, int targetChangedLine, boolean aligned) {\n\n\t\tString source = sourceStringList.get(sourceChangedLine);\n\t\tString target = targetStringList.get(targetChangedLine);\n\n\t\t// Convert the lines to lists where each element are chars of the lines.\n\n\t\tList<String> sourceList = _toList(source);\n\t\tList<String> targetList = _toList(target);\n\n\t\tDiff diff = new Diff(sourceList, targetList);\n\n\t\tList<Difference> differences = diff.diff();\n\n\t\tint deletedChars = 0;\n\t\tint addedChars = 0;\n\n\t\t// The following while loop will calculate how many characters of\n\t\t// the source line need to be changed to be equals to the target line.\n\n\t\tif (!aligned) {\n\t\t\tfor (Difference difference : differences) {\n\t\t\t\tif (difference.getDeletedEnd() != Difference.NONE) {\n\t\t\t\t\tdeletedChars =\n\t\t\t\t\t\tdeletedChars +\n\t\t\t\t\t\t(difference.getDeletedEnd() -\n\t\t\t\t\t\t\tdifference.getDeletedStart() + 1);\n\t\t\t\t}\n\n\t\t\t\tif (difference.getAddedEnd() != Difference.NONE) {\n\t\t\t\t\taddedChars =\n\t\t\t\t\t\taddedChars +\n\t\t\t\t\t\t(difference.getAddedEnd() - difference.getAddedStart()\n\t\t\t\t\t\t\t+ 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If a lot of changes were needed (more than half of the source line\n\t\t// length), consider this as not aligned yet.\n\n\t\tif ((deletedChars > (sourceList.size() / 2)) ||\n\t\t\t(addedChars > sourceList.size() / 2)) {\n\n\t\t\treturn false;\n\t\t}\n\n\t\tboolean sourceChanged = false;\n\t\tboolean targetChanged = false;\n\n\t\t// Iterate over Differences between chars of these lines.\n\n\t\tfor(Difference difference : differences) {\n\t\t\tif (difference.getAddedEnd() == Difference.NONE) {\n\n\t\t\t\t// Chars were deleted from source only.\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\tsourceList, deletedMarkerStart, deletedMarkerEnd,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tsourceChanged = true;\n\t\t\t}\n\t\t\telse if (difference.getDeletedEnd() == Difference.NONE) {\n\n\t\t\t\t// Chars were added to target only.\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\ttargetList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\n\t\t\t\ttargetChanged = true;\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Chars were both deleted and added.\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\tsourceList, deletedMarkerStart, deletedMarkerEnd,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tsourceChanged = true;\n\n\t\t\t\t_highlightChars(\n\t\t\t\t\ttargetList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\n\t\t\t\ttargetChanged = true;\n\t\t\t}\n\t\t}\n\n\t\tif (sourceChanged) {\n\t\t\tDiffResult sourceResult = new DiffResult(\n\t\t\t\tsourceChangedLine, _toString(sourceList));\n\n\t\t\tsourceResults.add(sourceResult);\n\n\t\t\tif (!targetChanged) {\n\t\t\t\tDiffResult targetResult = new DiffResult(\n\t\t\t\t\ttargetChangedLine, target);\n\n\t\t\t\ttargetResults.add(targetResult);\n\t\t\t}\n\t\t}\n\n\t\tif (targetChanged) {\n\t\t\tif (!sourceChanged) {\n\t\t\t\tDiffResult sourceResult = new DiffResult(\n\t\t\t\t\tsourceChangedLine, source);\n\n\t\t\t\tsourceResults.add(sourceResult);\n\t\t\t}\n\n\t\t\tDiffResult targetResult = new DiffResult(\n\t\t\t\ttargetChangedLine, _toString(targetList));\n\n\t\t\ttargetResults.add(targetResult);\n\t\t}\n\n\t\treturn true;\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n\t * The main entrance of this class. This method will compare the two texts,\n\t * highlight the changes by enclosing them with markers and return a list of\n\t * <code>DiffResults<\/code>.\n\t *\n\t * @return an array containing two lists of <code>DiffResults<\/code>, the\n\t *         first element contains DiffResults related to changes in source\n\t *         and the second element to changes in target\n\t */\n\tpublic static List<DiffResult>[] diff(\n\t\tReader source, Reader target, String addedMarkerStart,\n\t\tString addedMarkerEnd, String deletedMarkerStart,\n\t\tString deletedMarkerEnd, int margin) {\n\n\t\tList<DiffResult> sourceResults = new ArrayList<DiffResult>();\n\t\tList<DiffResult> targetResults = new ArrayList<DiffResult>();\n\n\t\tList<DiffResult>[] results = new List[] {sourceResults, targetResults};\n\n\t\t// Convert the texts to Lists where each element are lines of the texts.\n\n\t\tList<String> sourceStringList = FileUtil.toList(source);\n\t\tList<String> targetStringList = FileUtil.toList(target);\n\n\t\t// Make a a Diff of these lines and iterate over their Differences.\n\n\t\tDiff diff = new Diff(sourceStringList, targetStringList);\n\n\t\tList<Difference> differences = diff.diff();\n\n\t\tIterator<Difference> itr = differences.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tDifference difference = itr.next();\n\n\t\t\tif (difference.getAddedEnd() == Difference.NONE) {\n\n\t\t\t\t// Lines were deleted from source only.\n\n\t\t\t\t_highlightLines(\n\t\t\t\t\tsourceStringList, deletedMarkerStart, deletedMarkerEnd,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tmargin = _calculateMargin(\n\t\t\t\t\tsourceResults, targetResults, difference.getDeletedStart(),\n\t\t\t\t\tdifference.getAddedStart(), margin);\n\n\t\t\t\tList<String> changedLines = _addMargins(\n\t\t\t\t\tsourceResults, sourceStringList,\n\t\t\t\t\tdifference.getDeletedStart(), margin);\n\n\t\t\t\t_addResults(\n\t\t\t\t\tsourceResults, sourceStringList, changedLines,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tchangedLines = _addMargins(\n\t\t\t\t\ttargetResults, targetStringList, difference.getAddedStart(),\n\t\t\t\t\tmargin);\n\n\t\t\t\tint deletedLines =\n\t\t\t\t\tdifference.getDeletedEnd() + 1 -\n\t\t\t\t\t\tdifference.getDeletedStart();\n\n\t\t\t\tfor (int i = 0; i < deletedLines; i++) {\n\t\t\t\t\tchangedLines.add(CONTEXT_LINE);\n\t\t\t\t}\n\n\t\t\t\tDiffResult diffResult = new DiffResult(\n\t\t\t\t\tdifference.getDeletedStart(), changedLines);\n\n\t\t\t\ttargetResults.add(diffResult);\n\t\t\t}\n\t\t\telse if (difference.getDeletedEnd() == Difference.NONE) {\n\n\t\t\t\t// Lines were added to target only.\n\n\t\t\t\t_highlightLines(\n\t\t\t\t\ttargetStringList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\n\t\t\t\tmargin = _calculateMargin(\n\t\t\t\t\tsourceResults, targetResults, difference.getDeletedStart(),\n\t\t\t\t\tdifference.getAddedStart(), margin);\n\n\t\t\t\tList<String> changedLines = _addMargins(\n\t\t\t\t\tsourceResults, sourceStringList,\n\t\t\t\t\tdifference.getDeletedStart(), margin);\n\n\t\t\t\tint addedLines =\n\t\t\t\t\tdifference.getAddedEnd() + 1 - difference.getAddedStart();\n\n\t\t\t\tfor (int i = 0; i < addedLines; i++) {\n\t\t\t\t\tchangedLines.add(CONTEXT_LINE);\n\t\t\t\t}\n\n\t\t\t\tDiffResult diffResult = new DiffResult(\n\t\t\t\t\tdifference.getAddedStart(), changedLines);\n\n\t\t\t\tsourceResults.add(diffResult);\n\n\t\t\t\tchangedLines = _addMargins(\n\t\t\t\t\ttargetResults, targetStringList, difference.getAddedStart(),\n\t\t\t\t\tmargin);\n\n\t\t\t\t_addResults(\n\t\t\t\t\ttargetResults, targetStringList, changedLines,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Lines were deleted from source and added to target at the\n\t\t\t\t// same position. It needs to check for characters differences.\n\n\t\t\t\t_checkCharDiffs(\n\t\t\t\t\tsourceResults, targetResults, sourceStringList,\n\t\t\t\t\ttargetStringList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdeletedMarkerStart, deletedMarkerEnd, difference, margin);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}","id":67242,"modified_method":"/**\n\t * The main entrance of this class. This method will compare the two texts,\n\t * highlight the changes by enclosing them with markers and return a list of\n\t * <code>DiffResults<\/code>.\n\t *\n\t * @return an array containing two lists of <code>DiffResults<\/code>, the\n\t *         first element contains DiffResults related to changes in source\n\t *         and the second element to changes in target\n\t */\n\tpublic static List<DiffResult>[] diff(\n\t\tReader source, Reader target, String addedMarkerStart,\n\t\tString addedMarkerEnd, String deletedMarkerStart,\n\t\tString deletedMarkerEnd, int margin) {\n\n\t\tList<DiffResult> sourceResults = new ArrayList<DiffResult>();\n\t\tList<DiffResult> targetResults = new ArrayList<DiffResult>();\n\n\t\tList<DiffResult>[] results = new List[] {sourceResults, targetResults};\n\n\t\t// Convert the texts to Lists where each element are lines of the texts.\n\n\t\tList<String> sourceStringList = FileUtil.toList(source);\n\t\tList<String> targetStringList = FileUtil.toList(target);\n\n\t\t// Make a a Diff of these lines and iterate over their Differences.\n\n\t\tDiff diff = new Diff(sourceStringList, targetStringList);\n\n\t\tList<Difference> differences = diff.diff();\n\n\t\tfor (Difference difference : differences) {\n\t\t\tif (difference.getAddedEnd() == Difference.NONE) {\n\n\t\t\t\t// Lines were deleted from source only.\n\n\t\t\t\t_highlightLines(\n\t\t\t\t\tsourceStringList, deletedMarkerStart, deletedMarkerEnd,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tmargin = _calculateMargin(\n\t\t\t\t\tsourceResults, targetResults, difference.getDeletedStart(),\n\t\t\t\t\tdifference.getAddedStart(), margin);\n\n\t\t\t\tList<String> changedLines = _addMargins(\n\t\t\t\t\tsourceResults, sourceStringList,\n\t\t\t\t\tdifference.getDeletedStart(), margin);\n\n\t\t\t\t_addResults(\n\t\t\t\t\tsourceResults, sourceStringList, changedLines,\n\t\t\t\t\tdifference.getDeletedStart(), difference.getDeletedEnd());\n\n\t\t\t\tchangedLines = _addMargins(\n\t\t\t\t\ttargetResults, targetStringList, difference.getAddedStart(),\n\t\t\t\t\tmargin);\n\n\t\t\t\tint deletedLines =\n\t\t\t\t\tdifference.getDeletedEnd() + 1 -\n\t\t\t\t\t\tdifference.getDeletedStart();\n\n\t\t\t\tfor (int i = 0; i < deletedLines; i++) {\n\t\t\t\t\tchangedLines.add(CONTEXT_LINE);\n\t\t\t\t}\n\n\t\t\t\tDiffResult diffResult = new DiffResult(\n\t\t\t\t\tdifference.getDeletedStart(), changedLines);\n\n\t\t\t\ttargetResults.add(diffResult);\n\t\t\t}\n\t\t\telse if (difference.getDeletedEnd() == Difference.NONE) {\n\n\t\t\t\t// Lines were added to target only.\n\n\t\t\t\t_highlightLines(\n\t\t\t\t\ttargetStringList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\n\t\t\t\tmargin = _calculateMargin(\n\t\t\t\t\tsourceResults, targetResults, difference.getDeletedStart(),\n\t\t\t\t\tdifference.getAddedStart(), margin);\n\n\t\t\t\tList<String> changedLines = _addMargins(\n\t\t\t\t\tsourceResults, sourceStringList,\n\t\t\t\t\tdifference.getDeletedStart(), margin);\n\n\t\t\t\tint addedLines =\n\t\t\t\t\tdifference.getAddedEnd() + 1 - difference.getAddedStart();\n\n\t\t\t\tfor (int i = 0; i < addedLines; i++) {\n\t\t\t\t\tchangedLines.add(CONTEXT_LINE);\n\t\t\t\t}\n\n\t\t\t\tDiffResult diffResult = new DiffResult(\n\t\t\t\t\tdifference.getAddedStart(), changedLines);\n\n\t\t\t\tsourceResults.add(diffResult);\n\n\t\t\t\tchangedLines = _addMargins(\n\t\t\t\t\ttargetResults, targetStringList, difference.getAddedStart(),\n\t\t\t\t\tmargin);\n\n\t\t\t\t_addResults(\n\t\t\t\t\ttargetResults, targetStringList, changedLines,\n\t\t\t\t\tdifference.getAddedStart(), difference.getAddedEnd());\n\t\t\t}\n\t\t\telse {\n\n\t\t\t\t// Lines were deleted from source and added to target at the\n\t\t\t\t// same position. It needs to check for characters differences.\n\n\t\t\t\t_checkCharDiffs(\n\t\t\t\t\tsourceResults, targetResults, sourceStringList,\n\t\t\t\t\ttargetStringList, addedMarkerStart, addedMarkerEnd,\n\t\t\t\t\tdeletedMarkerStart, deletedMarkerEnd, difference, margin);\n\t\t\t}\n\t\t}\n\n\t\treturn results;\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private boolean _containsObjectEqualTo(\n\t\tElement example, List<Element> list, ElementComparator comparator) {\n\n\t\tIterator<Element> itr = list.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tElement candidate = itr.next();\n\n\t\t\tif (comparator.compare(example, candidate) == 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","id":67243,"modified_method":"private boolean _containsObjectEqualTo(\n\t\tElement example, List<Element> list, ElementComparator comparator) {\n\n\t\tfor (Element candidate : list) {\n\t\t\tif (comparator.compare(example, candidate) == 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _addChildren(\n\t\tElement first, Collection<Element> childrenToJoin) {\n\n\t\tCollection<Element> clones = new Vector<Element>();\n\n\t\tIterator<Element> itr = childrenToJoin.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tclones.add((Element)itr.next().clone());\n\t\t}\n\n\t\tfirst.elements().addAll(clones);\n\n\t\t_orderChildren(first, _descriptor.getChildrenOrder(first));\n\t}","id":67244,"modified_method":"private void _addChildren(\n\t\tElement first, Collection<Element> childrenToJoin) {\n\n\t\tCollection<Element> clones = new Vector<Element>();\n\n\t\tfor (Element childToJoin : childrenToJoin) {\n\t\t\tclones.add((Element)childToJoin.clone());\n\t\t}\n\n\t\tfirst.elements().addAll(clones);\n\n\t\t_orderChildren(first, _descriptor.getChildrenOrder(first));\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private void _mergeDuplicateElements(\n\t\tElement el, ElementComparator comparator) {\n\n\t\tif (el.elements().size() > 0) {\n\t\t\tList<Element> children = el.elements();\n\n\t\t\tList<Element> originals = new ArrayList<Element>();\n\t\t\tList<Element> duplicates = new ArrayList<Element>();\n\n\t\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\t\tElement child = children.get(i);\n\n\t\t\t\tif (_containsObjectEqualTo(child, originals, comparator)) {\n\t\t\t\t\tif (_descriptor.canJoinChildren(child)) {\n\t\t\t\t\t\tElement first = _findObjectEqualTo(\n\t\t\t\t\t\t\tchild, originals, comparator);\n\n\t\t\t\t\t\tCollection<Element> childrenToJoin = child.elements();\n\n\t\t\t\t\t\t_addChildren(first, childrenToJoin);\n\t\t\t\t\t}\n\n\t\t\t\t\tduplicates.add(child);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toriginals.add(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Element duplicate : duplicates) {\n\t\t\t\tduplicate.detach();\n\t\t\t}\n\n\t\t\tIterator<Element> itr = originals.iterator();\n\n\t\t\twhile (itr.hasNext()) {\n\t\t\t\tElement child = itr.next();\n\n\t\t\t\t_mergeDuplicateElements(child, comparator);\n\t\t\t}\n\t\t}\n\t}","id":67245,"modified_method":"private void _mergeDuplicateElements(\n\t\tElement el, ElementComparator comparator) {\n\n\t\tif (el.elements().size() > 0) {\n\t\t\tList<Element> children = el.elements();\n\n\t\t\tList<Element> originals = new ArrayList<Element>();\n\t\t\tList<Element> duplicates = new ArrayList<Element>();\n\n\t\t\tfor (int i = 0; i < children.size(); i++) {\n\t\t\t\tElement child = children.get(i);\n\n\t\t\t\tif (_containsObjectEqualTo(child, originals, comparator)) {\n\t\t\t\t\tif (_descriptor.canJoinChildren(child)) {\n\t\t\t\t\t\tElement first = _findObjectEqualTo(\n\t\t\t\t\t\t\tchild, originals, comparator);\n\n\t\t\t\t\t\tCollection<Element> childrenToJoin = child.elements();\n\n\t\t\t\t\t\t_addChildren(first, childrenToJoin);\n\t\t\t\t\t}\n\n\t\t\t\t\tduplicates.add(child);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\toriginals.add(child);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (Element duplicate : duplicates) {\n\t\t\t\tduplicate.detach();\n\t\t\t}\n\n\t\t\tfor(Element child : originals) {\n\t\t\t\t_mergeDuplicateElements(child, comparator);\n\t\t\t}\n\t\t}\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private Element _findObjectEqualTo(\n\t\tElement example, List<Element> list, ElementComparator comparator) {\n\n\t\tIterator<Element> itr = list.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tElement candidate = itr.next();\n\n\t\t\tif (comparator.compare(example, candidate) == 0) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\n\t\treturn example;\n\t}","id":67246,"modified_method":"private Element _findObjectEqualTo(\n\t\tElement example, List<Element> list, ElementComparator comparator) {\n\n\t\tfor (Element candidate : list) {\n\t\t\tif (comparator.compare(example, candidate) == 0) {\n\t\t\t\treturn candidate;\n\t\t\t}\n\t\t}\n\n\t\treturn example;\n\t}","commit_id":"91fb744d834639b165e116ff2fdb8e7e9a3e2bdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * @param index a termIndex - most likely retrieved from a switchboard object.\n     * @param sort true/false -  sorts the resulting TreeSet by index.count(); <b>Warning:<\/b> this causes heavy i/o.\n     */\n    public DidYouMean(final Segment segment, final StringBuilder word0) {\n        this.resultSet = Collections.synchronizedSortedSet(new TreeSet<StringBuilder>(new headMatchingComparator(word0, WORD_LENGTH_COMPARATOR)));\n        this.word = word0;\n        this.wordLen = this.word.length();\n        this.segment = segment;\n        this.more = segment.connectedRWI() && segment.RWICount() > 0; // with RWIs connected the guessing is super-fast\n\n        // identify language\n        if (this.word.length() > 0) {\n            final char testchar = this.word.charAt(0);\n            boolean alphafound = false;\n            alphatest: for (final char[] alpha: ALPHABETS) {\n                if (isAlphabet(alpha, testchar)) {\n                    this.alphabet = new char[alpha.length];\n                    System.arraycopy(alpha, 0, this.alphabet, 0, alpha.length);\n                    alphafound = true;\n                    break alphatest;\n                }\n            }\n            if (!alphafound && testchar < 'A') {\n                this.alphabet = new char[ALPHABET_LATIN.length];\n                System.arraycopy(ALPHABET_LATIN, 0, this.alphabet, 0, ALPHABET_LATIN.length);\n                alphafound = true;\n            }\n            if (!alphafound) {\n                // generate generic alphabet using simply a character block of 256 characters\n                final int firstchar = (0xff & (testchar / 256)) * 256;\n                final int lastchar = firstchar + 255;\n                this.alphabet = new char[256];\n                // test this with /suggest.json?q=%EF%BD%84\n                for (int a = firstchar; a <= lastchar; a++) {\n                    this.alphabet[0xff & (a - firstchar)] = (char) a;\n                }\n            }\n        }\n    }","id":67247,"modified_method":"/**\n     * @param index a termIndex - most likely retrieved from a switchboard object.\n     * @param sort true/false -  sorts the resulting TreeSet by index.count(); <b>Warning:<\/b> this causes heavy i/o.\n     */\n    public DidYouMean(final Segment segment, final String word0) {\n        this.word = new StringBuilder(word0.trim());\n        this.resultSet = Collections.synchronizedSortedSet(new TreeSet<StringBuilder>(new headMatchingComparator(this.word, WORD_LENGTH_COMPARATOR)));\n        this.wordLen = this.word.length();\n        this.segment = segment;\n        this.more = segment.connectedRWI() && segment.RWICount() > 0; // with RWIs connected the guessing is super-fast\n\n        // identify language\n        if (this.word.length() > 0) {\n            char testchar = this.word.charAt(0);\n            if (testchar >= 'A' && testchar <= 'Z') testchar = (char) (testchar + 32);\n            boolean alphafound = false;\n            alphatest: for (final char[] alpha: ALPHABETS) {\n                if (isAlphabet(alpha, testchar)) {\n                    this.alphabet = new char[alpha.length];\n                    System.arraycopy(alpha, 0, this.alphabet, 0, alpha.length);\n                    alphafound = true;\n                    break alphatest;\n                }\n            }\n            if (!alphafound && testchar < 'A') {\n                this.alphabet = new char[ALPHABET_LATIN.length];\n                System.arraycopy(ALPHABET_LATIN, 0, this.alphabet, 0, ALPHABET_LATIN.length);\n                alphafound = true;\n            }\n            if (!alphafound) {\n                // generate generic alphabet using simply a character block of 256 characters\n                final int firstchar = (0xff & (testchar / 256)) * 256;\n                final int lastchar = firstchar + 255;\n                this.alphabet = new char[256];\n                // test this with /suggest.json?q=%EF%BD%84\n                for (int a = firstchar; a <= lastchar; a++) {\n                    this.alphabet[0xff & (a - firstchar)] = (char) a;\n                }\n            }\n        }\n    }","commit_id":"6578ff3ddb1c9300e311360dfa2f02a1f64c7c61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"private void test(final StringBuilder s) {\n        final Set<StringBuilder> libr = LibraryProvider.dymLib.recommend(s);\n        libr.addAll(LibraryProvider.geoLoc.recommend(s));\n        for (final StringBuilder t: libr) {\n            if (t.length() >= MinimumOutputWordLength) this.resultSet.add(t);\n        }\n        if (s.length() >= MinimumOutputWordLength) this.resultSet.add(s);\n    }","id":67248,"modified_method":"private void test(final StringBuilder s) {\n        final Set<StringBuilder> libr = LibraryProvider.dymLib.recommend(s);\n        libr.addAll(LibraryProvider.geoLoc.recommend(s));\n        for (final StringBuilder t: libr) {\n            if (t.length() >= MinimumOutputWordLength) this.resultSet.add(t);\n        }\n    }","commit_id":"6578ff3ddb1c9300e311360dfa2f02a1f64c7c61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * This method triggers the producer and consumer threads of the DidYouMean object.\n     * @param word a String with a single word\n     * @param timeout execution time in ms.\n     * @return a Set&lt;String&gt; with word variations contained in term index.\n     */\n    private SortedSet<StringBuilder> getSuggestions(final long timeout) {\n        final long startTime = System.currentTimeMillis();\n        this.timeLimit = startTime + timeout;\n        \n        Thread[] producers = null;\n        if (this.more) {\n            // create and start producers\n            // the CPU load to create the guessed words is very low, but the testing\n            // against the library may be CPU intensive. Since it is possible to test\n            // words in the library concurrently, it is a good idea to start separate threads\n            producers = new Thread[4];\n            producers[0] = new ChangingOneLetter();\n            producers[1] = new AddingOneLetter();\n            producers[2] = new DeletingOneLetter();\n            producers[3] = new ReversingTwoConsecutiveLetters();\n            for (final Thread t: producers) {\n                t.start();\n            }\n        }\n\n        test(this.word);\n        this.resultSet.addAll(getSuggestions(this.word.toString(), \"\", timeout, 10, this.segment));\n        \n        if (this.more) {\n            // finish the producer\n            for (final Thread t: producers) {\n                long wait = this.timeLimit - System.currentTimeMillis();\n                if (wait > 0) try {\n                    t.join(wait);\n                } catch (final InterruptedException e) {}\n            }\n        }\n        \n        // we don't want the given word in the result\n        this.resultSet.remove(this.word);\n        return this.resultSet;\n    }","id":67249,"modified_method":"/**\n     * This method triggers the producer and consumer threads of the DidYouMean object.\n     * @param word a String with a single word\n     * @param timeout execution time in ms.\n     * @return a Set&lt;String&gt; with word variations contained in term index.\n     */\n    private Collection<StringBuilder> getSuggestions(final long timeout) {\n        final long startTime = System.currentTimeMillis();\n        this.timeLimit = startTime + timeout;\n        \n        Thread[] producers = null;\n        if (this.more) {\n            // create and start producers\n            // the CPU load to create the guessed words is very low, but the testing\n            // against the library may be CPU intensive. Since it is possible to test\n            // words in the library concurrently, it is a good idea to start separate threads\n            producers = new Thread[4];\n            producers[0] = new ChangingOneLetter();\n            producers[1] = new AddingOneLetter();\n            producers[2] = new DeletingOneLetter();\n            producers[3] = new ReversingTwoConsecutiveLetters();\n            for (final Thread t: producers) {\n                t.start();\n            }\n        }\n\n        test(this.word);\n        this.resultSet.addAll(getSuggestions(\"\", this.word.toString(), timeout, 10, this.segment));\n        \n        if (this.more) {\n            // finish the producer\n            for (final Thread t: producers) {\n                long wait = this.timeLimit - System.currentTimeMillis();\n                if (wait > 0) try {\n                    t.join(wait);\n                } catch (final InterruptedException e) {}\n            }\n        }\n        \n        // we don't want the given word in the result\n        this.resultSet.remove(this.word);\n        return this.resultSet;\n    }","commit_id":"6578ff3ddb1c9300e311360dfa2f02a1f64c7c61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * return a string that is a suggestion list for the list of given words\n     * @param head - the sequence of words before the last space in the sequence\n     * @param tail - the word after the last space, possibly empty\n     * @param timeout\n     * @param preSortSelection\n     * @return\n     */\n    private static Collection<StringBuilder> getSuggestions(final String head, final String tail, final long timeout, final int preSortSelection, final Segment segment) {\n        final SortedSet<StringBuilder> result = new TreeSet<StringBuilder>(StringBuilderComparator.CASE_INSENSITIVE_ORDER);\n        int count = 30;\n        final SolrQuery solrQuery = new SolrQuery();\n        solrQuery.setParam(\"defType\", \"edismax\");\n        solrQuery.setFacet(false);\n        solrQuery.setQuery(CollectionSchema.title.getSolrFieldName() + \":\\\"\" + head + \"\\\"^10 OR \" + CollectionSchema.text_t.getSolrFieldName() + \":\\\"\" + head + \"\\\"\" + (tail.length() == 0 ? \"\" : CollectionSchema.text_t.getSolrFieldName() + \":\\\"\" + head + \" \" + tail + \"\\\"\"));\n        solrQuery.setStart(0);\n        solrQuery.setRows(count);\n        solrQuery.setHighlight(true);\n        solrQuery.setHighlightFragsize(head.length() + tail.length() + 80);\n        solrQuery.setHighlightSimplePre(\"<b>\");\n        solrQuery.setHighlightSimplePost(\"<\/b>\");\n        solrQuery.setHighlightSnippets(1);\n        solrQuery.addHighlightField(CollectionSchema.title.getSolrFieldName());\n        solrQuery.addHighlightField(CollectionSchema.text_t.getSolrFieldName());\n        solrQuery.setFields(); // no fields wanted! only snippets\n        OrderedScoreMap<String> snippets = new OrderedScoreMap<String>(null);\n        try {\n            QueryResponse response = segment.fulltext().getDefaultConnector().getResponseByParams(solrQuery);\n            Map<String, Map<String, List<String>>> rawsnippets = response.getHighlighting(); // a map from the urlhash to a map with key=field and value = list of snippets\n            if (rawsnippets != null) {\n                for (Map<String, List<String>> re: rawsnippets.values()) {\n                    for (List<String> sl: re.values()) {\n                        for (String s: sl) {\n                            s = s.replaceAll(\"<\/b> <b>\", \" \");\n                            int sp = s.indexOf(\"<\/b>\");\n                            if (sp >= 0) {\n                                if (tail.length() > 0) {\n                                    if (sp - tail.length() < 0 || !s.substring(sp - tail.length(), sp).equals(tail)) continue;\n                                    s = tail + s.substring(sp + 4);\n                                } else {\n                                    s = s.substring(sp + 4);\n                                }\n                                for (int i = 0; i < s.length(); i++) {\n                                    char c = s.charAt(i);\n                                    if (c < 'A') s = s.replace(c, ' ');\n                                }\n                                s = s.trim();\n                                sp = s.indexOf(\"  \");\n                                if (sp >= 0) s = s.substring(0, sp);\n                                sp = s.indexOf(\"<b>\");\n                                if (sp >= 0) s = s.substring(0, sp).trim();\n                                String[] sx = CommonPattern.SPACE.split(s);\n                                StringBuilder sb = new StringBuilder(s.length());\n                                for (String x: sx) if (x.length() > 1 && sb.length() < 28) sb.append(x).append(' '); else break;\n                                s = sb.toString().trim();\n                                int score = count;\n                                if (s.length() > 2)  {\n                                    boolean store = true;\n                                    for (String a: snippets) {\n                                        if (a.startsWith(s)) {\n                                            snippets.inc(a, count);\n                                            store = false; // s becomes superfluous\n                                        }\n                                        if (s.startsWith(a)) {\n                                            snippets.dec(a, count); // a becomes superfluous\n                                            score += count;\n                                        }\n                                    }\n                                    if (store) snippets.inc(s, score);\n                                }\n                                count--;\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (SolrException e) {\n        } catch (IOException e) {\n        }\n        Iterator<String> si = snippets.keys(false);\n        while (si.hasNext() && result.size() < 10) {\n            String s = si.next();\n            StringBuilder sb = new StringBuilder(head.length() + s.length() + 1);\n            sb.append(head).append(' ').append(s);\n            result.add(sb);\n        }\n        return result;\n    }","id":67250,"modified_method":"/**\n     * return a string that is a suggestion list for the list of given words\n     * @param head - the sequence of words before the last space in the sequence, fixed (not to be corrected); possibly empty\n     * @param tail - the word after the last space, possibly empty or misspelled\n     * @param timeout for operation\n     * @param preSortSelection - number of suggestions to be computed\n     * @return\n     */\n    private static Collection<StringBuilder> getSuggestions(final String head, final String tail, final long timeout, final int preSortSelection, final Segment segment) {\n        final SortedSet<StringBuilder> result = new TreeSet<StringBuilder>(StringBuilderComparator.CASE_INSENSITIVE_ORDER);\n        int count = 30;\n        final SolrQuery solrQuery = new SolrQuery();\n        solrQuery.setParam(\"defType\", \"edismax\");\n        solrQuery.setFacet(false);\n        assert tail.length() > 0 && tail.indexOf(' ') < 0; // if there would be a space it should be part of head\n        String q = head.length() == 0 ? CollectionSchema.text_t.getSolrFieldName() + \":\" + tail + \"~\" : CollectionSchema.title.getSolrFieldName() + \":\\\"\" + head + \"\\\"^10 \" + CollectionSchema.text_t.getSolrFieldName() + \":(\" + head + \" \" + tail + \")~\"; // for a fuzzy search we cannot apply fuzzyness on the tail only\n        String fq = head.length() == 0 ? null : CollectionSchema.text_t.getSolrFieldName() + \":\\\"\" + head + \"\\\"\"; // in all cases (a) and (b) there must be that portion, but that is not part of the snippet that we are searching\n        solrQuery.setQuery(q);\n        if (head.length() > 0 && fq != null) solrQuery.setFilterQueries(fq);\n        solrQuery.setStart(0);\n        solrQuery.setRows(count);\n        solrQuery.setHighlight(true);\n        solrQuery.setHighlightFragsize(head.length() + tail.length() + 80);\n        solrQuery.setHighlightSimplePre(\"<b>\");\n        solrQuery.setHighlightSimplePost(\"<\/b>\");\n        solrQuery.setHighlightSnippets(1);\n        solrQuery.addHighlightField(CollectionSchema.title.getSolrFieldName());\n        solrQuery.addHighlightField(CollectionSchema.text_t.getSolrFieldName());\n        solrQuery.setFields(); // no fields wanted! only snippets\n        OrderedScoreMap<String> snippets = new OrderedScoreMap<String>(null);\n        try {\n            QueryResponse response = segment.fulltext().getDefaultConnector().getResponseByParams(solrQuery);\n            Map<String, Map<String, List<String>>> rawsnippets = response.getHighlighting(); // a map from the urlhash to a map with key=field and value = list of snippets\n            if (rawsnippets != null) {\n                for (Map<String, List<String>> re: rawsnippets.values()) {\n                    for (List<String> sl: re.values()) {\n                        for (String s: sl) {\n                            // the suggestion for the tail is in the snippet\n                            s = s.replaceAll(\"<\/b> <b>\", \" \");\n                            int snippetOpen = s.indexOf(\"<b>\");\n                            int snippetClose = s.indexOf(\"<\/b>\");\n                            if (snippetOpen >= 0 && snippetClose > snippetOpen) {\n                                String snippet = s.substring(snippetOpen + 3, snippetClose);\n                                String afterSnippet = s.substring(snippetClose + 4).trim();\n                                s = snippet + (afterSnippet.length() > 0 ? \" \" + afterSnippet : \"\");\n                                for (int i = 0; i < s.length(); i++) {char c = s.charAt(i); if (c < 'A') s = s.replace(c, ' ');} // remove funny symbols\n                                s = s.replaceAll(\"<b>\", \" \").replaceAll(\"<\/b>\", \" \").replaceAll(\"  \", \" \").trim(); // wipe superfluous whitespace\n                                String[] sx = CommonPattern.SPACE.split(s);\n                                StringBuilder sb = new StringBuilder(s.length());\n                                for (String x: sx) if (x.length() > 1 && sb.length() < 28) sb.append(x).append(' '); else break;\n                                s = sb.toString().trim();\n                                if (s.length() > 0)  snippets.inc(s, count--);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (SolrException e) {\n        } catch (IOException e) {\n        }\n        Iterator<String> si = snippets.keys(false);\n        while (si.hasNext() && result.size() < preSortSelection) {\n            result.add(new StringBuilder(si.next()));\n        }\n        return result;\n    }","commit_id":"6578ff3ddb1c9300e311360dfa2f02a1f64c7c61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\n     * get suggestions for a given word. The result is first ordered using a term size ordering,\n     * and a subset of the result is sorted again with a IO-intensive order based on the index size\n     * @param word0\n     * @param timeout\n     * @param preSortSelection the number of words that participate in the IO-intensive sort\n     * @return\n     */\n    public Collection<StringBuilder> getSuggestions(final long timeout, final int preSortSelection) {\n        if (this.word.length() < MinimumInputWordLength) {\n            return this.resultSet; // return nothing if input is too short\n        }\n        final long startTime = System.currentTimeMillis();\n        final long timelimit = startTime + timeout;\n        int lastIndexOfSpace = this.word.lastIndexOf(\" \");\n        if (lastIndexOfSpace > 0) {\n            // recursion over several words\n            return getSuggestions(this.word.substring(0, lastIndexOfSpace), this.word.substring(lastIndexOfSpace + 1), timeout, preSortSelection, this.segment);\n        }\n        final SortedSet<StringBuilder> preSorted = getSuggestions(timeout);\n        final ReversibleScoreMap<StringBuilder> scored = new ClusteredScoreMap<StringBuilder>(StringBuilderComparator.CASE_INSENSITIVE_ORDER);\n        Collection<StringBuilder> countSorted = new ArrayList<StringBuilder>();\n        if (this.more) {\n            final int wc = this.segment.getWordCountGuess(this.word.toString()); // all counts must be greater than this\n            try {\n    \t        for (final StringBuilder s: preSorted) {\n    \t            if (System.currentTimeMillis() > timelimit) break;\n    \t            if (!(scored.sizeSmaller(2 * preSortSelection))) break;\n    \t            String s0 = s.toString();\n    \t            int wcg = s0.indexOf(' ') > 0 ? s0.length() * 100 : this.segment.getWordCountGuess(s0);\n    \t            if (wcg > wc) scored.inc(s, wcg);\n    \t        }\n            } catch (final ConcurrentModificationException e) {\n            }\n            Iterator<StringBuilder> i = scored.keys(false);\n            while (i.hasNext()) countSorted.add(i.next());\n        } else {\n            try {\n                for (final StringBuilder s: preSorted) {\n                    if (StringBuilderComparator.CASE_INSENSITIVE_ORDER.startsWith(s, this.word) ||\n                        StringBuilderComparator.CASE_INSENSITIVE_ORDER.endsWith(this.word, s)) countSorted.add(s);\n                }\n            } catch (final ConcurrentModificationException e) {\n            }\n        }\n\n        // finished\n        ConcurrentLog.info(\"DidYouMean\", \"found \" + preSorted.size() + \" unsorted terms, returned \" + countSorted.size() + \" sorted suggestions; execution time: \"\n                        + (System.currentTimeMillis() - startTime) + \"ms\");\n\n        return countSorted;\n    }","id":67251,"modified_method":"/**\n     * get suggestions for a given word. The result is first ordered using a term size ordering,\n     * and a subset of the result is sorted again with a IO-intensive order based on the index size\n     * @param word0\n     * @param timeout\n     * @param preSortSelection the number of words that participate in the IO-intensive sort\n     * @return\n     */\n    public Collection<StringBuilder> getSuggestions(final long timeout, final int preSortSelection) {\n        if (this.word.length() < MinimumInputWordLength) {\n            return this.resultSet; // return nothing if input is too short\n        }\n        final long startTime = System.currentTimeMillis();\n        final long timelimit = startTime + timeout;\n        int lastIndexOfSpace = this.word.lastIndexOf(\" \");\n        final Collection<StringBuilder> preSorted;\n        if (lastIndexOfSpace > 0) {\n            // several words\n            preSorted = getSuggestions(this.word.substring(0, lastIndexOfSpace), this.word.substring(lastIndexOfSpace + 1), timeout, preSortSelection, this.segment);\n        } else {\n            preSorted = getSuggestions(timeout);\n        }\n        final ReversibleScoreMap<StringBuilder> scored = new ClusteredScoreMap<StringBuilder>(StringBuilderComparator.CASE_INSENSITIVE_ORDER);\n        LinkedHashSet<StringBuilder> countSorted = new LinkedHashSet<StringBuilder>();\n        if (this.more) {\n            final int wc = this.segment.getWordCountGuess(this.word.toString()); // all counts must be greater than this\n            try {\n    \t        for (final StringBuilder s: preSorted) {\n    \t            if (System.currentTimeMillis() > timelimit) break;\n    \t            if (!(scored.sizeSmaller(2 * preSortSelection))) break;\n    \t            String s0 = s.toString();\n    \t            int wcg = s0.indexOf(' ') > 0 ? s0.length() * 100 : this.segment.getWordCountGuess(s0);\n    \t            if (wcg > wc) scored.inc(s, wcg);\n    \t        }\n            } catch (final ConcurrentModificationException e) {\n            }\n            Iterator<StringBuilder> i = scored.keys(false);\n            while (i.hasNext()) countSorted.add(i.next());\n        } else {\n            try {\n                for (final StringBuilder s: preSorted) {\n                    if (StringBuilderComparator.CASE_INSENSITIVE_ORDER.startsWith(s, this.word) ||\n                        StringBuilderComparator.CASE_INSENSITIVE_ORDER.endsWith(this.word, s)) countSorted.add(this.word);\n                }\n                for (final StringBuilder s: preSorted) {\n                    if (!StringBuilderComparator.CASE_INSENSITIVE_ORDER.equals(s, this.word)) countSorted.add(s);\n                }\n            } catch (final ConcurrentModificationException e) {\n            }\n        }\n\n        // finished\n        ConcurrentLog.info(\"DidYouMean\", \"found \" + preSorted.size() + \" unsorted terms, returned \" + countSorted.size() + \" sorted suggestions; execution time: \"\n                        + (System.currentTimeMillis() - startTime) + \"ms\");\n\n        return countSorted;\n    }","commit_id":"6578ff3ddb1c9300e311360dfa2f02a1f64c7c61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final servletProperties prop = new servletProperties();\n\n        final String ext = header.get(\"EXT\", \"\");\n        final boolean json = ext.equals(\"json\");\n        final boolean xml = ext.equals(\"xml\");\n        \n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"q\", \"\"));\n        final String querystring =  originalquerystring.replace('+', ' ').replaceAll(\"%20\", \" \");\n        final int timeout = (post == null) ? 300 : post.getInt(\"timeout\", 300);\n        final int count = (post == null) ? 10 : Math.min(20, post.getInt(\"count\", 10));\n\n        int c = 0;\n        final DidYouMean didYouMean = new DidYouMean(sb.index, new StringBuilder(querystring));\n        final Collection<StringBuilder> suggestions = didYouMean.getSuggestions(timeout, count);\n        //[#[query]#,[#{suggestions}##[text]##(eol)#,::#(/eol)##{/suggestions}#]]\n        synchronized (suggestions) {\n            for (StringBuilder suggestion: suggestions) {\n                if (c >= meanMax) break;\n                try {\n                    String s = suggestion.toString();\n                    if (json) {\n                        prop.putJSON(\"suggestions_\" + c + \"_text\", s);\n                    } else if (xml) {\n                        prop.putXML(\"suggestions_\" + c + \"_text\", s);\n                    } else {\n                        prop.putHTML(\"suggestions_\" + c + \"_text\", s);\n                    }\n                    prop.put(\"suggestions_\" + c + \"_eol\", 0);\n                    c++;\n                } catch (final ConcurrentModificationException e) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n        }\n\n        if (c > 0) {\n            prop.put(\"suggestions_\" + (c - 1) + \"_eol\", 1);\n        }\n        prop.put(\"suggestions\", c);\n        if (json) {\n            prop.putJSON(\"query\", originalquerystring);\n        } else if (xml) {\n            prop.putXML(\"query\", originalquerystring);\n        } else {\n            prop.putHTML(\"query\", originalquerystring);\n        }\n\n        // Adding CORS Access header for xml output\n        if (xml) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // return rewrite properties\n        return prop;\n    }","id":67252,"modified_method":"public static serverObjects respond(final RequestHeader header, final serverObjects post, final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        final servletProperties prop = new servletProperties();\n\n        final String ext = header.get(\"EXT\", \"\");\n        final boolean json = ext.equals(\"json\");\n        final boolean xml = ext.equals(\"xml\");\n        \n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"q\", \"\"));\n        final String querystring =  originalquerystring.replace('+', ' ').replaceAll(\"%20\", \" \");\n        final int timeout = (post == null) ? 300 : post.getInt(\"timeout\", 300);\n        final int count = (post == null) ? 10 : Math.min(20, post.getInt(\"count\", 10));\n\n        int c = 0;\n        final DidYouMean didYouMean = new DidYouMean(sb.index, querystring);\n        final Collection<StringBuilder> suggestions = didYouMean.getSuggestions(timeout, count);\n        //[#[query]#,[#{suggestions}##[text]##(eol)#,::#(/eol)##{/suggestions}#]]\n        synchronized (suggestions) {\n            for (StringBuilder suggestion: suggestions) {\n                if (c >= meanMax) break;\n                try {\n                    String s = suggestion.toString();\n                    if (json) {\n                        prop.putJSON(\"suggestions_\" + c + \"_text\", s);\n                    } else if (xml) {\n                        prop.putXML(\"suggestions_\" + c + \"_text\", s);\n                    } else {\n                        prop.putHTML(\"suggestions_\" + c + \"_text\", s);\n                    }\n                    prop.put(\"suggestions_\" + c + \"_eol\", 0);\n                    c++;\n                } catch (final ConcurrentModificationException e) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n        }\n\n        if (c > 0) {\n            prop.put(\"suggestions_\" + (c - 1) + \"_eol\", 1);\n        }\n        prop.put(\"suggestions\", c);\n        if (json) {\n            prop.putJSON(\"query\", originalquerystring);\n        } else if (xml) {\n            prop.putXML(\"query\", originalquerystring);\n        } else {\n            prop.putHTML(\"query\", originalquerystring);\n        }\n\n        // Adding CORS Access header for xml output\n        if (xml) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"6578ff3ddb1c9300e311360dfa2f02a1f64c7c61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(\n        final RequestHeader header,\n        final serverObjects post,\n        final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        final boolean authorized = sb.verifyAuthentication(header);\n        final boolean searchAllowed = sb.getConfigBool(SwitchboardConstants.PUBLIC_SEARCHPAGE, true) || authorized;\n\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        if ( !authenticated ) {\n            final UserDB.Entry user = sb.userDB.getUser(header);\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\n        }\n        final boolean localhostAccess = header.accessFromLocalhost();\n        final String promoteSearchPageGreeting =\n            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                \"network.unit.description\",\n                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\n        \n        // in case that the crawler is running and the search user is the peer admin, we expect that the user wants to check recently crawled document\n        // to ensure that recent crawl results are inside the search results, we do a soft commit here. This is also important for live demos!\n        if (authenticated && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 0) {\n            sb.index.fulltext().commit(true);\n        }\n        final boolean focus  = (post == null) ? true : post.get(\"focus\", \"1\").equals(\"1\");\n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\n        String querystring = originalquerystring.replace('+', ' ').trim();\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", sb.getConfig(\"search.verify\", \"\")));\n        \n        final servletProperties prop = new servletProperties();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n\n        // produce vocabulary navigation sidebars\n        Collection<Tagging> vocabularies = LibraryProvider.autotagging.getVocabularies();\n        int j = 0;\n        for (Tagging v: vocabularies) {\n            prop.put(\"sidebarVocabulary_\" + j + \"_vocabulary\", v.getName());\n            j++;\n        }\n        prop.put(\"sidebarVocabulary\", j);\n\n        // get segment\n        Segment indexSegment = sb.index;\n\n        final String EXT = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\");\n        final boolean rss = \"rss.atom\".contains(EXT);\n        final boolean json = EXT.equals(\"json\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        \n        // adding some additional properties needed for the rss feed\n        String hostName = header.get(\"Host\", Domains.LOCALHOST);\n        if ( hostName.indexOf(':', 0) == -1 ) {\n            hostName += \":\" + env.getLocalPort(\"port\", 8090);\n        }\n        prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\n        prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.png\");\n        prop.put(\"thisaddress\", hostName);\n        final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n        boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n        boolean global = post == null || (!post.get(\"resource-switch\", post.get(\"resource\", \"global\")).equals(\"local\") && p2pmode);\n        boolean stealthmode = p2pmode && !global;\n        \n        if ( post == null || indexSegment == null || env == null || !searchAllowed ) {\n            if (indexSegment == null) ConcurrentLog.info(\"yacysearch\", \"indexSegment == null\");\n            // we create empty entries for template strings\n            prop.put(\"searchagain\", \"0\");\n            prop.put(\"former\", \"\");\n            prop.put(\"count\", \"10\");\n            prop.put(\"offset\", \"0\");\n            prop.put(\"resource\", \"global\");\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\n            prop.put(\"indexof\", \"off\");\n            prop.put(\"constraint\", \"\");\n            prop.put(\"depth\", \"0\");\n            prop.put(\n                \"search.verify\",\n                (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\n            prop.put(\n                \"search.navigation\",\n                (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n            prop.put(\"contentdom\", \"text\");\n            prop.put(\"contentdomCheckText\", \"1\");\n            prop.put(\"contentdomCheckAudio\", \"0\");\n            prop.put(\"contentdomCheckVideo\", \"0\");\n            prop.put(\"contentdomCheckImage\", \"0\");\n            prop.put(\"contentdomCheckApp\", \"0\");\n            prop.put(\"excluded\", \"0\");\n            prop.put(\"results\", \"\");\n            prop.put(\"resultTable\", \"0\");\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\n            prop.put(\"num-results_totalcount\", 0);\n            prop.put(\"num-results_offset\", 0);\n            prop.put(\"num-results_itemsPerPage\", 10);\n            prop.put(\"geoinfo\", \"0\");\n            prop.put(\"rss_queryenc\", \"\");\n            prop.put(\"meanCount\", 5);\n            return prop;\n        }\n\n        // check for JSONP\n        if ( post.containsKey(\"callback\") ) {\n            final String jsonp = post.get(\"callback\") + \"([\";\n            prop.put(\"jsonp-start\", jsonp);\n            prop.put(\"jsonp-end\", \"])\");\n        } else {\n            prop.put(\"jsonp-start\", \"\");\n            prop.put(\"jsonp-end\", \"\");\n        }\n\n        // Adding CORS Access header for yacysearch.rss output\n        if ( rss ) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // collect search attributes\n\n        int itemsPerPage =\n            Math.min(\n                (authenticated)\n                    ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()\n                        ? 100\n                        : 5000) : (snippetFetchStrategy != null\n                        && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000),\n                post.getInt(\"maximumRecords\", post.getInt(\"count\", post.getInt(\"rows\", sb.getConfigInt(SwitchboardConstants.SEARCH_ITEMS, 10))))); // SRU syntax with old property as alternative\n        int startRecord = post.getInt(\"startRecord\", post.getInt(\"offset\", post.getInt(\"start\", 0)));\n\n        final boolean indexof = (post != null && post.get(\"indexof\", \"\").equals(\"on\"));\n\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\n        if ( !prefermask.isEmpty() && prefermask.indexOf(\".*\", 0) < 0 ) {\n            prefermask = \".*\" + prefermask + \".*\";\n        }\n\n        Bitfield constraint =\n            (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty())\n                ? new Bitfield(4, post.get(\"constraint\", \"______\"))\n                : null;\n        if ( indexof ) {\n            constraint = new Bitfield(4);\n            constraint.set(Condenser.flag_cat_indexof, true);\n        }\n\n        // SEARCH\n        final boolean intranetMode = sb.isIntranetMode() || sb.isAllIPMode();\n\n        // increase search statistic counter\n        if ( !global ) {\n            // we count only searches on the local peer here, because global searches\n            // are counted on the target peer to preserve privacy of the searcher\n            if ( authenticated ) {\n                // local or authenticated search requests are counted separately\n                // because they are not part of a public available peer statistic\n                sb.searchQueriesRobinsonFromLocal++;\n            } else {\n                // robinson-searches from non-authenticated requests are public\n                // and may be part of the public available statistic\n                sb.searchQueriesRobinsonFromRemote++;\n            }\n        }\n\n        // find search domain\n        final Classification.ContentDomain contentdom = post == null || !post.containsKey(\"contentdom\") ? ContentDomain.ALL : ContentDomain.contentdomParser(post.get(\"contentdom\", \"all\"));\n\n        // patch until better search profiles are available\n        if (contentdom == ContentDomain.IMAGE && (itemsPerPage == 10 || itemsPerPage == 100)) {\n            itemsPerPage = 64;\n        } else if ( contentdom != ContentDomain.IMAGE && itemsPerPage > 50 && itemsPerPage < 100 ) {\n            itemsPerPage = 10;\n        }\n\n        // check the search tracker\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\n        if ( trackerHandles == null ) {\n            trackerHandles = new TreeSet<Long>();\n        }\n        boolean block = false;\n        if ( Domains.matchesList(client, sb.networkWhitelist) ) {\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \"\n                + client\n                + \" gets no search restrictions\");\n        } else if ( Domains.matchesList(client, sb.networkBlacklist) ) {\n            global = false;\n            if ( snippetFetchStrategy != null ) {\n                snippetFetchStrategy = null;\n            }\n            block = true;\n            ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \"\n                + client\n                + \" gets no permission to search\");\n        } else if ( !authenticated && !localhostAccess && !intranetMode ) {\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\n            synchronized ( trackerHandles ) {\n                final int accInThreeSeconds =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\n                final int accInOneMinute =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\n                final int accInTenMinutes =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\n                // protections against too strong YaCy network load, reduces remote search\n                if ( global ) {\n                    if ( accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1 ) {\n                        global = false;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed global search\");\n                    }\n                }\n                // protection against too many remote server snippet loads (protects traffic on server)\n                if ( snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ) {\n                    if ( accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1 ) {\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed remote snippet loading\");\n                    }\n                }\n                // general load protection\n                if ( accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60 ) {\n                    block = true;\n                    ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                        + client\n                        + \": \"\n                        + accInThreeSeconds\n                        + \"/3s, \"\n                        + accInOneMinute\n                        + \"/60s, \"\n                        + accInTenMinutes\n                        + \"/600s, \"\n                        + \" requests, disallowed search\");\n                }\n            }\n        }\n\n        if ( !block ) {\n            String urlmask = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"); // the expression must be a subset of the java Match syntax described in http://lucene.apache.org/core/4_4_0/core/org/apache/lucene/util/automaton/RegExp.html\n            String tld = null;\n            String inlink = null;\n\n            // check available memory and clean up if necessary\n            if ( !MemoryControl.request(8000000L, false) ) {\n                indexSegment.clearCaches();\n                SearchEventCache.cleanupEvents(false);\n            }\n\n            final RankingProfile ranking = sb.getRanking();\n            final QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n            if (modifier.sitehost != null && modifier.sitehost.length() > 0 && querystring.length() == 0) querystring = \"*\"; // allow to search for all documents on a host\n\n            // read collection\n            modifier.collection = post.get(\"collection\", modifier.collection); // post arguments may overrule parsed collection values\n            \n            int stp = querystring.indexOf('*');\n            if (stp >= 0) {\n                // if the star appears as a single entry, use the catchallstring\n                if (querystring.length() == 1) {\n                    querystring = Segment.catchallString;\n                } else {\n                    querystring = querystring.replaceAll(\"\\\\* \", Segment.catchallString + \" \").replace(\" \\\\*\", \" \" + Segment.catchallString);\n                }\n            }\n            if ( querystring.indexOf(\"/near\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/near\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_worddistance = RankingProfile.COEFF_MAX;\n                modifier.add(\"/near\");\n            }\n            if ( querystring.indexOf(\"/date\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/date\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\n                modifier.add(\"/date\");\n            }\n\n            if ( querystring.indexOf(\"/location\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/location\", \"\");\n                if ( constraint == null ) {\n                    constraint = new Bitfield(4);\n                }\n                constraint.set(Condenser.flag_cat_haslocation, true);\n                modifier.add(\"/location\");\n            }\n\n            final int inurlp = querystring.indexOf(\"inurl:\", 0);\n            if ( inurlp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inurlp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                final String urlstr = querystring.substring(inurlp + 6, ftb);\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\n                if ( !urlstr.isEmpty() ) {\n                    urlmask = urlmask == null || urlmask.equals(\".*\") ? \".*\" + urlstr + \".*\" : urlmask; // we cannot join the conditions; if an urlmask is already given then stay with that\n                }\n                modifier.add(\"inurl:\" + urlstr);\n            }\n\n            final int inlinkp = querystring.indexOf(\"inlink:\", 0);\n            if ( inlinkp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inlinkp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                inlink = querystring.substring(inlinkp + 7, ftb);\n                querystring = querystring.replace(\"inlink:\" + inlink, \"\");\n                modifier.add(\"inlink:\" + inlink);\n            }\n\n            int voc = 0;\n            Collection<Tagging.Metatag> metatags = new ArrayList<Tagging.Metatag>(1);\n            while ((voc = querystring.indexOf(\"/vocabulary/\", 0)) >= 0) {\n                String vocabulary = \"\";\n                int ve = querystring.indexOf(' ', voc + 12);\n                if (ve < 0) {\n                    vocabulary = querystring.substring(voc);\n                    querystring = querystring.substring(0, voc).trim();\n                } else {\n                    vocabulary = querystring.substring(voc, ve);\n                    querystring = querystring.substring(0, voc) + querystring.substring(ve);\n                }\n                modifier.add(vocabulary);\n                vocabulary = vocabulary.substring(12);\n                int p = vocabulary.indexOf('/');\n                if (p > 0) {\n                    String k = vocabulary.substring(0, p);\n                    String v = vocabulary.substring(p + 1);\n                    metatags.add(LibraryProvider.autotagging.metatag(k, v));\n                }\n            }\n\n            int radius = 0;\n            double lon = 0.0d, lat = 0.0d, rad = 0.0d;\n            if ((radius = querystring.indexOf(\"/radius/\")) >= 0) {\n                int ve = querystring.indexOf(' ', radius + 8);\n                String geo = \"\";\n                if (ve < 0) {\n                    geo = querystring.substring(radius);\n                    querystring = querystring.substring(0, radius).trim();\n                } else {\n                    geo = querystring.substring(radius, ve);\n                    querystring = querystring.substring(0, radius) + querystring.substring(ve);\n                }\n                geo = geo.substring(8);\n                String[] sp = geo.split(\"/\");\n                if (sp.length == 3) try {\n                    lat = Double.parseDouble(sp[0]);\n                    lon = Double.parseDouble(sp[1]);\n                    rad = Double.parseDouble(sp[2]);\n                } catch (final NumberFormatException e) {\n                    lon = 0.0d; lat = 0.0d; rad = 0.0d;\n                }\n            }\n\n            final int heuristicBlekko = querystring.indexOf(\"/heuristic\", 0);\n            if ( heuristicBlekko >= 0 ) {\n                querystring = querystring.replace(\"/heuristic\", \"\");\n                modifier.add(\"/heuristic\");\n            }\n            \n            final int tldp = querystring.indexOf(\"tld:\", 0);\n            if (tldp >= 0) {\n                int ftb = querystring.indexOf(' ', tldp);\n                if (ftb == -1) ftb = querystring.length();\n                tld = querystring.substring(tldp + 4, ftb);\n                querystring = querystring.replace(\"tld:\" + tld, \"\");\n                modifier.add(\"tld:\" + tld);\n                while ( tld.length() > 0 && tld.charAt(0) == '.' ) {\n                    tld = tld.substring(1);\n                }\n                if (tld.length() == 0) tld = null;\n            }\n            if (urlmask == null || urlmask.isEmpty()) urlmask = \".*\"; //if no urlmask was given\n\n            // read the language from the language-restrict option 'lr'\n            // if no one is given, use the user agent or the system language as default\n            String language = (post == null) ? null : post.get(\"lr\");\n            if (language != null && language.startsWith(\"lang_\") ) {\n                language = language.substring(5);\n                if (modifier.language == null) modifier.language = language;\n            }\n            if (language == null || !ISO639.exists(language) ) {\n                // find out language of the user by reading of the user-agent string\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\n                if ( agent == null ) {\n                    agent = System.getProperty(\"user.language\");\n                }\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\n                if ( language == null ) {\n                    language = \"en\";\n                }\n            }\n\n            // the query\n            final QueryGoal qg = new QueryGoal(querystring.trim());\n            final int maxDistance = (querystring.indexOf('\"', 0) >= 0) ? qg.getIncludeHashes().size() - 1 : Integer.MAX_VALUE;\n\n            // filter out stopwords\n            final SortedSet<String> filtered = SetTools.joinConstructiveByTest(qg.getIncludeWords(), Switchboard.stopwords); //find matching stopwords\n            qg.removeIncludeWords(filtered);\n            \n            // if a minus-button was hit, remove a special reference first\n            if ( post != null && post.containsKey(\"deleteref\") ) {\n                try {\n                    if ( !sb.verifyAuthentication(header) ) {\n                    \tprop.authenticationRequired();\n                        return prop;\n                    }\n\n                    // delete the index entry locally\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\n                    if (indexSegment.termIndex() != null) indexSegment.termIndex().remove(qg.getIncludeHashes(), delHash.getBytes());\n\n                    // make new news message with negative voting\n                    if ( !sb.isRobinsonMode() ) {\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"urlhash\", delHash);\n                        map.put(\"vote\", \"negative\");\n                        map.put(\"refid\", \"\");\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_VOTE_ADD,\n                            map);\n                    }\n\n                    // delete the search history since this still shows the entry\n                    SearchEventCache.delete(delHash);\n                } catch (final IOException e ) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n\n            // if a plus-button was hit, create new voting message\n            if ( post != null && post.containsKey(\"recommendref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\n                final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(recommendHash));\n                if ( urlentry != null ) {\n                    Document[] documents = null;\n                    try {\n                        documents =\n                            sb.loader.loadDocuments(\n                                sb.loader.request(urlentry.url(), true, false),\n                                CacheStrategy.IFEXIST,\n                                Integer.MAX_VALUE, BlacklistType.SEARCH, ClientIdentification.yacyIntranetCrawlerAgent);\n                    } catch (final IOException e ) {\n                    } catch (final Parser.Failure e ) {\n                    }\n                    if ( documents != null ) {\n                        // create a news message\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"url\", urlentry.url().toNormalform(true).replace(',', '|'));\n                        map.put(\"title\", urlentry.dc_title().replace(',', ' '));\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\n                        map.put(\"author\", documents[0].dc_creator());\n                        map.put(\"tags\", documents[0].dc_subject(' '));\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_ADD,\n                            map);\n                        documents[0].close();\n                    }\n                }\n            }\n\n            // if a bookmarks-button was hit, create new bookmark entry\n            if ( post != null && post.containsKey(\"bookmarkref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                //final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\n                final String urlstr = crypt.simpleDecode(post.get(\"bookmarkurl\"));\n                if (urlstr != null) {\n                    try {\n                        final Bookmark bmk = sb.bookmarksDB.createBookmark(urlstr, YMarkTables.USER_ADMIN);\n                        bmk.setProperty(Bookmark.BOOKMARK_DESCRIPTION, \"query=\"+querystring);\n                        //bmk.setProperty(Bookmark.BOOKMARK_QUERY, originalquerystring);\n                        bmk.addTag(\"/search\"); // add to bookmark folder\n                        bmk.addTag(\"searchresult\"); // add tag\n                        String urlhash = post.get(\"bookmarkref\");\n                        final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(urlhash));\n                        if (urlentry != null && !urlentry.dc_title().isEmpty()) \n                            bmk.setProperty(Bookmark.BOOKMARK_TITLE,urlentry.dc_title());\n                        sb.bookmarksDB.saveBookmark(bmk);\n\n                        // do the same for YMarks ?\n                        sb.tables.bookmarks.createBookmark(\n                                sb.loader,\n                                urlstr,\n                                ClientIdentification.yacyInternetCrawlerAgent,\n                                YMarkTables.USER_ADMIN,\n                                true,\n                                \"searchresult\",\n                                \"/search\");\n                    } catch (final Throwable e) { }\n                }\n            }\n\n            // check filters\n            try {\n                Pattern.compile(urlmask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal URL mask, not a valid regex: \" + urlmask);\n                prop.put(\"urlmaskerror\", 1);\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\n                urlmask = \".*\";\n            }\n\n            try {\n                Pattern.compile(prefermask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal prefer mask, not a valid regex: \" + prefermask);\n                prop.put(\"prefermaskerror\", 1);\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\n                prefermask = \"\";\n            }\n\n            // do the search\n            final QueryParams theQuery =\n                new QueryParams(\n                    qg,\n                    modifier,\n                    maxDistance,\n                    prefermask,\n                    contentdom,\n                    language,\n                    metatags,\n                    snippetFetchStrategy,\n                    itemsPerPage,\n                    startRecord,\n                    urlmask, tld, inlink,\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER : (global && indexReceiveGranted ? QueryParams.Searchdom.GLOBAL : QueryParams.Searchdom.LOCAL),\n                    constraint,\n                    true,\n                    DigestURL.hosthashess(sb.getConfig(\"search.excludehosth\", \"\")),\n                    MultiProtocolURL.TLD_any_zone_filter,\n                    client,\n                    authenticated,\n                    indexSegment,\n                    ranking,\n                    header.get(HeaderFramework.USER_AGENT, \"\"),\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false)\n                        && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                        && sb.peers.mySeed().getFlagAcceptRemoteIndex(),\n                    false,\n                    lat, lon, rad,\n                    sb.getConfigArray(\"search.navigation\", \"\"));\n            EventTracker.delete(EventTracker.EClass.SEARCH);\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(\n                theQuery.id(true),\n                SearchEventType.INITIALIZATION,\n                \"\",\n                0,\n                0), false);\n\n            // tell all threads to do nothing for a specific time\n            sb.intermissionAllThreads(3000);\n\n            // filter out words that appear in bluelist\n            theQuery.getQueryGoal().filterOut(Switchboard.blueList);\n\n            // log\n            ConcurrentLog.info(\n                \"LOCAL_SEARCH\",\n                \"INIT WORD SEARCH: \"\n                    + theQuery.getQueryGoal().getQueryString(false)\n                    + \":\"\n                    + QueryParams.hashSet2hashString(theQuery.getQueryGoal().getIncludeHashes())\n                    + \" - \"\n                    + theQuery.neededResults()\n                    + \" links to be computed, \"\n                    + theQuery.itemsPerPage()\n                    + \" lines to be displayed\");\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(\n                new RSSMessage(\"Local Search Request\", theQuery.getQueryGoal().getQueryString(false), \"\"));\n            final long timestamp = System.currentTimeMillis();\n\n            // create a new search event\n            if ( SearchEventCache.getEvent(theQuery.id(false)) == null ) {\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\n                startRecord = 0;\n            }\n            final SearchEvent theSearch =\n                SearchEventCache.getEvent(\n                    theQuery,\n                    sb.peers,\n                    sb.tables,\n                    (sb.isRobinsonMode()) ? sb.clusterhashes : null,\n                    false,\n                    sb.loader,\n                    (int) sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\n                    sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXTIME_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)));\n\n            if ( startRecord == 0 ) {\n                if ( modifier.sitehost != null && sb.getConfigBool(SwitchboardConstants.HEURISTIC_SITE, false) && authenticated && !stealthmode) {\n                    sb.heuristicSite(theSearch, modifier.sitehost);\n                }\n                if ( heuristicBlekko >= 0  && authenticated && !stealthmode ) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n                if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, false) && authenticated && !stealthmode) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n            }\n\n            // log\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \"\n                + theQuery.getQueryGoal().getQueryString(false)\n                + \" - \"\n                + \"local_rwi_available(\" + theSearch.local_rwi_available.get() + \"), \"\n                + \"local_rwi_stored(\" + theSearch.local_rwi_stored.get() + \"), \"\n                + \"remote_rwi_available(\" + theSearch.remote_rwi_available.get() + \"), \"\n                + \"remote_rwi_stored(\" + theSearch.remote_rwi_stored.get() + \"), \"\n                + \"remote_rwi_peerCount(\" + theSearch.remote_rwi_peerCount.get() + \"), \"\n                + \"local_solr_available(\" + theSearch.local_solr_available.get() + \"), \"\n                + \"local_solr_stored(\" + theSearch.local_solr_stored.get() + \"), \"\n                + \"remote_solr_available(\" + theSearch.remote_solr_available.get() + \"), \"\n                + \"remote_solr_stored(\" + theSearch.remote_solr_stored.get() + \"), \"\n                + \"remote_solr_peerCount(\" + theSearch.remote_solr_peerCount.get() + \"), \"\n                + (System.currentTimeMillis() - timestamp)\n                + \" ms\");\n\n            // prepare search statistics\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\n            AccessTracker.add(AccessTracker.Location.local, theQuery, theSearch.getResultCount());\n\n            // check suggestions\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\n\n            prop.put(\"meanCount\", meanMax);\n            if ( meanMax > 0 && !json && !rss && sb.index.connectedRWI()) {\n                final DidYouMean didYouMean = new DidYouMean(indexSegment, new StringBuilder(querystring));\n                final Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\n                int meanCount = 0;\n                String suggestion;\n                try {\n                    meanCollect: while ( meanCount < meanMax && meanIt.hasNext() ) {\n                        try {\n                            suggestion = meanIt.next().toString();\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_word\", suggestion);\n                            prop.put(\n                                \"didYouMean_suggestions_\" + meanCount + \"_url\",\n                                QueryParams.navurl(\n                                    RequestHeader.FileType.HTML,\n                                    0,\n                                    theQuery,\n                                    suggestion, true).toString());\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_sep\", \"|\");\n                            meanCount++;\n                        } catch (final ConcurrentModificationException e) {\n                            ConcurrentLog.logException(e);\n                            break meanCollect;\n                        }\n                    }\n                } catch (final ConcurrentModificationException e) {\n                    ConcurrentLog.logException(e);\n                }\n                prop.put(\"didYouMean_suggestions_\" + (meanCount - 1) + \"_sep\", \"\");\n                prop.put(\"didYouMean\", meanCount > 0 ? 1 : 0);\n                prop.put(\"didYouMean_suggestions\", meanCount);\n            } else {\n                prop.put(\"didYouMean\", 0);\n            }\n\n            // find geographic info\n            final SortedSet<GeoLocation> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\n            if ( coordinates == null || coordinates.isEmpty() || startRecord > 0 ) {\n                prop.put(\"geoinfo\", \"0\");\n            } else {\n                int i = 0;\n                for ( final GeoLocation c : coordinates ) {\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\n                    i++;\n                    if ( i >= 10 ) {\n                        break;\n                    }\n                }\n                prop.put(\"geoinfo_loc\", i);\n                prop.put(\"geoinfo\", \"1\");\n            }\n\n            // update the search tracker\n            try {\n                synchronized ( trackerHandles ) {\n                    trackerHandles.add(theQuery.starttime);\n                    while ( trackerHandles.size() > 600 ) {\n                        if ( !trackerHandles.remove(trackerHandles.first()) ) {\n                            break;\n                        }\n                    }\n                }\n                sb.localSearchTracker.put(client, trackerHandles);\n                if ( sb.localSearchTracker.size() > 100 ) {\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\n                }\n                if ( MemoryControl.shortStatus() ) {\n                    sb.localSearchTracker.clear();\n                }\n            } catch (final Exception e ) {\n                ConcurrentLog.logException(e);\n            }\n\n            prop.put(\"num-results_offset\", startRecord);\n            prop.put(\"num-results_itemscount\", Formatter.number(startRecord + theSearch.query.itemsPerPage > theSearch.getResultCount() ? startRecord + theSearch.getResultCount() % theSearch.query.itemsPerPage : startRecord + theSearch.query.itemsPerPage, true));\n            prop.put(\"num-results_itemsPerPage\", Formatter.number(itemsPerPage));\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getResultCount())); // also in yacyserchtrailer (hint: timing in p2p search )\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n\n            // generate the search result lines; the content will be produced by another servlet\n            for ( int i = 0; i < theQuery.itemsPerPage(); i++ ) {\n                prop.put(\"results_\" + i + \"_item\", startRecord + i);\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\n            }\n            prop.put(\"results\", theQuery.itemsPerPage());\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\n\n            // process result of search\n            if ( !filtered.isEmpty() ) {\n                prop.put(\"excluded\", \"1\");\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\n            } else {\n                prop.put(\"excluded\", \"0\");\n            }\n\n            if (prop.isEmpty() || querystring.length() == 0) {\n                if ( querystring.length() == 0 ) { // querystring is trimmed originalquerystring\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\n                } else {\n                    prop.put(\"num-results\", \"1\"); // no results\n                }\n            } else {\n                prop.put(\"num-results\", \"3\");\n            }\n\n            prop.put(\"depth\", \"0\");\n\n        }\n        prop.put(\"focus\", focus ? 1 : 0); // focus search field\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\n        prop.putHTML(\"former\", originalquerystring.replaceAll(Segment.catchallString, \"*\"));\n        prop.put(\"count\", itemsPerPage);\n        prop.put(\"offset\", startRecord);\n        prop.put(\"resource\", global ? \"global\" : \"local\");\n        prop.putHTML(\"prefermaskfilter\", prefermask);\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n        prop.putHTML(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\n\n        // for RSS: don't HTML encode some elements\n        prop.putXML(\"rss_query\", originalquerystring);\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\n\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        // hostname and port (assume locahost if nothing helps)\n        final String hostIP = sb.peers.mySeed().getIP();\n        prop.put(\"myhost\", hostIP != null ? hostIP : Domains.LOCALHOST);\n        prop.put(\"myport\", Domains.LOCALHOST.equals(hostIP) ? sb.getLocalPort(\"port\", 8090) : sb.getPublicPort(\"port\", 8090));\n\n        // return rewrite properties\n        return prop;\n    }","id":67253,"modified_method":"public static serverObjects respond(\n        final RequestHeader header,\n        final serverObjects post,\n        final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        final boolean authorized = sb.verifyAuthentication(header);\n        final boolean searchAllowed = sb.getConfigBool(SwitchboardConstants.PUBLIC_SEARCHPAGE, true) || authorized;\n\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        if ( !authenticated ) {\n            final UserDB.Entry user = sb.userDB.getUser(header);\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\n        }\n        final boolean localhostAccess = header.accessFromLocalhost();\n        final String promoteSearchPageGreeting =\n            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                \"network.unit.description\",\n                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\n        \n        // in case that the crawler is running and the search user is the peer admin, we expect that the user wants to check recently crawled document\n        // to ensure that recent crawl results are inside the search results, we do a soft commit here. This is also important for live demos!\n        if (authenticated && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 0) {\n            sb.index.fulltext().commit(true);\n        }\n        final boolean focus  = (post == null) ? true : post.get(\"focus\", \"1\").equals(\"1\");\n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\n        String querystring = originalquerystring.replace('+', ' ').trim();\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", sb.getConfig(\"search.verify\", \"\")));\n        \n        final servletProperties prop = new servletProperties();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n\n        // produce vocabulary navigation sidebars\n        Collection<Tagging> vocabularies = LibraryProvider.autotagging.getVocabularies();\n        int j = 0;\n        for (Tagging v: vocabularies) {\n            prop.put(\"sidebarVocabulary_\" + j + \"_vocabulary\", v.getName());\n            j++;\n        }\n        prop.put(\"sidebarVocabulary\", j);\n\n        // get segment\n        Segment indexSegment = sb.index;\n\n        final String EXT = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\");\n        final boolean rss = \"rss.atom\".contains(EXT);\n        final boolean json = EXT.equals(\"json\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        \n        // adding some additional properties needed for the rss feed\n        String hostName = header.get(\"Host\", Domains.LOCALHOST);\n        if ( hostName.indexOf(':', 0) == -1 ) {\n            hostName += \":\" + env.getLocalPort(\"port\", 8090);\n        }\n        prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\n        prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.png\");\n        prop.put(\"thisaddress\", hostName);\n        final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n        boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n        boolean global = post == null || (!post.get(\"resource-switch\", post.get(\"resource\", \"global\")).equals(\"local\") && p2pmode);\n        boolean stealthmode = p2pmode && !global;\n        \n        if ( post == null || indexSegment == null || env == null || !searchAllowed ) {\n            if (indexSegment == null) ConcurrentLog.info(\"yacysearch\", \"indexSegment == null\");\n            // we create empty entries for template strings\n            prop.put(\"searchagain\", \"0\");\n            prop.put(\"former\", \"\");\n            prop.put(\"count\", \"10\");\n            prop.put(\"offset\", \"0\");\n            prop.put(\"resource\", \"global\");\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\n            prop.put(\"indexof\", \"off\");\n            prop.put(\"constraint\", \"\");\n            prop.put(\"depth\", \"0\");\n            prop.put(\n                \"search.verify\",\n                (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\n            prop.put(\n                \"search.navigation\",\n                (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n            prop.put(\"contentdom\", \"text\");\n            prop.put(\"contentdomCheckText\", \"1\");\n            prop.put(\"contentdomCheckAudio\", \"0\");\n            prop.put(\"contentdomCheckVideo\", \"0\");\n            prop.put(\"contentdomCheckImage\", \"0\");\n            prop.put(\"contentdomCheckApp\", \"0\");\n            prop.put(\"excluded\", \"0\");\n            prop.put(\"results\", \"\");\n            prop.put(\"resultTable\", \"0\");\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\n            prop.put(\"num-results_totalcount\", 0);\n            prop.put(\"num-results_offset\", 0);\n            prop.put(\"num-results_itemsPerPage\", 10);\n            prop.put(\"geoinfo\", \"0\");\n            prop.put(\"rss_queryenc\", \"\");\n            prop.put(\"meanCount\", 5);\n            return prop;\n        }\n\n        // check for JSONP\n        if ( post.containsKey(\"callback\") ) {\n            final String jsonp = post.get(\"callback\") + \"([\";\n            prop.put(\"jsonp-start\", jsonp);\n            prop.put(\"jsonp-end\", \"])\");\n        } else {\n            prop.put(\"jsonp-start\", \"\");\n            prop.put(\"jsonp-end\", \"\");\n        }\n\n        // Adding CORS Access header for yacysearch.rss output\n        if ( rss ) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // collect search attributes\n\n        int itemsPerPage =\n            Math.min(\n                (authenticated)\n                    ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()\n                        ? 100\n                        : 5000) : (snippetFetchStrategy != null\n                        && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000),\n                post.getInt(\"maximumRecords\", post.getInt(\"count\", post.getInt(\"rows\", sb.getConfigInt(SwitchboardConstants.SEARCH_ITEMS, 10))))); // SRU syntax with old property as alternative\n        int startRecord = post.getInt(\"startRecord\", post.getInt(\"offset\", post.getInt(\"start\", 0)));\n\n        final boolean indexof = (post != null && post.get(\"indexof\", \"\").equals(\"on\"));\n\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\n        if ( !prefermask.isEmpty() && prefermask.indexOf(\".*\", 0) < 0 ) {\n            prefermask = \".*\" + prefermask + \".*\";\n        }\n\n        Bitfield constraint =\n            (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty())\n                ? new Bitfield(4, post.get(\"constraint\", \"______\"))\n                : null;\n        if ( indexof ) {\n            constraint = new Bitfield(4);\n            constraint.set(Condenser.flag_cat_indexof, true);\n        }\n\n        // SEARCH\n        final boolean intranetMode = sb.isIntranetMode() || sb.isAllIPMode();\n\n        // increase search statistic counter\n        if ( !global ) {\n            // we count only searches on the local peer here, because global searches\n            // are counted on the target peer to preserve privacy of the searcher\n            if ( authenticated ) {\n                // local or authenticated search requests are counted separately\n                // because they are not part of a public available peer statistic\n                sb.searchQueriesRobinsonFromLocal++;\n            } else {\n                // robinson-searches from non-authenticated requests are public\n                // and may be part of the public available statistic\n                sb.searchQueriesRobinsonFromRemote++;\n            }\n        }\n\n        // find search domain\n        final Classification.ContentDomain contentdom = post == null || !post.containsKey(\"contentdom\") ? ContentDomain.ALL : ContentDomain.contentdomParser(post.get(\"contentdom\", \"all\"));\n\n        // patch until better search profiles are available\n        if (contentdom == ContentDomain.IMAGE && (itemsPerPage == 10 || itemsPerPage == 100)) {\n            itemsPerPage = 64;\n        } else if ( contentdom != ContentDomain.IMAGE && itemsPerPage > 50 && itemsPerPage < 100 ) {\n            itemsPerPage = 10;\n        }\n\n        // check the search tracker\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\n        if ( trackerHandles == null ) {\n            trackerHandles = new TreeSet<Long>();\n        }\n        boolean block = false;\n        if ( Domains.matchesList(client, sb.networkWhitelist) ) {\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \"\n                + client\n                + \" gets no search restrictions\");\n        } else if ( Domains.matchesList(client, sb.networkBlacklist) ) {\n            global = false;\n            if ( snippetFetchStrategy != null ) {\n                snippetFetchStrategy = null;\n            }\n            block = true;\n            ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \"\n                + client\n                + \" gets no permission to search\");\n        } else if ( !authenticated && !localhostAccess && !intranetMode ) {\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\n            synchronized ( trackerHandles ) {\n                final int accInThreeSeconds =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\n                final int accInOneMinute =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\n                final int accInTenMinutes =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\n                // protections against too strong YaCy network load, reduces remote search\n                if ( global ) {\n                    if ( accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1 ) {\n                        global = false;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed global search\");\n                    }\n                }\n                // protection against too many remote server snippet loads (protects traffic on server)\n                if ( snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ) {\n                    if ( accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1 ) {\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed remote snippet loading\");\n                    }\n                }\n                // general load protection\n                if ( accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60 ) {\n                    block = true;\n                    ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                        + client\n                        + \": \"\n                        + accInThreeSeconds\n                        + \"/3s, \"\n                        + accInOneMinute\n                        + \"/60s, \"\n                        + accInTenMinutes\n                        + \"/600s, \"\n                        + \" requests, disallowed search\");\n                }\n            }\n        }\n\n        if ( !block ) {\n            String urlmask = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"); // the expression must be a subset of the java Match syntax described in http://lucene.apache.org/core/4_4_0/core/org/apache/lucene/util/automaton/RegExp.html\n            String tld = null;\n            String inlink = null;\n\n            // check available memory and clean up if necessary\n            if ( !MemoryControl.request(8000000L, false) ) {\n                indexSegment.clearCaches();\n                SearchEventCache.cleanupEvents(false);\n            }\n\n            final RankingProfile ranking = sb.getRanking();\n            final QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n            if (modifier.sitehost != null && modifier.sitehost.length() > 0 && querystring.length() == 0) querystring = \"*\"; // allow to search for all documents on a host\n\n            // read collection\n            modifier.collection = post.get(\"collection\", modifier.collection); // post arguments may overrule parsed collection values\n            \n            int stp = querystring.indexOf('*');\n            if (stp >= 0) {\n                // if the star appears as a single entry, use the catchallstring\n                if (querystring.length() == 1) {\n                    querystring = Segment.catchallString;\n                } else {\n                    querystring = querystring.replaceAll(\"\\\\* \", Segment.catchallString + \" \").replace(\" \\\\*\", \" \" + Segment.catchallString);\n                }\n            }\n            if ( querystring.indexOf(\"/near\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/near\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_worddistance = RankingProfile.COEFF_MAX;\n                modifier.add(\"/near\");\n            }\n            if ( querystring.indexOf(\"/date\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/date\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\n                modifier.add(\"/date\");\n            }\n\n            if ( querystring.indexOf(\"/location\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/location\", \"\");\n                if ( constraint == null ) {\n                    constraint = new Bitfield(4);\n                }\n                constraint.set(Condenser.flag_cat_haslocation, true);\n                modifier.add(\"/location\");\n            }\n\n            final int inurlp = querystring.indexOf(\"inurl:\", 0);\n            if ( inurlp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inurlp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                final String urlstr = querystring.substring(inurlp + 6, ftb);\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\n                if ( !urlstr.isEmpty() ) {\n                    urlmask = urlmask == null || urlmask.equals(\".*\") ? \".*\" + urlstr + \".*\" : urlmask; // we cannot join the conditions; if an urlmask is already given then stay with that\n                }\n                modifier.add(\"inurl:\" + urlstr);\n            }\n\n            final int inlinkp = querystring.indexOf(\"inlink:\", 0);\n            if ( inlinkp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inlinkp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                inlink = querystring.substring(inlinkp + 7, ftb);\n                querystring = querystring.replace(\"inlink:\" + inlink, \"\");\n                modifier.add(\"inlink:\" + inlink);\n            }\n\n            int voc = 0;\n            Collection<Tagging.Metatag> metatags = new ArrayList<Tagging.Metatag>(1);\n            while ((voc = querystring.indexOf(\"/vocabulary/\", 0)) >= 0) {\n                String vocabulary = \"\";\n                int ve = querystring.indexOf(' ', voc + 12);\n                if (ve < 0) {\n                    vocabulary = querystring.substring(voc);\n                    querystring = querystring.substring(0, voc).trim();\n                } else {\n                    vocabulary = querystring.substring(voc, ve);\n                    querystring = querystring.substring(0, voc) + querystring.substring(ve);\n                }\n                modifier.add(vocabulary);\n                vocabulary = vocabulary.substring(12);\n                int p = vocabulary.indexOf('/');\n                if (p > 0) {\n                    String k = vocabulary.substring(0, p);\n                    String v = vocabulary.substring(p + 1);\n                    metatags.add(LibraryProvider.autotagging.metatag(k, v));\n                }\n            }\n\n            int radius = 0;\n            double lon = 0.0d, lat = 0.0d, rad = 0.0d;\n            if ((radius = querystring.indexOf(\"/radius/\")) >= 0) {\n                int ve = querystring.indexOf(' ', radius + 8);\n                String geo = \"\";\n                if (ve < 0) {\n                    geo = querystring.substring(radius);\n                    querystring = querystring.substring(0, radius).trim();\n                } else {\n                    geo = querystring.substring(radius, ve);\n                    querystring = querystring.substring(0, radius) + querystring.substring(ve);\n                }\n                geo = geo.substring(8);\n                String[] sp = geo.split(\"/\");\n                if (sp.length == 3) try {\n                    lat = Double.parseDouble(sp[0]);\n                    lon = Double.parseDouble(sp[1]);\n                    rad = Double.parseDouble(sp[2]);\n                } catch (final NumberFormatException e) {\n                    lon = 0.0d; lat = 0.0d; rad = 0.0d;\n                }\n            }\n\n            final int heuristicBlekko = querystring.indexOf(\"/heuristic\", 0);\n            if ( heuristicBlekko >= 0 ) {\n                querystring = querystring.replace(\"/heuristic\", \"\");\n                modifier.add(\"/heuristic\");\n            }\n            \n            final int tldp = querystring.indexOf(\"tld:\", 0);\n            if (tldp >= 0) {\n                int ftb = querystring.indexOf(' ', tldp);\n                if (ftb == -1) ftb = querystring.length();\n                tld = querystring.substring(tldp + 4, ftb);\n                querystring = querystring.replace(\"tld:\" + tld, \"\");\n                modifier.add(\"tld:\" + tld);\n                while ( tld.length() > 0 && tld.charAt(0) == '.' ) {\n                    tld = tld.substring(1);\n                }\n                if (tld.length() == 0) tld = null;\n            }\n            if (urlmask == null || urlmask.isEmpty()) urlmask = \".*\"; //if no urlmask was given\n\n            // read the language from the language-restrict option 'lr'\n            // if no one is given, use the user agent or the system language as default\n            String language = (post == null) ? null : post.get(\"lr\");\n            if (language != null && language.startsWith(\"lang_\") ) {\n                language = language.substring(5);\n                if (modifier.language == null) modifier.language = language;\n            }\n            if (language == null || !ISO639.exists(language) ) {\n                // find out language of the user by reading of the user-agent string\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\n                if ( agent == null ) {\n                    agent = System.getProperty(\"user.language\");\n                }\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\n                if ( language == null ) {\n                    language = \"en\";\n                }\n            }\n\n            // the query\n            final QueryGoal qg = new QueryGoal(querystring.trim());\n            final int maxDistance = (querystring.indexOf('\"', 0) >= 0) ? qg.getIncludeHashes().size() - 1 : Integer.MAX_VALUE;\n\n            // filter out stopwords\n            final SortedSet<String> filtered = SetTools.joinConstructiveByTest(qg.getIncludeWords(), Switchboard.stopwords); //find matching stopwords\n            qg.removeIncludeWords(filtered);\n            \n            // if a minus-button was hit, remove a special reference first\n            if ( post != null && post.containsKey(\"deleteref\") ) {\n                try {\n                    if ( !sb.verifyAuthentication(header) ) {\n                    \tprop.authenticationRequired();\n                        return prop;\n                    }\n\n                    // delete the index entry locally\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\n                    if (indexSegment.termIndex() != null) indexSegment.termIndex().remove(qg.getIncludeHashes(), delHash.getBytes());\n\n                    // make new news message with negative voting\n                    if ( !sb.isRobinsonMode() ) {\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"urlhash\", delHash);\n                        map.put(\"vote\", \"negative\");\n                        map.put(\"refid\", \"\");\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_VOTE_ADD,\n                            map);\n                    }\n\n                    // delete the search history since this still shows the entry\n                    SearchEventCache.delete(delHash);\n                } catch (final IOException e ) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n\n            // if a plus-button was hit, create new voting message\n            if ( post != null && post.containsKey(\"recommendref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\n                final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(recommendHash));\n                if ( urlentry != null ) {\n                    Document[] documents = null;\n                    try {\n                        documents =\n                            sb.loader.loadDocuments(\n                                sb.loader.request(urlentry.url(), true, false),\n                                CacheStrategy.IFEXIST,\n                                Integer.MAX_VALUE, BlacklistType.SEARCH, ClientIdentification.yacyIntranetCrawlerAgent);\n                    } catch (final IOException e ) {\n                    } catch (final Parser.Failure e ) {\n                    }\n                    if ( documents != null ) {\n                        // create a news message\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"url\", urlentry.url().toNormalform(true).replace(',', '|'));\n                        map.put(\"title\", urlentry.dc_title().replace(',', ' '));\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\n                        map.put(\"author\", documents[0].dc_creator());\n                        map.put(\"tags\", documents[0].dc_subject(' '));\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_ADD,\n                            map);\n                        documents[0].close();\n                    }\n                }\n            }\n\n            // if a bookmarks-button was hit, create new bookmark entry\n            if ( post != null && post.containsKey(\"bookmarkref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                //final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\n                final String urlstr = crypt.simpleDecode(post.get(\"bookmarkurl\"));\n                if (urlstr != null) {\n                    try {\n                        final Bookmark bmk = sb.bookmarksDB.createBookmark(urlstr, YMarkTables.USER_ADMIN);\n                        bmk.setProperty(Bookmark.BOOKMARK_DESCRIPTION, \"query=\"+querystring);\n                        //bmk.setProperty(Bookmark.BOOKMARK_QUERY, originalquerystring);\n                        bmk.addTag(\"/search\"); // add to bookmark folder\n                        bmk.addTag(\"searchresult\"); // add tag\n                        String urlhash = post.get(\"bookmarkref\");\n                        final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(urlhash));\n                        if (urlentry != null && !urlentry.dc_title().isEmpty()) \n                            bmk.setProperty(Bookmark.BOOKMARK_TITLE,urlentry.dc_title());\n                        sb.bookmarksDB.saveBookmark(bmk);\n\n                        // do the same for YMarks ?\n                        sb.tables.bookmarks.createBookmark(\n                                sb.loader,\n                                urlstr,\n                                ClientIdentification.yacyInternetCrawlerAgent,\n                                YMarkTables.USER_ADMIN,\n                                true,\n                                \"searchresult\",\n                                \"/search\");\n                    } catch (final Throwable e) { }\n                }\n            }\n\n            // check filters\n            try {\n                Pattern.compile(urlmask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal URL mask, not a valid regex: \" + urlmask);\n                prop.put(\"urlmaskerror\", 1);\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\n                urlmask = \".*\";\n            }\n\n            try {\n                Pattern.compile(prefermask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal prefer mask, not a valid regex: \" + prefermask);\n                prop.put(\"prefermaskerror\", 1);\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\n                prefermask = \"\";\n            }\n\n            // do the search\n            final QueryParams theQuery =\n                new QueryParams(\n                    qg,\n                    modifier,\n                    maxDistance,\n                    prefermask,\n                    contentdom,\n                    language,\n                    metatags,\n                    snippetFetchStrategy,\n                    itemsPerPage,\n                    startRecord,\n                    urlmask, tld, inlink,\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER : (global && indexReceiveGranted ? QueryParams.Searchdom.GLOBAL : QueryParams.Searchdom.LOCAL),\n                    constraint,\n                    true,\n                    DigestURL.hosthashess(sb.getConfig(\"search.excludehosth\", \"\")),\n                    MultiProtocolURL.TLD_any_zone_filter,\n                    client,\n                    authenticated,\n                    indexSegment,\n                    ranking,\n                    header.get(HeaderFramework.USER_AGENT, \"\"),\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false)\n                        && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                        && sb.peers.mySeed().getFlagAcceptRemoteIndex(),\n                    false,\n                    lat, lon, rad,\n                    sb.getConfigArray(\"search.navigation\", \"\"));\n            EventTracker.delete(EventTracker.EClass.SEARCH);\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(\n                theQuery.id(true),\n                SearchEventType.INITIALIZATION,\n                \"\",\n                0,\n                0), false);\n\n            // tell all threads to do nothing for a specific time\n            sb.intermissionAllThreads(3000);\n\n            // filter out words that appear in bluelist\n            theQuery.getQueryGoal().filterOut(Switchboard.blueList);\n\n            // log\n            ConcurrentLog.info(\n                \"LOCAL_SEARCH\",\n                \"INIT WORD SEARCH: \"\n                    + theQuery.getQueryGoal().getQueryString(false)\n                    + \":\"\n                    + QueryParams.hashSet2hashString(theQuery.getQueryGoal().getIncludeHashes())\n                    + \" - \"\n                    + theQuery.neededResults()\n                    + \" links to be computed, \"\n                    + theQuery.itemsPerPage()\n                    + \" lines to be displayed\");\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(\n                new RSSMessage(\"Local Search Request\", theQuery.getQueryGoal().getQueryString(false), \"\"));\n            final long timestamp = System.currentTimeMillis();\n\n            // create a new search event\n            if ( SearchEventCache.getEvent(theQuery.id(false)) == null ) {\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\n                startRecord = 0;\n            }\n            final SearchEvent theSearch =\n                SearchEventCache.getEvent(\n                    theQuery,\n                    sb.peers,\n                    sb.tables,\n                    (sb.isRobinsonMode()) ? sb.clusterhashes : null,\n                    false,\n                    sb.loader,\n                    (int) sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\n                    sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXTIME_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)));\n\n            if ( startRecord == 0 ) {\n                if ( modifier.sitehost != null && sb.getConfigBool(SwitchboardConstants.HEURISTIC_SITE, false) && authenticated && !stealthmode) {\n                    sb.heuristicSite(theSearch, modifier.sitehost);\n                }\n                if ( heuristicBlekko >= 0  && authenticated && !stealthmode ) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n                if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, false) && authenticated && !stealthmode) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n            }\n\n            // log\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \"\n                + theQuery.getQueryGoal().getQueryString(false)\n                + \" - \"\n                + \"local_rwi_available(\" + theSearch.local_rwi_available.get() + \"), \"\n                + \"local_rwi_stored(\" + theSearch.local_rwi_stored.get() + \"), \"\n                + \"remote_rwi_available(\" + theSearch.remote_rwi_available.get() + \"), \"\n                + \"remote_rwi_stored(\" + theSearch.remote_rwi_stored.get() + \"), \"\n                + \"remote_rwi_peerCount(\" + theSearch.remote_rwi_peerCount.get() + \"), \"\n                + \"local_solr_available(\" + theSearch.local_solr_available.get() + \"), \"\n                + \"local_solr_stored(\" + theSearch.local_solr_stored.get() + \"), \"\n                + \"remote_solr_available(\" + theSearch.remote_solr_available.get() + \"), \"\n                + \"remote_solr_stored(\" + theSearch.remote_solr_stored.get() + \"), \"\n                + \"remote_solr_peerCount(\" + theSearch.remote_solr_peerCount.get() + \"), \"\n                + (System.currentTimeMillis() - timestamp)\n                + \" ms\");\n\n            // prepare search statistics\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\n            AccessTracker.add(AccessTracker.Location.local, theQuery, theSearch.getResultCount());\n\n            // check suggestions\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\n\n            prop.put(\"meanCount\", meanMax);\n            if ( meanMax > 0 && !json && !rss && sb.index.connectedRWI()) {\n                final DidYouMean didYouMean = new DidYouMean(indexSegment, querystring);\n                final Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\n                int meanCount = 0;\n                String suggestion;\n                try {\n                    meanCollect: while ( meanCount < meanMax && meanIt.hasNext() ) {\n                        try {\n                            suggestion = meanIt.next().toString();\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_word\", suggestion);\n                            prop.put(\n                                \"didYouMean_suggestions_\" + meanCount + \"_url\",\n                                QueryParams.navurl(\n                                    RequestHeader.FileType.HTML,\n                                    0,\n                                    theQuery,\n                                    suggestion, true).toString());\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_sep\", \"|\");\n                            meanCount++;\n                        } catch (final ConcurrentModificationException e) {\n                            ConcurrentLog.logException(e);\n                            break meanCollect;\n                        }\n                    }\n                } catch (final ConcurrentModificationException e) {\n                    ConcurrentLog.logException(e);\n                }\n                prop.put(\"didYouMean_suggestions_\" + (meanCount - 1) + \"_sep\", \"\");\n                prop.put(\"didYouMean\", meanCount > 0 ? 1 : 0);\n                prop.put(\"didYouMean_suggestions\", meanCount);\n            } else {\n                prop.put(\"didYouMean\", 0);\n            }\n\n            // find geographic info\n            final SortedSet<GeoLocation> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\n            if ( coordinates == null || coordinates.isEmpty() || startRecord > 0 ) {\n                prop.put(\"geoinfo\", \"0\");\n            } else {\n                int i = 0;\n                for ( final GeoLocation c : coordinates ) {\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\n                    i++;\n                    if ( i >= 10 ) {\n                        break;\n                    }\n                }\n                prop.put(\"geoinfo_loc\", i);\n                prop.put(\"geoinfo\", \"1\");\n            }\n\n            // update the search tracker\n            try {\n                synchronized ( trackerHandles ) {\n                    trackerHandles.add(theQuery.starttime);\n                    while ( trackerHandles.size() > 600 ) {\n                        if ( !trackerHandles.remove(trackerHandles.first()) ) {\n                            break;\n                        }\n                    }\n                }\n                sb.localSearchTracker.put(client, trackerHandles);\n                if ( sb.localSearchTracker.size() > 100 ) {\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\n                }\n                if ( MemoryControl.shortStatus() ) {\n                    sb.localSearchTracker.clear();\n                }\n            } catch (final Exception e ) {\n                ConcurrentLog.logException(e);\n            }\n\n            prop.put(\"num-results_offset\", startRecord);\n            prop.put(\"num-results_itemscount\", Formatter.number(startRecord + theSearch.query.itemsPerPage > theSearch.getResultCount() ? startRecord + theSearch.getResultCount() % theSearch.query.itemsPerPage : startRecord + theSearch.query.itemsPerPage, true));\n            prop.put(\"num-results_itemsPerPage\", Formatter.number(itemsPerPage));\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getResultCount())); // also in yacyserchtrailer (hint: timing in p2p search )\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n\n            // generate the search result lines; the content will be produced by another servlet\n            for ( int i = 0; i < theQuery.itemsPerPage(); i++ ) {\n                prop.put(\"results_\" + i + \"_item\", startRecord + i);\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\n            }\n            prop.put(\"results\", theQuery.itemsPerPage());\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\n\n            // process result of search\n            if ( !filtered.isEmpty() ) {\n                prop.put(\"excluded\", \"1\");\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\n            } else {\n                prop.put(\"excluded\", \"0\");\n            }\n\n            if (prop.isEmpty() || querystring.length() == 0) {\n                if ( querystring.length() == 0 ) { // querystring is trimmed originalquerystring\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\n                } else {\n                    prop.put(\"num-results\", \"1\"); // no results\n                }\n            } else {\n                prop.put(\"num-results\", \"3\");\n            }\n\n            prop.put(\"depth\", \"0\");\n\n        }\n        prop.put(\"focus\", focus ? 1 : 0); // focus search field\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\n        prop.putHTML(\"former\", originalquerystring.replaceAll(Segment.catchallString, \"*\"));\n        prop.put(\"count\", itemsPerPage);\n        prop.put(\"offset\", startRecord);\n        prop.put(\"resource\", global ? \"global\" : \"local\");\n        prop.putHTML(\"prefermaskfilter\", prefermask);\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n        prop.putHTML(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\n\n        // for RSS: don't HTML encode some elements\n        prop.putXML(\"rss_query\", originalquerystring);\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\n\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        // hostname and port (assume locahost if nothing helps)\n        final String hostIP = sb.peers.mySeed().getIP();\n        prop.put(\"myhost\", hostIP != null ? hostIP : Domains.LOCALHOST);\n        prop.put(\"myport\", Domains.LOCALHOST.equals(hostIP) ? sb.getLocalPort(\"port\", 8090) : sb.getPublicPort(\"port\", 8090));\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"6578ff3ddb1c9300e311360dfa2f02a1f64c7c61","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\n        public int compareTo( Object o )\n        {\n            return o instanceof IntegerElectionCredentials\n                    ? Integer.compare( credential, ( (IntegerElectionCredentials) o).credential )\n                    : 0;\n        }","id":67254,"modified_method":"@Override\n        public int compareTo( Object o )\n        {\n            return o instanceof IntegerElectionCredentials\n                    ? Integer.valueOf(credential).compareTo(Integer.valueOf(( (IntegerElectionCredentials) o).credential)) : 0;\n        }","commit_id":"c77956adf62d5283ea321c83f33bd3c557adb4c8","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n    MapEntry getEntry(String key) {\n        if (size == 0) {\n            return null;\n        }\n\n        Segment segment = getSegment();\n        int hash = checkNotNull(key).hashCode();\n\n        int d = -1;\n        for (int i = 0; i < size && d < 0; i++) {\n            d = Integer.compare(segment.readInt(getOffset(4 + i * 4)), hash);\n            if (d == 0) {\n                RecordId keyId = segment.readRecordId(\n                        getOffset(4 + size * 4, i));\n                d = segment.readString(keyId).compareTo(key);\n                if (d == 0) {\n                    RecordId valueId = segment.readRecordId(\n                            getOffset(4 + size * 4, size + i));\n                    return new MapEntry(segment, key, keyId, valueId);\n                }\n            }\n        }\n\n        return null;\n    }","id":67255,"modified_method":"@Override\n    MapEntry getEntry(String key) {\n        if (size == 0) {\n            return null;\n        }\n\n        Segment segment = getSegment();\n        int hash = checkNotNull(key).hashCode();\n\n        int d = -1;\n        for (int i = 0; i < size && d < 0; i++) {\n            d = Integer.valueOf(segment.readInt(getOffset(4 + i * 4)))\n                    .compareTo(Integer.valueOf(hash));\n            if (d == 0) {\n                RecordId keyId = segment.readRecordId(\n                        getOffset(4 + size * 4, i));\n                d = segment.readString(keyId).compareTo(key);\n                if (d == 0) {\n                    RecordId valueId = segment.readRecordId(\n                            getOffset(4 + size * 4, size + i));\n                    return new MapEntry(segment, key, keyId, valueId);\n                }\n            }\n        }\n\n        return null;\n    }","commit_id":"404393162d8057aabb074bd6f63c9d46d908a266","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public void compareAgainstBaseState(\n            SegmentReader reader, RecordId afterId,\n            Template beforeTemplate, RecordId beforeId,\n            NodeStateDiff diff) {\n        checkNotNull(reader);\n        checkNotNull(afterId);\n        checkNotNull(beforeTemplate);\n        checkNotNull(beforeId);\n        checkNotNull(diff);\n\n        // Compare type properties\n        compareProperties(beforeTemplate.primaryType, primaryType, diff);\n        compareProperties(beforeTemplate.mixinTypes, mixinTypes, diff);\n\n        // Compare other properties, leveraging the ordering\n        int beforeIndex = 0;\n        int afterIndex = 0;\n        while (beforeIndex < beforeTemplate.properties.length\n                && afterIndex < properties.length) {\n            int d = Integer.compare(\n                    properties[afterIndex].hashCode(),\n                    beforeTemplate.properties[beforeIndex].hashCode());\n            if (d == 0) {\n                d = properties[afterIndex].getName().compareTo(\n                        beforeTemplate.properties[beforeIndex].getName());\n            }\n            PropertyState beforeProperty = null;\n            PropertyState afterProperty = null;\n            if (d < 0) {\n                afterProperty = getProperty(reader, afterId, afterIndex++);\n            } else if (d > 0) {\n                beforeProperty = beforeTemplate.getProperty(\n                        reader, beforeId, beforeIndex++);\n            } else {\n                afterProperty = getProperty(reader, afterId, afterIndex++);\n                beforeProperty = beforeTemplate.getProperty(\n                        reader, beforeId, beforeIndex++);\n            }\n            compareProperties(beforeProperty, afterProperty, diff);\n        }\n        while (afterIndex < properties.length) {\n            diff.propertyAdded(getProperty(reader, afterId, afterIndex++));\n        }\n        while (beforeIndex < beforeTemplate.properties.length) {\n            diff.propertyDeleted(beforeTemplate.getProperty(\n                    reader, beforeId, beforeIndex++));\n        }\n\n        if (hasNoChildNodes()) {\n            if (!beforeTemplate.hasNoChildNodes()) {\n                for (ChildNodeEntry entry :\n                        beforeTemplate.getChildNodeEntries(reader, beforeId)) {\n                    diff.childNodeDeleted(\n                            entry.getName(), entry.getNodeState());\n                }\n            }\n        } else if (hasOneChildNode()) {\n            NodeState afterNode = getChildNode(childName, reader, afterId);\n            NodeState beforeNode = beforeTemplate.getChildNode(\n                    childName, reader, beforeId);\n            if (beforeNode == null) {\n                diff.childNodeAdded(childName, afterNode);\n            } else if (!beforeNode.equals(afterNode)) {\n                diff.childNodeChanged(childName, beforeNode, afterNode);\n            }\n            if ((beforeTemplate.hasOneChildNode() && beforeNode == null)\n                    || beforeTemplate.hasManyChildNodes()) {\n                for (ChildNodeEntry entry :\n                    beforeTemplate.getChildNodeEntries(reader, beforeId)) {\n                    if (!childName.equals(entry.getName())) {\n                        diff.childNodeDeleted(\n                                entry.getName(), entry.getNodeState());\n                    }\n                }\n            }\n        } else {\n            // TODO: Leverage the HAMT data structure for the comparison\n            Set<String> baseChildNodes = new HashSet<String>();\n            for (ChildNodeEntry beforeCNE\n                    : beforeTemplate.getChildNodeEntries(reader, beforeId)) {\n                String name = beforeCNE.getName();\n                NodeState beforeChild = beforeCNE.getNodeState();\n                NodeState afterChild = getChildNode(name, reader, afterId);\n                if (afterChild == null) {\n                    diff.childNodeDeleted(name, beforeChild);\n                } else {\n                    baseChildNodes.add(name);\n                    if (!beforeChild.equals(afterChild)) {\n                        diff.childNodeChanged(name, beforeChild, afterChild);\n                    }\n                }\n            }\n            for (ChildNodeEntry afterChild\n                    : getChildNodeEntries(reader, afterId)) {\n                String name = afterChild.getName();\n                if (!baseChildNodes.contains(name)) {\n                    diff.childNodeAdded(name, afterChild.getNodeState());\n                }\n            }\n        }\n    }","id":67256,"modified_method":"public void compareAgainstBaseState(\n            SegmentReader reader, RecordId afterId,\n            Template beforeTemplate, RecordId beforeId,\n            NodeStateDiff diff) {\n        checkNotNull(reader);\n        checkNotNull(afterId);\n        checkNotNull(beforeTemplate);\n        checkNotNull(beforeId);\n        checkNotNull(diff);\n\n        // Compare type properties\n        compareProperties(beforeTemplate.primaryType, primaryType, diff);\n        compareProperties(beforeTemplate.mixinTypes, mixinTypes, diff);\n\n        // Compare other properties, leveraging the ordering\n        int beforeIndex = 0;\n        int afterIndex = 0;\n        while (beforeIndex < beforeTemplate.properties.length\n                && afterIndex < properties.length) {\n            int d = Integer.valueOf(properties[afterIndex].hashCode())\n                    .compareTo(Integer.valueOf(beforeTemplate.properties[beforeIndex].hashCode()));\n            if (d == 0) {\n                d = properties[afterIndex].getName().compareTo(\n                        beforeTemplate.properties[beforeIndex].getName());\n            }\n            PropertyState beforeProperty = null;\n            PropertyState afterProperty = null;\n            if (d < 0) {\n                afterProperty = getProperty(reader, afterId, afterIndex++);\n            } else if (d > 0) {\n                beforeProperty = beforeTemplate.getProperty(\n                        reader, beforeId, beforeIndex++);\n            } else {\n                afterProperty = getProperty(reader, afterId, afterIndex++);\n                beforeProperty = beforeTemplate.getProperty(\n                        reader, beforeId, beforeIndex++);\n            }\n            compareProperties(beforeProperty, afterProperty, diff);\n        }\n        while (afterIndex < properties.length) {\n            diff.propertyAdded(getProperty(reader, afterId, afterIndex++));\n        }\n        while (beforeIndex < beforeTemplate.properties.length) {\n            diff.propertyDeleted(beforeTemplate.getProperty(\n                    reader, beforeId, beforeIndex++));\n        }\n\n        if (hasNoChildNodes()) {\n            if (!beforeTemplate.hasNoChildNodes()) {\n                for (ChildNodeEntry entry :\n                        beforeTemplate.getChildNodeEntries(reader, beforeId)) {\n                    diff.childNodeDeleted(\n                            entry.getName(), entry.getNodeState());\n                }\n            }\n        } else if (hasOneChildNode()) {\n            NodeState afterNode = getChildNode(childName, reader, afterId);\n            NodeState beforeNode = beforeTemplate.getChildNode(\n                    childName, reader, beforeId);\n            if (beforeNode == null) {\n                diff.childNodeAdded(childName, afterNode);\n            } else if (!beforeNode.equals(afterNode)) {\n                diff.childNodeChanged(childName, beforeNode, afterNode);\n            }\n            if ((beforeTemplate.hasOneChildNode() && beforeNode == null)\n                    || beforeTemplate.hasManyChildNodes()) {\n                for (ChildNodeEntry entry :\n                    beforeTemplate.getChildNodeEntries(reader, beforeId)) {\n                    if (!childName.equals(entry.getName())) {\n                        diff.childNodeDeleted(\n                                entry.getName(), entry.getNodeState());\n                    }\n                }\n            }\n        } else {\n            // TODO: Leverage the HAMT data structure for the comparison\n            Set<String> baseChildNodes = new HashSet<String>();\n            for (ChildNodeEntry beforeCNE\n                    : beforeTemplate.getChildNodeEntries(reader, beforeId)) {\n                String name = beforeCNE.getName();\n                NodeState beforeChild = beforeCNE.getNodeState();\n                NodeState afterChild = getChildNode(name, reader, afterId);\n                if (afterChild == null) {\n                    diff.childNodeDeleted(name, beforeChild);\n                } else {\n                    baseChildNodes.add(name);\n                    if (!beforeChild.equals(afterChild)) {\n                        diff.childNodeChanged(name, beforeChild, afterChild);\n                    }\n                }\n            }\n            for (ChildNodeEntry afterChild\n                    : getChildNodeEntries(reader, afterId)) {\n                String name = afterChild.getName();\n                if (!baseChildNodes.contains(name)) {\n                    diff.childNodeAdded(name, afterChild.getNodeState());\n                }\n            }\n        }\n    }","commit_id":"a68b1d217e42eed984d40dc0f288402389e78615","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public Object get(int index) {\n        Iterator iter = iterator();\n        for (int i = 0; iter.hasNext(); i++) {\n            Object value = iter.next();\n            if (i == index) {\n                return value;\n            }\n        }\n        return null;\n    }","id":67257,"modified_method":"public Object get(int index) {\n        dataSet.absolute(index);\n        return FlatpackConverter.toMap(dataSet);\n    }","commit_id":"912cb6cf19853fcbe1fd47d121f372d1579a2263","url":"https://github.com/apache/camel"},{"original_method":"public int size() {\n        int answer = 0;\n        for (Iterator iter = iterator(); iter.hasNext();) {\n            iter.next();\n            answer++;\n        }\n        return answer;\n    }","id":67258,"modified_method":"public int size() {\n        return dataSet.getRowCount();\n    }","commit_id":"912cb6cf19853fcbe1fd47d121f372d1579a2263","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Puts the values of the dataset into the map\n     * @param map\n     * @param dataSet\n     */\n    public static void putValues(Map<String, Object> map, DataSet dataSet) {\n        String[] columns = dataSet.getColumns();\n        for (String column : columns) {\n            // TODO deal with non-string types?\n            String value = dataSet.getString(column);\n            map.put(column, value);\n        }\n    }","id":67259,"modified_method":"/**\n     * Puts the values of the dataset into the map\n     */\n    public static void putValues(Map<String, Object> map, DataSet dataSet) {\n        boolean header = dataSet.isRecordID(FlatpackComponent.HEADER_ID);\n        boolean trailer = dataSet.isRecordID(FlatpackComponent.TRAILER_ID);\n\n        // the columns can vary depending on header, body or trailer\n        String[] columns;\n        if (header) {\n            columns = dataSet.getColumns(FlatpackComponent.HEADER_ID);\n        } else if (trailer) {\n            columns = dataSet.getColumns(FlatpackComponent.TRAILER_ID);\n        } else {\n            columns = dataSet.getColumns();\n        }\n\n        for (String column : columns) {\n            String value = dataSet.getString(column);\n            map.put(column, value);\n        }\n    }","commit_id":"912cb6cf19853fcbe1fd47d121f372d1579a2263","url":"https://github.com/apache/camel"},{"original_method":"static public junit.framework.Test suite() {\n        VoltServerConfig config = null;\n        final MultiConfigSuiteBuilder builder = new MultiConfigSuiteBuilder(TestCRUDSuite.class);\n\n        final VoltProjectBuilder project = new VoltProjectBuilder();\n\n        // necessary because at least one procedure is required\n        project.addStmtProcedure(\"CountP1\", \"select count(*) from p1;\");\n\n        try {\n            // a table that should generate procedures\n            project.addLiteralSchema(\n                    \"CREATE TABLE p1(a1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL, PRIMARY KEY (a1));\"\n            );\n            project.addPartitionInfo(\"p1\", \"a1\");\n\n            // a partitioned table that should not generate procedures (no pkey)\n            project.addLiteralSchema(\n                    \"CREATE TABLE p2(a1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL); \" +\n                    \"CREATE UNIQUE INDEX p2_tree_idx ON p2(a1);\"\n            );\n            project.addPartitionInfo(\"p2\", \"a1\");\n\n            // a partitioned table that should not generate procedures (pkey not partition key)\n            project.addLiteralSchema(\n                    \"CREATE TABLE p3(a1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL); \" +\n                    \"CREATE UNIQUE INDEX p3_tree_idx ON p3(a1);\"\n            );\n            project.addPartitionInfo(\"p3\", \"a2\");\n\n            // a replicated table (should not generate procedures).\n            project.addLiteralSchema(\n                    \"CREATE TABLE r1(a1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL, PRIMARY KEY (a1));\"\n            );\n        } catch (IOException error) {\n            fail(error.getMessage());\n        }\n\n        // JNI\n        config = new LocalSingleProcessServer(\"sqltypes-onesite.jar\", 1, BackendTarget.NATIVE_EE_JNI);\n        boolean t1 = config.compile(project);\n        assertTrue(t1);\n        builder.addServerConfig(config);\n\n        // CLUSTER\n        config = new LocalCluster(\"sqltypes-cluster.jar\", 2, 2, 1, BackendTarget.NATIVE_EE_JNI);\n        boolean t2 = config.compile(project);\n        assertTrue(t2);\n        builder.addServerConfig(config);\n\n        return builder;\n\n    }","id":67260,"modified_method":"static public junit.framework.Test suite() {\n        VoltServerConfig config = null;\n        final MultiConfigSuiteBuilder builder = new MultiConfigSuiteBuilder(TestCRUDSuite.class);\n\n        final VoltProjectBuilder project = new VoltProjectBuilder();\n\n        // necessary because at least one procedure is required\n        project.addStmtProcedure(\"CountP1\", \"select count(*) from p1;\");\n\n        try {\n            // a table that should generate procedures\n            // use column names such that lexical order != column order.\n            project.addLiteralSchema(\n                    \"CREATE TABLE p1(b1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL, PRIMARY KEY (b1));\"\n            );\n            project.addPartitionInfo(\"p1\", \"b1\");\n\n            // a partitioned table that should not generate procedures (no pkey)\n            project.addLiteralSchema(\n                    \"CREATE TABLE p2(a1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL); \" +\n                    \"CREATE UNIQUE INDEX p2_tree_idx ON p2(a1);\"\n            );\n            project.addPartitionInfo(\"p2\", \"a1\");\n\n            // a partitioned table that should not generate procedures (pkey not partition key)\n            project.addLiteralSchema(\n                    \"CREATE TABLE p3(a1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL); \" +\n                    \"CREATE UNIQUE INDEX p3_tree_idx ON p3(a1);\"\n            );\n            project.addPartitionInfo(\"p3\", \"a2\");\n\n            // a replicated table (should not generate procedures).\n            project.addLiteralSchema(\n                    \"CREATE TABLE r1(a1 INTEGER NOT NULL, a2 VARCHAR(10) NOT NULL, PRIMARY KEY (a1));\"\n            );\n\n            // table with a multi-column pkey. verify that pkey column ordering is\n            // in the index column order, not table order and not index column lex. order\n            project.addLiteralSchema(\n                    \"CREATE TABLE p4(z INTEGER NOT NULL, x VARCHAR(10) NOT NULL, y INTEGER NOT NULL, PRIMARY KEY(y,x,z));\"\n            );\n            project.addPartitionInfo(\"p4\", \"y\");\n\n        } catch (IOException error) {\n            fail(error.getMessage());\n        }\n\n        // JNI\n        config = new LocalSingleProcessServer(\"sqltypes-onesite.jar\", 1, BackendTarget.NATIVE_EE_JNI);\n        boolean t1 = config.compile(project);\n        assertTrue(t1);\n        builder.addServerConfig(config);\n\n        // CLUSTER\n        config = new LocalCluster(\"sqltypes-cluster.jar\", 2, 2, 1, BackendTarget.NATIVE_EE_JNI);\n        boolean t2 = config.compile(project);\n        assertTrue(t2);\n        builder.addServerConfig(config);\n\n        return builder;\n\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Helper to generate a WHERE pkey_col1 = ?, pkey_col2 = ? ...; clause.\n     * @param partitioncolumn partitioning column for the table\n     * @param pkey constraint from the catalog\n     * @param paramoffset 0-based counter of parameters in the full sql statement so far\n     * @param sb string buffer accumulating the sql statement\n     * @return partition key offset (which must be in the primary key)\n     */\n    private int generateCrudPKeyWhereClause(Column partitioncolumn,\n            Constraint pkey, int paramoffset, StringBuilder sb)\n    {\n        int partitionoffset = -1;\n        boolean first;\n        first = true;\n        sb.append(\" WHERE \");\n        for (ColumnRef pkc : pkey.getIndex().getColumns()) {\n            paramoffset++;\n            if (!first) sb.append(\" AND \");\n            first = false;\n            sb.append(\"(\" + pkc.getColumn().getName() + \" = ?\" + \")\");\n            if (pkc.getColumn() == partitioncolumn) {\n                partitionoffset = paramoffset;\n            }\n        }\n        sb.append(\";\");\n        return partitionoffset;\n    }","id":67261,"modified_method":"/**\n     * Helper to generate a WHERE pkey_col1 = ?, pkey_col2 = ? ...; clause.\n     * @param partitioncolumn partitioning column for the table\n     * @param pkey constraint from the catalog\n     * @param paramoffset 0-based counter of parameters in the full sql statement so far\n     * @param sb string buffer accumulating the sql statement\n     * @return offset in the index of the partition column\n     */\n    private int generateCrudPKeyWhereClause(Column partitioncolumn,\n            Constraint pkey, StringBuilder sb)\n    {\n        // Sort the catalog index columns by index column order.\n        ArrayList<ColumnRef> indexColumns = new ArrayList<ColumnRef>(pkey.getIndex().getColumns().size());\n        for (ColumnRef c : pkey.getIndex().getColumns()) {\n            indexColumns.add(c);\n        }\n        Collections.sort(indexColumns, new ColumnRefComparator());\n\n        boolean first = true;\n        int partitionOffset = -1;\n\n        sb.append(\" WHERE \");\n        for (ColumnRef pkc : indexColumns) {\n            if (!first) sb.append(\" AND \");\n            first = false;\n            sb.append(\"(\" + pkc.getColumn().getName() + \" = ?\" + \")\");\n            if (pkc.getColumn() == partitioncolumn) {\n                partitionOffset = pkc.getIndex();\n            }\n        }\n        sb.append(\";\");\n        return partitionOffset;\n\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Helper to generate a full col1, col2, col3 list.\n     */\n    private int generateCrudColumnList(Column partitioncolumn, Table table, StringBuilder sb) {\n        int partitionoffset = -1;\n        boolean first = true;\n        int paramoffset = -1;\n        sb.append(\"(\");\n        for (Column c : table.getColumns()) {\n            paramoffset++;\n            if (!first) sb.append(\", \");\n            first = false;\n            sb.append(\"?\");\n            if (c == partitioncolumn) {\n                partitionoffset = paramoffset;\n            }\n        }\n        sb.append(\")\");\n        return partitionoffset;\n    }","id":67262,"modified_method":"/**\n     * Helper to generate a full col1, col2, col3 list.\n     */\n    private void generateCrudColumnList(Table table, StringBuilder sb) {\n        boolean first = true;\n        sb.append(\"(\");\n\n        // Sort the catalog table columns by column order.\n        ArrayList<Column> tableColumns = new ArrayList<Column>(table.getColumns().size());\n        for (Column c : table.getColumns()) {\n            tableColumns.add(c);\n        }\n        Collections.sort(tableColumns, new TableColumnComparator());\n\n        // Output the SQL column list.\n        for (Column c : tableColumns) {\n            assert (c.getIndex() >= 0);  // mostly mask unused 'c'.\n            if (!first) sb.append(\", \");\n            first = false;\n            sb.append(\"?\");\n        }\n        sb.append(\")\");\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a statement like:\n     * \"update <table> set {<each-column = ?>...} where {<pkey-column = ?>...}\n     */\n    private ProcedureDescriptor generateCrudUpdate(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"UPDATE \" + table.getTypeName() + \" SET \");\n\n        int paramoffset =\n            generateCrudExpressionColumns(table, sb);\n\n        int partitionoffset =\n            generateCrudPKeyWhereClause(partitioncolumn, pkey, paramoffset, sb);\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitionoffset;\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".update\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.info(\"Synthesized built-in UPDATE procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","id":67263,"modified_method":"/**\n     * Create a statement like:\n     * \"update <table> set {<each-column = ?>...} where {<pkey-column = ?>...}\n     */\n    private ProcedureDescriptor generateCrudUpdate(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"UPDATE \" + table.getTypeName() + \" SET \");\n\n        generateCrudExpressionColumns(table, sb);\n        generateCrudPKeyWhereClause(partitioncolumn, pkey, sb);\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitioncolumn.getIndex();\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".update\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.info(\"Synthesized built-in UPDATE procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a statement like:\n     *  \"select * from <table> where pkey_col1 = ?, pkey_col2 = ? ... ;\"\n     */\n    private ProcedureDescriptor generateCrudSelect(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"SELECT * FROM \" + table.getTypeName());\n\n        int partitionoffset =\n            generateCrudPKeyWhereClause(partitioncolumn, pkey, -1, sb);\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitionoffset;\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".select\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.info(\"Synthesized built-in SELECT procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","id":67264,"modified_method":"/**\n     * Create a statement like:\n     *  \"select * from <table> where pkey_col1 = ?, pkey_col2 = ? ... ;\"\n     */\n    private ProcedureDescriptor generateCrudSelect(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"SELECT * FROM \" + table.getTypeName());\n\n        int partitionOffset =\n            generateCrudPKeyWhereClause(partitioncolumn, pkey, sb);\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitionOffset;\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".select\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.info(\"Synthesized built-in SELECT procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Helper to generate a full col1 = ?, col2 = ?... clause.\n     * @param table\n     * @param sb\n     * @return number of columns added (for partition key offset calculation).\n     */\n    private int generateCrudExpressionColumns(Table table, StringBuilder sb) {\n        boolean first = true;\n        int paramoffset = -1;\n        for (Column c : table.getColumns()) {\n            paramoffset++;\n            if (!first) sb.append(\", \");\n            first = false;\n            sb.append(c.getName() + \" = ?\");\n        }\n        return paramoffset;\n    }","id":67265,"modified_method":"/**\n     * Helper to generate a full col1 = ?, col2 = ?... clause.\n     * @param table\n     * @param sb\n     */\n    private void generateCrudExpressionColumns(Table table, StringBuilder sb) {\n        boolean first = true;\n\n        // Sort the catalog table columns by column order.\n        ArrayList<Column> tableColumns = new ArrayList<Column>(table.getColumns().size());\n        for (Column c : table.getColumns()) {\n            tableColumns.add(c);\n        }\n        Collections.sort(tableColumns, new TableColumnComparator());\n\n        for (Column c : tableColumns) {\n            if (!first) sb.append(\", \");\n            first = false;\n            sb.append(c.getName() + \" = ?\");\n        }\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a statement like:\n     *  \"delete from <table> where {<pkey-column =?>...}\"\n     */\n    private ProcedureDescriptor generateCrudDelete(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"DELETE FROM \" + table.getTypeName());\n\n        int partitionoffset =\n            generateCrudPKeyWhereClause(partitioncolumn, pkey, -1, sb);\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitionoffset;\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".delete\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.debug(\"Synthesized built-in DELETE procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","id":67266,"modified_method":"/**\n     * Create a statement like:\n     *  \"delete from <table> where {<pkey-column =?>...}\"\n     */\n    private ProcedureDescriptor generateCrudDelete(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"DELETE FROM \" + table.getTypeName());\n\n        int partitionOffset =\n            generateCrudPKeyWhereClause(partitioncolumn, pkey, sb);\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitionOffset;\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".delete\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.info(\"Synthesized built-in DELETE procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Create a statement like:\n     *  \"insert into <table> values (?, ?, ...);\"\n     */\n    private ProcedureDescriptor generateCrudInsert(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"INSERT INTO \" + table.getTypeName() + \" VALUES \");\n\n        int partitionoffset =\n            generateCrudColumnList(partitioncolumn, table, sb);\n        sb.append(\";\");\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitionoffset;\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".insert\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.info(\"Synthesized built-in INSERT procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","id":67267,"modified_method":"/**\n     * Create a statement like:\n     *  \"insert into <table> values (?, ?, ...);\"\n     */\n    private ProcedureDescriptor generateCrudInsert(Table table,\n            Column partitioncolumn, Constraint pkey)\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"INSERT INTO \" + table.getTypeName() + \" VALUES \");\n\n        generateCrudColumnList(table, sb);\n        sb.append(\";\");\n\n        String partitioninfo =\n            table.getTypeName() + \".\" + partitioncolumn.getName() + \":\" + partitioncolumn.getIndex();\n\n        ProcedureDescriptor pd =\n            new ProcedureDescriptor(\n                    new ArrayList<String>(),  // groups\n                    table.getTypeName() + \".insert\",        // className\n                    sb.toString(),            // singleStmt\n                    null,                     // joinOrder\n                    partitioninfo,            // table.column:offset\n                    true);                    // builtin statement\n\n        compilerLog.info(\"Synthesized built-in INSERT procedure: \" +\n                sb.toString() + \" for \" + table.getTypeName() + \" with partitioning: \" +\n                partitioninfo);\n\n        return pd;\n    }","commit_id":"7dd936554d1a59203b5e0eb5a5496044bf1d77c6","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static Session getSession(boolean cache) throws NamingException {\n\t\tSession session = PortalJNDIUtil.getMailSession();\n\n\t\tsession.setDebug(_log.isDebugEnabled());\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tsession.getProperties().list(System.out);\n\t\t}\n\n\t\treturn session;\n\t}","id":67268,"modified_method":"public static Session getSession(boolean cache) throws NamingException {\n\t\tSession session = PortalJNDIUtil.getMailSession();\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tsession.setDebug(true);\n\n\t\t\tsession.getProperties().list(System.out);\n\t\t}\n\n\t\treturn session;\n\t}","commit_id":"d2cb0e179522b2b63091a40c8a94860144abcf6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static void _send(\n\t\t\tSession session, Message msg, InternetAddress[] bulkAddresses) {\n\n\t\ttry {\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Trying to send a email using the following properties:\");\n\n\t\t\t\tStringWriter sw= new StringWriter();\n\t\t\t\tPrintWriter pw= new PrintWriter(sw);\n\t\t\t\tsession.getProperties().list(pw);\n\t\t\t\tpw.flush();\n\t\t\t\t_log.debug(sw.toString());\n\t\t\t}\n\n\t\t\tboolean smtpAuth = GetterUtil.getBoolean(\n\t\t\t\t_getSMTPProperty(session, \"auth\"), false);\n\t\t\tString smtpHost = _getSMTPProperty(session, \"host\");\n\t\t\tString smtpPort = _getSMTPProperty(session, \"port\");\n\t\t\tString user = _getSMTPProperty(session, \"user\");\n\t\t\tString password = _getSMTPProperty(session, \"password\");\n\n\t\t\tif (smtpAuth &&\n\t\t\t\tValidator.isNotNull(user) &&\n\t\t\t\tValidator.isNotNull(password)) {\n\n\t\t\t\tString protocol= session.getProperty(\"mail.transport.protocol\");\n\t\t\t\tif (Validator.isNull(protocol)) {\n\t\t\t\t\tprotocol= \"smtp\";\n\t\t\t\t}\n\n\t\t\t\tTransport transport = session.getTransport(protocol);\n\n\t\t\t\tif (Validator.isNotNull(smtpPort)\n\t\t\t\t\t&& Validator.isNumber(smtpPort)) {\n\n\t\t\t\t\ttransport.connect(\n\t\t\t\t\t\t\tsmtpHost, Integer.parseInt(smtpPort), user,\n\t\t\t\t\t\t\tpassword);\n\n\t\t\t\t} else {\n\t\t\t\t\ttransport.connect(smtpHost, user, password);\n\t\t\t\t}\n\n\t\t\t\tif (bulkAddresses != null && bulkAddresses.length > 0) {\n\t\t\t\t\ttransport.sendMessage(msg, bulkAddresses);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttransport.sendMessage(msg, msg.getAllRecipients());\n\t\t\t\t}\n\n\t\t\t\ttransport.close();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bulkAddresses != null) && (bulkAddresses.length > 0)) {\n\t\t\t\t\tTransport.send(msg, bulkAddresses);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tTransport.send(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tif (me.getNextException() instanceof SocketException) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Failed to connect to a valid mail server. Please \" +\n\t\t\t\t\t\t\t\"make sure one is properly configured. \" +\n\t\t\t\t\t\t\t\tme.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":67269,"modified_method":"private static void _send(\n\t\tSession session, Message msg, InternetAddress[] bulkAddresses) {\n\n\t\ttry {\n\t\t\tboolean smtpAuth = GetterUtil.getBoolean(\n\t\t\t\t_getSMTPProperty(session, \"auth\"), false);\n\t\t\tString smtpHost = _getSMTPProperty(session, \"host\");\n\t\t\tint smtpPort = GetterUtil.getInteger(\n\t\t\t\t_getSMTPProperty(session, \"port\"), _SMTP_PORT);\n\t\t\tString user = _getSMTPProperty(session, \"user\");\n\t\t\tString password = _getSMTPProperty(session, \"password\");\n\n\t\t\tif (smtpAuth && Validator.isNotNull(user) &&\n\t\t\t\tValidator.isNotNull(password)) {\n\n\t\t\t\tString protocol = GetterUtil.getString(\n\t\t\t\t\tsession.getProperty(\"mail.transport.protocol\"),\n\t\t\t\t\t_SMTP_PROTOCOL);\n\n\t\t\t\tTransport transport = session.getTransport(protocol);\n\n\t\t\t\ttransport.connect(smtpHost, smtpPort, user, password);\n\n\t\t\t\tif ((bulkAddresses != null) && (bulkAddresses.length > 0)) {\n\t\t\t\t\ttransport.sendMessage(msg, bulkAddresses);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttransport.sendMessage(msg, msg.getAllRecipients());\n\t\t\t\t}\n\n\t\t\t\ttransport.close();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif ((bulkAddresses != null) && (bulkAddresses.length > 0)) {\n\t\t\t\t\tTransport.send(msg, bulkAddresses);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tTransport.send(msg);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (MessagingException me) {\n\t\t\tif (me.getNextException() instanceof SocketException) {\n\t\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t\t_log.warn(\n\t\t\t\t\t\t\"Failed to connect to a valid mail server. Please \" +\n\t\t\t\t\t\t\t\"make sure one is properly configured. \" +\n\t\t\t\t\t\t\t\tme.getMessage());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"d2cb0e179522b2b63091a40c8a94860144abcf6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Session getSession(SMTPAccount smtpAccount)\n\t\tthrows NamingException {\n\n\t\tProperties properties = new Properties();\n\n\t\tSession session= null;\n\n\t\tString protocol= \"smtp\";\n\t\tString port= DEFAULT_SMTP_PORT;;\n\t\tif (smtpAccount != null && smtpAccount.isRequiresAuthentication()) {\n\n\t\t\tif (smtpAccount.isUseSSL()) {\n\n\t\t\t\tprotocol= \"smtps\";\n\n\t\t\t\tif (Validator.isNotNull(smtpAccount.getServerPort())) {\n\t\t\t\t\tport= String.valueOf(smtpAccount.getServerPort());\n\t\t\t\t} else {\n\t\t\t\t\tport= DEFAULT_SMTPS_PORT;\n\t\t\t\t}\n\n\t\t\t\tproperties.put(\"mail.\"+protocol+\".socketFactory.port\", port);\n\t\t\t\tproperties.put(\n\t\t\t\t\t\"mail.\"+protocol+\".socketFactory.class\",\n\t\t\t\t\t\"javax.net.ssl.SSLSocketFactory\");\n\t\t\t\tproperties.put(\n\t\t\t\t\t\"mail.\"+protocol+\".socketFactory.fallback\", \"false\");\n\n\t\t\t}\n\n\t\t\tproperties.put(\"mail.transport.protocol\", protocol);\n\t\t\tproperties.put(\"mail.\"+protocol+\".auth\", \"true\");\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\"+protocol+\".host\", smtpAccount.getServerName());\n\n\t\t\tif (Validator.isNotNull(smtpAccount.getServerPort())) {\n\t\t\t\tport= String.valueOf(smtpAccount.getServerPort());\n\t\t\t}\n\n\t\t\tproperties.put(\"mail.\"+protocol+\".port\", port);\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\"+protocol+\".user\", smtpAccount.getUserName());\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\"+protocol+\".password\", smtpAccount.getPassword());\n\n\t\t\tsession = Session.getInstance(properties);\n\t\t} else {\n\t\t\tsession= getSession();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tsession.setDebug(true);\n\t\t}\n\n\t\treturn session;\n\n\t}","id":67270,"modified_method":"public static Session getSession(SMTPAccount smtpAccount)\n\t\tthrows NamingException {\n\n\t\tSession session = null;\n\n\t\tif (smtpAccount.isRequiresAuthentication()) {\n\t\t\tString protocol = _SMTP_PROTOCOL;\n\n\t\t\tif (smtpAccount.isUseSSL()) {\n\t\t\t\tprotocol = _SMTPS_PROTOCOL;\n\t\t\t}\n\n\t\t\tint port = _SMTP_PORT;\n\n\t\t\tif (smtpAccount.getServerPort() > 0) {\n\t\t\t\tport = smtpAccount.getServerPort();\n\t\t\t}\n\n\t\t\tProperties properties = new Properties();\n\n\t\t\tproperties.put(\"mail.transport.protocol\", protocol);\n\t\t\tproperties.put(\"mail.\" + protocol + \".auth\", \"true\");\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\" + protocol + \".host\", smtpAccount.getServerName());\n\t\t\tproperties.put(\"mail.\" + protocol + \".port\", port);\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\" + protocol + \".user\", smtpAccount.getUserName());\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\" + protocol + \".password\", smtpAccount.getPassword());\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\" + protocol + \".socketFactory.class\",\n\t\t\t\t\"javax.net.ssl.SSLSocketFactory\");\n\t\t\tproperties.put(\n\t\t\t\t\"mail.\" + protocol + \".socketFactory.fallback\", \"false\");\n\n\t\t\tsession = Session.getInstance(properties);\n\t\t}\n\t\telse {\n\t\t\tsession = getSession();\n\t\t}\n\n\t\tif (_log.isDebugEnabled()) {\n\t\t\tsession.setDebug(true);\n\n\t\t\tsession.getProperties().list(System.out);\n\t\t}\n\n\t\treturn session;\n\t}","commit_id":"d2cb0e179522b2b63091a40c8a94860144abcf6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private static String _getSMTPProperty(\n\t\tSession session, String propertySuffix) {\n\n\t\tString property= session.getProperty(\"mail.smtp.\"+propertySuffix);\n\t\tif (property == null) {\n\t\t\tproperty= session.getProperty(\"mail.smtps.\"+propertySuffix);\n\t\t}\n\t\treturn property;\n\t}","id":67271,"modified_method":"private static String _getSMTPProperty(Session session, String suffix) {\n\t\tString value = session.getProperty(\"mail.smtp.\" + suffix);\n\n\t\tif (value == null) {\n\t\t\tvalue = session.getProperty(\"mail.smtps.\" + suffix);\n\t\t}\n\n\t\treturn value;\n\t}","commit_id":"d2cb0e179522b2b63091a40c8a94860144abcf6c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addLinkSteps(final String overlayName, final String serverGroup, final String[] deployments,\n            final boolean regexp, final ModelNode steps) {\n        for(String deployment : deployments) {\n            final ModelNode op = new ModelNode();\n            final ModelNode address = op.get(Util.ADDRESS);\n            if(serverGroup != null) {\n                address.add(Util.SERVER_GROUP, serverGroup);\n            }\n            address.add(Util.DEPLOYMENT_OVERLAY, overlayName);\n            address.add(Util.DEPLOYMENT, deployment);\n            op.get(Util.OPERATION).set(Util.ADD);\n            if(regexp) {\n                op.get(Util.REGULAR_EXPRESSION).set(true);\n            }\n            steps.add(op);\n        }\n    }","id":67272,"modified_method":"protected void addAddRedeployLinksSteps(CommandContext ctx, ModelNode steps,\n            String overlay, String serverGroup, String[] links, boolean regexp)\n                    throws CommandLineException {\n        for(String link : links) {\n            final ModelNode op = new ModelNode();\n            final ModelNode address = op.get(Util.ADDRESS);\n            if(serverGroup != null) {\n                address.add(Util.SERVER_GROUP, serverGroup);\n            }\n            address.add(Util.DEPLOYMENT_OVERLAY, overlay);\n            address.add(Util.DEPLOYMENT, link);\n            op.get(Util.OPERATION).set(Util.ADD);\n            if(regexp) {\n                op.get(Util.REGULAR_EXPRESSION).set(true);\n                steps.add(op);\n\n                final List<String> matchingDeployments = Util.getMatchingDeployments(ctx.getModelControllerClient(), link, serverGroup);\n                if(!matchingDeployments.isEmpty()) {\n                    if(serverGroup == null) {\n                        for(String deployment : matchingDeployments) {\n                            final ModelNode step = new ModelNode();\n                            final ModelNode addr = step.get(Util.ADDRESS);\n                            addr.add(Util.DEPLOYMENT, deployment);\n                            step.get(Util.OPERATION).set(Util.REDEPLOY);\n                            steps.add(step);\n                        }\n                    } else {\n                        for(String deployment : matchingDeployments) {\n                            final ModelNode step = new ModelNode();\n                            final ModelNode addr = step.get(Util.ADDRESS);\n                            addr.add(Util.SERVER_GROUP, serverGroup);\n                            addr.add(Util.DEPLOYMENT, deployment);\n                            step.get(Util.OPERATION).set(Util.REDEPLOY);\n                            steps.add(step);\n                        }\n                    }\n                }\n            } else if(redeployAffected.isPresent(ctx.getParsedCommandLine())) {\n                steps.add(op);\n\n                if(serverGroup == null) {\n                    if(Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT, link)) {\n                        final ModelNode step = new ModelNode();\n                        final ModelNode addr = step.get(Util.ADDRESS);\n                        addr.add(Util.DEPLOYMENT, link);\n                        step.get(Util.OPERATION).set(Util.REDEPLOY);\n                        steps.add(step);\n                    }\n                } else {\n                    if(Util.isValidPath(ctx.getModelControllerClient(), Util.SERVER_GROUP, serverGroup, Util.DEPLOYMENT, link)) {\n                        final ModelNode step = new ModelNode();\n                        final ModelNode addr = step.get(Util.ADDRESS);\n                        addr.add(Util.SERVER_GROUP, serverGroup);\n                        addr.add(Util.DEPLOYMENT, link);\n                        step.get(Util.OPERATION).set(Util.REDEPLOY);\n                        steps.add(step);\n                    }\n                }\n            } else {\n                steps.add(op);\n            }\n        }\n    }","commit_id":"6e4a3da6a7b173c07aa36c4320c016acba65aaf7","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void remove(CommandContext ctx) throws CommandLineException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        if(name == null) {\n            throw new CommandFormatException(this.name + \" is missing value.\");\n        }\n        final String contentStr = content.getValue(args);\n        String deploymentStr = deployments.getValue(args);\n        final String wildcardsStr = wildcards.getValue(args);\n        if(wildcardsStr != null) {\n            if(deploymentStr == null) {\n                deploymentStr = wildcardsStr;\n            } else {\n                deploymentStr += ',' + wildcardsStr;\n            }\n        }\n        final String sgStr = serverGroups.getValue(args);\n        final List<String> sg;\n        if(sgStr == null) {\n            if(allRelevantServerGroups.isPresent(args)) {\n                sg = Util.getServerGroupsReferencingOverlay(name, client);\n            } else {\n                sg = null;\n            }\n        } else {\n            sg = Arrays.asList(sgStr.split(\",+\"));\n            if(sg.isEmpty()) {\n                throw new CommandFormatException(serverGroups.getFullName() + \" is missing value.\");\n            }\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        byte redeploy = this.redeployAffected.isPresent(args) ? REDEPLOY_ONLY_AFFECTED : REDEPLOY_NONE;\n\n        // remove the content first and determine whether all the linked deployments\n        // should be redeployed\n        if(contentStr != null || deploymentStr == null && sg == null) {\n\n            if(redeploy == REDEPLOY_ONLY_AFFECTED) {\n                redeploy = REDEPLOY_ALL;\n            }\n\n            final List<String> contentList;\n            if(contentStr == null) {\n                contentList = loadContentFor(client, name);\n            } else {\n                contentList = java.util.Arrays.asList(contentStr.split(\",+\"));\n            }\n\n            for(String content : contentList) {\n                final ModelNode op = new ModelNode();\n                ModelNode addr = op.get(Util.ADDRESS);\n                addr.add(Util.DEPLOYMENT_OVERLAY, name);\n                addr.add(Util.CONTENT, content);\n                op.get(Util.OPERATION).set(Util.REMOVE);\n                steps.add(op);\n            }\n        }\n\n        if(deploymentStr != null || contentStr == null) {\n            // remove the overlay links\n\n            if(ctx.isDomainMode()) {\n                if(deploymentStr == null) {\n                    final List<String> groups = sg == null ? Util.getServerGroupsReferencingOverlay(name, client) : sg;\n                    for(String group : groups) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, null, true, redeploy);\n                    }\n                } else {\n                    if(ctx.isDomainMode() && sg == null) {\n                        throw new CommandFormatException(serverGroups.getFullName() + \" or \" + allRelevantServerGroups.getFullName() + \" is required.\");\n                    }\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    for(String group : sg) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, links, true, redeploy);\n                    }\n                }\n            } else {\n                if(deploymentStr == null) {\n                    // remove all\n                    addRemoveRedeployLinksSteps(client, steps, name, null, null, true, redeploy);\n                } else {\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    addRemoveRedeployLinksSteps(client, steps, name, null, links, true, redeploy);\n                }\n            }\n        } else if(redeploy == REDEPLOY_ALL) {\n            addRemoveRedeployLinksSteps(client, steps, name, null, null, false, redeploy);\n        }\n\n        if(contentStr == null && deploymentStr == null && sg == null) {\n            final ModelNode op = new ModelNode();\n            op.get(Util.ADDRESS).add(Util.DEPLOYMENT_OVERLAY, name);\n            op.get(Util.OPERATION).set(Util.REMOVE);\n            steps.add(op);\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(\"request: \" + composite.toString());\n                ctx.printLine(\"response: \" + result.toString());\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to remove overlay\", e);\n        }\n    }","id":67273,"modified_method":"protected void remove(CommandContext ctx) throws CommandLineException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        if(name == null) {\n            throw new CommandFormatException(this.name + \" is missing value.\");\n        }\n        final String contentStr = content.getValue(args);\n        String deploymentStr = deployments.getValue(args);\n        final String wildcardsStr = wildcards.getValue(args);\n        if(wildcardsStr != null) {\n            if(deploymentStr == null) {\n                deploymentStr = wildcardsStr;\n            } else {\n                deploymentStr += ',' + wildcardsStr;\n            }\n        }\n        final String sgStr = serverGroups.getValue(args);\n        final List<String> sg;\n        if(sgStr == null) {\n            if(allRelevantServerGroups.isPresent(args)) {\n                sg = Util.getServerGroupsReferencingOverlay(name, client);\n            } else {\n                sg = null;\n            }\n        } else {\n            sg = Arrays.asList(sgStr.split(\",+\"));\n            if(sg.isEmpty()) {\n                throw new CommandFormatException(serverGroups.getFullName() + \" is missing value.\");\n            }\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        byte redeploy = this.redeployAffected.isPresent(args) ? REDEPLOY_ONLY_AFFECTED : REDEPLOY_NONE;\n\n        // remove the content first and determine whether all the linked deployments\n        // should be redeployed\n        if(contentStr != null || deploymentStr == null && sg == null) {\n\n            if(redeploy == REDEPLOY_ONLY_AFFECTED) {\n                redeploy = REDEPLOY_ALL;\n            }\n\n            final List<String> contentList;\n            if(contentStr == null) {\n                contentList = loadContentFor(client, name);\n            } else {\n                contentList = java.util.Arrays.asList(contentStr.split(\",+\"));\n            }\n\n            for(String content : contentList) {\n                final ModelNode op = new ModelNode();\n                ModelNode addr = op.get(Util.ADDRESS);\n                addr.add(Util.DEPLOYMENT_OVERLAY, name);\n                addr.add(Util.CONTENT, content);\n                op.get(Util.OPERATION).set(Util.REMOVE);\n                steps.add(op);\n            }\n        }\n\n        if(deploymentStr != null || contentStr == null) {\n            // remove the overlay links\n\n            if(ctx.isDomainMode()) {\n                if(deploymentStr == null) {\n                    final List<String> groups = sg == null ? Util.getServerGroupsReferencingOverlay(name, client) : sg;\n                    for(String group : groups) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, null, true, redeploy);\n                    }\n                } else {\n                    if(ctx.isDomainMode() && sg == null) {\n                        throw new CommandFormatException(serverGroups.getFullName() + \" or \" + allRelevantServerGroups.getFullName() + \" is required.\");\n                    }\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    for(String group : sg) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, links, true, redeploy);\n                    }\n                }\n            } else {\n                if(deploymentStr == null) {\n                    // remove all\n                    addRemoveRedeployLinksSteps(client, steps, name, null, null, true, redeploy);\n                } else {\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    addRemoveRedeployLinksSteps(client, steps, name, null, links, true, redeploy);\n                }\n            }\n        } else if(redeploy == REDEPLOY_ALL) {\n            addRemoveRedeployLinksSteps(client, steps, name, null, null, false, redeploy);\n        }\n\n        if(contentStr == null && deploymentStr == null && sg == null) {\n            final ModelNode op = new ModelNode();\n            op.get(Util.ADDRESS).add(Util.DEPLOYMENT_OVERLAY, name);\n            op.get(Util.OPERATION).set(Util.REMOVE);\n            steps.add(op);\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(\"failed request: \" + composite.toString());\n                ctx.printLine(\"failed response: \" + result.toString());\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to remove overlay\", e);\n        }\n    }","commit_id":"6e4a3da6a7b173c07aa36c4320c016acba65aaf7","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void link(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n        if(deployments == null && wildcards == null) {\n            throw new CommandFormatException(\"Either \" + this.deployments.getFullName() + \" or \" + this.wildcards.getFullName() + \" is required.\");\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        if(ctx.isDomainMode()) {\n            final List<String> sg = getServerGroupsToLink(ctx);\n            for(String group : sg) {\n                if(!Util.isValidPath(ctx.getModelControllerClient(), Util.SERVER_GROUP, group, Util.DEPLOYMENT_OVERLAY, name)) {\n                    final ModelNode op = new ModelNode();\n                    final ModelNode address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                }\n                if(deployments != null) {\n                    addLinkSteps(name, group, deployments, false, steps);\n                }\n                if(wildcards != null) {\n                    addLinkSteps(name, group, wildcards, true, steps);\n                }\n            }\n        } else {\n            if(deployments != null) {\n                addLinkSteps(name, null, deployments, false, steps);\n            }\n            if(wildcards != null) {\n                addLinkSteps(name, null, wildcards, true, steps);\n            }\n        }\n\n        try {\n            final ModelNode result = ctx.getModelControllerClient().execute(composite);\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to link overlay\", e);\n        }\n    }","id":67274,"modified_method":"protected void link(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n        if(deployments == null && wildcards == null) {\n            throw new CommandFormatException(\"Either \" + this.deployments.getFullName() + \" or \" + this.wildcards.getFullName() + \" is required.\");\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        if(ctx.isDomainMode()) {\n            final List<String> sg = getServerGroupsToLink(ctx);\n            for(String group : sg) {\n                if(!Util.isValidPath(client, Util.SERVER_GROUP, group, Util.DEPLOYMENT_OVERLAY, name)) {\n                    final ModelNode op = new ModelNode();\n                    final ModelNode address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                }\n                if(deployments != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, group, deployments, false);\n                }\n                if(wildcards != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, group, wildcards, true);\n                }\n            }\n        } else {\n            if(deployments != null) {\n                addAddRedeployLinksSteps(ctx, steps, name, null, deployments, false);\n            }\n            if(wildcards != null) {\n                addAddRedeployLinksSteps(ctx, steps, name, null, wildcards, true);\n            }\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to link overlay\", e);\n        }\n    }","commit_id":"6e4a3da6a7b173c07aa36c4320c016acba65aaf7","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void upload(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(redeployAffected, args);\n\n        final String name = this.name.getValue(args, true);\n        if(!Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT_OVERLAY, name)) {\n            throw new CommandLineException(\"Deployment overlay \" + name + \" does not exist.\");\n        }\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String deploymentsStr = deployments.getValue(args);\n        if(deploymentsStr != null) {\n            throw new CommandFormatException(deployments.getFullName() + \" can't be used in combination with upload.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final ModelNode op = new ModelNode();\n            ModelNode address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentNames[i]);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","id":67275,"modified_method":"protected void upload(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args, true);\n        if(!Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT_OVERLAY, name)) {\n            throw new CommandLineException(\"Deployment overlay \" + name + \" does not exist.\");\n        }\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String deploymentsStr = deployments.getValue(args);\n        if(deploymentsStr != null) {\n            throw new CommandFormatException(deployments.getFullName() + \" can't be used in combination with upload.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final ModelNode op = new ModelNode();\n            ModelNode address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentNames[i]);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(redeployAffected.isPresent(args)) {\n            if(ctx.isDomainMode()) {\n                for(String sgName : Util.getServerGroups(client)) {\n                    addRemoveRedeployLinksSteps(client, steps, name, sgName, null, false, REDEPLOY_ALL);\n                }\n            } else {\n                addRemoveRedeployLinksSteps(client, steps, name, null, null, false, REDEPLOY_ALL);\n            }\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","commit_id":"6e4a3da6a7b173c07aa36c4320c016acba65aaf7","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void add(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the overlay\n        ModelNode op = new ModelNode();\n        ModelNode address = op.get(Util.ADDRESS);\n        address.add(Util.DEPLOYMENT_OVERLAY, name);\n        op.get(Util.OPERATION).set(Util.ADD);\n        steps.add(op);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final String contentName = contentNames[i];\n            op = new ModelNode();\n            address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentName);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(deployments != null || wildcards != null) {\n            if(ctx.isDomainMode()) {\n                final List<String> sg = getServerGroupsToLink(ctx);\n                for(String group : sg) {\n                    // here we don't need a separate check whether the overlay is linked\n                    // from the server group since it is created in the same op.\n                    op = new ModelNode();\n                    address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                    if(deployments != null) {\n                        addLinkSteps(name, group, deployments, false, steps);\n                    }\n                    if(wildcards != null) {\n                        addLinkSteps(name, group, wildcards, true, steps);\n                    }\n                }\n            } else {\n                if(deployments != null) {\n                    addLinkSteps(name, null, deployments, false, steps);\n                }\n                if(wildcards != null) {\n                    addLinkSteps(name, null, wildcards, true, steps);\n                }\n            }\n        } else if(ctx.isDomainMode() && (serverGroups.isPresent(args) || allServerGroups.isPresent(args))) {\n            throw new CommandFormatException(\"server groups are specified but neither \" + this.deployments.getFullName() +\n                    \" nor \" + this.wildcards.getFullName() + \" is.\");\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","id":67276,"modified_method":"protected void add(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the overlay\n        ModelNode op = new ModelNode();\n        ModelNode address = op.get(Util.ADDRESS);\n        address.add(Util.DEPLOYMENT_OVERLAY, name);\n        op.get(Util.OPERATION).set(Util.ADD);\n        steps.add(op);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final String contentName = contentNames[i];\n            op = new ModelNode();\n            address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentName);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(deployments != null || wildcards != null) {\n            if(ctx.isDomainMode()) {\n                final List<String> sg = getServerGroupsToLink(ctx);\n                for(String group : sg) {\n                    // here we don't need a separate check whether the overlay is linked\n                    // from the server group since it is created in the same op.\n                    op = new ModelNode();\n                    address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                    if(deployments != null) {\n                        addAddRedeployLinksSteps(ctx, steps, name, group, deployments, false);\n                    }\n                    if(wildcards != null) {\n                        addAddRedeployLinksSteps(ctx, steps, name, group, wildcards, true);\n                    }\n                }\n            } else {\n                if(deployments != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, null, deployments, false);\n                }\n                if(wildcards != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, null, wildcards, true);\n                }\n            }\n        } else if(ctx.isDomainMode() && (serverGroups.isPresent(args) || allServerGroups.isPresent(args))) {\n            throw new CommandFormatException(\"server groups are specified but neither \" + this.deployments.getFullName() +\n                    \" nor \" + this.wildcards.getFullName() + \" is.\");\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","commit_id":"6e4a3da6a7b173c07aa36c4320c016acba65aaf7","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ModelNode buildRequestWithoutHeaders(CommandContext ctx) throws CommandFormatException {\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args);\n        final boolean keepContent = this.keepContent.isPresent(args);\n        final boolean allRelevantServerGroups = this.allRelevantServerGroups.isPresent(args);\n        final String serverGroupsStr = this.serverGroups.getValue(args);\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                throw new OperationFormatException(\"Path '\" + f.getAbsolutePath() + \"' doesn't exist.\");\n            }\n            if(!isCliArchive(f)) {\n                throw new OperationFormatException(\"File '\" + f.getAbsolutePath() + \"' is not a valid CLI archive. CLI archives should have a '.cli' extension.\");\n            }\n        } else {\n            f = null;\n        }\n        if (isCliArchive(f)) {\n            if (name != null) {\n                throw new OperationFormatException(this.name.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            if(serverGroupsStr != null || allRelevantServerGroups) {\n                throw new OperationFormatException(this.serverGroups.getFullName() + \" and \" + this.allRelevantServerGroups.getFullName() +\n                        \" can't be used in combination with a CLI archive.\");\n            }\n\n            if (keepContent) {\n                throw new OperationFormatException(this.keepContent.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            MountHandle root;\n            try {\n                root = extractArchive(f);\n            } catch (IOException e) {\n                throw new OperationFormatException(\"Unable to extract archive '\" + f.getAbsolutePath() + \"' to temporary location\");\n            }\n\n            final File currentDir = ctx.getCurrentDir();\n            ctx.setCurrentDir(root.getMountSource());\n            String holdbackBatch = activateNewBatch(ctx);\n\n            try {\n                String script = this.script.getValue(args);\n                if (script == null) {\n                    script = \"undeploy.scr\";\n                }\n\n                File scriptFile = new File(ctx.getCurrentDir(),script);\n                if (!scriptFile.exists()) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                }\n\n                BufferedReader reader = null;\n                try {\n                    reader = new BufferedReader(new FileReader(scriptFile));\n                    String line = reader.readLine();\n                    while (!ctx.isTerminated() && line != null) {\n                        ctx.handle(line);\n                        line = reader.readLine();\n                    }\n                } catch (FileNotFoundException e) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                } catch (IOException e) {\n                    throw new CommandFormatException(\"Failed to read the next command from \" + scriptFile.getName() + \": \" + e.getMessage(), e);\n                } catch (CommandLineException e) {\n                    throw new CommandFormatException(e.getMessage(), e);\n                } finally {\n                    if(reader != null) {\n                        try {\n                            reader.close();\n                        } catch (IOException e) {\n                        }\n                    }\n                }\n\n                return ctx.getBatchManager().getActiveBatch().toRequest();\n            } finally {\n                // reset current dir in context\n                ctx.setCurrentDir(currentDir);\n                discardBatch(ctx, holdbackBatch);\n                try {\n                    root.close();\n                } catch (IOException ignore) {}\n            }\n        }\n\n        if(name == null) {\n            throw new OperationFormatException(\"Deployment name is missing.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        DefaultOperationRequestBuilder builder;\n\n        final List<String> deploymentNames;\n        if(name.indexOf('*') < 0) {\n            deploymentNames = Collections.singletonList(name);\n        } else {\n            deploymentNames = Util.getMatchingDeployments(client, name);\n            if(deploymentNames.isEmpty()) {\n                throw new CommandFormatException(\"No deployment matched wildcard expression \" + name);\n            }\n        }\n\n        for(String deploymentName : deploymentNames) {\n\n            final List<String> serverGroups;\n            if(ctx.isDomainMode()) {\n                if(allRelevantServerGroups) {\n                    if(keepContent) {\n                        serverGroups = Util.getAllEnabledServerGroups(deploymentName, client);\n                    } else {\n                        try {\n                            serverGroups = Util.getServerGroupsReferencingDeployment(deploymentName, client);\n                        } catch (CommandLineException e) {\n                            throw new CommandFormatException(\"Failed to retrieve all referencing server groups\", e);\n                        }\n                    }\n                } else {\n                    if(serverGroupsStr == null) {\n                        //throw new OperationFormatException(\"Either --all-relevant-server-groups or --server-groups must be specified.\");\n                        serverGroups = Collections.emptyList();\n                    } else {\n                        serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                    }\n                }\n\n                if(serverGroups.isEmpty()) {\n                    if(keepContent) {\n                        throw new OperationFormatException(\"None of the server groups is specified or references specified deployment.\");\n                    }\n                } else {\n                    for (String group : serverGroups){\n                        ModelNode groupStep = Util.configureDeploymentOperation(Util.UNDEPLOY, deploymentName, group);\n                        steps.add(groupStep);\n//                      if(!keepContent) {\n                            groupStep = Util.configureDeploymentOperation(Util.REMOVE, deploymentName, group);\n                            steps.add(groupStep);\n//                      }\n                    }\n                }\n            } else {\n                if(Util.isDeployedAndEnabledInStandalone(deploymentName, client)) {\n                    builder = new DefaultOperationRequestBuilder();\n                    builder.setOperationName(Util.UNDEPLOY);\n                    builder.addNode(Util.DEPLOYMENT, deploymentName);\n                    steps.add(builder.buildRequest());\n                }\n            }\n        }\n\n        if (!keepContent) {\n            for(String deploymentName : deploymentNames) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(Util.REMOVE);\n                builder.addNode(Util.DEPLOYMENT, deploymentName);\n                steps.add(builder.buildRequest());\n            }\n        }\n        return composite;\n    }","id":67277,"modified_method":"@Override\n    public ModelNode buildRequestWithoutHeaders(CommandContext ctx) throws CommandFormatException {\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args);\n        final boolean keepContent = this.keepContent.isPresent(args);\n        final boolean allRelevantServerGroups = this.allRelevantServerGroups.isPresent(args);\n        final String serverGroupsStr = this.serverGroups.getValue(args);\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                throw new OperationFormatException(\"Path '\" + f.getAbsolutePath() + \"' doesn't exist.\");\n            }\n            if(!isCliArchive(f)) {\n                throw new OperationFormatException(\"File '\" + f.getAbsolutePath() + \"' is not a valid CLI archive. CLI archives should have a '.cli' extension.\");\n            }\n        } else {\n            f = null;\n        }\n        if (isCliArchive(f)) {\n            if (name != null) {\n                throw new OperationFormatException(this.name.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            if(serverGroupsStr != null || allRelevantServerGroups) {\n                throw new OperationFormatException(this.serverGroups.getFullName() + \" and \" + this.allRelevantServerGroups.getFullName() +\n                        \" can't be used in combination with a CLI archive.\");\n            }\n\n            if (keepContent) {\n                throw new OperationFormatException(this.keepContent.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            MountHandle root;\n            try {\n                root = extractArchive(f);\n            } catch (IOException e) {\n                throw new OperationFormatException(\"Unable to extract archive '\" + f.getAbsolutePath() + \"' to temporary location\");\n            }\n\n            final File currentDir = ctx.getCurrentDir();\n            ctx.setCurrentDir(root.getMountSource());\n            String holdbackBatch = activateNewBatch(ctx);\n\n            try {\n                String script = this.script.getValue(args);\n                if (script == null) {\n                    script = \"undeploy.scr\";\n                }\n\n                File scriptFile = new File(ctx.getCurrentDir(),script);\n                if (!scriptFile.exists()) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                }\n\n                BufferedReader reader = null;\n                try {\n                    reader = new BufferedReader(new FileReader(scriptFile));\n                    String line = reader.readLine();\n                    while (!ctx.isTerminated() && line != null) {\n                        ctx.handle(line);\n                        line = reader.readLine();\n                    }\n                } catch (FileNotFoundException e) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                } catch (IOException e) {\n                    throw new CommandFormatException(\"Failed to read the next command from \" + scriptFile.getName() + \": \" + e.getMessage(), e);\n                } catch (CommandLineException e) {\n                    throw new CommandFormatException(e.getMessage(), e);\n                } finally {\n                    if(reader != null) {\n                        try {\n                            reader.close();\n                        } catch (IOException e) {\n                        }\n                    }\n                }\n\n                return ctx.getBatchManager().getActiveBatch().toRequest();\n            } finally {\n                // reset current dir in context\n                ctx.setCurrentDir(currentDir);\n                discardBatch(ctx, holdbackBatch);\n                try {\n                    root.close();\n                } catch (IOException ignore) {}\n            }\n        }\n\n        if(name == null) {\n            throw new OperationFormatException(\"Deployment name is missing.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        DefaultOperationRequestBuilder builder;\n\n        final List<String> deploymentNames;\n        if(name.indexOf('*') < 0) {\n            deploymentNames = Collections.singletonList(name);\n        } else {\n            deploymentNames = Util.getMatchingDeployments(client, name, null);\n            if(deploymentNames.isEmpty()) {\n                throw new CommandFormatException(\"No deployment matched wildcard expression \" + name);\n            }\n        }\n\n        for(String deploymentName : deploymentNames) {\n\n            final List<String> serverGroups;\n            if(ctx.isDomainMode()) {\n                if(allRelevantServerGroups) {\n                    if(keepContent) {\n                        serverGroups = Util.getAllEnabledServerGroups(deploymentName, client);\n                    } else {\n                        try {\n                            serverGroups = Util.getServerGroupsReferencingDeployment(deploymentName, client);\n                        } catch (CommandLineException e) {\n                            throw new CommandFormatException(\"Failed to retrieve all referencing server groups\", e);\n                        }\n                    }\n                } else {\n                    if(serverGroupsStr == null) {\n                        //throw new OperationFormatException(\"Either --all-relevant-server-groups or --server-groups must be specified.\");\n                        serverGroups = Collections.emptyList();\n                    } else {\n                        serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                    }\n                }\n\n                if(serverGroups.isEmpty()) {\n                    if(keepContent) {\n                        throw new OperationFormatException(\"None of the server groups is specified or references specified deployment.\");\n                    }\n                } else {\n                    for (String group : serverGroups){\n                        ModelNode groupStep = Util.configureDeploymentOperation(Util.UNDEPLOY, deploymentName, group);\n                        steps.add(groupStep);\n//                      if(!keepContent) {\n                            groupStep = Util.configureDeploymentOperation(Util.REMOVE, deploymentName, group);\n                            steps.add(groupStep);\n//                      }\n                    }\n                }\n            } else {\n                if(Util.isDeployedAndEnabledInStandalone(deploymentName, client)) {\n                    builder = new DefaultOperationRequestBuilder();\n                    builder.setOperationName(Util.UNDEPLOY);\n                    builder.addNode(Util.DEPLOYMENT, deploymentName);\n                    steps.add(builder.buildRequest());\n                }\n            }\n        }\n\n        if (!keepContent) {\n            for(String deploymentName : deploymentNames) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(Util.REMOVE);\n                builder.addNode(Util.DEPLOYMENT, deploymentName);\n                steps.add(builder.buildRequest());\n            }\n        }\n        return composite;\n    }","commit_id":"6e4a3da6a7b173c07aa36c4320c016acba65aaf7","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static List<String> getMatchingDeployments(ModelControllerClient client, String wildcardExpr) {\n\n        final DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n        final ModelNode request;\n        try {\n            builder.setOperationName(Util.READ_CHILDREN_NAMES);\n            builder.addProperty(Util.CHILD_TYPE, Util.DEPLOYMENT);\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            final ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                return getList(outcome, wildcardExpr);\n            }\n        } catch (Exception e) {\n        }\n\n        return Collections.emptyList();\n    }","id":67278,"modified_method":"public static List<String> getMatchingDeployments(ModelControllerClient client, String wildcardExpr, String serverGroup) {\n\n        final DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n        final ModelNode request;\n        try {\n            if(serverGroup != null) {\n                builder.addNode(Util.SERVER_GROUP, serverGroup);\n            }\n            builder.setOperationName(Util.READ_CHILDREN_NAMES);\n            builder.addProperty(Util.CHILD_TYPE, Util.DEPLOYMENT);\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            final ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                return getList(outcome, wildcardExpr);\n            }\n        } catch (Exception e) {\n        }\n\n        return Collections.emptyList();\n    }","commit_id":"6e4a3da6a7b173c07aa36c4320c016acba65aaf7","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void remove(CommandContext ctx) throws CommandLineException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        if(name == null) {\n            throw new CommandFormatException(this.name + \" is missing value.\");\n        }\n        final String contentStr = content.getValue(args);\n        String deploymentStr = deployments.getValue(args);\n        final String wildcardsStr = wildcards.getValue(args);\n        if(wildcardsStr != null) {\n            if(deploymentStr == null) {\n                deploymentStr = wildcardsStr;\n            } else {\n                deploymentStr += ',' + wildcardsStr;\n            }\n        }\n        final String sgStr = serverGroups.getValue(args);\n        final List<String> sg;\n        if(sgStr == null) {\n            if(allRelevantServerGroups.isPresent(args)) {\n                sg = Util.getServerGroupsReferencingOverlay(name, client);\n            } else {\n                sg = null;\n            }\n        } else {\n            sg = Arrays.asList(sgStr.split(\",+\"));\n            if(sg.isEmpty()) {\n                throw new CommandFormatException(serverGroups.getFullName() + \" is missing value.\");\n            }\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        byte redeploy = this.redeployAffected.isPresent(args) ? REDEPLOY_ONLY_AFFECTED : REDEPLOY_NONE;\n\n        // remove the content first and determine whether all the linked deployments\n        // should be redeployed\n        if(contentStr != null || deploymentStr == null && sg == null) {\n\n            if(redeploy == REDEPLOY_ONLY_AFFECTED) {\n                redeploy = REDEPLOY_ALL;\n            }\n\n            final List<String> contentList;\n            if(contentStr == null) {\n                contentList = loadContentFor(client, name);\n            } else {\n                contentList = java.util.Arrays.asList(contentStr.split(\",+\"));\n            }\n\n            for(String content : contentList) {\n                final ModelNode op = new ModelNode();\n                ModelNode addr = op.get(Util.ADDRESS);\n                addr.add(Util.DEPLOYMENT_OVERLAY, name);\n                addr.add(Util.CONTENT, content);\n                op.get(Util.OPERATION).set(Util.REMOVE);\n                steps.add(op);\n            }\n        }\n\n        if(deploymentStr != null || contentStr == null) {\n            // remove the overlay links\n\n            if(ctx.isDomainMode()) {\n                if(deploymentStr == null) {\n                    final List<String> groups = sg == null ? Util.getServerGroupsReferencingOverlay(name, client) : sg;\n                    for(String group : groups) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, null, true, redeploy);\n                    }\n                } else {\n                    if(ctx.isDomainMode() && sg == null) {\n                        throw new CommandFormatException(serverGroups.getFullName() + \" or \" + allRelevantServerGroups.getFullName() + \" is required.\");\n                    }\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    for(String group : sg) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, links, true, redeploy);\n                    }\n                }\n            } else {\n                if(deploymentStr == null) {\n                    // remove all\n                    addRemoveRedeployLinksSteps(client, steps, name, null, null, true, redeploy);\n                } else {\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    addRemoveRedeployLinksSteps(client, steps, name, null, links, true, redeploy);\n                }\n            }\n        } else if(redeploy == REDEPLOY_ALL) {\n            addRemoveRedeployLinksSteps(client, steps, name, null, null, false, redeploy);\n        }\n\n        if(contentStr == null && deploymentStr == null && sg == null) {\n            final ModelNode op = new ModelNode();\n            op.get(Util.ADDRESS).add(Util.DEPLOYMENT_OVERLAY, name);\n            op.get(Util.OPERATION).set(Util.REMOVE);\n            steps.add(op);\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(\"request: \" + composite.toString());\n                ctx.printLine(\"response: \" + result.toString());\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to remove overlay\", e);\n        }\n    }","id":67279,"modified_method":"protected void remove(CommandContext ctx) throws CommandLineException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        if(name == null) {\n            throw new CommandFormatException(this.name + \" is missing value.\");\n        }\n        final String contentStr = content.getValue(args);\n        String deploymentStr = deployments.getValue(args);\n        final String wildcardsStr = wildcards.getValue(args);\n        if(wildcardsStr != null) {\n            if(deploymentStr == null) {\n                deploymentStr = wildcardsStr;\n            } else {\n                deploymentStr += ',' + wildcardsStr;\n            }\n        }\n        final String sgStr = serverGroups.getValue(args);\n        final List<String> sg;\n        if(sgStr == null) {\n            if(allRelevantServerGroups.isPresent(args)) {\n                sg = Util.getServerGroupsReferencingOverlay(name, client);\n            } else {\n                sg = null;\n            }\n        } else {\n            sg = Arrays.asList(sgStr.split(\",+\"));\n            if(sg.isEmpty()) {\n                throw new CommandFormatException(serverGroups.getFullName() + \" is missing value.\");\n            }\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        byte redeploy = this.redeployAffected.isPresent(args) ? REDEPLOY_ONLY_AFFECTED : REDEPLOY_NONE;\n\n        // remove the content first and determine whether all the linked deployments\n        // should be redeployed\n        if(contentStr != null || deploymentStr == null && sg == null) {\n\n            if(redeploy == REDEPLOY_ONLY_AFFECTED) {\n                redeploy = REDEPLOY_ALL;\n            }\n\n            final List<String> contentList;\n            if(contentStr == null) {\n                contentList = loadContentFor(client, name);\n            } else {\n                contentList = java.util.Arrays.asList(contentStr.split(\",+\"));\n            }\n\n            for(String content : contentList) {\n                final ModelNode op = new ModelNode();\n                ModelNode addr = op.get(Util.ADDRESS);\n                addr.add(Util.DEPLOYMENT_OVERLAY, name);\n                addr.add(Util.CONTENT, content);\n                op.get(Util.OPERATION).set(Util.REMOVE);\n                steps.add(op);\n            }\n        }\n\n        if(deploymentStr != null || contentStr == null) {\n            // remove the overlay links\n\n            if(ctx.isDomainMode()) {\n                if(deploymentStr == null) {\n                    final List<String> groups = sg == null ? Util.getServerGroupsReferencingOverlay(name, client) : sg;\n                    for(String group : groups) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, null, true, redeploy);\n                    }\n                } else {\n                    if(ctx.isDomainMode() && sg == null) {\n                        throw new CommandFormatException(serverGroups.getFullName() + \" or \" + allRelevantServerGroups.getFullName() + \" is required.\");\n                    }\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    for(String group : sg) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, links, true, redeploy);\n                    }\n                }\n            } else {\n                if(deploymentStr == null) {\n                    // remove all\n                    addRemoveRedeployLinksSteps(client, steps, name, null, null, true, redeploy);\n                } else {\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    addRemoveRedeployLinksSteps(client, steps, name, null, links, true, redeploy);\n                }\n            }\n        } else if(redeploy == REDEPLOY_ALL) {\n            addRemoveRedeployLinksSteps(client, steps, name, null, null, false, redeploy);\n        }\n\n        if(contentStr == null && deploymentStr == null && sg == null) {\n            final ModelNode op = new ModelNode();\n            op.get(Util.ADDRESS).add(Util.DEPLOYMENT_OVERLAY, name);\n            op.get(Util.OPERATION).set(Util.REMOVE);\n            steps.add(op);\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(\"failed request: \" + composite.toString());\n                ctx.printLine(\"failed response: \" + result.toString());\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to remove overlay\", e);\n        }\n    }","commit_id":"818fea6f7b327d077b2f038f77d25bb6cadc62dc","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void add(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the overlay\n        ModelNode op = new ModelNode();\n        ModelNode address = op.get(Util.ADDRESS);\n        address.add(Util.DEPLOYMENT_OVERLAY, name);\n        op.get(Util.OPERATION).set(Util.ADD);\n        steps.add(op);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final String contentName = contentNames[i];\n            op = new ModelNode();\n            address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentName);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(deployments != null || wildcards != null) {\n            if(ctx.isDomainMode()) {\n                final List<String> sg = getServerGroupsToLink(ctx);\n                for(String group : sg) {\n                    // here we don't need a separate check whether the overlay is linked\n                    // from the server group since it is created in the same op.\n                    op = new ModelNode();\n                    address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                    if(deployments != null) {\n                        addLinkSteps(name, group, deployments, false, steps);\n                    }\n                    if(wildcards != null) {\n                        addLinkSteps(name, group, wildcards, true, steps);\n                    }\n                }\n            } else {\n                if(deployments != null) {\n                    addLinkSteps(name, null, deployments, false, steps);\n                }\n                if(wildcards != null) {\n                    addLinkSteps(name, null, wildcards, true, steps);\n                }\n            }\n        } else if(ctx.isDomainMode() && (serverGroups.isPresent(args) || allServerGroups.isPresent(args))) {\n            throw new CommandFormatException(\"server groups are specified but neither \" + this.deployments.getFullName() +\n                    \" nor \" + this.wildcards.getFullName() + \" is.\");\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","id":67280,"modified_method":"protected void add(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the overlay\n        ModelNode op = new ModelNode();\n        ModelNode address = op.get(Util.ADDRESS);\n        address.add(Util.DEPLOYMENT_OVERLAY, name);\n        op.get(Util.OPERATION).set(Util.ADD);\n        steps.add(op);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final String contentName = contentNames[i];\n            op = new ModelNode();\n            address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentName);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(deployments != null || wildcards != null) {\n            if(ctx.isDomainMode()) {\n                final List<String> sg = getServerGroupsToLink(ctx);\n                for(String group : sg) {\n                    // here we don't need a separate check whether the overlay is linked\n                    // from the server group since it is created in the same op.\n                    op = new ModelNode();\n                    address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                    if(deployments != null) {\n                        addAddRedeployLinksSteps(ctx, steps, name, group, deployments, false);\n                    }\n                    if(wildcards != null) {\n                        addAddRedeployLinksSteps(ctx, steps, name, group, wildcards, true);\n                    }\n                }\n            } else {\n                if(deployments != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, null, deployments, false);\n                }\n                if(wildcards != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, null, wildcards, true);\n                }\n            }\n        } else if(ctx.isDomainMode() && (serverGroups.isPresent(args) || allServerGroups.isPresent(args))) {\n            throw new CommandFormatException(\"server groups are specified but neither \" + this.deployments.getFullName() +\n                    \" nor \" + this.wildcards.getFullName() + \" is.\");\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","commit_id":"818fea6f7b327d077b2f038f77d25bb6cadc62dc","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void upload(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(redeployAffected, args);\n\n        final String name = this.name.getValue(args, true);\n        if(!Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT_OVERLAY, name)) {\n            throw new CommandLineException(\"Deployment overlay \" + name + \" does not exist.\");\n        }\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String deploymentsStr = deployments.getValue(args);\n        if(deploymentsStr != null) {\n            throw new CommandFormatException(deployments.getFullName() + \" can't be used in combination with upload.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final ModelNode op = new ModelNode();\n            ModelNode address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentNames[i]);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","id":67281,"modified_method":"protected void upload(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args, true);\n        if(!Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT_OVERLAY, name)) {\n            throw new CommandLineException(\"Deployment overlay \" + name + \" does not exist.\");\n        }\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String deploymentsStr = deployments.getValue(args);\n        if(deploymentsStr != null) {\n            throw new CommandFormatException(deployments.getFullName() + \" can't be used in combination with upload.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final ModelNode op = new ModelNode();\n            ModelNode address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentNames[i]);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(redeployAffected.isPresent(args)) {\n            if(ctx.isDomainMode()) {\n                for(String sgName : Util.getServerGroups(client)) {\n                    addRemoveRedeployLinksSteps(client, steps, name, sgName, null, false, REDEPLOY_ALL);\n                }\n            } else {\n                addRemoveRedeployLinksSteps(client, steps, name, null, null, false, REDEPLOY_ALL);\n            }\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","commit_id":"818fea6f7b327d077b2f038f77d25bb6cadc62dc","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void link(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n        if(deployments == null && wildcards == null) {\n            throw new CommandFormatException(\"Either \" + this.deployments.getFullName() + \" or \" + this.wildcards.getFullName() + \" is required.\");\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        if(ctx.isDomainMode()) {\n            final List<String> sg = getServerGroupsToLink(ctx);\n            for(String group : sg) {\n                if(!Util.isValidPath(ctx.getModelControllerClient(), Util.SERVER_GROUP, group, Util.DEPLOYMENT_OVERLAY, name)) {\n                    final ModelNode op = new ModelNode();\n                    final ModelNode address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                }\n                if(deployments != null) {\n                    addLinkSteps(name, group, deployments, false, steps);\n                }\n                if(wildcards != null) {\n                    addLinkSteps(name, group, wildcards, true, steps);\n                }\n            }\n        } else {\n            if(deployments != null) {\n                addLinkSteps(name, null, deployments, false, steps);\n            }\n            if(wildcards != null) {\n                addLinkSteps(name, null, wildcards, true, steps);\n            }\n        }\n\n        try {\n            final ModelNode result = ctx.getModelControllerClient().execute(composite);\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to link overlay\", e);\n        }\n    }","id":67282,"modified_method":"protected void link(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n        if(deployments == null && wildcards == null) {\n            throw new CommandFormatException(\"Either \" + this.deployments.getFullName() + \" or \" + this.wildcards.getFullName() + \" is required.\");\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        if(ctx.isDomainMode()) {\n            final List<String> sg = getServerGroupsToLink(ctx);\n            for(String group : sg) {\n                if(!Util.isValidPath(client, Util.SERVER_GROUP, group, Util.DEPLOYMENT_OVERLAY, name)) {\n                    final ModelNode op = new ModelNode();\n                    final ModelNode address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                }\n                if(deployments != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, group, deployments, false);\n                }\n                if(wildcards != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, group, wildcards, true);\n                }\n            }\n        } else {\n            if(deployments != null) {\n                addAddRedeployLinksSteps(ctx, steps, name, null, deployments, false);\n            }\n            if(wildcards != null) {\n                addAddRedeployLinksSteps(ctx, steps, name, null, wildcards, true);\n            }\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to link overlay\", e);\n        }\n    }","commit_id":"818fea6f7b327d077b2f038f77d25bb6cadc62dc","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void addLinkSteps(final String overlayName, final String serverGroup, final String[] deployments,\n            final boolean regexp, final ModelNode steps) {\n        for(String deployment : deployments) {\n            final ModelNode op = new ModelNode();\n            final ModelNode address = op.get(Util.ADDRESS);\n            if(serverGroup != null) {\n                address.add(Util.SERVER_GROUP, serverGroup);\n            }\n            address.add(Util.DEPLOYMENT_OVERLAY, overlayName);\n            address.add(Util.DEPLOYMENT, deployment);\n            op.get(Util.OPERATION).set(Util.ADD);\n            if(regexp) {\n                op.get(Util.REGULAR_EXPRESSION).set(true);\n            }\n            steps.add(op);\n        }\n    }","id":67283,"modified_method":"protected void addAddRedeployLinksSteps(CommandContext ctx, ModelNode steps,\n            String overlay, String serverGroup, String[] links, boolean regexp)\n                    throws CommandLineException {\n        for(String link : links) {\n            final ModelNode op = new ModelNode();\n            final ModelNode address = op.get(Util.ADDRESS);\n            if(serverGroup != null) {\n                address.add(Util.SERVER_GROUP, serverGroup);\n            }\n            address.add(Util.DEPLOYMENT_OVERLAY, overlay);\n            address.add(Util.DEPLOYMENT, link);\n            op.get(Util.OPERATION).set(Util.ADD);\n            if(regexp) {\n                op.get(Util.REGULAR_EXPRESSION).set(true);\n                steps.add(op);\n\n                final List<String> matchingDeployments = Util.getMatchingDeployments(ctx.getModelControllerClient(), link, serverGroup);\n                if(!matchingDeployments.isEmpty()) {\n                    if(serverGroup == null) {\n                        for(String deployment : matchingDeployments) {\n                            final ModelNode step = new ModelNode();\n                            final ModelNode addr = step.get(Util.ADDRESS);\n                            addr.add(Util.DEPLOYMENT, deployment);\n                            step.get(Util.OPERATION).set(Util.REDEPLOY);\n                            steps.add(step);\n                        }\n                    } else {\n                        for(String deployment : matchingDeployments) {\n                            final ModelNode step = new ModelNode();\n                            final ModelNode addr = step.get(Util.ADDRESS);\n                            addr.add(Util.SERVER_GROUP, serverGroup);\n                            addr.add(Util.DEPLOYMENT, deployment);\n                            step.get(Util.OPERATION).set(Util.REDEPLOY);\n                            steps.add(step);\n                        }\n                    }\n                }\n            } else if(redeployAffected.isPresent(ctx.getParsedCommandLine())) {\n                steps.add(op);\n\n                if(serverGroup == null) {\n                    if(Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT, link)) {\n                        final ModelNode step = new ModelNode();\n                        final ModelNode addr = step.get(Util.ADDRESS);\n                        addr.add(Util.DEPLOYMENT, link);\n                        step.get(Util.OPERATION).set(Util.REDEPLOY);\n                        steps.add(step);\n                    }\n                } else {\n                    if(Util.isValidPath(ctx.getModelControllerClient(), Util.SERVER_GROUP, serverGroup, Util.DEPLOYMENT, link)) {\n                        final ModelNode step = new ModelNode();\n                        final ModelNode addr = step.get(Util.ADDRESS);\n                        addr.add(Util.SERVER_GROUP, serverGroup);\n                        addr.add(Util.DEPLOYMENT, link);\n                        step.get(Util.OPERATION).set(Util.REDEPLOY);\n                        steps.add(step);\n                    }\n                }\n            } else {\n                steps.add(op);\n            }\n        }\n    }","commit_id":"818fea6f7b327d077b2f038f77d25bb6cadc62dc","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ModelNode buildRequestWithoutHeaders(CommandContext ctx) throws CommandFormatException {\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args);\n        final boolean keepContent = this.keepContent.isPresent(args);\n        final boolean allRelevantServerGroups = this.allRelevantServerGroups.isPresent(args);\n        final String serverGroupsStr = this.serverGroups.getValue(args);\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                throw new OperationFormatException(\"Path '\" + f.getAbsolutePath() + \"' doesn't exist.\");\n            }\n            if(!isCliArchive(f)) {\n                throw new OperationFormatException(\"File '\" + f.getAbsolutePath() + \"' is not a valid CLI archive. CLI archives should have a '.cli' extension.\");\n            }\n        } else {\n            f = null;\n        }\n        if (isCliArchive(f)) {\n            if (name != null) {\n                throw new OperationFormatException(this.name.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            if(serverGroupsStr != null || allRelevantServerGroups) {\n                throw new OperationFormatException(this.serverGroups.getFullName() + \" and \" + this.allRelevantServerGroups.getFullName() +\n                        \" can't be used in combination with a CLI archive.\");\n            }\n\n            if (keepContent) {\n                throw new OperationFormatException(this.keepContent.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            MountHandle root;\n            try {\n                root = extractArchive(f);\n            } catch (IOException e) {\n                throw new OperationFormatException(\"Unable to extract archive '\" + f.getAbsolutePath() + \"' to temporary location\");\n            }\n\n            final File currentDir = ctx.getCurrentDir();\n            ctx.setCurrentDir(root.getMountSource());\n            String holdbackBatch = activateNewBatch(ctx);\n\n            try {\n                String script = this.script.getValue(args);\n                if (script == null) {\n                    script = \"undeploy.scr\";\n                }\n\n                File scriptFile = new File(ctx.getCurrentDir(),script);\n                if (!scriptFile.exists()) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                }\n\n                BufferedReader reader = null;\n                try {\n                    reader = new BufferedReader(new FileReader(scriptFile));\n                    String line = reader.readLine();\n                    while (!ctx.isTerminated() && line != null) {\n                        ctx.handle(line);\n                        line = reader.readLine();\n                    }\n                } catch (FileNotFoundException e) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                } catch (IOException e) {\n                    throw new CommandFormatException(\"Failed to read the next command from \" + scriptFile.getName() + \": \" + e.getMessage(), e);\n                } catch (CommandLineException e) {\n                    throw new CommandFormatException(e.getMessage(), e);\n                } finally {\n                    if(reader != null) {\n                        try {\n                            reader.close();\n                        } catch (IOException e) {\n                        }\n                    }\n                }\n\n                return ctx.getBatchManager().getActiveBatch().toRequest();\n            } finally {\n                // reset current dir in context\n                ctx.setCurrentDir(currentDir);\n                discardBatch(ctx, holdbackBatch);\n                try {\n                    root.close();\n                } catch (IOException ignore) {}\n            }\n        }\n\n        if(name == null) {\n            throw new OperationFormatException(\"Deployment name is missing.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        DefaultOperationRequestBuilder builder;\n\n        final List<String> deploymentNames;\n        if(name.indexOf('*') < 0) {\n            deploymentNames = Collections.singletonList(name);\n        } else {\n            deploymentNames = Util.getMatchingDeployments(client, name);\n            if(deploymentNames.isEmpty()) {\n                throw new CommandFormatException(\"No deployment matched wildcard expression \" + name);\n            }\n        }\n\n        for(String deploymentName : deploymentNames) {\n\n            final List<String> serverGroups;\n            if(ctx.isDomainMode()) {\n                if(allRelevantServerGroups) {\n                    if(keepContent) {\n                        serverGroups = Util.getAllEnabledServerGroups(deploymentName, client);\n                    } else {\n                        try {\n                            serverGroups = Util.getServerGroupsReferencingDeployment(deploymentName, client);\n                        } catch (CommandLineException e) {\n                            throw new CommandFormatException(\"Failed to retrieve all referencing server groups\", e);\n                        }\n                    }\n                } else {\n                    if(serverGroupsStr == null) {\n                        //throw new OperationFormatException(\"Either --all-relevant-server-groups or --server-groups must be specified.\");\n                        serverGroups = Collections.emptyList();\n                    } else {\n                        serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                    }\n                }\n\n                if(serverGroups.isEmpty()) {\n                    if(keepContent) {\n                        throw new OperationFormatException(\"None of the server groups is specified or references specified deployment.\");\n                    }\n                } else {\n                    for (String group : serverGroups){\n                        ModelNode groupStep = Util.configureDeploymentOperation(Util.UNDEPLOY, deploymentName, group);\n                        steps.add(groupStep);\n//                      if(!keepContent) {\n                            groupStep = Util.configureDeploymentOperation(Util.REMOVE, deploymentName, group);\n                            steps.add(groupStep);\n//                      }\n                    }\n                }\n            } else {\n                if(Util.isDeployedAndEnabledInStandalone(deploymentName, client)) {\n                    builder = new DefaultOperationRequestBuilder();\n                    builder.setOperationName(Util.UNDEPLOY);\n                    builder.addNode(Util.DEPLOYMENT, deploymentName);\n                    steps.add(builder.buildRequest());\n                }\n            }\n        }\n\n        if (!keepContent) {\n            for(String deploymentName : deploymentNames) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(Util.REMOVE);\n                builder.addNode(Util.DEPLOYMENT, deploymentName);\n                steps.add(builder.buildRequest());\n            }\n        }\n        return composite;\n    }","id":67284,"modified_method":"@Override\n    public ModelNode buildRequestWithoutHeaders(CommandContext ctx) throws CommandFormatException {\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args);\n        final boolean keepContent = this.keepContent.isPresent(args);\n        final boolean allRelevantServerGroups = this.allRelevantServerGroups.isPresent(args);\n        final String serverGroupsStr = this.serverGroups.getValue(args);\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                throw new OperationFormatException(\"Path '\" + f.getAbsolutePath() + \"' doesn't exist.\");\n            }\n            if(!isCliArchive(f)) {\n                throw new OperationFormatException(\"File '\" + f.getAbsolutePath() + \"' is not a valid CLI archive. CLI archives should have a '.cli' extension.\");\n            }\n        } else {\n            f = null;\n        }\n        if (isCliArchive(f)) {\n            if (name != null) {\n                throw new OperationFormatException(this.name.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            if(serverGroupsStr != null || allRelevantServerGroups) {\n                throw new OperationFormatException(this.serverGroups.getFullName() + \" and \" + this.allRelevantServerGroups.getFullName() +\n                        \" can't be used in combination with a CLI archive.\");\n            }\n\n            if (keepContent) {\n                throw new OperationFormatException(this.keepContent.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            MountHandle root;\n            try {\n                root = extractArchive(f);\n            } catch (IOException e) {\n                throw new OperationFormatException(\"Unable to extract archive '\" + f.getAbsolutePath() + \"' to temporary location\");\n            }\n\n            final File currentDir = ctx.getCurrentDir();\n            ctx.setCurrentDir(root.getMountSource());\n            String holdbackBatch = activateNewBatch(ctx);\n\n            try {\n                String script = this.script.getValue(args);\n                if (script == null) {\n                    script = \"undeploy.scr\";\n                }\n\n                File scriptFile = new File(ctx.getCurrentDir(),script);\n                if (!scriptFile.exists()) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                }\n\n                BufferedReader reader = null;\n                try {\n                    reader = new BufferedReader(new FileReader(scriptFile));\n                    String line = reader.readLine();\n                    while (!ctx.isTerminated() && line != null) {\n                        ctx.handle(line);\n                        line = reader.readLine();\n                    }\n                } catch (FileNotFoundException e) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                } catch (IOException e) {\n                    throw new CommandFormatException(\"Failed to read the next command from \" + scriptFile.getName() + \": \" + e.getMessage(), e);\n                } catch (CommandLineException e) {\n                    throw new CommandFormatException(e.getMessage(), e);\n                } finally {\n                    if(reader != null) {\n                        try {\n                            reader.close();\n                        } catch (IOException e) {\n                        }\n                    }\n                }\n\n                return ctx.getBatchManager().getActiveBatch().toRequest();\n            } finally {\n                // reset current dir in context\n                ctx.setCurrentDir(currentDir);\n                discardBatch(ctx, holdbackBatch);\n                try {\n                    root.close();\n                } catch (IOException ignore) {}\n            }\n        }\n\n        if(name == null) {\n            throw new OperationFormatException(\"Deployment name is missing.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        DefaultOperationRequestBuilder builder;\n\n        final List<String> deploymentNames;\n        if(name.indexOf('*') < 0) {\n            deploymentNames = Collections.singletonList(name);\n        } else {\n            deploymentNames = Util.getMatchingDeployments(client, name, null);\n            if(deploymentNames.isEmpty()) {\n                throw new CommandFormatException(\"No deployment matched wildcard expression \" + name);\n            }\n        }\n\n        for(String deploymentName : deploymentNames) {\n\n            final List<String> serverGroups;\n            if(ctx.isDomainMode()) {\n                if(allRelevantServerGroups) {\n                    if(keepContent) {\n                        serverGroups = Util.getAllEnabledServerGroups(deploymentName, client);\n                    } else {\n                        try {\n                            serverGroups = Util.getServerGroupsReferencingDeployment(deploymentName, client);\n                        } catch (CommandLineException e) {\n                            throw new CommandFormatException(\"Failed to retrieve all referencing server groups\", e);\n                        }\n                    }\n                } else {\n                    if(serverGroupsStr == null) {\n                        //throw new OperationFormatException(\"Either --all-relevant-server-groups or --server-groups must be specified.\");\n                        serverGroups = Collections.emptyList();\n                    } else {\n                        serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                    }\n                }\n\n                if(serverGroups.isEmpty()) {\n                    if(keepContent) {\n                        throw new OperationFormatException(\"None of the server groups is specified or references specified deployment.\");\n                    }\n                } else {\n                    for (String group : serverGroups){\n                        ModelNode groupStep = Util.configureDeploymentOperation(Util.UNDEPLOY, deploymentName, group);\n                        steps.add(groupStep);\n//                      if(!keepContent) {\n                            groupStep = Util.configureDeploymentOperation(Util.REMOVE, deploymentName, group);\n                            steps.add(groupStep);\n//                      }\n                    }\n                }\n            } else {\n                if(Util.isDeployedAndEnabledInStandalone(deploymentName, client)) {\n                    builder = new DefaultOperationRequestBuilder();\n                    builder.setOperationName(Util.UNDEPLOY);\n                    builder.addNode(Util.DEPLOYMENT, deploymentName);\n                    steps.add(builder.buildRequest());\n                }\n            }\n        }\n\n        if (!keepContent) {\n            for(String deploymentName : deploymentNames) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(Util.REMOVE);\n                builder.addNode(Util.DEPLOYMENT, deploymentName);\n                steps.add(builder.buildRequest());\n            }\n        }\n        return composite;\n    }","commit_id":"818fea6f7b327d077b2f038f77d25bb6cadc62dc","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static List<String> getMatchingDeployments(ModelControllerClient client, String wildcardExpr) {\n\n        final DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n        final ModelNode request;\n        try {\n            builder.setOperationName(Util.READ_CHILDREN_NAMES);\n            builder.addProperty(Util.CHILD_TYPE, Util.DEPLOYMENT);\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            final ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                return getList(outcome, wildcardExpr);\n            }\n        } catch (Exception e) {\n        }\n\n        return Collections.emptyList();\n    }","id":67285,"modified_method":"public static List<String> getMatchingDeployments(ModelControllerClient client, String wildcardExpr, String serverGroup) {\n\n        final DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n        final ModelNode request;\n        try {\n            if(serverGroup != null) {\n                builder.addNode(Util.SERVER_GROUP, serverGroup);\n            }\n            builder.setOperationName(Util.READ_CHILDREN_NAMES);\n            builder.addProperty(Util.CHILD_TYPE, Util.DEPLOYMENT);\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            final ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                return getList(outcome, wildcardExpr);\n            }\n        } catch (Exception e) {\n        }\n\n        return Collections.emptyList();\n    }","commit_id":"818fea6f7b327d077b2f038f77d25bb6cadc62dc","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void upload(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args, true);\n        if(!Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT_OVERLAY, name)) {\n            throw new CommandLineException(\"Deployment overlay \" + name + \" does not exist.\");\n        }\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String deploymentsStr = deployments.getValue(args);\n        if(deploymentsStr != null) {\n            throw new CommandFormatException(deployments.getFullName() + \" can't be used in combination with upload.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final ModelNode op = new ModelNode();\n            ModelNode address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentNames[i]);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(redeployAffected.isPresent(args)) {\n            if(ctx.isDomainMode()) {\n                for(String sgName : Util.getServerGroups(client)) {\n                    addRemoveRedeployLinksSteps(client, steps, name, sgName, null, false, REDEPLOY_ALL);\n                }\n            } else {\n                addRemoveRedeployLinksSteps(client, steps, name, null, null, false, REDEPLOY_ALL);\n            }\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","id":67286,"modified_method":"protected void upload(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(redeployAffected, args);\n\n        final String name = this.name.getValue(args, true);\n        if(!Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT_OVERLAY, name)) {\n            throw new CommandLineException(\"Deployment overlay \" + name + \" does not exist.\");\n        }\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String deploymentsStr = deployments.getValue(args);\n        if(deploymentsStr != null) {\n            throw new CommandFormatException(deployments.getFullName() + \" can't be used in combination with upload.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final ModelNode op = new ModelNode();\n            ModelNode address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentNames[i]);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","commit_id":"d79bd6c7b52cd5812aa9bd704b2f2fc3fd2002e5","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void addAddRedeployLinksSteps(CommandContext ctx, ModelNode steps,\n            String overlay, String serverGroup, String[] links, boolean regexp)\n                    throws CommandLineException {\n        for(String link : links) {\n            final ModelNode op = new ModelNode();\n            final ModelNode address = op.get(Util.ADDRESS);\n            if(serverGroup != null) {\n                address.add(Util.SERVER_GROUP, serverGroup);\n            }\n            address.add(Util.DEPLOYMENT_OVERLAY, overlay);\n            address.add(Util.DEPLOYMENT, link);\n            op.get(Util.OPERATION).set(Util.ADD);\n            if(regexp) {\n                op.get(Util.REGULAR_EXPRESSION).set(true);\n                steps.add(op);\n\n                final List<String> matchingDeployments = Util.getMatchingDeployments(ctx.getModelControllerClient(), link, serverGroup);\n                if(!matchingDeployments.isEmpty()) {\n                    if(serverGroup == null) {\n                        for(String deployment : matchingDeployments) {\n                            final ModelNode step = new ModelNode();\n                            final ModelNode addr = step.get(Util.ADDRESS);\n                            addr.add(Util.DEPLOYMENT, deployment);\n                            step.get(Util.OPERATION).set(Util.REDEPLOY);\n                            steps.add(step);\n                        }\n                    } else {\n                        for(String deployment : matchingDeployments) {\n                            final ModelNode step = new ModelNode();\n                            final ModelNode addr = step.get(Util.ADDRESS);\n                            addr.add(Util.SERVER_GROUP, serverGroup);\n                            addr.add(Util.DEPLOYMENT, deployment);\n                            step.get(Util.OPERATION).set(Util.REDEPLOY);\n                            steps.add(step);\n                        }\n                    }\n                }\n            } else if(redeployAffected.isPresent(ctx.getParsedCommandLine())) {\n                steps.add(op);\n\n                if(serverGroup == null) {\n                    if(Util.isValidPath(ctx.getModelControllerClient(), Util.DEPLOYMENT, link)) {\n                        final ModelNode step = new ModelNode();\n                        final ModelNode addr = step.get(Util.ADDRESS);\n                        addr.add(Util.DEPLOYMENT, link);\n                        step.get(Util.OPERATION).set(Util.REDEPLOY);\n                        steps.add(step);\n                    }\n                } else {\n                    if(Util.isValidPath(ctx.getModelControllerClient(), Util.SERVER_GROUP, serverGroup, Util.DEPLOYMENT, link)) {\n                        final ModelNode step = new ModelNode();\n                        final ModelNode addr = step.get(Util.ADDRESS);\n                        addr.add(Util.SERVER_GROUP, serverGroup);\n                        addr.add(Util.DEPLOYMENT, link);\n                        step.get(Util.OPERATION).set(Util.REDEPLOY);\n                        steps.add(step);\n                    }\n                }\n            } else {\n                steps.add(op);\n            }\n        }\n    }","id":67287,"modified_method":"protected void addLinkSteps(final String overlayName, final String serverGroup, final String[] deployments,\n            final boolean regexp, final ModelNode steps) {\n        for(String deployment : deployments) {\n            final ModelNode op = new ModelNode();\n            final ModelNode address = op.get(Util.ADDRESS);\n            if(serverGroup != null) {\n                address.add(Util.SERVER_GROUP, serverGroup);\n            }\n            address.add(Util.DEPLOYMENT_OVERLAY, overlayName);\n            address.add(Util.DEPLOYMENT, deployment);\n            op.get(Util.OPERATION).set(Util.ADD);\n            if(regexp) {\n                op.get(Util.REGULAR_EXPRESSION).set(true);\n            }\n            steps.add(op);\n        }\n    }","commit_id":"d79bd6c7b52cd5812aa9bd704b2f2fc3fd2002e5","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void add(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the overlay\n        ModelNode op = new ModelNode();\n        ModelNode address = op.get(Util.ADDRESS);\n        address.add(Util.DEPLOYMENT_OVERLAY, name);\n        op.get(Util.OPERATION).set(Util.ADD);\n        steps.add(op);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final String contentName = contentNames[i];\n            op = new ModelNode();\n            address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentName);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(deployments != null || wildcards != null) {\n            if(ctx.isDomainMode()) {\n                final List<String> sg = getServerGroupsToLink(ctx);\n                for(String group : sg) {\n                    // here we don't need a separate check whether the overlay is linked\n                    // from the server group since it is created in the same op.\n                    op = new ModelNode();\n                    address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                    if(deployments != null) {\n                        addAddRedeployLinksSteps(ctx, steps, name, group, deployments, false);\n                    }\n                    if(wildcards != null) {\n                        addAddRedeployLinksSteps(ctx, steps, name, group, wildcards, true);\n                    }\n                }\n            } else {\n                if(deployments != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, null, deployments, false);\n                }\n                if(wildcards != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, null, wildcards, true);\n                }\n            }\n        } else if(ctx.isDomainMode() && (serverGroups.isPresent(args) || allServerGroups.isPresent(args))) {\n            throw new CommandFormatException(\"server groups are specified but neither \" + this.deployments.getFullName() +\n                    \" nor \" + this.wildcards.getFullName() + \" is.\");\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","id":67288,"modified_method":"protected void add(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String contentStr = content.getValue(args, true);\n\n        final String[] contentPairs = contentStr.split(\",+\");\n        if(contentPairs.length == 0) {\n            throw new CommandFormatException(\"Overlay content is not specified.\");\n        }\n        final String[] contentNames = new String[contentPairs.length];\n        final File[] contentPaths = new File[contentPairs.length];\n        for(int i = 0; i < contentPairs.length; ++i) {\n            final String pair = contentPairs[i];\n            final int equalsIndex = pair.indexOf('=');\n            if(equalsIndex < 0) {\n                throw new CommandFormatException(\"Content pair is not following archive-path=fs-path format: '\" + pair + \"'\");\n            }\n            contentNames[i] = pair.substring(0, equalsIndex);\n            if(contentNames[i].length() == 0) {\n                throw new CommandFormatException(\"The archive path is missing for the content '\" + pair + \"'\");\n            }\n            String path = pair.substring(equalsIndex + 1);\n            if(path.length() == 0) {\n                throw new CommandFormatException(\"The filesystem paths is missing for the content '\" + pair + \"'\");\n            }\n            path = pathCompleter.translatePath(path);\n            final File f = new File(path);\n            if(!f.exists()) {\n                throw new CommandFormatException(\"Content file doesn't exist \" + f.getAbsolutePath());\n            }\n            contentPaths[i] = f;\n        }\n\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ModelNode composite = new ModelNode();\n        final OperationBuilder opBuilder = new OperationBuilder(composite, true);\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        // add the overlay\n        ModelNode op = new ModelNode();\n        ModelNode address = op.get(Util.ADDRESS);\n        address.add(Util.DEPLOYMENT_OVERLAY, name);\n        op.get(Util.OPERATION).set(Util.ADD);\n        steps.add(op);\n\n        // add the content\n        for (int i = 0; i < contentNames.length; ++i) {\n            final String contentName = contentNames[i];\n            op = new ModelNode();\n            address = op.get(Util.ADDRESS);\n            address.add(Util.DEPLOYMENT_OVERLAY, name);\n            address.add(Util.CONTENT, contentName);\n            op.get(Util.OPERATION).set(Util.ADD);\n            op.get(Util.CONTENT).get(Util.INPUT_STREAM_INDEX).set(i);\n            opBuilder.addFileAsAttachment(contentPaths[i]);\n            steps.add(op);\n        }\n\n        if(deployments != null || wildcards != null) {\n            if(ctx.isDomainMode()) {\n                final List<String> sg = getServerGroupsToLink(ctx);\n                for(String group : sg) {\n                    // here we don't need a separate check whether the overlay is linked\n                    // from the server group since it is created in the same op.\n                    op = new ModelNode();\n                    address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                    if(deployments != null) {\n                        addLinkSteps(name, group, deployments, false, steps);\n                    }\n                    if(wildcards != null) {\n                        addLinkSteps(name, group, wildcards, true, steps);\n                    }\n                }\n            } else {\n                if(deployments != null) {\n                    addLinkSteps(name, null, deployments, false, steps);\n                }\n                if(wildcards != null) {\n                    addLinkSteps(name, null, wildcards, true, steps);\n                }\n            }\n        } else if(ctx.isDomainMode() && (serverGroups.isPresent(args) || allServerGroups.isPresent(args))) {\n            throw new CommandFormatException(\"server groups are specified but neither \" + this.deployments.getFullName() +\n                    \" nor \" + this.wildcards.getFullName() + \" is.\");\n        }\n\n        try {\n            final ModelNode result = client.execute(opBuilder.build());\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to add overlay\", e);\n        }\n    }","commit_id":"d79bd6c7b52cd5812aa9bd704b2f2fc3fd2002e5","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void remove(CommandContext ctx) throws CommandLineException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        if(name == null) {\n            throw new CommandFormatException(this.name + \" is missing value.\");\n        }\n        final String contentStr = content.getValue(args);\n        String deploymentStr = deployments.getValue(args);\n        final String wildcardsStr = wildcards.getValue(args);\n        if(wildcardsStr != null) {\n            if(deploymentStr == null) {\n                deploymentStr = wildcardsStr;\n            } else {\n                deploymentStr += ',' + wildcardsStr;\n            }\n        }\n        final String sgStr = serverGroups.getValue(args);\n        final List<String> sg;\n        if(sgStr == null) {\n            if(allRelevantServerGroups.isPresent(args)) {\n                sg = Util.getServerGroupsReferencingOverlay(name, client);\n            } else {\n                sg = null;\n            }\n        } else {\n            sg = Arrays.asList(sgStr.split(\",+\"));\n            if(sg.isEmpty()) {\n                throw new CommandFormatException(serverGroups.getFullName() + \" is missing value.\");\n            }\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        byte redeploy = this.redeployAffected.isPresent(args) ? REDEPLOY_ONLY_AFFECTED : REDEPLOY_NONE;\n\n        // remove the content first and determine whether all the linked deployments\n        // should be redeployed\n        if(contentStr != null || deploymentStr == null && sg == null) {\n\n            if(redeploy == REDEPLOY_ONLY_AFFECTED) {\n                redeploy = REDEPLOY_ALL;\n            }\n\n            final List<String> contentList;\n            if(contentStr == null) {\n                contentList = loadContentFor(client, name);\n            } else {\n                contentList = java.util.Arrays.asList(contentStr.split(\",+\"));\n            }\n\n            for(String content : contentList) {\n                final ModelNode op = new ModelNode();\n                ModelNode addr = op.get(Util.ADDRESS);\n                addr.add(Util.DEPLOYMENT_OVERLAY, name);\n                addr.add(Util.CONTENT, content);\n                op.get(Util.OPERATION).set(Util.REMOVE);\n                steps.add(op);\n            }\n        }\n\n        if(deploymentStr != null || contentStr == null) {\n            // remove the overlay links\n\n            if(ctx.isDomainMode()) {\n                if(deploymentStr == null) {\n                    final List<String> groups = sg == null ? Util.getServerGroupsReferencingOverlay(name, client) : sg;\n                    for(String group : groups) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, null, true, redeploy);\n                    }\n                } else {\n                    if(ctx.isDomainMode() && sg == null) {\n                        throw new CommandFormatException(serverGroups.getFullName() + \" or \" + allRelevantServerGroups.getFullName() + \" is required.\");\n                    }\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    for(String group : sg) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, links, true, redeploy);\n                    }\n                }\n            } else {\n                if(deploymentStr == null) {\n                    // remove all\n                    addRemoveRedeployLinksSteps(client, steps, name, null, null, true, redeploy);\n                } else {\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    addRemoveRedeployLinksSteps(client, steps, name, null, links, true, redeploy);\n                }\n            }\n        } else if(redeploy == REDEPLOY_ALL) {\n            addRemoveRedeployLinksSteps(client, steps, name, null, null, false, redeploy);\n        }\n\n        if(contentStr == null && deploymentStr == null && sg == null) {\n            final ModelNode op = new ModelNode();\n            op.get(Util.ADDRESS).add(Util.DEPLOYMENT_OVERLAY, name);\n            op.get(Util.OPERATION).set(Util.REMOVE);\n            steps.add(op);\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(\"failed request: \" + composite.toString());\n                ctx.printLine(\"failed response: \" + result.toString());\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to remove overlay\", e);\n        }\n    }","id":67289,"modified_method":"protected void remove(CommandContext ctx) throws CommandLineException {\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        if(name == null) {\n            throw new CommandFormatException(this.name + \" is missing value.\");\n        }\n        final String contentStr = content.getValue(args);\n        String deploymentStr = deployments.getValue(args);\n        final String wildcardsStr = wildcards.getValue(args);\n        if(wildcardsStr != null) {\n            if(deploymentStr == null) {\n                deploymentStr = wildcardsStr;\n            } else {\n                deploymentStr += ',' + wildcardsStr;\n            }\n        }\n        final String sgStr = serverGroups.getValue(args);\n        final List<String> sg;\n        if(sgStr == null) {\n            if(allRelevantServerGroups.isPresent(args)) {\n                sg = Util.getServerGroupsReferencingOverlay(name, client);\n            } else {\n                sg = null;\n            }\n        } else {\n            sg = Arrays.asList(sgStr.split(\",+\"));\n            if(sg.isEmpty()) {\n                throw new CommandFormatException(serverGroups.getFullName() + \" is missing value.\");\n            }\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        byte redeploy = this.redeployAffected.isPresent(args) ? REDEPLOY_ONLY_AFFECTED : REDEPLOY_NONE;\n\n        // remove the content first and determine whether all the linked deployments\n        // should be redeployed\n        if(contentStr != null || deploymentStr == null && sg == null) {\n\n            if(redeploy == REDEPLOY_ONLY_AFFECTED) {\n                redeploy = REDEPLOY_ALL;\n            }\n\n            final List<String> contentList;\n            if(contentStr == null) {\n                contentList = loadContentFor(client, name);\n            } else {\n                contentList = java.util.Arrays.asList(contentStr.split(\",+\"));\n            }\n\n            for(String content : contentList) {\n                final ModelNode op = new ModelNode();\n                ModelNode addr = op.get(Util.ADDRESS);\n                addr.add(Util.DEPLOYMENT_OVERLAY, name);\n                addr.add(Util.CONTENT, content);\n                op.get(Util.OPERATION).set(Util.REMOVE);\n                steps.add(op);\n            }\n        }\n\n        if(deploymentStr != null || contentStr == null) {\n            // remove the overlay links\n\n            if(ctx.isDomainMode()) {\n                if(deploymentStr == null) {\n                    final List<String> groups = sg == null ? Util.getServerGroupsReferencingOverlay(name, client) : sg;\n                    for(String group : groups) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, null, true, redeploy);\n                    }\n                } else {\n                    if(ctx.isDomainMode() && sg == null) {\n                        throw new CommandFormatException(serverGroups.getFullName() + \" or \" + allRelevantServerGroups.getFullName() + \" is required.\");\n                    }\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    for(String group : sg) {\n                        addRemoveRedeployLinksSteps(client, steps, name, group, links, true, redeploy);\n                    }\n                }\n            } else {\n                if(deploymentStr == null) {\n                    // remove all\n                    addRemoveRedeployLinksSteps(client, steps, name, null, null, true, redeploy);\n                } else {\n                    final List<String> links = Arrays.asList(deploymentStr.split(\",+\"));\n                    addRemoveRedeployLinksSteps(client, steps, name, null, links, true, redeploy);\n                }\n            }\n        } else if(redeploy == REDEPLOY_ALL) {\n            addRemoveRedeployLinksSteps(client, steps, name, null, null, false, redeploy);\n        }\n\n        if(contentStr == null && deploymentStr == null && sg == null) {\n            final ModelNode op = new ModelNode();\n            op.get(Util.ADDRESS).add(Util.DEPLOYMENT_OVERLAY, name);\n            op.get(Util.OPERATION).set(Util.REMOVE);\n            steps.add(op);\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                ctx.printLine(\"request: \" + composite.toString());\n                ctx.printLine(\"response: \" + result.toString());\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to remove overlay\", e);\n        }\n    }","commit_id":"d79bd6c7b52cd5812aa9bd704b2f2fc3fd2002e5","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void link(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n        if(deployments == null && wildcards == null) {\n            throw new CommandFormatException(\"Either \" + this.deployments.getFullName() + \" or \" + this.wildcards.getFullName() + \" is required.\");\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        if(ctx.isDomainMode()) {\n            final List<String> sg = getServerGroupsToLink(ctx);\n            for(String group : sg) {\n                if(!Util.isValidPath(client, Util.SERVER_GROUP, group, Util.DEPLOYMENT_OVERLAY, name)) {\n                    final ModelNode op = new ModelNode();\n                    final ModelNode address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                }\n                if(deployments != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, group, deployments, false);\n                }\n                if(wildcards != null) {\n                    addAddRedeployLinksSteps(ctx, steps, name, group, wildcards, true);\n                }\n            }\n        } else {\n            if(deployments != null) {\n                addAddRedeployLinksSteps(ctx, steps, name, null, deployments, false);\n            }\n            if(wildcards != null) {\n                addAddRedeployLinksSteps(ctx, steps, name, null, wildcards, true);\n            }\n        }\n\n        try {\n            final ModelNode result = client.execute(composite);\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to link overlay\", e);\n        }\n    }","id":67290,"modified_method":"protected void link(CommandContext ctx) throws CommandLineException {\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n        assertNotPresent(allRelevantServerGroups, args);\n\n        final String name = this.name.getValue(args, true);\n        final String[] deployments = getLinks(this.deployments, args);\n        final String[] wildcards = getLinks(this.wildcards, args);\n        if(deployments == null && wildcards == null) {\n            throw new CommandFormatException(\"Either \" + this.deployments.getFullName() + \" or \" + this.wildcards.getFullName() + \" is required.\");\n        }\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        if(ctx.isDomainMode()) {\n            final List<String> sg = getServerGroupsToLink(ctx);\n            for(String group : sg) {\n                if(!Util.isValidPath(ctx.getModelControllerClient(), Util.SERVER_GROUP, group, Util.DEPLOYMENT_OVERLAY, name)) {\n                    final ModelNode op = new ModelNode();\n                    final ModelNode address = op.get(Util.ADDRESS);\n                    address.add(Util.SERVER_GROUP, group);\n                    address.add(Util.DEPLOYMENT_OVERLAY, name);\n                    op.get(Util.OPERATION).set(Util.ADD);\n                    steps.add(op);\n                }\n                if(deployments != null) {\n                    addLinkSteps(name, group, deployments, false, steps);\n                }\n                if(wildcards != null) {\n                    addLinkSteps(name, group, wildcards, true, steps);\n                }\n            }\n        } else {\n            if(deployments != null) {\n                addLinkSteps(name, null, deployments, false, steps);\n            }\n            if(wildcards != null) {\n                addLinkSteps(name, null, wildcards, true, steps);\n            }\n        }\n\n        try {\n            final ModelNode result = ctx.getModelControllerClient().execute(composite);\n            if (!Util.isSuccess(result)) {\n                throw new CommandFormatException(Util.getFailureDescription(result));\n            }\n        } catch (IOException e) {\n            throw new CommandFormatException(\"Failed to link overlay\", e);\n        }\n    }","commit_id":"d79bd6c7b52cd5812aa9bd704b2f2fc3fd2002e5","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ModelNode buildRequestWithoutHeaders(CommandContext ctx) throws CommandFormatException {\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args);\n        final boolean keepContent = this.keepContent.isPresent(args);\n        final boolean allRelevantServerGroups = this.allRelevantServerGroups.isPresent(args);\n        final String serverGroupsStr = this.serverGroups.getValue(args);\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                throw new OperationFormatException(\"Path '\" + f.getAbsolutePath() + \"' doesn't exist.\");\n            }\n            if(!isCliArchive(f)) {\n                throw new OperationFormatException(\"File '\" + f.getAbsolutePath() + \"' is not a valid CLI archive. CLI archives should have a '.cli' extension.\");\n            }\n        } else {\n            f = null;\n        }\n        if (isCliArchive(f)) {\n            if (name != null) {\n                throw new OperationFormatException(this.name.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            if(serverGroupsStr != null || allRelevantServerGroups) {\n                throw new OperationFormatException(this.serverGroups.getFullName() + \" and \" + this.allRelevantServerGroups.getFullName() +\n                        \" can't be used in combination with a CLI archive.\");\n            }\n\n            if (keepContent) {\n                throw new OperationFormatException(this.keepContent.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            MountHandle root;\n            try {\n                root = extractArchive(f);\n            } catch (IOException e) {\n                throw new OperationFormatException(\"Unable to extract archive '\" + f.getAbsolutePath() + \"' to temporary location\");\n            }\n\n            final File currentDir = ctx.getCurrentDir();\n            ctx.setCurrentDir(root.getMountSource());\n            String holdbackBatch = activateNewBatch(ctx);\n\n            try {\n                String script = this.script.getValue(args);\n                if (script == null) {\n                    script = \"undeploy.scr\";\n                }\n\n                File scriptFile = new File(ctx.getCurrentDir(),script);\n                if (!scriptFile.exists()) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                }\n\n                BufferedReader reader = null;\n                try {\n                    reader = new BufferedReader(new FileReader(scriptFile));\n                    String line = reader.readLine();\n                    while (!ctx.isTerminated() && line != null) {\n                        ctx.handle(line);\n                        line = reader.readLine();\n                    }\n                } catch (FileNotFoundException e) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                } catch (IOException e) {\n                    throw new CommandFormatException(\"Failed to read the next command from \" + scriptFile.getName() + \": \" + e.getMessage(), e);\n                } catch (CommandLineException e) {\n                    throw new CommandFormatException(e.getMessage(), e);\n                } finally {\n                    if(reader != null) {\n                        try {\n                            reader.close();\n                        } catch (IOException e) {\n                        }\n                    }\n                }\n\n                return ctx.getBatchManager().getActiveBatch().toRequest();\n            } finally {\n                // reset current dir in context\n                ctx.setCurrentDir(currentDir);\n                discardBatch(ctx, holdbackBatch);\n                try {\n                    root.close();\n                } catch (IOException ignore) {}\n            }\n        }\n\n        if(name == null) {\n            throw new OperationFormatException(\"Deployment name is missing.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        DefaultOperationRequestBuilder builder;\n\n        final List<String> deploymentNames;\n        if(name.indexOf('*') < 0) {\n            deploymentNames = Collections.singletonList(name);\n        } else {\n            deploymentNames = Util.getMatchingDeployments(client, name, null);\n            if(deploymentNames.isEmpty()) {\n                throw new CommandFormatException(\"No deployment matched wildcard expression \" + name);\n            }\n        }\n\n        for(String deploymentName : deploymentNames) {\n\n            final List<String> serverGroups;\n            if(ctx.isDomainMode()) {\n                if(allRelevantServerGroups) {\n                    if(keepContent) {\n                        serverGroups = Util.getAllEnabledServerGroups(deploymentName, client);\n                    } else {\n                        try {\n                            serverGroups = Util.getServerGroupsReferencingDeployment(deploymentName, client);\n                        } catch (CommandLineException e) {\n                            throw new CommandFormatException(\"Failed to retrieve all referencing server groups\", e);\n                        }\n                    }\n                } else {\n                    if(serverGroupsStr == null) {\n                        //throw new OperationFormatException(\"Either --all-relevant-server-groups or --server-groups must be specified.\");\n                        serverGroups = Collections.emptyList();\n                    } else {\n                        serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                    }\n                }\n\n                if(serverGroups.isEmpty()) {\n                    if(keepContent) {\n                        throw new OperationFormatException(\"None of the server groups is specified or references specified deployment.\");\n                    }\n                } else {\n                    for (String group : serverGroups){\n                        ModelNode groupStep = Util.configureDeploymentOperation(Util.UNDEPLOY, deploymentName, group);\n                        steps.add(groupStep);\n//                      if(!keepContent) {\n                            groupStep = Util.configureDeploymentOperation(Util.REMOVE, deploymentName, group);\n                            steps.add(groupStep);\n//                      }\n                    }\n                }\n            } else {\n                if(Util.isDeployedAndEnabledInStandalone(deploymentName, client)) {\n                    builder = new DefaultOperationRequestBuilder();\n                    builder.setOperationName(Util.UNDEPLOY);\n                    builder.addNode(Util.DEPLOYMENT, deploymentName);\n                    steps.add(builder.buildRequest());\n                }\n            }\n        }\n\n        if (!keepContent) {\n            for(String deploymentName : deploymentNames) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(Util.REMOVE);\n                builder.addNode(Util.DEPLOYMENT, deploymentName);\n                steps.add(builder.buildRequest());\n            }\n        }\n        return composite;\n    }","id":67291,"modified_method":"@Override\n    public ModelNode buildRequestWithoutHeaders(CommandContext ctx) throws CommandFormatException {\n\n        final ModelNode composite = new ModelNode();\n        composite.get(Util.OPERATION).set(Util.COMPOSITE);\n        composite.get(Util.ADDRESS).setEmptyList();\n        final ModelNode steps = composite.get(Util.STEPS);\n\n        final ParsedCommandLine args = ctx.getParsedCommandLine();\n\n        final String name = this.name.getValue(args);\n        final boolean keepContent = this.keepContent.isPresent(args);\n        final boolean allRelevantServerGroups = this.allRelevantServerGroups.isPresent(args);\n        final String serverGroupsStr = this.serverGroups.getValue(args);\n\n        final String path = this.path.getValue(args);\n        final File f;\n        if(path != null) {\n            f = new File(path);\n            if(!f.exists()) {\n                throw new OperationFormatException(\"Path '\" + f.getAbsolutePath() + \"' doesn't exist.\");\n            }\n            if(!isCliArchive(f)) {\n                throw new OperationFormatException(\"File '\" + f.getAbsolutePath() + \"' is not a valid CLI archive. CLI archives should have a '.cli' extension.\");\n            }\n        } else {\n            f = null;\n        }\n        if (isCliArchive(f)) {\n            if (name != null) {\n                throw new OperationFormatException(this.name.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            if(serverGroupsStr != null || allRelevantServerGroups) {\n                throw new OperationFormatException(this.serverGroups.getFullName() + \" and \" + this.allRelevantServerGroups.getFullName() +\n                        \" can't be used in combination with a CLI archive.\");\n            }\n\n            if (keepContent) {\n                throw new OperationFormatException(this.keepContent.getFullName() + \" can't be used in combination with a CLI archive.\");\n            }\n\n            MountHandle root;\n            try {\n                root = extractArchive(f);\n            } catch (IOException e) {\n                throw new OperationFormatException(\"Unable to extract archive '\" + f.getAbsolutePath() + \"' to temporary location\");\n            }\n\n            final File currentDir = ctx.getCurrentDir();\n            ctx.setCurrentDir(root.getMountSource());\n            String holdbackBatch = activateNewBatch(ctx);\n\n            try {\n                String script = this.script.getValue(args);\n                if (script == null) {\n                    script = \"undeploy.scr\";\n                }\n\n                File scriptFile = new File(ctx.getCurrentDir(),script);\n                if (!scriptFile.exists()) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                }\n\n                BufferedReader reader = null;\n                try {\n                    reader = new BufferedReader(new FileReader(scriptFile));\n                    String line = reader.readLine();\n                    while (!ctx.isTerminated() && line != null) {\n                        ctx.handle(line);\n                        line = reader.readLine();\n                    }\n                } catch (FileNotFoundException e) {\n                    throw new CommandFormatException(\"ERROR: script '\" + script + \"' not found in archive '\" + f.getAbsolutePath() + \"'.\");\n                } catch (IOException e) {\n                    throw new CommandFormatException(\"Failed to read the next command from \" + scriptFile.getName() + \": \" + e.getMessage(), e);\n                } catch (CommandLineException e) {\n                    throw new CommandFormatException(e.getMessage(), e);\n                } finally {\n                    if(reader != null) {\n                        try {\n                            reader.close();\n                        } catch (IOException e) {\n                        }\n                    }\n                }\n\n                return ctx.getBatchManager().getActiveBatch().toRequest();\n            } finally {\n                // reset current dir in context\n                ctx.setCurrentDir(currentDir);\n                discardBatch(ctx, holdbackBatch);\n                try {\n                    root.close();\n                } catch (IOException ignore) {}\n            }\n        }\n\n        if(name == null) {\n            throw new OperationFormatException(\"Deployment name is missing.\");\n        }\n\n        final ModelControllerClient client = ctx.getModelControllerClient();\n        DefaultOperationRequestBuilder builder;\n\n        final List<String> deploymentNames;\n        if(name.indexOf('*') < 0) {\n            deploymentNames = Collections.singletonList(name);\n        } else {\n            deploymentNames = Util.getMatchingDeployments(client, name);\n            if(deploymentNames.isEmpty()) {\n                throw new CommandFormatException(\"No deployment matched wildcard expression \" + name);\n            }\n        }\n\n        for(String deploymentName : deploymentNames) {\n\n            final List<String> serverGroups;\n            if(ctx.isDomainMode()) {\n                if(allRelevantServerGroups) {\n                    if(keepContent) {\n                        serverGroups = Util.getAllEnabledServerGroups(deploymentName, client);\n                    } else {\n                        try {\n                            serverGroups = Util.getServerGroupsReferencingDeployment(deploymentName, client);\n                        } catch (CommandLineException e) {\n                            throw new CommandFormatException(\"Failed to retrieve all referencing server groups\", e);\n                        }\n                    }\n                } else {\n                    if(serverGroupsStr == null) {\n                        //throw new OperationFormatException(\"Either --all-relevant-server-groups or --server-groups must be specified.\");\n                        serverGroups = Collections.emptyList();\n                    } else {\n                        serverGroups = Arrays.asList(serverGroupsStr.split(\",\"));\n                    }\n                }\n\n                if(serverGroups.isEmpty()) {\n                    if(keepContent) {\n                        throw new OperationFormatException(\"None of the server groups is specified or references specified deployment.\");\n                    }\n                } else {\n                    for (String group : serverGroups){\n                        ModelNode groupStep = Util.configureDeploymentOperation(Util.UNDEPLOY, deploymentName, group);\n                        steps.add(groupStep);\n//                      if(!keepContent) {\n                            groupStep = Util.configureDeploymentOperation(Util.REMOVE, deploymentName, group);\n                            steps.add(groupStep);\n//                      }\n                    }\n                }\n            } else {\n                if(Util.isDeployedAndEnabledInStandalone(deploymentName, client)) {\n                    builder = new DefaultOperationRequestBuilder();\n                    builder.setOperationName(Util.UNDEPLOY);\n                    builder.addNode(Util.DEPLOYMENT, deploymentName);\n                    steps.add(builder.buildRequest());\n                }\n            }\n        }\n\n        if (!keepContent) {\n            for(String deploymentName : deploymentNames) {\n                builder = new DefaultOperationRequestBuilder();\n                builder.setOperationName(Util.REMOVE);\n                builder.addNode(Util.DEPLOYMENT, deploymentName);\n                steps.add(builder.buildRequest());\n            }\n        }\n        return composite;\n    }","commit_id":"d79bd6c7b52cd5812aa9bd704b2f2fc3fd2002e5","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static List<String> getMatchingDeployments(ModelControllerClient client, String wildcardExpr, String serverGroup) {\n\n        final DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n        final ModelNode request;\n        try {\n            if(serverGroup != null) {\n                builder.addNode(Util.SERVER_GROUP, serverGroup);\n            }\n            builder.setOperationName(Util.READ_CHILDREN_NAMES);\n            builder.addProperty(Util.CHILD_TYPE, Util.DEPLOYMENT);\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            final ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                return getList(outcome, wildcardExpr);\n            }\n        } catch (Exception e) {\n        }\n\n        return Collections.emptyList();\n    }","id":67292,"modified_method":"public static List<String> getMatchingDeployments(ModelControllerClient client, String wildcardExpr) {\n\n        final DefaultOperationRequestBuilder builder = new DefaultOperationRequestBuilder();\n        final ModelNode request;\n        try {\n            builder.setOperationName(Util.READ_CHILDREN_NAMES);\n            builder.addProperty(Util.CHILD_TYPE, Util.DEPLOYMENT);\n            request = builder.buildRequest();\n        } catch (OperationFormatException e) {\n            throw new IllegalStateException(\"Failed to build operation\", e);\n        }\n\n        try {\n            final ModelNode outcome = client.execute(request);\n            if (isSuccess(outcome)) {\n                return getList(outcome, wildcardExpr);\n            }\n        } catch (Exception e) {\n        }\n\n        return Collections.emptyList();\n    }","commit_id":"d79bd6c7b52cd5812aa9bd704b2f2fc3fd2002e5","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Trinity<Long, Pattern, Collection<String>> getXmlAnnotatedElementsValue() {\n    Trinity<Long, Pattern, Collection<String>> index = myXmlIndex;\n    if (index == null || myConfiguration.getModificationCount() != index.first.longValue()) {\n      final Map<ElementPattern<?>, BaseInjection> map = new THashMap<ElementPattern<?>, BaseInjection>();\n      for (BaseInjection injection : myConfiguration.getInjections(XmlLanguageInjectionSupport.XML_SUPPORT_ID)) {\n        for (InjectionPlace place : injection.getInjectionPlaces()) {\n          if (!place.isEnabled() || place.getElementPattern() == null) continue;\n          map.put(place.getElementPattern(), injection);\n        }\n      }\n      final Collection<String> stringSet = PatternValuesIndex.buildStringIndex(map.keySet());\n      index = Trinity.create(myConfiguration.getModificationCount(), buildPattern(stringSet), stringSet);\n      myXmlIndex = index;\n    }\n    return index;\n  }","id":67293,"modified_method":"private Trinity<Long, Pattern, Collection<String>> getXmlAnnotatedElementsValue() {\n    Trinity<Long, Pattern, Collection<String>> index = myXmlIndex;\n    if (index == null || myConfiguration.getModificationCount() != index.first.longValue()) {\n      final Map<ElementPattern<?>, BaseInjection> map = new THashMap<ElementPattern<?>, BaseInjection>();\n      for (BaseInjection injection : myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID)) {\n        for (InjectionPlace place : injection.getInjectionPlaces()) {\n          if (!place.isEnabled() || place.getElementPattern() == null) continue;\n          map.put(place.getElementPattern(), injection);\n        }\n      }\n      final Collection<String> stringSet = PatternValuesIndex.buildStringIndex(map.keySet());\n      index = Trinity.create(myConfiguration.getModificationCount(), buildPattern(stringSet), stringSet);\n      myXmlIndex = index;\n    }\n    return index;\n  }","commit_id":"b960dbb960c5a9cb558315d27ab37609efb88a1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void getInjectedLanguage(final PsiElement place, final PairProcessor<Language, List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>> processor) {\n    if (place instanceof XmlTag) {\n      final XmlTag xmlTag = (XmlTag)place;\n      //getXmlAnnotatedElementsValue().contains(xmlTag.getLocalName());\n      for (final BaseInjection injection : myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID)) {\n        if (injection.acceptsPsiElement(xmlTag)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final Ref<Boolean> hasSubTags = Ref.create(Boolean.FALSE);\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result = new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n\n          xmlTag.acceptChildren(new PsiElementVisitor() {\n            @Override\n            public void visitElement(final PsiElement element) {\n              if (element instanceof XmlText) {\n                if (element.getTextLength() == 0) return;\n                final List<TextRange> list = injection.getInjectedArea(element);\n                final InjectedLanguage l = InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n                for (TextRange textRange : list) {\n                  result.add(Trinity.create((PsiLanguageInjectionHost)element, l, textRange));\n                }\n              }\n              else if (element instanceof XmlTag) {\n                hasSubTags.set(Boolean.TRUE);\n                if (injection instanceof AbstractTagInjection && ((AbstractTagInjection)injection).isApplyToSubTagTexts()) {\n                  element.acceptChildren(this);\n                }\n              }\n            }\n          });\n          if (!result.isEmpty()) {\n            if (separateFiles) {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                processor.process(language, Collections.singletonList(trinity));\n              }\n            }\n            else {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                trinity.first.putUserData(LanguageInjectionSupport.HAS_UNPARSABLE_FRAGMENTS, hasSubTags.get());\n              }\n              processor.process(language, result);\n            }\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n    else if (place instanceof XmlAttributeValue && place.getParent() instanceof XmlAttribute) {\n      final XmlAttribute attribute = (XmlAttribute)place.getParent();\n      final XmlAttributeValue value = (XmlAttributeValue)place;\n      //if (value == null) return;\n      // Check that we don't inject anything into embedded (e.g. JavaScript) content:\n      // XmlToken: \"\n      // JSEmbeddedContent\n      // XmlToken \"\n\n      // Actually IDEA shouldn't ask for injected languages at all in this case.\n      final PsiElement[] children = value.getChildren();\n      if (children.length < 3 || !(children[1] instanceof XmlToken) ||\n          ((XmlToken)children[1]).getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {\n        return;\n      }\n\n      for (BaseInjection injection : myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID)) {\n        if (injection.acceptsPsiElement(attribute)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final List<TextRange> ranges = injection.getInjectedArea(value);\n          if (ranges.isEmpty()) continue;\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result = new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n          final InjectedLanguage l = InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n          for (TextRange textRange : ranges) {\n            result.add(Trinity.create((PsiLanguageInjectionHost)value, l, textRange));\n          }\n          if (separateFiles) {\n            for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n              processor.process(language, Collections.singletonList(trinity));\n            }\n          }\n          else {\n            processor.process(language, result);\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n  }","id":67294,"modified_method":"void getInjectedLanguage(final PsiElement place, final PairProcessor<Language, List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>> processor) {\n    if (place instanceof XmlTag) {\n      final XmlTag xmlTag = (XmlTag)place;\n\n      List<BaseInjection> injections = myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID);\n      //noinspection ForLoopReplaceableByForEach\n      for (int i = 0, injectionsSize = injections.size(); i < injectionsSize; i++) {\n        final BaseInjection injection = injections.get(i);\n        if (injection.acceptsPsiElement(xmlTag)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final Ref<Boolean> hasSubTags = Ref.create(Boolean.FALSE);\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result =\n            new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n\n          xmlTag.acceptChildren(new PsiElementVisitor() {\n            @Override\n            public void visitElement(final PsiElement element) {\n              if (element instanceof XmlText) {\n                if (element.getTextLength() == 0) return;\n                final List<TextRange> list = injection.getInjectedArea(element);\n                final InjectedLanguage l =\n                  InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n                for (TextRange textRange : list) {\n                  result.add(Trinity.create((PsiLanguageInjectionHost)element, l, textRange));\n                }\n              }\n              else if (element instanceof XmlTag) {\n                hasSubTags.set(Boolean.TRUE);\n                if (injection instanceof AbstractTagInjection && ((AbstractTagInjection)injection).isApplyToSubTagTexts()) {\n                  element.acceptChildren(this);\n                }\n              }\n            }\n          });\n          if (!result.isEmpty()) {\n            if (separateFiles) {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                processor.process(language, Collections.singletonList(trinity));\n              }\n            }\n            else {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                trinity.first.putUserData(LanguageInjectionSupport.HAS_UNPARSABLE_FRAGMENTS, hasSubTags.get());\n              }\n              processor.process(language, result);\n            }\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n    else if (place instanceof XmlAttributeValue && place.getParent() instanceof XmlAttribute) {\n      final XmlAttribute attribute = (XmlAttribute)place.getParent();\n      final XmlAttributeValue value = (XmlAttributeValue)place;\n      //if (value == null) return;\n      // Check that we don't inject anything into embedded (e.g. JavaScript) content:\n      // XmlToken: \"\n      // JSEmbeddedContent\n      // XmlToken \"\n\n      // Actually IDEA shouldn't ask for injected languages at all in this case.\n      final PsiElement[] children = value.getChildren();\n      if (children.length < 3 || !(children[1] instanceof XmlToken) ||\n          ((XmlToken)children[1]).getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {\n        return;\n      }\n\n      for (BaseInjection injection : myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID)) {\n        if (injection.acceptsPsiElement(attribute)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final List<TextRange> ranges = injection.getInjectedArea(value);\n          if (ranges.isEmpty()) continue;\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result = new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n          final InjectedLanguage l = InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n          for (TextRange textRange : ranges) {\n            result.add(Trinity.create((PsiLanguageInjectionHost)value, l, textRange));\n          }\n          if (separateFiles) {\n            for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n              processor.process(language, Collections.singletonList(trinity));\n            }\n          }\n          else {\n            processor.process(language, result);\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n  }","commit_id":"b960dbb960c5a9cb558315d27ab37609efb88a1e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void mergeWithDefaultConfiguration() {\n    try {\n      final Configuration cfg = load(getClass().getResourceAsStream(\"/\" + COMPONENT_NAME + \".xml\"));\n      if (cfg == null) return; // very strange\n      importFrom(cfg);\n    }\n    catch (Exception e) {\n      LOG.warn(e);\n    }\n  }","id":67295,"modified_method":"private void mergeWithDefaultConfiguration() {\n    Configuration cfg = null;\n    try {\n      cfg = load(getClass().getResourceAsStream(\"/\" + COMPONENT_NAME + \".xml\"));\n    }\n    catch (Exception e) {\n      LOG.warn(e);\n    }\n    if (cfg == null) return;\n    importFrom(cfg);\n  }","commit_id":"8192b229f7ee0b7c31ff1597caba83baae579817","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Import from another configuration (e.g. imported file). Returns the number of imported items.\n   */\n  public int importFrom(final Configuration cfg) {\n    int n = 0;\n    for (String supportId : InjectorUtils.getActiveInjectionSupportIds()) {\n      final List<BaseInjection> mineInjections = myInjections.get(supportId);\n      for (BaseInjection other : cfg.getInjections(supportId)) {\n        final BaseInjection existing = findExistingInjection(other);\n        if (existing == null) {\n          n ++;\n          mineInjections.add(other);\n        }\n        else {\n          if (existing.equals(other)) continue;\n          boolean placesAdded = false;\n          for (InjectionPlace place : other.getInjectionPlaces()) {\n            if (existing.findPlaceByText(place.getText()) == null) {\n              existing.getInjectionPlaces().add(place);\n              placesAdded = true;\n            }\n          }\n          if (placesAdded) n++;\n        }\n      }\n    }\n    if (n >= 0) configurationModified();\n    return n;\n  }","id":67296,"modified_method":"/**\n   * Import from another configuration (e.g. imported file). Returns the number of imported items.\n   * @param cfg configuration to import from\n   * @return added injections count\n   */\n  public int importFrom(final Configuration cfg) {\n    final ArrayList<BaseInjection> originalInjections = new ArrayList<BaseInjection>();\n    final ArrayList<BaseInjection> newInjections = new ArrayList<BaseInjection>();\n    for (String supportId : InjectorUtils.getActiveInjectionSupportIds()) {\n      importInjections(getInjections(supportId), cfg.getInjections(supportId), originalInjections, newInjections);\n    }\n    if (!newInjections.isEmpty()) configurationModified();\n    replaceInjections(newInjections, originalInjections);\n    return newInjections.size();\n  }","commit_id":"8192b229f7ee0b7c31ff1597caba83baae579817","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public InjectionsSettingsUI(final Project project, final Configuration configuration) {\n    myProject = project;\n    myConfiguration = configuration;\n\n    myOriginalInjections = ContainerUtil\n      .concat(InjectorUtils.getActiveInjectionSupportIds(), new Function<String, Collection<? extends BaseInjection>>() {\n        public Collection<? extends BaseInjection> fun(final String s) {\n          return ContainerUtil.findAll(myConfiguration.getInjections(s), new Condition<BaseInjection>() {\n            public boolean value(final BaseInjection injection) {\n              return InjectedLanguage.findLanguageById(injection.getInjectedLanguageId()) != null;\n            }\n          });\n        }\n      });\n    sortInjections(myOriginalInjections);\n    myInjections = new ArrayList<BaseInjection>();\n    for (BaseInjection injection : myOriginalInjections) {\n      myInjections.add(injection.copy());\n    }\n\n    myRoot = new JPanel(new BorderLayout());\n\n    myInjectionsTable = new InjectionsTable(myInjections);\n    final JPanel tablePanel = new JPanel(new BorderLayout());\n    //tablePanel.setBorder(BorderFactory.createTitledBorder(\"Available Injections\"));\n    tablePanel.add(BetterJTable.createStripedJScrollPane(myInjectionsTable), BorderLayout.CENTER);\n    tablePanel.add(Box.createVerticalStrut(10), BorderLayout.SOUTH);\n\n    final DefaultActionGroup group = createActions();\n\n    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    myToolbar.setTargetComponent(myInjectionsTable);\n    myRoot.add(myToolbar.getComponent(), BorderLayout.NORTH);\n    myRoot.add(tablePanel, BorderLayout.CENTER);\n  }","id":67297,"modified_method":"public InjectionsSettingsUI(final Project project, final Configuration configuration) {\n    myProject = project;\n    myConfiguration = configuration;\n\n    myOriginalInjections = ContainerUtil\n      .concat(InjectorUtils.getActiveInjectionSupportIds(), new Function<String, Collection<? extends BaseInjection>>() {\n        public Collection<? extends BaseInjection> fun(final String s) {\n          return ContainerUtil.findAll(myConfiguration.getInjections(s), new Condition<BaseInjection>() {\n            public boolean value(final BaseInjection injection) {\n              return InjectedLanguage.findLanguageById(injection.getInjectedLanguageId()) != null;\n            }\n          });\n        }\n      });\n    sortInjections(myOriginalInjections);\n    myInjections = new ArrayList<BaseInjection>();\n    for (BaseInjection injection : myOriginalInjections) {\n      myInjections.add(injection.copy());\n    }\n\n    myRoot = new JPanel(new BorderLayout());\n\n    myInjectionsTable = new InjectionsTable(myInjections);\n    final JPanel tablePanel = new JPanel(new BorderLayout());\n\n    tablePanel.add(BetterJTable.createStripedJScrollPane(myInjectionsTable), BorderLayout.CENTER);\n    //tablePanel.add(Box.createVerticalStrut(10), BorderLayout.SOUTH);\n\n    final DefaultActionGroup group = createActions();\n\n    myToolbar = ActionManager.getInstance().createActionToolbar(ActionPlaces.UNKNOWN, group, true);\n    myToolbar.setTargetComponent(myInjectionsTable);\n    myRoot.add(myToolbar.getComponent(), BorderLayout.NORTH);\n    myRoot.add(tablePanel, BorderLayout.CENTER);\n    myCountLabel = new JLabel();\n    myCountLabel.setHorizontalAlignment(SwingConstants.RIGHT);\n    myCountLabel.setForeground(SimpleTextAttributes.GRAY_ITALIC_ATTRIBUTES.getFgColor());\n    myRoot.add(myCountLabel, BorderLayout.SOUTH);\n    updateCountLabel();\n  }","commit_id":"8192b229f7ee0b7c31ff1597caba83baae579817","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private DefaultActionGroup createActions() {\n    final Consumer<BaseInjection> consumer = new Consumer<BaseInjection>() {\n      public void consume(final BaseInjection injection) {\n        addInjection(injection);\n      }\n    };\n    final Factory<BaseInjection> producer = new Factory<BaseInjection>() {\n      public BaseInjection create() {\n        return getSelectedInjection();\n      }\n    };\n    for (LanguageInjectionSupport support : InjectorUtils.getActiveInjectionSupports()) {\n      myAddActions.addAll(Arrays.asList(support.createAddActions(myProject, consumer)));\n      ContainerUtil.putIfNotNull(support.getId(), support.createEditAction(myProject, producer), myEditActions);\n      mySupports.put(support.getId(), support);\n    }\n    Collections.sort(myAddActions, new Comparator<AnAction>() {\n      public int compare(final AnAction o1, final AnAction o2) {\n        return Comparing.compare(o1.getTemplatePresentation().getText(), o2.getTemplatePresentation().getText());\n      }\n    });\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n    final AnAction addAction = new AnAction(\"Add\", \"Add\", Icons.ADD_ICON) {\n      @Override\n      public void update(final AnActionEvent e) {\n        e.getPresentation().setEnabled(!myAddActions.isEmpty());\n      }\n\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performAdd(e);\n      }\n    };\n    final AnAction removeAction = new AnAction(\"Remove\", \"Remove\", Icons.DELETE_ICON) {\n      @Override\n      public void update(final AnActionEvent e) {\n        e.getPresentation().setEnabled(!getSelectedInjections().isEmpty());\n      }\n\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performRemove();\n      }\n    };\n\n    final AnAction editAction = new AnAction(\"Edit\", \"Edit\", Icons.PROPERTIES_ICON) {\n      @Override\n      public void update(final AnActionEvent e) {\n        final AnAction action = getEditAction();\n        e.getPresentation().setEnabled(action != null);\n        if (action != null) action.update(e);\n      }\n\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        final int row = myInjectionsTable.getSelectedRow();\n        final AnAction action = getEditAction();\n        action.actionPerformed(e);\n        ((ListTableModel)myInjectionsTable.getModel()).fireTableDataChanged();\n        myInjectionsTable.getSelectionModel().setSelectionInterval(row, row);\n      }\n    };\n    group.add(addAction);\n    group.add(removeAction);\n    group.add(editAction);\n\n    addAction.registerCustomShortcutSet(CommonShortcuts.INSERT, myInjectionsTable);\n    removeAction.registerCustomShortcutSet(CommonShortcuts.DELETE, myInjectionsTable);\n    editAction.registerCustomShortcutSet(CommonShortcuts.ENTER, myInjectionsTable);\n\n    group.add(new AnAction(\"Import\", \"Import\", IconLoader.getIcon(\"/actions/install.png\")) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        doImportAction(e.getDataContext());\n      }\n    });\n    group.addSeparator();\n    group.add(new AnAction(\"Enabled Selected Injections\", \"Enabled Selected Injections\", Icons.SELECT_ALL_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performSelectedInjectionsEnabled(true);\n      }\n    });\n    group.add(new AnAction(\"Disabled Selected Injections\", \"Disabled Selected Injections\", Icons.UNSELECT_ALL_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performSelectedInjectionsEnabled(false);\n      }\n    });\n\n    new AnAction(\"Toggle\") {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performToggleAction();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0)), myInjectionsTable);\n    return group;\n  }","id":67298,"modified_method":"private DefaultActionGroup createActions() {\n    final Consumer<BaseInjection> consumer = new Consumer<BaseInjection>() {\n      public void consume(final BaseInjection injection) {\n        addInjection(injection);\n      }\n    };\n    final Factory<BaseInjection> producer = new Factory<BaseInjection>() {\n      public BaseInjection create() {\n        return getSelectedInjection();\n      }\n    };\n    for (LanguageInjectionSupport support : InjectorUtils.getActiveInjectionSupports()) {\n      myAddActions.addAll(Arrays.asList(support.createAddActions(myProject, consumer)));\n      ContainerUtil.putIfNotNull(support.getId(), support.createEditAction(myProject, producer), myEditActions);\n      mySupports.put(support.getId(), support);\n    }\n    Collections.sort(myAddActions, new Comparator<AnAction>() {\n      public int compare(final AnAction o1, final AnAction o2) {\n        return Comparing.compare(o1.getTemplatePresentation().getText(), o2.getTemplatePresentation().getText());\n      }\n    });\n\n    final DefaultActionGroup group = new DefaultActionGroup();\n    final AnAction addAction = new AnAction(\"Add\", \"Add\", Icons.ADD_ICON) {\n      @Override\n      public void update(final AnActionEvent e) {\n        e.getPresentation().setEnabled(!myAddActions.isEmpty());\n      }\n\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performAdd(e);\n        updateCountLabel();\n      }\n    };\n    final AnAction removeAction = new AnAction(\"Remove\", \"Remove\", Icons.DELETE_ICON) {\n      @Override\n      public void update(final AnActionEvent e) {\n        e.getPresentation().setEnabled(!getSelectedInjections().isEmpty());\n      }\n\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performRemove();\n        updateCountLabel();\n      }\n    };\n\n    final AnAction editAction = new AnAction(\"Edit\", \"Edit\", Icons.PROPERTIES_ICON) {\n      @Override\n      public void update(final AnActionEvent e) {\n        final AnAction action = getEditAction();\n        e.getPresentation().setEnabled(action != null);\n        if (action != null) action.update(e);\n      }\n\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        final int row = myInjectionsTable.getSelectedRow();\n        final AnAction action = getEditAction();\n        action.actionPerformed(e);\n        ((ListTableModel)myInjectionsTable.getModel()).fireTableDataChanged();\n        myInjectionsTable.getSelectionModel().setSelectionInterval(row, row);\n        updateCountLabel();\n      }\n    };\n    group.add(addAction);\n    group.add(removeAction);\n    group.add(editAction);\n\n    addAction.registerCustomShortcutSet(CommonShortcuts.INSERT, myInjectionsTable);\n    removeAction.registerCustomShortcutSet(CommonShortcuts.DELETE, myInjectionsTable);\n    editAction.registerCustomShortcutSet(CommonShortcuts.ENTER, myInjectionsTable);\n\n    group.add(new AnAction(\"Import\", \"Import\", IconLoader.getIcon(\"/actions/install.png\")) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        doImportAction(e.getDataContext());\n        updateCountLabel();\n      }\n    });\n    group.addSeparator();\n    group.add(new AnAction(\"Enabled Selected Injections\", \"Enabled Selected Injections\", Icons.SELECT_ALL_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performSelectedInjectionsEnabled(true);\n      }\n    });\n    group.add(new AnAction(\"Disabled Selected Injections\", \"Disabled Selected Injections\", Icons.UNSELECT_ALL_ICON) {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performSelectedInjectionsEnabled(false);\n        updateCountLabel();\n      }\n    });\n\n    new AnAction(\"Toggle\") {\n      @Override\n      public void actionPerformed(final AnActionEvent e) {\n        performToggleAction();\n        updateCountLabel();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_SPACE, 0)), myInjectionsTable);\n    return group;\n  }","commit_id":"8192b229f7ee0b7c31ff1597caba83baae579817","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {                                                 \n    myInjections.clear();\n    for (BaseInjection injection : myOriginalInjections) {\n      myInjections.add(injection.copy());\n    }\n    ((ListTableModel<BaseInjection>)myInjectionsTable.getModel()).setItems(myInjections);\n  }","id":67299,"modified_method":"public void reset() {                                                 \n    myInjections.clear();\n    for (BaseInjection injection : myOriginalInjections) {\n      myInjections.add(injection.copy());\n    }\n    ((ListTableModel<BaseInjection>)myInjectionsTable.getModel()).setItems(myInjections);\n    updateCountLabel();\n  }","commit_id":"8192b229f7ee0b7c31ff1597caba83baae579817","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doImportAction(final DataContext dataContext) {\n    final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, true, false, true, false) {\n      @Override\n      public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n        return super.isFileVisible(file, showHiddenFiles) &&\n               (file.isDirectory() || \"xml\".equals(file.getExtension()) || file.getFileType() == StdFileTypes.ARCHIVE);\n      }\n\n      @Override\n      public boolean isFileSelectable(VirtualFile file) {\n        return file.getFileType() == StdFileTypes.XML;\n      }\n    };\n    descriptor.setDescription(\"Please select the configuration file (usually named IntelliLang.xml) to import.\");\n    descriptor.setTitle(\"Import Configuration\");\n\n    descriptor.putUserData(LangDataKeys.MODULE_CONTEXT, LangDataKeys.MODULE.getData(dataContext));\n\n    final FileChooserDialog chooser = FileChooserFactory.getInstance().createFileChooser(descriptor, myProject);\n\n    final SplitterProportionsData splitterData = PeerFactory.getInstance().getUIHelper().createSplitterProportionsData();\n    splitterData.externalizeFromDimensionService(\"IntelliLang.ImportSettingsKey.SplitterProportions\");\n\n    final VirtualFile[] files = chooser.choose(null, myProject);\n    if (files.length != 1) return;\n    try {\n      final Configuration cfg = Configuration.load(files[0].getInputStream());\n      if (cfg == null) {\n        Messages.showWarningDialog(myProject, \"The selected file does not contain any importable configuration.\", \"Nothing to Import\");\n        return;\n      }\n      final List<BaseInjection> newInjections =\n        ContainerUtil.concat(cfg.getAllInjectorIds(), new Function<String, Collection<? extends BaseInjection>>() {\n          public Collection<? extends BaseInjection> fun(final String s) {\n            return cfg.getInjections(s);\n          }\n        });\n      newInjections.removeAll(myInjections);\n      myInjections.addAll(newInjections);\n      final int n = newInjections.size();\n      if (n > 1) {\n        Messages.showInfoMessage(myProject, n + \" entries have been successfully imported\", \"Import Successful\");\n      }\n      else if (n == 1) {\n        Messages.showInfoMessage(myProject, \"One entry has been successfully imported\", \"Import Successful\");\n      }\n      else {\n        Messages.showInfoMessage(myProject, \"No new entries have been imported\", \"Import\");\n      }\n    }\n    catch (Exception e1) {\n      Configuration.LOG.error(\"Unable to load Settings\", e1);\n\n      final String msg = e1.getLocalizedMessage();\n      Messages.showErrorDialog(myProject, msg != null && msg.length() > 0 ? msg : e1.toString(), \"Could not load Settings\");\n    }\n  }","id":67300,"modified_method":"private void doImportAction(final DataContext dataContext) {\n    final FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, true, false, true, false) {\n      @Override\n      public boolean isFileVisible(VirtualFile file, boolean showHiddenFiles) {\n        return super.isFileVisible(file, showHiddenFiles) &&\n               (file.isDirectory() || \"xml\".equals(file.getExtension()) || file.getFileType() == StdFileTypes.ARCHIVE);\n      }\n\n      @Override\n      public boolean isFileSelectable(VirtualFile file) {\n        return file.getFileType() == StdFileTypes.XML;\n      }\n    };\n    descriptor.setDescription(\"Please select the configuration file (usually named IntelliLang.xml) to import.\");\n    descriptor.setTitle(\"Import Configuration\");\n\n    descriptor.putUserData(LangDataKeys.MODULE_CONTEXT, LangDataKeys.MODULE.getData(dataContext));\n\n    final FileChooserDialog chooser = FileChooserFactory.getInstance().createFileChooser(descriptor, myProject);\n\n    final SplitterProportionsData splitterData = PeerFactory.getInstance().getUIHelper().createSplitterProportionsData();\n    splitterData.externalizeFromDimensionService(\"IntelliLang.ImportSettingsKey.SplitterProportions\");\n\n    final VirtualFile[] files = chooser.choose(null, myProject);\n    if (files.length != 1) return;\n    try {\n      final Configuration cfg = Configuration.load(files[0].getInputStream());\n      if (cfg == null) {\n        Messages.showWarningDialog(myProject, \"The selected file does not contain any importable configuration.\", \"Nothing to Import\");\n        return;\n      }\n      final Map<String,Set<BaseInjection>> currentMap =\n        ContainerUtil.classify(myInjections.iterator(), new Convertor<BaseInjection, String>() {\n          public String convert(final BaseInjection o) {\n            return o.getSupportId();\n          }\n        });\n      final List<BaseInjection> originalInjections = new ArrayList<BaseInjection>();\n      final List<BaseInjection> newInjections = new ArrayList<BaseInjection>();\n      //// remove duplicates\n      //for (String supportId : InjectorUtils.getActiveInjectionSupportIds()) {\n      //  final Set<BaseInjection> currentInjections = currentMap.get(supportId);\n      //  if (currentInjections == null) continue;\n      //  for (BaseInjection injection : currentInjections) {\n      //    Configuration.importInjections(newInjections, Collections.singleton(injection), originalInjections, newInjections);\n      //  }\n      //}\n      //myInjections.clear();\n      //myInjections.addAll(newInjections);\n\n      for (String supportId : InjectorUtils.getActiveInjectionSupportIds()) {\n        final Set<BaseInjection> currentInjections = currentMap.get(supportId);\n        final List<BaseInjection> importingInjections = cfg.getInjections(supportId);\n        if (currentInjections == null) {\n          newInjections.addAll(importingInjections);\n          continue;\n        }\n        else {\n          Configuration.importInjections(currentInjections, importingInjections, originalInjections, newInjections);\n        }\n      }\n      myInjections.removeAll(originalInjections);\n      myInjections.addAll(newInjections);\n      for (BaseInjection injection : newInjections) {\n        injection.initializePlaces(true);\n      }\n      ((ListTableModel<BaseInjection>)myInjectionsTable.getModel()).setItems(myInjections);\n      final int n = newInjections.size();\n      if (n > 1) {\n        Messages.showInfoMessage(myProject, n + \" entries have been successfully imported\", \"Import Successful\");\n      }\n      else if (n == 1) {\n        Messages.showInfoMessage(myProject, \"One entry has been successfully imported\", \"Import Successful\");\n      }\n      else {\n        Messages.showInfoMessage(myProject, \"No new entries have been imported\", \"Import\");\n      }\n    }\n    catch (Exception e1) {\n      Configuration.LOG.error(\"Unable to load Settings\", e1);\n\n      final String msg = e1.getLocalizedMessage();\n      Messages.showErrorDialog(myProject, msg != null && msg.length() > 0 ? msg : e1.toString(), \"Could not load Settings\");\n    }\n  }","commit_id":"8192b229f7ee0b7c31ff1597caba83baae579817","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void getInjectedLanguage(final PsiElement place, final PairProcessor<Language, List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>> processor) {\n    if (place instanceof XmlTag) {\n      final XmlTag xmlTag = (XmlTag)place;\n\n      List<BaseInjection> injections = myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID);\n      //noinspection ForLoopReplaceableByForEach\n      for (int i = 0, injectionsSize = injections.size(); i < injectionsSize; i++) {\n        final BaseInjection injection = injections.get(i);\n        if (injection.acceptsPsiElement(xmlTag)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final Ref<Boolean> hasSubTags = Ref.create(Boolean.FALSE);\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result =\n            new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n\n          xmlTag.acceptChildren(new PsiElementVisitor() {\n            @Override\n            public void visitElement(final PsiElement element) {\n              if (element instanceof XmlText) {\n                if (element.getTextLength() == 0) return;\n                final List<TextRange> list = injection.getInjectedArea(element);\n                final InjectedLanguage l =\n                  InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n                for (TextRange textRange : list) {\n                  result.add(Trinity.create((PsiLanguageInjectionHost)element, l, textRange));\n                }\n              }\n              else if (element instanceof XmlTag) {\n                hasSubTags.set(Boolean.TRUE);\n                if (injection instanceof AbstractTagInjection && ((AbstractTagInjection)injection).isApplyToSubTagTexts()) {\n                  element.acceptChildren(this);\n                }\n              }\n            }\n          });\n          if (!result.isEmpty()) {\n            if (separateFiles) {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                processor.process(language, Collections.singletonList(trinity));\n              }\n            }\n            else {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                trinity.first.putUserData(LanguageInjectionSupport.HAS_UNPARSABLE_FRAGMENTS, hasSubTags.get());\n              }\n              processor.process(language, result);\n            }\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n    else if (place instanceof XmlAttributeValue && place.getParent() instanceof XmlAttribute) {\n      final XmlAttribute attribute = (XmlAttribute)place.getParent();\n      final XmlAttributeValue value = (XmlAttributeValue)place;\n      //if (value == null) return;\n      // Check that we don't inject anything into embedded (e.g. JavaScript) content:\n      // XmlToken: \"\n      // JSEmbeddedContent\n      // XmlToken \"\n\n      // Actually IDEA shouldn't ask for injected languages at all in this case.\n      final PsiElement[] children = value.getChildren();\n      if (children.length < 3 || !(children[1] instanceof XmlToken) ||\n          ((XmlToken)children[1]).getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {\n        return;\n      }\n\n      for (BaseInjection injection : myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID)) {\n        if (injection.acceptsPsiElement(attribute)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final List<TextRange> ranges = injection.getInjectedArea(value);\n          if (ranges.isEmpty()) continue;\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result = new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n          final InjectedLanguage l = InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n          for (TextRange textRange : ranges) {\n            result.add(Trinity.create((PsiLanguageInjectionHost)value, l, textRange));\n          }\n          if (separateFiles) {\n            for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n              processor.process(language, Collections.singletonList(trinity));\n            }\n          }\n          else {\n            processor.process(language, result);\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n  }","id":67301,"modified_method":"void getInjectedLanguage(final PsiElement place, final PairProcessor<Language, List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>> processor) {\n    if (place instanceof XmlTag) {\n      final XmlTag xmlTag = (XmlTag)place;\n\n      List<BaseInjection> injections = myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID);\n      //noinspection ForLoopReplaceableByForEach\n      for (int i = 0, injectionsSize = injections.size(); i < injectionsSize; i++) {\n        final BaseInjection injection = injections.get(i);\n        if (injection.acceptsPsiElement(xmlTag)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final Ref<Boolean> hasSubTags = Ref.create(Boolean.FALSE);\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result =\n            new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n\n          xmlTag.acceptChildren(new PsiElementVisitor() {\n            @Override\n            public void visitElement(final PsiElement element) {\n              if (element instanceof XmlText) {\n                if (element.getTextLength() == 0) return;\n                final List<TextRange> list = injection.getInjectedArea(element);\n                final InjectedLanguage l =\n                  InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n                for (TextRange textRange : list) {\n                  result.add(Trinity.create((PsiLanguageInjectionHost)element, l, textRange));\n                }\n              }\n              else if (element instanceof XmlTag) {\n                hasSubTags.set(Boolean.TRUE);\n                if (injection instanceof AbstractTagInjection && ((AbstractTagInjection)injection).isApplyToSubTagTexts()) {\n                  element.acceptChildren(this);\n                }\n              }\n            }\n          });\n          if (!result.isEmpty()) {\n            if (separateFiles) {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                processor.process(language, Collections.singletonList(trinity));\n              }\n            }\n            else {\n              for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n                trinity.first.putUserData(LanguageInjectionSupport.HAS_UNPARSABLE_FRAGMENTS, hasSubTags.get());\n              }\n              processor.process(language, result);\n            }\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n    else if (place instanceof XmlAttributeValue && place.getParent() instanceof XmlAttribute) {\n      final XmlAttribute attribute = (XmlAttribute)place.getParent();\n      final XmlAttributeValue value = (XmlAttributeValue)place;\n      //if (value == null) return;\n      // Check that we don't inject anything into embedded (e.g. JavaScript) content:\n      // XmlToken: \"\n      // JSEmbeddedContent\n      // XmlToken \"\n\n      // Actually IDEA shouldn't ask for injected languages at all in this case.\n      final PsiElement[] children = value.getChildren();\n      if (children.length < 3 || !(children[1] instanceof XmlToken) ||\n          ((XmlToken)children[1]).getTokenType() != XmlTokenType.XML_ATTRIBUTE_VALUE_TOKEN) {\n        return;\n      }\n\n      List<BaseInjection> injections = myConfiguration.getInjections(LanguageInjectionSupport.XML_SUPPORT_ID);\n      //noinspection ForLoopReplaceableByForEach\n      for (int i = 0, size = injections.size(); i < size; i++) {\n        BaseInjection injection = injections.get(i);\n        if (injection.acceptsPsiElement(attribute)) {\n          final Language language = InjectedLanguage.findLanguageById(injection.getInjectedLanguageId());\n          if (language == null) continue;\n          final boolean separateFiles = !injection.isSingleFile() && StringUtil.isNotEmpty(injection.getValuePattern());\n\n          final List<TextRange> ranges = injection.getInjectedArea(value);\n          if (ranges.isEmpty()) continue;\n          final List<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>> result = new ArrayList<Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange>>();\n          final InjectedLanguage l =\n            InjectedLanguage.create(injection.getInjectedLanguageId(), injection.getPrefix(), injection.getSuffix(), false);\n          for (TextRange textRange : ranges) {\n            result.add(Trinity.create((PsiLanguageInjectionHost)value, l, textRange));\n          }\n          if (separateFiles) {\n            for (Trinity<PsiLanguageInjectionHost, InjectedLanguage, TextRange> trinity : result) {\n              processor.process(language, Collections.singletonList(trinity));\n            }\n          }\n          else {\n            processor.process(language, result);\n          }\n          if (injection.isTerminal()) {\n            break;\n          }\n        }\n      }\n    }\n  }","commit_id":"5acfd4e1beaf73f55397404c2f532395f1689fd8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public synchronized void runTransaction(PomTransaction transaction,\n                                          PomModelAspect aspect) throws IncorrectOperationException{\n    final ProgressIndicator progressIndicator = ProgressManager.getInstance().getProgressIndicator();\n    if(progressIndicator != null) progressIndicator.startNonCancelableSection();\n    try{\n    synchronized(PsiLock.LOCK){\n      final PsiDocumentManagerImpl manager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(myPomProject.getPsiProject());\n      final PsiToDocumentSynchronizer synchronizer = manager.getSynchronizer();\n      Document document = null;\n      if(transaction.getChangeScope().getContainingFile() != null) {\n        document = manager.getDocument(transaction.getChangeScope().getContainingFile());\n      }\n      myBlockedAspects.push(aspect);\n      if(document != null) synchronizer.startTransaction(document, transaction.getChangeScope());\n      final PomModelEvent event;\n      try{\n        event = transaction.run();\n        if(event == null) return;\n      }\n      catch(IncorrectOperationException ioe){\n        return;\n      }\n      finally{\n        if(document != null) synchronizer.commitTransaction(document);\n        myBlockedAspects.pop();\n      }\n\n      final List<PomModelAspect> dependants = getAllDependants(aspect);\n      { // update\n        final Iterator<PomModelAspect> depsIter = dependants.iterator();\n        while (depsIter.hasNext()) {\n          final PomModelAspect modelAspect = depsIter.next();\n          if(myBlockedAspects.contains(modelAspect)) continue;\n          modelAspect.update(event);\n        }\n      }\n      {\n        final Iterator<PomModelListener> listenersIterator = myListeners.iterator();\n        while (listenersIterator.hasNext()) listenersIterator.next().modelChanged(event);\n      }\n    }\n    }\n    finally{\n      if(progressIndicator != null) progressIndicator.finishNonCancelableSection();\n    }\n  }","id":67302,"modified_method":"public synchronized void runTransaction(PomTransaction transaction,\n                                          PomModelAspect aspect) throws IncorrectOperationException{\n    final ProgressIndicator progressIndicator = ProgressManager.getInstance().getProgressIndicator();\n    if(progressIndicator != null) progressIndicator.startNonCancelableSection();\n    final PsiDocumentManagerImpl manager = (PsiDocumentManagerImpl)PsiDocumentManager.getInstance(myPomProject.getPsiProject());\n    final PsiToDocumentSynchronizer synchronizer = manager.getSynchronizer();\n    Document document = null;\n\n    try{\n    synchronized(PsiLock.LOCK){\n      if(transaction.getChangeScope().getContainingFile() != null) {\n        document = manager.getDocument(transaction.getChangeScope().getContainingFile());\n      }\n      myBlockedAspects.push(aspect);\n      if(document != null) synchronizer.startTransaction(document, transaction.getChangeScope());\n      final PomModelEvent event;\n      try{\n        event = transaction.run();\n        if(event == null) return;\n      }\n      catch(IncorrectOperationException ioe){\n        return;\n      }\n      finally{\n        myBlockedAspects.pop();\n      }\n\n      final List<PomModelAspect> dependants = getAllDependants(aspect);\n      { // update\n        final Iterator<PomModelAspect> depsIter = dependants.iterator();\n        while (depsIter.hasNext()) {\n          final PomModelAspect modelAspect = depsIter.next();\n          if(myBlockedAspects.contains(modelAspect)) continue;\n          modelAspect.update(event);\n        }\n      }\n      {\n        final Iterator<PomModelListener> listenersIterator = myListeners.iterator();\n        while (listenersIterator.hasNext()) listenersIterator.next().modelChanged(event);\n      }\n    }\n    }\n    finally{\n      if(document != null) synchronizer.commitTransaction(document);\n      if(progressIndicator != null) progressIndicator.finishNonCancelableSection();\n    }\n  }","commit_id":"df2896c6c73ee380f4ff78daa5d8fa37b5be974d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doSync(PsiTreeChangeEvent event, DocSyncAction syncAction) {\n    if (!toProcessPsiEvent()) {\n      return;\n    }\n    PsiFile psiFile = event.getFile();\n    if (psiFile == null) return;\n    DocumentEx document = getCachedDocument(psiFile);\n    if (document == null) return;\n\n    TextBlock textBlock = getTextBlock(document);\n    if (!textBlock.isEmpty()) {\n      LOG.error(\"Attempt to modify PSI for non-commited Document!\");\n      textBlock.clear();\n    }\n\n    boolean isOriginal = isOriginal(event.getParent(), psiFile, document);\n\n    if (isOriginal) {\n      myPsiDocumentManager.setProcessDocumentEvents(false);\n      syncAction.syncDocument(document, (PsiTreeChangeEventImpl)event);\n      myPsiDocumentManager.setProcessDocumentEvents(true);\n\n      if(!myTransactionsMap.containsKey(document)){\n        document.setModificationStamp(psiFile.getModificationStamp());\n        mySmartPointerManager.synchronizePointers(psiFile);\n        if (LOG.isDebugEnabled()) {\n          PsiDocumentManagerImpl.checkConsistency(psiFile, document);\n          if (psiFile instanceof JspxFileImpl) {\n            ( (JspxFileImpl)psiFile).checkAllConsistent();\n          }\n        }\n      }\n    }\n  }","id":67303,"modified_method":"private void doSync(PsiTreeChangeEvent event, DocSyncAction syncAction) {\n    if (!toProcessPsiEvent()) {\n      return;\n    }\n    PsiFile psiFile = event.getFile();\n    if (psiFile == null) return;\n    DocumentEx document = getCachedDocument(psiFile);\n    if (document == null) return;\n\n    TextBlock textBlock = getTextBlock(document);\n    if (!textBlock.isEmpty()) {\n      LOG.error(\"Attempt to modify PSI for non-commited Document!\");\n      textBlock.clear();\n    }\n\n    boolean isOriginal = isOriginal(event.getParent(), psiFile, document);\n\n    if (isOriginal) {\n      final boolean insideTransaction = myTransactionsMap.containsKey(document);\n\n      myPsiDocumentManager.setProcessDocumentEvents(false);\n      syncAction.syncDocument(document, (PsiTreeChangeEventImpl)event);\n      if(!insideTransaction) document.setModificationStamp(psiFile.getModificationStamp());\n      myPsiDocumentManager.setProcessDocumentEvents(true);\n\n      if(!insideTransaction){\n        mySmartPointerManager.synchronizePointers(psiFile);\n        if (LOG.isDebugEnabled()) {\n          PsiDocumentManagerImpl.checkConsistency(psiFile, document);\n          if (psiFile instanceof JspxFileImpl) {\n            ( (JspxFileImpl)psiFile).checkAllConsistent();\n          }\n        }\n      }\n    }\n  }","commit_id":"df2896c6c73ee380f4ff78daa5d8fa37b5be974d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void _addImport(PsiJavaCodeReferenceElement ref, PsiClass targetClass) {\n    if (ref.isValid() && targetClass.isValid()){\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      RangeMarker caretMarker = (myEditor.getDocument()).createRangeMarker(caretOffset, caretOffset);\n      int colByOffset = myEditor.offsetToLogicalPosition(caretOffset).column;\n      int col = myEditor.getCaretModel().getLogicalPosition().column;\n      int virtualSpace = col != colByOffset ? col - colByOffset : 0;\n      int line = myEditor.getCaretModel().getLogicalPosition().line;\n      LogicalPosition pos = new LogicalPosition(line, 0);\n      myEditor.getCaretModel().moveToLogicalPosition(pos);\n\n      try{\n        if (!(ref instanceof PsiImportStaticReferenceElement)) {\n          ref.bindToElement(targetClass);\n        }\n        else {\n          ((PsiImportStaticReferenceElement)ref).bindToTargetClass(targetClass);\n        }\n      }\n      catch(IncorrectOperationException e){\n        LOG.error(e);\n      }\n\n      line = myEditor.getCaretModel().getLogicalPosition().line;\n      LogicalPosition pos1 = new LogicalPosition(line, col);\n      myEditor.getCaretModel().moveToLogicalPosition(pos1);\n      if (caretMarker.isValid()){\n        LogicalPosition pos2 = myEditor.offsetToLogicalPosition(caretMarker.getStartOffset());\n        int newCol = pos2.column + virtualSpace;\n        myEditor.getCaretModel().moveToLogicalPosition(new LogicalPosition(pos2.line, newCol));\n        myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      }\n    }\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(myProject);\n        if (daemonCodeAnalyzer != null) {\n          daemonCodeAnalyzer.updateVisibleHighlighters(myEditor);\n        }\n      }\n    });\n  }","id":67304,"modified_method":"private void _addImport(PsiJavaCodeReferenceElement ref, PsiClass targetClass) {\n    if (ref.isValid() && targetClass.isValid()){\n      int caretOffset = myEditor.getCaretModel().getOffset();\n      RangeMarker caretMarker = (myEditor.getDocument()).createRangeMarker(caretOffset, caretOffset);\n      int colByOffset = myEditor.offsetToLogicalPosition(caretOffset).column;\n      int col = myEditor.getCaretModel().getLogicalPosition().column;\n      int virtualSpace = col != colByOffset ? col - colByOffset : 0;\n      int line = myEditor.getCaretModel().getLogicalPosition().line;\n      LogicalPosition pos = new LogicalPosition(line, 0);\n      myEditor.getCaretModel().moveToLogicalPosition(pos);\n\n      try{\n        if (ref instanceof PsiImportStaticReferenceElement) {\n          ((PsiImportStaticReferenceElement)ref).bindToTargetClass(targetClass);\n        }\n        else {\n          ref.bindToElement(targetClass);\n        }\n      }\n      catch(IncorrectOperationException e){\n        LOG.error(e);\n      }\n\n      line = myEditor.getCaretModel().getLogicalPosition().line;\n      LogicalPosition pos1 = new LogicalPosition(line, col);\n      myEditor.getCaretModel().moveToLogicalPosition(pos1);\n      if (caretMarker.isValid()){\n        LogicalPosition pos2 = myEditor.offsetToLogicalPosition(caretMarker.getStartOffset());\n        int newCol = pos2.column + virtualSpace;\n        myEditor.getCaretModel().moveToLogicalPosition(new LogicalPosition(pos2.line, newCol));\n        myEditor.getScrollingModel().scrollToCaret(ScrollType.RELATIVE);\n      }\n    }\n\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      public void run() {\n        DaemonCodeAnalyzer daemonCodeAnalyzer = DaemonCodeAnalyzer.getInstance(myProject);\n        if (daemonCodeAnalyzer != null) {\n          daemonCodeAnalyzer.updateVisibleHighlighters(myEditor);\n        }\n      }\n    });\n  }","commit_id":"a14545b770ce95e7858aa67269281361977ca386","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doSync(PsiTreeChangeEvent event, DocSyncAction syncAction) {\n    if (!toProcessPsiEvent()) {\n      return;\n    }\n    PsiFile psiFile = event.getFile();\n    if (psiFile == null) return;\n    DocumentEx document = getCachedDocument(psiFile);\n    if (document == null) return;\n\n    TextBlock textBlock = getTextBlock(document);\n    if (!textBlock.isEmpty()) {\n      LOG.error(\"Attempt to modify PSI for non-commited Document!\");\n      textBlock.clear();\n    }\n\n    boolean isOriginal = isOriginal(event.getParent(), psiFile, document);\n\n    if (isOriginal) {\n      final boolean insideTransaction = myTransactionsMap.containsKey(document);\n\n      myPsiDocumentManager.setProcessDocumentEvents(false);\n      syncAction.syncDocument(document, (PsiTreeChangeEventImpl)event);\n      if(!insideTransaction) document.setModificationStamp(psiFile.getModificationStamp());\n      myPsiDocumentManager.setProcessDocumentEvents(true);\n\n      if(!insideTransaction){\n        mySmartPointerManager.synchronizePointers(psiFile);\n        if (LOG.isDebugEnabled()) {\n          PsiDocumentManagerImpl.checkConsistency(psiFile, document);\n          if (psiFile instanceof JspxFileImpl) {\n            ( (JspxFileImpl)psiFile).checkAllConsistent();\n          }\n        }\n      }\n    }\n  }","id":67305,"modified_method":"private void doSync(PsiTreeChangeEvent event, DocSyncAction syncAction) {\n    if (!toProcessPsiEvent()) {\n      return;\n    }\n    PsiFile psiFile = event.getFile();\n    if (psiFile == null) return;\n    DocumentEx document = getCachedDocument(psiFile);\n    if (document == null) return;\n\n    TextBlock textBlock = getTextBlock(document);\n    if (!textBlock.isEmpty()) {\n      LOG.error(\"Attempt to modify PSI for non-commited Document!\");\n      textBlock.clear();\n    }\n\n    if (!isOriginal(event.getParent(), psiFile, document)) {\n      return;\n    }\n\n    myPsiDocumentManager.setProcessDocumentEvents(false);\n    syncAction.syncDocument(document, (PsiTreeChangeEventImpl)event);\n    myPsiDocumentManager.setProcessDocumentEvents(true);\n\n    final boolean insideTransaction = myTransactionsMap.containsKey(document);\n    if(!insideTransaction){\n      document.setModificationStamp(psiFile.getModificationStamp());\n      mySmartPointerManager.synchronizePointers(psiFile);\n      if (LOG.isDebugEnabled()) {\n        PsiDocumentManagerImpl.checkConsistency(psiFile, document);\n        if (psiFile instanceof JspxFileImpl) {\n          ((JspxFileImpl)psiFile).checkAllConsistent();\n        }\n      }\n    }\n  }","commit_id":"a14545b770ce95e7858aa67269281361977ca386","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void commitTransaction(Document document){\n    final DocumentChangeTransaction documentChangeTransaction = myTransactionsMap.get(document);\n    myTransactionsMap.remove(document);\n    if(documentChangeTransaction == null) return;\n    if(documentChangeTransaction.getAffectedFragments().size() == 0) return; // Nothing to do\n\n    final PsiElement changeScope = documentChangeTransaction.getChangeScope();\n    final PsiTreeChangeEventImpl fakeEvent = new PsiTreeChangeEventImpl(changeScope.getManager());\n    fakeEvent.setParent(changeScope);\n    fakeEvent.setFile(changeScope.getContainingFile());\n    doSync(fakeEvent, new DocSyncAction() {\n      public void syncDocument(Document document, PsiTreeChangeEventImpl event) {\n        doCommitTransaction(document, documentChangeTransaction);\n      }\n    });\n  }","id":67306,"modified_method":"public void commitTransaction(Document document){\n    final DocumentChangeTransaction documentChangeTransaction = myTransactionsMap.remove(document);\n    if(documentChangeTransaction == null) return;\n    if(documentChangeTransaction.getAffectedFragments().size() == 0) return; // Nothing to do\n\n    final PsiElement changeScope = documentChangeTransaction.getChangeScope();\n    final PsiTreeChangeEventImpl fakeEvent = new PsiTreeChangeEventImpl(changeScope.getManager());\n    fakeEvent.setParent(changeScope);\n    fakeEvent.setFile(changeScope.getContainingFile());\n    doSync(fakeEvent, new DocSyncAction() {\n      public void syncDocument(Document document, PsiTreeChangeEventImpl event) {\n        doCommitTransaction(document, documentChangeTransaction);\n      }\n    });\n  }","commit_id":"a14545b770ce95e7858aa67269281361977ca386","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void replace(int start, int length, String str){\n      final int startInFragment;\n      final StringBuffer fragmentReplaceText;\n\n      { // calculating fragment\n        { // minimize replace\n          final int oldStart = start;\n          int end = start + length;\n\n          final int newStringLength = str.length();\n          final String chars = getText(start, length + start);\n          int newStartInString = 0;\n          int newEndInString = newStringLength;\n          {\n            while (newStartInString < newStringLength &&\n                   start < end &&\n                   str.charAt(newStartInString) == chars.charAt(start - oldStart)) {\n              start++;\n              newStartInString++;\n            }\n\n            while (end > start &&\n                   newEndInString > newStartInString &&\n                   str.charAt(newEndInString - 1) == chars.charAt(end - oldStart - 1)) {\n              newEndInString--;\n              end--;\n            }\n          }\n\n          str = str.substring(newStartInString, newEndInString);\n          length = end - start;\n        }\n\n        final Pair<MutableTextRange, StringBuffer> fragment = getFragmentByRange(start, length);\n        fragmentReplaceText = fragment.getSecond();\n        startInFragment = start - fragment.getFirst().getStartOffset();\n        { // text range adjustment\n          final int lengthDiff = str.length() - length;\n          final Iterator<Pair<MutableTextRange, StringBuffer>> iterator = myAffectedFragments.iterator();\n          boolean adjust = false;\n          while (iterator.hasNext()) {\n            final Pair<MutableTextRange, StringBuffer> pair = iterator.next();\n            if(adjust) pair.getFirst().shift(lengthDiff);\n            if(pair == fragment)\n              adjust = true;\n          }\n        }\n      }\n\n      fragmentReplaceText.replace(startInFragment, startInFragment + length, str);\n    }","id":67307,"modified_method":"public void replace(int start, int length, String str){\n      final int startInFragment;\n      final StringBuffer fragmentReplaceText;\n\n      { // calculating fragment\n        { // minimize replace\n          final int oldStart = start;\n          int end = start + length;\n\n          final int newStringLength = str.length();\n          final String chars = getText(start, end);\n          int newStartInString = 0;\n          int newEndInString = newStringLength;\n          while (newStartInString < newStringLength &&\n                 start < end &&\n                 str.charAt(newStartInString) == chars.charAt(start - oldStart)) {\n            start++;\n            newStartInString++;\n          }\n          while (end > start &&\n                 newEndInString > newStartInString &&\n                 str.charAt(newEndInString - 1) == chars.charAt(end - oldStart - 1)) {\n            newEndInString--;\n            end--;\n          }\n\n          str = str.substring(newStartInString, newEndInString);\n          length = end - start;\n        }\n\n        final Pair<MutableTextRange, StringBuffer> fragment = getFragmentByRange(start, length);\n        fragmentReplaceText = fragment.getSecond();\n        startInFragment = start - fragment.getFirst().getStartOffset();\n        { // text range adjustment\n          final int lengthDiff = str.length() - length;\n          final Iterator<Pair<MutableTextRange, StringBuffer>> iterator = myAffectedFragments.iterator();\n          boolean adjust = false;\n          while (iterator.hasNext()) {\n            final Pair<MutableTextRange, StringBuffer> pair = iterator.next();\n            if(adjust) pair.getFirst().shift(lengthDiff);\n            if(pair == fragment)\n              adjust = true;\n          }\n        }\n      }\n\n      fragmentReplaceText.replace(startInFragment, startInFragment + length, str);\n    }","commit_id":"a14545b770ce95e7858aa67269281361977ca386","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void commitTransaction(Document document){\n    final DocumentChangeTransaction documentChangeTransaction = myTransactionsMap.get(document);\n    try{\n      if(documentChangeTransaction == null) return;\n      if(documentChangeTransaction.getAffectedFragments().size() == 0) return; // Nothing to do\n\n      final PsiElement changeScope = documentChangeTransaction.getChangeScope();\n      final PsiTreeChangeEventImpl fakeEvent = new PsiTreeChangeEventImpl(changeScope.getManager());\n      fakeEvent.setParent(changeScope);\n      fakeEvent.setFile(changeScope.getContainingFile());\n      doSync(fakeEvent, new DocSyncAction() {\n        public void syncDocument(Document document, PsiTreeChangeEventImpl event) {\n          doCommitTransaction(document, documentChangeTransaction);\n        }\n      });\n    }\n    finally{\n      myTransactionsMap.remove(document);\n    }\n  }","id":67308,"modified_method":"public void commitTransaction(Document document){\n    final DocumentChangeTransaction documentChangeTransaction = myTransactionsMap.get(document);\n    myTransactionsMap.remove(document);\n    if(documentChangeTransaction == null) return;\n    if(documentChangeTransaction.getAffectedFragments().size() == 0) return; // Nothing to do\n\n    final PsiElement changeScope = documentChangeTransaction.getChangeScope();\n    final PsiTreeChangeEventImpl fakeEvent = new PsiTreeChangeEventImpl(changeScope.getManager());\n    fakeEvent.setParent(changeScope);\n    fakeEvent.setFile(changeScope.getContainingFile());\n    doSync(fakeEvent, new DocSyncAction() {\n      public void syncDocument(Document document, PsiTreeChangeEventImpl event) {\n        doCommitTransaction(document, documentChangeTransaction);\n      }\n    });\n  }","commit_id":"0a929ebad41a64ca7cc972f3d2460c17258b677f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doSync(PsiTreeChangeEvent event, DocSyncAction syncAction) {\n    if (!toProcessPsiEvent()) {\n      return;\n    }\n    PsiFile psiFile = event.getFile();\n    if (psiFile == null) return;\n    DocumentEx document = getCachedDocument(psiFile);\n    if (document == null) return;\n\n    TextBlock textBlock = getTextBlock(document);\n    if (!textBlock.isEmpty()) {\n      LOG.error(\"Attempt to modify PSI for non-commited Document!\");\n      textBlock.clear();\n    }\n\n    boolean isOriginal = true;\n    if(event.getParent() != null){\n      ASTNode element = SourceTreeToPsiMap.psiElementToTree(event.getParent());\n      while(element != null && !(element instanceof FileElement)) {\n        element = element.getTreeParent();\n      }\n      PsiFile fileForDoc = PsiDocumentManager.getInstance(psiFile.getProject()).getPsiFile(document);\n\n      isOriginal = element != null ? fileForDoc == SourceTreeToPsiMap.treeElementToPsi(element) : false;\n      LOG.debug(\"DOCSync: \" + isOriginal + \"; document=\" + document+\"; file=\"+psiFile.getName() + \":\" +\n                psiFile.getClass() +\"; file for doc=\"+fileForDoc.getName()+\"; virtualfile=\"+psiFile.getVirtualFile());\n    }\n\n    if (isOriginal) {\n      myPsiDocumentManager.setProcessDocumentEvents(false);\n      syncAction.syncDocument(document, (PsiTreeChangeEventImpl)event);\n      document.setModificationStamp(psiFile.getModificationStamp());\n      myPsiDocumentManager.setProcessDocumentEvents(true);\n      mySmartPointerManager.synchronizePointers(psiFile);\n      if (LOG.isDebugEnabled()) {\n        PsiDocumentManagerImpl.checkConsistency(psiFile, document);\n        if (psiFile instanceof JspxFileImpl) {\n            ( (JspxFileImpl)psiFile).checkAllConsistent();\n        }\n      }\n    }\n  }","id":67309,"modified_method":"private void doSync(PsiTreeChangeEvent event, DocSyncAction syncAction) {\n    if (!toProcessPsiEvent()) {\n      return;\n    }\n    PsiFile psiFile = event.getFile();\n    if (psiFile == null) return;\n    DocumentEx document = getCachedDocument(psiFile);\n    if (document == null) return;\n\n    TextBlock textBlock = getTextBlock(document);\n    if (!textBlock.isEmpty()) {\n      LOG.error(\"Attempt to modify PSI for non-commited Document!\");\n      textBlock.clear();\n    }\n\n    boolean isOriginal = isOriginal(event.getParent(), psiFile, document);\n\n    if (isOriginal) {\n      myPsiDocumentManager.setProcessDocumentEvents(false);\n      syncAction.syncDocument(document, (PsiTreeChangeEventImpl)event);\n      myPsiDocumentManager.setProcessDocumentEvents(true);\n\n      if(!myTransactionsMap.containsKey(document)){\n        document.setModificationStamp(psiFile.getModificationStamp());\n        mySmartPointerManager.synchronizePointers(psiFile);\n        if (LOG.isDebugEnabled()) {\n          PsiDocumentManagerImpl.checkConsistency(psiFile, document);\n          if (psiFile instanceof JspxFileImpl) {\n            ( (JspxFileImpl)psiFile).checkAllConsistent();\n          }\n        }\n      }\n    }\n  }","commit_id":"0a929ebad41a64ca7cc972f3d2460c17258b677f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String asAddressString() {\n        final StringBuffer sb = new StringBuffer();\n\n        if (this.getAddress1() != null) {\n            sb.append(this.getAddress1());\n            if (this.getAddress2() != null) {\n                sb.append(\" \").append(this.getAddress2());\n            }\n        }\n\n        if (this.getCity() != null) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCity());\n        }\n        if (this.getState() != null) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getState());\n        }\n        if (this.getZip() != null) {\n            if (this.getState() != null) {\n                sb.append(\" \");\n            } else if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(this.getZip());\n        }\n        if (this.getCountry() != null) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCountry());\n        }\n\n        return sb.toString();\n    }","id":67310,"modified_method":"public String asAddressString() {\n        final StringBuffer sb = new StringBuffer();\n\n        if (hasText(this.getAddress1())) {\n            sb.append(this.getAddress1());\n            if (hasText(this.getAddress2())) {\n                sb.append(\" \").append(this.getAddress2());\n            }\n        }\n\n        if (hasText(this.getCity())) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCity());\n        }\n        if (hasText(this.getState())) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getState());\n        }\n        if (hasText(this.getZip())) {\n            if (hasText(this.getState())) {\n                sb.append(\" \");\n            } else if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(this.getZip());\n        }\n        if (hasText(this.getCountry())) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCountry());\n        }\n\n        if (sb.length() == 0) {\n            return null;\n        }\n\n        return sb.toString();\n    }","commit_id":"b20aa845599eeeecce8e88a02a7d9a6c4f905b2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                \"USA\",\n                \"220 Chatham Business Dr, Pittsboro, NC 27312, USA\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC 27312\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                null,\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                null,\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, 27312\"\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \"PR7 3JE\",\n                \"UK\",\n                \"PR7 3JE, UK\"\n            },\n        });\n    }","id":67311,"modified_method":"@Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                \"USA\",\n                \"220 Chatham Business Dr, Pittsboro, NC 27312, USA\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC 27312\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                null,\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                null,\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, 27312\"\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \"PR7 3JE\",\n                \"UK\",\n                \"PR7 3JE, UK\"\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \" \",\n                \" \",\n                null\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \"\",\n                \"\",\n                null\n            }\n        });\n    }","commit_id":"b20aa845599eeeecce8e88a02a7d9a6c4f905b2a","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public String asAddressString() {\n        final StringBuffer sb = new StringBuffer();\n\n        if (this.getAddress1() != null) {\n            sb.append(this.getAddress1());\n            if (this.getAddress2() != null) {\n                sb.append(\" \").append(this.getAddress2());\n            }\n        }\n\n        if (this.getCity() != null) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCity());\n        }\n        if (this.getState() != null) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getState());\n        }\n        if (this.getZip() != null) {\n            if (this.getState() != null) {\n                sb.append(\" \");\n            } else if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(this.getZip());\n        }\n        if (this.getCountry() != null) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCountry());\n        }\n\n        return sb.toString();\n    }","id":67312,"modified_method":"public String asAddressString() {\n        final StringBuffer sb = new StringBuffer();\n\n        if (hasText(this.getAddress1())) {\n            sb.append(this.getAddress1());\n            if (hasText(this.getAddress2())) {\n                sb.append(\" \").append(this.getAddress2());\n            }\n        }\n\n        if (hasText(this.getCity())) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCity());\n        }\n        if (hasText(this.getState())) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getState());\n        }\n        if (hasText(this.getZip())) {\n            if (hasText(this.getState())) {\n                sb.append(\" \");\n            } else if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(this.getZip());\n        }\n        if (hasText(this.getCountry())) {\n            if (sb.length() > 0) sb.append(\", \");\n            sb.append(this.getCountry());\n        }\n\n        if (sb.length() == 0) {\n            return null;\n        }\n\n        return sb.toString();\n    }","commit_id":"07f341e09744fcb1da160f5182be4485ab33e9e0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"@Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                \"USA\",\n                \"220 Chatham Business Dr, Pittsboro, NC 27312, USA\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC 27312\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                null,\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                null,\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, 27312\"\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \"PR7 3JE\",\n                \"UK\",\n                \"PR7 3JE, UK\"\n            },\n        });\n    }","id":67313,"modified_method":"@Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][] {\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                \"USA\",\n                \"220 Chatham Business Dr, Pittsboro, NC 27312, USA\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC 27312\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                \"NC\",\n                null,\n                null,\n                \"220 Chatham Business Dr, Pittsboro, NC\"\n            },\n            {\n                \"220 Chatham Business Dr\",\n                null,\n                \"Pittsboro\",\n                null,\n                \"27312\",\n                null,\n                \"220 Chatham Business Dr, Pittsboro, 27312\"\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \"PR7 3JE\",\n                \"UK\",\n                \"PR7 3JE, UK\"\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \" \",\n                \" \",\n                null\n            },\n            {\n                null,\n                null,\n                null,\n                null,\n                \"\",\n                \"\",\n                null\n            }\n        });\n    }","commit_id":"07f341e09744fcb1da160f5182be4485ab33e9e0","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/** {@inheritDoc}\n     * @throws JspException\n     */\n    public int doStartTag() throws JspException {\n\n        JspWriter out = null;\n        // TODO mmccune - determine if we should use a more expanded tagset\n        // style system as found in the addresses.pxt/address_list.pxi.\n        // This is a bit more inline Java->HTML than I like.  Hard to re-arrange\n        // the layout if necessary.  Perhaps an expanded taglib vs one big tag\n        // that does all the work.\n        try {\n            out = pageContext.getOut();\n            LocalizationService ls = LocalizationService.getInstance();\n\n            StringBuilder result = new StringBuilder();\n            StringBuilder key = new StringBuilder(\"address type \");\n            key.append(type);\n            result.append(\"<div class=\\\"mail-address-border\\\">\");\n            result.append(\"<div class=\\\"container\\\">\");\n            result.append(\"<h1>\");\n            result.append(ls.getMessage(key.toString()));\n            result.append(\"<\/h1>\");\n            if (user == null) {\n                throw new IllegalArgumentException(\"User is null\");\n            }\n\n            // If this Address is new\n            if (address != null &&\n                address.getCity() != null &&\n                address.getZip() != null) {\n\n                // Address 1 and 2\n                result.append(\"<p>\");\n                result.append(address.getAddress1());\n                if (address.getAddress2() != null) {\n                    result.append(\"<br/>\");\n                    result.append(address.getAddress2());\n                }\n                result.append(\"<br/>\");\n\n                // Sity\n                result.append(address.getCity());\n                if (address.getState() != null) {\n                    result.append(\", \");\n                    result.append(address.getState());\n                }\n                result.append(\" \");\n                result.append(address.getZip());\n                result.append(\"<\/p>\");\n\n                // Phones\n                result.append(\"<p>\");\n                result.append(ls.getMessage(\"phone\"));\n                result.append(\": \");\n                result.append(address.getPhone());\n                result.append(\"<br/>\");\n                result.append(ls.getMessage(\"fax\"));\n                result.append(\": \");\n                if (address.getFax() != null) {\n                    result.append(address.getFax());\n                }\n                result.append(\"<\/p>\");\n\n                result.append(\"<p>\");\n                result.append(\"<a \")\n                      .append(\"class=\\\"btn btn-success btn-lg\\\"\")\n                      .append(\"href=\\\"\")\n                      .append(getActionUrl())\n                      .append(\"/EditAddress.do?type=\")\n                      .append(type)\n                      .append(\"&amp;uid=\")\n                      .append(String.valueOf(user.getId()))\n                      .append(\"\\\">\")\n                      .append(ls.getMessage(\"Edit this address\"))\n                      .append(\"<\/a>\");\n                result.append(\"<\/p>\");\n            }\n            else {\n                result.append(\"<div class=\\\"alert alert-info\\\">\");\n                result.append(ls.getMessage(\"address not filled out\"));\n                result.append(\"<\/div>\");\n                result.append(\"<p>\");\n                result.append(\"<a \")\n                      .append(\"class=\\\"btn btn-success btn-lg\\\"\")\n                      .append(\" href=\\\"\")\n                      .append(getActionUrl())\n                      .append(\"/EditAddress.do?type=\")\n                      .append(type)\n                      .append(\"&amp;uid=\")\n                      .append(String.valueOf(user.getId()))\n                      .append(\"\\\">\")\n                      .append(ls.getMessage(\"Add this address\"))\n                      .append(\"<\/a>\");\n                result.append(\"<\/p>\");\n            }\n            result.append(\"<\/div>\");\n            result.append(\"<\/div>\");\n\n            out.print(result);\n        }\n        catch (IOException ioe) {\n            throw new JspException(\"IO error writing to JSP file:\", ioe);\n        }\n\n        return (SKIP_BODY);\n    }","id":67314,"modified_method":"/** {@inheritDoc}\n     * @throws JspException\n     */\n    public int doStartTag() throws JspException {\n\n        JspWriter out = null;\n        // TODO mmccune - determine if we should use a more expanded tagset\n        // style system as found in the addresses.pxt/address_list.pxi.\n        // This is a bit more inline Java->HTML than I like.  Hard to re-arrange\n        // the layout if necessary.  Perhaps an expanded taglib vs one big tag\n        // that does all the work.\n        try {\n            out = pageContext.getOut();\n            LocalizationService ls = LocalizationService.getInstance();\n\n            StringBuilder result = new StringBuilder();\n            StringBuilder key = new StringBuilder(\"address type \");\n            key.append(type);\n            result.append(\"<strong>\");\n            result.append(ls.getMessage(key.toString()));\n            result.append(\"<\/strong>\");\n            if (user == null) {\n                throw new IllegalArgumentException(\"User is null\");\n            }\n\n            // If this Address is new\n            if (address != null &&\n                StringUtils.isNotBlank(address.getCity()) &&\n                StringUtils.isNotBlank(address.getZip())) {\n                result.append(\"<address>\");\n                // Address 1 and 2\n                result.append(address.getAddress1());\n                result.append(\"<br>\");\n                if (StringUtils.isNotBlank(address.getAddress2())) {\n                    result.append(address.getAddress2());\n                    result.append(\"<br>\");\n                }\n\n                // City\n                result.append(address.getCity());\n                if (StringUtils.isNotBlank(address.getState())) {\n                    result.append(\", \");\n                    result.append(address.getState());\n                }\n\n                result.append(\" \");\n                result.append(address.getZip());\n                result.append(\"<br>\");\n\n                // Phones\n                result.append(ls.getMessage(\"phone\"));\n                result.append(\": \");\n                result.append(address.getPhone());\n                result.append(\"<br>\");\n                if (StringUtils.isNotBlank(address.getFax())) {\n                    result.append(ls.getMessage(\"fax\"));\n                    result.append(\": \");\n                    result.append(address.getFax());\n                    result.append(\"<br>\");\n                }\n\n                result.append(\"<\/address>\");\n\n                result.append(\"<p>\");\n                result.append(\"<a \")\n                      .append(\"class=\\\"btn btn-primary\\\"\")\n                      .append(\"href=\\\"\")\n                      .append(getActionUrl())\n                      .append(\"/EditAddress.do?type=\")\n                      .append(type)\n                      .append(\"&amp;uid=\")\n                      .append(String.valueOf(user.getId()))\n                      .append(\"\\\">\")\n                      .append(ls.getMessage(\"Edit this address\"))\n                      .append(\"<\/a>\");\n                result.append(\"<\/p>\");\n            }\n            else {\n                result.append(\"<div class=\\\"alert alert-info\\\">\");\n                result.append(ls.getMessage(\"address not filled out\"));\n                result.append(\"<\/div>\");\n                result.append(\"<p>\");\n                result.append(\"<a \")\n                      .append(\"class=\\\"btn btn-primary\\\"\")\n                      .append(\" href=\\\"\")\n                      .append(getActionUrl())\n                      .append(\"/EditAddress.do?type=\")\n                      .append(type)\n                      .append(\"&amp;uid=\")\n                      .append(String.valueOf(user.getId()))\n                      .append(\"\\\">\")\n                      .append(ls.getMessage(\"Add this address\"))\n                      .append(\"<\/a>\");\n                result.append(\"<\/p>\");\n            }\n\n            out.print(result);\n        }\n        catch (IOException ioe) {\n            throw new JspException(\"IO error writing to JSP file:\", ioe);\n        }\n\n        return (SKIP_BODY);\n    }","commit_id":"20d40a632802f326cfcdcbff5098d31cfd5ec773","url":"https://github.com/spacewalkproject/spacewalk"},{"original_method":"private byte[] assembleDHParams(byte[] nonceInitiator,byte[] nonceResponder,BigInteger initiatorExponential, BigInteger responderExponential, byte[] id) {\n\t\tbyte[] _initiatorExponential = stripBigIntegerToNetworkFormat(initiatorExponential);\n\t\tbyte[] _responderExponential = stripBigIntegerToNetworkFormat(responderExponential);\n\t\tbyte[] toSign = new byte[nonceInitiator.length + nonceResponder.length + _initiatorExponential.length + _responderExponential.length + id.length];\n\t\tint offset = 0;\n\t\t\n\t\tSystem.arraycopy(nonceInitiator, 0,toSign,offset,nonceInitiator.length);\n\t\toffset += nonceInitiator.length;\n\t\tSystem.arraycopy(nonceResponder,0 ,toSign,offset,nonceResponder.length);\n\t\toffset += nonceResponder.length;\n\t\tSystem.arraycopy(_initiatorExponential, 0, toSign,offset, _initiatorExponential.length);\n\t\toffset += _initiatorExponential.length;\n\t\tSystem.arraycopy(_responderExponential, 0, toSign, offset, _responderExponential.length);\n\t\toffset += _responderExponential.length;\n\t\tSystem.arraycopy(id, 0, toSign , offset,id.length);\n\n\t\treturn SHA256.digest(toSign);\n\t}","id":67315,"modified_method":"private byte[] assembleDHParams(byte[] nonceInitiator,byte[] nonceResponder,BigInteger initiatorExponential, BigInteger responderExponential, byte[] id) {\n\t\tbyte[] _initiatorExponential = stripBigIntegerToNetworkFormat(initiatorExponential);\n\t\tbyte[] _responderExponential = stripBigIntegerToNetworkFormat(responderExponential);\n\t\tbyte[] result = new byte[nonceInitiator.length + nonceResponder.length + _initiatorExponential.length + _responderExponential.length + id.length];\n\t\tint offset = 0;\n\t\t\n\t\tSystem.arraycopy(nonceInitiator, 0,result,offset,nonceInitiator.length);\n\t\toffset += nonceInitiator.length;\n\t\tSystem.arraycopy(nonceResponder,0 ,result,offset,nonceResponder.length);\n\t\toffset += nonceResponder.length;\n\t\tSystem.arraycopy(_initiatorExponential, 0, result,offset, _initiatorExponential.length);\n\t\toffset += _initiatorExponential.length;\n\t\tSystem.arraycopy(_responderExponential, 0, result, offset, _responderExponential.length);\n\t\toffset += _responderExponential.length;\n\t\tSystem.arraycopy(id, 0, result , offset,id.length);\n\n\t\treturn result;\n\t}","commit_id":"4d0fd59cc739322db6c860e858a60029097dc9e7","url":"https://github.com/freenet/fred"},{"original_method":"private void sendMessage3Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 // Signature (R,S)\n\t\t                           ];\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n                \n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tDSASignature localSignature = crypto.sign(assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tif(logMINOR) Logger.minor(this, \"we are re-sending authenticator = \" + HexUtil.bytesToHex(authenticator));\n\t\tc.initialize(Ke);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\t\n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2];\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cleartext, HASH_LENGTH);\n\t\t\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t}","id":67316,"modified_method":"private void sendMessage3Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 // Signature (R,S)\n\t\t                           ];\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity);\n\t\tpn.setBufferJFK(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tif(logMINOR) Logger.minor(this, \"we are re-sending authenticator = \" + HexUtil.bytesToHex(authenticator));\n\t\tc.initialize(Ke);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\t\n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2];\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cleartext, HASH_LENGTH);\n\t\t\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t}","commit_id":"4d0fd59cc739322db6c860e858a60029097dc9e7","url":"https://github.com/freenet/fred"},{"original_method":"private void processMessage3(byte[] payload, PeerNode pn,Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it\");\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH; // it's at least a signature\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\tif(logMINOR) Logger.minor(this, \"We got the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tLogger.error(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery)\");\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often)\");\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message4), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// some sanity checks\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\tif(_ourExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!! (our exponential?!?)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Save the those values to verify message4\n\t\tpn.setBufferJFK(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity));\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length - inputOffset);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, payload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Remote sent us the following sig :\"+remoteSignature.toLongString());\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, pn.getBufferJFK()), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!!\");\n\t\t\treturn;\n\t\t}\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tauthenticatorCache.put(authenticator,payload);\n\t\t}\n\t\t// Send reply\n\t\tsendMessage4Packet(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c , pn, replyTo);\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":67317,"modified_method":"private void processMessage3(byte[] payload, PeerNode pn,Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it\");\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH; // it's at least a signature\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\tif(logMINOR) Logger.minor(this, \"We got the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tLogger.error(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery)\");\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often)\");\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message4), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// some sanity checks\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\tif(_ourExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!! (our exponential?!?)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length - inputOffset);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, payload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Remote sent us the following sig :\"+remoteSignature.toLongString());\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!!\");\n\t\t\treturn;\n\t\t}\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tauthenticatorCache.put(authenticator,payload);\n\t\t}\n\t\t// Send reply\n\t\tsendMessage4Packet(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c , pn, replyTo);\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"4d0fd59cc739322db6c860e858a60029097dc9e7","url":"https://github.com/freenet/fred"},{"original_method":"private byte[] assembleDHParams(BigInteger exponential, DSAGroup group) {\n\t\tbyte[] _myExponential = stripBigIntegerToNetworkFormat(exponential);\n\t\tbyte[] _myGroup = group.getP().toByteArray();\n\t\tbyte[] toSign = new byte[_myExponential.length + _myGroup.length];\n\n\t\tSystem.arraycopy(_myExponential, 0, toSign, 0, _myExponential.length);\n\t\tSystem.arraycopy(_myGroup, 0, toSign, _myExponential.length, _myGroup.length);\n\n\t\treturn SHA256.digest(toSign);\n\t}","id":67318,"modified_method":"private byte[] assembleDHParams(BigInteger exponential, DSAGroup group) {\n\t\tbyte[] _myExponential = stripBigIntegerToNetworkFormat(exponential);\n\t\tbyte[] _myGroup = group.getP().toByteArray();\n\t\tbyte[] toSign = new byte[_myExponential.length + _myGroup.length];\n\n\t\tSystem.arraycopy(_myExponential, 0, toSign, 0, _myExponential.length);\n\t\tSystem.arraycopy(_myGroup, 0, toSign, _myExponential.length, _myGroup.length);\n\n\t\treturn toSign;\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void sendMessage3Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + myRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(myRef, 0, data, 8, myRef.length);\n\t\tbyte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 + // Signature (R,S)\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity);\n\t\tpn.setJFKBuffer(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tpn.jfkKs = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(pn.jfkKe);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\t\n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(pn.jfkKa, cleartext, HASH_LENGTH);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tauthenticatorCache.put(authenticator,message3);\n\t\t}\t\t\n\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t}","id":67319,"modified_method":"private void sendMessage3Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + myRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(myRef, 0, data, 8, myRef.length);\n\t\tbyte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 + // Signature (R,S)\n\t\t                           data.length]; // The bootid+noderef\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity);\n\t\tpn.setJFKBuffer(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tpn.jfkKs = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tpn.jfkKe = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tpn.jfkKa = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(pn.jfkKe);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\t\n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cleartext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(pn.jfkKa, cleartext, HASH_LENGTH);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, cleartext.length-cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(authenticatorCache.size() > AUTHENTICATOR_CACHE_SIZE)\n\t\t\t\tresetTransientKey();\n\t\t\telse\n\t\t\t\tauthenticatorCache.put(authenticator,message3);\n\t\t}\t\t\n\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void processMessage3(byte[] payload, PeerNode pn,Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it\");\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t\t\t\t\t\t\t8;\t\t\t  // a bootid\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\tif(logMINOR) Logger.minor(this, \"We got the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tLogger.error(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery)\");\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often)\");\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message4), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// some sanity checks\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\tif(_ourExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!! (our exponential?!?)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tbyte[] Ks = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s)); \n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Send reply\n\t\tsendMessage4Packet(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c, Ke, Ka, authenticator, pn, replyTo);\n\t\t\n\t\t//FIXME: rekey .... ?\n\t\tc.initialize(Ks);\n\t\tif(!pn.completedHandshake(bootID, data, 8, data.length-8, c, Ks, replyTo, false)) {\n\t\t\tLogger.error(this, \"Handshake failure!\");\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":67320,"modified_method":"private void processMessage3(byte[] payload, PeerNode pn,Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it - \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // it's at least a signature\n\t\t\t\t\t\t\t\t\t8;\t\t\t  // a bootid\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tLogger.error(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery)\");\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) - \"+pn);\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message4), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// some sanity checks\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\tif(_ourExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!! (our exponential?!?)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tbyte[] Ks = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"0\");\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + payload.length - inputOffset];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length-decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s)); \n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity))), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(3) - \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Send reply\n\t\tsendMessage4Packet(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c, Ke, Ka, authenticator, pn, replyTo);\n\t\t\n\t\t//FIXME: rekey .... ?\n\t\tc.initialize(Ks);\n\t\tif(!pn.completedHandshake(bootID, data, 8, data.length-8, c, Ks, replyTo, true)) {\n\t\t\tLogger.error(this, \"Handshake failure! with \"+pn);\n\t\t}\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void sendMessage1(PeerNode pn, Peer replyTo) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+pn);\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tint offset = 0;\n\t\tbyte[] myExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] myNonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(myNonce);\n\n\t\tbyte[] message1 = new byte[NONCE_SIZE+DiffieHellman.modulusLengthInBytes()];\n\n\t\tSystem.arraycopy(myNonce, 0, message1, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tif(logMINOR) Logger.minor(this, \"My Exponential (message1), length =\"+DiffieHellman.modulusLengthInBytes()+\" value =\"+ dhContext.myExponential.toHexString());\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, DiffieHellman.modulusLengthInBytes());\n\n\t\tsendAuthPacket(1,2,0,message1,pn,replyTo);\n\t}","id":67321,"modified_method":"private void sendMessage1(PeerNode pn, Peer replyTo) {\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(1) message to \"+pn);\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tint offset = 0;\n\t\tbyte[] myExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] myNonce = new byte[NONCE_SIZE];\n\t\tnode.random.nextBytes(myNonce);\n\n\t\tbyte[] message1 = new byte[NONCE_SIZE+DiffieHellman.modulusLengthInBytes()];\n\n\t\tSystem.arraycopy(myNonce, 0, message1, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\tSystem.arraycopy(myExponential, 0, message1, offset, DiffieHellman.modulusLengthInBytes());\n\n\t\tsendAuthPacket(1,2,0,message1,pn,replyTo);\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void processMessage2(byte[] payload,PeerNode pn,Peer replyTo)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it\");\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes() + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tint inputOffset=3;\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, hisExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tif(logMINOR) Logger.minor(this, \"his exponential from message2 length=\"+DiffieHellman.modulusLengthInBytes() +\" value=\" + _hisExponential.toHexString());\n\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often)\");\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message3), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// sanity check\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Verify the DSA signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tif(logMINOR) Logger.minor(this, \"Remote sent us the following sig :\"+remoteSignature.toLongString());\n\t\t// At that point we don't know if it's \"him\"; let's check it out\n\t\tbyte[] locallyExpectedExponentials = assembleDHParams(_hisExponential, pn.peerCryptoGroup);\n\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, locallyExpectedExponentials), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsendMessage3Packet(1, 2, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":67322,"modified_method":"private void processMessage2(byte[] payload,PeerNode pn,Peer replyTo)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(2) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tint expectedLength = NONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes() + HASH_LENGTH*2;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(2), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\n\t\tint inputOffset=3;\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\n\t\tbyte[] hisExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, hisExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tinputOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message2\n\t\t// Now simply transmit the corresponding message3\n\t\tObject message3 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage3 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message3 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often) -\"+pn);\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message3), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// sanity check\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Verify the DSA signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\t// At that point we don't know if it's \"him\"; let's check it out\n\t\tbyte[] locallyExpectedExponentials = assembleDHParams(_hisExponential, pn.peerCryptoGroup);\n\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyExpectedExponentials)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed in JFK(2)!! \"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tsendMessage3Packet(1, 2, 3, nonceInitiator, nonceResponder, hisExponential, authenticator, pn, replyTo);\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void sendMessage4Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn);\n\t\tNativeBigInteger _responderExponential = new NativeBigInteger(1,responderExponential);\n\t\tNativeBigInteger _initiatorExponential = new NativeBigInteger(1,initiatorExponential);\n\t\t\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _initiatorExponential, _responderExponential, pn.identity)));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + myRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(myRef, 0, data, 8, myRef.length);\n\t\t\n\t\tPCFBMode pk=PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpk.reset(iv);\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"R\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\n\t\tbyte[] cyphertext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(prefix, 0, cyphertext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cyphertext, HASH_LENGTH);\n\t\t\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)]; \n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tauthenticatorCache.put(authenticator, message4);\n\t\t}\n\t\tsendAuthPacket(1, 2, 3, message4, pn, replyTo);\n\t}","id":67323,"modified_method":"private void sendMessage4Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] initiatorExponential,byte[] responderExponential, BlockCipher c, byte[] Ke, byte[] Ka, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn);\n\t\tNativeBigInteger _responderExponential = new NativeBigInteger(1,responderExponential);\n\t\tNativeBigInteger _initiatorExponential = new NativeBigInteger(1,initiatorExponential);\n\t\t\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _initiatorExponential, _responderExponential, pn.identity)));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\t\n\t\tbyte[] myRef = crypto.myCompressedSetupRef();\n\t\tbyte[] data = new byte[8 + myRef.length];\n\t\tSystem.arraycopy(Fields.longToBytes(node.bootID), 0, data, 0, 8);\n\t\tSystem.arraycopy(myRef, 0, data, 8, myRef.length);\n\t\t\n\t\tPCFBMode pk=PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpk.reset(iv);\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"R\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\n\t\tbyte[] cyphertext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2 + data.length];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(prefix, 0, cyphertext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cyphertext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cyphertext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(data, 0, cyphertext, cleartextOffset, data.length);\n\t\tcleartextOffset += data.length;\n\t\t// Now encrypt the cleartext[Signature]\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpk.blockEncipher(cyphertext, cleartextToEncypherOffset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// We compute the HMAC of (prefix + iv + signature)\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cyphertext, HASH_LENGTH);\n\t\t\n\t\t// Message4 = hmac + IV + encryptedSignature\n\t\tbyte[] message4 = new byte[HASH_LENGTH + ivLength + (cyphertext.length - cleartextToEncypherOffset)]; \n\t\tint offset = 0;\n\t\tSystem.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cyphertext, cleartextToEncypherOffset, message4, offset, cyphertext.length - cleartextToEncypherOffset);\n\t\t\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tif(authenticatorCache.size() > AUTHENTICATOR_CACHE_SIZE)\n\t\t\t\tresetTransientKey();\n\t\t\telse\n\t\t\t\tauthenticatorCache.put(authenticator, message4);\n\t\t}\n\t\tsendAuthPacket(1, 2, 3, message4, pn, replyTo);\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private DSASignature signDHParams(BigInteger exponential, DSAGroup group) {\n\t\treturn crypto.sign(assembleDHParams(exponential, group));\n\t}","id":67324,"modified_method":"private DSASignature signDHParams(BigInteger exponential, DSAGroup group) {\n\t\treturn crypto.sign(SHA256.digest(assembleDHParams(exponential, group)));\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void processMessage4(byte[] payload, PeerNode pn, Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it\");\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // the signature\n\t\t\t\t\t\t\t\t\t8\t\t\t  // the bootid; there should be the noderef too\n\t\t\t\t\t\t\t\t\t;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug\");\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\t//FIXME: do we need to \"c.initialize(Ke);\" ? I don't think so but I'm not sure - nextgens\n\t\tc.initialize(pn.jfkKe);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"R\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes() * 2 + crypto.myIdentity.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes()*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tSystem.arraycopy(crypto.myIdentity, 0, locallyGeneratedText, bufferOffset, crypto.myIdentity.length);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyGeneratedText)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!!\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t//FIXME: when do we reset the buffer/rekey/DH/transientkey ?\n\t\t// We change the key\n\t\tc.initialize(pn.jfkKs);\n\t\tif(!pn.completedHandshake(bootID, data, 8, data.length - 8, c, pn.jfkKs, replyTo, false)) {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\t\t// cleanup\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.jfkKs = null;\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":67325,"modified_method":"private void processMessage4(byte[] payload, PeerNode pn, Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(4) message, processing it - \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // the signature\n\t\t\t\t\t\t\t\t\t8\t\t\t  // the bootid; there should be the noderef too\n\t\t\t\t\t\t\t\t\t;\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(4), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\tbyte[] jfkBuffer = pn.getJFKBuffer();\n\t\t// FIXME: is that needed ?\n\t\tif(jfkBuffer == null) {\n\t\t\tLogger.normal(this, \"We have already handled this message... might be a replay or a bug - \"+pn);\n\t\t\treturn;\n\t\t}\n\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\t//FIXME: do we need to \"c.initialize(Ke);\" ? I don't think so but I'm not sure - nextgens\n\t\tc.initialize(pn.jfkKe);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"R\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + (payload.length-inputOffset)];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, payload.length-inputOffset);\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(pn.jfkKa, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, decypheredPayload.length - decypheredPayloadOffset);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t * bootID, znoderef\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] data = new byte[decypheredPayload.length - decypheredPayloadOffset];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, data, 0, decypheredPayload.length - decypheredPayloadOffset);\n\t\tlong bootID = Fields.bytesToLong(data);\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tbyte[] locallyGeneratedText = new byte[NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes() * 2 + crypto.myIdentity.length];\n\t\tint bufferOffset = NONCE_SIZE * 2 + DiffieHellman.modulusLengthInBytes()*2;\n\t\tSystem.arraycopy(jfkBuffer, 0, locallyGeneratedText, 0, bufferOffset);\n\t\tSystem.arraycopy(crypto.myIdentity, 0, locallyGeneratedText, bufferOffset, crypto.myIdentity.length);\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, SHA256.digest(locallyGeneratedText)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!! JFK(4) -\"+pn);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// We change the key\n\t\tc.initialize(pn.jfkKs);\n\t\tif(!pn.completedHandshake(bootID, data, 8, data.length - 8, c, pn.jfkKs, replyTo, false)) {\n\t\t\tLogger.error(this, \"Handshake failed!\");\n\t\t}\n\t\t// cleanup\n\t\tpn.setJFKBuffer(null);\n\t\tpn.jfkKa = null;\n\t\tpn.jfkKe = null;\n\t\tpn.jfkKs = null;\n\t\t\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void processMessage1(byte[] payload,PeerNode pn,Peer replyTo)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it\");\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < NONCE_SIZE + DiffieHellman.modulusLengthInBytes() + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(NONCE_SIZE + DiffieHellman.modulusLengthInBytes()));\n\t\t\treturn;\n\t\t}\n\t\tint offset=3;\n\t\t// get Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\n\t\t// get g^i\n\t\tbyte[] hisExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, offset, hisExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tif(logMINOR) Logger.minor(this, \"his exponential from message1 length=\"+DiffieHellman.modulusLengthInBytes() +\" value=\" + _hisExponential.toHexString());\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) > 0) {\n\t\t\tsendMessage2(nonceInitiator, pn, replyTo);\n\t\t}else\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":67326,"modified_method":"private void processMessage1(byte[] payload,PeerNode pn,Peer replyTo)\n\t{\n\t\tlong t1=System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(1) message, processing it - \"+pn);\n\t\t// FIXME: follow the spec and send IDr' ?\n\t\tif(payload.length < NONCE_SIZE + DiffieHellman.modulusLengthInBytes() + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(1), should be \"+(NONCE_SIZE + DiffieHellman.modulusLengthInBytes()));\n\t\t\treturn;\n\t\t}\n\t\tint offset=3;\n\t\t// get Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, offset, nonceInitiator, 0, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\n\t\t// get g^i\n\t\tbyte[] hisExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, offset, hisExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tif(logMINOR) Logger.minor(this, \"his exponential from message1 length=\"+DiffieHellman.modulusLengthInBytes() +\" value=\" + _hisExponential.toHexString());\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) > 0) {\n\t\t\tsendMessage2(nonceInitiator, pn, replyTo);\n\t\t}else\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\n\t\tlong t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message1 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"0d0bcd34a51e5a40d6f87a1109b16123980b4428","url":"https://github.com/freenet/fred"},{"original_method":"private void sendMessage3Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 // Signature (R,S)\n\t\t                           ];\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity);\n\t\tpn.setBufferJFK(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tif(logMINOR) Logger.minor(this, \"we are re-sending authenticator = \" + HexUtil.bytesToHex(authenticator));\n\t\tc.initialize(Ke);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\t\n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2];\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cleartext, HASH_LENGTH);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t}","id":67327,"modified_method":"private void sendMessage3Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] hisExponential, byte[] authenticator, PeerNode pn, Peer replyTo)\n\t{\n\t\tif(logMINOR) Logger.minor(this, \"Sending a JFK(3) message to \"+pn);\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tbyte[] ourExponential = stripBigIntegerToNetworkFormat(dhContext.myExponential);\n\t\tbyte[] message3 = new byte[NONCE_SIZE*2 + // nI, nR\n\t\t                           DiffieHellman.modulusLengthInBytes()*2 + // g^i, g^r\n\t\t                           HASH_LENGTH + // authenticator\n\t\t                           HASH_LENGTH + // HMAC(cyphertext)\n\t\t                           (c.getBlockSize() >> 3) + // IV\n\t\t                           Node.SIGNATURE_PARAMETER_LENGTH * 2 // Signature (R,S)\n\t\t                           ];\n\t\tint offset = 0;\n\t\t// Ni\n\t\tSystem.arraycopy(nonceInitiator, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// Nr\n\t\tSystem.arraycopy(nonceResponder, 0, message3, offset, NONCE_SIZE);\n\t\toffset += NONCE_SIZE;\n\t\t// g^i\n\t\tSystem.arraycopy(ourExponential, 0,message3, offset, ourExponential.length);\n\t\toffset += ourExponential.length;\n\t\t// g^r\n\t\tSystem.arraycopy(hisExponential, 0,message3, offset, hisExponential.length);\n\t\toffset += hisExponential.length;\n\n\t\t// Authenticator\n\t\tSystem.arraycopy(authenticator, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\t/*\n\t\t * Digital Signature of the message with the private key belonging to the initiator/responder\n\t\t * It is assumed to be non-message recovering\n\t\t */\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\t// save parameters so that we can verify message4\n\t\tbyte[] toSign = assembleDHParams(nonceInitiator, nonceResponder, _ourExponential, _hisExponential, pn.identity);\n\t\tpn.setBufferJFK(toSign);\n\t\tDSASignature localSignature = crypto.sign(SHA256.digest(toSign));\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) {\n\t\t\tLogger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\t\tLogger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\t\tLogger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\t\tLogger.minor(this, \"We are re-sending authenticator = \" + HexUtil.bytesToHex(authenticator));\n\t\t\tLogger.minor(this, \"We send the following signature : \"+localSignature.toLongString());\n\t\t\tLogger.minor(this, \"We have been signing \"+ HexUtil.bytesToHex(toSign));\n\t\t}\n\t\tc.initialize(Ke);\n\t\tPCFBMode pcfb = PCFBMode.create(c);\n\t\tint ivLength = pcfb.lengthIV();\n\t\tbyte[] iv = new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n\t\tpcfb.reset(iv);\n\t\tint cleartextOffset = 0;\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\t\n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2];\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\tint cleartextToEncypherOffset = prefix.length + ivLength;\n\t\tpcfb.blockEncipher(cleartext, cleartextToEncypherOffset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\t// We compute the HMAC of (prefix + cyphertext) Includes the IV!\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cleartext, HASH_LENGTH);\n\t\t\n\t\t// copy stuffs back to the message\n\t\tSystem.arraycopy(hmac, 0, message3, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message3, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message3, offset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\tsendAuthPacket(1, 2, 2, message3, pn, replyTo);\n\t}","commit_id":"db7f8fe780710d90dffc8e1439c0dfa836fd333d","url":"https://github.com/freenet/fred"},{"original_method":"private void processMessage3(byte[] payload, PeerNode pn,Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it\");\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH; // it's at least a signature\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\tif(logMINOR) Logger.minor(this, \"We got the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tLogger.error(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery)\");\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often)\");\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message4), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// some sanity checks\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\tif(_ourExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!! (our exponential?!?)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH*2];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, ivLength + Node.SIGNATURE_PARAMETER_LENGTH*2);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, Node.SIGNATURE_PARAMETER_LENGTH*2);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Remote sent us the following sig :\"+remoteSignature.toLongString());\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity)), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!!\");\n\t\t\treturn;\n\t\t}\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tauthenticatorCache.put(authenticator,payload);\n\t\t}\n\t\t// Send reply\n\t\tsendMessage4Packet(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c , pn, replyTo);\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","id":67328,"modified_method":"private void processMessage3(byte[] payload, PeerNode pn,Peer replyTo)\t\t\t\n\t{\n\t\tfinal long t1 = System.currentTimeMillis();\n\t\tif(logMINOR) Logger.minor(this, \"Got a JFK(3) message, processing it\");\n\t\tBlockCipher c = null;\n\t\ttry { c = new Rijndael(256, 256); } catch (UnsupportedCipherException e) {}\n\t\tint inputOffset=3;\n\t\t\n\t\tfinal int expectedLength =\tNONCE_SIZE*2 + DiffieHellman.modulusLengthInBytes()*2 +\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // authenticator\n\t\t\t\t\t\t\t\t\tHASH_LENGTH + // HMAC of the cyphertext\n\t\t\t\t\t\t\t\t\t(c.getBlockSize() >> 3) + // IV\n\t\t\t\t\t\t\t\t\tHASH_LENGTH; // it's at least a signature\n\t\tif(payload.length < expectedLength + 3) {\n\t\t\tLogger.error(this, \"Packet too short from \"+pn+\": \"+payload.length+\" after decryption in JFK(3), should be \"+(expectedLength + 3));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Ni\n\t\tbyte[] nonceInitiator = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceInitiator, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// Nr\n\t\tbyte[] nonceResponder = new byte[NONCE_SIZE];\n\t\tSystem.arraycopy(payload, inputOffset, nonceResponder, 0, NONCE_SIZE);\n\t\tinputOffset += NONCE_SIZE;\n\t\t// g^i\n\t\tbyte[] initiatorExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, initiatorExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t// g^r\n\t\tbyte[] responderExponential = new byte[DiffieHellman.modulusLengthInBytes()];\n\t\tSystem.arraycopy(payload, inputOffset, responderExponential, 0, DiffieHellman.modulusLengthInBytes());\n\t\tinputOffset += DiffieHellman.modulusLengthInBytes();\n\t\t\n\t\tbyte[] authenticator = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, authenticator, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\tif(logMINOR) Logger.minor(this, \"We got the following HMAC : \" + HexUtil.bytesToHex(authenticator));\n\t\t// FIXME: check the cache before or after the hmac verification ?\n\t\t// is it cheaper to wait for the lock on authenticatorCache or to verify the hmac ?\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tif(!mac.verify(getTransientKey(), assembleJFKAuthenticator(responderExponential, nonceResponder, nonceInitiator, replyTo.getAddress().getAddress()) , authenticator)) {\n\t\t\tLogger.error(this, \"The HMAC doesn't match; let's discard the packet (either we rekeyed or we are victim of forgery)\");\n\t\t\treturn;\n\t\t}\n\t\t// Check try to find the authenticator in the cache.\n\t\t// If authenticator is already present, indicates duplicate/replayed message3\n\t\t// Now simply transmit the corresponding message4\n\t\tObject message4 = null;\n\t\tsynchronized (authenticatorCache) {\n\t\t\tmessage4 = authenticatorCache.get(authenticator);\n\t\t}\n\t\tif(message4 != null) {\n\t\t\tLogger.normal(this, \"We replayed a message from the cache (shouldn't happen often)\");\n\t\t\ttry{\n\t\t\t\tsendAuthPacket(1, 2, 3, getBytes(message4), pn, replyTo);\n\t\t\t}catch(IOException e){\n\t\t\t\tLogger.error(this,\"Error getting bytes... wtf ? \"+e.getMessage(), e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// some sanity checks\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1, initiatorExponential);\n\t\tif(_hisExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!!\");\n\t\t\treturn;\n\t\t}\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1, responderExponential);\n\t\tif(_ourExponential.compareTo(NativeBigInteger.ONE) < 1) {\n\t\t\tLogger.error(this, \"We can't accept the exponential \"+pn+\" sent us; it's smaller than 1!! (our exponential?!?)\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tbyte[] hmac = new byte[HASH_LENGTH];\n\t\tSystem.arraycopy(payload, inputOffset, hmac, 0, HASH_LENGTH);\n\t\tinputOffset += HASH_LENGTH;\n\t\t\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tc.initialize(Ke);\n\t\tfinal PCFBMode pk = PCFBMode.create(c);\n\t\tint ivLength = pk.lengthIV();\n\t\tint decypheredPayloadOffset = 0;\n\t\t// We compute the HMAC of (\"I\"+cyphertext) : the cyphertext includes the IV!\n\t\tbyte[] prefix = null;\n\t\ttry { prefix = \"I\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n\t\tbyte[] decypheredPayload = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH*2];\n\t\tSystem.arraycopy(prefix, 0, decypheredPayload, decypheredPayloadOffset, prefix.length);\n\t\tdecypheredPayloadOffset += prefix.length;\n\t\tSystem.arraycopy(payload, inputOffset, decypheredPayload, decypheredPayloadOffset, ivLength + Node.SIGNATURE_PARAMETER_LENGTH*2);\n\t\tif(!mac.verify(Ka, decypheredPayload, hmac)) {\n\t\t\tLogger.error(this, \"The digest-HMAC doesn't match; let's discard the packet\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Get the IV\n\t\tpk.reset(decypheredPayload, decypheredPayloadOffset);\n\t\tdecypheredPayloadOffset += ivLength;\n\t\t// Decrypt the payload\n\t\tpk.blockDecipher(decypheredPayload, decypheredPayloadOffset, Node.SIGNATURE_PARAMETER_LENGTH*2);\n\t\t/*\n\t\t * DecipheredData Format:\n\t\t * Signature-r,s\n\t\t */\n\t\tbyte[] r = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, r, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tbyte[] s = new byte[Node.SIGNATURE_PARAMETER_LENGTH];\n\t\tSystem.arraycopy(decypheredPayload, decypheredPayloadOffset, s, 0, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tdecypheredPayloadOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\t\n\t\t// verify the signature\n\t\tDSASignature remoteSignature = new DSASignature(new NativeBigInteger(1,r), new NativeBigInteger(1,s));\n\t\tbyte[] locallyGeneratedText = SHA256.digest(assembleDHParams(nonceInitiator, nonceResponder, _hisExponential, _ourExponential, crypto.myIdentity));\n\t\tif(logMINOR) {\n\t\t\tLogger.minor(this, \"Remote sent us the following sig :\"+remoteSignature.toLongString());\n\t\t\tLogger.minor(this, \"We are have the following locally :\"+HexUtil.bytesToHex(locallyGeneratedText));\n\t\t}\n\t\tif(!DSA.verify(pn.peerPubKey, remoteSignature, new NativeBigInteger(1, locallyGeneratedText), false)) {\n\t\t\tLogger.error(this, \"The signature verification has failed!!\");\n\t\t\treturn;\n\t\t}\n\t\t// cache the message\n\t\tsynchronized (authenticatorCache) {\n\t\t\tauthenticatorCache.put(authenticator,payload);\n\t\t}\n\t\t// Send reply\n\t\tsendMessage4Packet(1, 2, 3, nonceInitiator, nonceResponder,initiatorExponential, responderExponential, c , pn, replyTo);\n\t\tfinal long t2=System.currentTimeMillis();\n\t\tif((t2-t1)>500)\n\t\t\tLogger.error(this,\"Message3 timeout error:Sending packet for\"+pn.getPeer());\n\t}","commit_id":"db7f8fe780710d90dffc8e1439c0dfa836fd333d","url":"https://github.com/freenet/fred"},{"original_method":"private void sendMessage4Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] ourExponential,byte[] hisExponential, BlockCipher c ,PeerNode pn,Peer replyTo)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn);\n\t\tlong now = System.currentTimeMillis();\n\t\tlong delta = now - pn.lastSentPacketTime();\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tDSASignature localSignature = signDHParams(nonceInitiator,nonceResponder,_ourExponential,_hisExponential, crypto.myIdentity);\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tc.initialize(Ke);\n\t\tPCFBMode pk=PCFBMode.create(c);\n                int ivLength = pk.lengthIV();\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n                pk.reset(iv);\n                byte[] prefix = null;\n\t\ttry { prefix = \"R\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n                \n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n                // We compute the HMAC of (prefix + iv + signature)\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cleartext, HASH_LENGTH);\n                // Now encrypt the cleartext[Signature]\n                int cleartextToEncypherOffset = prefix.length + ivLength;\n                pk.blockEncipher(cleartext, cleartextToEncypherOffset, Node.SIGNATURE_PARAMETER_LENGTH*2 );\n\t\t\n                // Message4 = hmac + IV + encryptedSignature\n                byte[] message4 = new byte[HASH_LENGTH + (c.getBlockSize() >> 3) + Node.SIGNATURE_PARAMETER_LENGTH * 2]; \n                int offset = 0;\n                System.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message4, offset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\tsendAuthPacket(1,2,3,message4,pn,replyTo);\n\t}","id":67329,"modified_method":"private void sendMessage4Packet(int version,int negType,int phase,byte[] nonceInitiator,byte[] nonceResponder,byte[] ourExponential,byte[] hisExponential, BlockCipher c ,PeerNode pn,Peer replyTo)\n\t{\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Sending a JFK(4) message to \"+pn);\n\t\tDiffieHellmanLightContext dhContext = getLightDiffieHellmanContext(pn);\n\t\tNativeBigInteger _ourExponential = new NativeBigInteger(1,ourExponential);\n\t\tNativeBigInteger _hisExponential = new NativeBigInteger(1,hisExponential);\n\t\tDSASignature localSignature = signDHParams(nonceInitiator,nonceResponder,_ourExponential,_hisExponential, crypto.myIdentity);\n\t\tbyte[] r = localSignature.getRBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tbyte[] s = localSignature.getSBytes(Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tBigInteger computedExponential = dhContext.getHMACKey(_hisExponential, Global.DHgroupA);\n\t\tif(logMINOR) Logger.minor(this, \"We have computed the following exponential : \" + HexUtil.biToHex(computedExponential));\n\t\tbyte[] Ke = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"1\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ke=\" + HexUtil.bytesToHex(Ke));\n\t\tbyte[] Ka = computeJFKSharedKey(computedExponential, nonceInitiator, nonceResponder, \"2\");\n\t\tif(logMINOR) Logger.minor(this, \"We are using Ka=\" + HexUtil.bytesToHex(Ka));\n\t\tc.initialize(Ke);\n\t\tPCFBMode pk=PCFBMode.create(c);\n                int ivLength = pk.lengthIV();\n\t\tbyte[] iv=new byte[ivLength];\n\t\tnode.random.nextBytes(iv);\n                pk.reset(iv);\n                byte[] prefix = null;\n\t\ttry { prefix = \"R\".getBytes(\"UTF-8\"); } catch (UnsupportedEncodingException e) {}\n                \n\t\tbyte[] cleartext = new byte[prefix.length + ivLength + Node.SIGNATURE_PARAMETER_LENGTH * 2];\n\t\tint cleartextOffset = 0;\n\t\tSystem.arraycopy(prefix, 0, cleartext, cleartextOffset, prefix.length);\n\t\tcleartextOffset += prefix.length;\n\t\tSystem.arraycopy(iv, 0, cleartext, cleartextOffset, ivLength);\n\t\tcleartextOffset += ivLength;\n\t\tSystem.arraycopy(r, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n\t\tSystem.arraycopy(s, 0, cleartext, cleartextOffset, Node.SIGNATURE_PARAMETER_LENGTH);\n\t\tcleartextOffset += Node.SIGNATURE_PARAMETER_LENGTH;\n                // We compute the HMAC of (prefix + iv + signature)\n\t\tHMAC mac = new HMAC(SHA256.getInstance());\n\t\tbyte[] hmac = mac.mac(Ka, cleartext, HASH_LENGTH);\n                // Now encrypt the cleartext[Signature]\n                int cleartextToEncypherOffset = prefix.length + ivLength;\n                pk.blockEncipher(cleartext, cleartextToEncypherOffset, Node.SIGNATURE_PARAMETER_LENGTH*2 );\n\t\t\n                // Message4 = hmac + IV + encryptedSignature\n                byte[] message4 = new byte[HASH_LENGTH + (c.getBlockSize() >> 3) + Node.SIGNATURE_PARAMETER_LENGTH * 2]; \n                int offset = 0;\n                System.arraycopy(hmac, 0, message4, offset, HASH_LENGTH);\n\t\toffset += HASH_LENGTH;\n\t\tSystem.arraycopy(iv, 0, message4, offset, ivLength);\n\t\toffset += ivLength;\n\t\tSystem.arraycopy(cleartext, cleartextToEncypherOffset, message4, offset, Node.SIGNATURE_PARAMETER_LENGTH * 2);\n\t\t\n\t\tsendAuthPacket(1,2,3,message4,pn,replyTo);\n\t}","commit_id":"db7f8fe780710d90dffc8e1439c0dfa836fd333d","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Called when we get an offer for a key. If this is an SSK, we will only accept it if we have previously asked for it.\n\t * If it is a CHK, we will accept it if we want it.\n\t * @param key The key we are being offered.\n\t * @param peer The node offering it.\n\t * @param authenticator \n\t */\n\tvoid onOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(!node.enableULPRDataPropagation) return;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Offered key \"+key+\" by peer \"+peer);\n\t\tif(node.hasKey(key)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = (FailureTableEntry) entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || ((key instanceof NodeCHK) && heAsked))) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) entriesByKey.removeKey(key);\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) entriesByKey.removeKey(key);\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(this) {\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = (BlockOfferList) blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Now, does anyone want it?\n\t\t\n\t\tnode.clientCore.maybeQueueOfferedKey(key, entry.othersWant(peer));\n\t}","id":67330,"modified_method":"/**\n\t * Called when we get an offer for a key. If this is an SSK, we will only accept it if we have previously asked for it.\n\t * If it is a CHK, we will accept it if we want it.\n\t * @param key The key we are being offered.\n\t * @param peer The node offering it.\n\t * @param authenticator \n\t */\n\tvoid onOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(!node.enableULPRDataPropagation) return;\n\t\tif(logMINOR)\n\t\t\tLogger.minor(this, \"Offered key \"+key+\" by peer \"+peer);\n\t\tif(node.hasKey(key)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = (FailureTableEntry) entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || ((key instanceof NodeCHK) && heAsked))) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) entriesByKey.removeKey(key);\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(this) {\n\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = (BlockOfferList) blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Now, does anyone want it?\n\t\t\n\t\tnode.clientCore.maybeQueueOfferedKey(key, entry.othersWant(peer));\n\t}","commit_id":"8830c41a700788a6ac7338131c107a42c9bd6f81","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * This method runs on the SerialExecutor. Therefore, any blocking network I/O needs to be scheduled\n\t * on a separate thread. However, blocking disk I/O *should happen on this thread*. We deliberately\n\t * serialise it, as high latencies can otherwise result.\n\t */\n\tprotected void innerOnOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(key.getRoutingKey() == null) throw new NullPointerException();\n\t\t//NB: node.hasKey() executes a datastore fetch\n\t\t// If we have the key in the datastore (store or cache), we don't want it.\n\t\t// If we have the key in the client cache, we might want it for other nodes,\n\t\t// although hopefully the client layer was tripped when we got it.\n\t\tif(node.hasKey(key, false, true)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Re-check after potentially long disk I/O.\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || heAsked)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) entriesByKey.removeKey(key);\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(this) {\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Accept the offer.\n\t\t// Either a peer wants it, in which case we want it for them,\n\t\t// or we want it, or we have requested it in the past, in which case\n\t\t// we will probably want it in the future.\n\t\t// FIXME: Not safe to queue offered keys as realtime????\n\t\t// For the same reason that priorities are not safe?\n\t\t// But do it at low priorities?\n\t\t// Offers mostly happen for SSKs anyway ... reconsider?\n\t\tnode.clientCore.queueOfferedKey(key, false);\n\t}","id":67331,"modified_method":"/**\n\t * This method runs on the SerialExecutor. Therefore, any blocking network I/O needs to be scheduled\n\t * on a separate thread. However, blocking disk I/O *should happen on this thread*. We deliberately\n\t * serialise it, as high latencies can otherwise result.\n\t */\n\tprotected void innerOnOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(key.getRoutingKey() == null) throw new NullPointerException();\n\t\t//NB: node.hasKey() executes a datastore fetch\n\t\t// If we have the key in the datastore (store or cache), we don't want it.\n\t\t// If we have the key in the client cache, we might want it for other nodes,\n\t\t// although hopefully the client layer was tripped when we got it.\n\t\tif(node.hasKey(key, false, true)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Re-check after potentially long disk I/O.\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || heAsked)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) {\n\t\t\tsynchronized(this) {\n\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(this) {\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Accept the offer.\n\t\t// Either a peer wants it, in which case we want it for them,\n\t\t// or we want it, or we have requested it in the past, in which case\n\t\t// we will probably want it in the future.\n\t\t// FIXME: Not safe to queue offered keys as realtime????\n\t\t// For the same reason that priorities are not safe?\n\t\t// But do it at low priorities?\n\t\t// Offers mostly happen for SSKs anyway ... reconsider?\n\t\tnode.clientCore.queueOfferedKey(key, false);\n\t}","commit_id":"206c62a965ba3e18778c228d474e58c8d5e61a20","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * This method runs on the SerialExecutor. Therefore, any blocking network I/O needs to be scheduled\n\t * on a separate thread. However, blocking disk I/O *should happen on this thread*. We deliberately\n\t * serialise it, as high latencies can otherwise result.\n\t */\n\tprotected void innerOnOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(key.getRoutingKey() == null) throw new NullPointerException();\n\t\t//NB: node.hasKey() executes a datastore fetch\n\t\t// If we have the key in the datastore (store or cache), we don't want it.\n\t\t// If we have the key in the client cache, we might want it for other nodes,\n\t\t// although hopefully the client layer was tripped when we got it.\n\t\tif(node.hasKey(key, false, true)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Re-check after potentially long disk I/O.\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || heAsked)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) entriesByKey.removeKey(key);\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(this) {\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Accept the offer.\n\t\t// Either a peer wants it, in which case we want it for them,\n\t\t// or we want it, or we have requested it in the past, in which case\n\t\t// we will probably want it in the future.\n\t\t// FIXME: Not safe to queue offered keys as realtime????\n\t\t// For the same reason that priorities are not safe?\n\t\t// But do it at low priorities?\n\t\t// Offers mostly happen for SSKs anyway ... reconsider?\n\t\tnode.clientCore.queueOfferedKey(key, false);\n\t}","id":67332,"modified_method":"/**\n\t * This method runs on the SerialExecutor. Therefore, any blocking network I/O needs to be scheduled\n\t * on a separate thread. However, blocking disk I/O *should happen on this thread*. We deliberately\n\t * serialise it, as high latencies can otherwise result.\n\t */\n\tprotected void innerOnOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(key.getRoutingKey() == null) throw new NullPointerException();\n\t\t//NB: node.hasKey() executes a datastore fetch\n\t\t// If we have the key in the datastore (store or cache), we don't want it.\n\t\t// If we have the key in the client cache, we might want it for other nodes,\n\t\t// although hopefully the client layer was tripped when we got it.\n\t\tif(node.hasKey(key, false, true)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Re-check after potentially long disk I/O.\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || heAsked)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) {\n\t\t\tsynchronized(this) {\n\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(this) {\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Accept the offer.\n\t\t// Either a peer wants it, in which case we want it for them,\n\t\t// or we want it, or we have requested it in the past, in which case\n\t\t// we will probably want it in the future.\n\t\t// FIXME: Not safe to queue offered keys as realtime????\n\t\t// For the same reason that priorities are not safe?\n\t\t// But do it at low priorities?\n\t\t// Offers mostly happen for SSKs anyway ... reconsider?\n\t\tnode.clientCore.queueOfferedKey(key, false);\n\t}","commit_id":"985dc9c3f773c90b2592dd9a0c7f1448e03dc9e6","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * Called when a data block is found (after it has been stored; there is a good chance of its being available in the\n\t * near future). If there are nodes waiting for it, we will offer it to them.\n\t * LOCKING: Never call when locked PeerNode, and try to avoid other locks as\n\t * they might cause a deadlock. Schedule off-thread if necessary.\n\t */\n\tpublic void onFound(KeyBlock block) {\n\t\tif(logMINOR) Logger.minor(this, \"Found \"+block.getKey());\n\t\tif(!(node.enableULPRDataPropagation || node.enablePerNodeFailureTables)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Ignoring onFound because enable ULPR = \"+node.enableULPRDataPropagation+\" and enable failure tables = \"+node.enablePerNodeFailureTables);\n\t\t\treturn;\n\t\t}\n\t\tKey key = block.getKey();\n\t\tif(key == null) throw new NullPointerException();\n\t\tFailureTableEntry entry;\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Key not found in entriesByKey\");\n\t\t\t\treturn; // Nobody cares\n\t\t\t}\n\t\t\tentriesByKey.removeKey(key);\n\t\t\tblockOfferListByKey.removeKey(key);\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Offering key\");\n\t\tif(!node.enableULPRDataPropagation) return;\n\t\tentry.offer();\n\t}","id":67333,"modified_method":"/**\n\t * Called when a data block is found (after it has been stored; there is a good chance of its being available in the\n\t * near future). If there are nodes waiting for it, we will offer it to them. Removes the list of \n\t * nodes that offered the key too (but this is a separate operation).\n\t * LOCKING: Never call when locked PeerNode, and try to avoid other locks as\n\t * they might cause a deadlock. Schedule off-thread if necessary.\n\t */\n\tpublic void onFound(KeyBlock block) {\n\t\tif(logMINOR) Logger.minor(this, \"Found \"+block.getKey());\n\t\tif(!(node.enableULPRDataPropagation || node.enablePerNodeFailureTables)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Ignoring onFound because enable ULPR = \"+node.enableULPRDataPropagation+\" and enable failure tables = \"+node.enablePerNodeFailureTables);\n\t\t\treturn;\n\t\t}\n\t\tKey key = block.getKey();\n\t\tif(key == null) throw new NullPointerException();\n\t\tFailureTableEntry entry;\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Key not found in entriesByKey\");\n\t\t\t\treturn; // Nobody cares\n\t\t\t}\n\t\t\tentriesByKey.removeKey(key);\n\t\t}\n\t\tsynchronized(blockOfferListByKey) {\n\t\t\tblockOfferListByKey.removeKey(key);\n\t\t}\n\t\tif(logMINOR) Logger.minor(this, \"Offering key\");\n\t\tif(!node.enableULPRDataPropagation) return;\n\t\tentry.offer();\n\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"/** Have we had any offers for the key?\n\t * @param key The key to check.\n\t * @return True if there are any offers, false otherwise.\n\t */\n\tpublic boolean hadAnyOffers(Key key) {\n\t\tBlockOfferList bl;\n\t\tsynchronized(this) {\n\t\t\tbl = blockOfferListByKey.get(key);\n\t\t\treturn bl != null;\n\t\t}\n\t}","id":67334,"modified_method":"/** Have we had any offers for the key?\n\t * @param key The key to check.\n\t * @return True if there are any offers, false otherwise.\n\t */\n\tpublic boolean hadAnyOffers(Key key) {\n\t\tBlockOfferList bl;\n\t\tsynchronized(blockOfferListByKey) {\n\t\t\tbl = blockOfferListByKey.get(key);\n\t\t\treturn bl != null;\n\t\t}\n\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"public long expires() {\n\t\t\tsynchronized(FailureTable.this) {\n\t\t\t\tlong last = 0;\n\t\t\t\tfor(BlockOffer offer: offers) {\n\t\t\t\t\tif(offer.offeredTime > last) last = offer.offeredTime;\n\t\t\t\t}\n\t\t\t\treturn last + OFFER_EXPIRY_TIME;\n\t\t\t}\n\t\t}","id":67335,"modified_method":"public long expires() {\n\t\t\tsynchronized(blockOfferListByKey) {\n\t\t\t\tlong last = 0;\n\t\t\t\tfor(BlockOffer offer: offers) {\n\t\t\t\t\tif(offer.offeredTime > last) last = offer.offeredTime;\n\t\t\t\t}\n\t\t\t\treturn last + OFFER_EXPIRY_TIME;\n\t\t\t}\n\t\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"public boolean isEmpty(long now) {\n\t\t\tsynchronized(FailureTable.this) {\n\t\t\t\tfor(BlockOffer offer: offers) {\n\t\t\t\t\tif(!offer.isExpired(now)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}","id":67336,"modified_method":"public boolean isEmpty(long now) {\n\t\t\tsynchronized(blockOfferListByKey) {\n\t\t\t\tfor(BlockOffer offer: offers) {\n\t\t\t\t\tif(!offer.isExpired(now)) return false;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"public void deleteOffer(BlockOffer offer) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Deleting \"+offer+\" from \"+this);\n\t\t\tsynchronized(FailureTable.this) {\n\t\t\t\tint idx = -1;\n\t\t\t\tfinal int offerLength = offers.length;\n\t\t\t\tfor(int i=0;i<offerLength;i++) {\n\t\t\t\t\tif(offers[i] == offer) idx = i;\n\t\t\t\t}\n\t\t\t\tif(idx < 0) return;\n\t\t\t\tBlockOffer[] newOffers = new BlockOffer[offerLength - 1];\n\t\t\t\tif(idx > 0)\n\t\t\t\t\tSystem.arraycopy(offers, 0, newOffers, 0, idx);\n\t\t\t\tif(idx < newOffers.length)\n\t\t\t\t\tSystem.arraycopy(offers, idx + 1, newOffers, idx, offers.length - idx - 1);\n\t\t\t\toffers = newOffers;\n\t\t\t\tif(offers.length > 1) return;\n\t\t\t\tblockOfferListByKey.removeKey(entry.key);\n\t\t\t}\n\t\t\tnode.clientCore.dequeueOfferedKey(entry.key);\n\t\t}","id":67337,"modified_method":"public void deleteOffer(BlockOffer offer) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Deleting \"+offer+\" from \"+this);\n\t\t\tsynchronized(blockOfferListByKey) {\n\t\t\t\tint idx = -1;\n\t\t\t\tfinal int offerLength = offers.length;\n\t\t\t\tfor(int i=0;i<offerLength;i++) {\n\t\t\t\t\tif(offers[i] == offer) idx = i;\n\t\t\t\t}\n\t\t\t\tif(idx < 0) return;\n\t\t\t\tBlockOffer[] newOffers = new BlockOffer[offerLength - 1];\n\t\t\t\tif(idx > 0)\n\t\t\t\t\tSystem.arraycopy(offers, 0, newOffers, 0, idx);\n\t\t\t\tif(idx < newOffers.length)\n\t\t\t\t\tSystem.arraycopy(offers, idx + 1, newOffers, idx, offers.length - idx - 1);\n\t\t\t\toffers = newOffers;\n\t\t\t\tif(offers.length > 1) return;\n\t\t\t\tblockOfferListByKey.removeKey(entry.key);\n\t\t\t}\n\t\t\tnode.clientCore.dequeueOfferedKey(entry.key);\n\t\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"private synchronized void trimOffersList(long now) {\n\t\twhile(true) {\n\t\t\tif(blockOfferListByKey.isEmpty()) return;\n\t\t\tBlockOfferList bl = blockOfferListByKey.peekValue();\n\t\t\tif(bl.isEmpty(now) || bl.expires() < now || blockOfferListByKey.size() > MAX_OFFERS) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing block offer list \"+bl+\" list size now \"+blockOfferListByKey.size());\n\t\t\t\tblockOfferListByKey.popKey();\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}","id":67338,"modified_method":"private void trimOffersList(long now) {\n\t\tsynchronized(blockOfferListByKey) {\n\t\t\twhile(true) {\n\t\t\t\tif(blockOfferListByKey.isEmpty()) return;\n\t\t\t\tBlockOfferList bl = blockOfferListByKey.peekValue();\n\t\t\t\tif(bl.isEmpty(now) || bl.expires() < now || blockOfferListByKey.size() > MAX_OFFERS) {\n\t\t\t\t\tif(logMINOR) Logger.minor(this, \"Removing block offer list \"+bl+\" list size now \"+blockOfferListByKey.size());\n\t\t\t\t\tblockOfferListByKey.popKey();\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"public OfferList getOffers(Key key) {\n\t\tif(!node.enableULPRDataPropagation) return null;\n\t\tBlockOfferList bl;\n\t\tsynchronized(this) {\n\t\t\tbl = blockOfferListByKey.get(key);\n\t\t\tif(bl == null) return null;\n\t\t}\n\t\treturn new OfferList(bl);\n\t}","id":67339,"modified_method":"public OfferList getOffers(Key key) {\n\t\tif(!node.enableULPRDataPropagation) return null;\n\t\tBlockOfferList bl;\n\t\tsynchronized(blockOfferListByKey) {\n\t\t\tbl = blockOfferListByKey.get(key);\n\t\t\tif(bl == null) return null;\n\t\t}\n\t\treturn new OfferList(bl);\n\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"/**\n\t * This method runs on the SerialExecutor. Therefore, any blocking network I/O needs to be scheduled\n\t * on a separate thread. However, blocking disk I/O *should happen on this thread*. We deliberately\n\t * serialise it, as high latencies can otherwise result.\n\t */\n\tprotected void innerOnOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(logMINOR) Logger.minor(this, \"Inner on offer for \"+key+\" from \"+peer+\" on \"+node.getDarknetPortNumber());\n\t\tif(key.getRoutingKey() == null) throw new NullPointerException();\n\t\t//NB: node.hasKey() executes a datastore fetch\n\t\t// If we have the key in the datastore (store or cache), we don't want it.\n\t\t// If we have the key in the client cache, we might want it for other nodes,\n\t\t// although hopefully the client layer was tripped when we got it.\n\t\tif(node.hasKey(key, false, true)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Re-check after potentially long disk I/O.\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || heAsked)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) {\n\t\t\tsynchronized(this) {\n\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(this) {\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Accept the offer.\n\t\t// Either a peer wants it, in which case we want it for them,\n\t\t// or we want it, or we have requested it in the past, in which case\n\t\t// we will probably want it in the future.\n\t\t// FIXME: Not safe to queue offered keys as realtime????\n\t\t// For the same reason that priorities are not safe?\n\t\t// But do it at low priorities?\n\t\t// Offers mostly happen for SSKs anyway ... reconsider?\n\t\tnode.clientCore.queueOfferedKey(key, false);\n\t}","id":67340,"modified_method":"/**\n\t * This method runs on the SerialExecutor. Therefore, any blocking network I/O needs to be scheduled\n\t * on a separate thread. However, blocking disk I/O *should happen on this thread*. We deliberately\n\t * serialise it, as high latencies can otherwise result.\n\t */\n\tprotected void innerOnOffer(Key key, PeerNode peer, byte[] authenticator) {\n\t\tif(logMINOR) Logger.minor(this, \"Inner on offer for \"+key+\" from \"+peer+\" on \"+node.getDarknetPortNumber());\n\t\tif(key.getRoutingKey() == null) throw new NullPointerException();\n\t\t//NB: node.hasKey() executes a datastore fetch\n\t\t// If we have the key in the datastore (store or cache), we don't want it.\n\t\t// If we have the key in the client cache, we might want it for other nodes,\n\t\t// although hopefully the client layer was tripped when we got it.\n\t\tif(node.hasKey(key, false, true)) {\n\t\t\tLogger.minor(this, \"Already have key\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Re-check after potentially long disk I/O.\n\t\tFailureTableEntry entry;\n\t\tlong now = System.currentTimeMillis();\n\t\tsynchronized(this) {\n\t\t\tentry = entriesByKey.get(key);\n\t\t\tif(entry == null) {\n\t\t\t\tif(logMINOR) Logger.minor(this, \"We didn't ask for the key\");\n\t\t\t\treturn; // we haven't asked for it\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Accept (subject to later checks) if we asked for it.\n\t\t * Should we accept it if we were asked for it? This is \"bidirectional propagation\".\n\t\t * It's good because it makes the whole structure much more reliable; it's bad because\n\t\t * it's not entirely under our control - we didn't choose to route it to the node, the node\n\t\t * routed it to us. Now it's found it before we did...\n\t\t * \n\t\t * Attacks:\n\t\t * - Frost spamming etc: Is it easier to offer data to our peers rather than inserting it? Will\n\t\t * it result in it being propagated further? The peer node would then do the request, rather than\n\t\t * this node doing an insert. Is that beneficial?\n\t\t * \n\t\t * Not relevant with CHKs anyway.\n\t\t * \n\t\t * On the plus side, propagation to nodes that have asked is worthwhile because reduced polling \n\t\t * cost enables more secure messaging systems e.g. outbox polling...\n\t\t * - Social engineering: If a key is unpopular, you can put a different copy of it on different \n\t\t * nodes. You can then use this to trace the requestor - identify that he is or isn't on the target. \n\t\t * You can't do this with a regular insert because it will often go several nodes even at htl 0. \n\t\t * With subscriptions, you might be able to bypass this - but only if you know no other nodes in the\n\t\t * neighbourhood are subscribed. Easier with SSKs; with CHKs you have only binary information of \n\t\t * whether the person got the key (with social engineering). Hard to exploit on darknet; if you're \n\t\t * that close to the suspect there are easier ways to get at them e.g. correlation attacks.\n\t\t * \n\t\t * Conclusion: We should accept the request if:\n\t\t * - We asked for it from that node. (Note that a node might both have asked us and been asked).\n\t\t * - That node asked for it, and it's a CHK.\n\t\t */\n\t\t\n\t\tboolean weAsked = entry.askedFromPeer(peer, now);\n\t\tboolean heAsked = entry.askedByPeer(peer, now);\n\t\tif(!(weAsked || heAsked)) {\n\t\t\tif(logMINOR) Logger.minor(this, \"Not propagating key: weAsked=\"+weAsked+\" heAsked=\"+heAsked);\n\t\t\tif(entry.isEmpty(now)) {\n\t\t\t\tsynchronized(this) {\n\t\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif(entry.isEmpty(now)) {\n\t\t\tsynchronized(this) {\n\t\t\t\tentriesByKey.removeKey(key);\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Valid offer.\n\t\t\n\t\t// Add to offers list\n\t\t\n\t\tsynchronized(blockOfferListByKey) {\t\t\t\n\t\t\tif(logMINOR) Logger.minor(this, \"Valid offer\");\n\t\t\tBlockOfferList bl = blockOfferListByKey.get(key);\n\t\t\tBlockOffer offer = new BlockOffer(peer, now, authenticator, peer.getBootID());\n\t\t\tif(bl == null) {\n\t\t\t\tbl = new BlockOfferList(entry, offer);\n\t\t\t} else {\n\t\t\t\tbl.addOffer(offer);\n\t\t\t}\n\t\t\tblockOfferListByKey.push(key, bl);\n\t\t\ttrimOffersList(now);\n\t\t}\n\t\t\n\t\t// Accept the offer.\n\t\t// Either a peer wants it, in which case we want it for them,\n\t\t// or we want it, or we have requested it in the past, in which case\n\t\t// we will probably want it in the future.\n\t\t// FIXME: Not safe to queue offered keys as realtime????\n\t\t// For the same reason that priorities are not safe?\n\t\t// But do it at low priorities?\n\t\t// Offers mostly happen for SSKs anyway ... reconsider?\n\t\tnode.clientCore.queueOfferedKey(key, false);\n\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"public void addOffer(BlockOffer offer) {\n\t\t\tsynchronized(FailureTable.this) {\n\t\t\t\toffers = Arrays.copyOf(offers, offers.length+1);\n\t\t\t\toffers[offers.length-1] = offer;\n\t\t\t}\n\t\t}","id":67341,"modified_method":"public void addOffer(BlockOffer offer) {\n\t\t\tsynchronized(blockOfferListByKey) {\n\t\t\t\toffers = Arrays.copyOf(offers, offers.length+1);\n\t\t\t\toffers[offers.length-1] = offer;\n\t\t\t}\n\t\t}","commit_id":"1097f0c81744f18262bdd72a69bf17caa5d35519","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n  public void paint(Graphics g, JComponent c) {\n    int w = c.getWidth();\n    int h = c.getHeight();\n    if (isHelpButton(c)) {\n      ((Graphics2D)g).setPaint(UIUtil.getGradientPaint(0, 0, getButtonColor1(), 0, h, getButtonColor2()));\n      int off = JBUI.scale(22);\n      int x = (w - off) / 2;\n      int y = (h - off) / 2;\n      g.fillOval(x, y, off, off);\n      AllIcons.Actions.Help.paintIcon(c, g, x + JBUI.scale(3), y + JBUI.scale(3));\n    } else {\n\n      AbstractButton b = (AbstractButton) c;\n\n\n      ButtonModel model = b.getModel();\n\n      String text = layout(b, SwingUtilities2.getFontMetrics(b, g),\n                           b.getWidth(), b.getHeight());\n\n      final Border border = c.getBorder();\n\n      if (b.isFocusPainted() && b.hasFocus()) {\n        if (border instanceof MacIntelliJBorder) {\n          border.paintBorder(b, g, 1, 1, b.getWidth()-2, b.getHeight()-4);\n        }\n      }\n\n      boolean isDefault = b instanceof JButton && ((JButton)b).isDefaultButton();\n      //final GraphicsConfig config = GraphicsUtil.setupAAPainting(g);\n      final boolean square = isSquare(c);\n      int x = 3;\n      int y = (h - viewRect.height) / 2;\n      Icon icon;\n      icon = isDefault ? LEFT_SELECTED : LEFT;\n      icon.paintIcon(b, g, x, y);\n      x+=icon.getIconWidth();\n      int stop = w - 3 - RIGHT.getIconWidth();\n      Graphics gg = g.create(0,0,w,h);\n      gg.setClip(x, y, stop - x, h);\n      icon = isDefault ? MIDDLE_SELECTED : MIDDLE;\n      while (x < stop) {\n        icon.paintIcon(b, gg, x, y);\n        x+=icon.getIconWidth();\n      }\n      gg.dispose();\n      icon = isDefault ? RIGHT_SELECTED : RIGHT;\n      icon.paintIcon(b, g, stop, y);\n      //config.restore();\n\n\n      clearTextShiftOffset();\n\n      // perform UI specific press action, e.g. Windows L&F shifts text\n      //if (model.isArmed() && model.isPressed()) {\n      //  paintButtonPressed(g,b);\n      //}\n\n      // Paint the Icon\n      if(b.getIcon() != null) {\n        paintIcon(g,c,iconRect);\n      }\n\n      if (text != null && !text.equals(\"\")){\n        View v = (View) c.getClientProperty(BasicHTML.propertyKey);\n        if (v != null) {\n          v.paint(g, textRect);\n        } else {\n          paintText(g, b, textRect, text);\n        }\n      }\n    }\n  }","id":67342,"modified_method":"@Override\n  public void paint(Graphics g, JComponent c) {\n    int w = c.getWidth();\n    int h = c.getHeight();\n    if (isHelpButton(c)) {\n      ((Graphics2D)g).setPaint(UIUtil.getGradientPaint(0, 0, getButtonColor1(), 0, h, getButtonColor2()));\n      int off = JBUI.scale(22);\n      int x = (w - off) / 2;\n      int y = (h - off) / 2;\n      g.fillOval(x, y, off, off);\n      AllIcons.Actions.Help.paintIcon(c, g, x + JBUI.scale(3), y + JBUI.scale(3));\n    } else {\n\n      AbstractButton b = (AbstractButton) c;\n\n\n      ButtonModel model = b.getModel();\n\n      String text = layout(b, SwingUtilities2.getFontMetrics(b, g),\n                           b.getWidth(), b.getHeight());\n\n      final Border border = c.getBorder();\n\n      //if (b.isFocusPainted() && b.hasFocus()) {\n      //  if (border instanceof MacIntelliJBorder) {\n      //    border.paintBorder(b, g, 1, 1, b.getWidth()-2, b.getHeight()-4);\n      //  }\n      //}\n\n      boolean isDefault = b instanceof JButton && ((JButton)b).isDefaultButton();\n      boolean isFocused = c.hasFocus();\n      //final GraphicsConfig config = GraphicsUtil.setupAAPainting(g);\n      final boolean square = isSquare(c);\n      int x = isFocused ? 0 : 2;\n      int y = isFocused ? 0 : (h - viewRect.height) / 2;\n      Icon icon;\n      icon = isDefault ? isFocused ? LEFT_SELECTED_FOCUSED : LEFT_SELECTED\n                       : isFocused ? LEFT_FOCUSED : LEFT;\n      icon.paintIcon(b, g, x, y);\n      x+=icon.getIconWidth();\n      int stop = w - (isFocused ? 0 : 2) - (isFocused ? RIGHT_FOCUSED.getIconWidth() : RIGHT.getIconWidth());\n      Graphics gg = g.create(0,0,w,h);\n      gg.setClip(x, y, stop - x, h);\n      icon = isDefault ? isFocused ? MIDDLE_SELECTED_FOCUSED : MIDDLE_SELECTED\n                       : isFocused ? MIDDLE_FOCUSED : MIDDLE;\n      while (x < stop) {\n        icon.paintIcon(b, gg, x, y);\n        x+=icon.getIconWidth();\n      }\n      gg.dispose();\n      icon = isDefault ? isFocused ? RIGHT_SELECTED_FOCUSED : RIGHT_SELECTED\n                       : isFocused ? RIGHT_FOCUSED : RIGHT;\n      icon.paintIcon(b, g, stop, y);\n      //config.restore();\n\n\n      clearTextShiftOffset();\n\n      // perform UI specific press action, e.g. Windows L&F shifts text\n      //if (model.isArmed() && model.isPressed()) {\n      //  paintButtonPressed(g,b);\n      //}\n\n      // Paint the Icon\n      if(b.getIcon() != null) {\n        paintIcon(g,c,iconRect);\n      }\n\n      if (text != null && !text.equals(\"\")){\n        View v = (View) c.getClientProperty(BasicHTML.propertyKey);\n        if (v != null) {\n          v.paint(g, textRect);\n        } else {\n          paintText(g, b, textRect, text);\n        }\n      }\n    }\n  }","commit_id":"45e056879c97afabb7fd3a311a917a81663270c0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public DirDiffPanel(DirDiffTableModel model, DirDiffDialog dirDiffDialog, DirDiffSettings settings) {\n    myModel = model;\n    myDialog = dirDiffDialog;\n    mySourceDirField.setText(model.getSourceDir().getPath());\n    myTargetDirField.setText(model.getTargetDir().getPath());\n    mySourceDirLabel.setIcon(Icons.FOLDER_ICON);\n    myTargetDirLabel.setIcon(Icons.FOLDER_ICON);\n    myTable.setModel(myModel);\n    final DirDiffTableCellRenderer renderer = new DirDiffTableCellRenderer(myTable);\n    myTable.setDefaultRenderer(Object.class, renderer);\n    myTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        final DirDiffElement last = myModel.getElementAt(e.getLastIndex());\n        final DirDiffElement first = myModel.getElementAt(e.getFirstIndex());\n        if (last.isSeparator()) {\n          myTable.getSelectionModel().setLeadSelectionIndex(e.getFirstIndex());\n        }\n        else if (first.isSeparator()) {\n          myTable.getSelectionModel().setLeadSelectionIndex(e.getLastIndex());\n        }\n        else {\n          final DirDiffElement element = myModel.getElementAt(myTable.getSelectedRow());\n          final Project project = myModel.getProject();\n          clearDiffPanel();\n          if (element.getType() == DirDiffElement.ElementType.CHANGED) {\n            myDiffPanelComponent = element.getSource().getDiffComponent(element.getTarget(), project, myDialog.getWindow());\n            if (myDiffPanelComponent != null) {\n              myDiffPanel.add(myDiffPanelComponent, BorderLayout.CENTER);\n              myCurrentElement = element.getSource();\n            }\n\n          } else {\n            final DiffElement object = element.isSource() ? element.getSource() : element.getTarget();\n            myViewComponent = object.getViewComponent(project);\n\n            if (myViewComponent != null) {\n              myCurrentElement = object;\n              myDiffPanel.add(myViewComponent, BorderLayout.CENTER);\n              myViewComponent.revalidate();\n            } else {\n              myDiffPanel.add(getErrorLabel(), BorderLayout.CENTER);\n              myDiffPanel.revalidate();\n              myDiffPanel.repaint();\n            }\n          }\n        }\n        myDialog.setTitle(myModel.getTitle());\n      }\n    });\n    myTable.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyPressed(KeyEvent e) {\n        final int keyCode = e.getKeyCode();\n        final int rows = myTable.getRowCount();\n        int row = myTable.getSelectedRow();\n        if (keyCode == KeyEvent.VK_DOWN && row != rows - 1) {\n          row++;\n          if (myModel.getElementAt(row).isSeparator()) {\n            row++;\n          }\n        } else if (keyCode == KeyEvent.VK_UP && row != 0) {\n          row--;\n          if (myModel.getElementAt(row).isSeparator()) {\n            row--;\n          }\n        } else {\n          return;\n        }\n        if (0 <= row && row < rows && !myModel.getElementAt(row).isSeparator()) {\n          e.consume();\n          myTable.changeSelection(row, (myModel.getColumnCount() - 1) / 2, false, false);\n        }\n      }\n    });\n    final TableColumnModel columnModel = myTable.getColumnModel();\n    final TableColumn operationColumn = columnModel.getColumn((columnModel.getColumnCount() - 1) / 2);\n    operationColumn.setMaxWidth(25);\n    operationColumn.setMinWidth(25);\n    final ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(\"DirDiff\", new DirDiffToolbarActions(myModel), true);\n    myToolBarPanel.add(toolbar.getComponent(), BorderLayout.CENTER);\n  }","id":67343,"modified_method":"public DirDiffPanel(DirDiffTableModel model, DirDiffDialog dirDiffDialog, DirDiffSettings settings) {\n    mySplitPanel.setDividerLocation(0.5);\n    myModel = model;\n    myDialog = dirDiffDialog;\n    mySourceDirField.setText(model.getSourceDir().getPath());\n    myTargetDirField.setText(model.getTargetDir().getPath());\n    mySourceDirLabel.setIcon(model.getSourceDir().getIcon());\n    myTargetDirLabel.setIcon(model.getTargetDir().getIcon());\n    myTable.setModel(myModel);\n    final DirDiffTableCellRenderer renderer = new DirDiffTableCellRenderer(myTable);\n    myTable.setDefaultRenderer(Object.class, renderer);\n    myTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      @Override\n      public void valueChanged(ListSelectionEvent e) {\n        final DirDiffElement last = myModel.getElementAt(e.getLastIndex());\n        final DirDiffElement first = myModel.getElementAt(e.getFirstIndex());\n        if (last.isSeparator()) {\n          myTable.getSelectionModel().setLeadSelectionIndex(e.getFirstIndex());\n        }\n        else if (first.isSeparator()) {\n          myTable.getSelectionModel().setLeadSelectionIndex(e.getLastIndex());\n        }\n        else {\n          final DirDiffElement element = myModel.getElementAt(myTable.getSelectedRow());\n          final Project project = myModel.getProject();\n          clearDiffPanel();\n          if (element.getType() == DirDiffElement.ElementType.CHANGED) {\n            myDiffPanelComponent = element.getSource().getDiffComponent(element.getTarget(), project, myDialog.getWindow());\n            if (myDiffPanelComponent != null) {\n              myDiffPanel.add(myDiffPanelComponent, BorderLayout.CENTER);\n              myCurrentElement = element.getSource();\n            }\n\n          } else {\n            final DiffElement object = element.isSource() ? element.getSource() : element.getTarget();\n            myViewComponent = object.getViewComponent(project);\n\n            if (myViewComponent != null) {\n              myCurrentElement = object;\n              myDiffPanel.add(myViewComponent, BorderLayout.CENTER);\n              myViewComponent.revalidate();\n            } else {\n              myDiffPanel.add(getErrorLabel(), BorderLayout.CENTER);\n              myDiffPanel.revalidate();\n              myDiffPanel.repaint();\n            }\n          }\n        }\n        myDialog.setTitle(myModel.getTitle());\n      }\n    });\n    myTable.addKeyListener(new KeyAdapter() {\n      @Override\n      public void keyPressed(KeyEvent e) {\n        final int keyCode = e.getKeyCode();\n        final int rows = myTable.getRowCount();\n        int row = myTable.getSelectedRow();\n        if (keyCode == KeyEvent.VK_DOWN && row != rows - 1) {\n          row++;\n          if (myModel.getElementAt(row).isSeparator()) {\n            row++;\n          }\n        } else if (keyCode == KeyEvent.VK_UP && row != 0) {\n          row--;\n          if (myModel.getElementAt(row).isSeparator()) {\n            row--;\n          }\n        } else {\n          return;\n        }\n        if (0 <= row && row < rows && !myModel.getElementAt(row).isSeparator()) {\n          e.consume();\n          myTable.changeSelection(row, (myModel.getColumnCount() - 1) / 2, false, false);\n        }\n      }\n    });\n    final TableColumnModel columnModel = myTable.getColumnModel();\n    final TableColumn operationColumn = columnModel.getColumn((columnModel.getColumnCount() - 1) / 2);\n    operationColumn.setMaxWidth(25);\n    operationColumn.setMinWidth(25);\n    final ActionToolbar toolbar = ActionManager.getInstance().createActionToolbar(\"DirDiff\", new DirDiffToolbarActions(myModel), true);\n    myToolBarPanel.add(toolbar.getComponent(), BorderLayout.CENTER);\n  }","commit_id":"58e33f4d9192e9edbb4ede4939636e18a63b1a15","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private BufferedImage getOrCreate(String path) {\n    final BufferedImage image = cache.get(path);\n    if (image != null) {\n      return image;\n    }\n    final int w = myTable.getWidth();\n    final int h = myTable.getRowHeight();\n    final BufferedImage img = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n    final Icon icon = Icons.FOLDER_ICON;\n    final Graphics g = img.getGraphics();\n    g.drawImage(IconUtil.toImage(icon), 2, (h - icon.getIconHeight()) / 2, null);\n    g.setColor(Color.BLACK);\n    g.drawString(path, 2 + icon.getIconWidth() + 2, h - 2);\n    cache.put(path, img);\n    return img;\n  }","id":67344,"modified_method":"private BufferedImage getOrCreate(String path, Icon icon) {\n    final BufferedImage image = cache.get(path);\n    if (image != null) {\n      return image;\n    }\n    final int w = myTable.getWidth();\n    final int h = myTable.getRowHeight();\n    final BufferedImage img = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n    final Graphics g = img.getGraphics();\n    if (icon != null) {\n      g.drawImage(IconUtil.toImage(icon), 2, (h - icon.getIconHeight()) / 2, null);\n    }\n    g.setColor(Color.BLACK);\n    g.drawString(path, 2 + (icon == null ? 0 : icon.getIconWidth()) + 2, h - 2);\n    cache.put(path, img);\n    return img;\n  }","commit_id":"58e33f4d9192e9edbb4ede4939636e18a63b1a15","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Component getTableCellRendererComponent(final JTable table, Object value, boolean isSelected, boolean hasFocus, final int row, final int column) {\n    final DirDiffTableModel model = (DirDiffTableModel)table.getModel();\n    final DirDiffElement element = model.getElementAt(row);\n    if (element.isSeparator()) {\n      return new JPanel() {\n        @Override\n        public void paint(Graphics g) {\n          super.paint(g);\n          int offset = 0;\n          int i = 0;\n          final TableColumnModel columnModel = table.getColumnModel();\n          while (i < column) {\n            offset += columnModel.getColumn(i).getWidth();\n            i++;\n          }\n          int width = columnModel.getColumn(column).getWidth();\n          int height = table.getRowHeight(row);\n          final BufferedImage image = getOrCreate(element.getName());\n          g.drawImage(image, 0, 0, width, height, offset, 0, offset + width, height, null);\n        }\n      };\n    }\n    final Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n    if (c instanceof JLabel) {\n      final JLabel label = (JLabel)c;\n      if (hasFocus || isSelected) {\n        label.setBorder(noFocusBorder);\n      }\n      label.setIcon(null);\n\n      final DirDiffOperation op = element.getOperation();\n      if (column == (table.getColumnCount() - 1) / 2) {\n        label.setIcon(op.getIcon());\n        label.setHorizontalAlignment(CENTER);\n        return label;\n      }\n\n      Color fg = isSelected ? UIUtil.getTableSelectionForeground() : getForegroundColor(op);\n      label.setForeground(fg);\n      final String name = table.getColumnName(column);\n      if (DirDiffTableModel.COLUMN_DATE.equals(name)) {\n        label.setHorizontalAlignment(CENTER);\n      } else if (DirDiffTableModel.COLUMN_SIZE.equals(name)) {\n        label.setHorizontalAlignment(RIGHT);\n        label.setText(label.getText() + \"  \");\n      } else {\n        label.setHorizontalAlignment(LEFT);\n        final String text = label.getText();\n        label.setText(\"  \" + text);\n        if (text != null && text.trim().length() > 0) {\n          label.setIcon(element.getIcon());\n        }\n      }\n    }\n    return c;\n  }","id":67345,"modified_method":"@Override\n  public Component getTableCellRendererComponent(final JTable table, Object value, boolean isSelected, boolean hasFocus, final int row, final int column) {\n    final DirDiffTableModel model = (DirDiffTableModel)table.getModel();\n    final DirDiffElement element = model.getElementAt(row);\n    if (element.isSeparator()) {\n      return new JPanel() {\n        @Override\n        public void paint(Graphics g) {\n          super.paint(g);\n          int offset = 0;\n          int i = 0;\n          final TableColumnModel columnModel = table.getColumnModel();\n          while (i < column) {\n            offset += columnModel.getColumn(i).getWidth();\n            i++;\n          }\n          int width = columnModel.getColumn(column).getWidth();\n          int height = table.getRowHeight(row);\n          final BufferedImage image = getOrCreate(element.getName(), element.getIcon());\n          g.drawImage(image, 0, 0, width, height, offset, 0, offset + width, height, null);\n        }\n      };\n    }\n    final Component c = super.getTableCellRendererComponent(table, value, isSelected, hasFocus, row, column);\n    if (c instanceof JLabel) {\n      final JLabel label = (JLabel)c;\n      if (hasFocus || isSelected) {\n        label.setBorder(noFocusBorder);\n      }\n      label.setIcon(null);\n\n      final DirDiffOperation op = element.getOperation();\n      if (column == (table.getColumnCount() - 1) / 2) {\n        label.setIcon(op.getIcon());\n        label.setHorizontalAlignment(CENTER);\n        return label;\n      }\n\n      Color fg = isSelected ? UIUtil.getTableSelectionForeground() : getForegroundColor(op);\n      label.setForeground(fg);\n      final String name = table.getColumnName(column);\n      if (DirDiffTableModel.COLUMN_DATE.equals(name)) {\n        label.setHorizontalAlignment(CENTER);\n      } else if (DirDiffTableModel.COLUMN_SIZE.equals(name)) {\n        label.setHorizontalAlignment(RIGHT);\n      } else {\n        label.setHorizontalAlignment(LEFT);\n        final String text = label.getText();\n        label.setText(\"  \" + text);\n        if (text != null && text.trim().length() > 0) {\n          label.setIcon(element.getIcon());\n        }\n      }\n    }\n    return c;\n  }","commit_id":"58e33f4d9192e9edbb4ede4939636e18a63b1a15","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void loadModel(DiffElement src, DiffElement trg, ProgressIndicator indicator) {\n    mySrc = src;\n    myTrg = trg;\n    scan(\"\", src, mySrcPaths, indicator, true);\n    scan(\"\", trg, myTrgPaths, indicator, true);\n\n    final HashSet<String> files = new HashSet<String>();\n    files.addAll(mySrcPaths.keySet());\n    files.addAll(myTrgPaths.keySet());\n    final ArrayList<String> pathes = new ArrayList<String>(files);\n    Collections.sort(pathes, new Comparator<String>() {\n      @Override\n      public int compare(String o1, String o2) {\n        final boolean b1 = o1.endsWith(\"/\");\n        final boolean b2 = o2.endsWith(\"/\");\n        final String[] dirs1 = o1.split(\"/\");\n        final String[] dirs2 = o2.split(\"/\");\n        final int len1 = dirs1.length;\n        final int len2 = dirs2.length;\n\n        if ((!b1 && len1 == 1) || (!b2 && len2 == 1)) {\n          if ((!b1 && len1 == 1) && (!b2 && len2 == 1)) {\n            return dirs1[0].toLowerCase().compareTo(dirs2[0].toLowerCase());\n          } else {\n            return len1 == 1 ? -1 : 1;\n          }\n        }\n        for (int i = 0; i < Math.min(len1, len2); i++) {\n          final int cmp = dirs1[i].toLowerCase().compareTo(dirs2[i].toLowerCase());\n          if (cmp != 0) return cmp;\n        }\n\n        return len1 - len2;\n      }\n    });\n\n    for (String path : pathes) {\n      final DiffElement srcFile = mySrcPaths.get(path);\n      final DiffElement trgFile = myTrgPaths.get(path);\n      if (srcFile == null && trgFile != null) {\n        myElements.add(DirDiffElement.createTargetOnly(trgFile));\n      } else if (srcFile != null && trgFile == null) {\n        myElements.add(DirDiffElement.createSourceOnly(srcFile));\n      } else if (srcFile != null && trgFile != null) {\n        indicator.setText2(\"Comparing \" + path);\n        if (srcFile.isContainer() && trgFile.isContainer()) {\n          myElements.add(DirDiffElement.createDirElement(srcFile, trgFile, path));\n        } else if (srcFile.isContainer() && !trgFile.isContainer()) {\n          myElements.add(DirDiffElement.createDirElement(srcFile, null, path));\n          myElements.add(DirDiffElement.createTargetOnly(trgFile));\n        } else if (!srcFile.isContainer() && trgFile.isContainer()) {\n          myElements.add(DirDiffElement.createDirElement(null, trgFile, path));\n          myElements.add(DirDiffElement.createSourceOnly(srcFile));\n        } else if (!isEqual(srcFile, trgFile)) {\n            myElements.add(DirDiffElement.createChange(srcFile, trgFile));\n        }\n      }\n    }\n    removeEmptyDirs(myElements);\n  }","id":67346,"modified_method":"public void loadModel(DiffElement src, DiffElement trg, ProgressIndicator indicator) {\n    mySrc = src;\n    myTrg = trg;\n    scan(\"\", src, mySrcPaths, indicator, true);\n    scan(\"\", trg, myTrgPaths, indicator, true);\n\n    final HashSet<String> files = new HashSet<String>();\n    files.addAll(mySrcPaths.keySet());\n    files.addAll(myTrgPaths.keySet());\n    final ArrayList<String> pathes = new ArrayList<String>(files);\n    Collections.sort(pathes, new Comparator<String>() {\n      @Override\n      public int compare(String o1, String o2) {\n        final boolean b1 = o1.endsWith(\"/\");\n        final boolean b2 = o2.endsWith(\"/\");\n        final String[] dirs1 = o1.split(\"/\");\n        final String[] dirs2 = o2.split(\"/\");\n        final int len1 = dirs1.length;\n        final int len2 = dirs2.length;\n\n        if ((!b1 && len1 == 1) || (!b2 && len2 == 1)) {\n          if ((!b1 && len1 == 1) && (!b2 && len2 == 1)) {\n            return dirs1[0].toLowerCase().compareTo(dirs2[0].toLowerCase());\n          } else {\n            return len1 == 1 ? -1 : 1;\n          }\n        }\n        for (int i = 0; i < Math.min(len1, len2); i++) {\n          final int cmp = dirs1[i].toLowerCase().compareTo(dirs2[i].toLowerCase());\n          if (cmp != 0) return cmp;\n        }\n\n        return len1 - len2;\n      }\n    });\n\n    for (String path : pathes) {\n      final DiffElement srcFile = mySrcPaths.get(path);\n      final DiffElement trgFile = myTrgPaths.get(path);\n      if (srcFile == null && trgFile != null) {\n        myElements.add(trgFile.isContainer() ? DirDiffElement.createDirElement(srcFile, trgFile, path) : DirDiffElement.createTargetOnly(trgFile));\n      } else if (srcFile != null && trgFile == null) {\n        myElements.add(srcFile.isContainer() ? DirDiffElement.createDirElement(srcFile, trgFile, path) : DirDiffElement.createSourceOnly(srcFile));\n      } else if (srcFile != null && trgFile != null) {\n        indicator.setText2(\"Comparing \" + path);\n        if (srcFile.isContainer() && trgFile.isContainer()) {\n          myElements.add(DirDiffElement.createDirElement(srcFile, trgFile, path));\n        } else if (srcFile.isContainer() && !trgFile.isContainer()) {\n          myElements.add(DirDiffElement.createDirElement(srcFile, null, path));\n          myElements.add(DirDiffElement.createTargetOnly(trgFile));\n        } else if (!srcFile.isContainer() && trgFile.isContainer()) {\n          myElements.add(DirDiffElement.createDirElement(null, trgFile, path));\n          myElements.add(DirDiffElement.createSourceOnly(srcFile));\n        } else if (!isEqual(srcFile, trgFile)) {\n            myElements.add(DirDiffElement.createChange(srcFile, trgFile));\n        }\n      }\n    }\n    removeEmptyDirs(myElements);\n  }","commit_id":"58e33f4d9192e9edbb4ede4939636e18a63b1a15","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Retrieves the blobName from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getBlobName(Exchange exchange) {\n        String blobName = ((JcloudsBlobStoreEndpoint) getEndpoint()).getBlobName();\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME))) {\n            blobName = (String) exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME);\n        }\n        return blobName;\n    }","id":67347,"modified_method":"/**\n     * Retrieves the blobName from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getBlobName(Exchange exchange) {\n        String blobName = ((JcloudsBlobStoreEndpoint) getEndpoint()).getBlobName();\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME))) {\n            blobName = exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME, String.class);\n        }\n        return blobName;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the locationId from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    public String getLocationId(Exchange exchange) {\n        String operation = ((JcloudsBlobStoreEndpoint) getEndpoint()).getLocationId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID))) {\n            operation = (String) exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID);\n        }\n        return operation;\n    }","id":67348,"modified_method":"/**\n     * Retrieves the locationId from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    public String getLocationId(Exchange exchange) {\n        String operation = ((JcloudsBlobStoreEndpoint) getEndpoint()).getLocationId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID))) {\n            operation = exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID, String.class);\n        }\n        return operation;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the operation from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    public String getOperation(Exchange exchange) {\n        String operation = ((JcloudsBlobStoreEndpoint) getEndpoint()).getOperation();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.OPERATION))) {\n            operation = (String) exchange.getIn().getHeader(JcloudsConstants.OPERATION);\n        }\n        return operation;\n    }","id":67349,"modified_method":"/**\n     * Retrieves the operation from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    public String getOperation(Exchange exchange) {\n        String operation = ((JcloudsBlobStoreEndpoint) getEndpoint()).getOperation();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.OPERATION))) {\n            operation = exchange.getIn().getHeader(JcloudsConstants.OPERATION, String.class);\n        }\n        return operation;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the Blob name list from the exchange headers.\n     */\n    public List getBlobNameList(Exchange exchange) {\n        List blobNames = new ArrayList<>();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME_LIST))) {\n            blobNames = (List) exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME_LIST);\n        }\n        return blobNames;\n    }","id":67350,"modified_method":"/**\n     * Retrieves the Blob name list from the exchange headers.\n     */\n    public List getBlobNameList(Exchange exchange) {\n        List blobNames = new ArrayList<>();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME_LIST))) {\n            blobNames = exchange.getIn().getHeader(JcloudsConstants.BLOB_NAME_LIST, List.class);\n        }\n        return blobNames;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the containerName from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getContainerName(Exchange exchange) {\n        String containerName = ((JcloudsBlobStoreEndpoint) getEndpoint()).getContainer();\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.CONTAINER_NAME))) {\n            containerName = (String) exchange.getIn().getHeader(JcloudsConstants.CONTAINER_NAME);\n        }\n        return containerName;\n    }","id":67351,"modified_method":"/**\n     * Retrieves the containerName from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getContainerName(Exchange exchange) {\n        String containerName = ((JcloudsBlobStoreEndpoint) getEndpoint()).getContainer();\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.CONTAINER_NAME))) {\n            containerName = exchange.getIn().getHeader(JcloudsConstants.CONTAINER_NAME, String.class);\n        }\n        return containerName;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the hardware id from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getHardwareId(Exchange exchange) {\n        String hardwareId = getEndpoint().getHardwareId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID))) {\n            hardwareId = (String) exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID);\n        }\n        return hardwareId;\n    }","id":67352,"modified_method":"/**\n     * Retrieves the hardware id from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getHardwareId(Exchange exchange) {\n        String hardwareId = getEndpoint().getHardwareId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID))) {\n            hardwareId = exchange.getIn().getHeader(JcloudsConstants.HARDWARE_ID, String.class);\n        }\n        return hardwareId;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the node id from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getNodeId(Exchange exchange) {\n        String nodeId = getEndpoint().getNodeId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.NODE_ID))) {\n            nodeId = (String) exchange.getIn().getHeader(JcloudsConstants.NODE_ID);\n        }\n        return nodeId;\n    }","id":67353,"modified_method":"/**\n     * Retrieves the node id from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getNodeId(Exchange exchange) {\n        String nodeId = getEndpoint().getNodeId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.NODE_ID))) {\n            nodeId = exchange.getIn().getHeader(JcloudsConstants.NODE_ID, String.class);\n        }\n        return nodeId;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the group from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getGroup(Exchange exchange) {\n        String group = getEndpoint().getGroup();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.GROUP))) {\n            group = (String) exchange.getIn().getHeader(JcloudsConstants.GROUP);\n        }\n        return group;\n    }","id":67354,"modified_method":"/**\n     * Retrieves the group from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getGroup(Exchange exchange) {\n        String group = getEndpoint().getGroup();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.GROUP))) {\n            group = exchange.getIn().getHeader(JcloudsConstants.GROUP, String.class);\n        }\n        return group;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the location id from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getLocationId(Exchange exchange) {\n        String locationId = getEndpoint().getLocationId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID))) {\n            locationId = (String) exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID);\n        }\n        return locationId;\n    }","id":67355,"modified_method":"/**\n     * Retrieves the location id from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getLocationId(Exchange exchange) {\n        String locationId = getEndpoint().getLocationId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID))) {\n            locationId = exchange.getIn().getHeader(JcloudsConstants.LOCATION_ID, String.class);\n        }\n        return locationId;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the user from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getUser(Exchange exchange) {\n        String user = getEndpoint().getUser();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.USER))) {\n            user = (String) exchange.getIn().getHeader(JcloudsConstants.USER);\n        }\n        return user;\n    }","id":67356,"modified_method":"/**\n     * Retrieves the user from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    protected String getUser(Exchange exchange) {\n        String user = getEndpoint().getUser();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.USER))) {\n            user = exchange.getIn().getHeader(JcloudsConstants.USER, String.class);\n        }\n        return user;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the operation from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    public String getOperation(Exchange exchange) {\n        String operation = getEndpoint().getOperation();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.OPERATION))) {\n            operation = (String) exchange.getIn().getHeader(JcloudsConstants.OPERATION);\n        }\n        return operation;\n    }","id":67357,"modified_method":"/**\n     * Retrieves the operation from the URI or from the exchange headers. The header will take precedence over the URI.\n     */\n    public String getOperation(Exchange exchange) {\n        String operation = getEndpoint().getOperation();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.OPERATION))) {\n            operation = exchange.getIn().getHeader(JcloudsConstants.OPERATION, String.class);\n        }\n        return operation;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Retrieves the image id from the URI or from the exchange properties. The property will take precedence over the URI.\n     */\n    protected String getImageId(Exchange exchange) {\n        String imageId = getEndpoint().getImageId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID))) {\n            imageId = (String) exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID);\n        }\n        return imageId;\n    }","id":67358,"modified_method":"/**\n     * Retrieves the image id from the URI or from the exchange properties. The property will take precedence over the URI.\n     */\n    protected String getImageId(Exchange exchange) {\n        String imageId = getEndpoint().getImageId();\n\n        if (ObjectHelper.isNotEmpty(exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID))) {\n            imageId = exchange.getIn().getHeader(JcloudsConstants.IMAGE_ID, String.class);\n        }\n        return imageId;\n    }","commit_id":"864bb35d7b48b42dfbf49933082cb0ca063d4ae9","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Populate Restlet Request from Camel message\n     * \n     * @param request to be populated\n     * @param exchange message to be copied from\n     */\n    public void populateRestletRequestFromExchange(Request request,\n            Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n        String body = exchange.getIn().getBody(String.class);\n        Form form = new Form();\n        // add the body as the key in the form with null value\n        form.add(body, null);\n        \n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Populate Restlet request from exchange body: \" + body);\n        }\n        \n        // login and password are filtered by header filter strategy\n        String login = (String) exchange.getIn().getHeader(RestletConstants.LOGIN);\n        String password = (String) exchange.getIn().getHeader(RestletConstants.PASSWORD);\n          \n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(\n                    ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Basic HTTP Authentication has been applied\");\n            }\n        }\n        \n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), \n                    entry.getValue())) {\n                if (entry.getKey().startsWith(\"org.restlet.\")) {\n                    // put the org.restlet headers in attributes\n                    request.getAttributes().put(entry.getKey(), entry.getValue());\n                } else {\n                    // put the user stuff in the form\n                    form.add(entry.getKey(), entry.getValue().toString());   \n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet request from exchange header: \" \n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n        \n        request.setEntity(form.getWebRepresentation());\n    }","id":67359,"modified_method":"/**\n     * Populate Restlet Request from Camel message\n     * \n     * @param request to be populated\n     * @param exchange message to be copied from\n     */\n    public void populateRestletRequestFromExchange(Request request, Exchange exchange) {\n        request.setReferrerRef(\"camel-restlet\");\n        String body = exchange.getIn().getBody(String.class);\n        Form form = new Form();\n        // add the body as the key in the form with null value\n        form.add(body, null);\n        \n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Populate Restlet request from exchange body: \" + body);\n        }\n        \n        // login and password are filtered by header filter strategy\n        String login = exchange.getIn().getHeader(RestletConstants.RESTLET_LOGIN, String.class);\n        String password = exchange.getIn().getHeader(RestletConstants.RESTLET_PASSWORD, String.class);\n          \n        if (login != null && password != null) {\n            ChallengeResponse authentication = new ChallengeResponse(ChallengeScheme.HTTP_BASIC, login, password);\n            request.setChallengeResponse(authentication);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Basic HTTP Authentication has been applied\");\n            }\n        }\n        \n        for (Map.Entry<String, Object> entry : exchange.getIn().getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue())) {\n                if (entry.getKey().startsWith(\"org.restlet.\")) {\n                    // put the org.restlet headers in attributes\n                    request.getAttributes().put(entry.getKey(), entry.getValue());\n                } else {\n                    // put the user stuff in the form\n                    form.add(entry.getKey(), entry.getValue().toString());   \n                }\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet request from exchange header: \" \n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n        \n        request.setEntity(form.getWebRepresentation());\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Populate Camel message from Restlet request\n     * \n     * @param request message to be copied from\n     * @param exchange to be populated\n     * @throws Exception \n     */\n    public void populateExchangeFromRestletRequest(Request request,\n            Exchange exchange) throws Exception {\n\n        Message inMessage = exchange.getIn();\n        // extract headers from restlet \n        for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), \n                    entry.getValue())) {\n                \n                inMessage.setHeader(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate exchange from Restlet request header: \" \n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n\n            }\n        }\n        \n        // copy query string to header\n        String query = request.getResourceRef().getQuery();\n        if (null != query) {\n            inMessage.setHeader(RestletConstants.QUERY_STRING, query);\n        }\n\n        if (!request.isEntityAvailable()) {\n            return;\n        }\n        \n        Form form = new Form(request.getEntity());\n        if (form != null) {\n            for (Map.Entry<String, String> entry : form.getValuesMap().entrySet()) {\n                // extract body added to the form as the key which has null value\n                if (entry.getValue() == null) {\n                    inMessage.setBody(entry.getKey());\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Populate exchange from Restlet request body: \" + entry.getValue());\n                    }\n                } else {\n                    if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), \n                            entry.getValue())) {\n\n                        inMessage.setHeader(entry.getKey(), entry.getValue());\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Populate exchange from Restlet request user header: \" \n                                    + entry.getKey() + \" value: \" + entry.getValue());\n                        }\n                    }\n                }\n            }\n        }        \n    }","id":67360,"modified_method":"/**\n     * Populate Camel message from Restlet request\n     * \n     * @param request message to be copied from\n     * @param exchange to be populated\n     * @throws Exception \n     */\n    public void populateExchangeFromRestletRequest(Request request, Exchange exchange) throws Exception {\n\n        Message inMessage = exchange.getIn();\n        // extract headers from restlet \n        for (Map.Entry<String, Object> entry : request.getAttributes().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(), \n                    entry.getValue())) {\n                \n                inMessage.setHeader(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate exchange from Restlet request header: \" \n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n\n            }\n        }\n        \n        // copy query string to header\n        String query = request.getResourceRef().getQuery();\n        if (null != query) {\n            inMessage.setHeader(RestletConstants.RESTLET_QUERY_STRING, query);\n        }\n\n        if (!request.isEntityAvailable()) {\n            return;\n        }\n\n        // TODO: What is this form used for? Doesnt make sence in the code below as form is never used\n        Form form = new Form(request.getEntity());\n        if (form != null) {\n            for (Map.Entry<String, String> entry : form.getValuesMap().entrySet()) {\n                // extract body added to the form as the key which has null value\n                if (entry.getValue() == null) {\n                    inMessage.setBody(entry.getKey());\n                    if (LOG.isDebugEnabled()) {\n                        LOG.debug(\"Populate exchange from Restlet request body: \" + entry.getValue());\n                    }\n                } else {\n                    if (!headerFilterStrategy.applyFilterToExternalHeaders(entry.getKey(),\n                            entry.getValue())) {\n\n                        inMessage.setHeader(entry.getKey(), entry.getValue());\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"Populate exchange from Restlet request user header: \"\n                                    + entry.getKey() + \" value: \" + entry.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Populate Restlet request from Camel message\n     *  \n     * @param exchange message to be copied from \n     * @param response to be populated\n     */\n    public void populateRestletResponseFromExchange(Exchange exchange,\n            Response response) {\n        \n        Message out = null;\n        if (exchange.isFailed()) {\n            // 500 for internal server error which can be overridden by response code in header\n            response.setStatus(Status.valueOf(500));\n            out = exchange.getFault(false);\n            if (out == null) {\n                Throwable t = exchange.getException();\n                if (t != null) {\n                    StringWriter sw = new StringWriter();\n                    PrintWriter pw = new PrintWriter(sw);\n                    t.printStackTrace(pw);\n                    response.setEntity(sw.toString(), MediaType.TEXT_PLAIN);\n                    return;\n                }\n            } \n        } else {\n            out = exchange.getOut();\n        }\n        \n        // get content type\n        MediaType mediaType = out.getHeader(RestletConstants.MEDIA_TYPE, MediaType.class);\n        if (mediaType == null) {\n            Object body = out.getBody();\n            mediaType = MediaType.TEXT_PLAIN;\n            if (body instanceof String) {\n                mediaType = MediaType.TEXT_PLAIN;\n            } else if (body instanceof StringSource || body instanceof DOMSource) {\n                mediaType = MediaType.TEXT_XML;\n            }\n        }\n                \n        // get response code\n        Integer responseCode = out.getHeader(RestletConstants.RESPONSE_CODE, Integer.class);\n        if (responseCode != null) {\n            response.setStatus(Status.valueOf(responseCode));\n        }\n\n        for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), \n                    entry.getValue())) {\n                response.getAttributes().put(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet response from exchange header: \" \n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n        \n        String text = out.getBody(String.class);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Populate Restlet response from exchange body: \" + text);\n        }\n        response.setEntity(text, mediaType);\n    }","id":67361,"modified_method":"/**\n     * Populate Restlet request from Camel message\n     *  \n     * @param exchange message to be copied from \n     * @param response to be populated\n     */\n    public void populateRestletResponseFromExchange(Exchange exchange, Response response) {\n        \n        Message out;\n        if (exchange.isFailed()) {\n            // 500 for internal server error which can be overridden by response code in header\n            response.setStatus(Status.valueOf(500));\n            out = exchange.getFault(false);\n            if (out == null) {\n                Throwable t = exchange.getException();\n                if (t != null) {\n                    StringWriter sw = new StringWriter();\n                    PrintWriter pw = new PrintWriter(sw);\n                    t.printStackTrace(pw);\n                    response.setEntity(sw.toString(), MediaType.TEXT_PLAIN);\n                    return;\n                }\n            } \n        } else {\n            out = exchange.getOut();\n        }\n        \n        // get content type\n        MediaType mediaType = out.getHeader(RestletConstants.RESTLET_MEDIA_TYPE, MediaType.class);\n        if (mediaType == null) {\n            Object body = out.getBody();\n            mediaType = MediaType.TEXT_PLAIN;\n            if (body instanceof String) {\n                mediaType = MediaType.TEXT_PLAIN;\n            } else if (body instanceof StringSource || body instanceof DOMSource) {\n                mediaType = MediaType.TEXT_XML;\n            }\n        }\n                \n        // get response code\n        Integer responseCode = out.getHeader(RestletConstants.RESTLET_RESPONSE_CODE, Integer.class);\n        if (responseCode != null) {\n            response.setStatus(Status.valueOf(responseCode));\n        }\n\n        for (Map.Entry<String, Object> entry : out.getHeaders().entrySet()) {\n            if (!headerFilterStrategy.applyFilterToCamelHeaders(entry.getKey(), entry.getValue())) {\n                response.getAttributes().put(entry.getKey(), entry.getValue());\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"Populate Restlet response from exchange header: \" \n                            + entry.getKey() + \" value: \" + entry.getValue());\n                }\n            }\n        }\n        \n        String text = out.getBody(String.class);\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Populate Restlet response from exchange body: \" + text);\n        }\n        response.setEntity(text, mediaType);\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() {\n\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"restlet:http://localhost:9080/users/{username}?restletMethod=POST\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getFault().setHeader(RestletConstants.RESPONSE_CODE, \"404\");\n                        exchange.getFault().setHeader(RestletConstants.MEDIA_TYPE, \"text/plain\");\n                        exchange.getFault().setBody(\"Application fault\");\n                        \n                    }        \n                });\n            }\n        };\n    }","id":67362,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() {\n\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"restlet:http://localhost:9080/users/{username}?restletMethod=POST\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getFault().setHeader(RestletConstants.RESTLET_RESPONSE_CODE, \"404\");\n                        exchange.getFault().setHeader(RestletConstants.RESTLET_MEDIA_TYPE, \"text/plain\");\n                        exchange.getFault().setBody(\"Application fault\");\n                        \n                    }        \n                });\n            }\n        };\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"public RestletHeaderFilterStrategy() {\n        // No IN filters and copy all headers from Restlet to Camel\n        \n        // OUT filters (from Camel headers to Restlet headers)\n        // filter headers used internally by this component\n        getOutFilter().add(RestletConstants.LOGIN);\n        getOutFilter().add(RestletConstants.PASSWORD);\n    }","id":67363,"modified_method":"public RestletHeaderFilterStrategy() {\n        // No IN filters and copy all headers from Restlet to Camel\n        \n        // OUT filters (from Camel headers to Restlet headers)\n        // filter headers used internally by this component\n        getOutFilter().add(RestletConstants.RESTLET_LOGIN);\n        getOutFilter().add(RestletConstants.RESTLET_PASSWORD);\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {   \n            assertEquals(QUERY_STRING, exchange.getIn().getHeader(RestletConstants.QUERY_STRING, String.class));\n        }","id":67364,"modified_method":"public void process(Exchange exchange) throws Exception {   \n            assertEquals(QUERY_STRING, exchange.getIn().getHeader(RestletConstants.RESTLET_QUERY_STRING, String.class));\n        }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() {\n\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"restlet:http://localhost:9080/users/{username}?restletMethod=POST\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setHeader(RestletConstants.RESPONSE_CODE, \"417\");\n                        exchange.getOut().setHeader(RestletConstants.MEDIA_TYPE, \"application/JSON\");\n                    }        \n                });\n            }\n        };\n    }","id":67365,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() {\n\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                from(\"restlet:http://localhost:9080/users/{username}?restletMethod=POST\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        exchange.getOut().setHeader(RestletConstants.RESTLET_RESPONSE_CODE, \"417\");\n                        exchange.getOut().setHeader(RestletConstants.RESTLET_MEDIA_TYPE, \"application/JSON\");\n                    }        \n                });\n            }\n        };\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"public void testhBasicAuthError() throws IOException {\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.LOGIN, \"admin\");\n        headers.put(RestletConstants.PASSWORD, \"bad\");\n        headers.put(\"id\", \"xyz\");\n        String response = (String) template.requestBodyAndHeaders(\"direct:start-auth\", \n                \"<order foo='1'/>\", headers);\n        assertTrue(response.contains(\"requires user authentication\"));\n    }","id":67366,"modified_method":"public void testhBasicAuthError() throws IOException {\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.RESTLET_LOGIN, \"admin\");\n        headers.put(RestletConstants.RESTLET_PASSWORD, \"bad\");\n        headers.put(\"id\", \"xyz\");\n        String response = (String) template.requestBodyAndHeaders(\"direct:start-auth\", \n                \"<order foo='1'/>\", headers);\n        assertTrue(response.contains(\"requires user authentication\"));\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"public void testBasicAuth() throws IOException {\n        \n        // START SNIPPET: auth_request\n        final String id = \"89531\";\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.LOGIN, \"admin\");\n        headers.put(RestletConstants.PASSWORD, \"foo\");\n        headers.put(\"id\", id);\n        \n        String response = (String) template.requestBodyAndHeaders(\"direct:start-auth\", \n                \"<order foo='1'/>\", headers);\n        // END SNIPPET: auth_request\n\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + id,\n                response);\n    }","id":67367,"modified_method":"public void testBasicAuth() throws IOException {\n        \n        // START SNIPPET: auth_request\n        final String id = \"89531\";\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(RestletConstants.RESTLET_LOGIN, \"admin\");\n        headers.put(RestletConstants.RESTLET_PASSWORD, \"foo\");\n        headers.put(\"id\", id);\n        \n        String response = (String) template.requestBodyAndHeaders(\"direct:start-auth\", \n                \"<order foo='1'/>\", headers);\n        // END SNIPPET: auth_request\n\n        assertEquals(\"received [<order foo='1'/>] as an order id = \" + id,\n                response);\n    }","commit_id":"dbdf1cf30bd5b5d23435a21a3e3a61d6e89ab27e","url":"https://github.com/apache/camel"},{"original_method":"private static DataDictionary getDataDictionary(Exchange exchange) throws ConfigError {\n        Object dictionaryValue = exchange.getProperties().get(QuickfixjEndpoint.DATA_DICTIONARY_KEY);\n\n        DataDictionary dataDictionary;\n        if (dictionaryValue instanceof DataDictionary) {\n            dataDictionary = (DataDictionary) dictionaryValue;\n        } else if (dictionaryValue instanceof String) {\n            dataDictionary = new DataDictionary((String) dictionaryValue);\n        } else {\n            SessionID sessionID = (SessionID) exchange.getIn().getHeader(QuickfixjEndpoint.SESSION_ID_KEY);\n            Session session = Session.lookupSession(sessionID);\n            dataDictionary = session != null ? session.getDataDictionary() : null;\n        }\n\n        return dataDictionary;\n    }","id":67368,"modified_method":"private static DataDictionary getDataDictionary(Exchange exchange) throws ConfigError {\n        Object dictionaryValue = exchange.getProperties().get(QuickfixjEndpoint.DATA_DICTIONARY_KEY);\n\n        DataDictionary dataDictionary = null;\n        if (dictionaryValue instanceof DataDictionary) {\n            dataDictionary = (DataDictionary) dictionaryValue;\n        } else if (dictionaryValue instanceof String) {\n            dataDictionary = new DataDictionary((String) dictionaryValue);\n        } else {\n            SessionID sessionID = exchange.getIn().getHeader(QuickfixjEndpoint.SESSION_ID_KEY, SessionID.class);\n            if (sessionID != null) {\n                Session session = Session.lookupSession(sessionID);\n                dataDictionary = session != null ? session.getDataDictionary() : null;\n            }\n        }\n\n        return dataDictionary;\n    }","commit_id":"4e2168db99349ada84d00446a33f1db1c5ba8acd","url":"https://github.com/apache/camel"},{"original_method":"private boolean isOrderExecutable(Message order, Price price) throws FieldNotFound {\n        if (order.getChar(OrdType.FIELD) == OrdType.LIMIT) {\n            BigDecimal limitPrice = new BigDecimal(order.getString(Price.FIELD));\n            char side = order.getChar(Side.FIELD);\n            BigDecimal thePrice = new BigDecimal(Double.toString(price.getValue()));\n\n            return (side == Side.BUY && thePrice.compareTo(limitPrice) <= 0) \n                || ((side == Side.SELL || side == Side.SELL_SHORT) && thePrice.compareTo(limitPrice) >= 0);\n        }\n        return true;\n    }","id":67369,"modified_method":"private boolean isOrderExecutable(Message order, Price price) throws FieldNotFound {\n        if (order.getChar(OrdType.FIELD) == OrdType.LIMIT) {\n            BigDecimal limitPrice = new BigDecimal(order.getString(Price.FIELD));\n            char side = order.getChar(Side.FIELD);\n            BigDecimal thePrice = price.getValue();\n\n            return (side == Side.BUY && thePrice.compareTo(limitPrice) <= 0) \n                || ((side == Side.SELL || side == Side.SELL_SHORT) && thePrice.compareTo(limitPrice) >= 0);\n        }\n        return true;\n    }","commit_id":"4e2168db99349ada84d00446a33f1db1c5ba8acd","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        String ssn = (String)exchange.getIn().getHeader(Constants.PROPERTY_SSN);\n        Integer historyLength = (Integer) exchange.getIn().getHeader(Constants.PROPERTY_HISTORYLENGTH);\n        double rate = primeRate + (double)(historyLength / 12) / 10 + (double)(Math.random() * 10) / 10;\n        LOG.info(\"The bank: \" + bankName + \" for client: \" + ssn + \" 's rate \" + rate);\n        exchange.getOut().setHeader(Constants.PROPERTY_RATE, new Double(rate));\n        exchange.getOut().setHeader(Constants.PROPERTY_BANK, bankName);\n        exchange.getOut().setHeader(Constants.PROPERTY_SSN, ssn);\n        // Sleep some time\n        try {\n            Thread.sleep((int) (Math.random() * 10) * 100);\n        } catch (InterruptedException e) {\n            // Discard\n        }\n    }","id":67370,"modified_method":"public void process(Exchange exchange) throws Exception {\n        String ssn = exchange.getIn().getHeader(Constants.PROPERTY_SSN, String.class);\n        Integer historyLength = exchange.getIn().getHeader(Constants.PROPERTY_HISTORYLENGTH, Integer.class);\n        double rate = primeRate + (double)(historyLength / 12) / 10 + (double)(Math.random() * 10) / 10;\n        LOG.info(\"The bank: \" + bankName + \" for client: \" + ssn + \" 's rate \" + rate);\n        exchange.getOut().setHeader(Constants.PROPERTY_RATE, new Double(rate));\n        exchange.getOut().setHeader(Constants.PROPERTY_BANK, bankName);\n        exchange.getOut().setHeader(Constants.PROPERTY_SSN, ssn);\n        // Sleep some time\n        try {\n            Thread.sleep((int) (Math.random() * 10) * 100);\n        } catch (InterruptedException e) {\n            // Discard\n        }\n    }","commit_id":"872947062d9c16bfafb8160eb08858447909dc07","url":"https://github.com/apache/camel"},{"original_method":"public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n        LOG.debug(\"Get the exchange to aggregate, older: \" + oldExchange + \" newer:\" + newExchange);\n        Integer old = (Integer) oldExchange.getProperty(\"aggregated\");\n        Double oldRate = (Double) oldExchange.getIn().getHeader(Constants.PROPERTY_RATE);\n        Double newRate = (Double) newExchange.getIn().getHeader(Constants.PROPERTY_RATE);\n        Exchange result = null;\n        if (old == null) {\n            old = 1;\n        }\n        if (newRate >= oldRate) {\n            result = oldExchange;\n        } else {\n            result = newExchange;\n        }\n        LOG.debug(\"Get the lower rate exchange \" + result);\n        // Set the property for the completeness condition\n        result.setProperty(\"aggregated\", old + 1);\n        return result;\n\n    }","id":67371,"modified_method":"public Exchange aggregate(Exchange oldExchange, Exchange newExchange) {\n        LOG.debug(\"Get the exchange to aggregate, older: \" + oldExchange + \" newer:\" + newExchange);\n        Integer old = oldExchange.getProperty(\"aggregated\", Integer.class);\n        Double oldRate = oldExchange.getIn().getHeader(Constants.PROPERTY_RATE, Double.class);\n        Double newRate = newExchange.getIn().getHeader(Constants.PROPERTY_RATE, Double.class);\n        Exchange result = null;\n        if (old == null) {\n            old = 1;\n        }\n        if (newRate >= oldRate) {\n            result = oldExchange;\n        } else {\n            result = newExchange;\n        }\n        LOG.debug(\"Get the lower rate exchange \" + result);\n        // Set the property for the completeness condition\n        result.setProperty(\"aggregated\", old + 1);\n        return result;\n\n    }","commit_id":"872947062d9c16bfafb8160eb08858447909dc07","url":"https://github.com/apache/camel"},{"original_method":"public static void main(String args[]) throws Exception {\n        CamelContext context = new DefaultCamelContext();\n        // Set up the ActiveMQ JMS Components\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\n        // Note we can explicit name of the component\n        context.addComponent(\"test-jms\", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));\n\n        context.addRoutes(new Client());\n\n        ProducerTemplate template = context.createProducerTemplate();\n\n        context.start();\n        // START SNIPPET: sending\n        // send out the request message\n        for (int i = 0; i < 2; i++) {\n            template.sendBodyAndHeader(\"test-jms:queue:loanRequestQueue\",\n                                       \"Quote for the lowerst rate of loaning bank\",\n                                       Constants.PROPERTY_SSN, \"Client\" + i);\n            Thread.sleep(100);\n        }\n        // END SNIPPET: sending\n\n        // Start the loan broker\n        Thread.sleep(1000 * 5);\n        context.stop();\n\n    }","id":67372,"modified_method":"public static void main(String args[]) throws Exception {\n        CamelContext context = new DefaultCamelContext();\n        // Set up the ActiveMQ JMS Components\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\n        // Note we can explicit name of the component\n        context.addComponent(\"jms\", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));\n\n        context.addRoutes(new Client());\n\n        ProducerTemplate template = context.createProducerTemplate();\n\n        context.start();\n        // START SNIPPET: sending\n        // send out the request message\n        for (int i = 0; i < 2; i++) {\n            template.sendBodyAndHeader(\"jms:queue:loanRequestQueue\",\n                                       \"Quote for the lowerst rate of loaning bank\",\n                                       Constants.PROPERTY_SSN, \"Client\" + i);\n            Thread.sleep(100);\n        }\n        // END SNIPPET: sending\n\n        // Start the loan broker\n        Thread.sleep(1000 * 5);\n        context.stop();\n\n    }","commit_id":"872947062d9c16bfafb8160eb08858447909dc07","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Lets configure the Camel routing rules using Java code to pull the response message\n     */\n    public void configure() {\n        // START SNIPPET: pulling\n        from(\"test-jms:queue:loanReplyQueue\").process(new Processor() {\n\n            public void process(Exchange exchange) throws Exception {\n                // Print out the response message\n                System.out.println(exchange.getIn().getBody());\n\n            }\n\n        });\n        // END SNIPPET: pulling\n    }","id":67373,"modified_method":"/**\n     * Lets configure the Camel routing rules using Java code to pull the response message\n     */\n    public void configure() {\n        // START SNIPPET: pulling\n        from(\"jms:queue:loanReplyQueue\").process(new Processor() {\n\n            public void process(Exchange exchange) throws Exception {\n                // Print out the response message\n                System.out.println(exchange.getIn().getBody());\n\n            }\n\n        });\n        // END SNIPPET: pulling\n    }","commit_id":"872947062d9c16bfafb8160eb08858447909dc07","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n        LOG.info(\"Receiving credit agency request\");\n        String ssn = (String)exchange.getIn().getHeader(Constants.PROPERTY_SSN);\n        int score = (int) (Math.random() * 600 + 300);\n        int hlength = (int) (Math.random() * 19 + 1);\n        exchange.getOut().setHeader(Constants.PROPERTY_SCORE, new Integer(score));\n        exchange.getOut().setHeader(Constants.PROPERTY_HISTORYLENGTH, new Integer(hlength));\n        exchange.getOut().setHeader(Constants.PROPERTY_SSN, ssn);\n    }","id":67374,"modified_method":"public void process(Exchange exchange) throws Exception {\n        LOG.info(\"Receiving credit agency request\");\n        String ssn = exchange.getIn().getHeader(Constants.PROPERTY_SSN, String.class);\n        int score = (int) (Math.random() * 600 + 300);\n        int hlength = (int) (Math.random() * 19 + 1);\n        exchange.getOut().setHeader(Constants.PROPERTY_SCORE, new Integer(score));\n        exchange.getOut().setHeader(Constants.PROPERTY_HISTORYLENGTH, new Integer(hlength));\n        exchange.getOut().setHeader(Constants.PROPERTY_SSN, ssn);\n    }","commit_id":"872947062d9c16bfafb8160eb08858447909dc07","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * Lets configure the Camel routing rules using Java code...\n     */\n    public void configure() {\n    // START SNIPPET: dsl\n        // Put the message from loanRequestQueue to the creditRequestQueue\n        from(\"test-jms:queue:loanRequestQueue\").to(\"test-jms:queue:creditRequestQueue\");\n\n        // Now we can let the CreditAgency process the request, then the message will be put into creditResponseQueue\n        from(\"test-jms:queue:creditRequestQueue\").process(new CreditAgency()).to(\"test-jms:queue:creditResponseQueue\");\n\n        // Here we use the multicast pattern to send the message to three different bank queue\n        from(\"test-jms:queue:creditResponseQueue\").multicast().to(\"test-jms:queue:bank1\", \"test-jms:queue:bank2\", \"test-jms:queue:bank3\");\n\n        // Each bank processor will process the message and put the response message into the bankReplyQueue\n        from(\"test-jms:queue:bank1\").process(new Bank(\"bank1\")).to(\"test-jms:queue:bankReplyQueue\");\n        from(\"test-jms:queue:bank2\").process(new Bank(\"bank2\")).to(\"test-jms:queue:bankReplyQueue\");\n        from(\"test-jms:queue:bank3\").process(new Bank(\"bank3\")).to(\"test-jms:queue:bankReplyQueue\");\n\n        // Now we aggregating the response message by using the Constants.PROPERTY_SSN header\n        // The aggregation will completed when all the three bank responses are received\n        from(\"test-jms:queue:bankReplyQueue\")\n            .aggregator(header(Constants.PROPERTY_SSN), new BankResponseAggregationStrategy())\n            .completedPredicate(header(\"aggregated\").isEqualTo(3))\n\n        // Here we do some translation and put the message back to loanReplyQueue\n            .process(new Translator()).to(\"test-jms:queue:loanReplyQueue\");\n\n    // END SNIPPET: dsl\n    }","id":67375,"modified_method":"/**\n     * Lets configure the Camel routing rules using Java code...\n     */\n    public void configure() {\n    // START SNIPPET: dsl\n        // Put the message from loanRequestQueue to the creditRequestQueue\n        from(\"jms:queue:loanRequestQueue\").to(\"jms:queue:creditRequestQueue\");\n\n        // Now we can let the CreditAgency process the request, then the message will be put into creditResponseQueue\n        from(\"jms:queue:creditRequestQueue\").process(new CreditAgency()).to(\"jms:queue:creditResponseQueue\");\n\n        // Here we use the multicast pattern to send the message to three different bank queue\n        from(\"jms:queue:creditResponseQueue\").multicast().to(\"jms:queue:bank1\", \"jms:queue:bank2\", \"jms:queue:bank3\");\n\n        // Each bank processor will process the message and put the response message into the bankReplyQueue\n        from(\"jms:queue:bank1\").process(new Bank(\"bank1\")).to(\"jms:queue:bankReplyQueue\");\n        from(\"jms:queue:bank2\").process(new Bank(\"bank2\")).to(\"jms:queue:bankReplyQueue\");\n        from(\"jms:queue:bank3\").process(new Bank(\"bank3\")).to(\"jms:queue:bankReplyQueue\");\n\n        // Now we aggregating the response message by using the Constants.PROPERTY_SSN header\n        // The aggregation will completed when all the three bank responses are received\n        from(\"jms:queue:bankReplyQueue\")\n            .aggregator(header(Constants.PROPERTY_SSN), new BankResponseAggregationStrategy())\n            .completedPredicate(header(\"aggregated\").isEqualTo(3))\n\n        // Here we do some translation and put the message back to loanReplyQueue\n            .process(new Translator()).to(\"jms:queue:loanReplyQueue\");\n\n    // END SNIPPET: dsl\n    }","commit_id":"872947062d9c16bfafb8160eb08858447909dc07","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * A main() so we can easily run these routing rules in our IDE\n     * @throws Exception\n     */\n    // START SNIPPET: starting\n    public static void main(String... args) throws Exception {\n\n        CamelContext context = new DefaultCamelContext();\n        JmsBroker broker = new JmsBroker();\n        broker.start();\n        // Set up the ActiveMQ JMS Components\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\n\n        // Note we can explicitly name the component\n        context.addComponent(\"test-jms\", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));\n\n        context.addRoutes(new LoanBroker());\n        // Start the loan broker\n        context.start();\n        System.out.println(\"Server is ready\");\n\n        Thread.sleep(5 * 60 * 1000);\n        context.stop();\n        Thread.sleep(1000);\n        broker.stop();\n\n    }","id":67376,"modified_method":"/**\n     * A main() so we can easily run these routing rules in our IDE\n     * @throws Exception\n     */\n    // START SNIPPET: starting\n    public static void main(String... args) throws Exception {\n\n        CamelContext context = new DefaultCamelContext();\n        JmsBroker broker = new JmsBroker();\n        broker.start();\n        // Set up the ActiveMQ JMS Components\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"tcp://localhost:61616\");\n\n        // Note we can explicitly name the component\n        context.addComponent(\"jms\", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));\n\n        context.addRoutes(new LoanBroker());\n        // Start the loan broker\n        context.start();\n        System.out.println(\"Server is ready\");\n\n        Thread.sleep(5 * 60 * 1000);\n        context.stop();\n        Thread.sleep(1000);\n        broker.stop();\n\n    }","commit_id":"872947062d9c16bfafb8160eb08858447909dc07","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void startLoanBroker() throws Exception {\n        AbstractApplicationContext applicationContext = \n            new ClassPathXmlApplicationContext(new String[]{\"/META-INF/spring/queueCamelContext.xml\"});\n        CamelContext camelContext = (CamelContext)applicationContext.getBean(\"myCamel\");\n        assertNotNull(\"The camel context should not be null\", camelContext);\n        Thread.sleep(2000);        \n        camelContext.stop();\n        applicationContext.stop();        \n    }","id":67377,"modified_method":"@Test\n    public void startLoanBroker() throws Exception {\n        deleteDirectory(\"activemq-data\");\n\n        AbstractApplicationContext applicationContext =\n            new ClassPathXmlApplicationContext(new String[]{\"/META-INF/spring/queueCamelContext.xml\"});\n\n        CamelContext camelContext = (CamelContext)applicationContext.getBean(\"myCamel\");\n        assertNotNull(\"The camel context should not be null\", camelContext);\n\n        Thread.sleep(2000);\n        camelContext.stop();\n        applicationContext.stop();        \n    }","commit_id":"dc6075327ba94c60198cd807f0de0e3028873ae9","url":"https://github.com/apache/camel"},{"original_method":"@Before\n    public void startServices() throws Exception {\n        camelContext = new DefaultCamelContext();\n        broker = new JmsBroker(\"vm://localhost\");\n        broker.start();\n        // Set up the ActiveMQ JMS Components\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"vm://localhost\");\n\n        // Note we can explicitly name the component\n        camelContext.addComponent(\"jms\", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));\n\n        camelContext.addRoutes(new LoanBroker());\n        \n        camelContext.addRoutes(new RouteBuilder() {\n            // using the mock endpoint to check the result\n            public void configure() throws Exception {\n                from(\"jms:queue:loanReplyQueue\").to(\"mock:endpoint\");\n            }\n        });\n       \n        template = camelContext.createProducerTemplate();\n        camelContext.start();\n    }","id":67378,"modified_method":"@Before\n    public void startServices() throws Exception {\n        deleteDirectory(\"activemq-data\");\n\n        camelContext = new DefaultCamelContext();\n        broker = new JmsBroker(\"vm://localhost\");\n        broker.start();\n        // Set up the ActiveMQ JMS Components\n        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(\"vm://localhost\");\n\n        // Note we can explicitly name the component\n        camelContext.addComponent(\"jms\", JmsComponent.jmsComponentAutoAcknowledge(connectionFactory));\n\n        camelContext.addRoutes(new LoanBroker());\n        \n        camelContext.addRoutes(new RouteBuilder() {\n            // using the mock endpoint to check the result\n            public void configure() throws Exception {\n                from(\"jms:queue:loanReplyQueue\").to(\"mock:endpoint\");\n            }\n        });\n       \n        template = camelContext.createProducerTemplate();\n        camelContext.start();\n    }","commit_id":"dc6075327ba94c60198cd807f0de0e3028873ae9","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testClientInvocation() throws Exception {\n        MockEndpoint endpoint = (MockEndpoint) camelContext.getEndpoint(\"mock:endpoint\");\n        endpoint.expectedMessageCount(2);\n        // send out the request message\n        for (int i = 0; i < 2; i++) {\n            template.sendBodyAndHeader(\"jms:queue:loanRequestQueue\",\n                                       \"Quote for the lowerst rate of loaning bank\",\n                                       Constants.PROPERTY_SSN, \"Client-A\" + i);\n            Thread.sleep(100);\n        }\n        endpoint.assertIsSatisfied();\n        // check the response from the mock endpoint\n        List<Exchange> exchanges = endpoint.getExchanges();\n        int index = 0;\n        for (Exchange exchange : exchanges) {\n            String ssn = \"Client-A\" + index;\n            String result = exchange.getIn().getBody(String.class);\n            assertNotNull(\"The result should not be null\", result);\n            assertTrue(\"The result is wrong\", result.startsWith(\"Loan quotion for Client \" + ssn));\n            index++;\n        }\n        \n        // send the request and get the response from the same queue       \n        Exchange exchange = template.send(\"jms:queue2:parallelLoanRequestQueue\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.setPattern(ExchangePattern.InOut);\n                exchange.getIn().setBody(\"Quote for the lowerst rate of loaning bank\");\n                exchange.getIn().setHeader(Constants.PROPERTY_SSN, \"Client-B\");\n            }\n        });\n        \n        String bank = (String)exchange.getOut().getHeader(Constants.PROPERTY_BANK);\n        Double rate = (Double)exchange.getOut().getHeader(Constants.PROPERTY_RATE);\n        String ssn = (String)exchange.getOut().getHeader(Constants.PROPERTY_SSN);\n        \n        assertNotNull(\"The ssn should not be null.\", ssn);\n        assertEquals(\"Get a wrong ssn\", \"Client-B\",  ssn);\n        assertNotNull(\"The bank should not be null\", bank);\n        assertNotNull(\"The rate should not be null\", rate);\n        \n    }","id":67379,"modified_method":"@Test\n    public void testClientInvocation() throws Exception {\n        MockEndpoint endpoint = (MockEndpoint) camelContext.getEndpoint(\"mock:endpoint\");\n        endpoint.expectedMessageCount(2);\n        // send out the request message\n        for (int i = 0; i < 2; i++) {\n            template.sendBodyAndHeader(\"jms:queue:loanRequestQueue\",\n                                       \"Quote for the lowerst rate of loaning bank\",\n                                       Constants.PROPERTY_SSN, \"Client-A\" + i);\n            Thread.sleep(100);\n        }\n        endpoint.assertIsSatisfied();\n\n        // check the response from the mock endpoint\n        List<Exchange> exchanges = endpoint.getExchanges();\n        int index = 0;\n        for (Exchange exchange : exchanges) {\n            String ssn = \"Client-A\" + index;\n            String result = exchange.getIn().getBody(String.class);\n            assertNotNull(\"The result should not be null\", result);\n            assertTrue(\"The result is wrong\", result.startsWith(\"Loan quotion for Client \" + ssn));\n            index++;\n        }\n        \n        // send the request and get the response from the same queue       \n        Exchange exchange = template.send(\"jms:queue2:parallelLoanRequestQueue\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                exchange.setPattern(ExchangePattern.InOut);\n                exchange.getIn().setBody(\"Quote for the lowerst rate of loaning bank\");\n                exchange.getIn().setHeader(Constants.PROPERTY_SSN, \"Client-B\");\n            }\n        });\n        \n        String bank = exchange.getOut().getHeader(Constants.PROPERTY_BANK, String.class);\n        Double rate = exchange.getOut().getHeader(Constants.PROPERTY_RATE, Double.class);\n        String ssn = exchange.getOut().getHeader(Constants.PROPERTY_SSN, String.class);\n        \n        assertNotNull(\"The ssn should not be null.\", ssn);\n        assertEquals(\"Get a wrong ssn\", \"Client-B\",  ssn);\n        assertNotNull(\"The bank should not be null\", bank);\n        assertNotNull(\"The rate should not be null\", rate);\n    }","commit_id":"dc6075327ba94c60198cd807f0de0e3028873ae9","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        config.parseURI(new URI(uri));\n        \n        CacheEndpoint cacheEndpoint = new CacheEndpoint(uri, this, config);\n        setProperties(cacheEndpoint.getConfig(), parameters);\n        return cacheEndpoint;\n    }","id":67380,"modified_method":"@Override\n    @SuppressWarnings(\"unchecked\")\n    protected Endpoint createEndpoint(String uri, String remaining, Map parameters) throws Exception {\n        config.parseURI(new URI(uri));\n        \n        CacheEndpoint cacheEndpoint = new CacheEndpoint(uri, this, config, cacheManagerFactory);\n        setProperties(cacheEndpoint.getConfig(), parameters);\n        return cacheEndpoint;\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"protected void createConsumerCacheConnection() {\n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n        CacheEventListener cacheEventListener = new CacheEventListenerFactory().createCacheEventListener(null);\n        cacheEventListener.setCacheConsumer(this);\n\n        if (cacheManager.cacheExists(config.getCacheName())) {\n            cache = cacheManager.getCache(config.getCacheName());\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n        } else {\n            cache = new Cache(config.getCacheName(), \n                    config.getMaxElementsInMemory(),\n                    config.getMemoryStoreEvictionPolicy(), \n                    config.isOverflowToDisk(), \n                    config.getDiskStorePath(), \n                    config.isEternal(), \n                    config.getTimeToLiveSeconds(), \n                    config.getTimeToIdleSeconds(), \n                    config.isDiskPersistent(), \n                    config.getDiskExpiryThreadIntervalSeconds(), \n                    null);\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n            cacheManager.addCache(cache);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Added a new cache: \" + cache.getName());\n            }\n        }\n    }","id":67381,"modified_method":"protected void createConsumerCacheConnection() {\n        cacheManager = getEndpoint().getCacheManagerFactory().instantiateCacheManager();\n        CacheEventListener cacheEventListener = new CacheEventListenerFactory().createCacheEventListener(null);\n        cacheEventListener.setCacheConsumer(this);\n\n        if (cacheManager.cacheExists(config.getCacheName())) {\n            cache = cacheManager.getCache(config.getCacheName());\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n        } else {\n            cache = new Cache(config.getCacheName(), \n                    config.getMaxElementsInMemory(),\n                    config.getMemoryStoreEvictionPolicy(), \n                    config.isOverflowToDisk(), \n                    config.getDiskStorePath(), \n                    config.isEternal(), \n                    config.getTimeToLiveSeconds(), \n                    config.getTimeToIdleSeconds(), \n                    config.isDiskPersistent(), \n                    config.getDiskExpiryThreadIntervalSeconds(), \n                    null);\n            cache.getCacheEventNotificationService().registerListener(cacheEventListener);\n            cacheManager.addCache(cache);\n\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Added a new cache: \" + cache.getName());\n            }\n        }\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public CacheEndpoint getEndpoint() {\n        return endpoint;\n    }","id":67382,"modified_method":"@Override\n    public CacheEndpoint getEndpoint() {\n        return (CacheEndpoint) super.getEndpoint();\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public CacheConsumer(Endpoint endpoint, Processor processor, CacheConfiguration config) {\n        super(endpoint, processor);\n        this.endpoint = (CacheEndpoint) endpoint;\n        this.config = config;\n    }","id":67383,"modified_method":"public CacheConsumer(Endpoint endpoint, Processor processor, CacheConfiguration config) {\n        super(endpoint, processor);\n        this.config = config;\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"protected void removeConsumerCacheConnection() {\n        cacheManager.removeCache(config.getCacheName());\n        if (cacheManager.getCacheNames().length == 0) {\n            cacheManager.shutdown();\n        }\n    }","id":67384,"modified_method":"protected void removeConsumerCacheConnection() {\n        cacheManager.removeCache(config.getCacheName());\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"cache://TestCache1\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String operation = (String)exchange.getIn().getHeader(\"CACHE_OPERATION\");\n                        String key = (String)exchange.getIn().getHeader(\"CACHE_KEY\");\n                        Object body = exchange.getIn().getBody();\n                        String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"------- Cache Event Notification ---------\");\n                            LOG.debug(\"Received notification for the following activity in cache TestCache1:\");\n                            LOG.debug(\"Operation = \" + operation);\n                            LOG.debug(\"key = \" + key);\n                            LOG.debug(\"value = \" + data);\n                            LOG.debug(\"------ End Cache Event Notification ------\");\n                        }\n                    }\n\n                }).to(\"mock:result\");\n\n                from(\"direct:start\").to(\"cache://TestCache1\");\n            }\n        };\n    }","id":67385,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            public void configure() {\n                from(\"cache://TestCache1\").process(new Processor() {\n                    public void process(Exchange exchange) throws Exception {\n                        String operation = (String) exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION);\n                        String key = (String) exchange.getIn().getHeader(CacheConstants.CACHE_KEY);\n                        Object body = exchange.getIn().getBody();\n                        String data = exchange.getContext().getTypeConverter().convertTo(String.class, body);\n\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"------- Cache Event Notification ---------\");\n                            LOG.debug(\"Received notification for the following activity in cache TestCache1:\");\n                            LOG.debug(\"Operation = \" + operation);\n                            LOG.debug(\"key = \" + key);\n                            LOG.debug(\"value = \" + data);\n                            LOG.debug(\"------ End Cache Event Notification ------\");\n                        }\n                    }\n\n                }).to(\"mock:result\");\n\n                from(\"direct:start\").to(\"cache://TestCache1\");\n            }\n        };\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testReceivingSerializedObjectFromCache() throws Exception {\n        LOG.debug(\"Beginning Test ---> testReceivingSerializedObjectFromCache()\");\n\n        resultEndpoint.expectedMessageCount(3);\n\n        List<String> operations = new ArrayList<String>();\n        operations.add(\"ADD\");\n        operations.add(\"UPDATE\");\n        operations.add(\"DELETE\");\n        for (final String operation : operations) {\n            producerTemplate.send(new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    Poetry p = new Poetry();\n                    p.setPoet(\"Ralph Waldo Emerson\");\n                    p.setPoem(\"Brahma\");\n                    \n                    exchange.setProperty(Exchange.CHARSET_NAME, \"UTF-8\");\n                    Message in = exchange.getIn();\n                    in.setHeader(\"CACHE_OPERATION\", operation);\n                    in.setHeader(\"CACHE_KEY\", \"poetry\");\n                    in.setBody(p);\n                }\n            });\n        }\n\n        resultEndpoint.assertIsSatisfied();\n        LOG.debug(\"Completed Test ---> testReceivingFileFromCache()\");\n    }","id":67386,"modified_method":"@Test\n    public void testReceivingSerializedObjectFromCache() throws Exception {\n        LOG.debug(\"Beginning Test ---> testReceivingSerializedObjectFromCache()\");\n\n        resultEndpoint.expectedMessageCount(3);\n\n        List<String> operations = new ArrayList<String>();\n        operations.add(CacheConstants.CACHE_OPERATION_ADD);\n        operations.add(CacheConstants.CACHE_OPERATION_UPDATE);\n        operations.add(CacheConstants.CACHE_OPERATION_DELETE);\n        for (final String operation : operations) {\n            producerTemplate.send(new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    Poetry p = new Poetry();\n                    p.setPoet(\"Ralph Waldo Emerson\");\n                    p.setPoem(\"Brahma\");\n\n                    exchange.setProperty(Exchange.CHARSET_NAME, \"UTF-8\");\n                    Message in = exchange.getIn();\n                    in.setHeader(CacheConstants.CACHE_OPERATION, operation);\n                    in.setHeader(CacheConstants.CACHE_KEY, \"poetry\");\n                    in.setBody(p);\n                }\n            });\n        }\n\n        resultEndpoint.assertIsSatisfied();\n        LOG.debug(\"Completed Test ---> testReceivingFileFromCache()\");\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testReceivingFileFromCache() throws Exception {\n        LOG.debug(\"Beginning Test ---> testReceivingFileFromCache()\");\n\n        resultEndpoint.expectedMessageCount(3);\n\n        List<String> operations = new ArrayList<String>();\n        operations.add(\"ADD\");\n        operations.add(\"UPDATE\");\n        operations.add(\"DELETE\");\n        for (final String operation : operations) {\n            producerTemplate.send(new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.setProperty(Exchange.CHARSET_NAME, \"UTF-8\");\n                    Message in = exchange.getIn();\n                    in.setHeader(\"CACHE_OPERATION\", operation);\n                    in.setHeader(\"CACHE_KEY\", \"greeting\");\n                    in.setBody(\"Hello World\");\n                }\n            });\n        }\n\n        resultEndpoint.assertIsSatisfied();\n        LOG.debug(\"Completed Test ---> testReceivingFileFromCache()\");\n    }","id":67387,"modified_method":"@Test\n    public void testReceivingFileFromCache() throws Exception {\n        LOG.debug(\"Beginning Test ---> testReceivingFileFromCache()\");\n\n        resultEndpoint.expectedMessageCount(3);\n\n        List<String> operations = new ArrayList<String>();\n        operations.add(CacheConstants.CACHE_OPERATION_ADD);\n        operations.add(CacheConstants.CACHE_OPERATION_UPDATE);\n        operations.add(CacheConstants.CACHE_OPERATION_DELETE);\n        for (final String operation : operations) {\n            producerTemplate.send(new Processor() {\n                public void process(Exchange exchange) throws Exception {\n                    exchange.setProperty(Exchange.CHARSET_NAME, \"UTF-8\");\n                    Message in = exchange.getIn();\n                    in.setHeader(CacheConstants.CACHE_OPERATION, operation);\n                    in.setHeader(CacheConstants.CACHE_KEY, \"greeting\");\n                    in.setBody(\"Hello World\");\n                }\n            });\n        }\n\n        resultEndpoint.assertIsSatisfied();\n        LOG.debug(\"Completed Test ---> testReceivingFileFromCache()\");\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public boolean isSingleton() {\n        return false;\n    }","id":67388,"modified_method":"public boolean isSingleton() {\n        return true;\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public CacheEndpoint(String endpointUri, Component component, CacheConfiguration config) {\n        super(endpointUri, component);\n        this.config = config;\n    }","id":67389,"modified_method":"public CacheEndpoint(String endpointUri, Component component, CacheConfiguration config,\n                         CacheManagerFactory cacheManagerFactory) {\n        super(endpointUri, component);\n        this.config = config;\n        this.cacheManagerFactory = cacheManagerFactory;\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public Consumer createConsumer(Processor processor) throws Exception {\n        return new CacheConsumer(this, processor, config);\n    }","id":67390,"modified_method":"public Consumer createConsumer(Processor processor) throws Exception {\n        ObjectHelper.notNull(config, \"config\");\n        ObjectHelper.notNull(cacheManagerFactory, \"cacheManagerFactory\");\n        return new CacheConsumer(this, processor, config);\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public Producer createProducer() throws Exception {\n        return new CacheProducer(this, config);\n    }","id":67391,"modified_method":"public Producer createProducer() throws Exception {\n        ObjectHelper.notNull(config, \"config\");\n        ObjectHelper.notNull(cacheManagerFactory, \"cacheManagerFactory\");\n        return new CacheProducer(this, config);\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n         \n        cacheManager = new CacheManagerFactory().instantiateCacheManager();\n        \n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Cache Name: \" + config.getCacheName());\n        }\n        if (cacheManager.cacheExists(config.getCacheName())) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Found an existing cache: \" + config.getCacheName());\n                LOG.trace(\"Cache \" + config.getCacheName() + \" currently contains \" + cacheManager.getCache(config.getCacheName()).getSize() + \" elements\");\n            }\n            cache = cacheManager.getCache(config.getCacheName());\n        } else {\n            cache = new Cache(config.getCacheName(), \n                    config.getMaxElementsInMemory(),\n                    config.getMemoryStoreEvictionPolicy(), \n                    config.isOverflowToDisk(), \n                    config.getDiskStorePath(), \n                    config.isEternal(), \n                    config.getTimeToLiveSeconds(), \n                    config.getTimeToIdleSeconds(), \n                    config.isDiskPersistent(), \n                    config.getDiskExpiryThreadIntervalSeconds(), \n                    null);\n            cacheManager.addCache(cache);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Added a new cache: \" + cache.getName());\n            }\n        }\n       \n        \n        String key = (String) exchange.getIn().getHeader(\"CACHE_KEY\");\n        String operation = (String) exchange.getIn().getHeader(\"CACHE_OPERATION\");\n        if (operation == null) {\n            throw new CacheException(\"Operation property is not specified in the incoming exchange header.\"\n                + \"A valid Operation property must be set to ADD, UPDATE, DELETE, DELETEALL\");\n        }\n        if ((key == null) && (!operation.equalsIgnoreCase(\"DELETEALL\"))) {\n            throw new CacheException(\"Cache Key is not specified in exchange either header or URL. Unable to add objects to the cache without a Key\");\n        }\n        \n        performCacheOperation(exchange, operation, key);\n    }","id":67392,"modified_method":"public void process(Exchange exchange) throws Exception {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Cache Name: \" + config.getCacheName());\n        }\n\n        if (cacheManager.cacheExists(config.getCacheName())) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Found an existing cache: \" + config.getCacheName());\n                LOG.trace(\"Cache \" + config.getCacheName() + \" currently contains \"\n                        + cacheManager.getCache(config.getCacheName()).getSize() + \" elements\");\n            }\n            cache = cacheManager.getCache(config.getCacheName());\n        } else {\n            cache = new Cache(config.getCacheName(),\n                    config.getMaxElementsInMemory(),\n                    config.getMemoryStoreEvictionPolicy(),\n                    config.isOverflowToDisk(),\n                    config.getDiskStorePath(),\n                    config.isEternal(),\n                    config.getTimeToLiveSeconds(),\n                    config.getTimeToIdleSeconds(),\n                    config.isDiskPersistent(),\n                    config.getDiskExpiryThreadIntervalSeconds(),\n                    null);\n            cacheManager.addCache(cache);\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Added a new cache: \" + cache.getName());\n            }\n        }\n\n        String key = exchange.getIn().getHeader(CacheConstants.CACHE_KEY, String.class);\n        String operation = exchange.getIn().getHeader(CacheConstants.CACHE_OPERATION, String.class);\n\n        if (operation == null) {\n            throw new CacheException(\"Operation not specified in the message header [\" + CacheConstants.CACHE_KEY + \"]\");\n        }\n        if ((key == null) && (!operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_DELETEALL))) {\n            throw new CacheException(\"Cache Key is not specified in message header header or endpoint URL.\");\n        }\n\n        performCacheOperation(exchange, operation, key);\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public CacheProducer(Endpoint endpoint, CacheConfiguration config) throws Exception {\n        super(endpoint);\n        this.endpoint = endpoint;\n        this.config = config;\n    }","id":67393,"modified_method":"public CacheProducer(Endpoint endpoint, CacheConfiguration config) throws Exception {\n        super(endpoint);\n        this.config = config;\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"private void performCacheOperation(Exchange exchange, String operation, String key) throws Exception {\n        Object element;\n\n        Object body = exchange.getIn().getBody();\n        if (body instanceof Serializable) {\n            element = body;\n        } else {\n            InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, body);\n\n            // Read InputStream into a byte[] buffer\n            byte[] buffer = new byte[is.available()];\n            int n = is.available();\n            for (int j = 0; j < n; j++) {\n                buffer[j] = (byte)is.read();\n            }\n\n            element = buffer;\n        }\n\n        if (operation.equalsIgnoreCase(\"ADD\")) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Adding an element with key \" + key + \" into the Cache\");\n            }\n            cache.put(new Element(key, element), true);\n        } else if (operation.equalsIgnoreCase(\"UPDATE\")) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Updating an element with key \" + key + \" into the Cache\");\n            }\n            cache.put(new Element(key, element), true);\n        } else if (operation.equalsIgnoreCase(\"DELETEALL\")) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Deleting All elements from the Cache\");\n            }\n            cache.removeAll();\n        } else if (operation.equalsIgnoreCase(\"DELETE\")) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Deleting an element with key \" + key + \" into the Cache\");\n            }\n            cache.remove(key, true);\n        }\n    }","id":67394,"modified_method":"private void performCacheOperation(Exchange exchange, String operation, String key) throws Exception {\n        Object element;\n\n        Object body = exchange.getIn().getBody();\n        if (body instanceof Serializable) {\n            element = body;\n        } else {\n            InputStream is = exchange.getContext().getTypeConverter().mandatoryConvertTo(InputStream.class, body);\n            // Read InputStream into a byte[] buffer\n            element = exchange.getContext().getTypeConverter().mandatoryConvertTo(byte[].class, is);\n        }\n\n        if (operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_ADD)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Adding an element with key \" + key + \" into the Cache\");\n            }\n            cache.put(new Element(key, element), true);\n        } else if (operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_UPDATE)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Updating an element with key \" + key + \" into the Cache\");\n            }\n            cache.put(new Element(key, element), true);\n        } else if (operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_DELETEALL)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Deleting All elements from the Cache\");\n            }\n            cache.removeAll();\n        } else if (operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_DELETE)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Deleting an element with key \" + key + \" into the Cache\");\n            }\n            cache.remove(key, true);\n        } else if (operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_GET)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Quering an element with key \" + key + \" from the Cache\");\n            }\n            if (cache.isKeyInCache(key)) {\n                exchange.getIn().setHeader(CacheConstants.CACHE_ELEMENT_WAS_FOUND, true);\n                exchange.getIn().setBody(cache.get(key).getValue());\n            } else {\n                exchange.getIn().removeHeader(CacheConstants.CACHE_ELEMENT_WAS_FOUND);\n            }\n        } else if (operation.equalsIgnoreCase(CacheConstants.CACHE_OPERATION_CHECK)) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Querying an element with key \" + key + \" from the Cache\");\n            }\n            if (cache.isKeyInCache(key)) {\n                exchange.getIn().setHeader(CacheConstants.CACHE_ELEMENT_WAS_FOUND, true);\n            } else {\n                exchange.getIn().removeHeader(CacheConstants.CACHE_ELEMENT_WAS_FOUND);\n            }\n        } else {\n            throw new CacheException(\"Operation \" + operation + \" is not supported.\");\n        }\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testAddingDataToCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:b\").\n                    setHeader(\"CACHE_OPERATION\", constant(\"ADD\")).\n                    setHeader(\"CACHE_KEY\", constant(\"Ralph_Waldo_Emerson\")).\n                    to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Add Test---------------\");\n        sendFile();\n    }","id":67395,"modified_method":"@Test\n    public void testAddingDataToCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:a\").\n                        setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)).\n                        setHeader(CacheConstants.CACHE_KEY, constant(\"Ralph_Waldo_Emerson\")).\n                        to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Add Test---------------\");\n        sendOriginalFile();\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testDeletingDataFromCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:c\").\n                    setHeader(\"CACHE_OPERATION\", constant(\"DELETE\")).\n                    setHeader(\"CACHE_KEY\", constant(\"Ralph_Waldo_Emerson\")).\n                    to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Delete Test---------------\");\n        sendUpdatedFile();\n    }","id":67396,"modified_method":"@Test\n    public void testDeletingDataFromCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:a\").\n                        setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETE)).\n                        setHeader(CacheConstants.CACHE_KEY, constant(\"Ralph_Waldo_Emerson\")).\n                        to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Delete Test---------------\");\n        sendUpdatedFile();\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testAddingSerializableDataToCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:b\").\n                    setHeader(\"CACHE_OPERATION\", constant(\"ADD\")).\n                    setHeader(\"CACHE_KEY\", constant(\"Ralph_Waldo_Emerson\")).\n                    to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Add Test---------------\");\n        sendFile();\n    }","id":67397,"modified_method":"@Test\n    public void testAddingSerializableDataToCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:a\").\n                        setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_ADD)).\n                        setHeader(CacheConstants.CACHE_KEY, constant(\"Ralph_Waldo_Emerson\")).\n                        to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Add Test---------------\");\n        sendOriginalFile();\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"private void sendFile() throws Exception {\n        template.send(\"direct:a\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n             // Read from an input stream\n                InputStream is = new BufferedInputStream(\n                    new FileInputStream(\"./src/test/resources/test.txt\"));\n\n                byte buffer[] = IOConverter.toBytes(is);\n                is.close();\n                \n                // Set the property of the charset encoding\n                exchange.setProperty(Exchange.CHARSET_NAME, \"UTF-8\");\n                Message in = exchange.getIn();\n                in.setBody(buffer);\n            }            \n        });\n    }","id":67398,"modified_method":"private void sendFile(final String path) throws Exception {\n        template.send(\"direct:a\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n                // Read from an input stream\n                InputStream is = new BufferedInputStream(\n                        new FileInputStream(path));    // \"./src/test/resources/test.txt\"));\n\n                byte buffer[] = IOConverter.toBytes(is);\n                is.close();\n\n                // Set the property of the charset encoding\n                exchange.setProperty(Exchange.CHARSET_NAME, \"UTF-8\");\n                Message in = exchange.getIn();\n                in.setBody(buffer);\n            }\n        });\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"private void sendUpdatedFile() throws Exception {\n        template.send(\"direct:a\", new Processor() {\n            public void process(Exchange exchange) throws Exception {\n             // Read from an input stream\n                InputStream is = new BufferedInputStream(\n                    new FileInputStream(\"./src/test/resources/updatedtest.txt\"));\n\n                byte buffer[] = IOConverter.toBytes(is);\n                is.close();\n                \n                // Set the property of the charset encoding\n                exchange.setProperty(Exchange.CHARSET_NAME, \"UTF-8\");\n                Message in = exchange.getIn();\n                in.setBody(buffer);\n            }            \n        });\n    }","id":67399,"modified_method":"private void sendUpdatedFile() throws Exception {\n        sendFile(FILEPATH_UPDATEDTEST_TXT);\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testDeletingAllDataFromCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:a\").\n                    setHeader(\"CACHE_OPERATION\", constant(\"ADD\")).\n                    setHeader(\"CACHE_KEY\", constant(\"Ralph_Waldo_Emerson\")).\n                    to(\"cache://TestCache1\");\n                from(\"direct:b\").\n                    setHeader(\"CACHE_OPERATION\", constant(\"ADD\")).\n                    setHeader(\"CACHE_KEY\", constant(\"Ralph_Waldo_Emerson2\")).\n                    to(\"cache://TestCache1\");\n                from(\"direct:c\").\n                    setHeader(\"CACHE_OPERATION\", constant(\"DELETEALL\")).\n                    to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Delete All Elements Test---------------\");\n        sendUpdatedFile();\n    }","id":67400,"modified_method":"@Test\n    public void testDeletingAllDataFromCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:a\").\n                        setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_DELETEALL)).\n                        to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Delete All Elements Test---------------\");\n        sendUpdatedFile();\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testUpdatingDataInCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:b\").\n                    setHeader(\"CACHE_OPERATION\", constant(\"UPDATE\")).\n                    setHeader(\"CACHE_KEY\", constant(\"Ralph_Waldo_Emerson\")).\n                    to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Update Test---------------\");\n        sendSerializedData();\n    }","id":67401,"modified_method":"@Test\n    public void testUpdatingDataInCache() throws Exception {\n        context.addRoutes(new RouteBuilder() {\n            public void configure() {\n                from(\"direct:a\").\n                        setHeader(CacheConstants.CACHE_OPERATION, constant(CacheConstants.CACHE_OPERATION_UPDATE)).\n                        setHeader(CacheConstants.CACHE_KEY, constant(\"Ralph_Waldo_Emerson\")).\n                        to(\"cache://TestCache1\");\n            }\n        });\n        context.start();\n        LOG.debug(\"------------Beginning CacheProducer Update Test---------------\");\n        sendSerializedData();\n    }","commit_id":"ab758230f5713708e2925cfeaa424e5fd2b8ead2","url":"https://github.com/apache/camel"},{"original_method":"public boolean isCustom() {\n        return customListener != null;\n    }","id":67402,"modified_method":"public boolean hasCustomListener() {\n        return customListener != null;\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public InfinispanEventListener start(InfinispanConsumer consumer) {\n        Cache<?, ?> embeddedCache = (Cache<?, ?>) consumer.getCache();\n        InfinispanConfiguration configuration = consumer.getConfiguration();\n        InfinispanEventListener listener;\n        if (configuration.isCustom()) {\n            listener = configuration.getCustomListener();\n            ((InfinispanCustomListener)listener).setInfinispanConsumer(consumer);\n        } else if (configuration.isClustered()) {\n            if (configuration.isSync()) {\n                listener = new InfinispanSyncClusteredEventListener(consumer, configuration.getEventTypes());\n            } else {\n                listener = new InfinispanAsyncClusteredEventListener(consumer, configuration.getEventTypes());\n            }\n        } else {\n            if (configuration.isSync()) {\n                listener = new InfinispanSyncLocalEventListener(consumer, configuration.getEventTypes());\n            } else {\n                listener = new InfinispanAsyncLocalEventListener(consumer, configuration.getEventTypes());\n            }\n        }\n        embeddedCache.addListener(listener);\n        return listener;\n    }","id":67403,"modified_method":"@Override\n    public InfinispanEventListener start(InfinispanConsumer consumer) {\n        Cache<?, ?> embeddedCache = (Cache<?, ?>) consumer.getCache();\n        InfinispanConfiguration configuration = consumer.getConfiguration();\n        InfinispanEventListener listener;\n        if (configuration.hasCustomListener()) {\n            listener = configuration.getCustomListener();\n            ((InfinispanCustomListener)listener).setInfinispanConsumer(consumer);\n        } else if (configuration.isClustered()) {\n            if (configuration.isSync()) {\n                listener = new InfinispanSyncClusteredEventListener(consumer, configuration.getEventTypes());\n            } else {\n                listener = new InfinispanAsyncClusteredEventListener(consumer, configuration.getEventTypes());\n            }\n        } else {\n            if (configuration.isSync()) {\n                listener = new InfinispanSyncLocalEventListener(consumer, configuration.getEventTypes());\n            } else {\n                listener = new InfinispanAsyncLocalEventListener(consumer, configuration.getEventTypes());\n            }\n        }\n        embeddedCache.addListener(listener);\n        return listener;\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    public InfinispanEventListener start(InfinispanConsumer consumer) {\n        if (consumer.getConfiguration().isSync()) {\n            throw new UnsupportedOperationException(\"Sync listeners not supported for remote caches.\");\n        }\n        RemoteCache<?, ?> remoteCache = (RemoteCache<?, ?>) consumer.getCache();\n        InfinispanConfiguration configuration = consumer.getConfiguration();\n        InfinispanEventListener listener;\n        if (configuration.isCustom()) {\n            listener = configuration.getCustomListener();\n            ((InfinispanCustomListener)listener).setInfinispanConsumer(consumer);\n        } else {\n            listener = new InfinispanRemoteEventListener(consumer, configuration.getEventTypes());\n        }\n        remoteCache.addClientListener(listener);\n        listener.setCacheName(remoteCache.getName());\n        return listener;\n\n    }","id":67404,"modified_method":"@Override\n    public InfinispanEventListener start(InfinispanConsumer consumer) {\n        if (consumer.getConfiguration().isSync()) {\n            throw new UnsupportedOperationException(\"Sync listeners not supported for remote caches.\");\n        }\n        RemoteCache<?, ?> remoteCache = InfinispanUtil.asRemote(consumer.getCache());\n        InfinispanConfiguration configuration = consumer.getConfiguration();\n        InfinispanEventListener listener;\n        if (configuration.hasCustomListener()) {\n            listener = configuration.getCustomListener();\n            listener.setInfinispanConsumer(consumer);\n        } else {\n            listener = new InfinispanRemoteEventListener(consumer, configuration.getEventTypes());\n        }\n        remoteCache.addClientListener(listener);\n        listener.setCacheName(remoteCache.getName());\n        return listener;\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"public static void process(Exchange exchange, InfinispanConfiguration configuration, BasicCache<Object, Object> cache) {\n        Operation operation = getOperation(exchange, configuration);\n        operation.execute(cache, exchange);\n    }","id":67405,"modified_method":"public static void process(Exchange exchange, InfinispanConfiguration configuration, BasicCache<Object, Object> cache) {\n        Operation operation = getOperation(exchange, configuration);\n        operation.execute(configuration, cache, exchange);\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"private static Operation getOperation(Exchange exchange, InfinispanConfiguration configuration) {\n        String operation = exchange.getIn().getHeader(InfinispanConstants.OPERATION, String.class);\n        if (operation == null) {\n            if (configuration.getCommand() != null) {\n                operation = InfinispanConstants.OPERATION + configuration.getCommand();\n            } else {\n                operation = InfinispanConstants.PUT;\n            }\n        }\n        LOGGER.trace(\"Operation: [{}]\", operation);\n        return Operation.valueOf(operation.substring(InfinispanConstants.OPERATION.length()).toUpperCase());\n    }","id":67406,"modified_method":"private static Operation getOperation(Exchange exchange, InfinispanConfiguration configuration) {\n        String operation = exchange.getIn().getHeader(InfinispanConstants.OPERATION, String.class);\n        if (operation == null) {\n            if (configuration.hasCommand()) {\n                operation = InfinispanConstants.OPERATION + configuration.getCommand();\n            } else {\n                operation = InfinispanConstants.PUT;\n            }\n        }\n        LOGGER.trace(\"Operation: [{}]\", operation);\n        return Operation.valueOf(operation.substring(InfinispanConstants.OPERATION.length()).toUpperCase());\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"public static Query buildQuery(BasicCache<Object, Object> cache, Exchange exchange) {\n        InfinispanQueryBuilder queryBuilder = (InfinispanQueryBuilder) exchange\n                .getIn().getHeader(InfinispanConstants.QUERY_BUILDER);\n        if (queryBuilder == null) {\n            return null;\n        }\n        RemoteCache<Object, Object> remoteCache = (RemoteCache<Object, Object>) cache;\n        return queryBuilder.build(Search.getQueryFactory(remoteCache));\n    }","id":67407,"modified_method":"public static Query buildQuery(InfinispanConfiguration configuration, BasicCache<Object, Object> cache, Exchange exchange) {\n        InfinispanQueryBuilder queryBuilder = exchange.getIn().getHeader(InfinispanConstants.QUERY_BUILDER, InfinispanQueryBuilder.class);\n        if (queryBuilder == null) {\n            queryBuilder = configuration.getQueryBuilder();\n        }\n\n        return buildQuery(queryBuilder, cache);\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void producerQueryWithoutResult() throws Exception {\n        Exchange request = template.request(\"direct:start\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(OPERATION, QUERY);\n                exchange.getIn().setHeader(QUERY_BUILDER,\n                        new InfinispanQueryBuilder() {\n                            public Query build(QueryFactory<Query> queryFactory) {\n                                return queryFactory.from(User.class)\n                                        .having(\"name\").like(\"%abc%\")\n                                        .toBuilder().build();\n                            }\n                        });\n            }\n        });\n        assertNull(request.getException());\n\n        @SuppressWarnings(\"unchecked\")\n        List<User> queryResult = (List<User>) request.getIn().getHeader(RESULT);\n        assertNotNull(queryResult);\n        assertEquals(0, queryResult.size());\n    }","id":67408,"modified_method":"@Test\n    public void producerQueryWithoutResult() throws Exception {\n        producerQueryWithoutResult(\"direct:start\", NO_RESULT_QUERY_BUILDER);\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected void doPostSetup() throws Exception {\n        /* Preload data. */\n        for (final User user : USERS) {\n            Exchange request = template.request(\"direct:start\",\n                    new Processor() {\n                        @Override\n                        public void process(Exchange exchange) throws Exception {\n                            Message in = exchange.getIn();\n                            in.setHeader(KEY, createKey(user));\n                            in.setHeader(VALUE, user);\n                        }\n                    });\n            assertNull(request.getException());\n        }\n    }","id":67409,"modified_method":"@Override\n    protected void doPostSetup() throws Exception {\n        // pre-load data\n        RemoteCache<Object, Object> cache = manager.getCache(\"remote_query\");\n        assertNotNull(cache);\n\n        cache.clear();\n        assertTrue(cache.isEmpty());\n\n        for (final User user : USERS) {\n            String key = createKey(user);\n            cache.put(key, user);\n\n            assertTrue(cache.containsKey(key));\n        }\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected JndiRegistry createRegistry() throws Exception {\n        JndiRegistry registry = super.createRegistry();\n        registry.bind(\"myCustomContainer\", manager);\n        return registry;\n    }","id":67410,"modified_method":"@Override\n    protected JndiRegistry createRegistry() throws Exception {\n        JndiRegistry registry = super.createRegistry();\n        registry.bind(\"myCustomContainer\", manager);\n        registry.bind(\"noResultQueryBuilder\", NO_RESULT_QUERY_BUILDER);\n        registry.bind(\"withResultQueryBuilder\", WITH_RESULT_QUERY_BUILDER);\n\n        return registry;\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void producerQueryWithResult() throws Exception {\n        Exchange request = template.request(\"direct:start\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                Message in = exchange.getIn();\n                in.setHeader(OPERATION, QUERY);\n                in.setHeader(QUERY_BUILDER, new InfinispanQueryBuilder() {\n                    public Query build(QueryFactory<Query> queryFactory) {\n                        return queryFactory.from(User.class).having(\"name\")\n                                .like(\"%A\").toBuilder().build();\n                    }\n                });\n            }\n        });\n        assertNull(request.getException());\n\n        @SuppressWarnings(\"unchecked\")\n        List<User> queryResult = (List<User>) request.getIn().getHeader(RESULT);\n        assertNotNull(queryResult);\n        assertEquals(2, queryResult.size());\n        assertTrue(hasUser(queryResult, \"nameA\", \"surnameA\"));\n        assertTrue(hasUser(queryResult, \"nameA\", \"surnameB\"));\n    }","id":67411,"modified_method":"@Test\n    public void producerQueryWithResult() throws Exception {\n        producerQueryWithResult(\"direct:start\", WITH_RESULT_QUERY_BUILDER);\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void producerQueryOperationWithoutQueryBuilder() throws Exception {\n        Exchange request = template.request(\"direct:start\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(OPERATION, QUERY);\n            }\n        });\n        assertNull(request.getException());\n\n        @SuppressWarnings(\"unchecked\")\n        List<User> queryResult = (List<User>) request.getIn().getHeader(RESULT);\n        assertNull(queryResult);\n    }","id":67412,"modified_method":"@Test\n    public void producerQueryOperationWithoutQueryBuilder() throws Exception {\n        Exchange request = template.request(\"direct:start\", new Processor() {\n            @Override\n            public void process(Exchange exchange) throws Exception {\n                exchange.getIn().setHeader(OPERATION, QUERY);\n            }\n        });\n        assertNull(request.getException());\n\n        List<User> queryResult = request.getIn().getHeader(RESULT, List.class);\n        assertNull(queryResult);\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() {\n                from(\"direct:start\").to(\n                        \"infinispan://?cacheContainer=#myCustomContainer&cacheName=remote_query\");\n            }\n        };\n    }","id":67413,"modified_method":"@Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() {\n                from(\"direct:start\")\n                    .to(\"infinispan://?cacheContainer=#myCustomContainer&cacheName=remote_query\");\n                from(\"direct:noQueryResults\")\n                    .to(\"infinispan://?cacheContainer=#myCustomContainer&cacheName=remote_query&queryBuilder=#noResultQueryBuilder\");\n                from(\"direct:queryWithResults\")\n                    .to(\"infinispan://?cacheContainer=#myCustomContainer&cacheName=remote_query&queryBuilder=#withResultQueryBuilder\");\n            }\n        };\n    }","commit_id":"8c415c8f36eb9c6dc72d3d00d37c7465b5b27a18","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testDeleteWithHeaders() throws Exception {\n\n        //first, INDEX a value\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_INDEX);\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_NAME, \"twitter\");\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_TYPE, \"tweet\");\n\n        String indexId = (String) template.requestBodyAndHeaders(\"direct:start\", map, headers);\n\n        //now, verify GET\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_GET_BY_ID);\n        GetResponse response = (GetResponse) template.requestBodyAndHeaders(\"direct:start\", indexId, headers);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n\n        //now, perform DELETE\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_DELETE);\n        DeleteResponse deleteResponse = (DeleteResponse) template.requestBodyAndHeaders(\"direct:start\", indexId, headers);\n        assertNotNull(\"response should not be null\", deleteResponse);\n\n        //now, verify GET fails to find the indexed value\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_GET_BY_ID);\n        response = (GetResponse) template.requestBodyAndHeaders(\"direct:start\", indexId, headers);\n        assertNotNull(\"response should not be null\", response);\n        assertNull(\"response source should be null\", response.getSource());\n    }","id":67414,"modified_method":"@Test\n    public void testDeleteWithHeaders() throws Exception {\n        //first, INDEX a value\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_INDEX);\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_NAME, \"twitter\");\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_TYPE, \"tweet\");\n\n        String indexId = template.requestBodyAndHeaders(\"direct:start\", map, headers, String.class);\n\n        //now, verify GET\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_GET_BY_ID);\n        GetResponse response = template.requestBodyAndHeaders(\"direct:start\", indexId, headers, GetResponse.class);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n\n        //now, perform DELETE\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_DELETE);\n        DeleteResponse deleteResponse = template.requestBodyAndHeaders(\"direct:start\", indexId, headers, DeleteResponse.class);\n        assertNotNull(\"response should not be null\", deleteResponse);\n\n        //now, verify GET fails to find the indexed value\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_GET_BY_ID);\n        response = template.requestBodyAndHeaders(\"direct:start\", indexId, headers, GetResponse.class);\n        assertNotNull(\"response should not be null\", response);\n        assertNull(\"response source should be null\", response.getSource());\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testGetWithHeaders() throws Exception {\n\n        //first, INDEX a value\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_INDEX);\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_NAME, \"twitter\");\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_TYPE, \"tweet\");\n\n        String indexId = (String) template.requestBodyAndHeaders(\"direct:start\", map, headers);\n\n        //now, verify GET\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_GET_BY_ID);\n        GetResponse response = (GetResponse) template.requestBodyAndHeaders(\"direct:start\", indexId, headers);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n    }","id":67415,"modified_method":"@Test\n    public void testGetWithHeaders() throws Exception {\n        //first, INDEX a value\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_INDEX);\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_NAME, \"twitter\");\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_TYPE, \"tweet\");\n\n        String indexId = template.requestBodyAndHeaders(\"direct:start\", map, headers, String.class);\n\n        //now, verify GET\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_GET_BY_ID);\n        GetResponse response = template.requestBodyAndHeaders(\"direct:start\", indexId, headers, GetResponse.class);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testIndexWithHeaders() throws Exception {\n\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_INDEX);\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_NAME, \"twitter\");\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_TYPE, \"tweet\");\n\n        String indexId = (String) template.requestBodyAndHeaders(\"direct:start\", map, headers);\n        assertNotNull(\"indexId should be set\", indexId);\n    }","id":67416,"modified_method":"@Test\n    public void testIndexWithHeaders() throws Exception {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n\n        Map<String, Object> headers = new HashMap<String, Object>();\n        headers.put(ElasticsearchConfiguration.PARAM_OPERATION, ElasticsearchConfiguration.OPERATION_INDEX);\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_NAME, \"twitter\");\n        headers.put(ElasticsearchConfiguration.PARAM_INDEX_TYPE, \"tweet\");\n\n        String indexId = template.requestBodyAndHeaders(\"direct:start\", map, headers, String.class);\n        assertNotNull(\"indexId should be set\", indexId);\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testIndex() throws Exception {\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n        String indexId = (String) template.requestBody(\"direct:index\", map);\n        assertNotNull(\"indexId should be set\", indexId);\n    }","id":67417,"modified_method":"@Test\n    public void testIndex() throws Exception {\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n        String indexId = template.requestBody(\"direct:index\", map, String.class);\n        assertNotNull(\"indexId should be set\", indexId);\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testDelete() throws Exception {\n\n        //first, INDEX a value\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n        sendBody(\"direct:index\", map);\n        String indexId = (String) template.requestBody(\"direct:index\", map);\n        assertNotNull(\"indexId should be set\", indexId);\n\n        //now, verify GET succeeded\n        GetResponse response = (GetResponse) template.requestBody(\"direct:get\", indexId);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n\n        //now, perform DELETE\n        DeleteResponse deleteResponse = (DeleteResponse) template.requestBody(\"direct:delete\", indexId);\n        assertNotNull(\"response should not be null\", deleteResponse);\n\n        //now, verify GET fails to find the indexed value\n        response = (GetResponse) template.requestBody(\"direct:get\", indexId);\n        assertNotNull(\"response should not be null\", response);\n        assertNull(\"response source should be null\", response.getSource());\n    }","id":67418,"modified_method":"@Test\n    public void testDelete() throws Exception {\n        //first, INDEX a value\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n        sendBody(\"direct:index\", map);\n        String indexId = template.requestBody(\"direct:index\", map, String.class);\n        assertNotNull(\"indexId should be set\", indexId);\n\n        //now, verify GET succeeded\n        GetResponse response = template.requestBody(\"direct:get\", indexId, GetResponse.class);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n\n        //now, perform DELETE\n        DeleteResponse deleteResponse = template.requestBody(\"direct:delete\", indexId, DeleteResponse.class);\n        assertNotNull(\"response should not be null\", deleteResponse);\n\n        //now, verify GET fails to find the indexed value\n        response = template.requestBody(\"direct:get\", indexId, GetResponse.class);\n        assertNotNull(\"response should not be null\", response);\n        assertNull(\"response source should be null\", response.getSource());\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"@Test\n    public void testGet() throws Exception {\n        //first, INDEX a value\n        HashMap<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n        sendBody(\"direct:index\", map);\n        String indexId = (String) template.requestBody(\"direct:index\", map);\n        assertNotNull(\"indexId should be set\", indexId);\n\n        //now, verify GET succeeded\n        GetResponse response = (GetResponse) template.requestBody(\"direct:get\", indexId);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n    }","id":67419,"modified_method":"@Test\n    public void testGet() throws Exception {\n        //first, INDEX a value\n        Map<String, String> map = new HashMap<String, String>();\n        map.put(\"content\", \"test\");\n        sendBody(\"direct:index\", map);\n        String indexId = template.requestBody(\"direct:index\", map, String.class);\n        assertNotNull(\"indexId should be set\", indexId);\n\n        //now, verify GET succeeded\n        GetResponse response = template.requestBody(\"direct:get\", indexId, GetResponse.class);\n        assertNotNull(\"response should not be null\", response);\n        assertNotNull(\"response source should not be null\", response.getSource());\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"public void getById(Client client, Exchange exchange) {\n\n        String indexName = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            indexName = endpoint.getConfig().getIndexName();\n        }\n\n        String indexType = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            indexType = endpoint.getConfig().getIndexType();\n        }\n\n        String indexId = exchange.getIn().getBody(String.class);\n\n        GetResponse response = client.prepareGet(indexName, indexType, indexId).execute().actionGet();\n        exchange.getIn().setBody(response);\n    }","id":67420,"modified_method":"public void getById(Client client, Exchange exchange) {\n        String indexName = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            indexName = getEndpoint().getConfig().getIndexName();\n        }\n\n        String indexType = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            indexType = getEndpoint().getConfig().getIndexType();\n        }\n\n        String indexId = exchange.getIn().getBody(String.class);\n\n        GetResponse response = client.prepareGet(indexName, indexType, indexId).execute().actionGet();\n        exchange.getIn().setBody(response);\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"public void process(Exchange exchange) throws Exception {\n\n        String operation = (String) exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_OPERATION);\n        if (operation == null) {\n            operation = endpoint.getConfig().getOperation();\n        }\n\n        if (operation == null) {\n            throw new IllegalArgumentException(ElasticsearchConfiguration.PARAM_OPERATION + \" is missing\");\n        }\n\n        Client client = endpoint.getClient();\n\n        if (operation.equalsIgnoreCase(ElasticsearchConfiguration.OPERATION_INDEX)) {\n            addToIndex(client, exchange);\n        } else if (operation.equalsIgnoreCase(ElasticsearchConfiguration.OPERATION_GET_BY_ID)) {\n            getById(client, exchange);\n        } else if (operation.equalsIgnoreCase(ElasticsearchConfiguration.OPERATION_DELETE)) {\n            deleteById(client, exchange);\n        } else {\n            throw new IllegalArgumentException(ElasticsearchConfiguration.PARAM_OPERATION + \" value '\" + operation + \"' is not supported\");\n        }\n    }","id":67421,"modified_method":"public void process(Exchange exchange) throws Exception {\n        String operation = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_OPERATION, String.class);\n        if (operation == null) {\n            operation = getEndpoint().getConfig().getOperation();\n        }\n\n        if (operation == null) {\n            throw new IllegalArgumentException(ElasticsearchConfiguration.PARAM_OPERATION + \" is missing\");\n        }\n\n        Client client = getEndpoint().getClient();\n\n        if (operation.equalsIgnoreCase(ElasticsearchConfiguration.OPERATION_INDEX)) {\n            addToIndex(client, exchange);\n        } else if (operation.equalsIgnoreCase(ElasticsearchConfiguration.OPERATION_GET_BY_ID)) {\n            getById(client, exchange);\n        } else if (operation.equalsIgnoreCase(ElasticsearchConfiguration.OPERATION_DELETE)) {\n            deleteById(client, exchange);\n        } else {\n            throw new IllegalArgumentException(ElasticsearchConfiguration.PARAM_OPERATION + \" value '\" + operation + \"' is not supported\");\n        }\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"public void deleteById(Client client, Exchange exchange) {\n\n        String indexName = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            indexName = endpoint.getConfig().getIndexName();\n        }\n\n        String indexType = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            indexType = endpoint.getConfig().getIndexType();\n        }\n\n        String indexId = exchange.getIn().getBody(String.class);\n\n        DeleteResponse response = client.prepareDelete(indexName, indexType, indexId).execute().actionGet();\n        exchange.getIn().setBody(response);\n    }","id":67422,"modified_method":"public void deleteById(Client client, Exchange exchange) {\n        String indexName = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            indexName = getEndpoint().getConfig().getIndexName();\n        }\n\n        String indexType = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            indexType = getEndpoint().getConfig().getIndexType();\n        }\n\n        String indexId = exchange.getIn().getBody(String.class);\n\n        DeleteResponse response = client.prepareDelete(indexName, indexType, indexId).execute().actionGet();\n        exchange.getIn().setBody(response);\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"public void addToIndex(Client client, Exchange exchange) {\n\n        String indexName = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            indexName = endpoint.getConfig().getIndexName();\n        }\n\n        String indexType = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            indexType = endpoint.getConfig().getIndexType();\n        }\n\n        IndexRequestBuilder prepareIndex = client.prepareIndex(indexName, indexType);\n\n        if (!setIndexRequestSource(exchange.getIn(), prepareIndex)) {\n            throw new ExpectedBodyTypeException(exchange, XContentBuilder.class);\n        }\n        ListenableActionFuture<IndexResponse> future = prepareIndex.execute();\n        IndexResponse response = future.actionGet();\n        exchange.getIn().setBody(response.getId());\n    }","id":67423,"modified_method":"public void addToIndex(Client client, Exchange exchange) {\n        String indexName = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_NAME, String.class);\n        if (indexName == null) {\n            indexName = getEndpoint().getConfig().getIndexName();\n        }\n\n        String indexType = exchange.getIn().getHeader(ElasticsearchConfiguration.PARAM_INDEX_TYPE, String.class);\n        if (indexType == null) {\n            indexType = getEndpoint().getConfig().getIndexType();\n        }\n\n        IndexRequestBuilder prepareIndex = client.prepareIndex(indexName, indexType);\n\n        if (!setIndexRequestSource(exchange.getIn(), prepareIndex)) {\n            throw new ExpectedBodyTypeException(exchange, XContentBuilder.class);\n        }\n        ListenableActionFuture<IndexResponse> future = prepareIndex.execute();\n        IndexResponse response = future.actionGet();\n        exchange.getIn().setBody(response.getId());\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"public ElasticsearchProducer(ElasticsearchEndpoint endpoint) {\n        super(endpoint);\n        this.endpoint = endpoint;\n    }","id":67424,"modified_method":"public ElasticsearchProducer(ElasticsearchEndpoint endpoint) {\n        super(endpoint);\n    }","commit_id":"f19e792bd3839040ffbdc622e75684da62211ea5","url":"https://github.com/apache/camel"},{"original_method":"public void updatedDownloadsList(List<IndexItem> list) {\n\t\tView mainView = getView();\n\t\tif (mainView == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (list.size() > 0) {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\t\tLinearLayout updates = (LinearLayout) mainView.findViewById(R.id.updates_items);\n\t\tupdates.removeAllViews();\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tfinal IndexItem item = list.get(i);\n\t\t\tif (i > 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_updates_item, null, false);\n\t\t\tString eName = item.getVisibleDescription(getMyApplication()) + \"\\n\"\n\t\t\t\t\t+ item.getVisibleName(getMyApplication(), getMyApplication().getResourceManager().getOsmandRegions());\n\t\t\tString d = item.getDate(getMyApplication().getResourceManager().getDateFormat()) + \"\\n\" + item.getSizeDescription(getMyApplication());\n\t\t\t((TextView) view.findViewById(R.id.map_name)).setText(eName);\n\t\t\t((TextView) view.findViewById(R.id.map_descr)).setText(d);\n\t\t\t(view.findViewById(R.id.btn_download)).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View view) {\n\t\t\t\t\tList<DownloadEntry> download = item.createDownloadEntry(getMyApplication(), item.getType(), new ArrayList<DownloadEntry>());\n\t\t\t\t\tgetDownloadActivity().getEntriesToDownload().put(item, download);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}","id":67425,"modified_method":"public void updatedDownloadsList(List<IndexItem> list) {\n\t\tView mainView = getView();\n\t\t//it may be null because download index thread is async\n\t\tif (mainView == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (list.size() > 0) {\n\t\t\tmainView.setVisibility(View.VISIBLE);\n\t\t} else {\n\t\t\tmainView.setVisibility(View.GONE);\n\t\t\treturn;\n\t\t}\n\n\t\t((TextView)mainView.findViewById(R.id.update_count)).setText(String.valueOf(list.size()));\n\n\t\tLinearLayout updates = (LinearLayout) mainView.findViewById(R.id.updates_items);\n\t\tupdates.removeAllViews();\n\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tfinal IndexItem item = list.get(i);\n\t\t\tif (i > 2) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tLayoutInflater inflater = getActivity().getLayoutInflater();\n\t\t\tView view = inflater.inflate(R.layout.dash_updates_item, null, false);\n\t\t\tString name = item.getVisibleName(getMyApplication(), getMyApplication().getResourceManager().getOsmandRegions());\n\t\t\tString d = item.getDate(getMyApplication().getResourceManager().getDateFormat()) + \", \" + item.getSizeDescription(getMyApplication());\n\t\t\tString eName = name.replace(\"\\n\", \" \");\n\t\t\t((TextView) view.findViewById(R.id.map_name)).setText(eName);\n\t\t\t((TextView) view.findViewById(R.id.map_descr)).setText(d);\n\t\t\t(view.findViewById(R.id.btn_download)).setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View view) {\n\t\t\t\t\tList<DownloadEntry> download = item.createDownloadEntry(getMyApplication(), item.getType(), new ArrayList<DownloadEntry>());\n\t\t\t\t\tgetDownloadActivity().getEntriesToDownload().put(item, download);\n\t\t\t\t}\n\t\t\t});\n\t\t\tupdates.addView(view);\n\t\t}\n\t}","commit_id":"742eb0a64a49b6fb10d0e2485785394e2dbbe533","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_updates_fragment, container, false);\n\t\treturn view;\n\t}","id":67426,"modified_method":"@Override\n\tpublic View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n\t\tView view = getActivity().getLayoutInflater().inflate(R.layout.dash_updates_fragment, container, false);\n\t\t(view.findViewById(R.id.show_all)).setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View view) {\n\t\t\t\tfinal Intent intent = new Intent(view.getContext(), getMyApplication().getAppCustomization().getDownloadIndexActivity());\n\t\t\t\tintent.putExtra(DownloadActivity.TAB_TO_OPEN, DownloadActivity.UPDATES_TAB);\n\t\t\t\tgetActivity().startActivity(intent);\n\t\t\t}\n\t\t});\n\t\treturn view;\n\t}","commit_id":"742eb0a64a49b6fb10d0e2485785394e2dbbe533","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.dashboard);\n\t\tgetSupportActionBar().setTitle(R.string.app_name_ver);\n\t\tColorDrawable color = new ColorDrawable(Color.parseColor(\"#ff8f00\"));\n\t\tgetSupportActionBar().setBackgroundDrawable(color);\n\t\tgetSupportActionBar().setIcon(android.R.color.transparent);\n\n\t\tif(downloadListIndexThread == null) {\n\t\t\tdownloadListIndexThread = new DownloadIndexesThread(this);\n\t\t}\n\t\tif (downloadListIndexThread.getCachedIndexFiles() != null && downloadListIndexThread.isDownloadedFromInternet()) {\n\t\t\tdownloadListIndexThread.runCategorization(DownloadActivityType.NORMAL_FILE);\n\t\t} else {\n\t\t\tdownloadListIndexThread.runReloadIndexFiles();\n\t\t}\n\t\tdownloadListIndexThread.setUiActivity(this);\n\n\t\tandroid.support.v4.app.FragmentManager manager = getSupportFragmentManager();\n\t\tandroid.support.v4.app.FragmentTransaction fragmentTransaction = manager.beginTransaction();\n\n\t\tDashSearchFragment searchFragment = new DashSearchFragment();\n\t\tfragmentTransaction.add(R.id.content, searchFragment);\n\t\tDashMapFragment mapFragment = new DashMapFragment();\n\t\tfragmentTransaction.add(R.id.content, mapFragment);\n\t\tDashFavoritesFragment favoritesFragment = new DashFavoritesFragment();\n\t\tfragmentTransaction.add(R.id.content, favoritesFragment);\n\t\tDashUpdatesFragment updatesFragment = new DashUpdatesFragment();\n\t\tfragmentTransaction.add(R.id.content, updatesFragment);\n\t\tDashPluginsFragment pluginsFragment = new DashPluginsFragment();\n\t\tfragmentTransaction.add(R.id.content, pluginsFragment).commit();\n\n\t}","id":67427,"modified_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.dashboard);\n\t\tgetSupportActionBar().setTitle(R.string.app_name_ver);\n\t\tColorDrawable color = new ColorDrawable(Color.parseColor(\"#ff8f00\"));\n\t\tgetSupportActionBar().setBackgroundDrawable(color);\n\t\tgetSupportActionBar().setIcon(android.R.color.transparent);\n\n\t\tandroid.support.v4.app.FragmentManager manager = getSupportFragmentManager();\n\t\tandroid.support.v4.app.FragmentTransaction fragmentTransaction = manager.beginTransaction();\n\n\t\tDashSearchFragment searchFragment = new DashSearchFragment();\n\t\tfragmentTransaction.add(R.id.content, searchFragment);\n\t\tDashMapFragment mapFragment = new DashMapFragment();\n\t\tfragmentTransaction.add(R.id.content, mapFragment);\n\t\tDashFavoritesFragment favoritesFragment = new DashFavoritesFragment();\n\t\tfragmentTransaction.add(R.id.content, favoritesFragment);\n\t\tDashUpdatesFragment updatesFragment = new DashUpdatesFragment();\n\t\tfragmentTransaction.add(R.id.content, updatesFragment);\n\t\tDashPluginsFragment pluginsFragment = new DashPluginsFragment();\n\t\tfragmentTransaction.add(R.id.content, pluginsFragment).commit();\n\n\t}","commit_id":"742eb0a64a49b6fb10d0e2485785394e2dbbe533","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n\t\tsetProgressBarIndeterminateVisibility(false);\n\n\t\tsetContentView(R.layout.tab_content);\n\t\tif(downloadListIndexThread == null) {\n\t\t\tdownloadListIndexThread = new DownloadIndexesThread(this);\n\t\t}\n\t\tif (downloadListIndexThread.getCachedIndexFiles() != null && downloadListIndexThread.isDownloadedFromInternet()) {\n\t\t\tdownloadListIndexThread.runCategorization(type);\n\t\t} else {\n\t\t\tdownloadListIndexThread.runReloadIndexFiles();\n\t\t}\n\t\tdownloadListIndexThread.setUiActivity(this);\n\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\ttabHost = (TabHost) findViewById(android.R.id.tabhost);\n\t\ttabHost.setup();\n\t\tViewPager viewPager = (ViewPager) findViewById(R.id.pager);\n\t\tmTabsAdapter = new FavouritesActivity.TabsAdapter(this, tabHost, viewPager, settings, false);\n\t\tif (getMyApplication().getAppCustomization().onlyTourDownload()){\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"DOWNLOADS\").setIndicator(\"Downloads\"),\n\t\t\t\t\tDownloadIndexFragment.class, null);\n\t\t} else {\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"LOCAL_INDEX\").setIndicator(\"Local\"),\n\t\t\t\t\tLocalIndexesFragment.class, null);\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"DOWNLOADS\").setIndicator(\"Downloads\"),\n\t\t\t\t\tDownloadIndexFragment.class, null);\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"UPDATES\").setIndicator(\"Updates\"),\n\t\t\t\t\tUpdatesIndexFragment.class, null);\n\t\t}\n\n\t\ttabHost.setCurrentTab(0);\n\n\t\tsettings = ((OsmandApplication)getApplication()).getSettings();\n\n\t\tindeterminateProgressBar = (ProgressBar) findViewById(R.id.IndeterminateProgressBar);\n\t\tdeterminateProgressBar = (ProgressBar) findViewById(R.id.DeterminateProgressBar);\n\t\tprogressView = findViewById(R.id.ProgressView);\n\t\tprogressMessage = (TextView) findViewById(R.id.ProgressMessage);\n\t\tprogressPercent = (TextView) findViewById(R.id.ProgressPercent);\n\t\tcancel = (ImageView) findViewById(R.id.Cancel);\n\t\tint d = settings.isLightContent() ? R.drawable.a_1_navigation_cancel_small_light : R.drawable.a_1_navigation_cancel_small_dark;\n\t\tcancel.setImageDrawable(getResources().getDrawable(d));\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tmakeSureUserCancelDownload();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.DownloadButton).setOnClickListener(new View.OnClickListener(){\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdownloadFilesCheckFreeVersion();\n\t\t\t}\n\n\t\t});\n\n\t\tfinal List<DownloadActivityType> downloadTypes = getDownloadTypes();\n\t\tfinal Intent intent = getIntent();\n\t\tsetType(downloadTypes.get(0));\n\t\tif (intent != null && intent.getExtras() != null) {\n\t\t\tfinal String filter = intent.getExtras().getString(FILTER_KEY);\n\t\t\tif (filter != null) {\n\t\t\t\tinitialFilter = filter;\n\t\t\t}\n\n\t\t\tfinal String filterCat = intent.getExtras().getString(FILTER_CAT);\n\t\t\tif (filterCat != null) {\n\t\t\t\tDownloadActivityType type = DownloadActivityType.getIndexType(filterCat.toLowerCase());\n\t\t\t\tif (type != null) {\n\t\t\t\t\tsetType(type);\n\t\t\t\t\tdownloadTypes.remove(type);\n\t\t\t\t\tdownloadTypes.add(0, type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString tab = intent.getExtras().getString(TAB_TO_OPEN);\n\t\t\tif (tab != null) {\n\t\t\t\tif (tab.equals(DOWNLOAD_TAB)){\n\t\t\t\t\ttabHost.setCurrentTab(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(getMyApplication().getResourceManager().getIndexFileNames().isEmpty()) {\n\t\t\tboolean showedDialog = false;\n\t\t\tif(Build.VERSION.SDK_INT < OsmandSettings.VERSION_DEFAULTLOCATION_CHANGED) {\n\t\t\t\tSuggestExternalDirectoryDialog.showDialog(this, null, null);\n\t\t\t}\n\t\t\tif(!showedDialog) {\n\t\t\t\tshowDialogOfFreeDownloadsIfNeeded();\n\t\t\t}\n\t\t} else {\n\t\t\tshowDialogOfFreeDownloadsIfNeeded();\n\t\t}\n\n\n\t\tif (Build.VERSION.SDK_INT >= OsmandSettings.VERSION_DEFAULTLOCATION_CHANGED) {\n\t\t\tfinal String currentStorage = settings.getExternalStorageDirectory().getAbsolutePath();\n\t\t\tString primaryStorage = settings.getDefaultExternalStorageLocation();\n\t\t\tif (!currentStorage.startsWith(primaryStorage)) {\n\t\t\t\t// secondary storage\n\t\t\t\tboolean currentDirectoryNotWritable = true;\n\t\t\t\tfor (String writeableDirectory : settings.getWritableSecondaryStorageDirectorys()) {\n\t\t\t\t\tif (currentStorage.startsWith(writeableDirectory)) {\n\t\t\t\t\t\tcurrentDirectoryNotWritable = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentDirectoryNotWritable) {\n\t\t\t\t\tcurrentDirectoryNotWritable = !OsmandSettings.isWritable(settings.getExternalStorageDirectory());\n\t\t\t\t}\n\t\t\t\tif (currentDirectoryNotWritable) {\n\t\t\t\t\tfinal String newLoc = settings.getMatchingExternalFilesDir(currentStorage);\n\t\t\t\t\tif (newLoc != null && newLoc.length() != 0) {\n\t\t\t\t\t\tAccessibleAlertBuilder ab = new AccessibleAlertBuilder(this);\n\t\t\t\t\t\tab.setMessage(getString(R.string.android_19_location_disabled,\n\t\t\t\t\t\t\t\tsettings.getExternalStorageDirectory()));\n\t\t\t\t\t\tab.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tcopyFilesForAndroid19(newLoc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tab.setNegativeButton(R.string.default_buttons_cancel, null);\n\t\t\t\t\t\tab.show();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgetSupportActionBar().setHomeButtonEnabled(true);\n\t\tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n\t}","id":67428,"modified_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n\t\tsetProgressBarIndeterminateVisibility(false);\n\n\t\tsetContentView(R.layout.tab_content);\n\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\ttabHost = (TabHost) findViewById(android.R.id.tabhost);\n\t\ttabHost.setup();\n\t\tViewPager viewPager = (ViewPager) findViewById(R.id.pager);\n\t\tmTabsAdapter = new FavouritesActivity.TabsAdapter(this, tabHost, viewPager, settings, false);\n\t\tif (getMyApplication().getAppCustomization().onlyTourDownload()){\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"DOWNLOADS\").setIndicator(\"Downloads\"),\n\t\t\t\t\tDownloadIndexFragment.class, null);\n\t\t} else {\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"LOCAL_INDEX\").setIndicator(\"Local\"),\n\t\t\t\t\tLocalIndexesFragment.class, null);\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"DOWNLOADS\").setIndicator(\"Downloads\"),\n\t\t\t\t\tDownloadIndexFragment.class, null);\n\t\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"UPDATES\").setIndicator(\"Updates\"),\n\t\t\t\t\tUpdatesIndexFragment.class, null);\n\t\t}\n\n\t\ttabHost.setCurrentTab(0);\n\n\t\tsettings = ((OsmandApplication)getApplication()).getSettings();\n\n\t\tindeterminateProgressBar = (ProgressBar) findViewById(R.id.IndeterminateProgressBar);\n\t\tdeterminateProgressBar = (ProgressBar) findViewById(R.id.DeterminateProgressBar);\n\t\tprogressView = findViewById(R.id.ProgressView);\n\t\tprogressMessage = (TextView) findViewById(R.id.ProgressMessage);\n\t\tprogressPercent = (TextView) findViewById(R.id.ProgressPercent);\n\t\tcancel = (ImageView) findViewById(R.id.Cancel);\n\t\tint d = settings.isLightContent() ? R.drawable.a_1_navigation_cancel_small_light : R.drawable.a_1_navigation_cancel_small_dark;\n\t\tcancel.setImageDrawable(getResources().getDrawable(d));\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tmakeSureUserCancelDownload();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.DownloadButton).setOnClickListener(new View.OnClickListener(){\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdownloadFilesCheckFreeVersion();\n\t\t\t}\n\n\t\t});\n\n\t\tfinal List<DownloadActivityType> downloadTypes = getDownloadTypes();\n\t\tfinal Intent intent = getIntent();\n\t\tsetType(downloadTypes.get(0));\n\t\tif (intent != null && intent.getExtras() != null) {\n\t\t\tfinal String filter = intent.getExtras().getString(FILTER_KEY);\n\t\t\tif (filter != null) {\n\t\t\t\tinitialFilter = filter;\n\t\t\t}\n\n\t\t\tfinal String filterCat = intent.getExtras().getString(FILTER_CAT);\n\t\t\tif (filterCat != null) {\n\t\t\t\tDownloadActivityType type = DownloadActivityType.getIndexType(filterCat.toLowerCase());\n\t\t\t\tif (type != null) {\n\t\t\t\t\tsetType(type);\n\t\t\t\t\tdownloadTypes.remove(type);\n\t\t\t\t\tdownloadTypes.add(0, type);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tString tab = intent.getExtras().getString(TAB_TO_OPEN);\n\t\t\tif (tab != null) {\n\t\t\t\tif (tab.equals(DOWNLOAD_TAB)){\n\t\t\t\t\ttabHost.setCurrentTab(1);\n\t\t\t\t} else if (tab.equals(UPDATES_TAB)){\n\t\t\t\t\ttabHost.setCurrentTab(2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(getMyApplication().getResourceManager().getIndexFileNames().isEmpty()) {\n\t\t\tboolean showedDialog = false;\n\t\t\tif(Build.VERSION.SDK_INT < OsmandSettings.VERSION_DEFAULTLOCATION_CHANGED) {\n\t\t\t\tSuggestExternalDirectoryDialog.showDialog(this, null, null);\n\t\t\t}\n\t\t\tif(!showedDialog) {\n\t\t\t\tshowDialogOfFreeDownloadsIfNeeded();\n\t\t\t}\n\t\t} else {\n\t\t\tshowDialogOfFreeDownloadsIfNeeded();\n\t\t}\n\n\n\t\tif (Build.VERSION.SDK_INT >= OsmandSettings.VERSION_DEFAULTLOCATION_CHANGED) {\n\t\t\tfinal String currentStorage = settings.getExternalStorageDirectory().getAbsolutePath();\n\t\t\tString primaryStorage = settings.getDefaultExternalStorageLocation();\n\t\t\tif (!currentStorage.startsWith(primaryStorage)) {\n\t\t\t\t// secondary storage\n\t\t\t\tboolean currentDirectoryNotWritable = true;\n\t\t\t\tfor (String writeableDirectory : settings.getWritableSecondaryStorageDirectorys()) {\n\t\t\t\t\tif (currentStorage.startsWith(writeableDirectory)) {\n\t\t\t\t\t\tcurrentDirectoryNotWritable = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (currentDirectoryNotWritable) {\n\t\t\t\t\tcurrentDirectoryNotWritable = !OsmandSettings.isWritable(settings.getExternalStorageDirectory());\n\t\t\t\t}\n\t\t\t\tif (currentDirectoryNotWritable) {\n\t\t\t\t\tfinal String newLoc = settings.getMatchingExternalFilesDir(currentStorage);\n\t\t\t\t\tif (newLoc != null && newLoc.length() != 0) {\n\t\t\t\t\t\tAccessibleAlertBuilder ab = new AccessibleAlertBuilder(this);\n\t\t\t\t\t\tab.setMessage(getString(R.string.android_19_location_disabled,\n\t\t\t\t\t\t\t\tsettings.getExternalStorageDirectory()));\n\t\t\t\t\t\tab.setPositiveButton(R.string.default_buttons_yes, new DialogInterface.OnClickListener() {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\t\t\tcopyFilesForAndroid19(newLoc);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tab.setNegativeButton(R.string.default_buttons_cancel, null);\n\t\t\t\t\t\tab.show();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgetSupportActionBar().setHomeButtonEnabled(true);\n\t\tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n\t}","commit_id":"742eb0a64a49b6fb10d0e2485785394e2dbbe533","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tformat = getMyApplication().getResourceManager().getDateFormat();\n\t\tupdateColor = getResources().getColor(R.color.color_update);\n\t\tosmandRegions = getMyApplication().getResourceManager().getOsmandRegions();\n\t\tList<IndexItem> indexItems = new ArrayList<IndexItem>();\n\t\tif (DownloadActivity.downloadListIndexThread != null) {\n\t\t\tindexItems = DownloadActivity.downloadListIndexThread.getItemsToUpdate();\n\t\t}\n\t\tlistAdapter = new UpdateIndexAdapter(getDownloadActivity(), R.layout.download_index_list_item, indexItems);\n\t\tlistAdapter.sort(new Comparator<IndexItem>() {\n\t\t\t@Override\n\t\t\tpublic int compare(IndexItem indexItem, IndexItem indexItem2) {\n\t\t\t\treturn indexItem.getVisibleName(getMyApplication(), osmandRegions).compareTo(indexItem2.getVisibleName(getMyApplication(), osmandRegions));\n\t\t\t}\n\t\t});\n\t\tsetListAdapter(listAdapter);\n\t\tsetHasOptionsMenu(true);\n\t}","id":67429,"modified_method":"@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tformat = getMyApplication().getResourceManager().getDateFormat();\n\t\tupdateColor = getResources().getColor(R.color.color_update);\n\t\tosmandRegions = getMyApplication().getResourceManager().getOsmandRegions();\n\t\tList<IndexItem> indexItems = new ArrayList<IndexItem>();\n\t\tif (BaseDownloadActivity.downloadListIndexThread != null) {\n\t\t\tindexItems = DownloadActivity.downloadListIndexThread.getItemsToUpdate();\n\t\t}\n\t\tlistAdapter = new UpdateIndexAdapter(getDownloadActivity(), R.layout.download_index_list_item, indexItems);\n\t\tlistAdapter.sort(new Comparator<IndexItem>() {\n\t\t\t@Override\n\t\t\tpublic int compare(IndexItem indexItem, IndexItem indexItem2) {\n\t\t\t\treturn indexItem.getVisibleName(getMyApplication(), osmandRegions).compareTo(indexItem2.getVisibleName(getMyApplication(), osmandRegions));\n\t\t\t}\n\t\t});\n\t\tsetListAdapter(listAdapter);\n\t\tsetHasOptionsMenu(true);\n\t}","commit_id":"742eb0a64a49b6fb10d0e2485785394e2dbbe533","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic View getChildView(final int groupPosition, final int childPosition, boolean isLastChild, View convertView, ViewGroup parent) {\n\t\tView v = convertView;\n\t\tif (v == null) {\n\t\t\tLayoutInflater inflater = (LayoutInflater) downloadFragment.getDownloadActivity().getSystemService( Context.LAYOUT_INFLATER_SERVICE );\n\t\t\tv = inflater.inflate(net.osmand.plus.R.layout.download_index_list_item, parent, false);\n\t\t}\n\t\tfinal View row = v;\n\t\tTextView item = (TextView) row.findViewById(R.id.download_item);\n\t\tTextView description = (TextView) row.findViewById(R.id.download_descr);\n\t\tIndexItem e = (IndexItem) getChild(groupPosition, childPosition);\n\t\tOsmandApplication clctx = downloadFragment.getMyApplication();\n\t\tString eName = e.getVisibleDescription(clctx) + \"\\n\" + e.getVisibleName(clctx, osmandRegions);\n\t\titem.setText(eName.trim()); //$NON-NLS-1$\n\t\tString d = e.getDate(format) + \"\\n\" + e.getSizeDescription(clctx);\n\t\tdescription.setText(d.trim());\n\n\t\tCheckBox ch = (CheckBox) row.findViewById(R.id.check_download_item);\n\t\tch.setChecked(downloadFragment.getDownloadActivity().getEntriesToDownload().containsKey(e));\n\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinal CheckBox ch = (CheckBox) v.findViewById(R.id.check_download_item);\n\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\tdownloadFragment.onChildClick(downloadFragment.getExpandableListView(), row, groupPosition, childPosition, getChildId(groupPosition, childPosition));\n\t\t\t}\n\t\t});\n\n\t\tif (indexFileNames != null) {\n\t\t\t\n\t\t\tif (!e.isAlreadyDownloaded(indexFileNames)) {\n\t\t\t\titem.setTextColor(defaultColor);\n\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t} else {\n\t\t\t\tif(e.getType() == DownloadActivityType.HILLSHADE_FILE\n\t\t\t\t\t\t|| e.getType() == DownloadActivityType.SRTM_COUNTRY_FILE){\n\t\t\t\t\titem.setTextColor(okColor); // GREEN\n\t\t\t\t\tString sfName = e.getTargetFileName();\n\t\t\t\t\tif (indexActivatedFileNames.containsKey(sfName)) {\n\t\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t\t\t// next case since present hillshade files cannot be deactivated, but are not in indexActivatedFileNames\n\t\t\t\t\t} else if (e.getType() == DownloadActivityType.HILLSHADE_FILE) {\n\t\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);\n\t\t\t\t\t}\n\t\t\t\t} else if (e.getDate(format) != null) {\n\t\t\t\t\tString sfName = e.getTargetFileName();\n\t\t\t\t\tfinal boolean updatableResource = indexActivatedFileNames.containsKey(sfName);\n\t\t\t\t\tif (updatableResource && !DownloadActivity.downloadListIndexThread.checkIfItemOutdated(e)) {\n\t\t\t\t\t\titem.setText(item.getText() + \"\\n\" + downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexActivatedFileNames.get(sfName));\n\t\t\t\t\t\titem.setTextColor(okColor); // GREEN\n\t\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t\t\t} else if (indexFileNames.containsKey(sfName) && !DownloadActivity.downloadListIndexThread.checkIfItemOutdated(e)) {\n\t\t\t\t\t\titem.setText(item.getText() + \"\\n\" + downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexFileNames.get(sfName));\n\t\t\t\t\t\titem.setTextColor(okColor);\n\t\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);\n\t\t\t\t\t} else if (updatableResource) {\n\t\t\t\t\t\titem.setText(item.getText() + \"\\n\" + downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexActivatedFileNames.get(sfName));\n\t\t\t\t\t\titem.setTextColor(updateColor); // LIGHT_BLUE\n\t\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.setText(item.getText() + \"\\n\" + downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexFileNames.get(sfName));\n\t\t\t\t\t\titem.setTextColor(updateColor);\n\t\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\titem.setTextColor(okColor);\n\t\t\t\t\titem.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn row;\n\t}","id":67430,"modified_method":"@Override\n\tpublic View getChildView(final int groupPosition, final int childPosition, boolean isLastChild, View convertView, ViewGroup parent) {\n\t\tView v = convertView;\n\t\tif (v == null) {\n\t\t\tLayoutInflater inflater = (LayoutInflater) downloadFragment.getDownloadActivity().getSystemService( Context.LAYOUT_INFLATER_SERVICE );\n\t\t\tv = inflater.inflate(net.osmand.plus.R.layout.download_index_list_item, parent, false);\n\t\t}\n\t\tfinal View row = v;\n\t\tTextView name = (TextView) row.findViewById(R.id.name);\n\t\tTextView edition = (TextView) row.findViewById(R.id.update_descr);\n\t\tedition.setText(\"\");\n\t\tTextView description = (TextView) row.findViewById(R.id.download_descr);\n\t\tIndexItem e = (IndexItem) getChild(groupPosition, childPosition);\n\t\tOsmandApplication clctx = downloadFragment.getMyApplication();\n\t\tString eName = e.getVisibleName(clctx, osmandRegions);\n\t\tname.setText(eName.trim()); //$NON-NLS-1$\n\t\tString d = e.getDate(format) + \" \" + e.getSizeDescription(clctx);\n\t\tdescription.setText(d.trim());\n\n\t\tCheckBox ch = (CheckBox) row.findViewById(R.id.check_download_item);\n\t\tch.setChecked(downloadFragment.getDownloadActivity().getEntriesToDownload().containsKey(e));\n\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinal CheckBox ch = (CheckBox) v.findViewById(R.id.check_download_item);\n\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\tdownloadFragment.onChildClick(downloadFragment.getExpandableListView(), row, groupPosition, childPosition, getChildId(groupPosition, childPosition));\n\t\t\t}\n\t\t});\n\n\t\tif (indexFileNames != null) {\n\n\t\t\tif (e.isAlreadyDownloaded(indexFileNames)) {\n\t\t\t\tif (e.getType() == DownloadActivityType.HILLSHADE_FILE\n\t\t\t\t\t\t|| e.getType() == DownloadActivityType.SRTM_COUNTRY_FILE) {\n\t\t\t\t\tString sfName = e.getTargetFileName();\n\t\t\t\t\tif (indexActivatedFileNames.containsKey(sfName)) {\n\t\t\t\t\t\tname.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t\t\t\t// next case since present hillshade files cannot be deactivated, but are not in indexActivatedFileNames\n\t\t\t\t\t} else if (e.getType() == DownloadActivityType.HILLSHADE_FILE) {\n\t\t\t\t\t\tname.setTypeface(Typeface.DEFAULT, Typeface.NORMAL);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tname.setTypeface(Typeface.DEFAULT, Typeface.ITALIC);\n\t\t\t\t\t}\n\t\t\t\t} else if (e.getDate(format) != null) {\n\t\t\t\t\tString sfName = e.getTargetFileName();\n\t\t\t\t\tfinal boolean updatableResource = indexActivatedFileNames.containsKey(sfName);\n\t\t\t\t\tif (updatableResource && !DownloadActivity.downloadListIndexThread.checkIfItemOutdated(e)) {\n\t\t\t\t\t\tedition.setText(downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexActivatedFileNames.get(sfName));\n\t\t\t\t\t} else if (indexFileNames.containsKey(sfName) && !DownloadActivity.downloadListIndexThread.checkIfItemOutdated(e)) {\n\t\t\t\t\t\tedition.setText(downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexFileNames.get(sfName));\n\t\t\t\t\t} else if (updatableResource) {\n\t\t\t\t\t\tedition.setText(downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexActivatedFileNames.get(sfName));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedition.setText(name.getText() + \"\\n\" + downloadFragment.getResources().getString(R.string.local_index_installed) + \" : \"\n\t\t\t\t\t\t\t\t+ indexFileNames.get(sfName));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn row;\n\t}","commit_id":"ccbb4e262573edf0f86d24c6c51aa09da3bdd8fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public DownloadIndexAdapter(DownloadIndexFragment downloadFragment, List<IndexItem> indexFiles) {\n\t\tthis.downloadFragment = downloadFragment;\n\t\t\n\t\tthis.indexFiles = new ArrayList<IndexItem>(indexFiles);\n\t\tapp = downloadFragment.getMyApplication();\n\t\tlist = new ArrayList<IndexItemCategory>(IndexItemCategory.categorizeIndexItems(app, indexFiles));\n\t\tformat = downloadFragment.getMyApplication().getResourceManager().getDateFormat();\n\t\tokColor = downloadFragment.getResources().getColor(R.color.color_ok);\n\t\tTypedArray ta = downloadFragment.getDownloadActivity().getTheme().obtainStyledAttributes(new int[]{android.R.attr.textColorPrimary});\n\t\tdefaultColor = ta.getColor(0, downloadFragment.getResources().getColor(R.color.color_unknown));\n\t\tta.recycle();\n\t\tupdateColor = downloadFragment.getResources().getColor(R.color.color_update);\n\t\tosmandRegions = downloadFragment.getMyApplication().getResourceManager().getOsmandRegions();\n\t}","id":67431,"modified_method":"public DownloadIndexAdapter(DownloadIndexFragment downloadFragment, List<IndexItem> indexFiles) {\n\t\tthis.downloadFragment = downloadFragment;\n\t\t\n\t\tthis.indexFiles = new ArrayList<IndexItem>(indexFiles);\n\t\tapp = downloadFragment.getMyApplication();\n\t\tlist = new ArrayList<IndexItemCategory>(IndexItemCategory.categorizeIndexItems(app, indexFiles));\n\t\tformat = downloadFragment.getMyApplication().getResourceManager().getDateFormat();\n\t\tTypedArray ta = downloadFragment.getDownloadActivity().getTheme().obtainStyledAttributes(new int[]{android.R.attr.textColorPrimary});\n\t\tta.recycle();\n\t\tosmandRegions = downloadFragment.getMyApplication().getResourceManager().getOsmandRegions();\n\t}","commit_id":"ccbb4e262573edf0f86d24c6c51aa09da3bdd8fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.searchpoi);\n\t\t\n\t\tgetSupportActionBar().setTitle(R.string.searchpoi_activity);\n\t\tgetSupportActionBar().setIcon(R.drawable.tab_search_poi_icon);\n\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\n\t\tapp = (OsmandApplication)getApplication();\n\t\t\n\t\tuiHandler = new Handler();\n\t\tsearchFilter = (EditText) findViewById(R.id.SearchFilter);\n\t\tsearchFilterLayout = findViewById(R.id.SearchFilterLayout);\n\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\t\n\t\tsearchFilter.addTextChangedListener(new TextWatcher(){\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif(!isNameFinderFilter() && !isSearchByNameFilter()){\n\t\t\t\t\tamenityAdapter.getFilter().filter(s);\n\t\t\t\t} else {\n\t\t\t\t\tif(searchPOILevel != null)  {\n\t\t\t\t\t\tsearchPOILevel.setEnabled(true);\n\t\t\t\t\t\tsearchPOILevel.setTitle(R.string.search_button);\n\t\t\t\t\t}\n\t\t\t\t\tsearchFooterButton.setEnabled(true);\n\t\t\t\t\tsearchFooterButton.setText(R.string.search_button);\n\t\t\t\t\t// Cancel current search request here?\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\t\t});\n\t\tsearchFilter.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onFocusChange(View v, boolean hasFocus) {\n\t\t\t\tif (hasFocus) {\n\t\t\t\t\tgetWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\taddFooterView();\n\t\tamenityAdapter = new AmenityAdapter(new ArrayList<Amenity>());\n\t\tsetListAdapter(amenityAdapter);\n\n\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\tDrawable arrowImage = getResources().getDrawable(R.drawable.ic_destination_arrow);\n\t\tif (light) {\n\t\t\tarrowImage.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t} else {\n\t\t\tarrowImage.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}","id":67432,"modified_method":"@Override\n\tpublic void onCreate(Bundle icicle) {\n\t\tsuper.onCreate(icicle);\n\t\tsetContentView(R.layout.searchpoi);\n\t\t\n\t\tgetSupportActionBar().setTitle(R.string.searchpoi_activity);\n\t\tgetSupportActionBar().setIcon(R.drawable.tab_search_poi_icon);\n\t\tsetSupportProgressBarIndeterminateVisibility(false);\n\t\t\n\t\tapp = (OsmandApplication)getApplication();\n\t\t\n\t\tuiHandler = new Handler();\n\t\tsearchFilter = (EditText) findViewById(R.id.SearchFilter);\n\t\tsearchFilterLayout = findViewById(R.id.SearchFilterLayout);\n\n\t\tsettings = ((OsmandApplication) getApplication()).getSettings();\n\t\t\n\t\tsearchFilter.addTextChangedListener(new TextWatcher(){\n\t\t\t@Override\n\t\t\tpublic void afterTextChanged(Editable s) {\n\t\t\t\tif(!isNameFinderFilter() && !isSearchByNameFilter()){\n\t\t\t\t\tamenityAdapter.getFilter().filter(s);\n\t\t\t\t} else {\n\t\t\t\t\tif(searchPOILevel != null)  {\n\t\t\t\t\t\tsearchPOILevel.setEnabled(true);\n\t\t\t\t\t\tsearchPOILevel.setTitle(R.string.search_button);\n\t\t\t\t\t}\n\t\t\t\t\tsearchFooterButton.setEnabled(true);\n\t\t\t\t\tsearchFooterButton.setText(R.string.search_button);\n\t\t\t\t\t// Cancel current search request here?\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\n\t\t\t}\n\t\t});\n\t\tsearchFilter.setOnFocusChangeListener(new View.OnFocusChangeListener() {\n\t\t\t@Override\n\t\t\tpublic void onFocusChange(View v, boolean hasFocus) {\n\t\t\t\tif (hasFocus) {\n\t\t\t\t\tgetWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_VISIBLE);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\taddFooterView();\n\t\tamenityAdapter = new AmenityAdapter(new ArrayList<Amenity>());\n\t\tsetListAdapter(amenityAdapter);\n\n\t\tboolean light = getMyApplication().getSettings().isLightContent();\n\t\tDrawable arrowImage = getResources().getDrawable(R.drawable.ic_destination_arrow_white);\n\t\tif (light) {\n\t\t\tarrowImage.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t} else {\n\t\t\tarrowImage.setColorFilter(getResources().getColor(R.color.color_distance), PorterDuff.Mode.MULTIPLY);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}","commit_id":"ccbb4e262573edf0f86d24c6c51aa09da3bdd8fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\trow = inflater.inflate(R.layout.searchpoi_list, parent, false);\n\t\t\t}\n\t\t\tfloat[] mes = null;\n\t\t\tTextView label = (TextView) row.findViewById(R.id.poi_label);\n\t\t\tTextView distanceText = (TextView) row.findViewById(R.id.distance);\n\t\t\tImageView direction = (ImageView) row.findViewById(R.id.poi_direction);\n\t\t\tImageView icon = (ImageView) row.findViewById(R.id.poi_icon);\n\t\t\tAmenity amenity = getItem(position);\n\t\t\tnet.osmand.Location loc = location;\n\t\t\tif(loc != null){\n\t\t\t\tmes = new float[2];\n\t\t\t\tLatLon l = amenity.getLocation();\n\t\t\t\tnet.osmand.Location.distanceBetween(l.getLatitude(), l.getLongitude(), loc.getLatitude(), loc.getLongitude(), mes);\n\t\t\t}\n\t\t\tint opened = -1;\n\t\t\tif (amenity.getOpeningHours() != null) {\n\t\t\t\tOpeningHours rs = OpeningHoursParser.parseOpenedHours(amenity.getOpeningHours());\n\t\t\t\tif (rs != null) {\n\t\t\t\t\tCalendar inst = Calendar.getInstance();\n\t\t\t\t\tinst.setTimeInMillis(System.currentTimeMillis());\n\t\t\t\t\tboolean work = false;\n\t\t\t\t\twork = rs.isOpenedForTime(inst);\n\t\t\t\t\tif (work) {\n\t\t\t\t\t\topened = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topened = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(loc != null){\n\t\t\t\tDirectionDrawable draw = new DirectionDrawable(SearchPOIActivity.this, width, height, R.drawable.ic_destination_arrow);\n\t\t\t\tFloat h = heading;\n\t\t\t\tfloat a = h != null ? h : 0;\n\n\t\t\t\t//Hardy: getRotation() is the correction if device's screen orientation != the default display's standard orientation\n\t\t\t\tint screenOrientation = 0;\n\t\t\t\tscreenOrientation = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();\n\t\t\t\tswitch (screenOrientation)\n\t\t\t\t{\n\t\t\t\tcase ORIENTATION_0:   // Device default (normally portrait)\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_90:  // Landscape right\n\t\t\t\t\tscreenOrientation = 90;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_270: // Landscape left\n\t\t\t\t\tscreenOrientation = 270;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_180: // Upside down\n\t\t\t\t\tscreenOrientation = 180;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Looks like screenOrientation correction must not be applied for devices without compass?\n\t\t\t\tSensor compass  = ((SensorManager) getSystemService(Context.SENSOR_SERVICE)).getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\n\t\t\t\tif (compass == null) {\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t}\n\n\t\t\t\tdraw.setAngle(mes[1] - a + 180 + screenOrientation);\n\n\t\t\t\tdraw.setOpenedColor(opened);\n\t\t\t\tdirection.setImageDrawable(draw);\n\t\t\t} else {\n\t\t\t\tif(opened == -1){\n\t\t\t\t\tdirection.setImageResource(R.drawable.poi);\n\t\t\t\t} else if(opened == 0){\n\t\t\t\t\tdirection.setImageResource(R.drawable.opened_poi);\n\t\t\t\t} else {\n\t\t\t\t\tdirection.setImageResource(R.drawable.closed_poi);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder tag = new StringBuilder();\n\t\t\tStringBuilder value = new StringBuilder();\n\t\t\tMapRenderingTypes.getDefault().getAmenityTagValue(amenity.getType(), amenity.getSubType(),\n\t\t\t\t\ttag, value);\n\t\t\tif(RenderingIcons.containsBigIcon(tag + \"_\" + value)) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(tag + \"_\" + value));\n\t\t\t} else if(RenderingIcons.containsBigIcon(value.toString())) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(value.toString()));\n\t\t\t} else {\n\t\t\t\ticon.setImageDrawable(null);\n\t\t\t}\n\n\t\t\tString distance = \"  \";\n\t\t\tif(mes != null){\n\t\t\t\tdistance = \" \" + OsmAndFormatter.getFormattedDistance((int) mes[0], getMyApplication()) + \"  \"; //$NON-NLS-1$\n\t\t\t}\n\t\t\tString poiType = OsmAndFormatter.getPoiStringWithoutType(amenity, settings.usingEnglishNames());\n\t\t\tlabel.setText(poiType);\n\t\t\tdistanceText.setText(distance);\n\t\t\treturn (row);\n\t\t}","id":67433,"modified_method":"@Override\n\t\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\t\tView row = convertView;\n\t\t\tif (row == null) {\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\n\t\t\t\trow = inflater.inflate(R.layout.searchpoi_list, parent, false);\n\t\t\t}\n\t\t\tfloat[] mes = null;\n\t\t\tTextView label = (TextView) row.findViewById(R.id.poi_label);\n\t\t\tTextView distanceText = (TextView) row.findViewById(R.id.distance);\n\t\t\tImageView direction = (ImageView) row.findViewById(R.id.poi_direction);\n\t\t\tImageView icon = (ImageView) row.findViewById(R.id.poi_icon);\n\t\t\tAmenity amenity = getItem(position);\n\t\t\tnet.osmand.Location loc = location;\n\t\t\tif(loc != null){\n\t\t\t\tmes = new float[2];\n\t\t\t\tLatLon l = amenity.getLocation();\n\t\t\t\tnet.osmand.Location.distanceBetween(l.getLatitude(), l.getLongitude(), loc.getLatitude(), loc.getLongitude(), mes);\n\t\t\t}\n\t\t\tint opened = -1;\n\t\t\tif (amenity.getOpeningHours() != null) {\n\t\t\t\tOpeningHours rs = OpeningHoursParser.parseOpenedHours(amenity.getOpeningHours());\n\t\t\t\tif (rs != null) {\n\t\t\t\t\tCalendar inst = Calendar.getInstance();\n\t\t\t\t\tinst.setTimeInMillis(System.currentTimeMillis());\n\t\t\t\t\tboolean work = false;\n\t\t\t\t\twork = rs.isOpenedForTime(inst);\n\t\t\t\t\tif (work) {\n\t\t\t\t\t\topened = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\topened = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(loc != null){\n\t\t\t\tDirectionDrawable draw = new DirectionDrawable(SearchPOIActivity.this, width, height, R.drawable.ic_destination_arrow_white);\n\t\t\t\tFloat h = heading;\n\t\t\t\tfloat a = h != null ? h : 0;\n\n\t\t\t\t//Hardy: getRotation() is the correction if device's screen orientation != the default display's standard orientation\n\t\t\t\tint screenOrientation = 0;\n\t\t\t\tscreenOrientation = ((WindowManager) getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getRotation();\n\t\t\t\tswitch (screenOrientation)\n\t\t\t\t{\n\t\t\t\tcase ORIENTATION_0:   // Device default (normally portrait)\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_90:  // Landscape right\n\t\t\t\t\tscreenOrientation = 90;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_270: // Landscape left\n\t\t\t\t\tscreenOrientation = 270;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ORIENTATION_180: // Upside down\n\t\t\t\t\tscreenOrientation = 180;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t//Looks like screenOrientation correction must not be applied for devices without compass?\n\t\t\t\tSensor compass  = ((SensorManager) getSystemService(Context.SENSOR_SERVICE)).getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD);\n\t\t\t\tif (compass == null) {\n\t\t\t\t\tscreenOrientation = 0;\n\t\t\t\t}\n\n\t\t\t\tdraw.setAngle(mes[1] - a + 180 + screenOrientation);\n\n\t\t\t\tdraw.setOpenedColor(opened);\n\t\t\t\tdirection.setImageDrawable(draw);\n\t\t\t} else {\n\t\t\t\tif(opened == -1){\n\t\t\t\t\tdirection.setImageResource(R.drawable.poi);\n\t\t\t\t} else if(opened == 0){\n\t\t\t\t\tdirection.setImageResource(R.drawable.opened_poi);\n\t\t\t\t} else {\n\t\t\t\t\tdirection.setImageResource(R.drawable.closed_poi);\n\t\t\t\t}\n\t\t\t}\n\t\t\tStringBuilder tag = new StringBuilder();\n\t\t\tStringBuilder value = new StringBuilder();\n\t\t\tMapRenderingTypes.getDefault().getAmenityTagValue(amenity.getType(), amenity.getSubType(),\n\t\t\t\t\ttag, value);\n\t\t\tif(RenderingIcons.containsBigIcon(tag + \"_\" + value)) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(tag + \"_\" + value));\n\t\t\t} else if(RenderingIcons.containsBigIcon(value.toString())) {\n\t\t\t\ticon.setImageResource(RenderingIcons.getBigIconResourceId(value.toString()));\n\t\t\t} else {\n\t\t\t\ticon.setImageDrawable(null);\n\t\t\t}\n\n\t\t\tString distance = \"  \";\n\t\t\tif(mes != null){\n\t\t\t\tdistance = \" \" + OsmAndFormatter.getFormattedDistance((int) mes[0], getMyApplication()) + \"  \"; //$NON-NLS-1$\n\t\t\t}\n\t\t\tString poiType = OsmAndFormatter.getPoiStringWithoutType(amenity, settings.usingEnglishNames());\n\t\t\tlabel.setText(poiType);\n\t\t\tdistanceText.setText(distance);\n\t\t\treturn (row);\n\t\t}","commit_id":"ccbb4e262573edf0f86d24c6c51aa09da3bdd8fe","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsuper.onCreate(savedInstanceState);\n\n\n\t\tsetContentView(R.layout.tab_content);\n\t\tOsmandSettings settings = ((OsmandApplication) getApplication()).getSettings();\n\t\ttabHost = (TabHost) findViewById(android.R.id.tabhost);\n\t\ttabHost.setup();\n\t\tViewPager viewPager = (ViewPager) findViewById(R.id.pager);\n\t\tmTabsAdapter = new FavouritesActivity.TabsAdapter(this, tabHost, viewPager, settings);\n\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"LOCAL_INDEX\").setIndicator(\"Local\"),\n\t\t\t\tLocalIndexesFragment.class, null);\n\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"DOWNLOADS\").setIndicator(\"Downloads\"),\n\t\t\t\tDownloadIndexFragment.class, null);\n\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"UPDATES\").setIndicator(\"Updates\"),\n\t\t\t\tUpdatesIndexFragment.class, null);\n\t\ttabHost.setCurrentTab(0);\n\n\t\tif(downloadListIndexThread == null) {\n\t\t\tdownloadListIndexThread = new DownloadIndexesThread(this);\n\t\t}\n\t\tif (downloadListIndexThread.getCachedIndexFiles() != null && downloadListIndexThread.isDownloadedFromInternet()) {\n\t\t\tdownloadListIndexThread.runCategorization(type);\n\t\t} else {\n\t\t\tdownloadListIndexThread.runReloadIndexFiles();\n\t\t}\n\n\t\tsettings = ((OsmandApplication)getApplication()).getSettings();\n\n\t\tindeterminateProgressBar = (ProgressBar) findViewById(R.id.IndeterminateProgressBar);\n\t\tdeterminateProgressBar = (ProgressBar) findViewById(R.id.DeterminateProgressBar);\n\t\tprogressView = findViewById(R.id.ProgressView);\n\t\tprogressMessage = (TextView) findViewById(R.id.ProgressMessage);\n\t\tprogressPercent = (TextView) findViewById(R.id.ProgressPercent);\n\t\tcancel = (ImageView) findViewById(R.id.Cancel);\n\t\tint d = settings.isLightContent() ? R.drawable.a_1_navigation_cancel_small_light : R.drawable.a_1_navigation_cancel_small_dark;\n\t\tcancel.setImageDrawable(getResources().getDrawable(d));\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tmakeSureUserCancelDownload();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.DownloadButton).setOnClickListener(new View.OnClickListener(){\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdownloadFilesCheckFreeVersion();\n\t\t\t}\n\n\t\t});\n\n\t\tfinal List<DownloadActivityType> downloadTypes = getDownloadTypes();\n\t\tfinal Intent intent = getIntent();\n\t\tsetType(downloadTypes.get(0));\n\t\tif (intent != null && intent.getExtras() != null) {\n\t\t\tfinal String filter = intent.getExtras().getString(FILTER_KEY);\n//\t\t\tif (filter != null) {\n//\t\t\t\tfilterText.setText(filter);\n//\t\t\t}\n\t\t\tfinal String filterCat = intent.getExtras().getString(FILTER_CAT);\n\t\t\tif (filterCat != null) {\n\t\t\t\tDownloadActivityType type = DownloadActivityType.getIndexType(filterCat.toLowerCase());\n\t\t\t\tif (type != null) {\n\t\t\t\t\tsetType(type);\n\t\t\t\t\tdownloadTypes.remove(type);\n\t\t\t\t\tdownloadTypes.add(0, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgetSupportActionBar().setHomeButtonEnabled(true);\n\t\tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n\t}","id":67434,"modified_method":"@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tgetMyApplication().applyTheme(this);\n\t\tsuper.onCreate(savedInstanceState);\n\t\trequestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);\n\t\tsetProgressBarIndeterminateVisibility(false);\n\n\t\tsetContentView(R.layout.tab_content);\n\t\tOsmandSettings settings = ((OsmandApplication) getApplication()).getSettings();\n\t\ttabHost = (TabHost) findViewById(android.R.id.tabhost);\n\t\ttabHost.setup();\n\t\tViewPager viewPager = (ViewPager) findViewById(R.id.pager);\n\t\tmTabsAdapter = new FavouritesActivity.TabsAdapter(this, tabHost, viewPager, settings);\n\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"LOCAL_INDEX\").setIndicator(\"Local\"),\n\t\t\t\tLocalIndexesFragment.class, null);\n\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"DOWNLOADS\").setIndicator(\"Downloads\"),\n\t\t\t\tDownloadIndexFragment.class, null);\n\t\tmTabsAdapter.addTab(tabHost.newTabSpec(\"UPDATES\").setIndicator(\"Updates\"),\n\t\t\t\tUpdatesIndexFragment.class, null);\n\t\ttabHost.setCurrentTab(0);\n\n\t\tif(downloadListIndexThread == null) {\n\t\t\tdownloadListIndexThread = new DownloadIndexesThread(this);\n\t\t}\n\t\tif (downloadListIndexThread.getCachedIndexFiles() != null && downloadListIndexThread.isDownloadedFromInternet()) {\n\t\t\tdownloadListIndexThread.runCategorization(type);\n\t\t} else {\n\t\t\tdownloadListIndexThread.runReloadIndexFiles();\n\t\t}\n\n\t\tsettings = ((OsmandApplication)getApplication()).getSettings();\n\n\t\tindeterminateProgressBar = (ProgressBar) findViewById(R.id.IndeterminateProgressBar);\n\t\tdeterminateProgressBar = (ProgressBar) findViewById(R.id.DeterminateProgressBar);\n\t\tprogressView = findViewById(R.id.ProgressView);\n\t\tprogressMessage = (TextView) findViewById(R.id.ProgressMessage);\n\t\tprogressPercent = (TextView) findViewById(R.id.ProgressPercent);\n\t\tcancel = (ImageView) findViewById(R.id.Cancel);\n\t\tint d = settings.isLightContent() ? R.drawable.a_1_navigation_cancel_small_light : R.drawable.a_1_navigation_cancel_small_dark;\n\t\tcancel.setImageDrawable(getResources().getDrawable(d));\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tmakeSureUserCancelDownload();\n\t\t\t}\n\t\t});\n\n\t\tfindViewById(R.id.DownloadButton).setOnClickListener(new View.OnClickListener(){\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tdownloadFilesCheckFreeVersion();\n\t\t\t}\n\n\t\t});\n\n\t\tfinal List<DownloadActivityType> downloadTypes = getDownloadTypes();\n\t\tfinal Intent intent = getIntent();\n\t\tsetType(downloadTypes.get(0));\n\t\tif (intent != null && intent.getExtras() != null) {\n\t\t\tfinal String filter = intent.getExtras().getString(FILTER_KEY);\n//\t\t\tif (filter != null) {\n//\t\t\t\tfilterText.setText(filter);\n//\t\t\t}\n\t\t\tfinal String filterCat = intent.getExtras().getString(FILTER_CAT);\n\t\t\tif (filterCat != null) {\n\t\t\t\tDownloadActivityType type = DownloadActivityType.getIndexType(filterCat.toLowerCase());\n\t\t\t\tif (type != null) {\n\t\t\t\t\tsetType(type);\n\t\t\t\t\tdownloadTypes.remove(type);\n\t\t\t\t\tdownloadTypes.add(0, type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tgetSupportActionBar().setHomeButtonEnabled(true);\n\t\tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n\t}","commit_id":"c76d5a021b9b8071e33b0794fedadb6d48a3c7b7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n\n\t\tActionBar actionBar = getDownloadActivity().getSupportActionBar();\n\t\t//hide action bar from downloadindexfragment\n\t\tactionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);\n\t\toptionsMenuAdapter = new ContextMenuAdapter(getDownloadActivity());\n\t\tOnContextMenuClick listener = new OnContextMenuClick() {\n\t\t\t@Override\n\t\t\tpublic void onContextMenuClick(int itemId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\tlocalOptionsMenu(itemId);\n\t\t\t}\n\t\t};\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_reload)\n\t\t\t\t\t\t.icons(R.drawable.ic_action_refresh_dark, R.drawable.ic_action_refresh_light)\n\t\t\t\t\t\t.listen(listener).position(1).reg();\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_backup)\n\t\t\t\t\t\t.icons(R.drawable.ic_action_undo_dark, R.drawable.ic_action_undo_light)\n\t\t\t\t\t\t.listen(listener).position(2).reg();\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_restore)\n\t\t\t\t.icons(R.drawable.ic_action_redo_dark, R.drawable.ic_action_redo_dark)\n\t\t\t\t\t\t.listen(listener).position(3).reg();\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_delete)\n\t\t\t\t\t\t.icons(R.drawable.ic_action_delete_dark, R.drawable.ic_action_delete_light)\n\t\t\t\t\t\t.listen(listener).position(4).reg();\n\t\tOsmandPlugin.onOptionsMenuActivity(getDownloadActivity(), null, optionsMenuAdapter);\n\t\t// doesn't work correctly\n\t\tint max =  getResources().getInteger(R.integer.abs__max_action_buttons);\n\t\tSubMenu split = null;\n\t\tfor (int j = 0; j < optionsMenuAdapter.length(); j++) {\n\t\t\tMenuItem item;\n\t\t\tif (j + 1 >= max && optionsMenuAdapter.length() > max) {\n\t\t\t\tif (split == null) {\n\t\t\t\t\tsplit = menu.addSubMenu(0, 1, 0, R.string.default_buttons_other_actions);\n\t\t\t\t\tsplit.setIcon(isLightActionBar() ? R.drawable.abs__ic_menu_moreoverflow_holo_light\n\t\t\t\t\t\t\t: R.drawable.abs__ic_menu_moreoverflow_holo_dark);\n\t\t\t\t\tsplit.getItem().setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\t\t}\n\t\t\t\titem = split.add(0, optionsMenuAdapter.getItemId(j), j + 1, optionsMenuAdapter.getItemName(j));\n\t\t\t\titem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM );\n\t\t\t} else {\n\t\t\t\titem = menu.add(0, optionsMenuAdapter.getItemId(j), j + 1, optionsMenuAdapter.getItemName(j));\n\t\t\t\titem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM  \n\t\t\t\t\t\t);\n\t\t\t}\n\t\t\tif (optionsMenuAdapter.getImageId(j, isLightActionBar()) != 0) {\n\t\t\t\titem.setIcon(optionsMenuAdapter.getImageId(j, isLightActionBar()));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(operationTask == null || operationTask.getStatus() == AsyncTask.Status.FINISHED){\n\t\t\tmenu.setGroupVisible(0, true);\n\t\t} else {\n\t\t\tmenu.setGroupVisible(0, false);\n\t\t}\n\t}","id":67435,"modified_method":"@Override\n\tpublic void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n\t\t//fixes issue when local files not shown after switching tabs\n\t\treloadIndexes();\n\t\tActionBar actionBar = getDownloadActivity().getSupportActionBar();\n\t\t//hide action bar from downloadindexfragment\n\t\tactionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);\n\t\toptionsMenuAdapter = new ContextMenuAdapter(getDownloadActivity());\n\t\tOnContextMenuClick listener = new OnContextMenuClick() {\n\t\t\t@Override\n\t\t\tpublic void onContextMenuClick(int itemId, int pos, boolean isChecked, DialogInterface dialog) {\n\t\t\t\tlocalOptionsMenu(itemId);\n\t\t\t}\n\t\t};\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_reload)\n\t\t\t\t\t\t.icons(R.drawable.ic_action_refresh_dark, R.drawable.ic_action_refresh_light)\n\t\t\t\t\t\t.listen(listener).position(1).reg();\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_backup)\n\t\t\t\t\t\t.icons(R.drawable.ic_action_undo_dark, R.drawable.ic_action_undo_light)\n\t\t\t\t\t\t.listen(listener).position(2).reg();\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_restore)\n\t\t\t\t.icons(R.drawable.ic_action_redo_dark, R.drawable.ic_action_redo_dark)\n\t\t\t\t\t\t.listen(listener).position(3).reg();\n\t\toptionsMenuAdapter.item(R.string.local_index_mi_delete)\n\t\t\t\t\t\t.icons(R.drawable.ic_action_delete_dark, R.drawable.ic_action_delete_light)\n\t\t\t\t\t\t.listen(listener).position(4).reg();\n\t\tOsmandPlugin.onOptionsMenuActivity(getDownloadActivity(), null, optionsMenuAdapter);\n\t\t// doesn't work correctly\n\t\tint max =  getResources().getInteger(R.integer.abs__max_action_buttons);\n\t\tSubMenu split = null;\n\t\tfor (int j = 0; j < optionsMenuAdapter.length(); j++) {\n\t\t\tMenuItem item;\n\t\t\tif (j + 1 >= max && optionsMenuAdapter.length() > max) {\n\t\t\t\tif (split == null) {\n\t\t\t\t\tsplit = menu.addSubMenu(0, 1, 0, R.string.default_buttons_other_actions);\n\t\t\t\t\tsplit.setIcon(isLightActionBar() ? R.drawable.abs__ic_menu_moreoverflow_holo_light\n\t\t\t\t\t\t\t: R.drawable.abs__ic_menu_moreoverflow_holo_dark);\n\t\t\t\t\tsplit.getItem().setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);\n\t\t\t\t}\n\t\t\t\titem = split.add(0, optionsMenuAdapter.getItemId(j), j + 1, optionsMenuAdapter.getItemName(j));\n\t\t\t\titem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM );\n\t\t\t} else {\n\t\t\t\titem = menu.add(0, optionsMenuAdapter.getItemId(j), j + 1, optionsMenuAdapter.getItemName(j));\n\t\t\t\titem.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM  \n\t\t\t\t\t\t);\n\t\t\t}\n\t\t\tif (optionsMenuAdapter.getImageId(j, isLightActionBar()) != 0) {\n\t\t\t\titem.setIcon(optionsMenuAdapter.getImageId(j, isLightActionBar()));\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tif(operationTask == null || operationTask.getStatus() == AsyncTask.Status.FINISHED){\n\t\t\tmenu.setGroupVisible(0, true);\n\t\t} else {\n\t\t\tmenu.setGroupVisible(0, false);\n\t\t}\n\t}","commit_id":"c76d5a021b9b8071e33b0794fedadb6d48a3c7b7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tView v = convertView;\n\n\t\t\tif(v == null){\n\t\t\t\tLayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t\t\t\tv = inflater.inflate(R.layout.download_index_list_item, null);\n\t\t\t}\n\n\t\t\tTextView name = (TextView) v.findViewById(R.id.download_item);\n\t\t\tTextView description = (TextView) v.findViewById(R.id.download_descr);\n\t\t\tIndexItem e = items.get(position);\n\t\t\tString eName = e.getVisibleDescription(getMyApplication()) + \"\\n\" + e.getVisibleName(getMyApplication(), osmandRegions);\n\t\t\tname.setText(eName.trim()); //$NON-NLS-1$\n\t\t\tString d = e.getDate(format) + \"\\n\" + e.getSizeDescription(getMyApplication());\n\t\t\tdescription.setText(d);\n\n\t\t\tfinal CheckBox ch = (CheckBox) v.findViewById(R.id.check_download_item);\n\t\t\tch.setChecked(getDownloadActivity().getEntriesToDownload().containsKey(e));\n\t\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\tfinal IndexItem e = (IndexItem) getListAdapter().getItem(position);\n\t\t\t\t\tif(ch.isChecked()){\n\t\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\t\tgetDownloadActivity().getEntriesToDownload().remove(e);\n\t\t\t\t\t\tgetDownloadActivity().updateDownloadButton(true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tList<DownloadEntry> download = e.createDownloadEntry(getMyApplication(), getDownloadActivity().getType(), new ArrayList<DownloadEntry>());\n\t\t\t\t\tif (download.size() > 0) {\n\t\t\t\t\t\tgetDownloadActivity().getEntriesToDownload().put(e, download);\n\t\t\t\t\t\tgetDownloadActivity().updateDownloadButton(true);\n\t\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn v;\n\t\t}","id":67436,"modified_method":"@Override\n\t\tpublic View getView(final int position, View convertView, ViewGroup parent) {\n\t\t\tView v = convertView;\n\n\t\t\tif(v == null){\n\t\t\t\tLayoutInflater inflater = (LayoutInflater) getDownloadActivity().getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n\t\t\t\tv = inflater.inflate(R.layout.download_index_list_item, null);\n\t\t\t}\n\n\t\t\tTextView name = (TextView) v.findViewById(R.id.download_item);\n\t\t\tTextView description = (TextView) v.findViewById(R.id.download_descr);\n\t\t\tIndexItem e = items.get(position);\n\t\t\tString eName = e.getVisibleName(getMyApplication(), osmandRegions);\n\t\t\tname.setText(eName.trim()); //$NON-NLS-1$\n\t\t\tString d = e.getDate(format) + \"\\n\" + e.getSizeDescription(getMyApplication());\n\t\t\tdescription.setText(d);\n\n\t\t\tfinal CheckBox ch = (CheckBox) v.findViewById(R.id.check_download_item);\n\t\t\tch.setChecked(getDownloadActivity().getEntriesToDownload().containsKey(e));\n\t\t\tch.setOnClickListener(new View.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\tfinal IndexItem e = (IndexItem) getListAdapter().getItem(position);\n\t\t\t\t\tif(ch.isChecked()){\n\t\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\t\tgetDownloadActivity().getEntriesToDownload().remove(e);\n\t\t\t\t\t\tgetDownloadActivity().updateDownloadButton(true);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tList<DownloadEntry> download = e.createDownloadEntry(getMyApplication(), getDownloadActivity().getType(), new ArrayList<DownloadEntry>());\n\t\t\t\t\tif (download.size() > 0) {\n\t\t\t\t\t\tgetDownloadActivity().getEntriesToDownload().put(e, download);\n\t\t\t\t\t\tgetDownloadActivity().updateDownloadButton(true);\n\t\t\t\t\t\tch.setChecked(!ch.isChecked());\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn v;\n\t\t}","commit_id":"c76d5a021b9b8071e33b0794fedadb6d48a3c7b7","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\tpublic String[] getGridServiceAgentZones() {\n\t\treturn properties.getArray(\n\t\t\t\tZONES_KEY, ZONES_SEPARATOR, ZONES_DEFAULT);\n\t}","id":67437,"modified_method":"@Override\n\tpublic AtLeastOneZoneConfig getGridServiceAgentZones() {\n\t\tString[] zones = properties.getArray(\n\t\t\t\tZONES_KEY, ZONES_SEPARATOR, ZONES_DEFAULT);\n\t\treturn new AtLeastOneZoneConfigurer().addZones(zones).create();\n\t}","commit_id":"4596abfa3d5150c7c0543359b86f648a2e5a3947","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic GridServiceAgent startMachine(final Set<String> zones, final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\n\t\tlogger.info(\"Cloudify Adapter is starting a new machine\");\n\t\t// calculate timeout\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\t// provision the machine\n\t\tlogger.info(\"Calling provisioning implementation for new machine\");\n\t\tMachineDetails machineDetails;\n\t\ttry {\n\t\t\tcloudifyProvisioning.setAdmin(getGlobalAdminInstance(originalESMAdmin));\n\t\t\t\n\t\t\tList<String> defaultZones = Arrays.asList(config.getGridServiceAgentZones());\t\t\t\n\t\t\t\n\t\t\tList<String> cloudZones = new ArrayList<String>();\n\t\t\t\n\t\t\tfor (String zone : zones) {\n\t\t\t\tif (zone.startsWith(CLOUD_ZONE_PREFIX)) {\n\t\t\t\t\tcloudZones.add(zone.substring(CLOUD_ZONE_PREFIX.length(), zone.length() - 1));\n\t\t\t\t} else {\n\t\t\t\t\tif (!defaultZones.contains(zone)) {\n\t\t\t\t\t\tthrow new UnsupportedOperationException(\"discovered an unsupported zone for machine allocation : \" + zone);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t\tif (cloudZones.size() != 0) {\n\t\t\t\t\n\t\t\t\t// to support choosing from many availability zones.\n\t\t\t\t// logic goes here to choose exactly which one. \n\t\t\t\t// for now just take the first one.\n\t\t\t\tmachineDetails = provisionMachine(cloudZones.get(0), duration, unit); \n\t\t\t\t\n\t\t\t} \n\t\t\tif (cloudZones.size() > 1) {\n\t\t\t\tthrow new UnsupportedOperationException(\"found multiple zones for machine allocation : \" + cloudZones);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmachineDetails = provisionMachine(duration, unit);\n\t\t\t}\n\t\t\t\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.WARNING, \"Failed to provision machine, reason: \" + e.getMessage(), e);\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to provisiong machine: \" + e.getMessage(), e);\n\t\t}\n\n\t\tlogger.info(\"Machine was provisioned by implementation. Machine is: \" + machineDetails);\n\n\t\t// which IP should be used in the cluster\n\t\tString machineIp;\n\t\tif (cloud.getConfiguration().isConnectToPrivateIp()) {\n\t\t\tmachineIp = machineDetails.getPrivateAddress();\n\t\t} else {\n\t\t\tmachineIp = machineDetails.getPublicAddress();\n\t\t}\n\t\ttry {\n\t\t\t// check for timeout\n\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\n\t\t\tif (machineDetails.isAgentRunning()) {\n\t\t\t\tlogger.info(\"Machine provisioning provided a machine and indicated that an agent is already running\");\n\t\t\t} else {\n\t\t\t\t// install gigaspaces and start agent\n\t\t\t\tlogger.info(\"Cloudify Adapter is installing Cloudify on new machine\");\n\t\t\t\tinstallAndStartAgent(machineDetails, end);\n\t\t\t\t// check for timeout again - the installation step can also take a\n\t\t\t\t// while to complete.\n\t\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\n\t\t\t}\n\n\t\t\t// There is another case here, that we do not handle - where the started image\n\t\t\t// has the cloudify distro, but the agent is not running. This means we should\n\t\t\t// run a modified remote execution script. Not sure if we really need this, though,\n\t\t\t// as this scenario really does not offer a better experience. If required, handling will\n\t\t\t// be added here.\n\n\t\t\tif (machineIp == null) {\n\t\t\t\tthrow new IllegalArgumentException(\"The IP of the new machine is null! Machine Details are: \"\n\t\t\t\t\t\t+ machineDetails + \" .\");\n\t\t\t}\n\t\t\t// wait for GSA to become available\n\t\t\tlogger.info(\"Cloudify adapter is waiting for GSA to become available\");\n\t\t\tfinal GridServiceAgent gsa = waitForGsa(machineIp, end);\n\t\t\tif (gsa == null) {\n\t\t\t\t// GSA did not start correctly or on time - shutdown the machine\n\t\t\t\t// handleGSANotFound(machineIp);\n\t\t\t\tthrow new TimeoutException(\"New machine was provisioned and Cloudify was installed, \"\n\t\t\t\t\t\t+ \"but a GSA was not discovered on the new machine: \" + machineDetails);\n\t\t\t}\n\t\t\treturn gsa;\n\t\t} catch (final ElasticMachineProvisioningException e) {\n\t\t\tlogger.info(\"ElasticMachineProvisioningException occurred, \" + e.getMessage());\n\t\t\tlogger.info(ExceptionUtils.getFullStackTrace(e));\n\t\t\thandleExceptionAfterMachineCreated(machineIp, machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final TimeoutException e) {\n\t\t\tlogger.info(\"TimeoutException occurred, \" + e.getMessage());\n\t\t\tlogger.info(ExceptionUtils.getFullStackTrace(e));\n\t\t\thandleExceptionAfterMachineCreated(machineIp, machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final InterruptedException e) {\n\t\t\tlogger.info(\"InterruptedException occurred, \" + e.getMessage());\n\t\t\tlogger.info(ExceptionUtils.getFullStackTrace(e));\n\t\t\thandleExceptionAfterMachineCreated(machineIp, machineDetails, end);\n\t\t\tthrow e;\n\t\t}\n\n\t}","id":67438,"modified_method":"@Override\n\tpublic GridServiceAgent startMachine(final ExactZonesConfig zones, final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\n\t\tlogger.info(\"Cloudify Adapter is starting a new machine\");\n\t\t// calculate timeout\n\t\tfinal long end = System.currentTimeMillis() + unit.toMillis(duration);\n\n\t\t// provision the machine\n\t\tlogger.info(\"Calling provisioning implementation for new machine\");\n\t\tMachineDetails machineDetails;\n\t\tcloudifyProvisioning.setAdmin(getGlobalAdminInstance(originalESMAdmin));\n\t\t\n\t\tAtLeastOneZoneConfig defaultZones = config.getGridServiceAgentZones();\t\t\t\n\t\tif (!defaultZones.satisfiedBy(zones)) {\n\t\t\tthrow new IllegalArgumentException(\"The specified zones \" + zones + \" does not satisfy the configuration zones \" + defaultZones);\n\t\t}\n\t\t\n\t\tString locationId = null;\n\t\t\n\t\tfor (String zone : zones.getZones()) {\n\t\t\tif (zone.startsWith(CLOUD_ZONE_PREFIX)) {\n\t\t\t\tif (locationId == null) {\n\t\t\t\t\tlocationId = zone.substring(CLOUD_ZONE_PREFIX.length());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"The specified zones \" + zones + \" should include only one zone with the \" + CLOUD_ZONE_PREFIX + \" prefix:\" + locationId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tif (locationId != null) {\n\t\t\t\tmachineDetails = provisionMachine(locationId, duration, unit); \n\t\t\t}\n\t\t\telse {\n\t\t\t\tmachineDetails = provisionMachine(duration, unit);\n\t\t\t}\t\t\t\n\t\t} catch (final Exception e) {\n\t\t\tlogger.log(Level.WARNING, \"Failed to provision machine, reason: \" + e.getMessage(), e);\n\t\t\tthrow new ElasticMachineProvisioningException(\"Failed to provisiong machine: \" + e.getMessage(), e);\n\t\t}\n\n\t\tlogger.info(\"Machine was provisioned by implementation. Machine is: \" + machineDetails);\n\n\t\t// which IP should be used in the cluster\n\t\tString machineIp;\n\t\tif (cloud.getConfiguration().isConnectToPrivateIp()) {\n\t\t\tmachineIp = machineDetails.getPrivateAddress();\n\t\t} else {\n\t\t\tmachineIp = machineDetails.getPublicAddress();\n\t\t}\n\t\tif (machineIp == null) {\n\t\t\tthrow new IllegalStateException(\"The IP of the new machine is null! Machine Details are: \"\n\t\t\t\t\t+ machineDetails + \" .\");\n\t\t}\n\t\t\n\t\ttry {\n\t\t\t// check for timeout\n\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\n\t\t\tif (machineDetails.isAgentRunning()) {\n\t\t\t\tlogger.info(\"Machine provisioning provided a machine and indicated that an agent is already running\");\n\t\t\t} else {\n\t\t\t\t// install gigaspaces and start agent\n\t\t\t\tlogger.info(\"Cloudify Adapter is installing Cloudify on new machine\");\n\t\t\t\tinstallAndStartAgent(machineDetails, end);\n\t\t\t\t// check for timeout again - the installation step can also take a\n\t\t\t\t// while to complete.\n\t\t\t\tcheckForProvisioningTimeout(end, machineDetails);\n\t\t\t}\n\n\t\t\t// There is another case here, that we do not handle - where the started image\n\t\t\t// has the cloudify distro, but the agent is not running. This means we should\n\t\t\t// run a modified remote execution script. Not sure if we really need this, though,\n\t\t\t// as this scenario really does not offer a better experience. If required, handling will\n\t\t\t// be added here.\n\n\t\t\t// wait for GSA to become available\n\t\t\tlogger.info(\"Cloudify adapter is waiting for GSA to become available\");\n\t\t\tfinal GridServiceAgent gsa = waitForGsa(machineIp, end);\n\t\t\tif (gsa == null) {\n\t\t\t\t// GSA did not start correctly or on time - shutdown the machine\n\t\t\t\t// handleGSANotFound(machineIp);\n\t\t\t\tthrow new TimeoutException(\"New machine was provisioned and Cloudify was installed, \"\n\t\t\t\t\t\t+ \"but a GSA was not discovered on the new machine: \" + machineDetails);\n\t\t\t}\n\t\t\treturn gsa;\n\t\t} catch (final ElasticMachineProvisioningException e) {\n\t\t\tlogger.info(\"ElasticMachineProvisioningException occurred, \" + e.getMessage());\n\t\t\tlogger.info(ExceptionUtils.getFullStackTrace(e));\n\t\t\thandleExceptionAfterMachineCreated(machineIp, machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final TimeoutException e) {\n\t\t\tlogger.info(\"TimeoutException occurred, \" + e.getMessage());\n\t\t\tlogger.info(ExceptionUtils.getFullStackTrace(e));\n\t\t\thandleExceptionAfterMachineCreated(machineIp, machineDetails, end);\n\t\t\tthrow e;\n\t\t} catch (final InterruptedException e) {\n\t\t\tlogger.info(\"InterruptedException occurred, \" + e.getMessage());\n\t\t\tlogger.info(ExceptionUtils.getFullStackTrace(e));\n\t\t\thandleExceptionAfterMachineCreated(machineIp, machineDetails, end);\n\t\t\tthrow e;\n\t\t}\n\n\t}","commit_id":"4596abfa3d5150c7c0543359b86f648a2e5a3947","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"private InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md)\n\t\t\tthrows FileNotFoundException {\n\t\tfinal CloudTemplate template = this.cloud.getTemplates().get(this.cloudTemplateName);\n\t\t\n\t\t// these are the default zone for a VM (aka service-name).\n\t\tfinal String[] zones = this.config.getGridServiceAgentZones();\n\t\t\n\t\t// append a unique prefix to the location id. this is to distinguish this zone from the default zone which is the service name.\n\t\t// TODO - remove the service name from the machine zone. in the case of cloudify, agent zones should be only their physical location.\n\t\tmd.setLocationId(CLOUD_ZONE_PREFIX + md.getLocationId()); \n\t\t\n\t\tfinal InstallationDetails details =\n\t\t\t\tUtils.createInstallationDetails(md, cloud, template, zones, lookupLocatorsString,\n\t\t\t\t\t\tthis.originalESMAdmin, false,\n\t\t\t\t\t\tnull);\n\n\t\tlogger.info(\"Created new Installation Details: \" + details);\n\t\treturn details;\n\n\t}","id":67439,"modified_method":"private InstallationDetails createInstallationDetails(final Cloud cloud, final MachineDetails md)\n\t\t\tthrows FileNotFoundException {\n\t\tfinal CloudTemplate template = this.cloud.getTemplates().get(this.cloudTemplateName);\n\t\t\n\t\t// Start with the default zone that are also used for discovering agents \n\t\t// By default cloudify puts the service-name as the zone.\n\t\t// We then add the location of the machine to the zone, so if it fails the ESM starts it with these zones\n\t\t// and this adapter can look for the CLOUD_ZONE_PREFIX and start a machine with the same location.\n\t\t// TODO Fix GS-9484 and then remove the service name from the machine zone and remove the CLOUD_ZONE_PREFIX.\n\t\t\t\t\n\t\tfinal ExactZonesConfig zones = \n\t\t\t\tnew ExactZonesConfigurer()\n\t\t\t\t.addZones(config.getGridServiceAgentZones().getZones())\n\t\t\t\t.addZone(CLOUD_ZONE_PREFIX + md.getLocationId())\n\t\t\t\t.create();\n\t\t\n\t\tfinal InstallationDetails details =\n\t\t\t\tUtils.createInstallationDetails(md, cloud, template, zones, lookupLocatorsString,\n\t\t\t\t\t\tthis.originalESMAdmin, false,\n\t\t\t\t\t\tnull);\n\n\t\tlogger.info(\"Created new Installation Details: \" + details);\n\t\treturn details;\n\n\t}","commit_id":"4596abfa3d5150c7c0543359b86f648a2e5a3947","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic void afterPropertiesSet()\n\t\t\tthrows Exception {\n\n\t\tfinal String[] zones = this.config.getGridServiceAgentZones();\n\t\tlogger = java.util.logging.Logger\n\t\t\t\t.getLogger(ElasticMachineProvisioningCloudifyAdapter.class.getName() + \"-\" + Arrays.toString(zones));\n\n\t\tfinal String cloudContents = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_CONFIGURATION);\n\t\tif (cloudContents == null) {\n\t\t\tthrow new IllegalArgumentException(\"Cloud configuration was not set!\");\n\t\t}\n\n\t\ttry {\n\t\t\tthis.cloud = ServiceReader.readCloud(cloudContents);\n\t\t\tthis.cloudTemplateName = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_TEMPLATE_NAME);\n\n\t\t\tif (this.cloudTemplateName == null) {\n\t\t\t\tthrow new BeanConfigurationException(\"Cloud template was not set!\");\n\t\t\t}\n\n\t\t\tfinal CloudTemplate cloudTemplate = this.cloud.getTemplates().get(this.cloudTemplateName);\n\t\t\tif (cloudTemplate == null) {\n\t\t\t\tthrow new BeanConfigurationException(\"The provided cloud template name: \" + this.cloudTemplateName\n\t\t\t\t\t\t+ \" was not found in the cloud configuration\");\n\t\t\t}\n\n\t\t\t// This code runs on the ESM in the remote machine,\n\t\t\t// so set the local directory to the value of the remote directory\n\t\t\tlogger.info(\"Remote Directory is: \" + cloudTemplate.getRemoteDirectory());\n\t\t\tif (ServiceUtils.isWindows()) {\n\t\t\t\tlogger.info(\"Windows machine - modifying local directory location\");\n\t\t\t\tString localDirectoryName = cloudTemplate.getRemoteDirectory();\n\t\t\t\tlocalDirectoryName = localDirectoryName.replace(\"$\", \"\");\n\t\t\t\tif (localDirectoryName.startsWith(\"/\")) {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tif (localDirectoryName.charAt(1) == '/') {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(0, 1) + \":\" + localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tlogger.info(\"Modified local dir name is: \" + localDirectoryName);\n\n\t\t\t\tcloudTemplate.setLocalDirectory(localDirectoryName);\n\t\t\t} else {\n\t\t\t\tcloudTemplate.setLocalDirectory(cloudTemplate.getRemoteDirectory());\n\t\t\t}\n\n\t\t\t// load the provisioning class and set it up\n\t\t\ttry {\n\t\t\t\tthis.cloudifyProvisioning =\n\t\t\t\t\t\t(ProvisioningDriver) Class.forName(this.cloud.getConfiguration().getClassName()).newInstance();\n\n\t\t\t\tif (cloudifyProvisioning instanceof ProvisioningDriverClassContextAware) {\n\t\t\t\t\tfinal ProvisioningDriverClassContext provisioningDriverContext =\n\t\t\t\t\t\t\tlazyCreateProvisioningDriverClassContext(cloudifyProvisioning);\n\t\t\t\t\tfinal ProvisioningDriverClassContextAware contextAware =\n\t\t\t\t\t\t\t(ProvisioningDriverClassContextAware) cloudifyProvisioning;\n\t\t\t\t\tcontextAware.setProvisioningDriverClassContext(provisioningDriverContext);\n\t\t\t\t}\n\n\t\t\t\t// checks if a service level configuration exists. If so, save the configuration to local file and pass\n\t\t\t\t// to cloud driver.\n\t\t\t\thandleServiceCloudConfiguration();\n\t\t\t\tthis.cloudifyProvisioning.setConfig(cloud, cloudTemplateName, false, zones);\n\n\t\t\t} catch (final ClassNotFoundException e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName() + \". Class not found: \" + this.cloud.getConfiguration().getClassName(),\n\t\t\t\t\t\te);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName(), e);\n\t\t\t}\n\n\t\t\tthis.lookupLocatorsString = createLocatorsString();\n\n\t\t\tlogger.info(\"Locators string used for new instances will be: \" + this.lookupLocatorsString);\n\n\t\t} catch (final DSLException e) {\n\t\t\tlogger.severe(\"Could not parse the provided cloud configuration: \" + cloudContents + \": \" + e.getMessage());\n\t\t\tthrow new BeanConfigurationException(\"Could not parse the prvided cloud configuration: \" + cloudContents\n\t\t\t\t\t+ \": \" + e.getMessage());\n\t\t}\n\n\t}","id":67440,"modified_method":"@Override\n\tpublic void afterPropertiesSet()\n\t\t\tthrows Exception {\n\n\t\tfinal String[] zones = this.config.getGridServiceAgentZones().getZones().toArray(new String[0]);\n\t\tlogger = java.util.logging.Logger\n\t\t\t\t.getLogger(ElasticMachineProvisioningCloudifyAdapter.class.getName() + \"-\" + Arrays.toString(zones));\n\n\t\tfinal String cloudContents = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_CONFIGURATION);\n\t\tif (cloudContents == null) {\n\t\t\tthrow new IllegalArgumentException(\"Cloud configuration was not set!\");\n\t\t}\n\n\t\ttry {\n\t\t\tthis.cloud = ServiceReader.readCloud(cloudContents);\n\t\t\tthis.cloudTemplateName = properties.get(CloudifyConstants.ELASTIC_PROPERTIES_CLOUD_TEMPLATE_NAME);\n\n\t\t\tif (this.cloudTemplateName == null) {\n\t\t\t\tthrow new BeanConfigurationException(\"Cloud template was not set!\");\n\t\t\t}\n\n\t\t\tfinal CloudTemplate cloudTemplate = this.cloud.getTemplates().get(this.cloudTemplateName);\n\t\t\tif (cloudTemplate == null) {\n\t\t\t\tthrow new BeanConfigurationException(\"The provided cloud template name: \" + this.cloudTemplateName\n\t\t\t\t\t\t+ \" was not found in the cloud configuration\");\n\t\t\t}\n\n\t\t\t// This code runs on the ESM in the remote machine,\n\t\t\t// so set the local directory to the value of the remote directory\n\t\t\tlogger.info(\"Remote Directory is: \" + cloudTemplate.getRemoteDirectory());\n\t\t\tif (ServiceUtils.isWindows()) {\n\t\t\t\tlogger.info(\"Windows machine - modifying local directory location\");\n\t\t\t\tString localDirectoryName = cloudTemplate.getRemoteDirectory();\n\t\t\t\tlocalDirectoryName = localDirectoryName.replace(\"$\", \"\");\n\t\t\t\tif (localDirectoryName.startsWith(\"/\")) {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tif (localDirectoryName.charAt(1) == '/') {\n\t\t\t\t\tlocalDirectoryName = localDirectoryName.substring(0, 1) + \":\" + localDirectoryName.substring(1);\n\t\t\t\t}\n\t\t\t\tlogger.info(\"Modified local dir name is: \" + localDirectoryName);\n\n\t\t\t\tcloudTemplate.setLocalDirectory(localDirectoryName);\n\t\t\t} else {\n\t\t\t\tcloudTemplate.setLocalDirectory(cloudTemplate.getRemoteDirectory());\n\t\t\t}\n\n\t\t\t// load the provisioning class and set it up\n\t\t\ttry {\n\t\t\t\tthis.cloudifyProvisioning =\n\t\t\t\t\t\t(ProvisioningDriver) Class.forName(this.cloud.getConfiguration().getClassName()).newInstance();\n\n\t\t\t\tif (cloudifyProvisioning instanceof ProvisioningDriverClassContextAware) {\n\t\t\t\t\tfinal ProvisioningDriverClassContext provisioningDriverContext =\n\t\t\t\t\t\t\tlazyCreateProvisioningDriverClassContext(cloudifyProvisioning);\n\t\t\t\t\tfinal ProvisioningDriverClassContextAware contextAware =\n\t\t\t\t\t\t\t(ProvisioningDriverClassContextAware) cloudifyProvisioning;\n\t\t\t\t\tcontextAware.setProvisioningDriverClassContext(provisioningDriverContext);\n\t\t\t\t}\n\n\t\t\t\t// checks if a service level configuration exists. If so, save the configuration to local file and pass\n\t\t\t\t// to cloud driver.\n\t\t\t\thandleServiceCloudConfiguration();\n\t\t\t\tthis.cloudifyProvisioning.setConfig(cloud, cloudTemplateName, false, zones);\n\n\t\t\t} catch (final ClassNotFoundException e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName() + \". Class not found: \" + this.cloud.getConfiguration().getClassName(),\n\t\t\t\t\t\te);\n\t\t\t} catch (final Exception e) {\n\t\t\t\tthrow new BeanConfigurationException(\"Failed to load provisioning class for cloud: \"\n\t\t\t\t\t\t+ this.cloud.getName(), e);\n\t\t\t}\n\n\t\t\tthis.lookupLocatorsString = createLocatorsString();\n\n\t\t\tlogger.info(\"Locators string used for new instances will be: \" + this.lookupLocatorsString);\n\n\t\t} catch (final DSLException e) {\n\t\t\tlogger.severe(\"Could not parse the provided cloud configuration: \" + cloudContents + \": \" + e.getMessage());\n\t\t\tthrow new BeanConfigurationException(\"Could not parse the prvided cloud configuration: \" + cloudContents\n\t\t\t\t\t+ \": \" + e.getMessage());\n\t\t}\n\n\t}","commit_id":"4596abfa3d5150c7c0543359b86f648a2e5a3947","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"@Override\n\tpublic GridServiceAgent startMachine(final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\t\treturn startMachine(new HashSet<String>(), duration, unit);\n\t}","id":67441,"modified_method":"@Override\n\tpublic GridServiceAgent startMachine(final long duration, final TimeUnit unit)\n\t\t\tthrows ElasticMachineProvisioningException, InterruptedException, TimeoutException {\n\t\treturn startMachine(new ExactZonesConfig(), duration, unit);\n\t}","commit_id":"4596abfa3d5150c7c0543359b86f648a2e5a3947","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"/*************************\n\t * Creates an Agentless Installer's InstallationDetails input object from a machine details object returned from a\n\t * provisioning implementation.\n\t * \n\t * @param md the machine details.\n\t * @param cloud The cloud configuration.\n\t * @param template the cloud template used for this machine.\n\t * @param zones the zones that the new machine should start in.\n\t * @param lookupLocatorsString the lookup locators string to pass to the new machine.\n\t * @param admin an admin object, may be null.\n\t * @param isManagement true if this machine will be installed as a cloudify controller, false otherwise.\n\t * @param cloudFile the cloud file, required only when isManagement == true.\n\t * @return the installation details.\n\t * @throws FileNotFoundException if a key file is specified and is not found.\n\t */\n\tpublic static InstallationDetails createInstallationDetails(final MachineDetails md,\n\t\t\tfinal Cloud cloud, final CloudTemplate template, final String[] zones,\n\t\t\tfinal String lookupLocatorsString, final Admin admin, final boolean isManagement, final File cloudFile)\n\t\t\tthrows FileNotFoundException {\n\n\t\tfinal InstallationDetails details = new InstallationDetails();\n\n\t\tdetails.setLocalDir(template.getLocalDirectory());\n\t\tfinal String remoteDir = template.getRemoteDirectory();\n\t\tdetails.setRemoteDir(remoteDir);\n\n\t\t// Create a copy of managementOnly files and mutate\n\t\tfinal List<String> managementOnlyFiles = new ArrayList<String>(cloud.getProvider().getManagementOnlyFiles());\n\t\tif (template.getKeyFile() != null) {\n\t\t\t// keyFile, if used, is always a management file.\n\t\t\tmanagementOnlyFiles.add(template.getKeyFile());\n\t\t}\n\t\tdetails.setManagementOnlyFiles(managementOnlyFiles);\n\n\t\tdetails.setManagementOnlyFiles(cloud.getProvider().getManagementOnlyFiles());\n\n\t\t// we add the machine location id to the zone.\n\t\t// this way in case this machine failes, we can look at the zones and conclude where it was allocated.\n\t\tfinal String[] zonesWithLocation = StringUtils.addStringToArray(zones, md.getLocationId());\n\t\t\n\t\tdetails.setZones(StringUtils.join(zonesWithLocation, \",\", 0, zonesWithLocation.length));\n\n\t\tdetails.setPrivateIp(md.getPrivateAddress());\n\t\tdetails.setPublicIp(md.getPublicAddress());\n\n\t\tdetails.setLocator(lookupLocatorsString);\n\n\t\tdetails.setCloudifyUrl(cloud.getProvider().getCloudifyUrl());\n\t\tdetails.setOverridesUrl(cloud.getProvider().getCloudifyOverridesUrl());\n\t\t\n\t\tdetails.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());\n\t\tdetails.setAdmin(admin);\n\n\t\tdetails.setUsername(md.getRemoteUsername());\n\t\tdetails.setPassword(md.getRemotePassword());\n\t\tdetails.setRemoteExecutionMode(md.getRemoteExecutionMode());\n\t\tdetails.setFileTransferMode(md.getFileTransferMode());\n\n\t\tdetails.setCloudFile(cloudFile);\n\t\tdetails.setLus(isManagement);\n\t\tif (isManagement) {\n\t\t\tdetails.setConnectedToPrivateIp(!cloud.getConfiguration().isBootstrapManagementOnPublicIp());\n\t\t} else {\n\t\t\tdetails.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());\n\t\t}\n\n\t\t// Add all template custom data fields starting with 'installer.' to the installation details\n\t\tfinal Set<Entry<String, Object>> customEntries = template.getCustom().entrySet();\n\t\tfor (final Entry<String, Object> entry : customEntries) {\n\t\t\tif (entry.getKey().startsWith(\"installer.\")) {\n\t\t\t\tdetails.getCustomData().put(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tfinal String keyFileName = template.getKeyFile();\n\t\tif (keyFileName != null && !keyFileName.isEmpty()) {\n\t\t\tFile keyFile = new File(keyFileName);\n\t\t\tif (!keyFile.isAbsolute()) {\n\t\t\t\tkeyFile = new File(details.getLocalDir(), keyFileName);\n\t\t\t}\n\t\t\tif (!keyFile.isFile()) {\n\t\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\t\"Could not find key file matching specified cloud configuration key file: \"\n\t\t\t\t\t\t\t\t+ template.getKeyFile() + \". Tried: \" + keyFile + \" but file does not exist\");\n\t\t\t}\n\t\t\tdetails.setKeyFile(keyFile.getAbsolutePath());\n\t\t}\n\n\t\tif (template.getHardwareId() != null) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_HARDWARE_ID,\n\t\t\t\t\ttemplate.getHardwareId());\n\n\t\t}\n\n\t\tif (template.getImageId() != null) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_IMAGE_ID,\n\t\t\t\t\ttemplate.getImageId());\n\t\t}\n\n\t\t// Add the template privileged mode flag\n\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVILEGED,\n\t\t\t\tBoolean.toString(template.isPrivileged()));\n\n\t\t// Add the template initialization command\n\t\tif (!org.apache.commons.lang.StringUtils.isBlank(template.getInitializationCommand())) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_AGENT_ENV_INIT_COMMAND,\n\t\t\t\t\ttemplate.getInitializationCommand());\n\t\t}\n\t\t\n\t\t// Add the template custom environment\n\t\tfinal Set<Entry<String, String>> entries = template.getEnv().entrySet();\n\t\tfor (Entry<String, String> entry : entries) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(entry.getKey(), entry.getValue());\n\t\t}\n\t\t\n\t\t\n\t\tif(!org.apache.commons.lang.StringUtils.isBlank(template.getJavaUrl())) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_AGENT_ENV_JAVA_URL, template.getJavaUrl());\n\t\t}\n\n\t\tlogger.fine(\"Created InstallationDetails: \" + details);\n\t\treturn details;\n\n\t}","id":67442,"modified_method":"/*************************\n\t * Creates an Agentless Installer's InstallationDetails input object from a machine details object returned from a\n\t * provisioning implementation.\n\t * \n\t * @param md the machine details.\n\t * @param cloud The cloud configuration.\n\t * @param template the cloud template used for this machine.\n\t * @param zones the zones that the new machine should start in.\n\t * @param lookupLocatorsString the lookup locators string to pass to the new machine.\n\t * @param admin an admin object, may be null.\n\t * @param isManagement true if this machine will be installed as a cloudify controller, false otherwise.\n\t * @param cloudFile the cloud file, required only when isManagement == true.\n\t * @return the installation details.\n\t * @throws FileNotFoundException if a key file is specified and is not found.\n\t */\n\tpublic static InstallationDetails createInstallationDetails(final MachineDetails md,\n\t\t\tfinal Cloud cloud, final CloudTemplate template, final ExactZonesConfig zones,\n\t\t\tfinal String lookupLocatorsString, final Admin admin, final boolean isManagement, final File cloudFile)\n\t\t\tthrows FileNotFoundException {\n\n\t\tfinal InstallationDetails details = new InstallationDetails();\n\n\t\tdetails.setLocalDir(template.getLocalDirectory());\n\t\tfinal String remoteDir = template.getRemoteDirectory();\n\t\tdetails.setRemoteDir(remoteDir);\n\n\t\t// Create a copy of managementOnly files and mutate\n\t\tfinal List<String> managementOnlyFiles = new ArrayList<String>(cloud.getProvider().getManagementOnlyFiles());\n\t\tif (template.getKeyFile() != null) {\n\t\t\t// keyFile, if used, is always a management file.\n\t\t\tmanagementOnlyFiles.add(template.getKeyFile());\n\t\t}\n\t\tdetails.setManagementOnlyFiles(managementOnlyFiles);\n\n\t\tdetails.setManagementOnlyFiles(cloud.getProvider().getManagementOnlyFiles());\n\t\t\n\t\tdetails.setZones(StringUtils.collectionToCommaDelimitedString(zones.getZones()));\n\n\t\tdetails.setPrivateIp(md.getPrivateAddress());\n\t\tdetails.setPublicIp(md.getPublicAddress());\n\n\t\tdetails.setLocator(lookupLocatorsString);\n\n\t\tdetails.setCloudifyUrl(cloud.getProvider().getCloudifyUrl());\n\t\tdetails.setOverridesUrl(cloud.getProvider().getCloudifyOverridesUrl());\n\t\t\n\t\tdetails.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());\n\t\tdetails.setAdmin(admin);\n\n\t\tdetails.setUsername(md.getRemoteUsername());\n\t\tdetails.setPassword(md.getRemotePassword());\n\t\tdetails.setRemoteExecutionMode(md.getRemoteExecutionMode());\n\t\tdetails.setFileTransferMode(md.getFileTransferMode());\n\n\t\tdetails.setCloudFile(cloudFile);\n\t\tdetails.setLus(isManagement);\n\t\tif (isManagement) {\n\t\t\tdetails.setConnectedToPrivateIp(!cloud.getConfiguration().isBootstrapManagementOnPublicIp());\n\t\t} else {\n\t\t\tdetails.setConnectedToPrivateIp(cloud.getConfiguration().isConnectToPrivateIp());\n\t\t}\n\n\t\t// Add all template custom data fields starting with 'installer.' to the installation details\n\t\tfinal Set<Entry<String, Object>> customEntries = template.getCustom().entrySet();\n\t\tfor (final Entry<String, Object> entry : customEntries) {\n\t\t\tif (entry.getKey().startsWith(\"installer.\")) {\n\t\t\t\tdetails.getCustomData().put(entry.getKey(), entry.getValue());\n\t\t\t}\n\t\t}\n\n\t\tfinal String keyFileName = template.getKeyFile();\n\t\tif (keyFileName != null && !keyFileName.isEmpty()) {\n\t\t\tFile keyFile = new File(keyFileName);\n\t\t\tif (!keyFile.isAbsolute()) {\n\t\t\t\tkeyFile = new File(details.getLocalDir(), keyFileName);\n\t\t\t}\n\t\t\tif (!keyFile.isFile()) {\n\t\t\t\tthrow new FileNotFoundException(\n\t\t\t\t\t\t\"Could not find key file matching specified cloud configuration key file: \"\n\t\t\t\t\t\t\t\t+ template.getKeyFile() + \". Tried: \" + keyFile + \" but file does not exist\");\n\t\t\t}\n\t\t\tdetails.setKeyFile(keyFile.getAbsolutePath());\n\t\t}\n\n\t\tif (template.getHardwareId() != null) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_HARDWARE_ID,\n\t\t\t\t\ttemplate.getHardwareId());\n\n\t\t}\n\n\t\tif (template.getImageId() != null) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_CLOUD_IMAGE_ID,\n\t\t\t\t\ttemplate.getImageId());\n\t\t}\n\n\t\t// Add the template privileged mode flag\n\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_AGENT_ENV_PRIVILEGED,\n\t\t\t\tBoolean.toString(template.isPrivileged()));\n\n\t\t// Add the template initialization command\n\t\tif (!org.apache.commons.lang.StringUtils.isBlank(template.getInitializationCommand())) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_AGENT_ENV_INIT_COMMAND,\n\t\t\t\t\ttemplate.getInitializationCommand());\n\t\t}\n\t\t\n\t\t// Add the template custom environment\n\t\tfinal Set<Entry<String, String>> entries = template.getEnv().entrySet();\n\t\tfor (Entry<String, String> entry : entries) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(entry.getKey(), entry.getValue());\n\t\t}\n\t\t\n\t\t\n\t\tif(!org.apache.commons.lang.StringUtils.isBlank(template.getJavaUrl())) {\n\t\t\tdetails.getExtraRemoteEnvironmentVariables().put(CloudifyConstants.CLOUDIFY_AGENT_ENV_JAVA_URL, template.getJavaUrl());\n\t\t}\n\n\t\tlogger.fine(\"Created InstallationDetails: \" + details);\n\t\treturn details;\n\n\t}","commit_id":"4596abfa3d5150c7c0543359b86f648a2e5a3947","url":"https://github.com/CloudifySource/cloudify"},{"original_method":"public String addPortletId(\n\t\tlong userId, String portletId, String columnId, int columnPos,\n\t\tboolean checkPermission) {\n\n\t\tLayout layout = getLayout();\n\n\t\tPortlet portlet = null;\n\n\t\ttry {\n\t\t\tportlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tlayout.getCompanyId(), portletId);\n\n\t\t\tif (portlet == null) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Portlet \" + portletId +\n\t\t\t\t\t\t\" cannot be added because it is not registered\");\n\t\t\t}\n\n\t\t\tif (checkPermission && !portlet.hasAddPortletPermission(userId)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e);\n\t\t}\n\n\t\tif (portlet != null) {\n\t\t\tif (portlet.isSystem()) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ((portlet.isInstanceable()) &&\n\t\t\t\t(PortletConstants.getInstanceId(\n\t\t\t\t\tportlet.getPortletId()) == null)) {\n\n\t\t\t\tportletId = portletId + getFullInstanceSeparator();\n\t\t\t}\n\n\t\t\tif (hasPortletId(portletId)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (columnId == null) {\n\t\t\t\tLayoutTemplate layoutTemplate = getLayoutTemplate();\n\n\t\t\t\tList<String> columns = layoutTemplate.getColumns();\n\n\t\t\t\tif (columns.size() > 0) {\n\t\t\t\t\tcolumnId = columns.get(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (columnId != null) {\n\t\t\t\tString columnValue =\n\t\t\t\t\tgetTypeSettingsProperties().getProperty(columnId);\n\n\t\t\t\tif ((columnValue == null) &&\n\t\t\t\t\t(columnId.startsWith(PortletKeys.NESTED_PORTLETS))) {\n\n\t\t\t\t\taddNestedColumn(columnId);\n\t\t\t\t}\n\n\t\t\t\tif (columnPos >= 0) {\n\t\t\t\t\tList<String> portletIds =\n\t\t\t\t\t\tListUtil.fromArray(StringUtil.split(columnValue));\n\n\t\t\t\t\tif (columnPos <= portletIds.size()) {\n\t\t\t\t\t\tportletIds.add(columnPos, portletId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tportletIds.add(portletId);\n\t\t\t\t\t}\n\n\t\t\t\t\tcolumnValue = StringUtil.merge(portletIds);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumnValue = StringUtil.add(columnValue, portletId);\n\t\t\t\t}\n\n\t\t\t\tgetTypeSettingsProperties().setProperty(columnId, columnValue);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletLayoutListener portletLayoutListener =\n\t\t\t\t\tportlet.getPortletLayoutListener();\n\n\t\t\t\tif (_enablePortletLayoutListener &&\n\t\t\t\t\t(portletLayoutListener != null)) {\n\n\t\t\t\t\tportletLayoutListener.onAddToLayout(\n\t\t\t\t\t\tportletId, layout.getPlid());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to fire portlet layout listener event\", e);\n\t\t\t}\n\n\t\t\treturn portletId;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","id":67443,"modified_method":"public String addPortletId(\n\t\tlong userId, String portletId, String columnId, int columnPos,\n\t\tboolean checkPermission) {\n\n\t\tportletId = JS.getSafeName(portletId);\n\n\t\tLayout layout = getLayout();\n\n\t\tPortlet portlet = null;\n\n\t\ttry {\n\t\t\tportlet = PortletLocalServiceUtil.getPortletById(\n\t\t\t\tlayout.getCompanyId(), portletId);\n\n\t\t\tif (portlet == null) {\n\t\t\t\t_log.error(\n\t\t\t\t\t\"Portlet \" + portletId +\n\t\t\t\t\t\t\" cannot be added because it is not registered\");\n\t\t\t}\n\n\t\t\tif (checkPermission && !portlet.hasAddPortletPermission(userId)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\t_log.error(e);\n\t\t}\n\n\t\tif (portlet != null) {\n\t\t\tif (portlet.isSystem()) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif ((portlet.isInstanceable()) &&\n\t\t\t\t(PortletConstants.getInstanceId(\n\t\t\t\t\tportlet.getPortletId()) == null)) {\n\n\t\t\t\tportletId = portletId + getFullInstanceSeparator();\n\t\t\t}\n\n\t\t\tif (hasPortletId(portletId)) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tif (columnId == null) {\n\t\t\t\tLayoutTemplate layoutTemplate = getLayoutTemplate();\n\n\t\t\t\tList<String> columns = layoutTemplate.getColumns();\n\n\t\t\t\tif (columns.size() > 0) {\n\t\t\t\t\tcolumnId = columns.get(0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (columnId != null) {\n\t\t\t\tString columnValue =\n\t\t\t\t\tgetTypeSettingsProperties().getProperty(columnId);\n\n\t\t\t\tif ((columnValue == null) &&\n\t\t\t\t\t(columnId.startsWith(PortletKeys.NESTED_PORTLETS))) {\n\n\t\t\t\t\taddNestedColumn(columnId);\n\t\t\t\t}\n\n\t\t\t\tif (columnPos >= 0) {\n\t\t\t\t\tList<String> portletIds =\n\t\t\t\t\t\tListUtil.fromArray(StringUtil.split(columnValue));\n\n\t\t\t\t\tif (columnPos <= portletIds.size()) {\n\t\t\t\t\t\tportletIds.add(columnPos, portletId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tportletIds.add(portletId);\n\t\t\t\t\t}\n\n\t\t\t\t\tcolumnValue = StringUtil.merge(portletIds);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolumnValue = StringUtil.add(columnValue, portletId);\n\t\t\t\t}\n\n\t\t\t\tgetTypeSettingsProperties().setProperty(columnId, columnValue);\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tPortletLayoutListener portletLayoutListener =\n\t\t\t\t\tportlet.getPortletLayoutListener();\n\n\t\t\t\tif (_enablePortletLayoutListener &&\n\t\t\t\t\t(portletLayoutListener != null)) {\n\n\t\t\t\t\tportletLayoutListener.onAddToLayout(\n\t\t\t\t\t\tportletId, layout.getPlid());\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(\"Unable to fire portlet layout listener event\", e);\n\t\t\t}\n\n\t\t\treturn portletId;\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"d00614af50a7dd933059e67ed5870122d7cc3059","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected String[] getStaticPortletIds(String position) {\n\t\tLayout layout = getLayout();\n\n\t\tString selector1 = StringPool.BLANK;\n\n\t\tGroup group = layout.getGroup();\n\n\t\tif (group.isUser()) {\n\t\t\tselector1 = STATIC_PORTLET_USER_SELECTOR;\n\t\t}\n\t\telse if (group.isCommunity()) {\n\t\t\tselector1 = STATIC_PORTLET_COMMUNITY_SELECTOR;\n\t\t}\n\t\telse if (group.isOrganization()) {\n\t\t\tselector1 = STATIC_PORTLET_ORGANIZATION_SELECTOR;\n\t\t}\n\n\t\tString selector2 = layout.getFriendlyURL();\n\n\t\treturn PropsUtil.getArray(position, new Filter(selector1, selector2));\n\t}","id":67444,"modified_method":"protected String[] getStaticPortletIds(String position) {\n\t\tLayout layout = getLayout();\n\n\t\tString selector1 = StringPool.BLANK;\n\n\t\tGroup group = layout.getGroup();\n\n\t\tif (group.isUser()) {\n\t\t\tselector1 = STATIC_PORTLET_USER_SELECTOR;\n\t\t}\n\t\telse if (group.isCommunity()) {\n\t\t\tselector1 = STATIC_PORTLET_COMMUNITY_SELECTOR;\n\t\t}\n\t\telse if (group.isOrganization()) {\n\t\t\tselector1 = STATIC_PORTLET_ORGANIZATION_SELECTOR;\n\t\t}\n\n\t\tString selector2 = layout.getFriendlyURL();\n\n\t\tString[] portletIds = PropsUtil.getArray(\n\t\t\tposition, new Filter(selector1, selector2));\n\n\t\tfor (int i = 0; i < portletIds.length; i++) {\n\t\t\tportletIds[i] = JS.getSafeName(portletIds[i]);\n\t\t}\n\n\t\treturn portletIds;\n\t}","commit_id":"d00614af50a7dd933059e67ed5870122d7cc3059","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tpublic String[] getRestrictedVariables(String language) {\n\t\tString[] restrictedVariables;\n\n\t\tif (language.equals(TemplateConstants.LANG_TYPE_FTL)) {\n\t\t\trestrictedVariables = PropsUtil.getArray(\n\t\t\t\tPropsKeys.FREEMARKER_ENGINE_RESTRICTED_VARIABLES);\n\t\t}\n\t\telse if (language.equals(TemplateConstants.LANG_TYPE_VM)) {\n\t\t\trestrictedVariables = PropsUtil.getArray(\n\t\t\t\tPropsKeys.VELOCITY_ENGINE_RESTRICTED_VARIABLES);\n\t\t}\n\t\telse {\n\t\t\trestrictedVariables = new String[0];\n\t\t}\n\n\t\treturn restrictedVariables;\n\t}","id":67445,"modified_method":"@Override\n\tpublic String[] getRestrictedVariables(String language) {\n\t\tif (language.equals(TemplateConstants.LANG_TYPE_FTL)) {\n\t\t\treturn PropsUtil.getArray(\n\t\t\t\tPropsKeys.FREEMARKER_ENGINE_RESTRICTED_VARIABLES);\n\t\t}\n\t\telse if (language.equals(TemplateConstants.LANG_TYPE_VM)) {\n\t\t\treturn PropsUtil.getArray(\n\t\t\t\tPropsKeys.VELOCITY_ENGINE_RESTRICTED_VARIABLES);\n\t\t}\n\n\t\treturn new String[0];\n\t}","commit_id":"a1806fc47298dfcef86a1fd969d73b81555d6c18","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void setCurrentView(MainView view)\n   {\n      currentView = view;\n      if (view == MainView.Documents)\n      {\n         display.setRunValidationVisible(true);\n         display.setRunValidationTitle(messages.documentValidationTitle());\n         if (hasErrorReport())\n         {\n            display.showReportLink(true);\n         }\n      }\n      else\n      {\n         display.setRunValidationVisible(false);\n         display.setRunValidationTitle(messages.editorValidationTitle());\n         display.showReportLink(false);\n      }\n   }","id":67446,"modified_method":"public void setCurrentView(MainView view)\n   {\n      currentView = view;\n      if (view == MainView.Documents)\n      {\n         display.setRunValidationVisible(true);\n         display.setRunValidationTitle(messages.documentValidationTitle());\n      }\n      else\n      {\n         display.setRunValidationVisible(false);\n         display.setRunValidationTitle(messages.editorValidationTitle());\n      }\n   }","commit_id":"ca7eca04f8775f785a5f2b8696e87271ad96ca1f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   protected void onBind()\n   {\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), this));\n      registerHandler(eventBus.addHandler(DocValidationResultEvent.getType(), this));\n      registerHandler(eventBus.addHandler(DocValidationReportResultEvent.getType(), this));\n      initDisplay();\n\n      display.updateValidationResult(null);\n      display.showReportLink(false);\n\n      display.setListener(this);\n   }","id":67447,"modified_method":"@Override\n   protected void onBind()\n   {\n      registerHandler(eventBus.addHandler(WorkspaceContextUpdateEvent.getType(), this));\n      registerHandler(eventBus.addHandler(DocValidationResultEvent.getType(), this));\n      initDisplay();\n\n      display.updateValidationResult(null);\n\n      display.setListener(this);\n   }","commit_id":"ca7eca04f8775f785a5f2b8696e87271ad96ca1f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void onCompleteRunDocValidation(DocValidationResultEvent event)\n   {\n      display.updateValidationResult(event.getEndTime());\n      errorDocs = event.getErrorDocs();\n      if (currentView == MainView.Documents)\n      {\n         display.showReportLink(true);\n      }\n   }","id":67448,"modified_method":"@Override\n   public void onCompleteRunDocValidation(DocValidationResultEvent event)\n   {\n      display.updateValidationResult(event.getEndTime());\n   }","commit_id":"ca7eca04f8775f785a5f2b8696e87271ad96ca1f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void updateValidationResult(Date endTime)\n   {\n      if (endTime != null)\n      {\n         reportLink.setTitle(messages.lastValidationRunTooltip(DateUtil.formatLongDateTime(endTime)));\n         reportLink.setVisible(true);\n      }\n      else\n      {\n         reportLink.setTitle(\"\");\n      }\n   }","id":67449,"modified_method":"@Override\n   public void updateValidationResult(Date endTime)\n   {\n      if (endTime != null)\n      {\n         lastValidationRun.setText(messages.lastValidationRun(DateUtil.formatLongDateTime(endTime)));\n      }\n      else\n      {\n         lastValidationRun.setText(messages.lastValidationRun(\"none\"));\n      }\n   }","commit_id":"ca7eca04f8775f785a5f2b8696e87271ad96ca1f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public ValidationOptionsView(WebTransMessages messages, DocValidationReportDisplay docValidationReport)\n   {\n      initWidget(uiBinder.createAndBindUi(this));\n      this.messages = messages;\n      this.docValidationReport = docValidationReport;\n\n      validationOptionsHeader.setText(messages.validationOptions());\n      runValidation.setText(messages.runValidation());\n      \n      reportLink.setText(messages.validationReportLink());\n   }","id":67450,"modified_method":"@Inject\n   public ValidationOptionsView(WebTransMessages messages)\n   {\n      initWidget(uiBinder.createAndBindUi(this));\n      this.messages = messages;\n\n      validationOptionsHeader.setText(messages.validationOptions());\n      runValidation.setText(messages.runValidation());\n   }","commit_id":"ca7eca04f8775f785a5f2b8696e87271ad96ca1f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public ValidationService(final CachingDispatchAsync dispatcher, final EventBus eventBus, final TableEditorMessages messages, final ValidationMessages validationMessages, final UserConfigHolder configHolder)\n   {\n      this.eventBus = eventBus;\n      this.messages = messages;\n      this.configHolder = configHolder;\n      this.dispatcher = dispatcher;\n      \n      validationFactory = new ValidationFactory(validationMessages);\n\n      eventBus.addHandler(RunValidationEvent.getType(), this);\n   }","id":67451,"modified_method":"@Inject\n   public ValidationService(final EventBus eventBus, final TableEditorMessages messages, final ValidationMessages validationMessages, final UserConfigHolder configHolder)\n   {\n      this.eventBus = eventBus;\n      this.messages = messages;\n      this.configHolder = configHolder;\n      \n      validationFactory = new ValidationFactory(validationMessages);\n\n      eventBus.addHandler(RunValidationEvent.getType(), this);\n   }","commit_id":"ca7eca04f8775f785a5f2b8696e87271ad96ca1f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@BeforeMethod\n   public void beforeMethod() throws IOException\n   {\n      MockitoAnnotations.initMocks(this);\n\n      validationMessages = Gwti18nReader.create(ValidationMessages.class);\n\n      service = new ValidationService(dispatcher, eventBus, messages, validationMessages, configHolder);\n      ValidationFactory validationFactory = new ValidationFactory(validationMessages);\n\n      Collection<ValidationAction> validationList = validationFactory.getAllValidationActions().values();\n      Map<ValidationId, ValidationInfo> validationInfoList = new HashMap<ValidationId, ValidationInfo>();\n      \n      for (ValidationAction action : validationList)\n      {\n         action.getValidationInfo().setEnabled(true);\n         validationInfoList.put(action.getId(), action.getValidationInfo());\n      }\n      service.setValidationRules(validationInfoList);\n\n      when(messages.notifyValidationError()).thenReturn(\"validation error\");\n      verify(eventBus).addHandler(RunValidationEvent.getType(), service);\n   }","id":67452,"modified_method":"@BeforeMethod\n   public void beforeMethod() throws IOException\n   {\n      MockitoAnnotations.initMocks(this);\n\n      validationMessages = Gwti18nReader.create(ValidationMessages.class);\n\n      service = new ValidationService(eventBus, messages, validationMessages, configHolder);\n      ValidationFactory validationFactory = new ValidationFactory(validationMessages);\n\n      Collection<ValidationAction> validationList = validationFactory.getAllValidationActions().values();\n      Map<ValidationId, ValidationInfo> validationInfoList = new HashMap<ValidationId, ValidationInfo>();\n      \n      for (ValidationAction action : validationList)\n      {\n         action.getValidationInfo().setEnabled(true);\n         validationInfoList.put(action.getId(), action.getValidationInfo());\n      }\n      service.setValidationRules(validationInfoList);\n\n      when(messages.notifyValidationError()).thenReturn(\"validation error\");\n      verify(eventBus).addHandler(RunValidationEvent.getType(), service);\n   }","commit_id":"ca7eca04f8775f785a5f2b8696e87271ad96ca1f","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void onDocumentListClicked()\n   {\n      HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n\n      if (token.getView().equals(MainView.Documents))\n      {\n         if (selectedDocument == null)\n         {\n            return; // abort if no doc to edit\n         }\n         token.setView(MainView.Editor);\n      }\n      else\n      {\n         token.setView(MainView.Documents);\n      }\n      history.newItem(token.toTokenString());\n   }","id":67453,"modified_method":"@Override\n   public void onDocumentListClicked()\n   {\n\n      HistoryToken token = HistoryToken.fromTokenString(history.getToken());\n      if (!token.getView().equals(MainView.Documents))\n      {\n         token.setView(MainView.Documents);\n         history.newItem(token.toTokenString());\n      }\n   }","commit_id":"b5b117f5d56bcbd9ebe3420e5ace2b34e5b372a3","url":"https://github.com/zanata/zanata-server"},{"original_method":"public void showView(MainView viewToShow)\n   {\n      if (currentView == viewToShow)\n      {\n         return;\n      }\n\n      if (currentView == MainView.Editor)\n      {\n         translationPresenter.saveEditorPendingChange();\n      }\n      Log.info(\"view to show is:\" + viewToShow);\n      switch (viewToShow)\n      {\n         // TODO use revealDisplay/concealDisplay for editor and document views\n         case Editor:\n            if (selectedDocument != null)\n            {\n               display.setDocumentLabel(selectedDocument.getPath(), selectedDocument.getName());\n            }\n            currentDisplayStats = selectedDocumentStats;\n            translationPresenter.revealDisplay();\n            searchResultsPresenter.concealDisplay();\n            sideMenuPresenter.showEditorMenu(true);\n            display.setResizeVisible(true);\n            break;\n         case Search:\n            // these two lines temporarily here until PresenterRevealedHandler\n            // is\n            // fully functional\n            display.setDocumentLabel(\"\", messages.projectWideSearchAndReplace());\n            currentDisplayStats = projectStats;\n            translationPresenter.concealDisplay();\n            searchResultsPresenter.revealDisplay();\n            sideMenuPresenter.showEditorMenu(false);\n            display.setResizeVisible(false);\n            break;\n         case Documents:\n         default:\n            if (selectedDocument != null)\n            {\n               display.setDocumentLabel(selectedDocument.getPath(), selectedDocument.getName());\n            }\n            else\n            {\n               display.setDocumentLabel(\"\", messages.noDocumentSelected());\n            }\n            currentDisplayStats = projectStats;\n            translationPresenter.concealDisplay();\n            searchResultsPresenter.concealDisplay();\n            sideMenuPresenter.showEditorMenu(false);\n            display.setResizeVisible(false);\n            break;\n      }\n      display.showInMainView(viewToShow);\n      currentView = viewToShow;\n      refreshStatsDisplay();\n   }","id":67454,"modified_method":"public void showView(MainView viewToShow)\n   {\n      if (currentView == viewToShow)\n      {\n         return;\n      }\n\n      if (currentView == MainView.Editor)\n      {\n         translationPresenter.saveEditorPendingChange();\n      }\n      Log.info(\"view to show is:\" + viewToShow);\n      switch (viewToShow)\n      {\n         // TODO use revealDisplay/concealDisplay for editor and document views\n         case Editor:\n            if (selectedDocument != null)\n            {\n               display.setDocumentLabel(selectedDocument.getPath(), selectedDocument.getName());\n            }\n         else\n         {\n            display.setDocumentLabel(\"\", messages.noDocumentSelected());\n         }\n            currentDisplayStats = selectedDocumentStats;\n            translationPresenter.revealDisplay();\n            searchResultsPresenter.concealDisplay();\n            sideMenuPresenter.showEditorMenu(true);\n            display.setResizeVisible(true);\n            break;\n         case Search:\n            // these two lines temporarily here until PresenterRevealedHandler\n            // is\n            // fully functional\n            display.setDocumentLabel(\"\", messages.projectWideSearchAndReplace());\n            currentDisplayStats = projectStats;\n            translationPresenter.concealDisplay();\n            searchResultsPresenter.revealDisplay();\n            sideMenuPresenter.showEditorMenu(false);\n            display.setResizeVisible(false);\n            break;\n         case Documents:\n         default:\n         display.setDocumentLabel(\"\", messages.documentListTitle());\n            currentDisplayStats = projectStats;\n            translationPresenter.concealDisplay();\n            searchResultsPresenter.concealDisplay();\n            sideMenuPresenter.showEditorMenu(false);\n            display.setResizeVisible(false);\n            break;\n      }\n      display.showInMainView(viewToShow);\n      currentView = viewToShow;\n      refreshStatsDisplay();\n   }","commit_id":"b5b117f5d56bcbd9ebe3420e5ace2b34e5b372a3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void showSideMenu(boolean isShowing)\n   {\n      rootContainer.forceLayout();\n      if (isShowing)\n      {\n         rootContainer.setWidgetLeftRight(editorContainer, 0.0, Unit.PX, MINIMISED_EDITOR_RIGHT, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, EXPENDED_MENU_RIGHT, Unit.PX);\n      }\n      else\n      {\n         rootContainer.setWidgetLeftRight(editorContainer, 0.0, Unit.PX, 0.0, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, MIN_MENU_WIDTH, Unit.PX);\n      }\n      rootContainer.animate(ANIMATE_DURATION);\n   }","id":67455,"modified_method":"@Override\n   public void showSideMenu(boolean isShowing)\n   {\n      rootContainer.forceLayout();\n      if (isShowing)\n      {\n         rootContainer.setWidgetLeftRight(contentBody, 0.0, Unit.PX, MINIMISED_EDITOR_RIGHT, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, EXPENDED_MENU_RIGHT, Unit.PX);\n      }\n      else\n      {\n         rootContainer.setWidgetLeftRight(contentBody, 0.0, Unit.PX, 0.0, Unit.PX);\n         rootContainer.setWidgetRightWidth(sideMenuContainer, 0.0, Unit.PX, MIN_MENU_WIDTH, Unit.PX);\n      }\n      rootContainer.animate(ANIMATE_DURATION);\n   }","commit_id":"b5b117f5d56bcbd9ebe3420e5ace2b34e5b372a3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n   public void showInMainView(MainView view)\n   {\n      switch (view)\n      {\n      case Documents:\n         setWidgetVisible(documentListView, true);\n         setWidgetVisible(searchResultsView, false);\n         setWidgetVisible(translationView, false);\n         break;\n      case Search:\n         setWidgetVisible(documentListView, false);\n         setWidgetVisible(searchResultsView, true);\n         setWidgetVisible(translationView, false);\n         break;\n      case Editor:\n         setWidgetVisible(documentListView, false);\n         setWidgetVisible(searchResultsView, false);\n         setWidgetVisible(translationView, true);\n         break;\n      }\n   }","id":67456,"modified_method":"@Override\n   public void showInMainView(MainView view)\n   {\n      switch (view)\n      {\n      case Documents:\n         contentBody.selectTab(DOCUMENT_VIEW);\n         break;\n      case Search:\n         contentBody.selectTab(SEARCH_AND_REPLACE_VIEW);\n         break;\n      case Editor:\n         contentBody.selectTab(EDITOR_VIEW);\n         break;\n      }\n   }","commit_id":"b5b117f5d56bcbd9ebe3420e5ace2b34e5b372a3","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, SideMenuPresenter.Display sideMenuView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n      initWidget(uiBinder.createAndBindUi(this));\n\n      readOnlyLabel.setText(\"[\" + messages.readOnly() + \"]\");\n\n      keyShortcuts.setTitle(messages.availableKeyShortcutsTitle());\n      searchAndReplace.setTitle(messages.projectWideSearchAndReplace());\n      documentList.setTitle(messages.documentListTitle());\n\n      resize.setTitle(messages.maximize());\n      resize.addStyleName(STYLE_MAXIMIZE);\n\n      this.searchResultsView = searchResultsView.asWidget();\n      this.editorContainer.add(this.searchResultsView);\n\n      this.translationView = translationView.asWidget();\n      this.editorContainer.add(this.translationView);\n\n      this.documentListView = documentListView.asWidget();\n      this.editorContainer.add(this.documentListView);\n\n      sideMenuContainer.add(sideMenuView.asWidget());\n\n      setWidgetVisible(this.documentListView, false);\n      setWidgetVisible(this.searchResultsView, false);\n      setWidgetVisible(this.translationView, false);\n      \n      Window.enableScrolling(false);\n   }","id":67457,"modified_method":"@Inject\n   public AppView(Resources resources, WebTransMessages messages, DocumentListPresenter.Display documentListView, SearchResultsPresenter.Display searchResultsView, TranslationPresenter.Display translationView, SideMenuPresenter.Display sideMenuView, final Identity identity)\n   {\n      this.resources = resources;\n      this.messages = messages;\n\n      StyleInjector.inject(resources.style().getText(), true);\n\n      // this must be initialized before uiBinder.createAndBindUi(), or an\n      // exception will be thrown at runtime\n      translationStatsBar = new TransUnitCountBar(messages, true);\n      translationStatsBar.setVisible(false); // hide until there is a value to\n                                             // display\n      initWidget(uiBinder.createAndBindUi(this));\n\n      readOnlyLabel.setText(\"[\" + messages.readOnly() + \"]\");\n\n      keyShortcuts.setTitle(messages.availableKeyShortcutsTitle());\n\n      resize.setTitle(messages.maximize());\n      resize.addStyleName(STYLE_MAXIMIZE);\n\n      sideMenuContainer.add(sideMenuView.asWidget());\n\n      InlineLabel searchAndReplaceTab = new InlineLabel();\n      searchAndReplaceTab.addStyleName(\"icon-search\");\n      searchAndReplaceTab.setText(messages.projectWideSearchAndReplace());\n\n      InlineLabel documentListTab = new InlineLabel();\n      documentListTab.addStyleName(\"icon-list\");\n      documentListTab.setText(messages.documentListTitle());\n\n      InlineLabel editorTab = new InlineLabel();\n      editorTab.addStyleName(\"icon-edit\");\n      editorTab.setText(messages.editor());\n\n      contentBody.add(documentListView.asWidget(), documentListTab);\n      contentBody.add(translationView.asWidget(), editorTab);\n      contentBody.add(searchResultsView.asWidget(), searchAndReplaceTab);\n      \n      Window.enableScrolling(false);\n   }","commit_id":"b5b117f5d56bcbd9ebe3420e5ace2b34e5b372a3","url":"https://github.com/zanata/zanata-server"},{"original_method":"private void processForAppPresenter(HistoryToken token)\n   {\n      DocumentId docId = documentListPresenter.getDocumentId(token.getDocumentPath());\n      if (docId != null && !equal(appPresenter.getSelectedDocIdOrNull(), docId))\n      {\n         appPresenter.selectDocument(docId);\n      }\n      Log.info(\"[gwt-history] document id: \" + docId);\n\n      // if there is no valid document, don't show the editor\n      // default to document list instead\n      if (docId == null && token.getView() == MainView.Editor)\n      {\n         Log.warn(\"[gwt-history] access editor view with invalid document id. Showing document list view instead\");\n         token.setView(MainView.Documents);\n      }\n\n      if (docId != null)\n      {\n         eventBus.fireEvent(new DocumentSelectionEvent(docId, token.getSearchText()));\n      }\n   }","id":67458,"modified_method":"private void processForAppPresenter(HistoryToken token)\n   {\n      DocumentId docId = documentListPresenter.getDocumentId(token.getDocumentPath());\n      if (docId != null && !equal(appPresenter.getSelectedDocIdOrNull(), docId))\n      {\n         appPresenter.selectDocument(docId);\n      }\n      Log.info(\"[gwt-history] document id: \" + docId);\n\n      if (docId != null)\n      {\n         eventBus.fireEvent(new DocumentSelectionEvent(docId, token.getSearchText()));\n      }\n   }","commit_id":"b5b117f5d56bcbd9ebe3420e5ace2b34e5b372a3","url":"https://github.com/zanata/zanata-server"},{"original_method":"public PageDefinition getPageDefinitionDirectly(Document content, String ext) {\n\t\treturn PageDefinitions.getPageDefinitionDirectly(\n\t\t\tgetDesktop().getWebApp(), content, ext);\n\t}","id":67459,"modified_method":"public PageDefinition getPageDefinitionDirectly(Document content, String ext) {\n\t\t//Note: we have to go thru UiFactory (so user can override it)\n\t\treturn ((WebAppCtrl)getDesktop().getWebApp()).getUiFactory()\n\t\t\t.getPageDefinitionDirectly(newRequestInfo(null), content, ext);\n\t}","commit_id":"da8769c8bbcc11fc08d3d511b5db7cf841178f9e","url":"https://github.com/zkoss/zk"},{"original_method":"public PageDefinition getPageDefinition(String uri) {\n\t\tfinal PageDefinition pagedef = \tPageDefinitions.getPageDefinition(\n\t\t\t_ctx, toAbsoluteURI(uri));\n\t\tif (pagedef == null)\n\t\t\tthrow new UiException(\"Page not found: \"+uri);\n\t\treturn pagedef;\n\t}","id":67460,"modified_method":"public PageDefinition getPageDefinition(String uri) {\n\t\t//Note: we have to go thru UiFactory (so user can override it)\n\t\turi = toAbsoluteURI(uri);\n\t\tfinal PageDefinition pagedef =\n\t\t\t((WebAppCtrl)getDesktop().getWebApp()).getUiFactory()\n\t\t\t.getPageDefinition(newRequestInfo(uri), uri);\n\t\tif (pagedef == null)\n\t\t\tthrow new UiException(\"Page not found: \"+uri);\n\t\treturn pagedef;\n\t}","commit_id":"da8769c8bbcc11fc08d3d511b5db7cf841178f9e","url":"https://github.com/zkoss/zk"},{"original_method":"public PageDefinition getPageDefinitionDirectly(String content, String ext) {\n\t\treturn PageDefinitions.getPageDefinitionDirectly(\n\t\t\tgetDesktop().getWebApp(), content, ext);\n\t}","id":67461,"modified_method":"public PageDefinition getPageDefinitionDirectly(String content, String ext) {\n\t\t//Note: we have to go thru UiFactory (so user can override it)\n\t\treturn ((WebAppCtrl)getDesktop().getWebApp()).getUiFactory()\n\t\t\t.getPageDefinitionDirectly(newRequestInfo(null), content, ext);\n\t}","commit_id":"da8769c8bbcc11fc08d3d511b5db7cf841178f9e","url":"https://github.com/zkoss/zk"},{"original_method":"public PageDefinition getPageDefinitionDirectly(Reader reader, String ext)\n\tthrows IOException {\n\t\treturn PageDefinitions.getPageDefinitionDirectly(\n\t\t\tgetDesktop().getWebApp(), reader, ext);\n\t}","id":67462,"modified_method":"public PageDefinition getPageDefinitionDirectly(Reader reader, String ext)\n\tthrows IOException {\n\t\t//Note: we have to go thru UiFactory (so user can override it)\n\t\treturn ((WebAppCtrl)getDesktop().getWebApp()).getUiFactory()\n\t\t\t.getPageDefinitionDirectly(newRequestInfo(null), reader, ext);\n\t}","commit_id":"da8769c8bbcc11fc08d3d511b5db7cf841178f9e","url":"https://github.com/zkoss/zk"},{"original_method":"public PageDefinition getPageDefinitionDirectly(\n\tRequestInfo ri, String content, String extension) {\n\t\treturn PageDefinitions.getPageDefinitionDirectly(\n\t\t\tri.getLocator(), content, extension);\n\t}","id":67463,"modified_method":"/** Returns the page definition of the specified content; never null.\n\t *\n\t * <p>Dependency: Execution.createComponentsDirectly -&amp; Execution.getPageDefinitionDirectly\n\t * -&amp; UiFactory.getPageDefiitionDirectly -&amp; PageDefintions.getPageDefinitionDirectly\n\t */\n\tpublic PageDefinition getPageDefinitionDirectly(\n\tRequestInfo ri, String content, String extension) {\n\t\treturn PageDefinitions.getPageDefinitionDirectly(\n\t\t\tri.getLocator(), content, extension);\n\t}","commit_id":"da8769c8bbcc11fc08d3d511b5db7cf841178f9e","url":"https://github.com/zkoss/zk"},{"original_method":"public PageDefinition getPageDefinition(RequestInfo ri, String path) {\n\t\t//FUTURE: better isolation of PageDefinitions\n\t\tfinal Object ctx = ri.getWebApp().getNativeContext();\n\t\tif (ctx instanceof ServletContext) {\n\t\t\treturn PageDefinitions.getPageDefinition((ServletContext)ctx, path);\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"Unknown context: \"+ctx);\n\t\t}\n\t}","id":67464,"modified_method":"/** Returns the page definition of the specified path, or null if not found.\n\t *\n\t * <p>Dependency: Execution.createComponents -&amp; Execution.getPageDefinition\n\t * -&amp; UiFactory.getPageDefiition -&amp; PageDefintions.getPageDefinition\n\t */\n\tpublic PageDefinition getPageDefinition(RequestInfo ri, String path) {\n\t\t//FUTURE: better isolation of PageDefinitions\n\t\tfinal Object ctx = ri.getWebApp().getNativeContext();\n\t\tif (ctx instanceof ServletContext) {\n\t\t\treturn PageDefinitions.getPageDefinition((ServletContext)ctx, path);\n\t\t} else {\n\t\t\tthrow new UnsupportedOperationException(\"Unknown context: \"+ctx);\n\t\t}\n\t}","commit_id":"da8769c8bbcc11fc08d3d511b5db7cf841178f9e","url":"https://github.com/zkoss/zk"},{"original_method":"@NotNull\n  public static byte[] readCompressedWithoutOriginalBufferLength(@NotNull DataInput in) throws IOException {\n    int size = DataInputOutputUtil.readINT(in);\n\n    byte[] bytes = spareBufferLocal.getBuffer(size);\n    in.readFully(bytes, 0, size);\n\n    int decompressedRequests = myDecompressionRequests.incrementAndGet();\n    long started = System.nanoTime();\n\n    byte[] decompressedResult = Snappy.uncompress(bytes, 0, size);\n\n    long doneTime = System.nanoTime() - started;\n    long decompressedSize = myDecompressedSize.addAndGet(size);\n    long decompressedTime = myDecompressionTime.addAndGet(doneTime);\n    if (DUMP_COMPRESSION_STATS && decompressedRequests % 1000 == 0) {\n      System.out.println(\"Decompressed \" + decompressedRequests + \" times, size: \" + decompressedSize  + \" for \" + (decompressedTime / 1000000) + \"ms\");\n    }\n\n    return decompressedResult;\n  }","id":67465,"modified_method":"@NotNull\n  public static byte[] readCompressedWithoutOriginalBufferLength(@NotNull DataInput in) throws IOException {\n    int size = DataInputOutputUtil.readINT(in);\n\n    byte[] bytes = spareBufferLocal.getBuffer(size);\n    in.readFully(bytes, 0, size);\n\n    int decompressedRequests = myDecompressionRequests.incrementAndGet();\n    long started = DUMP_COMPRESSION_STATS ? System.nanoTime() : 0;\n\n    byte[] decompressedResult = Snappy.uncompress(bytes, 0, size);\n\n    long doneTime = (DUMP_COMPRESSION_STATS ? System.nanoTime() : 0) - started;\n    long decompressedSize = myDecompressedSize.addAndGet(size);\n    long decompressedTime = myDecompressionTime.addAndGet(doneTime);\n    if (DUMP_COMPRESSION_STATS && decompressedRequests % 1000 == 0) {\n      System.out.println(\"Decompressed \" + decompressedRequests + \" times, size: \" + decompressedSize  + \" for \" + (decompressedTime / 1000000) + \"ms\");\n    }\n\n    return decompressedResult;\n  }","commit_id":"9c92e04d821fd5f5756c48c101f925ea3dbf3bbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static int writeCompressedWithoutOriginalBufferLength(@NotNull DataOutput out, @NotNull byte[] bytes, int length) throws IOException {\n    long started = System.nanoTime();\n\n    final byte[] compressedOutputBuffer = spareBufferLocal.getBuffer(Snappy.maxCompressedLength(length));\n    int compressedSize = Snappy.compress(bytes, 0, length, compressedOutputBuffer, 0);\n\n    final long time = System.nanoTime() - started;\n    mySizeAfterCompression.addAndGet(compressedSize);\n    mySizeBeforeCompression.addAndGet(length);\n    int requests = myCompressionRequests.incrementAndGet();\n    long l = myCompressionTime.addAndGet(time);\n\n    if (DUMP_COMPRESSION_STATS && requests % 1000  == 0) {\n      System.out.println(\"Compressed \" + requests + \" times, size:\" + mySizeBeforeCompression + \"->\" + mySizeAfterCompression + \" for \" + (l  / 1000000) + \"ms\");\n    }\n\n    DataInputOutputUtil.writeINT(out, compressedSize);\n    out.write(compressedOutputBuffer, 0, compressedSize);\n\n    return compressedSize;\n  }","id":67466,"modified_method":"public static int writeCompressedWithoutOriginalBufferLength(@NotNull DataOutput out, @NotNull byte[] bytes, int length) throws IOException {\n    long started = DUMP_COMPRESSION_STATS ? System.nanoTime() : 0;\n\n    final byte[] compressedOutputBuffer = spareBufferLocal.getBuffer(Snappy.maxCompressedLength(length));\n    int compressedSize = Snappy.compress(bytes, 0, length, compressedOutputBuffer, 0);\n\n    final long time = (DUMP_COMPRESSION_STATS ? System.nanoTime() : 0) - started;\n    mySizeAfterCompression.addAndGet(compressedSize);\n    mySizeBeforeCompression.addAndGet(length);\n    int requests = myCompressionRequests.incrementAndGet();\n    long l = myCompressionTime.addAndGet(time);\n\n    if (DUMP_COMPRESSION_STATS && requests % 1000  == 0) {\n      System.out.println(\"Compressed \" + requests + \" times, size:\" + mySizeBeforeCompression + \"->\" + mySizeAfterCompression + \" for \" + (l  / 1000000) + \"ms\");\n    }\n\n    DataInputOutputUtil.writeINT(out, compressedSize);\n    out.write(compressedOutputBuffer, 0, compressedSize);\n\n    return compressedSize;\n  }","commit_id":"9c92e04d821fd5f5756c48c101f925ea3dbf3bbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Reads bytes pointed by tailChunkAddress into result passed, returns new address if linked list compactification have been performed\n   */\n  public ReadResult readBytes(long tailChunkAddress) throws IOException {\n    forceAppender(myPath);\n\n    checkCancellation();\n    long startedTime = System.nanoTime();\n    long chunk = tailChunkAddress;\n    int chunkCount = 0;\n\n    byte[] result = null;\n    RAReader reader = myCompactionModeReader;\n    FileAccessorCache.Handle<RAReader> readerHandle = null;\n    if (reader == null) {\n      readerHandle = myCompressedAppendableFile != null ? null : ourReadersCache.get(myPath);\n      reader = myCompressedAppendableFile != null ? null : readerHandle.get();\n    }\n\n    try {\n      while (chunk != 0) {\n        if (chunk < 0 || chunk > mySize) throw new PersistentEnumeratorBase.CorruptedException(myFile);\n        int len = (int)Math.min(myBuffer.length, mySize - chunk);\n\n        if (myCompressedAppendableFile != null) {\n          DataInputStream stream = myCompressedAppendableFile.getStream(chunk);\n          stream.readFully(myBuffer, 0, len);\n          stream.close();\n        } else {\n          reader.get(chunk, myBuffer, 0, len);\n        }\n        myBufferStreamWrapper.init(myBuffer, 0, len);\n\n        final int chunkSize = DataInputOutputUtil.readINT(myBufferDataStreamWrapper);\n        if (chunkSize < 0) {\n          throw new IOException(\"Value storage corrupted: negative chunk size: \"+chunkSize);\n        }\n        final long prevChunkAddress = readPrevChunkAddress(chunk);\n        final int headerOffset = len - myBufferStreamWrapper.available();\n\n        byte[] b = new byte[(result != null ? result.length:0) + chunkSize];\n        if (result != null) System.arraycopy(result, 0, b, b.length - result.length, result.length);\n        result = b;\n\n        checkPreconditions(result, chunkSize, 0);\n        if (chunkSize < myBuffer.length - headerOffset) {\n          System.arraycopy(myBuffer, headerOffset, result, 0, chunkSize);\n        } else {\n          if (myCompressedAppendableFile != null) {\n            DataInputStream stream = myCompressedAppendableFile.getStream(chunk + headerOffset);\n            stream.readFully(result, 0, chunkSize);\n            stream.close();\n          } else {\n            reader.get(chunk + headerOffset, result, 0, chunkSize);\n          }\n        }\n\n        if (prevChunkAddress >= chunk) throw new PersistentEnumeratorBase.CorruptedException(myFile);\n\n        chunk = prevChunkAddress;\n        chunkCount++;\n\n        if (prevChunkAddress != 0) checkCancellation();\n        if (result.length > mySize && myCompressedAppendableFile == null) {\n          throw new PersistentEnumeratorBase.CorruptedException(myFile);\n        }\n      }\n    } catch (OutOfMemoryError error) {\n      result = null;\n      throw new PersistentEnumeratorBase.CorruptedException(myFile);\n    }\n    finally {\n      if (readerHandle != null) {\n        readerHandle.release();\n      }\n    }\n\n    if (chunkCount > 1 && !myCompactionMode) {\n      checkCancellation();\n      long endCompactionTime = System.nanoTime();\n      long diff = endCompactionTime - startedTime;\n\n      myChunksRemovalTime += diff;\n      myChunks += chunkCount;\n      if (ourDumpChunkRemovalTime && chunkCount > 2) {\n        System.out.println(\"Removed \" + chunkCount + \" chunks for \" + (diff / 1000000) + \"ms, bytes: \" + result.length + \", total: \" +\n                           (myChunksRemovalTime / 1000000) + \"ms for \" + myChunks + \" chunks in \" + myPath);\n      }\n      long l = appendBytes(new ByteSequence(result), 0);\n      return new ReadResult(l, result);\n    }\n\n    return new ReadResult(tailChunkAddress, result);\n  }","id":67467,"modified_method":"/**\n   * Reads bytes pointed by tailChunkAddress into result passed, returns new address if linked list compactification have been performed\n   */\n  public ReadResult readBytes(long tailChunkAddress) throws IOException {\n    forceAppender(myPath);\n\n    checkCancellation();\n    long startedTime = ourDumpChunkRemovalTime ? System.nanoTime() : 0;\n    long chunk = tailChunkAddress;\n    int chunkCount = 0;\n\n    byte[] result = null;\n    RAReader reader = myCompactionModeReader;\n    FileAccessorCache.Handle<RAReader> readerHandle = null;\n    if (reader == null) {\n      readerHandle = myCompressedAppendableFile != null ? null : ourReadersCache.get(myPath);\n      reader = myCompressedAppendableFile != null ? null : readerHandle.get();\n    }\n\n    try {\n      while (chunk != 0) {\n        if (chunk < 0 || chunk > mySize) throw new PersistentEnumeratorBase.CorruptedException(myFile);\n        int len = (int)Math.min(myBuffer.length, mySize - chunk);\n\n        if (myCompressedAppendableFile != null) {\n          DataInputStream stream = myCompressedAppendableFile.getStream(chunk);\n          stream.readFully(myBuffer, 0, len);\n          stream.close();\n        } else {\n          reader.get(chunk, myBuffer, 0, len);\n        }\n        myBufferStreamWrapper.init(myBuffer, 0, len);\n\n        final int chunkSize = DataInputOutputUtil.readINT(myBufferDataStreamWrapper);\n        if (chunkSize < 0) {\n          throw new IOException(\"Value storage corrupted: negative chunk size: \"+chunkSize);\n        }\n        final long prevChunkAddress = readPrevChunkAddress(chunk);\n        final int headerOffset = len - myBufferStreamWrapper.available();\n\n        byte[] b = new byte[(result != null ? result.length:0) + chunkSize];\n        if (result != null) System.arraycopy(result, 0, b, b.length - result.length, result.length);\n        result = b;\n\n        checkPreconditions(result, chunkSize, 0);\n        if (chunkSize < myBuffer.length - headerOffset) {\n          System.arraycopy(myBuffer, headerOffset, result, 0, chunkSize);\n        } else {\n          if (myCompressedAppendableFile != null) {\n            DataInputStream stream = myCompressedAppendableFile.getStream(chunk + headerOffset);\n            stream.readFully(result, 0, chunkSize);\n            stream.close();\n          } else {\n            reader.get(chunk + headerOffset, result, 0, chunkSize);\n          }\n        }\n\n        if (prevChunkAddress >= chunk) throw new PersistentEnumeratorBase.CorruptedException(myFile);\n\n        chunk = prevChunkAddress;\n        chunkCount++;\n\n        if (prevChunkAddress != 0) checkCancellation();\n        if (result.length > mySize && myCompressedAppendableFile == null) {\n          throw new PersistentEnumeratorBase.CorruptedException(myFile);\n        }\n      }\n    } catch (OutOfMemoryError error) {\n      result = null;\n      throw new PersistentEnumeratorBase.CorruptedException(myFile);\n    }\n    finally {\n      if (readerHandle != null) {\n        readerHandle.release();\n      }\n    }\n\n    if (chunkCount > 1 && !myCompactionMode) {\n      checkCancellation();\n      long endCompactionTime = ourDumpChunkRemovalTime ? System.nanoTime() : 0;\n      long diff = endCompactionTime - startedTime;\n\n      myChunksRemovalTime += diff;\n      myChunks += chunkCount;\n      if (ourDumpChunkRemovalTime && chunkCount > 2) {\n        System.out.println(\"Removed \" + chunkCount + \" chunks for \" + (diff / 1000000) + \"ms, bytes: \" + result.length + \", total: \" +\n                           (myChunksRemovalTime / 1000000) + \"ms for \" + myChunks + \" chunks in \" + myPath);\n      }\n      long l = appendBytes(new ByteSequence(result), 0);\n      return new ReadResult(l, result);\n    }\n\n    return new ReadResult(tailChunkAddress, result);\n  }","commit_id":"9c92e04d821fd5f5756c48c101f925ea3dbf3bbc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testPerCallTimeout() throws Exception {\n        CSL csl = new CSL();\n\n        ClientConfig config = new ClientConfig(null, null, csl);\n        config.setProcedureCallTimeout(500);\n        Client client = ClientFactory.createClient(config);\n        client.createConnection(\"localhost\");\n\n        ClientResponse response = client.callProcedure(\"ArbitraryDurationProc\", 0);\n        assertEquals(ClientResponse.SUCCESS, response.getStatus());\n\n        try {\n            client.callProcedure(\"ArbitraryDurationProc\", 3000);\n            fail();\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().startsWith(\"No response received in the allotted time\"));\n        }\n        // make sure the callback gets called\n        assertTrue(csl.waitForCall(6000));\n\n        //\n        // From here down test special exception for slow snapshots or catalogs updates\n        //\n\n        // build a catalog with a ton of indexes so catalog update will be slow\n        CatalogBuilder builder = new CatalogBuilder();\n        builder.addSchema(getClass().getResource(\"clientfeatures-wellindexed.sql\"));\n        builder.addProcedures(ArbitraryDurationProc.class);\n        byte[] catalogToUpdate = builder.compileToBytes();\n        assert(catalogToUpdate != null);\n\n        // make a copy of the table from ddl for loading\n        // (shouldn't have to do this, but for now, the table loader requires\n        //  a VoltTable, and can't read schema. Could fix by using this VoltTable\n        //  to generate schema or by teaching to loader how to discover tables)\n        VoltTable t = TableHelper.quickTable(\"indexme (pkey:bigint, \" +\n                                                      \"c01:varchar63, \" +\n                                                      \"c02:varchar63, \" +\n                                                      \"c03:varchar63, \" +\n                                                      \"c04:varchar63, \" +\n                                                      \"c05:varchar63, \" +\n                                                      \"c06:varchar63, \" +\n                                                      \"c07:varchar63, \" +\n                                                      \"c08:varchar63, \" +\n                                                      \"c09:varchar63, \" +\n                                                      \"c10:varchar63) \" +\n                                                      \"PKEY(pkey)\");\n        // get a client with a normal timout\n        Client client2 = ClientFactory.createClient();\n        client2.createConnection(\"localhost\");\n        TableHelper.fillTableWithBigintPkey(t, 400, client2, new Random(), 0, 1);\n\n        // run a catalog update that *might* normally timeout\n        long start = System.nanoTime();\n        response = client.callProcedure(\"@UpdateApplicationCatalog\", catalogToUpdate, depBuilder.getXML());\n        double duration = (System.nanoTime() - start) / 1000000000.0;\n        System.out.printf(\"Catalog update duration in seconds: %.2f\\n\", duration);\n        assertEquals(ClientResponse.SUCCESS, response.getStatus());\n\n        // run a blocking snapshot that *might* normally timeout\n        start = System.nanoTime();\n        response = client.callProcedure(\"@SnapshotSave\", Configuration.getPathToCatalogForTest(\"\"), \"slow\", 1);\n        duration = (System.nanoTime() - start) / 1000000000.0;\n        System.out.printf(\"Snapshot save duration in seconds: %.2f\\n\", duration);\n        assertEquals(ClientResponse.SUCCESS, response.getStatus());\n    }","id":67468,"modified_method":"public void testPerCallTimeout() throws Exception {\n        CSL csl = new CSL();\n\n        ClientConfig config = new ClientConfig(null, null, csl);\n        config.setProcedureCallTimeout(500);\n        Client client = ClientFactory.createClient(config);\n        client.createConnection(\"localhost\");\n\n        ClientResponse response = client.callProcedure(\"ArbitraryDurationProc\", 0);\n        assertEquals(ClientResponse.SUCCESS, response.getStatus());\n\n        try {\n            client.callProcedure(\"ArbitraryDurationProc\", 3000);\n            fail();\n        }\n        catch (ProcCallException e) {\n            assertTrue(e.getMessage().startsWith(\"No response received in the allotted time\"));\n        }\n        // make sure the callback gets called\n        assertTrue(csl.waitForCall(6000));\n\n        //\n        // From here down test special exception for slow snapshots or catalogs updates\n        //\n\n        // build a catalog with a ton of indexes so catalog update will be slow\n        CatalogBuilder builder = new CatalogBuilder();\n        builder.addSchema(getClass().getResource(\"clientfeatures-wellindexed.sql\"));\n        builder.addProcedures(ArbitraryDurationProc.class);\n        byte[] catalogToUpdate = builder.compileToBytes();\n        assert(catalogToUpdate != null);\n\n        // make a copy of the table from ddl for loading\n        // (shouldn't have to do this, but for now, the table loader requires\n        //  a VoltTable, and can't read schema. Could fix by using this VoltTable\n        //  to generate schema or by teaching to loader how to discover tables)\n        VoltTable t = TableHelper.quickTable(\"indexme (pkey:bigint, \" +\n                                                      \"c01:varchar63, \" +\n                                                      \"c02:varchar63, \" +\n                                                      \"c03:varchar63, \" +\n                                                      \"c04:varchar63, \" +\n                                                      \"c05:varchar63, \" +\n                                                      \"c06:varchar63, \" +\n                                                      \"c07:varchar63, \" +\n                                                      \"c08:varchar63, \" +\n                                                      \"c09:varchar63, \" +\n                                                      \"c10:varchar63) \" +\n                                                      \"PKEY(pkey)\");\n        // get a client with a normal timout\n        Client client2 = ClientFactory.createClient();\n        client2.createConnection(\"localhost\");\n        TableHelper.fillTableWithBigintPkey(t, 400, client2, new Random(), 0, 1);\n\n        long start;\n        double duration;\n\n        if (VoltDB.instance().getConfig().m_isEnterprise) {\n            // run a catalog update that *might* normally timeout\n            start = System.nanoTime();\n            response = client.callProcedure(\"@UpdateApplicationCatalog\", catalogToUpdate, depBuilder.getXML());\n            duration = (System.nanoTime() - start) / 1000000000.0;\n            System.out.printf(\"Catalog update duration in seconds: %.2f\\n\", duration);\n            assertEquals(ClientResponse.SUCCESS, response.getStatus());\n        }\n\n        // run a blocking snapshot that *might* normally timeout\n        start = System.nanoTime();\n        response = client.callProcedure(\"@SnapshotSave\", Configuration.getPathToCatalogForTest(\"\"), \"slow\", 1);\n        duration = (System.nanoTime() - start) / 1000000000.0;\n        System.out.printf(\"Snapshot save duration in seconds: %.2f\\n\", duration);\n        assertEquals(ClientResponse.SUCCESS, response.getStatus());\n    }","commit_id":"5a3cba16e4dbda74946eebfeb8776994701e13f8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testJSONAuth() throws Exception {\n    try {\n        String simpleSchema =\n            \"CREATE TABLE HELLOWORLD (\\n\" +\n            \"    HELLO VARCHAR(15),\\n\" +\n            \"    WORLD VARCHAR(20),\\n\" +\n            \"    DIALECT VARCHAR(15) NOT NULL,\\n\" +\n            \"    PRIMARY KEY (DIALECT)\\n\" +\n            \");\";\n\n        File schemaFile = VoltProjectBuilder.writeStringToTempFile(simpleSchema);\n        String schemaPath = schemaFile.getPath();\n        schemaPath = URLEncoder.encode(schemaPath, \"UTF-8\");\n\n        VoltProjectBuilder builder = new VoltProjectBuilder();\n        builder.addSchema(schemaPath);\n        builder.addPartitionInfo(\"HELLOWORLD\", \"DIALECT\");\n\n        GroupInfo gi = new GroupInfo(\"foo\", true, true, true);\n        builder.addGroups(new GroupInfo[] { gi } );\n\n        // create 20 users, only the first one has an interesting user/pass\n        UserInfo[] ui = new UserInfo[15];\n        ui[0] = new UserInfo(\"ry@nlikesthe\", \"y@nkees\", new String[] { \"foo\" } );\n        for (int i = 1; i < ui.length; i++) {\n            ui[i] = new UserInfo(\"USER\" + String.valueOf(i), \"PASS\" + String.valueOf(i), new String[] { \"foo\" } );\n        }\n        builder.addUsers(ui);\n\n        builder.setSecurityEnabled(true);\n\n        ProcedureInfo[] pi = new ProcedureInfo[2];\n        pi[0] = new ProcedureInfo(new String[] { \"foo\" }, \"Insert\", \"insert into HELLOWORLD values (?,?,?);\", null);\n        pi[1] = new ProcedureInfo(new String[] { \"foo\" }, \"Select\", \"select * from HELLOWORLD;\", null);\n        builder.addProcedures(pi);\n\n        builder.setHTTPDPort(8095);\n\n        boolean success = builder.compile(Configuration.getPathToCatalogForTest(\"json.jar\"));\n        assertTrue(success);\n\n        VoltDB.Configuration config = new VoltDB.Configuration();\n        config.m_pathToCatalog = config.setPathToCatalogForTest(\"json.jar\");\n        config.m_pathToDeployment = builder.getPathToDeployment();\n        server = new ServerThread(config);\n        server.start();\n        server.waitForInitialization();\n\n        // test good auths\n        for (UserInfo u : ui) {\n            ParameterSet pset = new ParameterSet();\n            pset.setParameters(u.name, u.password, u.name);\n            String response = callProcOverJSON(\"Insert\", pset, u.name, u.password, true);\n            Response r = responseFromJSON(response);\n            assertEquals(ClientResponse.SUCCESS, r.status);\n        }\n        // test re-using auths\n        for (UserInfo u : ui) {\n            ParameterSet pset = new ParameterSet();\n            pset.setParameters(u.name + \"-X\", u.password + \"-X\", u.name + \"-X\");\n            String response = callProcOverJSON(\"Insert\", pset, u.name, u.password, false);\n            Response r = responseFromJSON(response);\n            assertEquals(ClientResponse.SUCCESS, r.status);\n        }\n\n        // test bad auth\n        UserInfo u = ui[0];\n        ParameterSet pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X1\", u.password + \"-X1\", u.name + \"-X1\");\n        String response = callProcOverJSON(\"Insert\", pset, u.name, \"ick\", true);\n        Response r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        response = callProcOverJSON(\"Insert\", pset, u.name, \"ick\", false);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n\n        // test malformed auth (too short hash)\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X2\", u.password + \"-X2\", u.name + \"-X2\");\n        String paramsInJSON = pset.toJSONString();\n        HashMap<String,String> params = new HashMap<String,String>();\n        params.put(\"Procedure\", \"Insert\");\n        params.put(\"Parameters\", paramsInJSON);\n        params.put(\"User\", u.name);\n        params.put(\"Password\", Encoder.hexEncode(new byte[] {1,2,3}));\n        String varString = getHTTPVarString(params);\n        response = callProcOverJSONRaw(varString, 200);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n\n        // test malformed auth (gibberish password, but good length)\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X3\", u.password + \"-X3\", u.name + \"-X3\");\n        paramsInJSON = pset.toJSONString();\n        params = new HashMap<String,String>();\n        params.put(\"Procedure\", \"Insert\");\n        params.put(\"Parameters\", paramsInJSON);\n        params.put(\"User\", u.name);\n        params.put(\"Password\", \"abcdefghiabcdefghiabcdefghiabcdefghi\");\n        varString = getHTTPVarString(params);\n        response = callProcOverJSONRaw(varString, 200);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n\n        // test back-to-back rejections, unknown user\n        // partial ENG-954 test (make sure the rejection timeout works)\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X4\", u.password + \"-X4\", u.name + \"-X4\");\n        response = callProcOverJSON(\"Insert\", pset, \"rando\", \"ick\", true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"Authentication rejected\"));\n        System.out.println(r.statusString);\n        response = callProcOverJSON(\"Insert\", pset, \"rando\", \"ick\", true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"rejected due to too many recent rejected attempts\"));\n        System.out.println(r.statusString);\n        // Rejection timeout is 1 second, sleep for slightly more and make sure we get the first error\n        Thread.sleep(1100);\n        response = callProcOverJSON(\"Insert\", pset, \"rando\", \"ick\", true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"Authentication rejected\"));\n        System.out.println(r.statusString);\n\n        // ENG-1115 test (make sure the rejection timeout works when the password is null\n        // but the username is not)\n        // Wait and clear the authentication failure timeout from above\n        Thread.sleep(1100);\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X4\", u.password + \"-X4\", u.name + \"-X4\");\n        response = callProcOverJSON(\"Insert\", pset, \"rando2\", null, true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"Authentication rejected\"));\n        System.out.println(r.statusString);\n        response = callProcOverJSON(\"Insert\", pset, \"rando2\", null, true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"rejected due to too many recent rejected attempts\"));\n        System.out.println(r.statusString);\n\n\n        // ENG-963 below here\n        // do enough to get a new deployment file\n        VoltProjectBuilder builder2 = new VoltProjectBuilder();\n        builder2.addSchema(schemaPath);\n        builder2.addPartitionInfo(\"HELLOWORLD\", \"DIALECT\");\n\n        // Same groups\n        builder2.addGroups(new GroupInfo[] { gi } );\n\n        // create same 15 users, hack the last 14 passwords\n        ui = new UserInfo[15];\n        ui[0] = new UserInfo(\"ry@nlikesthe\", \"y@nkees\", new String[] { \"foo\" } );\n        for (int i = 1; i < ui.length; i++) {\n            ui[i] = new UserInfo(\"USER\" + String.valueOf(i),\n                                 \"welcomehackers\" + String.valueOf(i),\n                                 new String[] { \"foo\" } );\n        }\n        builder2.addUsers(ui);\n\n        builder2.setSecurityEnabled(true);\n        builder2.addProcedures(pi);\n        builder2.setHTTPDPort(8095);\n\n        success = builder2.compile(Configuration.getPathToCatalogForTest(\"json-update.jar\"));\n        assertTrue(success);\n\n        pset = new ParameterSet();\n        pset.setParameters(Encoder.hexEncode(CatalogUtil.toBytes(new File(config.m_pathToCatalog))),\n                           new String(CatalogUtil.toBytes(new File(builder2.getPathToDeployment())), \"UTF-8\"));\n        response = callProcOverJSON(\"@UpdateApplicationCatalog\", pset,\n                                    ui[0].name, ui[0].password, true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.SUCCESS, r.status);\n\n        // retest the good auths above\n        for (UserInfo user : ui) {\n            ParameterSet ps = new ParameterSet();\n            ps.setParameters(user.name + \"-X3\", user.password + \"-X3\", user.name + \"-X3\");\n            String respstr = callProcOverJSON(\"Insert\", ps, user.name, user.password, false);\n            Response resp = responseFromJSON(respstr);\n            assertEquals(ClientResponse.SUCCESS, resp.status);\n        }\n    } finally {\n        if (server != null) {\n            server.shutdown();\n            server.join();\n        }\n        server = null;\n    }\n    }","id":67469,"modified_method":"public void testJSONAuth() throws Exception {\n    try {\n        String simpleSchema =\n            \"CREATE TABLE HELLOWORLD (\\n\" +\n            \"    HELLO VARCHAR(15),\\n\" +\n            \"    WORLD VARCHAR(20),\\n\" +\n            \"    DIALECT VARCHAR(15) NOT NULL,\\n\" +\n            \"    PRIMARY KEY (DIALECT)\\n\" +\n            \");\";\n\n        File schemaFile = VoltProjectBuilder.writeStringToTempFile(simpleSchema);\n        String schemaPath = schemaFile.getPath();\n        schemaPath = URLEncoder.encode(schemaPath, \"UTF-8\");\n\n        VoltProjectBuilder builder = new VoltProjectBuilder();\n        builder.addSchema(schemaPath);\n        builder.addPartitionInfo(\"HELLOWORLD\", \"DIALECT\");\n\n        GroupInfo gi = new GroupInfo(\"foo\", true, true, true);\n        builder.addGroups(new GroupInfo[] { gi } );\n\n        // create 20 users, only the first one has an interesting user/pass\n        UserInfo[] ui = new UserInfo[15];\n        ui[0] = new UserInfo(\"ry@nlikesthe\", \"y@nkees\", new String[] { \"foo\" } );\n        for (int i = 1; i < ui.length; i++) {\n            ui[i] = new UserInfo(\"USER\" + String.valueOf(i), \"PASS\" + String.valueOf(i), new String[] { \"foo\" } );\n        }\n        builder.addUsers(ui);\n\n        builder.setSecurityEnabled(true);\n\n        ProcedureInfo[] pi = new ProcedureInfo[2];\n        pi[0] = new ProcedureInfo(new String[] { \"foo\" }, \"Insert\", \"insert into HELLOWORLD values (?,?,?);\", null);\n        pi[1] = new ProcedureInfo(new String[] { \"foo\" }, \"Select\", \"select * from HELLOWORLD;\", null);\n        builder.addProcedures(pi);\n\n        builder.setHTTPDPort(8095);\n\n        boolean success = builder.compile(Configuration.getPathToCatalogForTest(\"json.jar\"));\n        assertTrue(success);\n\n        VoltDB.Configuration config = new VoltDB.Configuration();\n        config.m_pathToCatalog = config.setPathToCatalogForTest(\"json.jar\");\n        config.m_pathToDeployment = builder.getPathToDeployment();\n        server = new ServerThread(config);\n        server.start();\n        server.waitForInitialization();\n\n        // test good auths\n        for (UserInfo u : ui) {\n            ParameterSet pset = new ParameterSet();\n            pset.setParameters(u.name, u.password, u.name);\n            String response = callProcOverJSON(\"Insert\", pset, u.name, u.password, true);\n            Response r = responseFromJSON(response);\n            assertEquals(ClientResponse.SUCCESS, r.status);\n        }\n        // test re-using auths\n        for (UserInfo u : ui) {\n            ParameterSet pset = new ParameterSet();\n            pset.setParameters(u.name + \"-X\", u.password + \"-X\", u.name + \"-X\");\n            String response = callProcOverJSON(\"Insert\", pset, u.name, u.password, false);\n            Response r = responseFromJSON(response);\n            assertEquals(ClientResponse.SUCCESS, r.status);\n        }\n\n        // test bad auth\n        UserInfo u = ui[0];\n        ParameterSet pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X1\", u.password + \"-X1\", u.name + \"-X1\");\n        String response = callProcOverJSON(\"Insert\", pset, u.name, \"ick\", true);\n        Response r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        response = callProcOverJSON(\"Insert\", pset, u.name, \"ick\", false);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n\n        // test malformed auth (too short hash)\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X2\", u.password + \"-X2\", u.name + \"-X2\");\n        String paramsInJSON = pset.toJSONString();\n        HashMap<String,String> params = new HashMap<String,String>();\n        params.put(\"Procedure\", \"Insert\");\n        params.put(\"Parameters\", paramsInJSON);\n        params.put(\"User\", u.name);\n        params.put(\"Password\", Encoder.hexEncode(new byte[] {1,2,3}));\n        String varString = getHTTPVarString(params);\n        response = callProcOverJSONRaw(varString, 200);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n\n        // test malformed auth (gibberish password, but good length)\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X3\", u.password + \"-X3\", u.name + \"-X3\");\n        paramsInJSON = pset.toJSONString();\n        params = new HashMap<String,String>();\n        params.put(\"Procedure\", \"Insert\");\n        params.put(\"Parameters\", paramsInJSON);\n        params.put(\"User\", u.name);\n        params.put(\"Password\", \"abcdefghiabcdefghiabcdefghiabcdefghi\");\n        varString = getHTTPVarString(params);\n        response = callProcOverJSONRaw(varString, 200);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n\n        // test back-to-back rejections, unknown user\n        // partial ENG-954 test (make sure the rejection timeout works)\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X4\", u.password + \"-X4\", u.name + \"-X4\");\n        response = callProcOverJSON(\"Insert\", pset, \"rando\", \"ick\", true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"Authentication rejected\"));\n        System.out.println(r.statusString);\n        response = callProcOverJSON(\"Insert\", pset, \"rando\", \"ick\", true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"rejected due to too many recent rejected attempts\"));\n        System.out.println(r.statusString);\n        // Rejection timeout is 1 second, sleep for slightly more and make sure we get the first error\n        Thread.sleep(1100);\n        response = callProcOverJSON(\"Insert\", pset, \"rando\", \"ick\", true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"Authentication rejected\"));\n        System.out.println(r.statusString);\n\n        // ENG-1115 test (make sure the rejection timeout works when the password is null\n        // but the username is not)\n        // Wait and clear the authentication failure timeout from above\n        Thread.sleep(1100);\n        pset = new ParameterSet();\n        pset.setParameters(u.name + \"-X4\", u.password + \"-X4\", u.name + \"-X4\");\n        response = callProcOverJSON(\"Insert\", pset, \"rando2\", null, true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"Authentication rejected\"));\n        System.out.println(r.statusString);\n        response = callProcOverJSON(\"Insert\", pset, \"rando2\", null, true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.UNEXPECTED_FAILURE, r.status);\n        assertTrue(r.statusString.contains(\"rejected due to too many recent rejected attempts\"));\n        System.out.println(r.statusString);\n\n        // the update catalog test below is for enterprise only\n        if (VoltDB.instance().getConfig().m_isEnterprise == false) {\n            return;\n        }\n\n        // ENG-963 below here\n        // do enough to get a new deployment file\n        VoltProjectBuilder builder2 = new VoltProjectBuilder();\n        builder2.addSchema(schemaPath);\n        builder2.addPartitionInfo(\"HELLOWORLD\", \"DIALECT\");\n\n        // Same groups\n        builder2.addGroups(new GroupInfo[] { gi } );\n\n        // create same 15 users, hack the last 14 passwords\n        ui = new UserInfo[15];\n        ui[0] = new UserInfo(\"ry@nlikesthe\", \"y@nkees\", new String[] { \"foo\" } );\n        for (int i = 1; i < ui.length; i++) {\n            ui[i] = new UserInfo(\"USER\" + String.valueOf(i),\n                                 \"welcomehackers\" + String.valueOf(i),\n                                 new String[] { \"foo\" } );\n        }\n        builder2.addUsers(ui);\n\n        builder2.setSecurityEnabled(true);\n        builder2.addProcedures(pi);\n        builder2.setHTTPDPort(8095);\n\n        success = builder2.compile(Configuration.getPathToCatalogForTest(\"json-update.jar\"));\n        assertTrue(success);\n\n        pset = new ParameterSet();\n        pset.setParameters(Encoder.hexEncode(CatalogUtil.toBytes(new File(config.m_pathToCatalog))),\n                           new String(CatalogUtil.toBytes(new File(builder2.getPathToDeployment())), \"UTF-8\"));\n        response = callProcOverJSON(\"@UpdateApplicationCatalog\", pset,\n                                    ui[0].name, ui[0].password, true);\n        r = responseFromJSON(response);\n        assertEquals(ClientResponse.SUCCESS, r.status);\n\n        // retest the good auths above\n        for (UserInfo user : ui) {\n            ParameterSet ps = new ParameterSet();\n            ps.setParameters(user.name + \"-X3\", user.password + \"-X3\", user.name + \"-X3\");\n            String respstr = callProcOverJSON(\"Insert\", ps, user.name, user.password, false);\n            Response resp = responseFromJSON(respstr);\n            assertEquals(ClientResponse.SUCCESS, resp.status);\n        }\n    } finally {\n        if (server != null) {\n            server.shutdown();\n            server.join();\n        }\n        server = null;\n    }\n    }","commit_id":"5a3cba16e4dbda74946eebfeb8776994701e13f8","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\r\n\t * helper method to load a specific library in an operation system dependant manner\r\n\t * \r\n\t * @param resource the name of the resource\r\n\t */\r\n\tprivate static void loadLibrary (String resource) {\r\n\t\tString package_path = \"/javax/media/\";\r\n\t\tString library = \"\";\r\n\r\n\t\tString os = System.getProperty(\"os.name\");\r\n\t\tString arch = System.getProperty(\"os.arch\");\r\n\r\n\t\tif (os.contains(\"Windows\")) {\r\n\t\t\tif (!arch.equals(\"amd64\"))\r\n\t\t\t\tlibrary = resource + \"-win32.dll\";\r\n\t\t\telse {\r\n\t\t\t\tlibrary = resource + \"-win64.dll\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (os.contains(\"Linux\")) {\r\n\t\t\tif (!arch.equals(\"amd64\"))\r\n\t\t\t\tlibrary = \"lib\" + resource + \"-linux32.so\";\r\n\t\t\telse\r\n\t\t\t\tlibrary = \"lib\" + resource + \"-linux64.so\";\r\n\t\t}\r\n\r\n\t\tif (os.contains(\"Mac\")) {\r\n\t\t\tlibrary = \"lib\" + resource + \".jnilib\";\r\n\t\t}\r\n\t\tload(package_path, library);\r\n\t}","id":67470,"modified_method":"/**\r\n\t * helper method to load a specific library in an operation system dependant manner\r\n\t * \r\n\t * @param resource the name of the resource\r\n\t */\r\n\tprivate static void loadLibrary (String resource) {\r\n\t\tString package_path = \"/javax/media/\";\r\n\t\tString library = \"\";\r\n\r\n\t\tString os = System.getProperty(\"os.name\");\r\n\t\tString arch = System.getProperty(\"os.arch\");\r\n\r\n\t\tif (os.contains(\"Windows\")) {\r\n\t\t\tif (!arch.equals(\"amd64\"))\r\n\t\t\t\tlibrary = resource + \"-win32.dll\";\r\n\t\t\telse {\r\n\t\t\t\tlibrary = resource + \"-win64.dll\";\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (os.contains(\"Linux\")) {\r\n\t\t\tif (!arch.equals(\"amd64\"))\r\n\t\t\t\tlibrary = \"lib\" + resource + \"-linux32.so\";\r\n\t\t\telse\r\n\t\t\t\tlibrary = \"lib\" + resource + \"-linux64.so\";\r\n\t\t}\r\n\r\n\t\tif (os.contains(\"Mac\")) {\r\n\t\t\tlibrary = \"lib\" + resource + \".jnilib\";\r\n\t\t}\r\n\t\tload(package_path, library, true);\r\n\t}","commit_id":"f986bb27d834472bf51d655bcb12bbc7b7ab22b5","url":"https://github.com/libgdx/libgdx"},{"original_method":"/**\r\n\t * loads the necessary libraries depending on the operating system\r\n\t */\r\n\tstatic void loadLibraries () {\r\n\t\tif (nativesLoaded) return;\r\n\r\n\t\tNativeLibLoader.disableLoading();\r\n\t\tcom.sun.gluegen.runtime.NativeLibLoader.disableLoading();\r\n\t\t// By wkien: On some systems (read: mine) jogl_awt would not find its\r\n\t\t// dependency jawt if not loaded before\r\n\t\tif (System.getProperty(\"os.name\", \"\").contains(\"Windows\")\r\n\t\t\t&& !System.getProperty(\"libgdx.nojawtpreloading\", \"false\").contains(\"true\")) {\r\n\t\t\ttry {\r\n\t\t\t\tSystem.loadLibrary(\"jawt\");\r\n\t\t\t} catch (Exception ex) {\r\n\t\t\t\tSystem.err.println(\"WARNING: Unable to load native jawt library: '\" + ex.getMessage() + \"'\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tloadLibrary(\"gluegen-rt\");\r\n\t\tloadLibrary(\"jogl_awt\");\r\n\t\tloadLibrary(\"jogl\");\r\n\r\n\t\tString os = System.getProperty(\"os.name\");\r\n\t\tboolean is64Bit = System.getProperty(\"os.arch\").equals(\"amd64\");\r\n\t\tif (os.contains(\"Windows\")) {\r\n\t\t\tload(\"/native/windows/\", is64Bit ? \"lwjgl64.dll\" : \"lwjgl.dll\");\r\n\t\t\tload(\"/native/windows/\", is64Bit ? \"OpenAL64.dll\" : \"OpenAL32.dll\");\r\n\t\t} else if (os.contains(\"Linux\")) {\r\n\t\t\tload(\"/native/linux/\", is64Bit ? \"liblwjgl64.so\" : \"liblwjgl.so\");\r\n\t\t\tload(\"/native/linux/\", is64Bit ? \"libopenal64.so\" : \"libopenal.so\");\r\n\t\t} else if (os.contains(\"Mac\")) {\r\n\t\t\tload(\"/native/macosx/\", \"liblwjgl.jnilib\");\r\n\t\t\tload(\"/native/macosx/\", \"libopenal.dylib\");\r\n\t\t}\r\n\t\tSystem.setProperty(\"org.lwjgl.librarypath\", new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath());\r\n\r\n\t\tnativesLoaded = true;\r\n\t}","id":67471,"modified_method":"/**\r\n\t * loads the necessary libraries depending on the operating system\r\n\t */\r\n\tstatic void loadLibraries () {\r\n\t\tif (nativesLoaded) return;\r\n\r\n\t\tNativeLibLoader.disableLoading();\r\n\t\tcom.sun.gluegen.runtime.NativeLibLoader.disableLoading();\r\n\t\t// By wkien: On some systems (read: mine) jogl_awt would not find its\r\n\t\t// dependency jawt if not loaded before\r\n\t\tif (System.getProperty(\"os.name\", \"\").contains(\"Windows\")\r\n\t\t\t&& !System.getProperty(\"libgdx.nojawtpreloading\", \"false\").contains(\"true\")) {\r\n\t\t\ttry {\r\n\t\t\t\tSystem.loadLibrary(\"jawt\");\r\n\t\t\t} catch (Exception ex) {\r\n\t\t\t\tSystem.err.println(\"WARNING: Unable to load native jawt library: '\" + ex.getMessage() + \"'\");\r\n\t\t\t}\r\n\t\t}\r\n\t\tloadLibrary(\"gluegen-rt\");\r\n\t\tloadLibrary(\"jogl_awt\");\r\n\t\tloadLibrary(\"jogl\");\r\n\r\n\t\tString os = System.getProperty(\"os.name\");\r\n\t\tboolean is64Bit = System.getProperty(\"os.arch\").equals(\"amd64\");\r\n\t\tif (os.contains(\"Windows\")) {\r\n\t\t\tload(\"/native/windows/\", is64Bit ? \"lwjgl64.dll\" : \"lwjgl.dll\", false);\r\n\t\t\tload(\"/native/windows/\", is64Bit ? \"OpenAL64.dll\" : \"OpenAL32.dll\", false);\r\n\t\t} else if (os.contains(\"Linux\")) {\r\n\t\t\tload(\"/native/linux/\", is64Bit ? \"liblwjgl64.so\" : \"liblwjgl.so\", false);\r\n\t\t\tload(\"/native/linux/\", is64Bit ? \"libopenal64.so\" : \"libopenal.so\", false);\r\n\t\t} else if (os.contains(\"Mac\")) {\r\n\t\t\tload(\"/native/macosx/\", \"liblwjgl.jnilib\", false);\r\n\t\t\tload(\"/native/macosx/\", \"libopenal.dylib\", false);\r\n\t\t}\r\n\t\tSystem.setProperty(\"org.lwjgl.librarypath\", new File(System.getProperty(\"java.io.tmpdir\")).getAbsolutePath());\r\n\r\n\t\tnativesLoaded = true;\r\n\t}","commit_id":"f986bb27d834472bf51d655bcb12bbc7b7ab22b5","url":"https://github.com/libgdx/libgdx"},{"original_method":"private static void load (String package_path, String library) {\r\n\t\tString so = System.getProperty(\"java.io.tmpdir\") + \"/\" + System.nanoTime() + library;\r\n\t\tInputStream in = JoglGraphics.class.getResourceAsStream(package_path + library);\r\n\t\tif (in == null) throw new RuntimeException(\"couldn't find \" + library + \" in jar file.\");\r\n\r\n\t\ttry {\r\n\t\t\tBufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(so));\r\n\t\t\tbyte[] bytes = new byte[1024 * 4];\r\n\t\t\twhile (true) {\r\n\t\t\t\tint read_bytes = in.read(bytes);\r\n\t\t\t\tif (read_bytes == -1) break;\r\n\r\n\t\t\t\tout.write(bytes, 0, read_bytes);\r\n\t\t\t}\r\n\t\t\tout.close();\r\n\t\t\tin.close();\r\n\t\t\tSystem.load(so);\r\n\t\t} catch (FileNotFoundException e) {\r\n\t\t\tthrow new RuntimeException(\"couldn't write \" + library + \" to temporary file \" + so);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"couldn't write \" + library + \" to temporary file \" + so);\r\n\t\t}\r\n\t}","id":67472,"modified_method":"private static void load (String package_path, String library, boolean stamped) {\r\n\t\tString so = System.getProperty(\"java.io.tmpdir\") + \"/\" + (stamped?System.nanoTime():\"\") + library;\r\n\t\tInputStream in = JoglGraphics.class.getResourceAsStream(package_path + library);\r\n\t\tif (in == null) throw new RuntimeException(\"couldn't find \" + library + \" in jar file.\");\r\n\r\n\t\ttry {\r\n\t\t\tBufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(so));\r\n\t\t\tbyte[] bytes = new byte[1024 * 4];\r\n\t\t\twhile (true) {\r\n\t\t\t\tint read_bytes = in.read(bytes);\r\n\t\t\t\tif (read_bytes == -1) break;\r\n\r\n\t\t\t\tout.write(bytes, 0, read_bytes);\r\n\t\t\t}\r\n\t\t\tout.close();\r\n\t\t\tin.close();\r\n\t\t\tSystem.load(so);\r\n\t\t} catch (FileNotFoundException e) {\r\n\t\t\tif(stamped)\r\n\t\t\t\tthrow new RuntimeException(\"couldn't write \" + library + \" to temporary file \" + so);\r\n\t\t} catch (IOException e) {\r\n\t\t\tthrow new RuntimeException(\"couldn't write \" + library + \" to temporary file \" + so);\r\n\t\t}\r\n\t}","commit_id":"f986bb27d834472bf51d655bcb12bbc7b7ab22b5","url":"https://github.com/libgdx/libgdx"},{"original_method":"public void restoreState() {\n      assert myState != null && mySharedState != null;\n      getRunManager().initializeConfigurationTypes(RunConfigurationsStateManager.getConfigurationTypes());\n      try {\n        getRunManager().readExternal(myState);\n        getSharedConfigurationManager().readExternal(mySharedState);\n      } catch (InvalidDataException e) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"Can't read execution configurations state\", e);\n        }\n      }\n    }","id":67473,"modified_method":"public void restoreState() {\n      assert myState != null && mySharedState != null;\n      getRunManager().initializeConfigurationTypes(RunConfigurationsStateManager.getConfigurationTypes());\n      try {\n        getRunManager().loadState(myState);\n        getSharedConfigurationManager().loadState(mySharedState);\n      } catch (Exception e) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"Can't read execution configurations state\", e);\n        }\n      }\n    }","commit_id":"0f66ee8959c6f6f24e7f53f686df6cf4eac059f3","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void saveState() {\n      try {\n        Element newState = new Element(\"root\");\n        getRunManager().writeExternal(newState);\n        myState = newState;\n\n        Element newSharedState = new Element(\"root\");\n        getSharedConfigurationManager().writeExternal(newSharedState);\n        mySharedState = newSharedState;\n      } catch (WriteExternalException e) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"Can't save run configurations state\", e);\n        }\n      }\n    }","id":67474,"modified_method":"public void saveState() {\n      try {\n        myState = getRunManager().getState();\n\n        mySharedState = getSharedConfigurationManager().getState();\n      } catch (Exception e) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"Can't save run configurations state\", e);\n        }\n      }\n    }","commit_id":"0f66ee8959c6f6f24e7f53f686df6cf4eac059f3","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Element getState() {\n    Element e = new Element(\"state\");\n    try {\n      writeExternal(e);\n    }\n    catch (WriteExternalException ex) {\n      LOG.error(ex);\n    }\n    return e;\n  }","id":67475,"modified_method":"@Override\n  public Element getState() {\n    Element element = XmlSerializer.serialize(this, new SkipDefaultValuesSerializationFilters());\n    String profile = InspectionProfileManager.getInstance().getRootProfile().getName();\n    if (!\"Default\".equals(profile)) {\n      element.setAttribute(\"profile\", profile);\n    }\n    return element;\n  }","commit_id":"36e0760408d01b69503dddee7de062f7e10aeb62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isCodeHighlightingChanged(DaemonCodeAnalyzerSettings oldSettings) {\n    try {\n      Element rootNew = new Element(ROOT_TAG);\n      writeExternal(rootNew);\n      Element rootOld = new Element(ROOT_TAG);\n      ((DaemonCodeAnalyzerSettingsImpl)oldSettings).writeExternal(rootOld);\n\n      return !JDOMUtil.areElementsEqual(rootOld, rootNew);\n    }\n    catch (WriteExternalException e) {\n      LOG.error(e);\n    }\n\n    return false;\n  }","id":67476,"modified_method":"@Override\n  public boolean isCodeHighlightingChanged(DaemonCodeAnalyzerSettings oldSettings) {\n    return !JDOMUtil.areElementsEqual(((DaemonCodeAnalyzerSettingsImpl)oldSettings).getState(), getState());\n  }","commit_id":"36e0760408d01b69503dddee7de062f7e10aeb62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void loadState(final Element state) {\n    try {\n      readExternal(state);\n    }\n    catch (InvalidDataException e) {\n      LOG.error(e);\n    }\n  }","id":67477,"modified_method":"@Override\n  public void loadState(Element state) {\n    XmlSerializer.deserializeInto(this, state);\n    InspectionProfileManagerImpl inspectionProfileManager = InspectionProfileManagerImpl.getInstanceImpl();\n    inspectionProfileManager.getConverter().storeEditorHighlightingProfile(state,\n                                                                           new InspectionProfileImpl(InspectionProfileConvertor.OLD_HIGHTLIGHTING_SETTINGS_PROFILE));\n    inspectionProfileManager.setRootProfile(StringUtil.notNullize(state.getAttributeValue(\"profile\"), \"Default\"));\n  }","commit_id":"36e0760408d01b69503dddee7de062f7e10aeb62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public DaemonCodeAnalyzerSettingsImpl clone() {\n    DaemonCodeAnalyzerSettingsImpl settings = new DaemonCodeAnalyzerSettingsImpl(myManager);\n    settings.AUTOREPARSE_DELAY = AUTOREPARSE_DELAY;\n    settings.SHOW_ADD_IMPORT_HINTS = SHOW_ADD_IMPORT_HINTS;\n    settings.SHOW_METHOD_SEPARATORS = SHOW_METHOD_SEPARATORS;\n    settings.NO_AUTO_IMPORT_PATTERN = NO_AUTO_IMPORT_PATTERN;\n    settings.SHOW_SMALL_ICONS_IN_GUTTER = SHOW_SMALL_ICONS_IN_GUTTER;\n    return settings;\n  }","id":67478,"modified_method":"@Override\n  public DaemonCodeAnalyzerSettingsImpl clone() {\n    DaemonCodeAnalyzerSettingsImpl settings = new DaemonCodeAnalyzerSettingsImpl();\n    settings.AUTOREPARSE_DELAY = AUTOREPARSE_DELAY;\n    settings.SHOW_ADD_IMPORT_HINTS = SHOW_ADD_IMPORT_HINTS;\n    settings.SHOW_METHOD_SEPARATORS = SHOW_METHOD_SEPARATORS;\n    settings.NO_AUTO_IMPORT_PATTERN = NO_AUTO_IMPORT_PATTERN;\n    settings.SHOW_SMALL_ICONS_IN_GUTTER = SHOW_SMALL_ICONS_IN_GUTTER;\n    return settings;\n  }","commit_id":"36e0760408d01b69503dddee7de062f7e10aeb62","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        NDC.push(\"Page: \" + getClass().getName()+ (d2wContext()!= null ? (\" - Configuration: \"+d2wContext().valueForKey(\"pageConfiguration\")) : \"\"));\n        try {\n            super.appendToResponse(r,c);\n        } catch(Exception ex) {\n            log.warn(\"Error in D2WPage: propertyKey=\" + propertyKey() + \", componentName=\" + d2wContext().valueForKey(\"componentName\") + \", customComponent=\" +  d2wContext().valueForKey(\"customComponentName\"), ex);\n            throw new NSForwardException(ex, \"Error generating page\");\n        } finally {\n            NDC.pop();\n        }\n    }","id":67479,"modified_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        NDC.push(\"Page: \" + getClass().getName()+ (d2wContext()!= null ? (\" - Configuration: \"+d2wContext().valueForKey(\"pageConfiguration\")) : \"\"));\n        try {\n            super.appendToResponse(r,c);\n        } catch(Exception ex) {\n            ERDirectToWeb.reportException(ex, d2wContext());\n        } finally {\n            NDC.pop();\n        }\n    }","commit_id":"5f1b05d7226306602e5b0d001c7e66cbf3d94556","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        maybeResetCaches();\n        super.appendToResponse(r, c);\n    }","id":67480,"modified_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        try {\n            maybeResetCaches();\n            super.appendToResponse(r,c);\n        } catch(Exception ex) {\n            ERDirectToWeb.reportException(ex, subContext());\n        }\n    }","commit_id":"5f1b05d7226306602e5b0d001c7e66cbf3d94556","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        // in the case where we are non-synchronizing but not stateless, make sure we pull again\n        if (!synchronizesVariablesWithBindings() && !isStateless()) {\n            reset();\n        }\n        super.appendToResponse(r,c);\n    }","id":67481,"modified_method":"public void appendToResponse(WOResponse r, WOContext c) {\n        try {\n            // in the case where we are non-synchronizing but not stateless, make sure we pull again\n            if (!synchronizesVariablesWithBindings() && !isStateless()) {\n                reset();\n            }\n            super.appendToResponse(r,c);\n        } catch(Exception ex) {\n            ERDirectToWeb.reportException(ex, d2wContext());\n        }\n    }","commit_id":"5f1b05d7226306602e5b0d001c7e66cbf3d94556","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean tryToSaveChanges(boolean validateObject) { // throws Throwable {\n        validationLog.debug(\"tryToSaveChanges calling validateForSave\");\n        boolean saved = false;\n        try {\n            if (object()!=null && validateObject && shouldValidateBeforeSave()) {\n                if (_context.insertedObjects().containsObject(object()))\n                    object().validateForInsert();\n                else\n                    object().validateForUpdate();\n            }\n            if (object()!=null && shouldSaveChanges() && object().editingContext().hasChanges())\n                object().editingContext().saveChanges();\n            saved = true;\n        } catch (ERXValidationException ex) {\n            String propertyKey = ex.propertyKey();\n            ex.setContext(d2wContext());\n            ex.setTargetLanguage(ERXLocalizer.currentLocalizer().language());\n            Object o = ex.object();\n            if(o instanceof EOEnterpriseObject) {\n                EOEnterpriseObject eo = (EOEnterpriseObject)o;\n                d2wContext().takeValueForKey(eo.entityName(), \"entityName\");\n                d2wContext().takeValueForKey(propertyKey, \"propertyKey\");\n            }\n            if(propertyKey != null && propertyKey.indexOf(\",\") > 0) {\n                keyPathsWithValidationExceptions.addObjectsFromArray(NSArray.componentsSeparatedByString(propertyKey, \",\"));\n            }\n            errorMessage = \" Could not save your changes: \"+ex.getMessage()+\" \";\n        } catch (NSValidation.ValidationException e) {\n            log.info(e.getMessage(), e);\n            errorMessage = \" Could not save your changes: \"+e.getMessage()+\" \";\n        } catch(EOGeneralAdaptorException e) {\n            if(shouldRecoverFromOptimisticLockingFailure() && ERXEOAccessUtilities.recoverFromAdaptorException(object().editingContext(), e)) {\n                    errorMessage = \"Could not save your changes. The \"+d2wContext().valueForKey(\"displayNameForEntity\")+\n                    \" has changed in the database before you could save. Your changes have been lost. Please reapply them.\";\n            } else {\n                throw e;\n            }\n        }\n\n        return saved;\n    }","id":67482,"modified_method":"public boolean tryToSaveChanges(boolean validateObject) { // throws Throwable {\n        validationLog.debug(\"tryToSaveChanges calling validateForSave\");\n        boolean saved = false;\n        try {\n            if (object()!=null && validateObject && shouldValidateBeforeSave()) {\n                if (_context.insertedObjects().containsObject(object()))\n                    object().validateForInsert();\n                else\n                    object().validateForUpdate();\n            }\n            if (object()!=null && shouldSaveChanges() && object().editingContext().hasChanges())\n                object().editingContext().saveChanges();\n            saved = true;\n        } catch (NSValidation.ValidationException ex) {\n            errorMessage = ERXLocalizer.currentLocalizer().localizedTemplateStringForKeyWithObject(\"CouldNotSave\", ex);\n            validationFailedWithException(ex, ex.object(), \"saveChangesExceptionKey\");\n        } catch(EOGeneralAdaptorException ex) {\n            if(shouldRecoverFromOptimisticLockingFailure() && ERXEOAccessUtilities.recoverFromAdaptorException(object().editingContext(), ex)) {\n                errorMessage = ERXLocalizer.currentLocalizer().localizedTemplateStringForKeyWithObject(\"CouldNotSavePleaseReapply\", d2wContext());\n            } else {\n                throw ex;\n            }\n        }\n\n        return saved;\n    }","commit_id":"ecaede7e056f7611fe8aec3ed282a73cd0fd2c4f","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent submitAction() throws Throwable {\n        WOComponent returnComponent = null;\n        // catch the case where the user hits cancel and then the back button\n        if (object()!=null && object().editingContext()==null) {\n            errorMessage=\"<b>You already aborted this operation<\/b>. Please hit cancel and try again from the first step\";\n            clearValidationFailed();\n        } else {\n            if (errorMessages.count()==0) {\n                try {\n                    _objectWasSaved=true;\n                    returnComponent = tryToSaveChanges(true) ? nextPage() : null;\n                } catch (NSValidation.ValidationException e) {\n                    log.info(e.getMessage(), e);\n                    errorMessage = \" Could not save your changes: \"+e.getMessage()+\" \";\n                } finally {\n                    _objectWasSaved=false;\n                }\n            } else {\n                // if we don't do this, we end up with the error message in two places\n                // in errorMessages and errorMessage (super class)\n                errorMessage=null;\n            }\n        }\n        return returnComponent;\n    }","id":67483,"modified_method":"public WOComponent submitAction() throws Throwable {\n        WOComponent returnComponent = null;\n        // catch the case where the user hits cancel and then the back button\n        if (object()!=null && object().editingContext()==null) {\n            errorMessage = ERXLocalizer.currentLocalizer().localizedTemplateStringForKeyWithObject(\"ERD2WInspect.alreadyAborted\", d2wContext());\n            clearValidationFailed();\n        } else {\n            if (errorMessages.count()==0) {\n                try {\n                    _objectWasSaved=true;\n                    returnComponent = tryToSaveChanges(true) ? nextPage() : null;\n                } finally {\n                    _objectWasSaved=false;\n                }\n            } else {\n                // if we don't do this, we end up with the error message in two places\n                // in errorMessages and errorMessage (super class)\n                errorMessage=null;\n            }\n        }\n        return returnComponent;\n    }","commit_id":"ecaede7e056f7611fe8aec3ed282a73cd0fd2c4f","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent deleteObjectAction() {\n        String confirmDeleteConfigurationName=(String)d2wContext().valueForKey(\"confirmDeleteConfigurationName\");\n        ConfirmPageInterface nextPage;\n        if(confirmDeleteConfigurationName==null) {\n            log.warn(\"Using default delete template: ERD2WConfirmPageTemplate, set the 'confirmDeleteConfigurationName' key to something more sensible\");\n            nextPage = (ConfirmPageInterface)pageWithName(\"ERD2WConfirmPageTemplate\");\n        } else {\n            nextPage = (ConfirmPageInterface)D2W.factory().pageForConfigurationNamed(confirmDeleteConfigurationName,session());\n        }\n        nextPage.setConfirmDelegate(new ERDDeletionDelegate(object(),dataSource(),context().page()));\n        nextPage.setCancelDelegate(new ERDDeletionDelegate(null,null,context().page()));\n        if(nextPage instanceof InspectPageInterface) {\n            ((InspectPageInterface)nextPage).setObject(object());\n        } else {\n            nextPage.setMessage(\"Are you sure you want to delete the following \"+d2wContext().valueForKey(\"displayNameForEntity\")+\":<br> \"+object().userPresentableDescription()+ \" ?\");\n        }\n        return (WOComponent) nextPage;\n    }","id":67484,"modified_method":"public WOComponent deleteObjectAction() {\n        String confirmDeleteConfigurationName=(String)d2wContext().valueForKey(\"confirmDeleteConfigurationName\");\n        ConfirmPageInterface nextPage;\n        if(confirmDeleteConfigurationName==null) {\n            log.warn(\"Using default delete template: ERD2WConfirmPageTemplate, set the 'confirmDeleteConfigurationName' key to something more sensible\");\n            nextPage = (ConfirmPageInterface)pageWithName(\"ERD2WConfirmPageTemplate\");\n        } else {\n            nextPage = (ConfirmPageInterface)D2W.factory().pageForConfigurationNamed(confirmDeleteConfigurationName,session());\n        }\n        nextPage.setConfirmDelegate(new ERDDeletionDelegate(object(),dataSource(),context().page()));\n        nextPage.setCancelDelegate(new ERDDeletionDelegate(null,null,context().page()));\n        if(nextPage instanceof InspectPageInterface) {\n            ((InspectPageInterface)nextPage).setObject(object());\n        } else {\n            String message = ERXLocalizer.currentLocalizer().localizedTemplateStringForKeyWithObject(\"ERD2WList.confirmDeletionMessage\", d2wContext()); \n            nextPage.setMessage(message);\n        }\n        return (WOComponent) nextPage;\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Public constructor\n     * @param c current context\n     */\n    public ERD2WListPage(WOContext c) {\n        super(c);\n        NSNotificationCenter.defaultCenter().addObserver(this, new NSSelector(\"savedChanges\", ERXConstant.NotificationClassArray), EOEditingContext.EditingContextDidSaveChangesNotification, null);\n    }","id":67485,"modified_method":"/**\n     * Public constructor.\n     * Registers for {@link EOEditingContext.EditingContextDidSaveChangesNotification} so that\n     * component stays informed when objects are deleted and added.\n     * @param c current context\n     */\n    public ERD2WListPage(WOContext c) {\n        super(c);\n        NSNotificationCenter.defaultCenter().addObserver(this, new NSSelector(\"savedChanges\", ERXConstant.NotificationClassArray), EOEditingContext.EditingContextDidSaveChangesNotification, null);\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setSelectedObject(EOEnterpriseObject eo) {\n        if(eo != null)\n            displayGroup().selectObject(eo);\n        else\n            displayGroup().clearSelection();\n    }","id":67486,"modified_method":"/** Sets currently selected object. Pushes the value to the display group, clearing the selection if needed. */\n    public void setSelectedObject(EOEnterpriseObject eo) {\n        if(eo != null)\n            displayGroup().selectObject(eo);\n        else\n            displayGroup().clearSelection();\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WODisplayGroup displayGroup() {\n        if(_displayGroup == null) {\n            _displayGroup = new WODisplayGroup();\n            if (ERD2WFactory.erFactory().defaultListPageDisplayGroupDelegate() != null) {\n                _displayGroup.setDelegate(ERD2WFactory.erFactory().defaultListPageDisplayGroupDelegate());\n            }\n        }\n        return _displayGroup;\n    }","id":67487,"modified_method":"/** Returns the display group, creating one if there is none present. */\n    public WODisplayGroup displayGroup() {\n        if(_displayGroup == null) {\n            _displayGroup = new WODisplayGroup();\n            if (ERD2WFactory.erFactory().defaultListPageDisplayGroupDelegate() != null) {\n                _displayGroup.setDelegate(ERD2WFactory.erFactory().defaultListPageDisplayGroupDelegate());\n            }\n        }\n        return _displayGroup;\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String backgroundColorForRow() {\n       return !isSelecting() || object() != displayGroup().selectedObject() ? alternatingColorForRow() : \"#FFFF00\";\n    }","id":67488,"modified_method":"/** The background color for the current row. Override this to have more than one color. */\n    public String backgroundColorForRow() {\n       return !isSelecting() || object() != displayGroup().selectedObject() ? alternatingColorForRow() : \"#FFFF00\";\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public EOEnterpriseObject selectedObject() {\n        return (EOEnterpriseObject)displayGroup().selectedObject();\n    }","id":67489,"modified_method":"/** The currently selected object.*/\n    public EOEnterpriseObject selectedObject() {\n        return (EOEnterpriseObject)displayGroup().selectedObject();\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public int listSize() {\n        return displayGroup().allObjects().count();\n    }","id":67490,"modified_method":"/** The number of objects in the list. */\n    public int listSize() {\n        return displayGroup().allObjects().count();\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void setBackgroundColorForRow(String value) {\n        // just for KVC reasons\n    }","id":67491,"modified_method":"/** Does nothing and exists only for KeyValueCoding.*/\n    public void setBackgroundColorForRow(String value) {\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isListEmpty() {\n        return listSize() == 0;\n    }","id":67492,"modified_method":"/** Checks if the current list is empty. */\n    public boolean isListEmpty() {\n        return listSize() == 0;\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isSelecting() {\n        return task().equals(\"select\");\n    }","id":67493,"modified_method":"/** Checks if the current task is select. We need this because this page implements the {@link SelectPageInterface} so we can't do an instanceof test.  */\n    public boolean isSelecting() {\n        return task().equals(\"select\");\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public boolean isEntityReadOnly() {\n        boolean flag = super.isEntityReadOnly();\n        flag = !ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"isEntityEditable\"), !flag);\n        flag = ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"readOnly\"), flag);\n        return flag;\n    }","id":67494,"modified_method":"/** Checks if the entity is read only, meaning that you can't edit it's objects. */\n    public boolean isEntityReadOnly() {\n        boolean flag = super.isEntityReadOnly();\n        flag = !ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"isEntityEditable\"), !flag);\n        flag = ERXValueUtilities.booleanValueWithDefault(d2wContext().valueForKey(\"readOnly\"), flag);\n        return flag;\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public String alternatingColorForRow() {\n        _rowFlip = !_rowFlip;\n        if(_rowFlip || !alternateRowColor())\n           return backgroundColorForTable();\n        else\n           return backgroundColorForTableDark();\n    }","id":67495,"modified_method":"/** Utility to have alternating row colors. Override this to have more than one color. */\n    public String alternatingColorForRow() {\n        _rowFlip = !_rowFlip;\n        if(_rowFlip || !alternateRowColor())\n           return backgroundColorForTable();\n        else\n           return backgroundColorForTableDark();\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void savedChanges(NSNotification nsnotification) {\n        _hasToUpdate = true;\n    }","id":67496,"modified_method":"/** Called when an {@link EOditingContext} has changed. Sets {@link #_hasToUpdate} which in turn lets the group refetch on the next display. */\n    // CHECKME ak is this really needed? I'd think it's kindo of overkill.\n    public void savedChanges(NSNotification nsnotification) {\n        _hasToUpdate = true;\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public WOComponent selectObjectAction() {\n        setSelectedObject(object());\n        if(nextPageDelegate() != null)\n            return nextPageDelegate().nextPage(this);\n        else\n            return null;\n    }","id":67497,"modified_method":"/** Action method to select an object. */\n    public WOComponent selectObjectAction() {\n        setSelectedObject(object());\n        if(nextPageDelegate() != null)\n            return nextPageDelegate().nextPage(this);\n        else\n            return null;\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"public void finalize() throws Throwable {\n        NSNotificationCenter.defaultCenter().removeObserver(this);\n        super.finalize();\n    }","id":67498,"modified_method":"/** Override to un-register for stop obsevring notifcations. */\n    public void finalize() throws Throwable {\n        NSNotificationCenter.defaultCenter().removeObserver(this);\n        super.finalize();\n    }","commit_id":"b5f9fa842868c1d33a65fb5ade446bb3f26eaa59","url":"https://github.com/wocommunity/wonder"},{"original_method":"@Override\n  public ModuleWizardStep[] createWizardSteps(@NotNull WizardContext wizardContext, @NotNull ModulesProvider modulesProvider, boolean forNewWizard) {\n    if (forNewWizard) return ModuleWizardStep.EMPTY_ARRAY;\n    ModuleType moduleType = getModuleType();\n    return moduleType == null\n           ? ModuleWizardStep.EMPTY_ARRAY\n           : moduleType.createWizardSteps(wizardContext, this, modulesProvider, false);\n  }","id":67499,"modified_method":"@Override\n  public ModuleWizardStep[] createWizardSteps(@NotNull WizardContext wizardContext, @NotNull ModulesProvider modulesProvider, boolean forNewWizard) {\n    return getModuleType().createWizardSteps(wizardContext, this, modulesProvider, forNewWizard);\n  }","commit_id":"3ab2bad21d29a9849385d49b6e1174f1fc36c749","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public ModuleWizardStep[] createWizardSteps(@NotNull final WizardContext wizardContext,\n                                              @NotNull final PythonModuleBuilderBase moduleBuilder,\n                                              @NotNull final ModulesProvider modulesProvider) {\n    ArrayList<ModuleWizardStep> steps = new ArrayList<ModuleWizardStep>();\n    final Project project = getProject(wizardContext);\n    steps.add(new PythonSdkSelectStep(moduleBuilder, \"reference.project.structure.sdk.python\", project));\n    final List<FrameworkSupportInModuleProvider> providers = FrameworkSupportUtil.getProviders(getInstance(), DefaultFacetsProvider.INSTANCE);\n    if (!providers.isEmpty()) {\n      steps.add(new SupportForFrameworksStep(wizardContext, moduleBuilder, LibrariesContainerFactory.createContainer(project)));\n    }\n    return steps.toArray(new ModuleWizardStep[steps.size()]);\n  }","id":67500,"modified_method":"@NotNull\n  @Override\n  public ModuleWizardStep[] createWizardSteps(@NotNull final WizardContext wizardContext,\n                                              @NotNull final PythonModuleBuilderBase moduleBuilder,\n                                              @NotNull final ModulesProvider modulesProvider,\n                                              boolean forNewWizard) {\n    ArrayList<ModuleWizardStep> steps = new ArrayList<ModuleWizardStep>();\n    final Project project = getProject(wizardContext);\n    steps.add(new PythonSdkSelectStep(moduleBuilder, \"reference.project.structure.sdk.python\", project));\n    if (!forNewWizard) {\n      final List<FrameworkSupportInModuleProvider> providers = FrameworkSupportUtil.getProviders(getInstance(), DefaultFacetsProvider.INSTANCE);\n      if (!providers.isEmpty()) {\n        steps.add(new SupportForFrameworksStep(wizardContext, moduleBuilder, LibrariesContainerFactory.createContainer(project)));\n      }\n    }\n    return steps.toArray(new ModuleWizardStep[steps.size()]);\n  }","commit_id":"3ab2bad21d29a9849385d49b6e1174f1fc36c749","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public String getBuilderId() {\n    return getModuleType().getId();\n  }","id":67501,"modified_method":"@Nullable\n  public String getBuilderId() {\n    ModuleType moduleType = getModuleType();\n    return moduleType == null ? null : moduleType.getId();\n  }","commit_id":"5e3692454dabc355af656baf455d43cb7f93956d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ModuleWizardStep[] createWizardSteps(WizardContext wizardContext, ModulesProvider modulesProvider) {\n    return getModuleType().createWizardSteps(wizardContext, this, modulesProvider);\n  }","id":67502,"modified_method":"public ModuleWizardStep[] createWizardSteps(WizardContext wizardContext, ModulesProvider modulesProvider) {\n    ModuleType moduleType = getModuleType();\n    return moduleType == null ? ModuleWizardStep.EMPTY_ARRAY : moduleType.createWizardSteps(wizardContext, this, modulesProvider);\n  }","commit_id":"5e3692454dabc355af656baf455d43cb7f93956d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isModuleAccepted(final Module module) {\n    return ArrayUtil.find(new ModuleType[]{ModuleType.JAVA, ModuleType.WEB, ModuleType.EJB}, module.getModuleType()) != -1;\n  }","id":67503,"modified_method":"public static boolean isModuleAccepted(final Module module) {\n    return ModuleTypeManager.getInstance().isClasspathProvider(module.getModuleType());    \n  }","commit_id":"362c67c323674db97ec3e77a425404acb7d85c6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void registerModuleType(ModuleType type) {\n    for (ModuleType oldType : myModuleTypes) {\n      if (oldType.getId().equals(type.getId())) {\n        LOG.error(\"Trying to register a module type that claunches with existing one. Old=\" + oldType + \", new = \" + type);\n        return;\n      }\n    }\n    myModuleTypes.add(type);\n  }","id":67504,"modified_method":"public void registerModuleType(ModuleType type) {\n    registerModuleType(type, false);\n  }","commit_id":"362c67c323674db97ec3e77a425404acb7d85c6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ModuleType[] getRegisteredTypes() {\n    return myModuleTypes.toArray(new ModuleType[myModuleTypes.size()]);\n  }","id":67505,"modified_method":"public ModuleType[] getRegisteredTypes() {\n    return myModuleTypes.keySet().toArray(new ModuleType[myModuleTypes.size()]);\n  }","commit_id":"362c67c323674db97ec3e77a425404acb7d85c6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ModuleType findByID(String moduleTypeID) {\n    if (JAVA_MODULE_ID_OLD.equals(moduleTypeID)) {\n      return ModuleType.JAVA; // for compatibility with the previous ID that Java modules had\n    }\n    for (ModuleType type : myModuleTypes) {\n      if (type.getId().equals(moduleTypeID)) {\n        return type;\n      }\n    }\n\n    return new UnknownModuleType(moduleTypeID);\n  }","id":67506,"modified_method":"public ModuleType findByID(String moduleTypeID) {\n    if (JAVA_MODULE_ID_OLD.equals(moduleTypeID)) {\n      return ModuleType.JAVA; // for compatibility with the previous ID that Java modules had\n    }\n    for (ModuleType type : myModuleTypes.keySet()) {\n      if (type.getId().equals(moduleTypeID)) {\n        return type;\n      }\n    }\n\n    return new UnknownModuleType(moduleTypeID);\n  }","commit_id":"362c67c323674db97ec3e77a425404acb7d85c6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void registerDefaultTypes() {\n    registerModuleType(ModuleType.JAVA);\n  }","id":67507,"modified_method":"private void registerDefaultTypes() {\n    registerModuleType(ModuleType.JAVA, true);\n  }","commit_id":"362c67c323674db97ec3e77a425404acb7d85c6e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean validateConfiguration(CompileScope compileScope) {\n    VirtualFile[] files = compileScope.getFiles(GroovyFileType.GROOVY_FILE_TYPE, true);\n    if (files.length == 0) return true;\n\n    final Set<String> scriptExtensions = GroovyFileTypeLoader.getCustomGroovyScriptExtensions();\n\n    Set<Module> modules = new HashSet<Module>();\n    for (VirtualFile file : files) {\n      if (scriptExtensions.contains(file.getExtension())) {\n        continue;\n      }\n\n      ProjectRootManager rootManager = ProjectRootManager.getInstance(myProject);\n      Module module = rootManager.getFileIndex().getModuleForFile(file);\n      if (module != null) {\n        modules.add(module);\n      }\n    }\n\n    Set<Module> nojdkModules = new HashSet<Module>();\n    for (Module module : modules) {\n      if(!(module.getModuleType() instanceof JavaModuleType)) return true;\n      final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n      if (sdk == null || !(sdk.getSdkType() instanceof JavaSdkType)) {\n        nojdkModules.add(module);\n        continue;\n      }\n\n      if (!LibrariesUtil.hasGroovySdk(module)) {\n        if (!GroovyConfigUtils.getInstance().tryToSetUpGroovyFacetOntheFly(module)) {\n          Messages.showErrorDialog(myProject, GroovyBundle.message(\"cannot.compile.groovy.files.no.facet\", module.getName()),\n                                   GroovyBundle.message(\"cannot.compile\"));\n          ModulesConfigurator.showDialog(module.getProject(), module.getName(), ClasspathEditor.NAME, false);\n          return false;\n        }\n      }\n    }\n\n    if (!nojdkModules.isEmpty()) {\n      final Module[] noJdkArray = nojdkModules.toArray(new Module[nojdkModules.size()]);\n      if (noJdkArray.length == 1) {\n        Messages.showErrorDialog(myProject, GroovyBundle.message(\"cannot.compile.groovy.files.no.sdk\", noJdkArray[0].getName()),\n                                 GroovyBundle.message(\"cannot.compile\"));\n      }\n      else {\n        StringBuffer modulesList = new StringBuffer();\n        for (int i = 0; i < noJdkArray.length; i++) {\n          if (i > 0) modulesList.append(\", \");\n          modulesList.append(noJdkArray[i].getName());\n        }\n        Messages.showErrorDialog(myProject, GroovyBundle.message(\"cannot.compile.groovy.files.no.sdk.mult\", modulesList.toString()),\n                                 GroovyBundle.message(\"cannot.compile\"));\n      }\n      return false;\n    }\n\n    final GroovyCompilerConfiguration configuration = GroovyCompilerConfiguration.getInstance(myProject);\n    if (!configuration.transformsOk && needTransformCopying(compileScope)) {\n      final int result = Messages.showYesNoDialog(myProject,\n                                                  \"You seem to have global Groovy AST transformations defined in your project,\\n\" +\n                                                  \"but they won't be applied to your code because they are not marked as compiler resources.\\n\" +\n                                                  \"Do you want to add them to compiler resource list?\\n\" +\n                                                  \"(you can do it yourself later in Settings | Compiler | Resource patterns)\", \"AST Transformations found\",\n                                                  GroovyIcons.GROOVY_ICON_32x32);\n      if (result == 0) {\n        CompilerConfiguration.getInstance(myProject).addResourceFilePattern(AST_TRANSFORM_FILE_NAME);\n      } else {\n        configuration.transformsOk = true;\n      }\n    }\n\n    return true;\n  }","id":67508,"modified_method":"public boolean validateConfiguration(CompileScope compileScope) {\n    VirtualFile[] files = compileScope.getFiles(GroovyFileType.GROOVY_FILE_TYPE, true);\n    if (files.length == 0) return true;\n\n    final Set<String> scriptExtensions = GroovyFileTypeLoader.getCustomGroovyScriptExtensions();\n\n    Set<Module> modules = new HashSet<Module>();\n    for (VirtualFile file : files) {\n      if (scriptExtensions.contains(file.getExtension())) {\n        continue;\n      }\n\n      ProjectRootManager rootManager = ProjectRootManager.getInstance(myProject);\n      Module module = rootManager.getFileIndex().getModuleForFile(file);\n      if (module != null) {\n        modules.add(module);\n      }\n    }\n\n    Set<Module> nojdkModules = new HashSet<Module>();\n    for (Module module : modules) {\n      if(!GroovyUtils.isAcceptableModuleType(module.getModuleType())) continue;\n      final Sdk sdk = ModuleRootManager.getInstance(module).getSdk();\n      if (sdk == null || !(sdk.getSdkType() instanceof JavaSdkType)) {\n        nojdkModules.add(module);\n        continue;\n      }\n\n      if (!LibrariesUtil.hasGroovySdk(module)) {\n        if (!GroovyConfigUtils.getInstance().tryToSetUpGroovyFacetOntheFly(module)) {\n          Messages.showErrorDialog(myProject, GroovyBundle.message(\"cannot.compile.groovy.files.no.facet\", module.getName()),\n                                   GroovyBundle.message(\"cannot.compile\"));\n          ModulesConfigurator.showDialog(module.getProject(), module.getName(), ClasspathEditor.NAME, false);\n          return false;\n        }\n      }\n    }\n\n    if (!nojdkModules.isEmpty()) {\n      final Module[] noJdkArray = nojdkModules.toArray(new Module[nojdkModules.size()]);\n      if (noJdkArray.length == 1) {\n        Messages.showErrorDialog(myProject, GroovyBundle.message(\"cannot.compile.groovy.files.no.sdk\", noJdkArray[0].getName()),\n                                 GroovyBundle.message(\"cannot.compile\"));\n      }\n      else {\n        StringBuffer modulesList = new StringBuffer();\n        for (int i = 0; i < noJdkArray.length; i++) {\n          if (i > 0) modulesList.append(\", \");\n          modulesList.append(noJdkArray[i].getName());\n        }\n        Messages.showErrorDialog(myProject, GroovyBundle.message(\"cannot.compile.groovy.files.no.sdk.mult\", modulesList.toString()),\n                                 GroovyBundle.message(\"cannot.compile\"));\n      }\n      return false;\n    }\n\n    final GroovyCompilerConfiguration configuration = GroovyCompilerConfiguration.getInstance(myProject);\n    if (!configuration.transformsOk && needTransformCopying(compileScope)) {\n      final int result = Messages.showYesNoDialog(myProject,\n                                                  \"You seem to have global Groovy AST transformations defined in your project,\\n\" +\n                                                  \"but they won't be applied to your code because they are not marked as compiler resources.\\n\" +\n                                                  \"Do you want to add them to compiler resource list?\\n\" +\n                                                  \"(you can do it yourself later in Settings | Compiler | Resource patterns)\", \"AST Transformations found\",\n                                                  GroovyIcons.GROOVY_ICON_32x32);\n      if (result == 0) {\n        CompilerConfiguration.getInstance(myProject).addResourceFilePattern(AST_TRANSFORM_FILE_NAME);\n      } else {\n        configuration.transformsOk = true;\n      }\n    }\n\n    return true;\n  }","commit_id":"0b9afcd5afbefcf5fa5c36cd35b6c61aa912a307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void compile(final CompileContext compileContext, Chunk<Module> moduleChunk, final VirtualFile[] virtualFiles, OutputSink sink) {\n    Map<Module, List<VirtualFile>> mapModulesToVirtualFiles;\n    if (moduleChunk.getNodes().size() == 1) {\n      mapModulesToVirtualFiles = Collections.singletonMap(moduleChunk.getNodes().iterator().next(), Arrays.asList(virtualFiles));\n    }\n    else {\n      mapModulesToVirtualFiles = CompilerUtil.buildModuleToFilesMap(compileContext, virtualFiles);\n    }\n    for (final Module module : moduleChunk.getNodes()) {\n      final List<VirtualFile> moduleFiles = mapModulesToVirtualFiles.get(module);\n      if (moduleFiles == null) {\n        continue;\n      }\n\n      final ModuleFileIndex index = ModuleRootManager.getInstance(module).getFileIndex();\n      final List<VirtualFile> toCompile = new ArrayList<VirtualFile>();\n      final List<VirtualFile> toCompileTests = new ArrayList<VirtualFile>();\n      final CompilerConfiguration configuration = CompilerConfiguration.getInstance(myProject);\n\n      if (module.getModuleType() instanceof JavaModuleType) {\n        for (final VirtualFile file : moduleFiles) {\n          final boolean shouldCompile = !configuration.isResourceFile(file) &&\n                                        (file.getFileType() == GroovyFileType.GROOVY_FILE_TYPE ||\n                                         file.getFileType() == StdFileTypes.JAVA);\n          if (shouldCompile) {\n            (index.isInTestSourceContent(file) ? toCompileTests : toCompile).add(file);\n          }\n        }\n      }\n\n      if (!toCompile.isEmpty()) {\n        compileFiles(compileContext, module, toCompile, sink, false);\n      }\n      if (!toCompileTests.isEmpty()) {\n        compileFiles(compileContext, module, toCompileTests, sink, true);\n      }\n\n    }\n\n  }","id":67509,"modified_method":"public void compile(final CompileContext compileContext, Chunk<Module> moduleChunk, final VirtualFile[] virtualFiles, OutputSink sink) {\n    Map<Module, List<VirtualFile>> mapModulesToVirtualFiles;\n    if (moduleChunk.getNodes().size() == 1) {\n      mapModulesToVirtualFiles = Collections.singletonMap(moduleChunk.getNodes().iterator().next(), Arrays.asList(virtualFiles));\n    }\n    else {\n      mapModulesToVirtualFiles = CompilerUtil.buildModuleToFilesMap(compileContext, virtualFiles);\n    }\n    for (final Module module : moduleChunk.getNodes()) {\n      final List<VirtualFile> moduleFiles = mapModulesToVirtualFiles.get(module);\n      if (moduleFiles == null) {\n        continue;\n      }\n\n      final ModuleFileIndex index = ModuleRootManager.getInstance(module).getFileIndex();\n      final List<VirtualFile> toCompile = new ArrayList<VirtualFile>();\n      final List<VirtualFile> toCompileTests = new ArrayList<VirtualFile>();\n      final CompilerConfiguration configuration = CompilerConfiguration.getInstance(myProject);\n\n      if (GroovyUtils.isAcceptableModuleType(module.getModuleType())) {\n        for (final VirtualFile file : moduleFiles) {\n          final boolean shouldCompile = !configuration.isResourceFile(file) &&\n                                        (file.getFileType() == GroovyFileType.GROOVY_FILE_TYPE ||\n                                         file.getFileType() == StdFileTypes.JAVA);\n          if (shouldCompile) {\n            (index.isInTestSourceContent(file) ? toCompileTests : toCompile).add(file);\n          }\n        }\n      }\n\n      if (!toCompile.isEmpty()) {\n        compileFiles(compileContext, module, toCompile, sink, false);\n      }\n      if (!toCompileTests.isEmpty()) {\n        compileFiles(compileContext, module, toCompileTests, sink, true);\n      }\n\n    }\n\n  }","commit_id":"0b9afcd5afbefcf5fa5c36cd35b6c61aa912a307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isEnabledForModuleType(@NotNull ModuleType moduleType) {\n    return moduleType instanceof JavaModuleType;\n  }","id":67510,"modified_method":"public boolean isEnabledForModuleType(@NotNull ModuleType moduleType) {\n    return GroovyUtils.isAcceptableModuleType(moduleType);\n  }","commit_id":"0b9afcd5afbefcf5fa5c36cd35b6c61aa912a307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public GenerationItem[] getGenerationItems(CompileContext context) {\n    if (GroovyCompilerConfiguration.getInstance(myProject).isUseGroovycStubs()) {\n      return new GenerationItem[0];\n    }\n\n    List<GenerationItem> generationItems = new ArrayList<GenerationItem>();\n    GenerationItem item;\n    final CompilerManager compilerManager = CompilerManager.getInstance(myProject);\n    final CompilerConfiguration compilerConfiguration = CompilerConfiguration.getInstance(myProject);\n    final ExcludedEntriesConfiguration excluded = GroovyCompilerConfiguration.getExcludeConfiguration(myProject);\n    for (VirtualFile file : getGroovyFilesToGenerate(context)) {\n      if (compilerManager.isExcludedFromCompilation(file)) continue;\n      if (excluded.isExcluded(file)) continue;\n      if (compilerConfiguration.isResourceFile(file)) continue;\n\n      final Module module = getModuleByFile(context, file);\n      if (module == null || !(module.getModuleType() instanceof JavaModuleType)) {\n        continue;\n      }\n\n      boolean isInTestSources = ModuleRootManager.getInstance(module).getFileIndex().isInTestSourceContent(file);\n\n      final GroovyFileBase psiFile = findPsiFile(file);\n      GrTopStatement[] statements = getTopStatementsInReadAction(psiFile);\n\n      boolean needCreateTopLevelClass = !needsCreateClassFromFileName(statements);\n\n      String prefix = \"\";\n      if (statements.length > 0 && statements[0] instanceof GrPackageDefinition) {\n        prefix = getJavaClassPackage((GrPackageDefinition) statements[0]);\n      }\n\n      //top level class\n      if (needCreateTopLevelClass) {\n        generationItems.add(new GenerationItem(prefix + file.getNameWithoutExtension() + \".\" + \"java\", module, new TimestampValidityState(file.getTimeStamp()), isInTestSources, file));\n      }\n\n      GrTypeDefinition[] typeDefinitions = ApplicationManager.getApplication().runReadAction(new Computable<GrTypeDefinition[]>() {\n        public GrTypeDefinition[] compute() {\n          return psiFile.getTypeDefinitions();\n        }\n      });\n\n      for (GrTypeDefinition typeDefinition : typeDefinitions) {\n        item = new GenerationItem(prefix + typeDefinition.getName() + \".\" + \"java\", module, new TimestampValidityState(file.getTimeStamp()), isInTestSources, file);\n        generationItems.add(item);\n      }\n    }\n    return generationItems.toArray(new GenerationItem[generationItems.size()]);\n  }","id":67511,"modified_method":"public GenerationItem[] getGenerationItems(CompileContext context) {\n    if (GroovyCompilerConfiguration.getInstance(myProject).isUseGroovycStubs()) {\n      return new GenerationItem[0];\n    }\n\n    List<GenerationItem> generationItems = new ArrayList<GenerationItem>();\n    GenerationItem item;\n    final CompilerManager compilerManager = CompilerManager.getInstance(myProject);\n    final CompilerConfiguration compilerConfiguration = CompilerConfiguration.getInstance(myProject);\n    final ExcludedEntriesConfiguration excluded = GroovyCompilerConfiguration.getExcludeConfiguration(myProject);\n    for (VirtualFile file : getGroovyFilesToGenerate(context)) {\n      if (compilerManager.isExcludedFromCompilation(file)) continue;\n      if (excluded.isExcluded(file)) continue;\n      if (compilerConfiguration.isResourceFile(file)) continue;\n\n      final Module module = getModuleByFile(context, file);\n      if (!GroovyUtils.isSuitableModule(module)) {\n        continue;\n      }\n\n      boolean isInTestSources = ModuleRootManager.getInstance(module).getFileIndex().isInTestSourceContent(file);\n\n      final GroovyFileBase psiFile = findPsiFile(file);\n      GrTopStatement[] statements = getTopStatementsInReadAction(psiFile);\n\n      boolean needCreateTopLevelClass = !needsCreateClassFromFileName(statements);\n\n      String prefix = \"\";\n      if (statements.length > 0 && statements[0] instanceof GrPackageDefinition) {\n        prefix = getJavaClassPackage((GrPackageDefinition) statements[0]);\n      }\n\n      //top level class\n      if (needCreateTopLevelClass) {\n        generationItems.add(new GenerationItem(prefix + file.getNameWithoutExtension() + \".\" + \"java\", module, new TimestampValidityState(file.getTimeStamp()), isInTestSources, file));\n      }\n\n      GrTypeDefinition[] typeDefinitions = ApplicationManager.getApplication().runReadAction(new Computable<GrTypeDefinition[]>() {\n        public GrTypeDefinition[] compute() {\n          return psiFile.getTypeDefinitions();\n        }\n      });\n\n      for (GrTypeDefinition typeDefinition : typeDefinitions) {\n        item = new GenerationItem(prefix + typeDefinition.getName() + \".\" + \"java\", module, new TimestampValidityState(file.getTimeStamp()), isInTestSources, file);\n        generationItems.add(item);\n      }\n    }\n    return generationItems.toArray(new GenerationItem[generationItems.size()]);\n  }","commit_id":"0b9afcd5afbefcf5fa5c36cd35b6c61aa912a307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isSuitableModule(Module module) {\n    if (module == null) return false;\n    ModuleType moduleType = module.getModuleType();\n    return moduleType instanceof JavaModuleType || moduleType.getId().equals(PLUGIN_MODULE_ID);\n  }","id":67512,"modified_method":"public static boolean isSuitableModule(Module module) {\n    if (module == null) return false;\n    return isAcceptableModuleType(module.getModuleType());\n  }","commit_id":"0b9afcd5afbefcf5fa5c36cd35b6c61aa912a307","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void parseParameterListContents(IElementType endToken, boolean advanceLexer, boolean isLambda) {\n    PsiBuilder.Marker parameterList;\n    parameterList = myBuilder.mark();\n    if (advanceLexer) {\n      myBuilder.advanceLexer();\n    }\n\n    boolean first = true;\n    while (myBuilder.getTokenType() != endToken) {\n      if (first) {\n        first = false;\n      }\n      else {\n        if (myBuilder.getTokenType() == PyTokenTypes.COMMA) {\n          myBuilder.advanceLexer();\n        }\n        else if (myBuilder.getTokenType() == PyTokenTypes.LPAR) {\n          parseParameterSubList();\n          continue;\n        }\n        else {\n          myBuilder.error(message(\"PARSE.expected.comma.lpar.rpar\"));\n          break;\n        }\n      }\n\n      final PsiBuilder.Marker parameter = myBuilder.mark();\n      boolean isStarParameter = false;\n      if (myBuilder.getTokenType() == PyTokenTypes.MULT) {\n        myBuilder.advanceLexer();\n        if (myContext.getLanguageLevel().isPy3K() &&\n            (myBuilder.getTokenType() == PyTokenTypes.COMMA) || myBuilder.getTokenType() == endToken) {\n          parameter.done(PyElementTypes.SINGLE_STAR_PARAMETER);\n          continue;\n        }\n        isStarParameter = true;\n      }\n      else if (myBuilder.getTokenType() == PyTokenTypes.EXP) {\n        myBuilder.advanceLexer();\n        isStarParameter = true;\n      }\n      if (matchToken(PyTokenTypes.IDENTIFIER)) {\n        if (!isLambda && myContext.getLanguageLevel().isPy3K() && atToken(PyTokenTypes.COLON)) {\n          PsiBuilder.Marker annotationMarker = myBuilder.mark();\n          nextToken();\n          if (!getExpressionParser().parseSingleExpression(false)) {\n            myBuilder.error(message(\"PARSE.expected.expression\"));\n          }\n          annotationMarker.done(PyElementTypes.ANNOTATION);\n        }\n        if (!isStarParameter && matchToken(PyTokenTypes.EQ)) {\n          getExpressionParser().parseSingleExpression(false);\n        }\n        parameter.done(PyElementTypes.NAMED_PARAMETER);\n      }\n      else {\n        myBuilder.error(message(\"PARSE.expected.formal.param.name\"));\n        parameter.rollbackTo();\n      }\n    }\n\n    if (myBuilder.getTokenType() == endToken) {\n      myBuilder.advanceLexer();\n    }\n\n    parameterList.done(PyElementTypes.PARAMETER_LIST);\n  }","id":67513,"modified_method":"public void parseParameterListContents(IElementType endToken, boolean advanceLexer, boolean isLambda) {\n    PsiBuilder.Marker parameterList;\n    parameterList = myBuilder.mark();\n    if (advanceLexer) {\n      myBuilder.advanceLexer();\n    }\n\n    boolean first = true;\n    while (myBuilder.getTokenType() != endToken) {\n      if (first) {\n        first = false;\n      }\n      else {\n        if (myBuilder.getTokenType() == PyTokenTypes.COMMA) {\n          myBuilder.advanceLexer();\n        }\n        else if (myBuilder.getTokenType() == PyTokenTypes.LPAR) {\n          parseParameterSubList();\n          continue;\n        }\n        else {\n          myBuilder.error(message(\"PARSE.expected.comma.lpar.rpar\"));\n          break;\n        }\n      }\n\n      final PsiBuilder.Marker parameter = myBuilder.mark();\n      boolean isStarParameter = false;\n      if (myBuilder.getTokenType() == PyTokenTypes.MULT) {\n        myBuilder.advanceLexer();\n        if (myContext.getLanguageLevel().isPy3K() &&\n            (myBuilder.getTokenType() == PyTokenTypes.COMMA) || myBuilder.getTokenType() == endToken) {\n          parameter.done(PyElementTypes.SINGLE_STAR_PARAMETER);\n          continue;\n        }\n        isStarParameter = true;\n      }\n      else if (myBuilder.getTokenType() == PyTokenTypes.EXP) {\n        myBuilder.advanceLexer();\n        isStarParameter = true;\n      }\n      if (matchToken(PyTokenTypes.IDENTIFIER)) {\n        if (!isLambda && myContext.getLanguageLevel().isPy3K() && atToken(PyTokenTypes.COLON)) {\n          PsiBuilder.Marker annotationMarker = myBuilder.mark();\n          nextToken();\n          if (!getExpressionParser().parseSingleExpression(false)) {\n            myBuilder.error(message(\"PARSE.expected.expression\"));\n          }\n          annotationMarker.done(PyElementTypes.ANNOTATION);\n        }\n        if (!isStarParameter && matchToken(PyTokenTypes.EQ)) {\n          if (!getExpressionParser().parseSingleExpression(false)) {\n            myBuilder.error(message(\"PARSE.expected.expression\"));\n          }\n        }\n        parameter.done(PyElementTypes.NAMED_PARAMETER);\n      }\n      else {\n        myBuilder.error(message(\"PARSE.expected.formal.param.name\"));\n        parameter.rollbackTo();\n      }\n    }\n\n    if (myBuilder.getTokenType() == endToken) {\n      myBuilder.advanceLexer();\n    }\n\n    parameterList.done(PyElementTypes.PARAMETER_LIST);\n  }","commit_id":"c2fdba40216db9dbd6b4064ed70d8ffee7d66b1d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void parseAssertStatement(boolean inSuite) {\n    assertCurrentToken(PyTokenTypes.ASSERT_KEYWORD);\n    final PsiBuilder.Marker assertStatement = myBuilder.mark();\n    myBuilder.advanceLexer();\n    getExpressionParser().parseSingleExpression(false);\n    if (myBuilder.getTokenType() == PyTokenTypes.COMMA) {\n      myBuilder.advanceLexer();\n      getExpressionParser().parseSingleExpression(false);\n    }\n    checkEndOfStatement(inSuite);\n    assertStatement.done(PyElementTypes.ASSERT_STATEMENT);\n  }","id":67514,"modified_method":"private void parseAssertStatement(boolean inSuite) {\n    assertCurrentToken(PyTokenTypes.ASSERT_KEYWORD);\n    final PsiBuilder.Marker assertStatement = myBuilder.mark();\n    myBuilder.advanceLexer();\n    if (getExpressionParser().parseSingleExpression(false)) {\n      if (myBuilder.getTokenType() == PyTokenTypes.COMMA) {\n        myBuilder.advanceLexer();\n        if (!getExpressionParser().parseSingleExpression(false)) {\n          myContext.getBuilder().error(\"Expression expected\");\n        }\n      }\n      checkEndOfStatement(inSuite);\n    }\n    else myContext.getBuilder().error(\"Expression expected\");\n    assertStatement.done(PyElementTypes.ASSERT_STATEMENT);\n  }","commit_id":"77cb93c189809cf7e361864a64f30aea685ff4ad","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JetNodeType parseTypeDef() {\n        assert _at(TYPE_KEYWORD);\n\n        advance(); // TYPE_KEYWORD\n\n        expect(IDENTIFIER, \"Type name expected\", TokenSet.orSet(TokenSet.create(LT, EQ, SEMICOLON), TOPLEVEL_OBJECT_FIRST));\n\n        parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET);\n\n        expect(EQ, \"Expecting '='\", TokenSet.orSet(TOPLEVEL_OBJECT_FIRST, TokenSet.create(SEMICOLON)));\n\n        parseTypeRef();\n\n        consumeIf(SEMICOLON);\n\n        return TYPEDEF;\n    }","id":67515,"modified_method":"public JetNodeType parseTypeDef() {\n        assert _at(TYPE_KEYWORD);\n\n        advance(); // TYPE_KEYWORD\n\n        expect(IDENTIFIER, \"Type name expected\", TokenSet.orSet(TokenSet.create(LT, EQ, SEMICOLON), TOPLEVEL_OBJECT_FIRST));\n\n        if (parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET)) {\n            parseTypeConstraints();\n        }\n\n        expect(EQ, \"Expecting '='\", TokenSet.orSet(TOPLEVEL_OBJECT_FIRST, TokenSet.create(SEMICOLON)));\n\n        parseTypeRef();\n\n        consumeIf(SEMICOLON);\n\n        return TYPEDEF;\n    }","commit_id":"c2435f0f24b877f5041a532171dabcc1692ff79b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetNodeType parseClass(boolean enumClass) {\n        assert _at(CLASS_KEYWORD);\n        advance(); // CLASS_KEYWORD\n\n        expect(IDENTIFIER, \"Class name expected\", CLASS_NAME_RECOVERY_SET);\n        parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET);\n\n        if (at(WRAPS_KEYWORD)) {\n            advance(); // WRAPS_KEYWORD\n            parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n        }\n        else {\n            if (parseModifierList(PRIMARY_CONSTRUCTOR_MODIFIER_LIST)) {\n                parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n            }\n            else {\n                if (at(LPAR)) {\n                    parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n                }\n            }\n        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseDelegationSpecifierList();\n        }\n\n        if (at(LBRACE)) {\n            if (enumClass) {\n                parseEnumClassBody();\n            }\n            else {\n                parseClassBody();\n            }\n        }\n\n        return CLASS;\n    }","id":67516,"modified_method":"public JetNodeType parseClass(boolean enumClass) {\n        assert _at(CLASS_KEYWORD);\n        advance(); // CLASS_KEYWORD\n\n        expect(IDENTIFIER, \"Class name expected\", CLASS_NAME_RECOVERY_SET);\n        boolean typeParametersDeclared = parseTypeParameterList(TYPE_PARAMETER_GT_RECOVERY_SET);\n\n        if (at(WRAPS_KEYWORD)) {\n            advance(); // WRAPS_KEYWORD\n            parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n        }\n        else {\n            if (parseModifierList(PRIMARY_CONSTRUCTOR_MODIFIER_LIST)) {\n                parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n            }\n            else {\n                if (at(LPAR)) {\n                    parseValueParameterList(false, TokenSet.create(COLON, LBRACE));\n                }\n            }\n        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseDelegationSpecifierList();\n        }\n\n        parseTypeConstraintsGuarded(typeParametersDeclared);\n\n        if (at(LBRACE)) {\n            if (enumClass) {\n                parseEnumClassBody();\n            }\n            else {\n                parseClassBody();\n            }\n        }\n\n        return CLASS;\n    }","commit_id":"c2435f0f24b877f5041a532171dabcc1692ff79b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetNodeType parseFunction() {\n        assert _at(FUN_KEYWORD);\n\n        advance(); // FUN_KEYWORD\n\n        // Recovery for the case of class A { fun| }\n        if (at(RBRACE)) {\n            error(\"Function body expected\");\n            return FUN;\n        }\n\n        boolean typeParameterListOccurred = false;\n        if (at(LT)) {\n            parseTypeParameterList(TokenSet.create(LBRACKET, LBRACE, LPAR));\n            typeParameterListOccurred = true;\n        }\n\n        int lastDot = findLastBefore(RECEIVER_TYPE_TERMINATORS, TokenSet.create(LPAR), true);\n        parseReceiverType(\"function\", TokenSet.create(LT, LPAR, COLON, EQ), lastDot);\n\n        TokenSet valueParametersFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON, RPAR);\n\n        if (at(LT)) {\n            PsiBuilder.Marker error = mark();\n            parseTypeParameterList(TokenSet.orSet(TokenSet.create(LPAR), valueParametersFollow));\n            if (typeParameterListOccurred) {\n                error.error(\"Only one type parameter list is allowed for a function\"); // TODO : discuss\n            }\n            else {\n                error.drop();\n            }\n        }\n\n        parseValueParameterList(false, valueParametersFollow);\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            parseTypeRef();\n        }\n\n        if (at(SEMICOLON)) {\n            advance(); // SEMICOLON\n        }\n        else if (at(EQ) || at(LBRACE)) {\n            parseFunctionBody();\n        }\n\n        return FUN;\n    }","id":67517,"modified_method":"public JetNodeType parseFunction() {\n        assert _at(FUN_KEYWORD);\n\n        advance(); // FUN_KEYWORD\n\n        // Recovery for the case of class A { fun| }\n        if (at(RBRACE)) {\n            error(\"Function body expected\");\n            return FUN;\n        }\n\n        boolean typeParameterListOccurred = false;\n        if (at(LT)) {\n            parseTypeParameterList(TokenSet.create(LBRACKET, LBRACE, LPAR));\n            typeParameterListOccurred = true;\n        }\n\n        int lastDot = findLastBefore(RECEIVER_TYPE_TERMINATORS, TokenSet.create(LPAR), true);\n        parseReceiverType(\"function\", TokenSet.create(LT, LPAR, COLON, EQ), lastDot);\n\n        TokenSet valueParametersFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON, RPAR);\n\n        if (at(LT)) {\n            PsiBuilder.Marker error = mark();\n            parseTypeParameterList(TokenSet.orSet(TokenSet.create(LPAR), valueParametersFollow));\n            if (typeParameterListOccurred) {\n                error.error(\"Only one type parameter list is allowed for a function\"); // TODO : discuss\n            }\n            else {\n                error.drop();\n            }\n            typeParameterListOccurred = true;\n        }\n\n        parseValueParameterList(false, valueParametersFollow);\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            parseTypeRef();\n        }\n\n        parseTypeConstraintsGuarded(typeParameterListOccurred);\n\n        if (at(SEMICOLON)) {\n            advance(); // SEMICOLON\n        }\n        else if (at(EQ) || at(LBRACE)) {\n            parseFunctionBody();\n        }\n\n        return FUN;\n    }","commit_id":"c2435f0f24b877f5041a532171dabcc1692ff79b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseEnumEntry() {\n        assert _at(IDENTIFIER);\n\n        PsiBuilder.Marker nameAsDeclaration = mark();\n        advance(); // IDENTIFIER\n        nameAsDeclaration.done(OBJECT_DECLARATION_NAME);\n\n        parseTypeParameterList(TokenSet.create(COLON, LPAR, SEMICOLON, LBRACE));\n\n        if (at(LPAR)) {\n            parseValueParameterList(false, TokenSet.create(COLON, SEMICOLON, LBRACE));\n        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            parseInitializerList();\n        }\n\n        if (at(LBRACE)) {\n            parseClassBody();\n        }\n\n        consumeIf(SEMICOLON);\n    }","id":67518,"modified_method":"private void parseEnumEntry() {\n        assert _at(IDENTIFIER);\n\n        PsiBuilder.Marker nameAsDeclaration = mark();\n        advance(); // IDENTIFIER\n        nameAsDeclaration.done(OBJECT_DECLARATION_NAME);\n\n        boolean typeParametersDeclared = parseTypeParameterList(TokenSet.create(COLON, LPAR, SEMICOLON, LBRACE));\n\n        if (at(LPAR)) {\n            parseValueParameterList(false, TokenSet.create(COLON, SEMICOLON, LBRACE));\n        }\n\n        if (at(COLON)) {\n            advance(); // COLON\n\n            parseInitializerList();\n        }\n\n        parseTypeConstraintsGuarded(typeParametersDeclared);\n\n        if (at(LBRACE)) {\n            parseClassBody();\n        }\n\n        consumeIf(SEMICOLON);\n    }","commit_id":"c2435f0f24b877f5041a532171dabcc1692ff79b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public JetNodeType parseProperty(boolean local) {\n        if (at(VAL_KEYWORD) || at(VAR_KEYWORD)) {\n            advance(); // VAL_KEYWORD or VAR_KEYWORD\n        } else {\n            errorAndAdvance(\"Expecting 'val' or 'var'\");\n        }\n\n        if (at(LT)) {\n            parseTypeParameterList(TokenSet.create(IDENTIFIER, EQ, COLON, SEMICOLON));\n        }\n\n        TokenSet propertyNameFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON);\n\n        // TODO: extract constant\n        int lastDot = matchTokenStreamPredicate(new FirstBefore(\n                new AtSet(DOT, SAFE_ACCESS),\n                new AbstractTokenStreamPredicate() {\n                    @Override\n                    public boolean matching(boolean topLevel) {\n                        if (topLevel && (at(EQ) || at(COLON))) return true;\n                        if (topLevel && at(IDENTIFIER)) {\n                            IElementType lookahead = lookahead(1);\n                            return lookahead != LT && lookahead != DOT && lookahead != SAFE_ACCESS;\n                        }\n                        return false;\n                    }\n                }));\n\n        parseReceiverType(\"property\", propertyNameFollow, lastDot);\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseTypeRef();\n        }\n\n        if (local) {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                // \"val a = 1; b\" must not be an infix call of b on \"val ...;\"\n            }\n        }\n        else {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                consumeIf(SEMICOLON);\n            }\n\n            if (parsePropertyGetterOrSetter()) {\n                parsePropertyGetterOrSetter();\n            }\n            if  (!atSet(EOL_OR_SEMICOLON, RBRACE)) {\n                if (getLastToken() != SEMICOLON) {\n                    errorUntil(\"Property getter or setter expected\", TokenSet.create(EOL_OR_SEMICOLON));\n                }\n            }\n            else {\n                consumeIf(SEMICOLON);\n            }\n        }\n\n\n        return PROPERTY;\n    }","id":67519,"modified_method":"public JetNodeType parseProperty(boolean local) {\n        if (at(VAL_KEYWORD) || at(VAR_KEYWORD)) {\n            advance(); // VAL_KEYWORD or VAR_KEYWORD\n        } else {\n            errorAndAdvance(\"Expecting 'val' or 'var'\");\n        }\n\n        boolean typeParametersDeclared = at(LT) ? parseTypeParameterList(TokenSet.create(IDENTIFIER, EQ, COLON, SEMICOLON)) : false;\n\n        TokenSet propertyNameFollow = TokenSet.create(COLON, EQ, LBRACE, SEMICOLON);\n\n        // TODO: extract constant\n        int lastDot = matchTokenStreamPredicate(new FirstBefore(\n                new AtSet(DOT, SAFE_ACCESS),\n                new AbstractTokenStreamPredicate() {\n                    @Override\n                    public boolean matching(boolean topLevel) {\n                        if (topLevel && (at(EQ) || at(COLON))) return true;\n                        if (topLevel && at(IDENTIFIER)) {\n                            IElementType lookahead = lookahead(1);\n                            return lookahead != LT && lookahead != DOT && lookahead != SAFE_ACCESS;\n                        }\n                        return false;\n                    }\n                }));\n\n        parseReceiverType(\"property\", propertyNameFollow, lastDot);\n\n        if (at(COLON)) {\n            advance(); // COLON\n            parseTypeRef();\n        }\n\n        parseTypeConstraintsGuarded(typeParametersDeclared);\n\n        if (local) {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                // \"val a = 1; b\" must not be an infix call of b on \"val ...;\"\n            }\n        }\n        else {\n            if (at(EQ)) {\n                advance(); // EQ\n                myExpressionParsing.parseExpression();\n                consumeIf(SEMICOLON);\n            }\n\n            if (parsePropertyGetterOrSetter()) {\n                parsePropertyGetterOrSetter();\n            }\n            if  (!atSet(EOL_OR_SEMICOLON, RBRACE)) {\n                if (getLastToken() != SEMICOLON) {\n                    errorUntil(\"Property getter or setter expected\", TokenSet.create(EOL_OR_SEMICOLON));\n                }\n            }\n            else {\n                consumeIf(SEMICOLON);\n            }\n        }\n\n\n        return PROPERTY;\n    }","commit_id":"c2435f0f24b877f5041a532171dabcc1692ff79b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void parseTypeParameterList(TokenSet recoverySet) {\n        PsiBuilder.Marker list = mark();\n        if (at(LT)) {\n\n            myBuilder.disableNewlines();\n            advance(); // LT\n\n            while (true) {\n                if (at(COMMA)) errorAndAdvance(\"Expecting type parameter declaration\");\n                parseTypeParameter();\n\n                if (!at(COMMA)) break;\n                advance(); // COMMA\n            }\n\n            expect(GT, \"Missing '>'\", recoverySet);\n            myBuilder.restoreNewlinesState();\n\n            if (at(WHERE_KEYWORD)) {\n                parseTypeConstraintList();\n            }\n        }\n        list.done(TYPE_PARAMETER_LIST);\n    }","id":67520,"modified_method":"private boolean parseTypeParameterList(TokenSet recoverySet) {\n        PsiBuilder.Marker list = mark();\n        boolean result = false;\n        if (at(LT)) {\n\n            myBuilder.disableNewlines();\n            advance(); // LT\n\n            while (true) {\n                if (at(COMMA)) errorAndAdvance(\"Expecting type parameter declaration\");\n                parseTypeParameter();\n\n                if (!at(COMMA)) break;\n                advance(); // COMMA\n            }\n\n            expect(GT, \"Missing '>'\", recoverySet);\n            myBuilder.restoreNewlinesState();\n            result = true;\n        }\n        list.done(TYPE_PARAMETER_LIST);\n        return result;\n    }","commit_id":"c2435f0f24b877f5041a532171dabcc1692ff79b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    public List<JetTypeConstraint> getTypeConstaints() {\n        JetTypeParameterList typeParameterList = getTypeParameterList();\n        if (typeParameterList == null) {\n            return Collections.emptyList();\n        }\n        JetTypeConstraintList typeConstraintList = typeParameterList.getTypeConstraintList();\n        if (typeConstraintList == null) {\n            return Collections.emptyList();\n        }\n        return typeConstraintList.getConstraints();\n    }","id":67521,"modified_method":"@NotNull\n    public List<JetTypeConstraint> getTypeConstaints() {\n        JetTypeConstraintList typeConstraintList = getTypeConstraintList();\n        if (typeConstraintList == null) {\n            return Collections.emptyList();\n        }\n        return typeConstraintList.getConstraints();\n    }","commit_id":"c2435f0f24b877f5041a532171dabcc1692ff79b","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkAssignment(AbstractElement object, String feature) {\n\t\tif (assignedFeatures.containsKey(feature)) {\n\t\t\tCollection<AbstractElement> sources = Lists.newArrayList(assignedFeatures.get(feature));\n\t\t\tassignedFeatures.replaceValues(feature, Iterables.<AbstractElement> emptyIterable());\n\t\t\tif (sources != null && sources.equals(Collections.singletonList(object))) {\n\t\t\t\tacceptWarning(\"The assigned value of feature '\" + feature\n\t\t\t\t\t\t+ \"' will possibly override itself because it is used inside of a loop.\", object, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sources != null) {\n\t\t\t\t\tfor (AbstractElement source : sources)\n\t\t\t\t\t\tacceptWarning(\"The possibly assigned value of feature '\" + feature\n\t\t\t\t\t\t\t\t+ \"' may be overridden by subsequent assignments.\", source, null);\n\t\t\t\t}\n\t\t\t\tacceptWarning(\"This assignment will override the possibly assigned value of feature '\"\n\t\t\t\t\t\t+ feature + \"'.\", object, null);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassignedFeatures.put(feature, object);\n\t\t}\n\t}","id":67522,"modified_method":"private void checkAssignment(AbstractElement object, String feature) {\n\t\tif (assignedFeatures.containsKey(feature)) {\n\t\t\tCollection<AbstractElement> sources = Lists.newArrayList(assignedFeatures.get(feature));\n\t\t\tassignedFeatures.replaceValues(feature, Iterables.<AbstractElement> emptyIterable());\n\t\t\tif (sources != null && sources.equals(Collections.singletonList(object))) {\n\t\t\t\tif (getNestingLevel() == 0)\n\t\t\t\t\tacceptWarning(\"The assigned value of feature '\" + feature\n\t\t\t\t\t\t\t+ \"' will possibly override itself because it is used inside of a loop.\", object, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (sources != null) {\n\t\t\t\t\tif (getNestingLevel() == 0)\n\t\t\t\t\t\tfor (AbstractElement source : sources)\n\t\t\t\t\t\t\tacceptWarning(\"The possibly assigned value of feature '\" + feature\n\t\t\t\t\t\t\t\t\t+ \"' may be overridden by subsequent assignments.\", source, null);\n\t\t\t\t}\n\t\t\t\tif (getNestingLevel() == 0)\n\t\t\t\t\tacceptWarning(\"This assignment will override the possibly assigned value of feature '\"\n\t\t\t\t\t\t\t+ feature + \"'.\", object, null);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tassignedFeatures.put(feature, object);\n\t\t}\n\t}","commit_id":"f9b566698e17e0e0a669ddf02f027e68b49753c2","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testRichStringValidation() throws Exception {\n\t\tRichString richString = richString(\"'''\\n\"\n\t\t\t\t+ \"\\tindentedLine\\n\"\n\t\t\t\t+ \"'''\");\n\t\tvalidationTestHelper.assertNoIssues(richString);\n\t}","id":67523,"modified_method":"public void testRichStringValidation_02() throws Exception {\n\t\tRichString richString = richString(\"'''  \\n\"\n\t\t\t\t+ \"\\t\\tindentedLine\\n\"\n\t\t\t\t+ \"\\t\\tindentedLine\\n\"\n\t\t\t\t+ \"  '''\");\n\t\tvalidationTestHelper.assertNoIssues(richString);\n\t}","commit_id":"b3467ebaf51e5e988a0b65348437113afce978d6","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void resetCurrentOffset(RichStringLiteral origin) {\n\t\tif (root == null)\n\t\t\troot = origin;\n\t\tif (origin != null && origin != recent) {\n\t\t\t// no actions are involved, we are interested in the real node\n\t\t\trecent = origin;\n\t\t\tList<INode> featureNodes = NodeModelUtils.findNodesForFeature(origin,\n\t\t\t\t\tXbasePackage.Literals.XSTRING_LITERAL__VALUE);\n\t\t\tif (featureNodes.size() == 1) {\n\t\t\t\tINode node = featureNodes.get(0);\n\t\t\t\tcurrentOffset = node.getOffset();\n\t\t\t\tif (node.getText().charAt(0) == '\\'') {\n\t\t\t\t\tcurrentOffset += 3;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentOffset += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":67524,"modified_method":"protected void resetCurrentOffset(RichStringLiteral origin) {\n\t\tif (root == null)\n\t\t\troot = origin;\n\t\tif (origin != null && origin != recent) {\n\t\t\t// no actions are involved, we are interested in the real node\n\t\t\trecent = origin;\n\t\t\tList<INode> featureNodes = NodeModelUtils.findNodesForFeature(origin,\n\t\t\t\t\tXbasePackage.Literals.XSTRING_LITERAL__VALUE);\n\t\t\tif (featureNodes.size() == 1) {\n\t\t\t\tINode node = featureNodes.get(0);\n\t\t\t\tcurrentOffset = node.getOffset();\n\t\t\t\tString nodeText = node.getText();\n\t\t\t\tif (nodeText.endsWith(\"'''\")) {\n\t\t\t\t\tlastOffsetOfLiteral = currentOffset + node.getLength() - 3;\n\t\t\t\t}\n\t\t\t\tif (nodeText.charAt(0) == '\\'') {\n\t\t\t\t\tcurrentOffset += 3;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentOffset += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"b3467ebaf51e5e988a0b65348437113afce978d6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void accept(IRichStringPartAcceptor acceptor) {\n\t\tif (indentationStack.isEmpty())\n\t\t\treturn;\n\t\tString indentation = indentationStack.getLast();\n\t\tif (unfulfilledIndentationExpectation != null) {\n\t\t\tthis.acceptor.acceptWarning(\"Inconsistent indentation\", root, currentOffset, indentation.length(), \n\t\t\t\t\tIssueCodes.INCONSISTENT_INDENTATION, unfulfilledIndentationExpectation);\n\t\t\tunfulfilledIndentationExpectation = null;\n\t\t}\n\t\tcurrentOffset+=indentation.length();\n\t}","id":67525,"modified_method":"public void accept(IRichStringPartAcceptor acceptor) {\n\t\tif (indentationStack.isEmpty())\n\t\t\treturn;\n\t\tString indentation = indentationStack.getLast();\n\t\tif (unfulfilledIndentationExpectation != null) {\n\t\t\tif (currentOffset + indentation.length() != lastOffsetOfLiteral) {\n\t\t\t\tthis.acceptor.acceptWarning(\"Inconsistent indentation\", root, currentOffset, indentation.length(), \n\t\t\t\t\t\tIssueCodes.INCONSISTENT_INDENTATION, unfulfilledIndentationExpectation);\n\t\t\t}\n\t\t\tunfulfilledIndentationExpectation = null;\n\t\t}\n\t\tcurrentOffset+=indentation.length();\n\t}","commit_id":"b3467ebaf51e5e988a0b65348437113afce978d6","url":"https://github.com/eclipse/xtext"},{"original_method":"public void testRichStringValidation() throws Exception {\n\t\tRichString richString = richString(\"'''\\n\"\n\t\t\t\t+ \"\\tindentedLine\\n\"\n\t\t\t\t+ \"'''\");\n\t\tvalidationTestHelper.assertNoIssues(richString);\n\t}","id":67526,"modified_method":"public void testRichStringValidation_02() throws Exception {\n\t\tRichString richString = richString(\"'''  \\n\"\n\t\t\t\t+ \"\\t\\tindentedLine\\n\"\n\t\t\t\t+ \"\\t\\tindentedLine\\n\"\n\t\t\t\t+ \"  '''\");\n\t\tvalidationTestHelper.assertNoIssues(richString);\n\t}","commit_id":"2574a3394149cd9b59dc927d513f2aaf3246121a","url":"https://github.com/eclipse/xtext"},{"original_method":"public void accept(IRichStringPartAcceptor acceptor) {\n\t\tif (indentationStack.isEmpty())\n\t\t\treturn;\n\t\tString indentation = indentationStack.getLast();\n\t\tif (unfulfilledIndentationExpectation != null) {\n\t\t\tthis.acceptor.acceptWarning(\"Inconsistent indentation\", root, currentOffset, indentation.length(), \n\t\t\t\t\tIssueCodes.INCONSISTENT_INDENTATION, unfulfilledIndentationExpectation);\n\t\t\tunfulfilledIndentationExpectation = null;\n\t\t}\n\t\tcurrentOffset+=indentation.length();\n\t}","id":67527,"modified_method":"public void accept(IRichStringPartAcceptor acceptor) {\n\t\tif (indentationStack.isEmpty())\n\t\t\treturn;\n\t\tString indentation = indentationStack.getLast();\n\t\tif (unfulfilledIndentationExpectation != null) {\n\t\t\tif (currentOffset + indentation.length() != lastOffsetOfLiteral) {\n\t\t\t\tthis.acceptor.acceptWarning(\"Inconsistent indentation\", root, currentOffset, indentation.length(), \n\t\t\t\t\t\tIssueCodes.INCONSISTENT_INDENTATION, unfulfilledIndentationExpectation);\n\t\t\t}\n\t\t\tunfulfilledIndentationExpectation = null;\n\t\t}\n\t\tcurrentOffset+=indentation.length();\n\t}","commit_id":"2574a3394149cd9b59dc927d513f2aaf3246121a","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void resetCurrentOffset(RichStringLiteral origin) {\n\t\tif (root == null)\n\t\t\troot = origin;\n\t\tif (origin != null && origin != recent) {\n\t\t\t// no actions are involved, we are interested in the real node\n\t\t\trecent = origin;\n\t\t\tList<INode> featureNodes = NodeModelUtils.findNodesForFeature(origin,\n\t\t\t\t\tXbasePackage.Literals.XSTRING_LITERAL__VALUE);\n\t\t\tif (featureNodes.size() == 1) {\n\t\t\t\tINode node = featureNodes.get(0);\n\t\t\t\tcurrentOffset = node.getOffset();\n\t\t\t\tif (node.getText().charAt(0) == '\\'') {\n\t\t\t\t\tcurrentOffset += 3;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentOffset += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":67528,"modified_method":"protected void resetCurrentOffset(RichStringLiteral origin) {\n\t\tif (root == null)\n\t\t\troot = origin;\n\t\tif (origin != null && origin != recent) {\n\t\t\t// no actions are involved, we are interested in the real node\n\t\t\trecent = origin;\n\t\t\tList<INode> featureNodes = NodeModelUtils.findNodesForFeature(origin,\n\t\t\t\t\tXbasePackage.Literals.XSTRING_LITERAL__VALUE);\n\t\t\tif (featureNodes.size() == 1) {\n\t\t\t\tINode node = featureNodes.get(0);\n\t\t\t\tcurrentOffset = node.getOffset();\n\t\t\t\tString nodeText = node.getText();\n\t\t\t\tif (nodeText.endsWith(\"'''\")) {\n\t\t\t\t\tlastOffsetOfLiteral = currentOffset + node.getLength() - 3;\n\t\t\t\t}\n\t\t\t\tif (nodeText.charAt(0) == '\\'') {\n\t\t\t\t\tcurrentOffset += 3;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentOffset += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"2574a3394149cd9b59dc927d513f2aaf3246121a","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public boolean shouldBeExecuted(Project p) {\n    String value = MigrationPropertiesManager.getInstance().getProperties(p).getProperty(Name2IdMigration.EXECUTED_PROPERTY);\n    return !(EXECUTED_VALUE.equals(value));\n  }","id":67529,"modified_method":"@Override\n  public boolean shouldBeExecuted(Project p) {\n    String value = MigrationPropertiesManager.getInstance().getProperties(p).getProperty(Name2IdMigration.EXECUTED_PROPERTY);\n    if (EXECUTED_VALUE.equals(value)) {\n      return false;\n    }\n\n    for (SModule module : Sequence.fromIterable(p.getModules())) {\n      for (SModel model : Sequence.fromIterable(module.getModels())) {\n        if (model.isReadOnly()) {\n          continue;\n        }\n        if (!((model instanceof PersistenceVersionAware))) {\n          continue;\n        }\n        if (((PersistenceVersionAware) model).getPersistenceVersion() != 9) {\n          return true;\n        }\n      }\n    }\n    MigrationPropertiesManager.getInstance().getProperties(p).setProperty(EXECUTED_PROPERTY, EXECUTED_VALUE);\n    return false;\n  }","commit_id":"ef38db70a5d35f9b17285738d9661f6efddddd47","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void execute(Project p) {\n    Iterable<? extends SModule> modules = p.getModulesWithGenerators();\n    final ModelFactory defaultModelFactory = PersistenceFacade.getInstance().getDefaultModelFactory();\n    // models: editable, persistence aware, in xml (default) persistence and of older version \n    Iterable<PersistenceVersionAware> models = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {\n      public Iterable<SModel> translate(SModule it) {\n        return it.getModels();\n      }\n    }).ofType(EditableSModel.class).ofType(PersistenceVersionAware.class).where(new IWhereFilter<PersistenceVersionAware>() {\n      public boolean accept(PersistenceVersionAware it) {\n        return it.getModelFactory() == defaultModelFactory && it.getPersistenceVersion() < 9;\n      }\n    });\n    Sequence.fromIterable(models).visitAll(new IVisitor<PersistenceVersionAware>() {\n      public void visit(PersistenceVersionAware it) {\n        it.load();\n      }\n    });\n\n    // do not migrate test refactoring models \n    models = Sequence.fromIterable(models).subtract(Sequence.fromIterable(models).where(new IWhereFilter<PersistenceVersionAware>() {\n      public boolean accept(PersistenceVersionAware it) {\n        SModuleReference mr = it.getModule().getModuleReference();\n        return mr.equals(PersistenceFacade.getInstance().createModuleReference(\"343e2a8b-449f-45b3-9da8-1463945cb208(testRefactoring)\")) || mr.equals(PersistenceFacade.getInstance().createModuleReference(\"7bb4f305-7fb7-495b-be9c-5777cd6ab9d6(testRefactoringTargetLang)\")) || mr.equals(PersistenceFacade.getInstance().createModuleReference(\"343e2a8b-449f-45b3-9da8-1463945cb208(testRefactoring)\")) || mr.equals(PersistenceFacade.getInstance().createModuleReference(\"24106442-1955-413a-8c2b-cc6969a4b149(testRefactoring.sandbox)\"));\n      }\n    }));\n\n    Sequence.fromIterable(models).visitAll(new IVisitor<PersistenceVersionAware>() {\n      public void visit(PersistenceVersionAware model) {\n        model.setPersistenceVersion(9);\n        ((EditableSModel) model).setChanged(true);\n        ((EditableSModel) model).save();\n      }\n    });\n\n    MigrationPropertiesManager.getInstance().getProperties(p).setProperty(EXECUTED_PROPERTY, EXECUTED_VALUE);\n  }","id":67530,"modified_method":"@Override\n  public void execute(Project p) {\n    Iterable<? extends SModule> modules = p.getModulesWithGenerators();\n    final ModelFactory defaultModelFactory = PersistenceFacade.getInstance().getDefaultModelFactory();\n    // models: editable, persistence aware, in xml (default) persistence and of older version \n    Iterable<PersistenceVersionAware> models = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {\n      public Iterable<SModel> translate(SModule it) {\n        return it.getModels();\n      }\n    }).ofType(EditableSModel.class).where(new IWhereFilter<EditableSModel>() {\n      public boolean accept(EditableSModel it) {\n        return !(it.isReadOnly());\n      }\n    }).ofType(PersistenceVersionAware.class).where(new IWhereFilter<PersistenceVersionAware>() {\n      public boolean accept(PersistenceVersionAware it) {\n        return it.getModelFactory() == defaultModelFactory && it.getPersistenceVersion() < 9;\n      }\n    });\n    Sequence.fromIterable(models).visitAll(new IVisitor<PersistenceVersionAware>() {\n      public void visit(PersistenceVersionAware it) {\n        it.load();\n      }\n    });\n\n    // do not migrate test refactoring models \n    models = Sequence.fromIterable(models).subtract(Sequence.fromIterable(models).where(new IWhereFilter<PersistenceVersionAware>() {\n      public boolean accept(PersistenceVersionAware it) {\n        SModuleReference mr = it.getModule().getModuleReference();\n        return mr.equals(PersistenceFacade.getInstance().createModuleReference(\"343e2a8b-449f-45b3-9da8-1463945cb208(testRefactoring)\")) || mr.equals(PersistenceFacade.getInstance().createModuleReference(\"7bb4f305-7fb7-495b-be9c-5777cd6ab9d6(testRefactoringTargetLang)\")) || mr.equals(PersistenceFacade.getInstance().createModuleReference(\"343e2a8b-449f-45b3-9da8-1463945cb208(testRefactoring)\")) || mr.equals(PersistenceFacade.getInstance().createModuleReference(\"24106442-1955-413a-8c2b-cc6969a4b149(testRefactoring.sandbox)\"));\n      }\n    }));\n\n    Sequence.fromIterable(models).visitAll(new IVisitor<PersistenceVersionAware>() {\n      public void visit(PersistenceVersionAware model) {\n        model.setPersistenceVersion(9);\n        ((EditableSModel) model).setChanged(true);\n        ((EditableSModel) model).save();\n      }\n    });\n\n    MigrationPropertiesManager.getInstance().getProperties(p).setProperty(EXECUTED_PROPERTY, EXECUTED_VALUE);\n  }","commit_id":"ef38db70a5d35f9b17285738d9661f6efddddd47","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      Iterable<? extends SModule> modulesWithGenerators = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getModulesWithGenerators();\n      Sequence.fromIterable(modulesWithGenerators).translate(new ITranslator2<SModule, SModel>() {\n        public Iterable<SModel> translate(SModule it) {\n          return it.getModels();\n        }\n      }).select(new ISelector<SModel, DataSource>() {\n        public DataSource select(SModel it) {\n          return it.getSource();\n        }\n      }).select(new ISelector<DataSource, IFile>() {\n        public IFile select(DataSource it) {\n          if (it instanceof FileDataSource) {\n            IFile modelFile = as_wouwxe_a0a0a0a0a0a0a0a0b0a0f(it, FileDataSource.class).getFile();\n            String modelPath = modelFile.getPath();\n            return FileSystem.getInstance().getFileByPath(modelPath.substring(0, modelPath.length() - MPSExtentions.DOT_MODEL.length()) + MPSExtentions.DOT_REFACTORINGS);\n          } else if (it instanceof FilePerRootDataSource) {\n            return as_wouwxe_a0a0a0a0a0a0a0a0b0a0f_0(it, FilePerRootDataSource.class).getFile(MPSExtentions.DOT_REFACTORINGS);\n          } else {\n            return null;\n          }\n        }\n      }).where(new IWhereFilter<IFile>() {\n        public boolean accept(IFile it) {\n          return it != null && it.exists();\n        }\n      }).visitAll(new IVisitor<IFile>() {\n        public void visit(IFile it) {\n          it.delete();\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ClearHistoryFiles\", t);\n      }\n    }\n  }","id":67531,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      Iterable<? extends SModule> modulesWithGenerators = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getModulesWithGenerators();\n      Sequence.fromIterable(modulesWithGenerators).translate(new ITranslator2<SModule, SModel>() {\n        public Iterable<SModel> translate(SModule it) {\n          return it.getModels();\n        }\n      }).where(new IWhereFilter<SModel>() {\n        public boolean accept(SModel it) {\n          return !(it.isReadOnly());\n        }\n      }).select(new ISelector<SModel, DataSource>() {\n        public DataSource select(SModel it) {\n          return it.getSource();\n        }\n      }).select(new ISelector<DataSource, IFile>() {\n        public IFile select(DataSource it) {\n          if (it instanceof FileDataSource) {\n            IFile modelFile = as_wouwxe_a0a0a0a0a0a0a0a0b0a0f(it, FileDataSource.class).getFile();\n            String modelPath = modelFile.getPath();\n            return FileSystem.getInstance().getFileByPath(modelPath.substring(0, modelPath.length() - MPSExtentions.DOT_MODEL.length()) + MPSExtentions.DOT_REFACTORINGS);\n          } else if (it instanceof FilePerRootDataSource) {\n            return as_wouwxe_a0a0a0a0a0a0a0a0b0a0f_0(it, FilePerRootDataSource.class).getFile(MPSExtentions.DOT_REFACTORINGS);\n          } else {\n            return null;\n          }\n        }\n      }).where(new IWhereFilter<IFile>() {\n        public boolean accept(IFile it) {\n          return it != null && it.exists();\n        }\n      }).visitAll(new IVisitor<IFile>() {\n        public void visit(IFile it) {\n          it.delete();\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"ClearHistoryFiles\", t);\n      }\n    }\n  }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"public int languageStepsCount() {\n    final Wrappers._int result = new Wrappers._int();\n    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {\n      public Integer invoke() {\n        Iterable<? extends SModule> projectModules = mpsProject.getModulesWithGenerators();\n        Iterable<Integer> scriptsByModule = Sequence.fromIterable(projectModules).ofType(AbstractModule.class).select(new ISelector<AbstractModule, Integer>() {\n          public Integer select(AbstractModule module) {\n            int scripts = 0;\n            for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {\n              int currentLangVersion = lang.getLanguageVersion();\n              int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);\n\n              ver = Math.max(ver, 0);\n              currentLangVersion = Math.max(currentLangVersion, 0);\n\n              if (ver < currentLangVersion) {\n                scripts += currentLangVersion - ver;\n              }\n            }\n            return scripts;\n          }\n        });\n        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {\n          public Integer combine(Integer s, Integer it) {\n            return s + it;\n          }\n        });\n      }\n    }));\n    return result.value;\n  }","id":67532,"modified_method":"public int languageStepsCount() {\n    final Wrappers._int result = new Wrappers._int();\n    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Integer>() {\n      public Integer invoke() {\n        Iterable<Integer> scriptsByModule = Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).ofType(AbstractModule.class).select(new ISelector<AbstractModule, Integer>() {\n          public Integer select(AbstractModule module) {\n            int scripts = 0;\n            for (SLanguage lang : SetSequence.fromSet(((AbstractModule) module).getAllUsedLanguages())) {\n              int currentLangVersion = lang.getLanguageVersion();\n              int ver = ((AbstractModule) module).getUsedLanguageVersion(lang);\n\n              ver = Math.max(ver, 0);\n              currentLangVersion = Math.max(currentLangVersion, 0);\n\n              if (ver < currentLangVersion) {\n                scripts += currentLangVersion - ver;\n              }\n            }\n            return scripts;\n          }\n        });\n        return result.value = Sequence.fromIterable(scriptsByModule).foldLeft(0, new ILeftCombinator<Integer, Integer>() {\n          public Integer combine(Integer s, Integer it) {\n            return s + it;\n          }\n        });\n      }\n    }));\n    return result.value;\n  }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"public MigrationManager.MigrationStep nextLanguageStep() {\n    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);\n\n    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {\n      public Boolean invoke() {\n        Collection<ScriptApplied> scripts = CollectionSequence.fromCollection(new ArrayList<ScriptApplied>());\n\n        Iterable<? extends SModule> projectModules = mpsProject.getModulesWithGenerators();\n        return Sequence.fromIterable(projectModules).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {\n          public boolean accept(final AbstractModule module) {\n            return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {\n              public boolean accept(MigrationScriptReference it) {\n                if (!(MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module))) {\n                  return false;\n                }\n                MigrationScript loaded = fetchScript(it);\n                if (loaded == null) {\n                  return false;\n                }\n                final ScriptApplied applied = new ScriptApplied(loaded, module);\n                if (!(areDepsSatisfied(applied))) {\n                  return false;\n                }\n                result.value = new MigrationManager.MigrationStep() {\n                  public String getDescription() {\n                    return applied.toString();\n                  }\n                  public boolean execute() {\n                    final Wrappers._boolean res = new Wrappers._boolean();\n                    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n                      public void run() {\n                        res.value = executeScript(applied);\n                      }\n                    });\n                    return res.value;\n                  }\n                  public void forceExecutionNextTime() {\n                    throw new UnsupportedOperationException(\"not supported for language migrations\");\n                  }\n                };\n                return true;\n              }\n            });\n          }\n        });\n      }\n    }));\n\n    return result.value;\n  }","id":67533,"modified_method":"public MigrationManager.MigrationStep nextLanguageStep() {\n    final Wrappers._T<MigrationManager.MigrationStep> result = new Wrappers._T<MigrationManager.MigrationStep>(null);\n\n    ModelAccess.instance().runReadAction(new _Adapters._return_P0_E0_to_Runnable_adapter(new _FunctionTypes._return_P0_E0<Boolean>() {\n      public Boolean invoke() {\n        Collection<ScriptApplied> scripts = CollectionSequence.fromCollection(new ArrayList<ScriptApplied>());\n\n        return Sequence.fromIterable(MigrationsUtil.getMigrateableModulesFromProject(mpsProject)).ofType(AbstractModule.class).any(new IWhereFilter<AbstractModule>() {\n          public boolean accept(final AbstractModule module) {\n            return Sequence.fromIterable(MigrationsUtil.getNextStepScripts(module)).any(new IWhereFilter<MigrationScriptReference>() {\n              public boolean accept(MigrationScriptReference it) {\n                if (!(MigrationsUtil.isMigrationNeeded(it.getLanguage(), it.getFromVersion(), module))) {\n                  return false;\n                }\n                MigrationScript loaded = fetchScript(it);\n                if (loaded == null) {\n                  return false;\n                }\n                final ScriptApplied applied = new ScriptApplied(loaded, module);\n                if (!(areDepsSatisfied(applied))) {\n                  return false;\n                }\n                result.value = new MigrationManager.MigrationStep() {\n                  public String getDescription() {\n                    return applied.toString();\n                  }\n                  public boolean execute() {\n                    final Wrappers._boolean res = new Wrappers._boolean();\n                    ModelAccess.instance().runWriteActionInCommand(new Runnable() {\n                      public void run() {\n                        res.value = executeScript(applied);\n                      }\n                    });\n                    return res.value;\n                  }\n                  public void forceExecutionNextTime() {\n                    throw new UnsupportedOperationException(\"not supported for language migrations\");\n                  }\n                };\n                return true;\n              }\n            });\n          }\n        });\n      }\n    }));\n\n    return result.value;\n  }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void doRun(final ProgressIndicator progress) {\n    Map<String, Object> options = InitialStep.getOptions();\n    setFraction(progress, ProgressEstimation.initial());\n\n    boolean cleanNotification = false;\n    List<MigrationManager.MigrationStep> cleanupMigrations = ListSequence.fromList(new ArrayList<MigrationManager.MigrationStep>());\n    int cleanupStepsCount = myManager.projectStepsCount(true);\n    int stepNum = 0;\n    while (true) {\n      MigrationManager.MigrationStep step = myManager.nextProjectStep(options, true);\n      if (step == null) {\n        break;\n      }\n\n      ListSequence.fromList(cleanupMigrations).addElement(step);\n      if (!(executeSingleStep(step))) {\n        break;\n      }\n\n      if (!(cleanNotification)) {\n        cleanNotification = true;\n        addElementToMigrationList(\"Cleaning project... Please wait.\");\n      }\n\n      stepNum++;\n      setFraction(progress, ProgressEstimation.cleanupMigrations(1.0 * stepNum / cleanupStepsCount));\n    }\n\n    addElementToMigrationList(\"Checking migrations consistency... Please wait.\");\n    List<Tuples._3<SModule, SLanguage, Integer>> missingMigrations = myManager.getMissingMigrations();\n    setFraction(progress, ProgressEstimation.migrationsCheck(1.0));\n    if (ListSequence.fromList(missingMigrations).isNotEmpty()) {\n      myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.MigrationsMissingError(missingMigrations));\n      addElementToMigrationList(\"Some migrations are missing. Press 'Next' to continue.\");\n      return;\n    }\n\n    addElementToMigrationList(\"Checking models... Please wait.\");\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        Iterable<SModule> modules = ((Iterable<SModule>) ProjectHelper.toMPSProject(myProject).getModulesWithGenerators());\n        if (MigrationCheckUtil.haveProblems(modules, new _FunctionTypes._void_P1_E0<Double>() {\n          public void invoke(Double fraction) {\n            setFraction(progress, ProgressEstimation.preCheck(fraction));\n          }\n        })) {\n          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PreCheckError());\n        }\n      }\n    });\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      // start cleanup migrations next time migration is started \n      for (MigrationManager.MigrationStep cleanupMigration : ListSequence.fromList(cleanupMigrations)) {\n        cleanupMigration.forceExecutionNextTime();\n      }\n      addElementToMigrationList(\"Can't start migration: errors detected. Press 'Next' to continue.\");\n      return;\n    }\n\n    int projectStepsCount = myManager.projectStepsCount(false);\n    stepNum = 0;\n    while (executeSingleStep(myManager.nextProjectStep(options, false))) {\n      stepNum++;\n      setFraction(progress, ProgressEstimation.projectMigrations(1.0 * stepNum / projectStepsCount));\n    }\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      addElementToMigrationList(\"Exception while running migration. Press 'Next' to continue.\");\n      return;\n    }\n\n    int languageStepsCount = myManager.languageStepsCount();\n    stepNum = 0;\n    while (executeSingleStep(myManager.nextLanguageStep())) {\n      stepNum++;\n      setFraction(progress, ProgressEstimation.languageMigrations(1.0 * stepNum / languageStepsCount));\n    }\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      addElementToMigrationList(\"Exception while running migration. Press 'Next' to continue.\");\n      return;\n    }\n\n    addElementToMigrationList(\"Saving changed models... Please wait.\");\n    ModelAccess.instance().runWriteInEDT(new Runnable() {\n      public void run() {\n        MPSModuleRepository.getInstance().saveAll();\n      }\n    });\n    setFraction(progress, ProgressEstimation.saving(1.0));\n\n    addElementToMigrationList(\"Checking models... Please wait.\");\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        Iterable<SModule> modules = ((Iterable<SModule>) ProjectHelper.toMPSProject(myProject).getModulesWithGenerators());\n        final Wrappers._int moduleNum = new Wrappers._int(0);\n        if (MigrationCheckUtil.haveProblems(modules, new _FunctionTypes._void_P1_E0<Double>() {\n          public void invoke(Double fraction) {\n            moduleNum.value++;\n            setFraction(progress, ProgressEstimation.postCheck(fraction));\n          }\n        })) {\n          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PostCheckError());\n        }\n      }\n    });\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      addElementToMigrationList(\"Errors are detected in project after executing migrations. Press 'Next' to continue.\");\n      return;\n    }\n\n    addElementToMigrationList(\"Done!\");\n  }","id":67534,"modified_method":"private void doRun(final ProgressIndicator progress) {\n    Map<String, Object> options = InitialStep.getOptions();\n    setFraction(progress, ProgressEstimation.initial());\n\n    boolean cleanNotification = false;\n    List<MigrationManager.MigrationStep> cleanupMigrations = ListSequence.fromList(new ArrayList<MigrationManager.MigrationStep>());\n    int cleanupStepsCount = myManager.projectStepsCount(true);\n    int stepNum = 0;\n    while (true) {\n      MigrationManager.MigrationStep step = myManager.nextProjectStep(options, true);\n      if (step == null) {\n        break;\n      }\n\n      ListSequence.fromList(cleanupMigrations).addElement(step);\n      if (!(executeSingleStep(step))) {\n        break;\n      }\n\n      if (!(cleanNotification)) {\n        cleanNotification = true;\n        addElementToMigrationList(\"Cleaning project... Please wait.\");\n      }\n\n      stepNum++;\n      setFraction(progress, ProgressEstimation.cleanupMigrations(1.0 * stepNum / cleanupStepsCount));\n    }\n\n    addElementToMigrationList(\"Checking migrations consistency... Please wait.\");\n    List<Tuples._3<SModule, SLanguage, Integer>> missingMigrations = myManager.getMissingMigrations();\n    setFraction(progress, ProgressEstimation.migrationsCheck(1.0));\n    if (ListSequence.fromList(missingMigrations).isNotEmpty()) {\n      myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.MigrationsMissingError(missingMigrations));\n      addElementToMigrationList(\"Some migrations are missing. Press 'Next' to continue.\");\n      return;\n    }\n\n    addElementToMigrationList(\"Checking models... Please wait.\");\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));\n        if (MigrationCheckUtil.haveProblems(modules, new _FunctionTypes._void_P1_E0<Double>() {\n          public void invoke(Double fraction) {\n            setFraction(progress, ProgressEstimation.preCheck(fraction));\n          }\n        })) {\n          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PreCheckError());\n        }\n      }\n    });\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      // start cleanup migrations next time migration is started \n      for (MigrationManager.MigrationStep cleanupMigration : ListSequence.fromList(cleanupMigrations)) {\n        cleanupMigration.forceExecutionNextTime();\n      }\n      addElementToMigrationList(\"Can't start migration: errors detected. Press 'Next' to continue.\");\n      return;\n    }\n\n    int projectStepsCount = myManager.projectStepsCount(false);\n    stepNum = 0;\n    while (executeSingleStep(myManager.nextProjectStep(options, false))) {\n      stepNum++;\n      setFraction(progress, ProgressEstimation.projectMigrations(1.0 * stepNum / projectStepsCount));\n    }\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      addElementToMigrationList(\"Exception while running migration. Press 'Next' to continue.\");\n      return;\n    }\n\n    int languageStepsCount = myManager.languageStepsCount();\n    stepNum = 0;\n    while (executeSingleStep(myManager.nextLanguageStep())) {\n      stepNum++;\n      setFraction(progress, ProgressEstimation.languageMigrations(1.0 * stepNum / languageStepsCount));\n    }\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      addElementToMigrationList(\"Exception while running migration. Press 'Next' to continue.\");\n      return;\n    }\n\n    addElementToMigrationList(\"Saving changed models... Please wait.\");\n    ModelAccess.instance().runWriteInEDT(new Runnable() {\n      public void run() {\n        MPSModuleRepository.getInstance().saveAll();\n      }\n    });\n    setFraction(progress, ProgressEstimation.saving(1.0));\n\n    addElementToMigrationList(\"Checking models... Please wait.\");\n    ModelAccess.instance().runReadAction(new Runnable() {\n      public void run() {\n        Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(ProjectHelper.toMPSProject(myProject));\n        final Wrappers._int moduleNum = new Wrappers._int(0);\n        if (MigrationCheckUtil.haveProblems(modules, new _FunctionTypes._void_P1_E0<Double>() {\n          public void invoke(Double fraction) {\n            moduleNum.value++;\n            setFraction(progress, ProgressEstimation.postCheck(fraction));\n          }\n        })) {\n          myErrorContainer.setErrorDescriptor(new MigrationsProgressWizardStep.PostCheckError());\n        }\n      }\n    });\n    if (myErrorContainer.getErrorDescriptor() != null) {\n      addElementToMigrationList(\"Errors are detected in project after executing migrations. Press 'Next' to continue.\");\n      return;\n    }\n\n    addElementToMigrationList(\"Done!\");\n  }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Iterable<Problem> getProblems() {\n      jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);\n      Iterable<SModule> modules = ((Iterable<SModule>) mpsProject.getModulesWithGenerators());\n      return MigrationCheckUtil.getProblems(modules, null, 100);\n    }","id":67535,"modified_method":"public Iterable<Problem> getProblems() {\n      jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);\n      Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);\n      return MigrationCheckUtil.getProblems(modules, null, 100);\n    }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Iterable<Problem> getProblems() {\n      jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);\n      Iterable<SModule> modules = ((Iterable<SModule>) mpsProject.getModulesWithGenerators());\n      return MigrationCheckUtil.getProblems(modules, null, 100);\n    }","id":67536,"modified_method":"public Iterable<Problem> getProblems() {\n      jetbrains.mps.project.Project mpsProject = ProjectHelper.toMPSProject(myProject);\n      Iterable<SModule> modules = MigrationsUtil.getMigrateableModulesFromProject(mpsProject);\n      return MigrationCheckUtil.getProblems(modules, null, 100);\n    }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void saveAll(Project p) {\n    Iterable<? extends SModule> modules = p.getModulesWithGenerators();\n    List<EditableSModel> allModels = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {\n      public Iterable<SModel> translate(SModule it) {\n        return it.getModels();\n      }\n    }).ofType(EditableSModel.class).where(new IWhereFilter<EditableSModel>() {\n      public boolean accept(EditableSModel it) {\n        return SModelStereotype.isUserModel(it);\n      }\n    }).toListSequence();\n\n    for (Language language : Sequence.fromIterable(modules).ofType(Language.class)) {\n      for (Generator generator : CollectionSequence.fromCollection(language.getGenerators())) {\n        generator.updateModuleReferences();\n      }\n      language.updateSModelReferences();\n      language.save();\n    }\n\n    for (EditableSModel model : ListSequence.fromList(allModels)) {\n      if (model.isReadOnly()) {\n        continue;\n      }\n      try {\n        // ensure model is loaded \n        model.load();\n        //  and force to save model \n        model.setChanged(true);\n        if (model.isChanged()) {\n          model.save();\n        }\n      } catch (Exception ex) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"Error re-saving model \" + model.getModelName(), ex);\n        }\n      }\n    }\n  }","id":67537,"modified_method":"private void saveAll(Project p) {\n    Iterable<? extends SModule> modules = p.getModulesWithGenerators();\n    List<EditableSModel> allModels = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {\n      public Iterable<SModel> translate(SModule it) {\n        return it.getModels();\n      }\n    }).ofType(EditableSModel.class).where(new IWhereFilter<EditableSModel>() {\n      public boolean accept(EditableSModel it) {\n        return SModelStereotype.isUserModel(it);\n      }\n    }).toListSequence();\n\n    for (Language language : Sequence.fromIterable(modules).ofType(Language.class).where(new IWhereFilter<Language>() {\n      public boolean accept(Language it) {\n        return !(it.isReadOnly());\n      }\n    })) {\n      for (Generator generator : CollectionSequence.fromCollection(language.getGenerators())) {\n        generator.updateModuleReferences();\n      }\n      language.updateSModelReferences();\n      language.save();\n    }\n\n    for (EditableSModel model : ListSequence.fromList(allModels)) {\n      if (model.isReadOnly()) {\n        continue;\n      }\n      try {\n        // ensure model is loaded \n        model.load();\n        //  and force to save model \n        model.setChanged(true);\n        if (model.isChanged()) {\n          model.save();\n        }\n      } catch (Exception ex) {\n        if (LOG.isEnabledFor(Level.ERROR)) {\n          LOG.error(\"Error re-saving model \" + model.getModelName(), ex);\n        }\n      }\n    }\n  }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public boolean doExecute(Project p) {\n    Iterable<? extends SModule> modules = p.getModulesWithGenerators();\n    for (AbstractModule module : Sequence.fromIterable(modules).ofType(AbstractModule.class)) {\n      if (!(module.getModuleDescriptor().hasLanguageVersions())) {\n        module.setChanged();\n      }\n    }\n    MPSModuleRepository.getInstance().saveAll();\n    return true;\n  }","id":67538,"modified_method":"@Override\n  public boolean doExecute(Project p) {\n    Iterable<? extends SModule> modules = p.getModulesWithGenerators();\n    for (AbstractModule module : Sequence.fromIterable(modules).ofType(AbstractModule.class).where(new IWhereFilter<AbstractModule>() {\n      public boolean accept(AbstractModule it) {\n        return !(it.isReadOnly());\n      }\n    })) {\n      if (!(module.getModuleDescriptor().hasLanguageVersions())) {\n        module.setChanged();\n      }\n    }\n    MPSModuleRepository.getInstance().saveAll();\n    return true;\n  }","commit_id":"ef4feecfc34e854fb3b36a4e3fc4221d79c53c83","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      DebugRegistryUtil.fillDebugRegistry();\n      Iterable<SModule> modules = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getModules();\n      Iterable<DefaultSModelDescriptor> models = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {\n        public Iterable<SModel> translate(SModule it) {\n          return it.getModels();\n        }\n      }).ofType(DefaultSModelDescriptor.class);\n      Sequence.fromIterable(models).visitAll(new IVisitor<DefaultSModelDescriptor>() {\n        public void visit(final DefaultSModelDescriptor model) {\n          List<SModuleReference> impLangs = model.importedLanguages();\n          ListSequence.fromList(impLangs).visitAll(new IVisitor<SModuleReference>() {\n            public void visit(SModuleReference lang) {\n              model.addLanguageId(IdHelper.getLanguageId(lang.getModuleId()), 0);\n            }\n          });\n          // concept ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              ((jetbrains.mps.smodel.SNode) it).setConceptId(IdHelper.getConceptId((jetbrains.mps.smodel.SNode) (SNode) SNodeOperations.getConceptDeclaration(it)));\n            }\n          });\n          // node role ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.getParent(it) != null;\n            }\n          }).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              SContainmentLinkId rid = IdHelper.getNodeRoleId((jetbrains.mps.smodel.SNode) (SNode) SNodeOperations.getContainingLinkDeclaration(it));\n              ((jetbrains.mps.smodel.SNode) it).setRoleInParent_byId(rid);\n            }\n          });\n          // ref role ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).translate(new ITranslator2<SNode, SReference>() {\n            public Iterable<SReference> translate(SNode it) {\n              return ((Iterable<SReference>) ((SNode) it).getReferences());\n            }\n          }).visitAll(new IVisitor<SReference>() {\n            public void visit(SReference it) {\n              SReference sref = it;\n              assert sref instanceof jetbrains.mps.smodel.SReference;\n              SReferenceLinkId rid = IdHelper.getRefRoleId((jetbrains.mps.smodel.SNode) (SNode) SLinkOperations.findLinkDeclaration(((SReference) it)));\n              ((jetbrains.mps.smodel.SReference) sref).setRoleId_direct(rid);\n            }\n          });\n          // property ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).visitAll(new IVisitor<SNode>() {\n            public void visit(final SNode node) {\n              Set<String> propNames = ((jetbrains.mps.smodel.SNode) node).getPropertyNames();\n              SetSequence.fromSet(propNames).visitAll(new IVisitor<String>() {\n                public void visit(String pName) {\n                  SPropertyId pid = IdHelper.getPropId((jetbrains.mps.smodel.SNode) (SNode) BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), ((SNode) SNodeOperations.getConceptDeclaration(node)), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", \"call_findPropertyDeclaration_1219835742593\", new Object[]{pName}));\n                  ((jetbrains.mps.smodel.SNode) node).setProperty_byId(pid, ((jetbrains.mps.smodel.SNode) node).getProperty(pName));\n                }\n              });\n            }\n          });\n\n        }\n      });\n      Sequence.fromIterable(models).visitAll(new IVisitor<DefaultSModelDescriptor>() {\n        public void visit(DefaultSModelDescriptor model) {\n          LazySModel innerModel = model.getSModelInternal();\n          if (innerModel instanceof DefaultSModel) {\n            ((DefaultSModel) innerModel).setPersistenceVersion(9);\n          }\n          model.save();\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"MigrateIds\", t);\n      }\n    }\n  }","id":67539,"modified_method":"public void doExecute(@NotNull final AnActionEvent event, final Map<String, Object> _params) {\n    try {\n      DebugRegistryUtil.fillDebugRegistry();\n      Iterable<SModule> modules = ((MPSProject) MapSequence.fromMap(_params).get(\"project\")).getModules();\n      Iterable<DefaultSModelDescriptor> models = Sequence.fromIterable(modules).translate(new ITranslator2<SModule, SModel>() {\n        public Iterable<SModel> translate(SModule it) {\n          return it.getModels();\n        }\n      }).ofType(DefaultSModelDescriptor.class).where(new IWhereFilter<DefaultSModelDescriptor>() {\n        public boolean accept(DefaultSModelDescriptor it) {\n          return it.getSModelInternal() instanceof DefaultSModel && as_fu9gb8_a0a0a0a0a0a0a0c0a0f(it.getSModelInternal(), DefaultSModel.class).getPersistenceVersion() < 9;\n        }\n      });\n      Sequence.fromIterable(models).visitAll(new IVisitor<DefaultSModelDescriptor>() {\n        public void visit(final DefaultSModelDescriptor model) {\n          List<SModuleReference> impLangs = model.importedLanguages();\n          ListSequence.fromList(impLangs).visitAll(new IVisitor<SModuleReference>() {\n            public void visit(SModuleReference lang) {\n              model.addLanguageId(IdHelper.getLanguageId(lang.getModuleId()), 0);\n            }\n          });\n          // concept ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              ((jetbrains.mps.smodel.SNode) it).setConceptId(IdHelper.getConceptId((jetbrains.mps.smodel.SNode) (SNode) SNodeOperations.getConceptDeclaration(it)));\n            }\n          });\n          // node role ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).where(new IWhereFilter<SNode>() {\n            public boolean accept(SNode it) {\n              return SNodeOperations.getParent(it) != null;\n            }\n          }).visitAll(new IVisitor<SNode>() {\n            public void visit(SNode it) {\n              SContainmentLinkId rid = IdHelper.getNodeRoleId((jetbrains.mps.smodel.SNode) (SNode) SNodeOperations.getContainingLinkDeclaration(it));\n              ((jetbrains.mps.smodel.SNode) it).setRoleInParent_byId(rid);\n            }\n          });\n          // ref role ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).translate(new ITranslator2<SNode, SReference>() {\n            public Iterable<SReference> translate(SNode it) {\n              return ((Iterable<SReference>) ((SNode) it).getReferences());\n            }\n          }).visitAll(new IVisitor<SReference>() {\n            public void visit(SReference it) {\n              SReference sref = it;\n              assert sref instanceof jetbrains.mps.smodel.SReference;\n              SReferenceLinkId rid = IdHelper.getRefRoleId((jetbrains.mps.smodel.SNode) (SNode) SLinkOperations.findLinkDeclaration(((SReference) it)));\n              ((jetbrains.mps.smodel.SReference) sref).setRoleId_direct(rid);\n            }\n          });\n          // property ids \n          ListSequence.fromList(SModelOperations.getNodes(((SModel) model), null)).visitAll(new IVisitor<SNode>() {\n            public void visit(final SNode node) {\n              Set<String> propNames = ((jetbrains.mps.smodel.SNode) node).getPropertyNames();\n              SetSequence.fromSet(propNames).visitAll(new IVisitor<String>() {\n                public void visit(String pName) {\n                  SPropertyId pid = IdHelper.getPropId((jetbrains.mps.smodel.SNode) (SNode) BehaviorReflection.invokeNonVirtual((Class<SNode>) ((Class) Object.class), ((SNode) SNodeOperations.getConceptDeclaration(node)), \"jetbrains.mps.lang.structure.structure.AbstractConceptDeclaration\", \"call_findPropertyDeclaration_1219835742593\", new Object[]{pName}));\n                  ((jetbrains.mps.smodel.SNode) node).setProperty_byId(pid, ((jetbrains.mps.smodel.SNode) node).getProperty(pName));\n                }\n              });\n            }\n          });\n\n        }\n      });\n      Sequence.fromIterable(models).visitAll(new IVisitor<DefaultSModelDescriptor>() {\n        public void visit(DefaultSModelDescriptor model) {\n          LazySModel innerModel = model.getSModelInternal();\n          if (innerModel instanceof DefaultSModel) {\n            ((DefaultSModel) innerModel).setPersistenceVersion(9);\n          }\n          model.save();\n        }\n      });\n    } catch (Throwable t) {\n      if (LOG.isEnabledFor(Level.ERROR)) {\n        LOG.error(\"User's action execute method failed. Action:\" + \"MigrateIds\", t);\n      }\n    }\n  }","commit_id":"c0e972a64c06ae8e5d3e054a03112bec82c1a620","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void addBindNode(NodeInfo nodeInfo, XFormsModelBinds.Bind.BindNode bindNode) {\n        final InstanceData instanceData = getOrCreateInstanceData(nodeInfo);\n        if (instanceData.bindNodes == null)\n            instanceData.bindNodes = Collections.singletonList(bindNode);\n        else if (instanceData.bindNodes.size() == 1) {\n            final XFormsModelBinds.Bind.BindNode oldBindNode = instanceData.bindNodes.get(0);\n            instanceData.bindNodes = new ArrayList<XFormsModelBinds.Bind.BindNode>(4); // hoping that situations where many binds point to same node are rare\n            instanceData.bindNodes.add(oldBindNode);\n            instanceData.bindNodes.add(bindNode);\n        }\n    }","id":67540,"modified_method":"public static void addBindNode(NodeInfo nodeInfo, XFormsModelBinds.Bind.BindNode bindNode) {\n        final InstanceData instanceData = getOrCreateInstanceData(nodeInfo);\n        if (instanceData.bindNodes == null)\n            instanceData.bindNodes = Collections.singletonList(bindNode);\n        else if (instanceData.bindNodes.size() == 1) {\n            final XFormsModelBinds.Bind.BindNode oldBindNode = instanceData.bindNodes.get(0);\n            instanceData.bindNodes = new ArrayList<XFormsModelBinds.Bind.BindNode>(4); // hoping that situations where many binds point to same node are rare\n            instanceData.bindNodes.add(oldBindNode);\n            instanceData.bindNodes.add(bindNode);\n        } else {\n            instanceData.bindNodes.add(bindNode);\n        }\n    }","commit_id":"9e7716aef1603f1f0bdfa77ef492d353fe606c4b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Test\n    public void testXPathAnalysis() {\n        if (Version.isPE()) { // only test this feature if we are the PE version\n            final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/form.xml\");\n            final Map<String, String> namespaces = new HashMap<String, String>();\n            namespaces.put(\"\", \"\");\n\n            final PathMapXPathDependencies dependencies = new PathMapXPathDependencies(staticState.getIndentedLogger(), staticState);\n\n            final PipelineContext pipelineContext = new PipelineContext();\n            staticState.dumpAnalysis(pipelineContext);\n\n            // == Value change to default ==================================================================================\n            dependencies.refreshStart();\n            dependencies.setModifiedPathTest(\"default\", namespaces, \"a\");\n\n            assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n            assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n            assertTrue(dependencies.requireValueUpdate(\"select1\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"group2\"));\n    //        assertTrue(dependencies.requireValueUpdate(\"group2\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"select2\"));\n            assertTrue(dependencies.requireValueUpdate(\"select2\"));\n\n\n            assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n            assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n            assertFalse(dependencies.requireValueUpdate(\"select4\"));\n\n            dependencies.refreshDone();\n\n            // == Value change to default ==================================================================================\n            dependencies.refreshStart();\n            dependencies.setModifiedPathTest(\"default\", namespaces, \"b\");\n\n            assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n            assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n            assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n            assertTrue(dependencies.requireValueUpdate(\"select2\"));\n\n\n            assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n            assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n            assertFalse(dependencies.requireValueUpdate(\"select4\"));\n\n            dependencies.refreshDone();\n\n            // == Value change to instance2 ================================================================================\n            dependencies.refreshStart();\n            dependencies.setModifiedPathTest(\"instance2\", namespaces, \"a\");\n\n            assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n            assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n            assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n            assertFalse(dependencies.requireValueUpdate(\"select2\"));\n\n\n            assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n            assertTrue(dependencies.requireValueUpdate(\"select3\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"group4\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"select4\"));\n            assertTrue(dependencies.requireValueUpdate(\"select4\"));\n\n            dependencies.refreshDone();\n\n            // == Value change to instance2 ================================================================================\n            dependencies.refreshStart();\n            dependencies.setModifiedPathTest(\"instance2\", namespaces, \"b\");\n\n            assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n            assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n            assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n            assertFalse(dependencies.requireValueUpdate(\"select2\"));\n\n\n            assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n            assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n            assertTrue(dependencies.requireValueUpdate(\"select4\"));\n\n            dependencies.refreshDone();\n\n            // == Structural change to model1 ==============================================================================\n            dependencies.refreshStart();\n            dependencies.markStructuralChangeTest(\"model1\");\n\n            assertTrue(dependencies.requireBindingUpdate(\"trigger1\"));\n            assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"select1\"));\n            assertTrue(dependencies.requireValueUpdate(\"select1\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"group2\"));\n    //        assertTrue(dependencies.requireValueUpdate(\"group2\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"select2\"));\n            assertTrue(dependencies.requireValueUpdate(\"select2\"));\n\n\n            assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n            assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n            assertFalse(dependencies.requireValueUpdate(\"select4\"));\n\n            dependencies.refreshDone();\n\n            // == Structural change to model2 ==============================================================================\n            dependencies.refreshStart();\n            dependencies.markStructuralChangeTest(\"model2\");\n\n            assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n            assertTrue(dependencies.requireBindingUpdate(\"trigger2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n            assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n    //        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n            assertFalse(dependencies.requireValueUpdate(\"select2\"));\n\n\n            assertTrue(dependencies.requireBindingUpdate(\"group3\"));\n    //        assertTrue(dependencies.requireValueUpdate(\"group3\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"select3\"));\n            assertTrue(dependencies.requireValueUpdate(\"select3\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"group4\"));\n    //        assertTrue(dependencies.requireValueUpdate(\"group4\"));\n\n            assertTrue(dependencies.requireBindingUpdate(\"select4\"));\n            assertTrue(dependencies.requireValueUpdate(\"select4\"));\n\n            dependencies.refreshDone();\n        }\n    }","id":67541,"modified_method":"@Test\n    public void testXPathAnalysis() {\n        Assume.assumeTrue(Version.isPE()); // only test this feature if we are the PE version\n\n        final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/form.xhtml\");\n        final Map<String, String> namespaces = new HashMap<String, String>();\n        namespaces.put(\"\", \"\");\n\n        final PathMapXPathDependencies dependencies = new PathMapXPathDependencies(staticState.getIndentedLogger(), staticState);\n\n        final PipelineContext pipelineContext = new PipelineContext();\n        staticState.dumpAnalysis(pipelineContext);\n\n        // == Value change to default ==================================================================================\n        dependencies.refreshStart();\n        dependencies.setModifiedPathTest(\"default\", namespaces, \"a\");\n\n        assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n        assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n        assertTrue(dependencies.requireValueUpdate(\"select1\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"group2\"));\n//        assertTrue(dependencies.requireValueUpdate(\"group2\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"select2\"));\n        assertTrue(dependencies.requireValueUpdate(\"select2\"));\n\n\n        assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n        assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n        assertFalse(dependencies.requireValueUpdate(\"select4\"));\n\n        dependencies.refreshDone();\n\n        // == Value change to default ==================================================================================\n        dependencies.refreshStart();\n        dependencies.setModifiedPathTest(\"default\", namespaces, \"b\");\n\n        assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n        assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n        assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n        assertTrue(dependencies.requireValueUpdate(\"select2\"));\n\n\n        assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n        assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n        assertFalse(dependencies.requireValueUpdate(\"select4\"));\n\n        dependencies.refreshDone();\n\n        // == Value change to instance2 ================================================================================\n        dependencies.refreshStart();\n        dependencies.setModifiedPathTest(\"instance2\", namespaces, \"a\");\n\n        assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n        assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n        assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n        assertFalse(dependencies.requireValueUpdate(\"select2\"));\n\n\n        assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n        assertTrue(dependencies.requireValueUpdate(\"select3\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"group4\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"select4\"));\n        assertTrue(dependencies.requireValueUpdate(\"select4\"));\n\n        dependencies.refreshDone();\n\n        // == Value change to instance2 ================================================================================\n        dependencies.refreshStart();\n        dependencies.setModifiedPathTest(\"instance2\", namespaces, \"b\");\n\n        assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n        assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n        assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n        assertFalse(dependencies.requireValueUpdate(\"select2\"));\n\n\n        assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n        assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n        assertTrue(dependencies.requireValueUpdate(\"select4\"));\n\n        dependencies.refreshDone();\n\n        // == Structural change to model1 ==============================================================================\n        dependencies.refreshStart();\n        dependencies.markStructuralChangeTest(\"model1\");\n\n        assertTrue(dependencies.requireBindingUpdate(\"trigger1\"));\n        assertFalse(dependencies.requireBindingUpdate(\"trigger2\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"select1\"));\n        assertTrue(dependencies.requireValueUpdate(\"select1\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"group2\"));\n//        assertTrue(dependencies.requireValueUpdate(\"group2\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"select2\"));\n        assertTrue(dependencies.requireValueUpdate(\"select2\"));\n\n\n        assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select3\"));\n        assertFalse(dependencies.requireValueUpdate(\"select3\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group4\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select4\"));\n        assertFalse(dependencies.requireValueUpdate(\"select4\"));\n\n        dependencies.refreshDone();\n\n        // == Structural change to model2 ==============================================================================\n        dependencies.refreshStart();\n        dependencies.markStructuralChangeTest(\"model2\");\n\n        assertFalse(dependencies.requireBindingUpdate(\"trigger1\"));\n        assertTrue(dependencies.requireBindingUpdate(\"trigger2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select1\"));\n        assertFalse(dependencies.requireValueUpdate(\"select1\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n//        assertFalse(dependencies.requireValueUpdate(\"group2\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"select2\"));\n        assertFalse(dependencies.requireValueUpdate(\"select2\"));\n\n\n        assertTrue(dependencies.requireBindingUpdate(\"group3\"));\n//        assertTrue(dependencies.requireValueUpdate(\"group3\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"select3\"));\n        assertTrue(dependencies.requireValueUpdate(\"select3\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"group4\"));\n//        assertTrue(dependencies.requireValueUpdate(\"group4\"));\n\n        assertTrue(dependencies.requireBindingUpdate(\"select4\"));\n        assertTrue(dependencies.requireValueUpdate(\"select4\"));\n\n        dependencies.refreshDone();\n    }","commit_id":"9e7716aef1603f1f0bdfa77ef492d353fe606c4b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Test\n    public void testVariables() {\n        if (Version.isPE()) { // only test this feature if we are the PE version\n            final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/variables.xml\");\n            final Map<String, String> namespaces = new HashMap<String, String>();\n            namespaces.put(\"\", \"\");\n\n            final PathMapXPathDependencies dependencies = new PathMapXPathDependencies(staticState.getIndentedLogger(), staticState);\n\n//            final PipelineContext pipelineContext = new PipelineContext();\n//            staticState.dumpAnalysis(pipelineContext);\n\n            // == Value change to default ==================================================================================\n            dependencies.refreshStart();\n            dependencies.setModifiedPathTest(\"default\", namespaces, \"value\");\n\n            assertFalse(dependencies.requireBindingUpdate(\"values\"));\n            assertTrue(dependencies.requireValueUpdate(\"values\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"repeat\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"value\"));\n            assertTrue(dependencies.requireValueUpdate(\"value\"));\n\n            assertFalse(dependencies.requireBindingUpdate(\"input\"));\n            assertTrue(dependencies.requireValueUpdate(\"input\"));\n            dependencies.refreshDone();\n        }\n    }","id":67542,"modified_method":"@Test\n    public void testVariables() {\n        Assume.assumeTrue(Version.isPE()); // only test this feature if we are the PE version\n\n        final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/variables.xhtml\");\n        final Map<String, String> namespaces = new HashMap<String, String>();\n        namespaces.put(\"\", \"\");\n\n        final PathMapXPathDependencies dependencies = new PathMapXPathDependencies(staticState.getIndentedLogger(), staticState);\n\n//            final PipelineContext pipelineContext = new PipelineContext();\n//            staticState.dumpAnalysis(pipelineContext);\n\n        // == Value change to default ==================================================================================\n        dependencies.refreshStart();\n        dependencies.setModifiedPathTest(\"default\", namespaces, \"value\");\n\n        assertFalse(dependencies.requireBindingUpdate(\"values\"));\n        assertTrue(dependencies.requireValueUpdate(\"values\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"repeat\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"value\"));\n        assertTrue(dependencies.requireValueUpdate(\"value\"));\n\n        assertFalse(dependencies.requireBindingUpdate(\"input\"));\n        assertTrue(dependencies.requireValueUpdate(\"input\"));\n        dependencies.refreshDone();\n    }","commit_id":"9e7716aef1603f1f0bdfa77ef492d353fe606c4b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Test\n    public void testModelVariables() {\n        if (Version.isPE()) { // only test this feature if we are the PE version\n            final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/model-variables.xml\");\n            final Map<String, String> namespaces = new HashMap<String, String>();\n            namespaces.put(\"\", \"\");\n            \n            final PathMapXPathDependencies dependencies = new PathMapXPathDependencies(staticState.getIndentedLogger(), staticState);\n\n//            final PipelineContext pipelineContext = new PipelineContext();\n//            staticState.dumpAnalysis(pipelineContext);\n\n            // == Value change to instance1 ============================================================================\n            dependencies.refreshStart();\n            dependencies.setModifiedPathTest(\"instance1\", namespaces, \"\");\n\n            // No binding update\n            assertFalse(dependencies.requireBindingUpdate(\"output1\"));\n            assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output2a\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output2b\"));\n            assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output3a\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output3b\"));\n            // TODO: group4 has @context attribute so not analyzed\n//            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4a\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4b\"));\n\n            // $mv pointing to model1 must update their value\n            assertTrue(dependencies.requireValueUpdate(\"output1\"));\n            assertTrue(dependencies.requireValueUpdate(\"output2b\"));\n            assertTrue(dependencies.requireValueUpdate(\"output3a\"));\n            assertTrue(dependencies.requireValueUpdate(\"output3b\"));\n            assertTrue(dependencies.requireValueUpdate(\"output4a\"));\n            assertTrue(dependencies.requireValueUpdate(\"output4b\"));\n            assertTrue(dependencies.requireValueUpdate(\"output5a\"));\n\n            // $mv pointing to model2 must not update\n            assertFalse(dependencies.requireValueUpdate(\"output2a\"));\n            assertFalse(dependencies.requireValueUpdate(\"output3c\"));\n            assertFalse(dependencies.requireValueUpdate(\"output4c\"));\n            assertFalse(dependencies.requireValueUpdate(\"output5b\"));\n\n            dependencies.refreshDone();\n            \n            // == Value change to instance2 ============================================================================\n            dependencies.refreshStart();\n            dependencies.setModifiedPathTest(\"instance2\", namespaces, \"\");\n\n            // No binding update\n            assertFalse(dependencies.requireBindingUpdate(\"output1\"));\n            assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output2a\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output2b\"));\n            assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output3a\"));\n            assertFalse(dependencies.requireBindingUpdate(\"output3b\"));\n            // TODO: group4 has @context attribute so not analyzed\n//            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4a\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4b\"));\n\n            // $mv pointing to model1 must not update their value\n            assertFalse(dependencies.requireValueUpdate(\"output1\"));\n            assertFalse(dependencies.requireValueUpdate(\"output2b\"));\n            assertFalse(dependencies.requireValueUpdate(\"output3a\"));\n            assertFalse(dependencies.requireValueUpdate(\"output3b\"));\n            assertFalse(dependencies.requireValueUpdate(\"output4a\"));\n            assertFalse(dependencies.requireValueUpdate(\"output4b\"));\n            assertFalse(dependencies.requireValueUpdate(\"output5a\"));\n\n            // $mv pointing to model2 must update\n            assertTrue(dependencies.requireValueUpdate(\"output2a\"));\n            assertTrue(dependencies.requireValueUpdate(\"output3c\"));\n            assertTrue(dependencies.requireValueUpdate(\"output4c\"));\n            assertTrue(dependencies.requireValueUpdate(\"output5b\"));\n\n            dependencies.refreshDone();\n        }\n    }","id":67543,"modified_method":"@Test\n    public void testModelVariables() {\n        Assume.assumeTrue(Version.isPE()); // only test this feature if we are the PE version\n\n        final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/model-variables.xhtml\");\n        final Map<String, String> namespaces = new HashMap<String, String>();\n        namespaces.put(\"\", \"\");\n\n        final PathMapXPathDependencies dependencies = new PathMapXPathDependencies(staticState.getIndentedLogger(), staticState);\n\n//            final PipelineContext pipelineContext = new PipelineContext();\n//            staticState.dumpAnalysis(pipelineContext);\n\n        // == Value change to instance1 ============================================================================\n        dependencies.refreshStart();\n        dependencies.setModifiedPathTest(\"instance1\", namespaces, \"\");\n\n        // No binding update\n        assertFalse(dependencies.requireBindingUpdate(\"output1\"));\n        assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output2a\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output2b\"));\n        assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output3a\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output3b\"));\n        // TODO: group4 has @context attribute so not analyzed\n//            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4a\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4b\"));\n\n        // $mv pointing to model1 must update their value\n        assertTrue(dependencies.requireValueUpdate(\"output1\"));\n        assertTrue(dependencies.requireValueUpdate(\"output2b\"));\n        assertTrue(dependencies.requireValueUpdate(\"output3a\"));\n        assertTrue(dependencies.requireValueUpdate(\"output3b\"));\n        assertTrue(dependencies.requireValueUpdate(\"output4a\"));\n        assertTrue(dependencies.requireValueUpdate(\"output4b\"));\n        assertTrue(dependencies.requireValueUpdate(\"output5a\"));\n\n        // $mv pointing to model2 must not update\n        assertFalse(dependencies.requireValueUpdate(\"output2a\"));\n        assertFalse(dependencies.requireValueUpdate(\"output3c\"));\n        assertFalse(dependencies.requireValueUpdate(\"output4c\"));\n        assertFalse(dependencies.requireValueUpdate(\"output5b\"));\n\n        dependencies.refreshDone();\n\n        // == Value change to instance2 ============================================================================\n        dependencies.refreshStart();\n        dependencies.setModifiedPathTest(\"instance2\", namespaces, \"\");\n\n        // No binding update\n        assertFalse(dependencies.requireBindingUpdate(\"output1\"));\n        assertFalse(dependencies.requireBindingUpdate(\"group2\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output2a\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output2b\"));\n        assertFalse(dependencies.requireBindingUpdate(\"group3\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output3a\"));\n        assertFalse(dependencies.requireBindingUpdate(\"output3b\"));\n        // TODO: group4 has @context attribute so not analyzed\n//            assertFalse(dependencies.requireBindingUpdate(\"group4\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4a\"));\n//            assertFalse(dependencies.requireBindingUpdate(\"output4b\"));\n\n        // $mv pointing to model1 must not update their value\n        assertFalse(dependencies.requireValueUpdate(\"output1\"));\n        assertFalse(dependencies.requireValueUpdate(\"output2b\"));\n        assertFalse(dependencies.requireValueUpdate(\"output3a\"));\n        assertFalse(dependencies.requireValueUpdate(\"output3b\"));\n        assertFalse(dependencies.requireValueUpdate(\"output4a\"));\n        assertFalse(dependencies.requireValueUpdate(\"output4b\"));\n        assertFalse(dependencies.requireValueUpdate(\"output5a\"));\n\n        // $mv pointing to model2 must update\n        assertTrue(dependencies.requireValueUpdate(\"output2a\"));\n        assertTrue(dependencies.requireValueUpdate(\"output3c\"));\n        assertTrue(dependencies.requireValueUpdate(\"output4c\"));\n        assertTrue(dependencies.requireValueUpdate(\"output5b\"));\n\n        dependencies.refreshDone();\n    }","commit_id":"9e7716aef1603f1f0bdfa77ef492d353fe606c4b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Test\n    public void testBindAnalysis() {\n        if (Version.isPE()) { // only test this feature if we are the PE version\n            final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/binds.xml\");\n\n//            final PipelineContext pipelineContext = new PipelineContext();\n//            staticState.dumpAnalysis(pipelineContext);\n\n            // TODO: test computedBindExpressionsInstances and validationBindInstances\n            {\n                final Model model1 = staticState.getModel(\"model1\");\n                assertTrue(model1.figuredAllBindRefAnalysis());\n\n                assertTrue(model1.bindInstances().contains(\"instance11\"));\n                assertTrue(model1.bindInstances().contains(\"instance12\"));\n                assertTrue(model1.bindInstances().contains(\"instance13\"));\n            }\n            {\n                final Model model2 = staticState.getModel(\"model2\");\n                assertTrue(model2.figuredAllBindRefAnalysis());\n\n                assertFalse(model2.bindInstances().contains(\"instance21\"));\n            }\n            {\n                final Model model3 = staticState.getModel(\"model3\");\n                assertTrue(model3.figuredAllBindRefAnalysis());\n\n                assertFalse(model3.bindInstances().contains(\"instance31\"));\n                assertTrue(model3.bindInstances().contains(\"instance32\"));\n            }\n            {\n                final Model model4 = staticState.getModel(\"model4\");\n                assertTrue(model4.figuredAllBindRefAnalysis());\n\n                assertTrue(model4.bindInstances().contains(\"instance41\"));\n                assertFalse(model4.bindInstances().contains(\"instance42\"));\n            }\n            {\n                final Model model5 = staticState.getModel(\"model5\");\n                assertTrue(model5.figuredAllBindRefAnalysis());\n\n                assertTrue(model5.validationBindInstances().contains(\"instance51\"));\n                assertFalse(model5.computedBindExpressionsInstances().contains(\"instance51\"));\n\n                assertFalse(model5.validationBindInstances().contains(\"instance52\"));\n                assertTrue(model5.computedBindExpressionsInstances().contains(\"instance52\"));\n            }\n        }\n    }","id":67544,"modified_method":"@Test\n    public void testBindAnalysis() {\n        Assume.assumeTrue(Version.isPE()); // only test this feature if we are the PE version\n\n        final XFormsStaticState staticState = getStaticState(\"oxf:/org/orbeon/oxf/xforms/analysis/binds.xhtml\");\n\n//            final PipelineContext pipelineContext = new PipelineContext();\n//            staticState.dumpAnalysis(pipelineContext);\n\n        // TODO: test computedBindExpressionsInstances and validationBindInstances\n        {\n            final Model model1 = staticState.getModel(\"model1\");\n            assertTrue(model1.figuredAllBindRefAnalysis());\n\n            assertTrue(model1.bindInstances().contains(\"instance11\"));\n            assertTrue(model1.bindInstances().contains(\"instance12\"));\n            assertTrue(model1.bindInstances().contains(\"instance13\"));\n        }\n        {\n            final Model model2 = staticState.getModel(\"model2\");\n            assertTrue(model2.figuredAllBindRefAnalysis());\n\n            assertFalse(model2.bindInstances().contains(\"instance21\"));\n        }\n        {\n            final Model model3 = staticState.getModel(\"model3\");\n            assertTrue(model3.figuredAllBindRefAnalysis());\n\n            assertFalse(model3.bindInstances().contains(\"instance31\"));\n            assertTrue(model3.bindInstances().contains(\"instance32\"));\n        }\n        {\n            final Model model4 = staticState.getModel(\"model4\");\n            assertTrue(model4.figuredAllBindRefAnalysis());\n\n            assertTrue(model4.bindInstances().contains(\"instance41\"));\n            assertFalse(model4.bindInstances().contains(\"instance42\"));\n        }\n        {\n            final Model model5 = staticState.getModel(\"model5\");\n            assertTrue(model5.figuredAllBindRefAnalysis());\n\n            assertTrue(model5.validationBindInstances().contains(\"instance51\"));\n            assertFalse(model5.computedBindExpressionsInstances().contains(\"instance51\"));\n\n            assertFalse(model5.validationBindInstances().contains(\"instance52\"));\n            assertTrue(model5.computedBindExpressionsInstances().contains(\"instance52\"));\n        }\n    }","commit_id":"9e7716aef1603f1f0bdfa77ef492d353fe606c4b","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n    public SomeResponse doSomething(SomeRequest in) {\n        SomeResponse response = new SomeResponse();\n        if (in.getId().equals(\"1234567890\")) {\n            response.setTransactionId(\"aaaaaaaaaaxxx\"); // invalid transaction id\n        } else {\n            response.setTransactionId(\"aaaaaaaaaa\");\n        }\n        \n        return response;\n    }","id":67545,"modified_method":"@Override\n    public SomeResponse doSomething(SomeRequest in) throws DoSomethingFault {\n        SomeResponse response = new SomeResponse();\n        if (in.getId().equals(\"1234567890\")) {\n            response.setTransactionId(\"aaaaaaaaaaxxx\"); // invalid transaction id\n        } else if (in.getId().equals(\"9999999999\")) {\n            SomeFault someFault = new SomeFault();\n            someFault.setErrorCode(\"1234\");\n            throw new DoSomethingFault(\"Fault\", someFault);\n        } else if (in.getId().equals(\"8888888888\")) {\n            SomeFault someFault = new SomeFault();\n            someFault.setErrorCode(\"1\");\n            throw new DoSomethingFault(\"Fault\", someFault);\n        } else {\n            response.setTransactionId(\"aaaaaaaaaa\");\n        }\n        \n        return response;\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testSchemaValidation() throws Exception {\n        SchemaValidation validation = createService(Boolean.TRUE);\n        ComplexStruct complexStruct = new ComplexStruct();\n        complexStruct.setElem1(\"one\");\n        // Don't initialize a member of the structure.  \n        // Client side validation should throw an exception.\n        // complexStruct.setElem2(\"two\");\n        complexStruct.setElem3(3);\n        try {\n            /*boolean result =*/\n            validation.setComplexStruct(complexStruct);\n            fail(\"Set ComplexStruct should have thrown ProtocolException\");\n        } catch (WebServiceException e) {\n            String expected = \"'{\\\"http://apache.org/schema_validation/types\\\":elem2}' is expected.\";\n            assertTrue(e.getMessage(), e.getMessage().indexOf(expected) != -1);\n        }\n\n        OccuringStruct occuringStruct = new OccuringStruct();\n        // Populate the list in the wrong order.\n        // Client side validation should throw an exception.\n        List<Serializable> floatIntStringList = occuringStruct.getVarFloatAndVarIntAndVarString();\n        floatIntStringList.add(new Integer(42));\n        floatIntStringList.add(new Float(4.2f));\n        floatIntStringList.add(\"Goofus and Gallant\");\n        try {\n            /*boolean result =*/\n            validation.setOccuringStruct(occuringStruct);\n            fail(\"Set OccuringStruct should have thrown ProtocolException\");\n        } catch (WebServiceException e) {\n            String expected = \"'{\\\"http://apache.org/schema_validation/types\\\":varFloat}' is expected.\";\n            assertTrue(e.getMessage().indexOf(expected) != -1);\n        }\n        \n        validation = createService(Boolean.FALSE);\n\n        try {\n            // The server will attempt to return an invalid ComplexStruct\n            // When validation is disabled on the server side, we'll get the\n            // exception while unmarshalling the invalid response.\n            /*complexStruct =*/\n            validation.getComplexStruct(\"Hello\");\n            fail(\"Get ComplexStruct should have thrown ProtocolException\");\n        } catch (WebServiceException e) {\n            String expected = \"'{\\\"http://apache.org/schema_validation/types\\\":elem2}' is expected.\";\n            assertTrue(\"Found message \" + e.getMessage(), \n                       e.getMessage().indexOf(expected) != -1);\n        }\n\n        validation = createService(Boolean.TRUE);\n        \n        try {\n            // The server will attempt to return an invalid OccuringStruct\n            // When validation is disabled on the server side, we'll get the\n            // exception while unmarshalling the invalid response.\n            /*occuringStruct =*/\n            validation.getOccuringStruct(\"World\");\n            fail(\"Get OccuringStruct should have thrown ProtocolException\");\n        } catch (WebServiceException e) {\n            String expected = \"'{\\\"http://apache.org/schema_validation/types\\\":varFloat}' is expected.\";\n            assertTrue(e.getMessage().indexOf(expected) != -1);\n        }\n    }","id":67546,"modified_method":"@Test\n    public void testSchemaValidationServer() throws Exception {\n        SchemaValidation validation = createService(Boolean.FALSE, \"SoapPortValidate\");\n        runSchemaValidationTest(validation);\n        ((java.io.Closeable)validation).close();\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"private void assertFailedRequestValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        SomeResponse response = execute(service, \"1111111111\");\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaa\");\n        \n        try {\n            execute(service, \"1234567890aaa\");\n            fail(\"should catch marshall exception as the invalid outgoing message per schema\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Marshalling Error\"));\n            assertTrue(e.getMessage().contains(\"is not facet-valid with respect to pattern\"));\n        }\n    }","id":67547,"modified_method":"private void assertFailedRequestValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        SomeResponse response = execute(service, \"1111111111\");\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaa\");\n        \n        try {\n            execute(service, \"1234567890aaa\");\n            fail(\"should catch marshall exception as the invalid outgoing message per schema\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Marshalling Error\"));\n            assertTrue(e.getMessage().contains(\"is not facet-valid with respect to pattern\"));\n        }\n        ((java.io.Closeable)service).close();\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"private SchemaValidation createService(Object validationConfig) throws Exception {\n        URL wsdl = getClass().getResource(\"/wsdl/schema_validation.wsdl\");\n        assertNotNull(wsdl);\n\n        SchemaValidationService service = new SchemaValidationService(wsdl, serviceName);\n        assertNotNull(service);\n\n        SchemaValidation validation = service.getPort(portName, SchemaValidation.class);\n        updateAddressPort(validation, PORT);\n        ((BindingProvider)validation).getRequestContext().put(Message.SCHEMA_VALIDATION_ENABLED, validationConfig);\n        ((BindingProvider)validation).getResponseContext().put(Message.SCHEMA_VALIDATION_ENABLED, validationConfig);\n        \n        return validation;\n    }","id":67548,"modified_method":"private SchemaValidation createService(Object validationConfig) throws Exception {\n        return createService(validationConfig, \"SoapPort\");\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"private void assertIgnoredRequestValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        // this is an invalid request but validation is turned off.\n        SomeResponse response = execute(service, \"1234567890aaaa\");\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaa\");\n    }","id":67549,"modified_method":"private void assertIgnoredRequestValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        // this is an invalid request but validation is turned off.\n        SomeResponse response = execute(service, \"1234567890aaaa\");\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaa\");\n        ((java.io.Closeable)service).close();\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"private void assertFailureResponseValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        SomeResponse response = execute(service, \"1111111111\"); // valid request\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaa\");\n        \n        try {\n            execute(service, \"1234567890\"); // valid request, but will result in invalid response\n            fail(\"should catch marshall exception as the invalid incoming message per schema\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Unmarshalling Error\"));\n            assertTrue(e.getMessage().contains(\"is not facet-valid with respect to pattern\"));\n        }\n    }","id":67550,"modified_method":"private void assertFailureResponseValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        SomeResponse response = execute(service, \"1111111111\"); // valid request\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaa\");\n        \n        try {\n            execute(service, \"1234567890\"); // valid request, but will result in invalid response\n            fail(\"should catch marshall exception as the invalid incoming message per schema\");\n        } catch (Exception e) {\n            assertTrue(e.getMessage().contains(\"Unmarshalling Error\"));\n            assertTrue(e.getMessage().contains(\"is not facet-valid with respect to pattern\"));\n        }\n        \n        ((java.io.Closeable)service).close();\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"private void assertIgnoredResponseValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        // the request will result in invalid response but validation is turned off\n        SomeResponse response = execute(service, \"1234567890\");\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaaxxx\");\n    }","id":67551,"modified_method":"private void assertIgnoredResponseValidation(Object validationConfig) throws Exception {\n        SchemaValidation service = createService(validationConfig);\n        \n        // the request will result in invalid response but validation is turned off\n        SomeResponse response = execute(service, \"1234567890\");\n        assertEquals(response.getTransactionId(), \"aaaaaaaaaaxxx\");\n        ((java.io.Closeable)service).close();\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        Object implementor = new SchemaValidationImpl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","id":67552,"modified_method":"protected void run() {\n        Object implementor = new SchemaValidationImpl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext\";\n        eps.add(Endpoint.publish(address + \"/SoapPort\", implementor));\n        eps.add(Endpoint.publish(address + \"/SoapPortValidate\", new ValidatingSchemaValidationImpl()));\n        eps.add(Endpoint.publish(address + \"/PProvider\", new PayloadProvider()));\n        eps.add(Endpoint.publish(address + \"/MProvider\", new MessageProvider()));\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"public void handleMessage(Message message) throws Fault {\n        Fault f = (Fault)message.getContent(Exception.class);\n        if (f == null) {\n            return;\n        }\n        try {\n            if (f.getCause().getClass().equals(SOAPFaultException.class)) {\n                SOAPFaultException sf = (SOAPFaultException) (f.getCause());\n                if (f instanceof SoapFault) {\n                    for (Iterator<QName> it = CastUtils.cast(sf.getFault().getFaultSubcodes()); it.hasNext();) {\n                        ((SoapFault) f).addSubCode(it.next());    \n                    }\n                }\n                if (sf.getFault().getFaultReasonLocales().hasNext()) {\n                    Locale lang = (Locale) sf.getFault()\n                           .getFaultReasonLocales().next();\n                    String convertedLang = lang.getLanguage();\n                    String country = lang.getCountry();\n                    if (country.length() > 0) {\n                        convertedLang = convertedLang + '_' + country;\n                    }\n                    f.setLang(convertedLang);\n                }\n                message.setContent(Exception.class, f);\n            }\n        } catch (Exception e) {\n          // do nothing;\n        }\n        Throwable cause = f.getCause();\n        WebFault fault = null;\n        if (cause != null) {\n            fault = getWebFaultAnnotation(cause.getClass());\n        }\n        if (cause instanceof Exception && fault != null) {\n            Exception ex = (Exception)cause;\n            Object faultInfo = null;\n            try {\n                Method method = cause.getClass().getMethod(\"getFaultInfo\", new Class[0]);\n                faultInfo = method.invoke(cause, new Object[0]);\n            } catch (NoSuchMethodException e) {\n                faultInfo = createFaultInfoBean(fault, cause);\n                \n            } catch (InvocationTargetException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVOCATION_TARGET_EXC\", BUNDLE), e);\n            } catch (IllegalAccessException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"COULD_NOT_INVOKE\", BUNDLE), e);\n            } catch (IllegalArgumentException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"COULD_NOT_INVOKE\", BUNDLE), e);\n            }\n            Service service = message.getExchange().get(Service.class);\n\n            try {\n                DataWriter<XMLStreamWriter> writer \n                    = service.getDataBinding().createWriter(XMLStreamWriter.class);\n    \n                OperationInfo op = message.getExchange().get(BindingOperationInfo.class).getOperationInfo();\n                QName faultName = getFaultName(fault, cause.getClass(), op);\n                MessagePartInfo part = getFaultMessagePart(faultName, op);\n                if (f.hasDetails()) {\n                    writer.write(faultInfo, part, new W3CDOMStreamWriter(f.getDetail()));\n                } else {\n                    writer.write(faultInfo, part, new W3CDOMStreamWriter(f.getOrCreateDetail()));\n                    if (!f.getDetail().hasChildNodes()) {\n                        f.setDetail(null);\n                    }\n                }\n    \n                f.setMessage(ex.getMessage());\n            } catch (Exception nex) {\n                //if exception occurs while writing a fault, we'll just let things continue\n                //and let the rest of the chain try handling it as is.\n                LOG.log(Level.WARNING, \"EXCEPTION_WHILE_WRITING_FAULT\", nex);\n            }\n        } else {\n            FaultMode mode = message.get(FaultMode.class);\n            if (mode == FaultMode.CHECKED_APPLICATION_FAULT) {\n                //only convert checked exceptions with this\n                //otherwise delegate down to the normal protocol specific stuff\n                super.handleMessage(message);\n            }\n        }\n    }","id":67553,"modified_method":"public void handleMessage(Message message) throws Fault {\n        Fault f = (Fault)message.getContent(Exception.class);\n        if (f == null) {\n            return;\n        }\n        try {\n            if (f.getCause().getClass().equals(SOAPFaultException.class)) {\n                SOAPFaultException sf = (SOAPFaultException) (f.getCause());\n                if (f instanceof SoapFault) {\n                    for (Iterator<QName> it = CastUtils.cast(sf.getFault().getFaultSubcodes()); it.hasNext();) {\n                        ((SoapFault) f).addSubCode(it.next());    \n                    }\n                }\n                if (sf.getFault().getFaultReasonLocales().hasNext()) {\n                    Locale lang = (Locale) sf.getFault()\n                           .getFaultReasonLocales().next();\n                    String convertedLang = lang.getLanguage();\n                    String country = lang.getCountry();\n                    if (country.length() > 0) {\n                        convertedLang = convertedLang + '_' + country;\n                    }\n                    f.setLang(convertedLang);\n                }\n                message.setContent(Exception.class, f);\n            }\n        } catch (Exception e) {\n          // do nothing;\n        }\n        Throwable cause = f.getCause();\n        WebFault fault = null;\n        if (cause != null) {\n            fault = getWebFaultAnnotation(cause.getClass());\n        }\n        if (cause instanceof Exception && fault != null) {\n            Exception ex = (Exception)cause;\n            Object faultInfo = null;\n            try {\n                Method method = cause.getClass().getMethod(\"getFaultInfo\", new Class[0]);\n                faultInfo = method.invoke(cause, new Object[0]);\n            } catch (NoSuchMethodException e) {\n                faultInfo = createFaultInfoBean(fault, cause);\n                \n            } catch (InvocationTargetException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"INVOCATION_TARGET_EXC\", BUNDLE), e);\n            } catch (IllegalAccessException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"COULD_NOT_INVOKE\", BUNDLE), e);\n            } catch (IllegalArgumentException e) {\n                throw new Fault(new org.apache.cxf.common.i18n.Message(\"COULD_NOT_INVOKE\", BUNDLE), e);\n            }\n            Service service = message.getExchange().get(Service.class);\n\n            try {\n                DataWriter<XMLStreamWriter> writer \n                    = service.getDataBinding().createWriter(XMLStreamWriter.class);\n                \n                if (ServiceUtils.isSchemaValidationEnabled(SchemaValidationType.OUT, message)) {\n                    Schema schema = EndpointReferenceUtils.getSchema(service.getServiceInfos().get(0),\n                                                                     message.getExchange().getBus());\n                    writer.setSchema(schema);\n                }\n\n                OperationInfo op = message.getExchange().get(BindingOperationInfo.class).getOperationInfo();\n                QName faultName = getFaultName(fault, cause.getClass(), op);\n                MessagePartInfo part = getFaultMessagePart(faultName, op);\n                if (f.hasDetails()) {\n                    writer.write(faultInfo, part, new W3CDOMStreamWriter(f.getDetail()));\n                } else {\n                    writer.write(faultInfo, part, new W3CDOMStreamWriter(f.getOrCreateDetail()));\n                    if (!f.getDetail().hasChildNodes()) {\n                        f.setDetail(null);\n                    }\n                }\n    \n                f.setMessage(ex.getMessage());\n            } catch (Exception nex) {\n                if (nex instanceof Fault) {\n                    message.setContent(Exception.class, nex);\n                    super.handleMessage(message);\n                } else {\n                    //if exception occurs while writing a fault, we'll just let things continue\n                    //and let the rest of the chain try handling it as is.\n                    LOG.log(Level.WARNING, \"EXCEPTION_WHILE_WRITING_FAULT\", nex);\n                }\n            }\n        } else {\n            FaultMode mode = message.get(FaultMode.class);\n            if (mode == FaultMode.CHECKED_APPLICATION_FAULT) {\n                //only convert checked exceptions with this\n                //otherwise delegate down to the normal protocol specific stuff\n                super.handleMessage(message);\n            }\n        }\n    }","commit_id":"0400b946bcd06736b6d951ec61990d6b4967367e","url":"https://github.com/apache/cxf"},{"original_method":"public Greeter createGreeter(EndpointReferenceType target) throws Exception {\n        ServiceImpl serviceImpl = \n            ServiceDelegateAccessor.get(new SOAPService(getWSDLURL(), SERVICE_NAME));\n        Greeter g = serviceImpl.getPort(target, Greeter.class);\n        updateAddressPort(g, PORT);\n        return g;\n    }","id":67554,"modified_method":"public Greeter createGreeter(EndpointReferenceType target) throws Exception {\n        ServiceImpl serviceImpl = \n            ServiceDelegateAccessor.get(new SOAPService(getWSDLURL(), SERVICE_NAME));\n        Greeter g = serviceImpl.getPort(target, Greeter.class);\n        updateAddressPort(g, getPort());\n        return g;\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"@AfterClass\n    public static void shutdownBus() throws Exception {\n        staticBus.shutdown(true);\n    }","id":67555,"modified_method":"@AfterClass\n    public static void shutdownBus() throws Exception {\n        staticBus.shutdown(true);\n        staticBus = null;\n        messageIDs.clear();\n        mapVerifier = null;\n        headerVerifier = null;\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"@After\n    public void tearDown() throws Exception {\n        Interceptor<?>[] interceptors = {mapVerifier, headerVerifier };\n        removeInterceptors(staticBus.getInInterceptors(), interceptors);\n        removeInterceptors(staticBus.getOutInterceptors(), interceptors);\n        removeInterceptors(staticBus.getOutFaultInterceptors(), interceptors);\n        removeInterceptors(staticBus.getInFaultInterceptors(), interceptors);\n        \n        mapVerifier = null;\n        headerVerifier = null;\n        verified = null;\n        messageIDs.clear();\n    }","id":67556,"modified_method":"@After\n    public void tearDown() throws Exception {\n        Interceptor<?>[] interceptors = {mapVerifier, headerVerifier };\n        removeInterceptors(staticBus.getInInterceptors(), interceptors);\n        removeInterceptors(staticBus.getOutInterceptors(), interceptors);\n        removeInterceptors(staticBus.getOutFaultInterceptors(), interceptors);\n        removeInterceptors(staticBus.getInFaultInterceptors(), interceptors);\n\n        if (greeter instanceof Closeable) {\n            ((Closeable)greeter).close();\n        }\n        greeter = null;\n\n        mapVerifier = null;\n        headerVerifier = null;\n        verified = null;\n        messageIDs.clear();\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\"server did not launch correctly\", launchServer(Server.class, true));\n    }","id":67557,"modified_method":"@BeforeClass\n    public static void startServers() throws Exception {\n        assertTrue(\"server did not launch correctly\", launchServer(Server.class, true));\n        createStaticBus();\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testGet() {\n        // Create the client\n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setAddress(\"http://localhost:\" + PORT + \"/jaxws/addmex\");\n        proxyFac.getFeatures().add(new LoggingFeature());\n        MetadataExchange exc = proxyFac.create(MetadataExchange.class);\n        Metadata metadata = exc.get2004();\n        assertNotNull(metadata);\n        assertEquals(2, metadata.getMetadataSection().size());\n        \n\n        assertEquals(\"http://schemas.xmlsoap.org/wsdl/\",\n                     metadata.getMetadataSection().get(0).getDialect());\n        assertEquals(\"http://apache.org/cxf/systest/ws/addr_feature/\",\n                     metadata.getMetadataSection().get(0).getIdentifier());\n        assertEquals(\"http://www.w3.org/2001/XMLSchema\", \n                     metadata.getMetadataSection().get(1).getDialect());\n        \n        GetMetadata body = new GetMetadata();\n        body.setDialect(\"http://www.w3.org/2001/XMLSchema\");\n        metadata = exc.getMetadata(body);\n        assertEquals(1, metadata.getMetadataSection().size());\n        assertEquals(\"http://www.w3.org/2001/XMLSchema\", \n                     metadata.getMetadataSection().get(0).getDialect());\n    }","id":67558,"modified_method":"@Test\n    public void testGet() {\n        // Create the client\n        JaxWsProxyFactoryBean proxyFac = new JaxWsProxyFactoryBean();\n        proxyFac.setBus(getStaticBus());\n        proxyFac.setAddress(\"http://localhost:\" + PORT + \"/jaxws/addmex\");\n        proxyFac.getFeatures().add(new LoggingFeature());\n        MetadataExchange exc = proxyFac.create(MetadataExchange.class);\n        Metadata metadata = exc.get2004();\n        assertNotNull(metadata);\n        assertEquals(2, metadata.getMetadataSection().size());\n        \n\n        assertEquals(\"http://schemas.xmlsoap.org/wsdl/\",\n                     metadata.getMetadataSection().get(0).getDialect());\n        assertEquals(\"http://apache.org/cxf/systest/ws/addr_feature/\",\n                     metadata.getMetadataSection().get(0).getIdentifier());\n        assertEquals(\"http://www.w3.org/2001/XMLSchema\", \n                     metadata.getMetadataSection().get(1).getDialect());\n        \n        GetMetadata body = new GetMetadata();\n        body.setDialect(\"http://www.w3.org/2001/XMLSchema\");\n        metadata = exc.getMetadata(body);\n        assertEquals(1, metadata.getMetadataSection().size());\n        assertEquals(\"http://www.w3.org/2001/XMLSchema\", \n                     metadata.getMetadataSection().get(0).getDialect());\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/AddNumberImplPort\";\n        EndpointImpl ep = new EndpointImpl(implementor);\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n        \n        ep = new EndpointImpl(new AddNumberImplNoAddr());\n        ep.publish(address + \"-noaddr\");\n        \n    }","id":67559,"modified_method":"protected void run() {\n        setBus(BusFactory.getDefaultBus());\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/AddNumberImplPort\";\n        ep1 = new EndpointImpl(implementor);\n        ep1.getFeatures().add(new WSAddressingFeature());\n        ep1.publish(address);\n        \n        ep2 = new EndpointImpl(new AddNumberImplNoAddr());\n        ep2.publish(address + \"-noaddr\");\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {    \n        Object implementor = new AddNumberReg();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        EndpointImpl ep;\n        ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n\n        implementor = new AddNumberNonAnon();\n        address = \"http://localhost:\" + PORT + \"/jaxws/addNonAnon\";\n        \n        ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n\n        implementor = new AddNumberOnlyAnon();\n        address = \"http://localhost:\" + PORT + \"/jaxws/addAnon\";\n        \n        ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n    }","id":67560,"modified_method":"protected void run()  {    \n        Object implementor = new AddNumberReg();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        EndpointImpl ep;\n        ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n        eps.add(ep);\n\n        implementor = new AddNumberNonAnon();\n        address = \"http://localhost:\" + PORT + \"/jaxws/addNonAnon\";\n        \n        ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n        eps.add(ep);\n\n        implementor = new AddNumberOnlyAnon();\n        address = \"http://localhost:\" + PORT + \"/jaxws/addAnon\";\n        \n        ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n        eps.add(ep);\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/addmex\";\n        \n        EndpointImpl ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.publish(address);\n    }","id":67561,"modified_method":"protected void run() {\n        setBus(BusFactory.getDefaultBus());\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/addmex\";\n        \n        ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.publish(address);\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        \n        EndpointImpl ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.publish(address);\n        \n        Endpoint.publish(address + \"-provider\", new AddNumberProvider());\n        Endpoint.publish(address + \"-providernows\", new AddNumberProviderNoWsdl());\n    }","id":67562,"modified_method":"protected void run() {\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        \n        EndpointImpl ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n\n        ep.publish(address);\n        eps.add(ep);\n        \n        eps.add(Endpoint.publish(address + \"-provider\", new AddNumberProvider()));\n        eps.add(Endpoint.publish(address + \"-providernows\", new AddNumberProviderNoWsdl()));\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {    \n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        //Endpoint.publish(address, implementor);\n\n        EndpointImpl ep = (EndpointImpl) Endpoint.create(implementor);\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n    }","id":67563,"modified_method":"protected void run()  { \n        setBus(BusFactory.getDefaultBus());\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        //Endpoint.publish(address, implementor);\n\n        ep = (EndpointImpl) Endpoint.create(implementor);\n        ep.getFeatures().add(new WSAddressingFeature());\n        ep.publish(address);\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        \n        EndpointImpl ep = new EndpointImpl(BusFactory.getThreadDefaultBus(), \n                                           implementor, \n                                           null, \n                                           getWsdl());\n        ep.publish(address);\n    }","id":67564,"modified_method":"protected void run() {\n        Object implementor = new AddNumberImpl();\n        String address = \"http://localhost:\" + PORT + \"/jaxws/add\";\n        setBus(BusFactory.getThreadDefaultBus());\n        ep = new EndpointImpl(getBus(), \n                              implementor, \n                              null, \n                              getWsdl());\n        ep.publish(address);\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        SpringBusFactory factory = new SpringBusFactory();\n        Bus bus = factory.createBus(\"org/apache/cxf/systest/ws/addressing/server.xml\");\n        BusFactory.setDefaultBus(bus);\n        setBus(bus);\n\n        addVerifiers();\n\n        try {\n            AbstractGreeterImpl implementor = (AbstractGreeterImpl)cls.newInstance();\n            implementor.verificationCache = this;\n            Endpoint.publish(address, implementor);\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }","id":67565,"modified_method":"protected void run() {\n        SpringBusFactory factory = new SpringBusFactory();\n        Bus bus = factory.createBus(\"org/apache/cxf/systest/ws/addressing/server.xml\");\n        BusFactory.setDefaultBus(bus);\n        setBus(bus);\n\n        addVerifiers();\n\n        try {\n            AbstractGreeterImpl implementor = (AbstractGreeterImpl)cls.newInstance();\n            implementor.verificationCache = this;\n            ep = Endpoint.publish(address, implementor);\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"@Test\n    public void testUsingAddressing() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n\n        bus = bf.createBus(\"org/apache/cxf/systest/ws/policy/addr-inline-policy-old.xml\");\n\n        BusFactory.setDefaultBus(bus);\n\n        URL wsdlURL = new URL(WSDL_ADDRESS);\n\n        AsyncMessagingService ams = new AsyncMessagingService(wsdlURL, ENDPOINT_NAME);\n        AsyncMessaging am = ams.getAsyncMessagingImplPort();\n\n        ConnectionHelper.setKeepAliveConnection(am, true);\n        testInterceptors(bus);\n\n        // oneway\n        am.deliver(\"This is a test\");\n        am.deliver(\"This is another test\");\n    }","id":67566,"modified_method":"@Test\n    public void testUsingAddressing() throws Exception {\n        SpringBusFactory bf = new SpringBusFactory();\n\n        Bus bus = bf.createBus(\"org/apache/cxf/systest/ws/policy/addr-inline-policy-old.xml\");\n\n        BusFactory.setDefaultBus(bus);\n\n        URL wsdlURL = new URL(WSDL_ADDRESS);\n\n        AsyncMessagingService ams = new AsyncMessagingService(wsdlURL, ENDPOINT_NAME);\n        AsyncMessaging am = ams.getAsyncMessagingImplPort();\n\n        ConnectionHelper.setKeepAliveConnection(am, true);\n        testInterceptors(bus);\n\n        // oneway\n        am.deliver(\"This is a test\");\n        am.deliver(\"This is another test\");\n        bus.shutdown(true);\n    }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n            SpringBusFactory bf = new SpringBusFactory();\n            Bus bus = bf.createBus(\"org/apache/cxf/systest/ws/addr_wsdl/jaxwsmm/server.xml\");\n\n            JaxWsServerFactoryBean serviceFactory = new JaxWsServerFactoryBean();\n            serviceFactory.setBus(bus);\n            serviceFactory.setServiceClass(MessageProviderWithAddressingPolicy.class);\n            serviceFactory.setWsdlLocation(\"wsdl_systest_wsspec/addr-jaxwsmm.wsdl\");\n            serviceFactory.setAddress(ADDRESS);\n            org.apache.cxf.endpoint.Server provider = serviceFactory.create();\n            EndpointInfo ei = provider.getEndpoint().getEndpointInfo();\n            LOG.info(\"Started server at: \" + ei.getAddress());\n\n            testInterceptors(bus);\n        }","id":67567,"modified_method":"protected void run() {\n            SpringBusFactory bf = new SpringBusFactory();\n            Bus bus = bf.createBus(\"org/apache/cxf/systest/ws/addr_wsdl/jaxwsmm/server.xml\");\n            setBus(bus);\n            JaxWsServerFactoryBean serviceFactory = new JaxWsServerFactoryBean();\n            serviceFactory.setBus(bus);\n            serviceFactory.setServiceClass(MessageProviderWithAddressingPolicy.class);\n            serviceFactory.setWsdlLocation(\"wsdl_systest_wsspec/addr-jaxwsmm.wsdl\");\n            serviceFactory.setAddress(ADDRESS);\n            org.apache.cxf.endpoint.Server provider = serviceFactory.create();\n            EndpointInfo ei = provider.getEndpoint().getEndpointInfo();\n            LOG.info(\"Started server at: \" + ei.getAddress());\n\n            testInterceptors(bus);\n        }","commit_id":"af0d47cbdf832a489bcb749f526acb9843e917fc","url":"https://github.com/apache/cxf"},{"original_method":"@Before\n    public void before() throws Exception {\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setAddress(\"http://localhost:\" + PORT + \"/Echo\");\n        sf.setDataBinding(new AegisDatabinding());\n        sf.setServiceBean(new Echo());\n        Server server = sf.create();\n        // turn off nanny in URIMappingInterceptor\n        server.getEndpoint()\n            .getService().put(AbstractInDatabindingInterceptor.NO_VALIDATE_PARTS, Boolean.TRUE);\n        \n        ServerFactoryBean sf2 = new ServerFactoryBean();\n        sf2.setAddress(\"http://localhost:\" + PORT + \"/SimpleEcho\");\n        sf2.setDataBinding(new AegisDatabinding());\n        sf2.setServiceBean(new Echo());\n        server = sf2.create();\n        // turn off nanny in URIMappingInterceptor\n        server.getEndpoint()\n            .getService().put(AbstractInDatabindingInterceptor.NO_VALIDATE_PARTS, Boolean.TRUE);\n    }","id":67568,"modified_method":"@SuppressWarnings(\"deprecation\")\n    @Before\n    public void before() throws Exception {\n        JaxWsServerFactoryBean sf = new JaxWsServerFactoryBean();\n        sf.setAddress(\"http://localhost:\" + PORT + \"/Echo\");\n        sf.setDataBinding(new AegisDatabinding());\n        sf.setServiceBean(new Echo());\n        sf.getInInterceptors().add(new URIMappingInterceptor());\n        Server server = sf.create();\n        // turn off nanny in URIMappingInterceptor\n        server.getEndpoint()\n            .getService().put(AbstractInDatabindingInterceptor.NO_VALIDATE_PARTS, Boolean.TRUE);\n        \n        ServerFactoryBean sf2 = new ServerFactoryBean();\n        sf2.setAddress(\"http://localhost:\" + PORT + \"/SimpleEcho\");\n        sf2.setDataBinding(new AegisDatabinding());\n        sf2.setServiceBean(new Echo());\n        sf2.getInInterceptors().add(new URIMappingInterceptor());\n        server = sf2.create();\n        // turn off nanny in URIMappingInterceptor\n        server.getEndpoint()\n            .getService().put(AbstractInDatabindingInterceptor.NO_VALIDATE_PARTS, Boolean.TRUE);\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n            MyImplementation implementor = new MyImplementation();\n            JaxWsServerFactoryBean svrFactory = new JaxWsServerFactoryBean();\n            svrFactory.setServiceClass(MyInterface.class);\n            svrFactory.setAddress(BASE_URL);\n            svrFactory.setServiceBean(implementor);\n            svrFactory.getInInterceptors().add(new LoggingInInterceptor());\n            svrFactory.getOutInterceptors().add(new LoggingOutInterceptor());\n            svrFactory.create();\n        }","id":67569,"modified_method":"@SuppressWarnings(\"deprecation\")\n        protected void run() {\n            MyImplementation implementor = new MyImplementation();\n            JaxWsServerFactoryBean svrFactory = new JaxWsServerFactoryBean();\n            svrFactory.setServiceClass(MyInterface.class);\n            svrFactory.getInInterceptors().add(new URIMappingInterceptor());\n            svrFactory.setAddress(BASE_URL);\n            svrFactory.setServiceBean(implementor);\n            svrFactory.getInInterceptors().add(new LoggingInInterceptor());\n            svrFactory.getOutInterceptors().add(new LoggingOutInterceptor());\n            svrFactory.create();\n        }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        URL url = getClass().getResource(\"fault-stack-trace.xml\");\n        if (url != null) {\n            System.setProperty(\"cxf.config.file.url\", url.toString());\n        }\n        Object implementor;\n        String address;\n\n        implementor = new AsyncGreeter();\n        address = \"http://localhost:\" + PORT + \"/SoapContext/AsyncSoapPort\";\n        Endpoint.publish(address, implementor);\n        \n        implementor = new GreeterImplMultiPort();\n        address = \"http://localhost:\" + PORT + \"/MultiPort/GreeterPort\";\n        Endpoint.publish(address, implementor);\n\n        implementor = new DocLitBareGreeterMultiPort();\n        address = \"http://localhost:\" + PORT + \"/MultiPort/DocBarePort\";\n        Endpoint.publish(address, implementor);\n        \n        implementor = new GreeterImpl();\n        address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n\n        implementor = new RefGreeterImpl();\n        address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort2\";\n        Endpoint.publish(address, implementor);\n        \n        //publish port with soap12 binding\n        address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n\n        \n        EndpointImpl e = (EndpointImpl) Endpoint.create(javax.xml.ws.soap.SOAPBinding.SOAP12HTTP_BINDING, \n                                                        new Greeter12Impl());\n        e.publish(address);\n        \n        implementor = new DocLitBareGreeterImpl();\n        address = \"http://localhost:\" + BARE_PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n        \n        \n        implementor = new GreeterImplBogus();\n        address = \"http://localhost:\" + BOGUS_REAL_PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","id":67570,"modified_method":"@SuppressWarnings(\"deprecation\")\n    protected void run() {\n        URL url = getClass().getResource(\"fault-stack-trace.xml\");\n        if (url != null) {\n            System.setProperty(\"cxf.config.file.url\", url.toString());\n        }\n        Object implementor;\n        String address;\n\n        implementor = new AsyncGreeter();\n        address = \"http://localhost:\" + PORT + \"/SoapContext/AsyncSoapPort\";\n        eps.add(Endpoint.publish(address, implementor));\n        \n        implementor = new GreeterImplMultiPort();\n        address = \"http://localhost:\" + PORT + \"/MultiPort/GreeterPort\";\n        eps.add(Endpoint.publish(address, implementor));\n\n        implementor = new DocLitBareGreeterMultiPort();\n        address = \"http://localhost:\" + PORT + \"/MultiPort/DocBarePort\";\n        eps.add(Endpoint.publish(address, implementor));\n        \n        implementor = new GreeterImpl();\n        address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint ep = Endpoint.publish(address, implementor);\n        ((EndpointImpl)ep).getService().getInInterceptors().add(new URIMappingInterceptor());\n        eps.add(ep);\n\n        implementor = new RefGreeterImpl();\n        address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort2\";\n        eps.add(Endpoint.publish(address, implementor));\n        \n        //publish port with soap12 binding\n        address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n\n        \n        EndpointImpl e = (EndpointImpl) Endpoint.create(javax.xml.ws.soap.SOAPBinding.SOAP12HTTP_BINDING, \n                                                        new Greeter12Impl());\n        e.publish(address);\n        eps.add(e);\n        \n        implementor = new DocLitBareGreeterImpl();\n        address = \"http://localhost:\" + BARE_PORT + \"/SoapContext/SoapPort\";\n        eps.add(Endpoint.publish(address, implementor));\n        \n        \n        implementor = new GreeterImplBogus();\n        address = \"http://localhost:\" + BOGUS_REAL_PORT + \"/SoapContext/SoapPort\";\n        eps.add(Endpoint.publish(address, implementor));\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"protected void run()  {    \n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        Endpoint.publish(address, implementor);\n    }","id":67571,"modified_method":"@SuppressWarnings(\"deprecation\")\n    protected void run()  {    \n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/SoapPort\";\n        ep = Endpoint.publish(address, implementor);\n        EndpointImpl epi = (EndpointImpl)ep;\n        epi.getService().getInInterceptors().add(new URIMappingInterceptor());\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        Object implementor = new GreeterImplNoWsdl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/GreeterPort\";\n        Endpoint ep = Endpoint.create(implementor);\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(WSDLGetUtils.WSDL_CREATE_IMPORTS, Boolean.TRUE);\n        ep.setProperties(props);\n        ep.publish(address);\n    }","id":67572,"modified_method":"@SuppressWarnings(\"deprecation\")\n    protected void run() {\n        Object implementor = new GreeterImplNoWsdl();\n        String address = \"http://localhost:\" + PORT + \"/SoapContext/GreeterPort\";\n        Endpoint ep = Endpoint.create(implementor);\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(WSDLGetUtils.WSDL_CREATE_IMPORTS, Boolean.TRUE);\n        ep.setProperties(props);\n        ep.publish(address);\n        ((EndpointImpl)ep).getService().getInInterceptors().add(new URIMappingInterceptor());\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        \n        Factory factory = new PerRequestFactory(DocLitWrappedCodeFirstServiceImpl.class);\n        factory = new PooledFactory(factory, 4);\n        \n        JAXWSMethodInvoker invoker = new JAXWSMethodInvoker(factory);\n        JaxWsServerFactoryBean factoryBean;\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.create();\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_SETTINGS_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.getServiceFactory().setAnonymousWrapperTypes(true);\n        factoryBean.getServiceFactory().getServiceConfigurations().add(0, new AbstractServiceConfiguration() {\n            public Boolean isWrapperPartNillable(MessagePartInfo mpi) {\n                return Boolean.TRUE;\n            }\n            public Long getWrapperPartMinOccurs(MessagePartInfo mpi) {\n                return Long.valueOf(1L);\n            }\n        });\n        factoryBean.create();\n         \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor7 = new DocLitBareCodeFirstServiceImpl();\n        EndpointImpl ep = (EndpointImpl)Endpoint.publish(DOCLITBARE_CODEFIRST_URL, implementor7);\n        ep.getServer().getEndpoint().getInInterceptors().add(new SAAJInInterceptor());\n\n        \n        Object implementor6 = new InterfaceInheritTestImpl();\n        Endpoint.publish(DOCLIT_CODEFIRST_BASE_URL, implementor6);\n        \n        Object implementor1 = new AnonymousComplexTypeImpl();\n        String address = \"http://localhost:\" + PORT + \"/anonymous_complex_typeSOAP\";\n        Endpoint.publish(address, implementor1);\n\n        Object implementor2 = new JaxbElementTestImpl();\n        address = \"http://localhost:\" + PORT + \"/jaxb_element_test\";\n        Endpoint.publish(address, implementor2);\n\n        Object implementor3 = new OrderedParamHolderImpl();\n        address = \"http://localhost:\" + PORT + \"/ordered_param_holder/\";\n        Endpoint.publish(address, implementor3);\n        \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor5 = new RpcLitCodeFirstServiceImpl();\n        Endpoint.publish(RPCLIT_CODEFIRST_URL, implementor5);\n        \n        Endpoint.publish(\"http://localhost:\" + PORT + \"/InheritContext/InheritPort\",\n                         new InheritImpl());\n\n    }","id":67573,"modified_method":"@SuppressWarnings(\"deprecation\")\n    protected void run() {\n        \n        Factory factory = new PerRequestFactory(DocLitWrappedCodeFirstServiceImpl.class);\n        factory = new PooledFactory(factory, 4);\n        \n        JAXWSMethodInvoker invoker = new JAXWSMethodInvoker(factory);\n        JaxWsServerFactoryBean factoryBean;\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.create();\n        \n        factoryBean = new JaxWsServerFactoryBean();\n        factoryBean.setAddress(DOCLIT_CODEFIRST_SETTINGS_URL);\n        factoryBean.setServiceClass(DocLitWrappedCodeFirstServiceImpl.class);\n        factoryBean.setInvoker(invoker);\n        factoryBean.getServiceFactory().setAnonymousWrapperTypes(true);\n        factoryBean.getServiceFactory().getServiceConfigurations().add(0, new AbstractServiceConfiguration() {\n            public Boolean isWrapperPartNillable(MessagePartInfo mpi) {\n                return Boolean.TRUE;\n            }\n            public Long getWrapperPartMinOccurs(MessagePartInfo mpi) {\n                return Long.valueOf(1L);\n            }\n        });\n        factoryBean.create();\n         \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor7 = new DocLitBareCodeFirstServiceImpl();\n        EndpointImpl ep = (EndpointImpl)Endpoint.publish(DOCLITBARE_CODEFIRST_URL, implementor7);\n        ep.getServer().getEndpoint().getInInterceptors().add(new SAAJInInterceptor());\n        ep.getServer().getEndpoint().getInInterceptors().add(new URIMappingInterceptor());\n\n        \n        Object implementor6 = new InterfaceInheritTestImpl();\n        Endpoint.publish(DOCLIT_CODEFIRST_BASE_URL, implementor6);\n        \n        Object implementor1 = new AnonymousComplexTypeImpl();\n        String address = \"http://localhost:\" + PORT + \"/anonymous_complex_typeSOAP\";\n        Endpoint.publish(address, implementor1);\n\n        Object implementor2 = new JaxbElementTestImpl();\n        address = \"http://localhost:\" + PORT + \"/jaxb_element_test\";\n        Endpoint.publish(address, implementor2);\n\n        Object implementor3 = new OrderedParamHolderImpl();\n        address = \"http://localhost:\" + PORT + \"/ordered_param_holder/\";\n        Endpoint.publish(address, implementor3);\n        \n        //Object implementor4 = new DocLitWrappedCodeFirstServiceImpl();\n        //Endpoint.publish(DOCLIT_CODEFIRST_URL, implementor4);\n        \n        Object implementor5 = new RpcLitCodeFirstServiceImpl();\n        Endpoint.publish(RPCLIT_CODEFIRST_URL, implementor5);\n        \n        Endpoint.publish(\"http://localhost:\" + PORT + \"/InheritContext/InheritPort\",\n                         new InheritImpl());\n\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"protected void run() {\n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLPort\";\n        Endpoint.publish(address, implementor);\n\n        Object implementor1 = new org.apache.hello_world_xml_http.wrapped.GreeterImpl();\n        address = \"http://localhost:\" + WRAP_PORT + \"/XMLService/XMLPort\";\n        Endpoint.publish(address, implementor1);\n\n        Object faultImplementor = new GreeterFaultImpl();\n        String faultAddress = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLFaultPort\";\n        Endpoint.publish(faultAddress, faultImplementor);\n\n        Object implementor2 = new HeaderTesterImpl();\n        address = \"http://localhost:\" + REG_PORT + \"/XMLContext/XMLPort\";\n        Endpoint.publish(address, implementor2);\n        \n        Object implementor3 = new org.apache.hello_world_xml_http.mixed.GreeterImpl();\n        address = \"http://localhost:\" + MIX_PORT + \"/XMLService/XMLPort\";\n        Endpoint.publish(address, implementor3);\n    }","id":67574,"modified_method":"@SuppressWarnings(\"deprecation\")\n    protected void run() {\n        Object implementor = new GreeterImpl();\n        String address = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor));\n        \n        ((EndpointImpl)eps.get(0)).getService().getInInterceptors().add(new URIMappingInterceptor());\n\n        Object implementor1 = new org.apache.hello_world_xml_http.wrapped.GreeterImpl();\n        address = \"http://localhost:\" + WRAP_PORT + \"/XMLService/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor1));\n\n        Object faultImplementor = new GreeterFaultImpl();\n        String faultAddress = \"http://localhost:\" + REG_PORT + \"/XMLService/XMLFaultPort\";\n        eps.add(Endpoint.publish(faultAddress, faultImplementor));\n\n        Object implementor2 = new HeaderTesterImpl();\n        address = \"http://localhost:\" + REG_PORT + \"/XMLContext/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor2));\n        \n        Object implementor3 = new org.apache.hello_world_xml_http.mixed.GreeterImpl();\n        address = \"http://localhost:\" + MIX_PORT + \"/XMLService/XMLPort\";\n        eps.add(Endpoint.publish(address, implementor3));\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"public Binding createBinding(BindingInfo binding) {\n        // TODO what about the mix style/use?\n\n\n        // The default style should be doc-lit wrapped.\n        String parameterStyle = SoapBindingConstants.PARAMETER_STYLE_WRAPPED;\n        String bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n\n        boolean hasWrapped = false;\n        \n        org.apache.cxf.binding.soap.SoapBinding sb = null;\n        SoapVersion version = null;\n        if (binding instanceof SoapBindingInfo) {\n            SoapBindingInfo sbi = (SoapBindingInfo) binding;\n            version = sbi.getSoapVersion();\n            sb = new org.apache.cxf.binding.soap.SoapBinding(binding, version);\n            // Service wide style\n            if (!StringUtils.isEmpty(sbi.getStyle())) {\n                bindingStyle = sbi.getStyle();\n            }\n\n            boolean hasRPC = false;\n            boolean hasDoc = false;\n            \n            // Operation wide style, what to do with the mixed style/use?\n            for (BindingOperationInfo boi : sbi.getOperations()) {\n                String st = sbi.getStyle(boi.getOperationInfo());\n                if (st != null) {\n                    bindingStyle = st;\n                    if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(st)) {\n                        hasRPC = true;\n                    } else {\n                        hasDoc = true;\n                    }\n                }\n                if (boi.getUnwrappedOperation() == null) {\n                    parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                } else {\n                    hasWrapped = true;\n                }\n            }\n            \n            if (Boolean.TRUE.equals(binding.getService().getProperty(\"soap.force.doclit.bare\"))) {\n                hasDoc = true;\n                hasRPC = false;\n                parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n            }\n            if (hasRPC && hasDoc) {\n                throw new RuntimeException(\"WSI-BP prohibits RPC and Document style \"\n                                           + \"operations in same service.\");\n            }\n            \n            //jms\n            if (sbi.getTransportURI().equals(SoapJMSConstants.SOAP_JMS_SPECIFICIATION_TRANSPORTID)) {\n                sb.getInInterceptors().add(new SoapJMSInInterceptor());\n            }\n        } else {\n            throw new RuntimeException(\"Can not initialize SoapBinding, BindingInfo is not SoapBindingInfo\");\n        }\n\n        sb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n        sb.getInInterceptors().add(new AttachmentInInterceptor());\n        sb.getInInterceptors().add(new StaxInInterceptor());\n        sb.getInInterceptors().add(new SoapActionInInterceptor());\n        \n        sb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        sb.getOutInterceptors().add(new StaxOutInterceptor());\n        sb.getOutInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(bindingStyle)) {\n            sb.getInInterceptors().add(new RPCInInterceptor());\n            sb.getOutInterceptors().add(new RPCOutInterceptor());\n        } else if (SoapBindingConstants.BINDING_STYLE_DOC.equalsIgnoreCase(bindingStyle)\n                        && SoapBindingConstants.PARAMETER_STYLE_BARE.equalsIgnoreCase(parameterStyle)) {\n            //sb.getInInterceptors().add(new BareInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            if (hasWrapped) {\n                sb.getOutInterceptors().add(new WrappedOutInterceptor());                    \n            }\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        } else {\n            //sb.getInInterceptors().add(new WrappedInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            sb.getOutInterceptors().add(new WrappedOutInterceptor());\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        }\n        sb.getInInterceptors().add(new SoapHeaderInterceptor());\n\n        sb.getInInterceptors().add(new ReadHeadersInterceptor(getBus(), version));\n        sb.getInInterceptors().add(new StartBodyInterceptor());\n        sb.getInInterceptors().add(new CheckFaultInterceptor());\n        sb.getInInterceptors().add(new MustUnderstandInterceptor());\n        sb.getOutInterceptors().add(new SoapPreProtocolOutInterceptor());\n        sb.getOutInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        // REVISIT: The phase interceptor chain seems to freak out if this added\n        // first. Not sure what the deal is at the moment, I suspect the\n        // ordering algorithm needs to be improved\n        sb.getInInterceptors().add(new URIMappingInterceptor());\n\n        if (version.getVersion() == 1.1) {\n            sb.getInFaultInterceptors().add(new Soap11FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap11FaultOutInterceptor());\n        } else if (version.getVersion() == 1.2) {\n            sb.getInFaultInterceptors().add(new Soap12FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap12FaultOutInterceptor());\n        }\n        \n        if (binding.getService() != null) {\n            for (EndpointInfo ei: binding.getService().getEndpoints()) {\n                if (ei.getAddress() != null && ei.getAddress().startsWith(\"soap.udp\")) {\n                    setupUDP(sb, ei);\n                }\n            }\n        }\n\n        return sb;\n    }","id":67575,"modified_method":"public Binding createBinding(BindingInfo binding) {\n        // TODO what about the mix style/use?\n\n\n        // The default style should be doc-lit wrapped.\n        String parameterStyle = SoapBindingConstants.PARAMETER_STYLE_WRAPPED;\n        String bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n\n        boolean hasWrapped = false;\n        \n        org.apache.cxf.binding.soap.SoapBinding sb = null;\n        SoapVersion version = null;\n        if (binding instanceof SoapBindingInfo) {\n            SoapBindingInfo sbi = (SoapBindingInfo) binding;\n            version = sbi.getSoapVersion();\n            sb = new org.apache.cxf.binding.soap.SoapBinding(binding, version);\n            // Service wide style\n            if (!StringUtils.isEmpty(sbi.getStyle())) {\n                bindingStyle = sbi.getStyle();\n            }\n\n            boolean hasRPC = false;\n            boolean hasDoc = false;\n            \n            // Operation wide style, what to do with the mixed style/use?\n            for (BindingOperationInfo boi : sbi.getOperations()) {\n                String st = sbi.getStyle(boi.getOperationInfo());\n                if (st != null) {\n                    bindingStyle = st;\n                    if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(st)) {\n                        hasRPC = true;\n                    } else {\n                        hasDoc = true;\n                    }\n                }\n                if (boi.getUnwrappedOperation() == null) {\n                    parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                } else {\n                    hasWrapped = true;\n                }\n            }\n            \n            if (Boolean.TRUE.equals(binding.getService().getProperty(\"soap.force.doclit.bare\"))) {\n                hasDoc = true;\n                hasRPC = false;\n                parameterStyle = SoapBindingConstants.PARAMETER_STYLE_BARE;\n                bindingStyle = SoapBindingConstants.BINDING_STYLE_DOC;\n            }\n            if (hasRPC && hasDoc) {\n                throw new RuntimeException(\"WSI-BP prohibits RPC and Document style \"\n                                           + \"operations in same service.\");\n            }\n            \n            //jms\n            if (sbi.getTransportURI().equals(SoapJMSConstants.SOAP_JMS_SPECIFICIATION_TRANSPORTID)) {\n                sb.getInInterceptors().add(new SoapJMSInInterceptor());\n            }\n        } else {\n            throw new RuntimeException(\"Can not initialize SoapBinding, BindingInfo is not SoapBindingInfo\");\n        }\n\n        sb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n\n        sb.getInInterceptors().add(new AttachmentInInterceptor());\n        sb.getInInterceptors().add(new StaxInInterceptor());\n        sb.getInInterceptors().add(new SoapActionInInterceptor());\n        \n        sb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        sb.getOutInterceptors().add(new StaxOutInterceptor());\n        sb.getOutInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        if (SoapBindingConstants.BINDING_STYLE_RPC.equalsIgnoreCase(bindingStyle)) {\n            sb.getInInterceptors().add(new RPCInInterceptor());\n            sb.getOutInterceptors().add(new RPCOutInterceptor());\n        } else if (SoapBindingConstants.BINDING_STYLE_DOC.equalsIgnoreCase(bindingStyle)\n                        && SoapBindingConstants.PARAMETER_STYLE_BARE.equalsIgnoreCase(parameterStyle)) {\n            //sb.getInInterceptors().add(new BareInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            if (hasWrapped) {\n                sb.getOutInterceptors().add(new WrappedOutInterceptor());                    \n            }\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        } else {\n            //sb.getInInterceptors().add(new WrappedInInterceptor());\n            sb.getInInterceptors().add(new DocLiteralInInterceptor());\n            sb.getOutInterceptors().add(new WrappedOutInterceptor());\n            sb.getOutInterceptors().add(new BareOutInterceptor());\n        }\n        sb.getInInterceptors().add(new SoapHeaderInterceptor());\n\n        sb.getInInterceptors().add(new ReadHeadersInterceptor(getBus(), version));\n        sb.getInInterceptors().add(new StartBodyInterceptor());\n        sb.getInInterceptors().add(new CheckFaultInterceptor());\n        sb.getInInterceptors().add(new MustUnderstandInterceptor());\n        sb.getOutInterceptors().add(new SoapPreProtocolOutInterceptor());\n        sb.getOutInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(new SoapOutInterceptor(getBus()));\n        sb.getOutFaultInterceptors().add(SoapHeaderOutFilterInterceptor.INSTANCE);\n\n        if (version.getVersion() == 1.1) {\n            sb.getInFaultInterceptors().add(new Soap11FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap11FaultOutInterceptor());\n        } else if (version.getVersion() == 1.2) {\n            sb.getInFaultInterceptors().add(new Soap12FaultInInterceptor());\n            sb.getOutFaultInterceptors().add(new Soap12FaultOutInterceptor());\n        }\n        \n        if (binding.getService() != null) {\n            for (EndpointInfo ei: binding.getService().getEndpoints()) {\n                if (ei.getAddress() != null && ei.getAddress().startsWith(\"soap.udp\")) {\n                    setupUDP(sb, ei);\n                }\n            }\n        }\n\n        return sb;\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"public Binding createBinding(BindingInfo binding) {\n        XMLBinding xb = new XMLBinding(binding);\n        \n        xb.getInInterceptors().add(new AttachmentInInterceptor());    \n        xb.getInInterceptors().add(new StaxInInterceptor());\n        xb.getInInterceptors().add(new URIMappingInterceptor());\n        xb.getInInterceptors().add(new DocLiteralInInterceptor());\n        xb.getInInterceptors().add(new XMLMessageInInterceptor());\n        \n        xb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        xb.getOutInterceptors().add(new StaxOutInterceptor());\n        xb.getOutInterceptors().add(new WrappedOutInterceptor());\n        xb.getOutInterceptors().add(new XMLMessageOutInterceptor());            \n\n        xb.getInFaultInterceptors().add(new XMLFaultInInterceptor());\n        xb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        xb.getOutFaultInterceptors().add(new XMLFaultOutInterceptor());\n        \n        return xb;\n    }","id":67576,"modified_method":"public Binding createBinding(BindingInfo binding) {\n        XMLBinding xb = new XMLBinding(binding);\n        \n        xb.getInInterceptors().add(new AttachmentInInterceptor());    \n        xb.getInInterceptors().add(new StaxInInterceptor());\n        xb.getInInterceptors().add(new DocLiteralInInterceptor());\n        xb.getInInterceptors().add(new XMLMessageInInterceptor());\n        \n        xb.getOutInterceptors().add(new AttachmentOutInterceptor());\n        xb.getOutInterceptors().add(new StaxOutInterceptor());\n        xb.getOutInterceptors().add(new WrappedOutInterceptor());\n        xb.getOutInterceptors().add(new XMLMessageOutInterceptor());            \n\n        xb.getInFaultInterceptors().add(new XMLFaultInInterceptor());\n        xb.getOutFaultInterceptors().add(new StaxOutInterceptor());\n        xb.getOutFaultInterceptors().add(new XMLFaultOutInterceptor());\n        \n        return xb;\n    }","commit_id":"94a98b3fe9c79e2cf3941acbbad216ba54999bc0","url":"https://github.com/apache/cxf"},{"original_method":"@Override\n\tpublic void close(boolean force) {\n\t\tPortalExecutorManagerUtil.shutdown(getName(), force);\n\t}","id":67577,"modified_method":"@Override\n\tpublic void close(boolean force) {\n\t\tThreadPoolExecutor threadPoolExecutor =\n\t\t\tPortalExecutorManagerUtil.getPortalExecutor(getName());\n\n\t\tif (force) {\n\t\t\tthreadPoolExecutor.shutdownNow();\n\t\t}\n\t\telse {\n\t\t\tthreadPoolExecutor.shutdown();\n\t\t}\n\t}","commit_id":"5bc2aa2f316007065f33163449beb14463f7fefb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPortalExecutor5() throws Exception {\n\t\ttry {\n\t\t\tPortalExecutorManagerUtil.shutdown(\"liferay/hot_deploy\");\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t}\n\t}","id":67578,"modified_method":"@Test\n\tpublic void testPortalExecutor5() throws Exception {\n\t\ttry {\n\t\t\tThreadPoolExecutor threadPoolExecutor =\n\t\t\t\tPortalExecutorManagerUtil.getPortalExecutor(\n\t\t\t\t\t\"liferay/hot_deploy\");\n\n\t\t\tthreadPoolExecutor.shutdown();\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t}\n\t}","commit_id":"5bc2aa2f316007065f33163449beb14463f7fefb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPortalExecutor2() throws Exception {\n\t\ttry {\n\t\t\tPortalExecutorManagerUtil.execute(\n\t\t\t\t\"liferay/test_pacl\",\n\t\t\t\tnew Callable<Void>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t\tAssert.fail();\n\t\t}\n\t}","id":67579,"modified_method":"@Test\n\tpublic void testPortalExecutor2() throws Exception {\n\t\ttry {\n\t\t\tThreadPoolExecutor threadPoolExecutor =\n\t\t\t\tPortalExecutorManagerUtil.getPortalExecutor(\n\t\t\t\t\t\"liferay/test_pacl\");\n\n\t\t\tthreadPoolExecutor.submit(\n\t\t\t\tnew Callable<Void>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t\tAssert.fail();\n\t\t}\n\t}","commit_id":"5bc2aa2f316007065f33163449beb14463f7fefb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPortalExecutor1() throws Exception {\n\t\ttry {\n\t\t\tPortalExecutorManagerUtil.execute(\n\t\t\t\t\"liferay/hot_deploy\",\n\t\t\t\tnew Callable<Void>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t}\n\t}","id":67580,"modified_method":"@Test\n\tpublic void testPortalExecutor1() throws Exception {\n\t\ttry {\n\t\t\tThreadPoolExecutor threadPoolExecutor =\n\t\t\t\tPortalExecutorManagerUtil.getPortalExecutor(\n\t\t\t\t\t\"liferay/hot_deploy\");\n\n\t\t\tthreadPoolExecutor.submit(\n\t\t\t\tnew Callable<Void>() {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Void call() throws Exception {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tAssert.fail();\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t}\n\t}","commit_id":"5bc2aa2f316007065f33163449beb14463f7fefb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Test\n\tpublic void testPortalExecutor6() throws Exception {\n\t\ttry {\n\t\t\tPortalExecutorManagerUtil.shutdown(\"liferay/test_pacl\");\n\n\t\t\tPortalExecutorManagerUtil.getPortalExecutor(\n\t\t\t\t\"liferay/test_pacl\", true);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tDestination destination = messageBus.getDestination(\n\t\t\t\t\"liferay/test_pacl\");\n\n\t\t\tdestination.open();\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t\tAssert.fail();\n\t\t}\n\t}","id":67581,"modified_method":"@Test\n\tpublic void testPortalExecutor6() throws Exception {\n\t\ttry {\n\t\t\tThreadPoolExecutor threadPoolExecutor =\n\t\t\t\tPortalExecutorManagerUtil.getPortalExecutor(\n\t\t\t\t\t\"liferay/test_pacl\");\n\n\t\t\tthreadPoolExecutor.shutdown();\n\n\t\t\tthreadPoolExecutor.awaitTermination(1, TimeUnit.MINUTES);\n\n\t\t\tPortalExecutorManagerUtil.getPortalExecutor(\n\t\t\t\t\"liferay/test_pacl\", true);\n\n\t\t\tMessageBus messageBus = MessageBusUtil.getMessageBus();\n\n\t\t\tDestination destination = messageBus.getDestination(\n\t\t\t\t\"liferay/test_pacl\");\n\n\t\t\tdestination.open();\n\t\t}\n\t\tcatch (SecurityException se) {\n\t\t\tAssert.fail();\n\t\t}\n\t}","commit_id":"5bc2aa2f316007065f33163449beb14463f7fefb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"private ASTNode createBlockFrom(List<Block> result, ASTNode child, final IElementType from, final IElementType to) {\n\n    return createSynteticBlock(result,\n                               child,\n                               from,\n                               to,\n                               getCodeBlockExternalIndent(),\n                               getCodeBlockInternalIndent(child),\n                               new WrappingStrategy(Formatter.getInstance().createWrap(Wrap.NORMAL, true)) {\n      protected boolean shouldWrap(final IElementType type) {\n        return true;\n      }\n    },\n                               null);\n  }","id":67582,"modified_method":"private ASTNode createBlockFrom(List<Block> result, ASTNode child, final IElementType from, final IElementType to) {\n\n    return createSynteticBlock(result,\n                               child,\n                               from,\n                               to,\n                               getCodeBlockExternalIndent(),\n                               getCodeBlockInternalIndent(child),\n                               new WrappingStrategy(Formatter.getInstance().createWrap(Wrap.NORMAL, true)) {\n      protected boolean shouldWrap(final IElementType type) {\n        return true;\n      }\n    },\n                               AlignmentStrategy.DO_NOT_ALIGN);\n  }","commit_id":"8073fc2d58c87310dd345e2409065063d74a5dc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ASTNode createSynteticBlock(List<Block> result,\n                                      ASTNode child,\n                                      IElementType from,\n                                      IElementType to,\n                                      Indent externalIndent,\n                                      Indent internalIndent,\n                                      WrappingStrategy wrappingStrategy,\n                                      Alignment alignment) {\n    ASTNode prev = child;\n    List<Block> resultList = new ArrayList<Block>();\n    List<Block> codeBlock = new ArrayList<Block>();\n    while (child != null) {\n      if (!containsWhiteSpacesOnly(child) && child.getTextLength() > 0){\n        if (child.getElementType() == from) {\n          resultList.add(createJavaBlock(child, mySettings));\n        } else if (child.getElementType() == ElementType.SWITCH_LABEL_STATEMENT){\n          child = createCaseBlockFrom(codeBlock, child);\n        } else if (child.getElementType() == to) {\n          if (!codeBlock.isEmpty()) {\n            resultList.add(new SynteticCodeBlock(codeBlock, null, mySettings, internalIndent, null));\n\n          }\n          resultList.add(createJavaBlock(child, mySettings));\n          result.add(new SynteticCodeBlock(resultList, null, mySettings, externalIndent, null));\n          return child;\n        } else {\n          codeBlock.add(createJavaBlock(child, mySettings, null, wrappingStrategy.getWrap(child.getElementType()), alignment));\n          if (to == null) {\n            resultList.add(new SynteticCodeBlock(codeBlock, null, mySettings, internalIndent, null));\n            result.add(new SynteticCodeBlock(resultList, null, mySettings, externalIndent, null));\n            return child;//process only one statement\n          }\n        }\n      }\n      prev = child;\n      if (child != null) {\n        child = child.getTreeNext();\n      }\n    }\n\n    if (!codeBlock.isEmpty()) {\n      resultList.add(new SynteticCodeBlock(codeBlock, null, mySettings, internalIndent, null));\n    }\n\n    if (!resultList.isEmpty()) {\n      result.add(new SynteticCodeBlock(resultList, null, mySettings, externalIndent, null));\n    }\n\n    return prev;\n\n  }","id":67583,"modified_method":"private ASTNode createSynteticBlock(List<Block> result,\n                                      ASTNode child,\n                                      IElementType from,\n                                      IElementType to,\n                                      Indent externalIndent,\n                                      Indent internalIndent,\n                                      WrappingStrategy wrappingStrategy,\n                                      AlignmentStrategy alignmentStrategy) {\n    ASTNode prev = child;\n    List<Block> resultList = new ArrayList<Block>();\n    List<Block> codeBlock = new ArrayList<Block>();\n    while (child != null) {\n      if (!containsWhiteSpacesOnly(child) && child.getTextLength() > 0){\n        if (child.getElementType() == from) {\n          resultList.add(createJavaBlock(child, mySettings));\n        } else if (child.getElementType() == ElementType.SWITCH_LABEL_STATEMENT){\n          child = createCaseBlockFrom(codeBlock, child);\n        } else if (child.getElementType() == to) {\n          if (!codeBlock.isEmpty()) {\n            resultList.add(new SynteticCodeBlock(codeBlock, null, mySettings, internalIndent, null));\n\n          }\n          resultList.add(createJavaBlock(child, mySettings));\n          result.add(new SynteticCodeBlock(resultList, null, mySettings, externalIndent, null));\n          return child;\n        } else {\n          final IElementType elementType = child.getElementType();\n          codeBlock.add(createJavaBlock(child, mySettings, null,\n                                        wrappingStrategy.getWrap(elementType),\n                                        alignmentStrategy.getAlignment(elementType)));\n          if (to == null) {\n            resultList.add(new SynteticCodeBlock(codeBlock, null, mySettings, internalIndent, null));\n            result.add(new SynteticCodeBlock(resultList, null, mySettings, externalIndent, null));\n            return child;//process only one statement\n          }\n        }\n      }\n      prev = child;\n      if (child != null) {\n        child = child.getTreeNext();\n      }\n    }\n\n    if (!codeBlock.isEmpty()) {\n      resultList.add(new SynteticCodeBlock(codeBlock, null, mySettings, internalIndent, null));\n    }\n\n    if (!resultList.isEmpty()) {\n      result.add(new SynteticCodeBlock(resultList, null, mySettings, externalIndent, null));\n    }\n\n    return prev;\n\n  }","commit_id":"8073fc2d58c87310dd345e2409065063d74a5dc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected ASTNode processChild(final ArrayList<Block> result, ASTNode child, Alignment defaultAlignment, final Wrap defaultWrap) {\n    if (child.getElementType() == ElementType.LBRACE) {\n      if (!result.isEmpty()) {\n        final ArrayList<Block> subBlock = new ArrayList<Block>(result);\n        result.clear();\n        result.add(new SynteticCodeBlock(subBlock, null, mySettings, null, null));\n      }\n      child = createBlockFrom(result, child, ElementType.LBRACE, ElementType.RBRACE);\n    }\n    else if (isStatement(child)) {\n      createBlockFrom(result, child, null, null);\n    }\n    else\n    if (child.getElementType() == ElementType.LPARENTH && myNode.getElementType() == ElementType.EXPRESSION_LIST){\n      final Wrap wrap = Formatter.getInstance().createWrap(getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n      child = createSynteticBlock(result, child, ElementType.LPARENTH, ElementType.RPARENTH,\n                                  Formatter.getInstance().getNoneIndent(),\n                                  Formatter.getInstance().createContinuationIndent(),\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  createAlignment(mySettings.ALIGN_MULTILINE_PARAMETERS_IN_CALLS, null));\n    }\n\n    else if (child.getElementType() == ElementType.LPARENTH && myNode.getElementType() == ElementType.PARAMETER_LIST){\n      final Wrap wrap = Formatter.getInstance().createWrap(getWrapType(mySettings.METHOD_PARAMETERS_WRAP), false);\n      child = createSynteticBlock(result, child, ElementType.LPARENTH, ElementType.RPARENTH,\n                                  Formatter.getInstance().getNoneIndent(),\n                                  Formatter.getInstance().createContinuationIndent(),\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  createAlignment(mySettings.ALIGN_MULTILINE_PARAMETERS, null));\n    }\n    else if (child.getElementType() == ElementType.LPARENTH && myNode.getElementType() == ElementType.PARENTH_EXPRESSION){\n      child = createSynteticBlock(result, child, ElementType.LPARENTH, ElementType.RPARENTH,\n                                  Formatter.getInstance().getNoneIndent(),\n                                  Formatter.getInstance().createContinuationIndent(),\n                                  WrappingStrategy.DO_NOT_WRAP,\n                                  createAlignment(mySettings.ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION, null));\n    }\n\n    else {\n      Indent indent = null;\n      if (shouldShift(child)) {\n        indent = Formatter.getInstance().createNormalIndent();\n      }\n      final Block block =\n        createJavaBlock(child, mySettings, indent, arrangeChildWrap(child, defaultWrap), arrangeChildAlignment(child, defaultAlignment));\n\n      if (block instanceof AbstractJavaBlock) {\n        final AbstractJavaBlock javaBlock = ((AbstractJavaBlock)block);\n        if (myNode.getElementType() == ElementType.METHOD_CALL_EXPRESSION && child.getElementType() == ElementType.REFERENCE_EXPRESSION) {\n          javaBlock.setReservedWrap(getReservedWrap());\n        } else if (myNode.getElementType() == ElementType.REFERENCE_EXPRESSION && child.getElementType() == ElementType.METHOD_CALL_EXPRESSION) {\n          javaBlock.setReservedWrap(getReservedWrap());\n        } else if (myNode.getElementType() == ElementType.BINARY_EXPRESSION) {\n          javaBlock.setReservedWrap(defaultWrap);\n        }\n      }\n\n      result.add(block);\n    }\n\n\n    return child;\n  }","id":67584,"modified_method":"protected ASTNode processChild(final ArrayList<Block> result, ASTNode child, Alignment defaultAlignment, final Wrap defaultWrap) {\n    if (child.getElementType() == ElementType.LBRACE) {\n      if (!result.isEmpty()) {\n        final ArrayList<Block> subBlock = new ArrayList<Block>(result);\n        result.clear();\n        result.add(new SynteticCodeBlock(subBlock, null, mySettings, null, null));\n      }\n      child = createBlockFrom(result, child, ElementType.LBRACE, ElementType.RBRACE);\n    }\n    else if (isStatement(child)) {\n      createBlockFrom(result, child, null, null);\n    }\n    else\n    if (child.getElementType() == ElementType.LPARENTH && myNode.getElementType() == ElementType.EXPRESSION_LIST){\n      final Wrap wrap = Formatter.getInstance().createWrap(getWrapType(mySettings.CALL_PARAMETERS_WRAP), false);\n      child = createSynteticBlock(result, child, ElementType.LPARENTH, ElementType.RPARENTH,\n                                  Formatter.getInstance().getNoneIndent(),\n                                  Formatter.getInstance().createContinuationIndent(),\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  AlignmentStrategy.createDoNotAlingCommaStrategy(createAlignment(mySettings.ALIGN_MULTILINE_PARAMETERS_IN_CALLS, null))\n                                  );\n    }\n\n    else if (child.getElementType() == ElementType.LPARENTH && myNode.getElementType() == ElementType.PARAMETER_LIST){\n      final Wrap wrap = Formatter.getInstance().createWrap(getWrapType(mySettings.METHOD_PARAMETERS_WRAP), false);\n      child = createSynteticBlock(result, child, ElementType.LPARENTH, ElementType.RPARENTH,\n                                  Formatter.getInstance().getNoneIndent(),\n                                  Formatter.getInstance().createContinuationIndent(),\n                                  WrappingStrategy.createDoNotWrapCommaStrategy(wrap),\n                                  AlignmentStrategy.createDoNotAlingCommaStrategy(createAlignment(mySettings.ALIGN_MULTILINE_PARAMETERS, null)));\n    }\n    else if (child.getElementType() == ElementType.LPARENTH && myNode.getElementType() == ElementType.PARENTH_EXPRESSION){\n      child = createSynteticBlock(result, child, ElementType.LPARENTH, ElementType.RPARENTH,\n                                  Formatter.getInstance().getNoneIndent(),\n                                  Formatter.getInstance().createContinuationIndent(),\n                                  WrappingStrategy.DO_NOT_WRAP,\n                                  AlignmentStrategy.createDoNotAlingCommaStrategy(createAlignment(mySettings.ALIGN_MULTILINE_PARENTHESIZED_EXPRESSION, null)));\n    }\n\n    else {\n      Indent indent = null;\n      if (shouldShift(child)) {\n        indent = Formatter.getInstance().createNormalIndent();\n      }\n      final Block block =\n        createJavaBlock(child, mySettings, indent, arrangeChildWrap(child, defaultWrap), arrangeChildAlignment(child, defaultAlignment));\n\n      if (block instanceof AbstractJavaBlock) {\n        final AbstractJavaBlock javaBlock = ((AbstractJavaBlock)block);\n        if (myNode.getElementType() == ElementType.METHOD_CALL_EXPRESSION && child.getElementType() == ElementType.REFERENCE_EXPRESSION) {\n          javaBlock.setReservedWrap(getReservedWrap());\n        } else if (myNode.getElementType() == ElementType.REFERENCE_EXPRESSION && child.getElementType() == ElementType.METHOD_CALL_EXPRESSION) {\n          javaBlock.setReservedWrap(getReservedWrap());\n        } else if (myNode.getElementType() == ElementType.BINARY_EXPRESSION) {\n          javaBlock.setReservedWrap(defaultWrap);\n        }\n      }\n\n      result.add(block);\n    }\n\n\n    return child;\n  }","commit_id":"8073fc2d58c87310dd345e2409065063d74a5dc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int adjustLineIndent(PsiFile file, int offset) throws IncorrectOperationException {\n    return adjustLineIndent(file, offset, true);\n  }","id":67585,"modified_method":"public int adjustLineIndent(PsiFile file, int offset) throws IncorrectOperationException {\n    final PsiElement element = file.findElementAt(offset);\n    if (CodeFormatterFacade.useBlockFormatter(file) && CodeFormatterFacade.useBlockFormatter(element.getLanguage())) {\n      return adjustLineIndent(file, offset, true);\n    } else {\n      return adjustLineIndent(file, offset, true);\n    }\n  }","commit_id":"8073fc2d58c87310dd345e2409065063d74a5dc1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public SocketChannel connect() {\n    SocketChannel _xblockexpression = null;\n    {\n      final File portFile = new File(DaemonConnector.DAEMON_LOCK_FILE);\n      try {\n        boolean _exists = portFile.exists();\n        if (_exists) {\n          FileReader _fileReader = new FileReader(portFile);\n          BufferedReader _bufferedReader = new BufferedReader(_fileReader);\n          final String line = _bufferedReader.readLine();\n          String _trim = line.trim();\n          final int port = Integer.parseInt(_trim);\n          SocketChannel socketChannel = SocketChannel.open();\n          socketChannel.configureBlocking(true);\n          InetAddress _byName = InetAddress.getByName(\"127.0.0.1\");\n          InetSocketAddress _inetSocketAddress = new InetSocketAddress(_byName, port);\n          socketChannel.connect(_inetSocketAddress);\n          return socketChannel;\n        }\n      } catch (final Throwable _t) {\n        if (_t instanceof Exception) {\n          final Exception exc = (Exception)_t;\n        } else {\n          throw Exceptions.sneakyThrow(_t);\n        }\n      }\n      _xblockexpression = this.launch(portFile);\n    }\n    return _xblockexpression;\n  }","id":67586,"modified_method":"public SocketChannel connect() {\n    SocketChannel _xblockexpression = null;\n    {\n      final File portFile = new File(DaemonConnector.DAEMON_LOCK_FILE);\n      try {\n        boolean _exists = portFile.exists();\n        if (_exists) {\n          FileReader _fileReader = new FileReader(portFile);\n          BufferedReader _bufferedReader = new BufferedReader(_fileReader);\n          final String line = _bufferedReader.readLine();\n          String _trim = line.trim();\n          final int port = Integer.parseInt(_trim);\n          SocketChannel socketChannel = this.connectClientSocketChannel(port);\n          return socketChannel;\n        }\n      } catch (final Throwable _t) {\n        if (_t instanceof Exception) {\n          final Exception exc = (Exception)_t;\n        } else {\n          throw Exceptions.sneakyThrow(_t);\n        }\n      }\n      _xblockexpression = this.launch(portFile);\n    }\n    return _xblockexpression;\n  }","commit_id":"47b26129aef2c098155b021da97bb939ae50d127","url":"https://github.com/eclipse/xtext"},{"original_method":"public SocketChannel launch(final File lockFile) {\n    try {\n      IntegerRange _upTo = new IntegerRange(DaemonConnector.DEFAULT_PORT, (DaemonConnector.DEFAULT_PORT + 10));\n      for (final Integer port : _upTo) {\n        {\n          final RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n          String _property = System.getProperty(\"java.home\");\n          String _plus = (_property + File.separator);\n          String _plus_1 = (_plus + \"bin\");\n          String _plus_2 = (_plus_1 + File.separator);\n          final String java = (_plus_2 + \"java\");\n          final LinkedHashSet<String> classpath = CollectionLiterals.<String>newLinkedHashSet();\n          String _classPath = runtimeMxBean.getClassPath();\n          String _quote = Pattern.quote(File.pathSeparator);\n          String[] _split = _classPath.split(_quote);\n          Iterables.<String>addAll(classpath, ((Iterable<? extends String>)Conversions.doWrapArray(_split)));\n          Class<? extends DaemonConnector> _class = this.getClass();\n          final ClassLoader classLoader = _class.getClassLoader();\n          if ((classLoader instanceof URLClassLoader)) {\n            URL[] _uRLs = ((URLClassLoader)classLoader).getURLs();\n            final Procedure1<URL> _function = new Procedure1<URL>() {\n              @Override\n              public void apply(final URL it) {\n                String _protocol = it.getProtocol();\n                boolean _equals = Objects.equal(_protocol, \"file\");\n                if (_equals) {\n                  String _asPath = FilesAndURIs.asPath(it);\n                  classpath.add(_asPath);\n                }\n              }\n            };\n            IterableExtensions.<URL>forEach(((Iterable<URL>)Conversions.doWrapArray(_uRLs)), _function);\n          }\n          final ArrayList<String> command = CollectionLiterals.<String>newArrayList();\n          command.add(java);\n          command.add(\"-cp\");\n          List<String> _list = IterableExtensions.<String>toList(classpath);\n          List<String> _reverseView = ListExtensions.<String>reverseView(_list);\n          String _join = IterableExtensions.join(_reverseView, File.pathSeparator);\n          command.add(_join);\n          List<String> _inputArguments = runtimeMxBean.getInputArguments();\n          final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n            @Override\n            public Boolean apply(final String it) {\n              boolean _startsWith = it.startsWith(\"-agentlib\");\n              return Boolean.valueOf((!_startsWith));\n            }\n          };\n          Iterable<String> _filter = IterableExtensions.<String>filter(_inputArguments, _function_1);\n          Iterables.<String>addAll(command, _filter);\n          if (this.debug) {\n            command.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5006\");\n          }\n          String _canonicalName = XtextBuildDaemon.class.getCanonicalName();\n          command.add(_canonicalName);\n          command.add(\"-port\");\n          String _string = port.toString();\n          command.add(_string);\n          ProcessBuilder _processBuilder = new ProcessBuilder();\n          ProcessBuilder _command = _processBuilder.command(command);\n          final Process daemonProcess = _command.start();\n          IntegerRange _upTo_1 = new IntegerRange(0, 200);\n          for (final Integer i : _upTo_1) {\n            try {\n              SocketChannel socketChannel = SocketChannel.open();\n              socketChannel.configureBlocking(true);\n              InetAddress _byName = InetAddress.getByName(\"127.0.0.1\");\n              InetSocketAddress _inetSocketAddress = new InetSocketAddress(_byName, (port).intValue());\n              socketChannel.connect(_inetSocketAddress);\n              this.writeLockFile(lockFile, (port).intValue());\n              return socketChannel;\n            } catch (final Throwable _t) {\n              if (_t instanceof ConnectException) {\n                final ConnectException exc = (ConnectException)_t;\n                Thread.sleep(100);\n              } else {\n                throw Exceptions.sneakyThrow(_t);\n              }\n            }\n          }\n          DaemonConnector.LOG.warn((\"Failed to start daemon on port \" + port));\n          if (daemonProcess!=null) {\n            daemonProcess.destroy();\n          }\n        }\n      }\n      return null;\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":67587,"modified_method":"public SocketChannel launch(final File lockFile) {\n    try {\n      IntegerRange _upTo = new IntegerRange(DaemonConnector.DEFAULT_PORT, (DaemonConnector.DEFAULT_PORT + 10));\n      for (final Integer port : _upTo) {\n        {\n          final RuntimeMXBean runtimeMxBean = ManagementFactory.getRuntimeMXBean();\n          String _property = System.getProperty(\"java.home\");\n          String _plus = (_property + File.separator);\n          String _plus_1 = (_plus + \"bin\");\n          String _plus_2 = (_plus_1 + File.separator);\n          final String java = (_plus_2 + \"java\");\n          final LinkedHashSet<String> classpath = CollectionLiterals.<String>newLinkedHashSet();\n          String _classPath = runtimeMxBean.getClassPath();\n          String _quote = Pattern.quote(File.pathSeparator);\n          String[] _split = _classPath.split(_quote);\n          Iterables.<String>addAll(classpath, ((Iterable<? extends String>)Conversions.doWrapArray(_split)));\n          Class<? extends DaemonConnector> _class = this.getClass();\n          final ClassLoader classLoader = _class.getClassLoader();\n          if ((classLoader instanceof URLClassLoader)) {\n            URL[] _uRLs = ((URLClassLoader)classLoader).getURLs();\n            final Procedure1<URL> _function = new Procedure1<URL>() {\n              @Override\n              public void apply(final URL it) {\n                String _protocol = it.getProtocol();\n                boolean _equals = Objects.equal(_protocol, \"file\");\n                if (_equals) {\n                  String _asPath = FilesAndURIs.asPath(it);\n                  classpath.add(_asPath);\n                }\n              }\n            };\n            IterableExtensions.<URL>forEach(((Iterable<URL>)Conversions.doWrapArray(_uRLs)), _function);\n          }\n          final ArrayList<String> command = CollectionLiterals.<String>newArrayList();\n          command.add(java);\n          command.add(\"-cp\");\n          List<String> _list = IterableExtensions.<String>toList(classpath);\n          List<String> _reverseView = ListExtensions.<String>reverseView(_list);\n          String _join = IterableExtensions.join(_reverseView, File.pathSeparator);\n          command.add(_join);\n          List<String> _inputArguments = runtimeMxBean.getInputArguments();\n          final Function1<String, Boolean> _function_1 = new Function1<String, Boolean>() {\n            @Override\n            public Boolean apply(final String it) {\n              boolean _startsWith = it.startsWith(\"-agentlib\");\n              return Boolean.valueOf((!_startsWith));\n            }\n          };\n          Iterable<String> _filter = IterableExtensions.<String>filter(_inputArguments, _function_1);\n          Iterables.<String>addAll(command, _filter);\n          if (this.debug) {\n            command.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5006\");\n          }\n          String _canonicalName = XtextBuildDaemon.class.getCanonicalName();\n          command.add(_canonicalName);\n          command.add(\"-port\");\n          String _string = port.toString();\n          command.add(_string);\n          ProcessBuilder _processBuilder = new ProcessBuilder();\n          ProcessBuilder _command = _processBuilder.command(command);\n          final Process daemonProcess = _command.start();\n          IntegerRange _upTo_1 = new IntegerRange(0, 200);\n          for (final Integer i : _upTo_1) {\n            try {\n              SocketChannel socketChannel = this.connectClientSocketChannel((port).intValue());\n              this.writeLockFile(lockFile, (port).intValue());\n              return socketChannel;\n            } catch (final Throwable _t) {\n              if (_t instanceof ConnectException) {\n                final ConnectException exc = (ConnectException)_t;\n                Thread.sleep(100);\n              } else {\n                throw Exceptions.sneakyThrow(_t);\n              }\n            }\n          }\n          DaemonConnector.LOG.warn((\"Failed to start daemon on port \" + port));\n          if (daemonProcess!=null) {\n            daemonProcess.destroy();\n          }\n        }\n      }\n      return null;\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"47b26129aef2c098155b021da97bb939ae50d127","url":"https://github.com/eclipse/xtext"},{"original_method":"public void writeObject(final Serializable o) {\n    try {\n      this.outputBuffer.clear();\n      final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      final ObjectOutputStream oos = new ObjectOutputStream(baos);\n      try {\n        oos.writeObject(o);\n        final byte[] bytes = baos.toByteArray();\n        int _length = bytes.length;\n        this.outputBuffer.putInt(_length);\n        int offset = 0;\n        while (((bytes.length - offset) > 0)) {\n          {\n            int _remaining = this.outputBuffer.remaining();\n            int _length_1 = bytes.length;\n            int _minus = (_length_1 - offset);\n            int numBytes = Math.min(_remaining, _minus);\n            this.outputBuffer.put(bytes, offset, numBytes);\n            this.outputBuffer.flip();\n            this.outputChannel.write(this.outputBuffer);\n            this.outputBuffer.clear();\n            int _offset = offset;\n            offset = (_offset + numBytes);\n          }\n        }\n      } finally {\n        oos.close();\n      }\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","id":67588,"modified_method":"public void writeObject(final Serializable o) {\n    try {\n      this.outputBuffer.clear();\n      final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      final ObjectOutputStream oos = new ObjectOutputStream(baos);\n      try {\n        oos.writeObject(o);\n        final byte[] bytes = baos.toByteArray();\n        int _length = bytes.length;\n        this.outputBuffer.putInt(_length);\n        int offset = 0;\n        while (((bytes.length - offset) > 0)) {\n          {\n            int _remaining = this.outputBuffer.remaining();\n            int _length_1 = bytes.length;\n            int _minus = (_length_1 - offset);\n            int numBytes = Math.min(_remaining, _minus);\n            this.outputBuffer.put(bytes, offset, numBytes);\n            this.outputBuffer.flip();\n            while (this.outputBuffer.hasRemaining()) {\n              this.outputChannel.write(this.outputBuffer);\n            }\n            this.outputBuffer.clear();\n            int _offset = offset;\n            offset = (_offset + numBytes);\n          }\n        }\n      } finally {\n        oos.close();\n      }\n    } catch (Throwable _e) {\n      throw Exceptions.sneakyThrow(_e);\n    }\n  }","commit_id":"47b26129aef2c098155b021da97bb939ae50d127","url":"https://github.com/eclipse/xtext"},{"original_method":"public void run(final XtextBuildDaemon.Arguments arguments) {\n      try {\n        ServerSocket serverSocket = null;\n        try {\n          XtextBuildDaemon.LOG.info(((\"Starting xtext build daemon at port \" + Integer.valueOf(arguments.port)) + \"...\"));\n          SelectorProvider _provider = SelectorProvider.provider();\n          final AbstractSelector socketSelector = _provider.openSelector();\n          final ServerSocketChannel serverChannel = ServerSocketChannel.open();\n          serverChannel.configureBlocking(false);\n          InetAddress _byName = InetAddress.getByName(\"127.0.0.1\");\n          final InetSocketAddress socketAddress = new InetSocketAddress(_byName, arguments.port);\n          ServerSocket _socket = serverChannel.socket();\n          _socket.bind(socketAddress);\n          serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n          XtextBuildDaemon.LOG.info(\"... success\");\n          long currentTimeout = arguments.initialTimeout;\n          boolean shutdown = false;\n          while ((!shutdown)) {\n            {\n              XtextBuildDaemon.LOG.info(\"Accepting connections...\");\n              try {\n                socketSelector.select(currentTimeout);\n                Set<SelectionKey> _selectedKeys = socketSelector.selectedKeys();\n                for (final SelectionKey key : _selectedKeys) {\n                  boolean _isAcceptable = key.isAcceptable();\n                  if (_isAcceptable) {\n                    SocketChannel socketChannel = null;\n                    try {\n                      SocketChannel _accept = serverChannel.accept();\n                      socketChannel = _accept;\n                      boolean _equals = Objects.equal(socketChannel, null);\n                      if (_equals) {\n                        XtextBuildDaemon.LOG.info(((\"No requests within \" + Long.valueOf(currentTimeout)) + \"ms.\"));\n                        shutdown = true;\n                      } else {\n                        socketChannel.configureBlocking(true);\n                        currentTimeout = arguments.timeout;\n                        boolean _serve = this.worker.serve(socketChannel);\n                        shutdown = _serve;\n                      }\n                    } finally {\n                      if (socketChannel!=null) {\n                        socketChannel.close();\n                      }\n                    }\n                  }\n                }\n              } catch (final Throwable _t) {\n                if (_t instanceof Exception) {\n                  final Exception exc = (Exception)_t;\n                  XtextBuildDaemon.LOG.error(\"Error during build\", exc);\n                } else {\n                  throw Exceptions.sneakyThrow(_t);\n                }\n              }\n            }\n          }\n        } catch (final Throwable _t) {\n          if (_t instanceof Exception) {\n            final Exception exc = (Exception)_t;\n            XtextBuildDaemon.LOG.error(\"Error starting server socket\", exc);\n          } else {\n            throw Exceptions.sneakyThrow(_t);\n          }\n        }\n        XtextBuildDaemon.LOG.info(\"Shutting down\");\n        if (serverSocket!=null) {\n          serverSocket.close();\n        }\n      } catch (Throwable _e) {\n        throw Exceptions.sneakyThrow(_e);\n      }\n    }","id":67589,"modified_method":"public void run(final XtextBuildDaemon.Arguments arguments) {\n      try {\n        ServerSocket serverSocket = null;\n        try {\n          XtextBuildDaemon.LOG.info(((\"Starting xtext build daemon at port \" + Integer.valueOf(arguments.port)) + \"...\"));\n          SelectorProvider _provider = SelectorProvider.provider();\n          final AbstractSelector socketSelector = _provider.openSelector();\n          final ServerSocketChannel serverChannel = ServerSocketChannel.open();\n          serverChannel.configureBlocking(false);\n          InetAddress _byName = InetAddress.getByName(\"127.0.0.1\");\n          final InetSocketAddress socketAddress = new InetSocketAddress(_byName, arguments.port);\n          ServerSocket _socket = serverChannel.socket();\n          _socket.bind(socketAddress);\n          serverChannel.register(socketSelector, SelectionKey.OP_ACCEPT);\n          XtextBuildDaemon.LOG.info(\"... success\");\n          long currentTimeout = arguments.initialTimeout;\n          boolean shutdown = false;\n          while ((!shutdown)) {\n            {\n              XtextBuildDaemon.LOG.info(\"Accepting connections...\");\n              try {\n                socketSelector.select(currentTimeout);\n                Set<SelectionKey> _selectedKeys = socketSelector.selectedKeys();\n                for (final SelectionKey key : _selectedKeys) {\n                  boolean _isAcceptable = key.isAcceptable();\n                  if (_isAcceptable) {\n                    SocketChannel socketChannel = null;\n                    try {\n                      SocketChannel _accept = serverChannel.accept();\n                      socketChannel = _accept;\n                      boolean _equals = Objects.equal(socketChannel, null);\n                      if (_equals) {\n                        XtextBuildDaemon.LOG.info(((\"No requests within \" + Long.valueOf(currentTimeout)) + \"ms.\"));\n                        shutdown = true;\n                      } else {\n                        socketChannel.configureBlocking(true);\n                        Socket _socket_1 = socketChannel.socket();\n                        _socket_1.setSendBufferSize(ObjectChannel.BUFFER_SIZE);\n                        Socket _socket_2 = socketChannel.socket();\n                        _socket_2.setReceiveBufferSize(ObjectChannel.BUFFER_SIZE);\n                        Socket _socket_3 = socketChannel.socket();\n                        _socket_3.setTcpNoDelay(true);\n                        currentTimeout = arguments.timeout;\n                        boolean _serve = this.worker.serve(socketChannel);\n                        shutdown = _serve;\n                      }\n                    } finally {\n                      if (socketChannel!=null) {\n                        socketChannel.close();\n                      }\n                    }\n                  }\n                }\n              } catch (final Throwable _t) {\n                if (_t instanceof Exception) {\n                  final Exception exc = (Exception)_t;\n                  XtextBuildDaemon.LOG.error(\"Error during build\", exc);\n                } else {\n                  throw Exceptions.sneakyThrow(_t);\n                }\n              }\n            }\n          }\n        } catch (final Throwable _t) {\n          if (_t instanceof Exception) {\n            final Exception exc = (Exception)_t;\n            XtextBuildDaemon.LOG.error(\"Error starting server socket\", exc);\n          } else {\n            throw Exceptions.sneakyThrow(_t);\n          }\n        }\n        XtextBuildDaemon.LOG.info(\"Shutting down\");\n        if (serverSocket!=null) {\n          serverSocket.close();\n        }\n      } catch (Throwable _e) {\n        throw Exceptions.sneakyThrow(_e);\n      }\n    }","commit_id":"47b26129aef2c098155b021da97bb939ae50d127","url":"https://github.com/eclipse/xtext"},{"original_method":"Connection(SocketChannel s, Address peer_addr)\n      {\n         super(s.socket(), peer_addr);\n         sock_ch = s;\n         m_readState = new ConnectionReadState(this);\n         m_readState.init();\n      }","id":67590,"modified_method":"Connection(SocketChannel s, Address peer_addr)\n      {\n         super(s.socket(), peer_addr);\n         sock_ch = s;\n         m_readState = new ConnectionReadState(this);\n      }","commit_id":"7f59bd6a472913246632b4acef79b427c5642a25","url":"https://github.com/belaban/JGroups"},{"original_method":"private void readOnce(Connection conn)\n         throws IOException\n      {\n         ConnectionReadState readState = conn.getReadState();\n         if (readState.getHandShakingStatus() != ConnectionReadState.HANDSHAKINGFIN)  // hand shaking not finished\n            if (!readForHandShaking(conn))\n            {  // not finished yet\n               return;\n            } else\n            {\n               synchronized (conns)\n               {\n                  if (conns.containsKey(conn.getPeerAddress()))\n                  {\n                     if (conn.getPeerAddress().equals(getLocalAddress()))\n                     {\n                        if (LOG.isWarnEnabled())\n                           LOG.warn(conn.getPeerAddress() + \" is myself, not put it in table twice, but still read from it\");\n                     } else\n                     {\n                        if (LOG.isWarnEnabled())\n                           LOG.warn(conn.getPeerAddress() + \" is already there, will terminate connection\");\n                        throw new IOException(conn.getPeerAddress() + \" is already there, terminate\");\n                     }\n                  } else\n                     addConnection(conn.getPeerAddress(), conn);\n               }\n               notifyConnectionOpened(conn.getPeerAddress());\n            }\n         if (!readState.isHeadFinished())\n         {  // a brand new message coming or header is not completed\n            // Begin or continue to read header\n            int size = readHeader(conn);\n            if (0 == size)\n            {  // header is not completed\n               return;\n            }\n         }\n         // Begin or continue to read body\n         if (readBody(conn) > 0)\n         { // not finish yet\n            return;\n         }\n         Address addr = conn.getPeerAddress();\n         ByteBuffer buf = readState.getReadBodyBuffer();\n         // Clear status\n         readState.bodyFinished();\n         // Assign worker thread to execute call back\n         try\n         {\n            m_requestProcessors.execute(new ExecuteTask(addr, buf));\n         } catch (InterruptedException e)\n         {\n            // Cannot do call back, what can we do?\n            // Give up handling the message then\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while assigning executor to process read request\" , e);\n         }\n      }","id":67591,"modified_method":"private void readOnce(Connection conn)\n         throws IOException\n      {\n         ConnectionReadState readState = conn.getReadState();\n         if (!readState.isHeadFinished())\n         {  // a brand new message coming or header is not completed\n            // Begin or continue to read header\n            int size = readHeader(conn);\n            if (0 == size)\n            {  // header is not completed\n               return;\n            }\n         }\n         // Begin or continue to read body\n         if (readBody(conn) > 0)\n         { // not finish yet\n            return;\n         }\n         Address addr = conn.getPeerAddress();\n         ByteBuffer buf = readState.getReadBodyBuffer();\n         // Clear status\n         readState.bodyFinished();\n         // Assign worker thread to execute call back\n         try\n         {\n            m_requestProcessors.execute(new ExecuteTask(addr, buf));\n         } catch (InterruptedException e)\n         {\n            // Cannot do call back, what can we do?\n            // Give up handling the message then\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while assigning executor to process read request\" , e);\n         }\n      }","commit_id":"7f59bd6a472913246632b4acef79b427c5642a25","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Try to obtain correct Connection (or create one if not yet existent)\n    */\n   ConnectionTable.Connection getConnection(Address dest) throws Exception\n   {\n      Connection conn = null;\n      SocketChannel sock_ch;\n\n      synchronized (conns)\n      {\n         conn = (Connection) conns.get(dest);\n         if (conn == null)\n         {\n            InetSocketAddress destAddress = new InetSocketAddress(((IpAddress) dest).getIpAddress(),\n               ((IpAddress) dest).getPort());\n            sock_ch = SocketChannel.open(destAddress);\n            conn = new Connection(sock_ch, dest);\n\n            conn.sendLocalAddress(local_addr);\n            // This outbound connection is ready\n            conn.getReadState().setHandShakingStatus(ConnectionReadState.HANDSHAKINGFIN);\n\n            // Set channel to be non-block only after hand shaking\n            try\n            {\n               sock_ch.configureBlocking(false);\n            } catch (IOException e)\n            {\n               // No way to handle the blocking socket\n               conn.destroy();\n               throw e;\n            }\n\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection send buff size from \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n               sock_ch.socket().setSendBufferSize(send_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection send buff size to \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection receive buff size from \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection receive buff size to \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n\n            int idx;\n            synchronized (m_lockNextWriteHandler)\n            {\n               idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n            }\n            conn.setupWriteHandler(m_writeHandlers[idx]);\n\n            // Put the new connection to the queue\n            try\n            {\n               synchronized (m_lockNextReadHandler)\n               {\n                  idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n               }\n               m_readHandlers[idx].add(conn);\n\n            } catch (InterruptedException e)\n            {\n               if (LOG.isWarnEnabled())\n                  LOG.warn(\"Thread (\" +Thread.currentThread().getName() + \") was interrupted, closing connection\", e);\n               // What can we do? Remove it from table then.\n               conn.destroy();\n               throw e;\n            }\n\n            // Add connection to table\n            addConnection(dest, conn);\n\n            notifyConnectionOpened(dest);\n            if (LOG.isInfoEnabled()) LOG.info(\"created socket to \" + dest);\n         }\n         return conn;\n      }\n   }","id":67592,"modified_method":"/**\n    * Try to obtain correct Connection (or create one if not yet existent)\n    */\n   ConnectionTable.Connection getConnection(Address dest) throws Exception\n   {\n      Connection conn = null;\n      SocketChannel sock_ch;\n\n      synchronized (conns)\n      {\n         conn = (Connection) conns.get(dest);\n         if (conn == null)\n         {\n            InetSocketAddress destAddress = new InetSocketAddress(((IpAddress) dest).getIpAddress(),\n               ((IpAddress) dest).getPort());\n            sock_ch = SocketChannel.open(destAddress);\n            conn = new Connection(sock_ch, dest);\n\n            conn.sendLocalAddress(local_addr);\n            // This outbound connection is ready\n\n            sock_ch.configureBlocking(false);\n\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection send buff size from \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n               sock_ch.socket().setSendBufferSize(send_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection send buff size to \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection receive buff size from \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection receive buff size to \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n\n            int idx;\n            synchronized (m_lockNextWriteHandler)\n            {\n               idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n            }\n            conn.setupWriteHandler(m_writeHandlers[idx]);\n\n            // Put the new connection to the queue\n            try\n            {\n               synchronized (m_lockNextReadHandler)\n               {\n                  idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n               }\n               m_readHandlers[idx].add(conn);\n\n            } catch (InterruptedException e)\n            {\n               if (LOG.isWarnEnabled())\n                  LOG.warn(\"Thread (\" +Thread.currentThread().getName() + \") was interrupted, closing connection\", e);\n               // What can we do? Remove it from table then.\n               conn.destroy();\n               throw e;\n            }\n\n            // Add connection to table\n            addConnection(dest, conn);\n\n            notifyConnectionOpened(dest);\n            if (LOG.isInfoEnabled()) LOG.info(\"created socket to \" + dest);\n         }\n         return conn;\n      }\n   }","commit_id":"7f59bd6a472913246632b4acef79b427c5642a25","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Acceptor thread. Continuously accept new connections and assign readhandler/writehandler\n    * to them.\n    */\n   public void run()\n   {\n      Connection conn = null;\n\n      while (m_serverSocketChannel.isOpen())\n      {\n         int num = 0;\n         try\n         {\n            num = m_acceptSelector.select();\n         } catch (IOException e)\n         {\n            if (LOG.isWarnEnabled())\n               LOG.warn(\"Select operation on listening socket failed\", e);\n            continue;   // Give up this time\n         }\n\n         if (num > 0)\n         {\n            Set readyKeys = m_acceptSelector.selectedKeys();\n            for (Iterator i = readyKeys.iterator(); i.hasNext();)\n            {\n               SelectionKey key = (SelectionKey) i.next();\n               i.remove();\n               // We only deal with new incoming connections\n\n               ServerSocketChannel readyChannel = (ServerSocketChannel) key.channel();\n               SocketChannel client_sock_ch = null;\n               try\n               {\n                  client_sock_ch = readyChannel.accept();\n               } catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to accept new connection from listening socket failed\" , e);\n                  // Give up this connection\n                  continue;\n               }\n\n               if (LOG.isInfoEnabled())\n                  LOG.info(\"accepted connection, client_sock=\" + client_sock_ch.socket());\n\n               try\n               {\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection send buff size from \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setSendBufferSize(send_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection send buff size to \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" ,ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" , e);\n               }\n               try\n               {\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection receive buff size from \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection receive buff size to \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     send_buf_size + \" bytes: \" , ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     recv_buf_size + \" bytes: \" , e);\n               }\n\n               conn = new Connection(client_sock_ch, null);\n\n               // Set it to be nonblocking\n               try\n               {\n                  client_sock_ch.configureBlocking(false);\n\n                  int idx;\n                  synchronized (m_lockNextWriteHandler)\n                  {\n                     idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n                  }\n                  conn.setupWriteHandler(m_writeHandlers[idx]);\n\n               } catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure accepted connection failed\" , e);\n                  // Give up this connection if we cannot set it to non-block\n                  conn.destroy();\n                  continue;\n               }\n               catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure accepted connection was interrupted\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n\n               try\n               {\n                  int idx;\n                  synchronized (m_lockNextReadHandler)\n                  {\n                     idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n                  }\n                  m_readHandlers[idx].add(conn);\n\n               } catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure read handler for accepted connection failed\" , e);\n                  // What can we do? Remove it from table then. -- not in table yet since we moved hand shaking\n                  conn.destroy();\n               }\n            }   // end of iteration\n         }   // end of selected key > 0\n      }   // end of thread\n      if (LOG.isTraceEnabled())\n         LOG.trace(\"acceptor thread terminated\");\n\n   }","id":67593,"modified_method":"/**\n    * Acceptor thread. Continuously accept new connections and assign readhandler/writehandler\n    * to them.\n    */\n   public void run()\n   {\n      Connection conn = null;\n\n      while (m_serverSocketChannel.isOpen())\n      {\n         int num = 0;\n         try\n         {\n            num = m_acceptSelector.select();\n         } catch (IOException e)\n         {\n            if (LOG.isWarnEnabled())\n               LOG.warn(\"Select operation on listening socket failed\", e);\n            continue;   // Give up this time\n         }\n\n         if (num > 0)\n         {\n            Set readyKeys = m_acceptSelector.selectedKeys();\n            for (Iterator i = readyKeys.iterator(); i.hasNext();)\n            {\n               SelectionKey key = (SelectionKey) i.next();\n               i.remove();\n               // We only deal with new incoming connections\n\n               ServerSocketChannel readyChannel = (ServerSocketChannel) key.channel();\n               SocketChannel client_sock_ch = null;\n               try\n               {\n                  client_sock_ch = readyChannel.accept();\n               } catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to accept new connection from listening socket failed\" , e);\n                  // Give up this connection\n                  continue;\n               }\n\n               if (LOG.isInfoEnabled())\n                  LOG.info(\"accepted connection, client_sock=\" + client_sock_ch.socket());\n\n               try {\n\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection send buff size from \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setSendBufferSize(send_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection send buff size to \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" ,ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" , e);\n               }\n\n               try\n               {\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection receive buff size from \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection receive buff size to \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     send_buf_size + \" bytes: \" , ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     recv_buf_size + \" bytes: \" , e);\n               }\n\n               conn = new Connection(client_sock_ch, null);\n               try\n               {\n                  conn.peer_addr = conn.readPeerAddress(client_sock_ch.socket());\n\n                  synchronized (conns)\n                  {\n                     if (conns.containsKey(conn.getPeerAddress()))\n                     {\n                        if (conn.getPeerAddress().equals(getLocalAddress()))\n                        {\n                           if (LOG.isWarnEnabled())\n                              LOG.warn(conn.getPeerAddress() + \" is myself, not put it in table twice, but still read from it\");\n                        } else\n                        {\n                           if (LOG.isWarnEnabled())\n                              LOG.warn(conn.getPeerAddress() + \" is already there, will terminate connection\");\n                           // keep existing connection, close this new one\n                           Address peerAddr = conn.getPeerAddress();\n                           conn.destroy();\n                           continue;\n                        }\n                     } else {\n                        addConnection(conn.getPeerAddress(), conn);\n                     }\n                  }\n                  notifyConnectionOpened(conn.getPeerAddress());\n                  client_sock_ch.configureBlocking(false);\n               }\n               catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure non-blocking mode failed\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n               catch (Exception e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to handshake with other peer failed\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n\n               try\n               {\n                  int idx;\n                  synchronized (m_lockNextWriteHandler)\n                  {\n                     idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n                  }\n                  conn.setupWriteHandler(m_writeHandlers[idx]);\n\n               }\n               catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure accepted connection was interrupted\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n\n               try\n               {\n                  int idx;\n                  synchronized (m_lockNextReadHandler)\n                  {\n                     idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n                  }\n                  m_readHandlers[idx].add(conn);\n\n               } catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure read handler for accepted connection failed\" , e);\n                  // What can we do? Remove it from table then. -- not in table yet since we moved hand shaking\n                  conn.destroy();\n               }\n            }   // end of iteration\n         }   // end of selected key > 0\n      }   // end of thread\n      if (LOG.isTraceEnabled())\n         LOG.trace(\"acceptor thread terminated\");\n\n   }","commit_id":"7f59bd6a472913246632b4acef79b427c5642a25","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Acceptor thread. Continuously accept new connections and assign readhandler/writehandler\n    * to them.\n    */\n   public void run()\n   {\n      Connection conn = null;\n\n      while (m_serverSocketChannel.isOpen())\n      {\n         int num = 0;\n         try\n         {\n            num = m_acceptSelector.select();\n         } catch (IOException e)\n         {\n            if (LOG.isWarnEnabled())\n               LOG.warn(\"Select operation on listening socket failed\", e);\n            continue;   // Give up this time\n         }\n\n         if (num > 0)\n         {\n            Set readyKeys = m_acceptSelector.selectedKeys();\n            for (Iterator i = readyKeys.iterator(); i.hasNext();)\n            {\n               SelectionKey key = (SelectionKey) i.next();\n               i.remove();\n               // We only deal with new incoming connections\n\n               ServerSocketChannel readyChannel = (ServerSocketChannel) key.channel();\n               SocketChannel client_sock_ch = null;\n               try\n               {\n                  client_sock_ch = readyChannel.accept();\n               } catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to accept new connection from listening socket failed\" , e);\n                  // Give up this connection\n                  continue;\n               }\n\n               if (LOG.isInfoEnabled())\n                  LOG.info(\"accepted connection, client_sock=\" + client_sock_ch.socket());\n\n               try\n               {\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection send buff size from \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setSendBufferSize(send_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection send buff size to \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" ,ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" , e);\n               }\n               try\n               {\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection receive buff size from \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection receive buff size to \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     send_buf_size + \" bytes: \" , ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     recv_buf_size + \" bytes: \" , e);\n               }\n\n               conn = new Connection(client_sock_ch, null);\n\n               // Set it to be nonblocking\n               try\n               {\n                  client_sock_ch.configureBlocking(false);\n\n                  int idx;\n                  synchronized (m_lockNextWriteHandler)\n                  {\n                     idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n                  }\n                  conn.setupWriteHandler(m_writeHandlers[idx]);\n\n               } catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure accepted connection failed\" , e);\n                  // Give up this connection if we cannot set it to non-block\n                  conn.destroy();\n                  continue;\n               }\n               catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure accepted connection was interrupted\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n\n               try\n               {\n                  int idx;\n                  synchronized (m_lockNextReadHandler)\n                  {\n                     idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n                  }\n                  m_readHandlers[idx].add(conn);\n\n               } catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure read handler for accepted connection failed\" , e);\n                  // What can we do? Remove it from table then. -- not in table yet since we moved hand shaking\n                  conn.destroy();\n               }\n            }   // end of iteration\n         }   // end of selected key > 0\n      }   // end of thread\n      if (LOG.isTraceEnabled())\n         LOG.trace(\"acceptor thread terminated\");\n\n   }","id":67594,"modified_method":"/**\n    * Acceptor thread. Continuously accept new connections and assign readhandler/writehandler\n    * to them.\n    */\n   public void run()\n   {\n      Connection conn = null;\n\n      while (m_serverSocketChannel.isOpen())\n      {\n         int num = 0;\n         try\n         {\n            num = m_acceptSelector.select();\n         } catch (IOException e)\n         {\n            if (LOG.isWarnEnabled())\n               LOG.warn(\"Select operation on listening socket failed\", e);\n            continue;   // Give up this time\n         }\n\n         if (num > 0)\n         {\n            Set readyKeys = m_acceptSelector.selectedKeys();\n            for (Iterator i = readyKeys.iterator(); i.hasNext();)\n            {\n               SelectionKey key = (SelectionKey) i.next();\n               i.remove();\n               // We only deal with new incoming connections\n\n               ServerSocketChannel readyChannel = (ServerSocketChannel) key.channel();\n               SocketChannel client_sock_ch = null;\n               try\n               {\n                  client_sock_ch = readyChannel.accept();\n               } catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to accept new connection from listening socket failed\" , e);\n                  // Give up this connection\n                  continue;\n               }\n\n               if (LOG.isInfoEnabled())\n                  LOG.info(\"accepted connection, client_sock=\" + client_sock_ch.socket());\n\n               try {\n\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection send buff size from \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setSendBufferSize(send_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection send buff size to \" + client_sock_ch.socket().getSendBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" ,ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                     send_buf_size + \" bytes: \" , e);\n               }\n\n               try\n               {\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"About to change new connection receive buff size from \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n                  client_sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n                  if (LOG.isTraceEnabled())\n                     LOG.trace(\"Changed new connection receive buff size to \" + client_sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               }\n               catch (IllegalArgumentException ex)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     send_buf_size + \" bytes: \" , ex);\n               }\n               catch (SocketException e)\n               {\n                  if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                     recv_buf_size + \" bytes: \" , e);\n               }\n\n               conn = new Connection(client_sock_ch, null);\n               try\n               {\n                  conn.peer_addr = conn.readPeerAddress(client_sock_ch.socket());\n\n                  synchronized (conns)\n                  {\n                     if (conns.containsKey(conn.getPeerAddress()))\n                     {\n                        if (conn.getPeerAddress().equals(getLocalAddress()))\n                        {\n                           if (LOG.isWarnEnabled())\n                              LOG.warn(conn.getPeerAddress() + \" is myself, not put it in table twice, but still read from it\");\n                        } else\n                        {\n                           if (LOG.isWarnEnabled())\n                              LOG.warn(conn.getPeerAddress() + \" is already there, will terminate connection\");\n                           // keep existing connection, close this new one\n                           Address peerAddr = conn.getPeerAddress();\n                           conn.destroy();\n                           continue;\n                        }\n                     } else {\n                        addConnection(conn.getPeerAddress(), conn);\n                     }\n                  }\n                  notifyConnectionOpened(conn.getPeerAddress());\n                  client_sock_ch.configureBlocking(false);\n               }\n               catch (IOException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure non-blocking mode failed\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n               catch (Exception e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to handshake with other peer failed\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n\n               try\n               {\n                  int idx;\n                  synchronized (m_lockNextWriteHandler)\n                  {\n                     idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n                  }\n                  conn.setupWriteHandler(m_writeHandlers[idx]);\n\n               }\n               catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure accepted connection was interrupted\", e);\n                  // Give up this connection\n                  conn.destroy();\n                  continue;\n               }\n\n               try\n               {\n                  int idx;\n                  synchronized (m_lockNextReadHandler)\n                  {\n                     idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n                  }\n                  m_readHandlers[idx].add(conn);\n\n               } catch (InterruptedException e)\n               {\n                  if (LOG.isWarnEnabled())\n                     LOG.warn(\"Attempt to configure read handler for accepted connection failed\" , e);\n                  // What can we do? Remove it from table then. -- not in table yet since we moved hand shaking\n                  conn.destroy();\n               }\n            }   // end of iteration\n         }   // end of selected key > 0\n      }   // end of thread\n      if (LOG.isTraceEnabled())\n         LOG.trace(\"acceptor thread terminated\");\n\n   }","commit_id":"7f130a350fecc62ce608e5faf5f28e6786430352","url":"https://github.com/belaban/JGroups"},{"original_method":"private void readOnce(Connection conn)\n         throws IOException\n      {\n         ConnectionReadState readState = conn.getReadState();\n         if (readState.getHandShakingStatus() != ConnectionReadState.HANDSHAKINGFIN)  // hand shaking not finished\n            if (!readForHandShaking(conn))\n            {  // not finished yet\n               return;\n            } else\n            {\n               synchronized (conns)\n               {\n                  if (conns.containsKey(conn.getPeerAddress()))\n                  {\n                     if (conn.getPeerAddress().equals(getLocalAddress()))\n                     {\n                        if (LOG.isWarnEnabled())\n                           LOG.warn(conn.getPeerAddress() + \" is myself, not put it in table twice, but still read from it\");\n                     } else\n                     {\n                        if (LOG.isWarnEnabled())\n                           LOG.warn(conn.getPeerAddress() + \" is already there, will terminate connection\");\n                        throw new IOException(conn.getPeerAddress() + \" is already there, terminate\");\n                     }\n                  } else\n                     addConnection(conn.getPeerAddress(), conn);\n               }\n               notifyConnectionOpened(conn.getPeerAddress());\n            }\n         if (!readState.isHeadFinished())\n         {  // a brand new message coming or header is not completed\n            // Begin or continue to read header\n            int size = readHeader(conn);\n            if (0 == size)\n            {  // header is not completed\n               return;\n            }\n         }\n         // Begin or continue to read body\n         if (readBody(conn) > 0)\n         { // not finish yet\n            return;\n         }\n         Address addr = conn.getPeerAddress();\n         ByteBuffer buf = readState.getReadBodyBuffer();\n         // Clear status\n         readState.bodyFinished();\n         // Assign worker thread to execute call back\n         try\n         {\n            m_requestProcessors.execute(new ExecuteTask(addr, buf));\n         } catch (InterruptedException e)\n         {\n            // Cannot do call back, what can we do?\n            // Give up handling the message then\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while assigning executor to process read request\" , e);\n         }\n      }","id":67595,"modified_method":"private void readOnce(Connection conn)\n         throws IOException\n      {\n         ConnectionReadState readState = conn.getReadState();\n         if (!readState.isHeadFinished())\n         {  // a brand new message coming or header is not completed\n            // Begin or continue to read header\n            int size = readHeader(conn);\n            if (0 == size)\n            {  // header is not completed\n               return;\n            }\n         }\n         // Begin or continue to read body\n         if (readBody(conn) > 0)\n         { // not finish yet\n            return;\n         }\n         Address addr = conn.getPeerAddress();\n         ByteBuffer buf = readState.getReadBodyBuffer();\n         // Clear status\n         readState.bodyFinished();\n         // Assign worker thread to execute call back\n         try\n         {\n            m_requestProcessors.execute(new ExecuteTask(addr, buf));\n         } catch (InterruptedException e)\n         {\n            // Cannot do call back, what can we do?\n            // Give up handling the message then\n            LOG.error(\"Thread (\"+Thread.currentThread().getName() +\") was interrupted while assigning executor to process read request\" , e);\n         }\n      }","commit_id":"7f130a350fecc62ce608e5faf5f28e6786430352","url":"https://github.com/belaban/JGroups"},{"original_method":"Connection(SocketChannel s, Address peer_addr)\n      {\n         super(s.socket(), peer_addr);\n         sock_ch = s;\n         m_readState = new ConnectionReadState(this);\n         m_readState.init();\n      }","id":67596,"modified_method":"Connection(SocketChannel s, Address peer_addr)\n      {\n         super(s.socket(), peer_addr);\n         sock_ch = s;\n         m_readState = new ConnectionReadState(this);\n      }","commit_id":"7f130a350fecc62ce608e5faf5f28e6786430352","url":"https://github.com/belaban/JGroups"},{"original_method":"/**\n    * Try to obtain correct Connection (or create one if not yet existent)\n    */\n   ConnectionTable.Connection getConnection(Address dest) throws Exception\n   {\n      Connection conn = null;\n      SocketChannel sock_ch;\n\n      synchronized (conns)\n      {\n         conn = (Connection) conns.get(dest);\n         if (conn == null)\n         {\n            InetSocketAddress destAddress = new InetSocketAddress(((IpAddress) dest).getIpAddress(),\n               ((IpAddress) dest).getPort());\n            sock_ch = SocketChannel.open(destAddress);\n            conn = new Connection(sock_ch, dest);\n\n            conn.sendLocalAddress(local_addr);\n            // This outbound connection is ready\n            conn.getReadState().setHandShakingStatus(ConnectionReadState.HANDSHAKINGFIN);\n\n            // Set channel to be non-block only after hand shaking\n            try\n            {\n               sock_ch.configureBlocking(false);\n            } catch (IOException e)\n            {\n               // No way to handle the blocking socket\n               conn.destroy();\n               throw e;\n            }\n\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection send buff size from \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n               sock_ch.socket().setSendBufferSize(send_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection send buff size to \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection receive buff size from \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection receive buff size to \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n\n            int idx;\n            synchronized (m_lockNextWriteHandler)\n            {\n               idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n            }\n            conn.setupWriteHandler(m_writeHandlers[idx]);\n\n            // Put the new connection to the queue\n            try\n            {\n               synchronized (m_lockNextReadHandler)\n               {\n                  idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n               }\n               m_readHandlers[idx].add(conn);\n\n            } catch (InterruptedException e)\n            {\n               if (LOG.isWarnEnabled())\n                  LOG.warn(\"Thread (\" +Thread.currentThread().getName() + \") was interrupted, closing connection\", e);\n               // What can we do? Remove it from table then.\n               conn.destroy();\n               throw e;\n            }\n\n            // Add connection to table\n            addConnection(dest, conn);\n\n            notifyConnectionOpened(dest);\n            if (LOG.isInfoEnabled()) LOG.info(\"created socket to \" + dest);\n         }\n         return conn;\n      }\n   }","id":67597,"modified_method":"/**\n    * Try to obtain correct Connection (or create one if not yet existent)\n    */\n   ConnectionTable.Connection getConnection(Address dest) throws Exception\n   {\n      Connection conn = null;\n      SocketChannel sock_ch;\n\n      synchronized (conns)\n      {\n         conn = (Connection) conns.get(dest);\n         if (conn == null)\n         {\n            InetSocketAddress destAddress = new InetSocketAddress(((IpAddress) dest).getIpAddress(),\n               ((IpAddress) dest).getPort());\n            sock_ch = SocketChannel.open(destAddress);\n            conn = new Connection(sock_ch, dest);\n\n            conn.sendLocalAddress(local_addr);\n            // This outbound connection is ready\n\n            sock_ch.configureBlocking(false);\n\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection send buff size from \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n               sock_ch.socket().setSendBufferSize(send_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection send buff size to \" + sock_ch.socket().getSendBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting send buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n            try\n            {\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"About to change new connection receive buff size from \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n               sock_ch.socket().setReceiveBufferSize(recv_buf_size);\n               if (LOG.isTraceEnabled())\n                  LOG.trace(\"Changed new connection receive buff size to \" + sock_ch.socket().getReceiveBufferSize() + \" bytes\");\n            }\n            catch (IllegalArgumentException ex)\n            {\n               if (log.isErrorEnabled()) log.error(\"exception setting receive buffer size to \" +\n                  send_buf_size + \" bytes: \" + ex);\n            }\n\n            int idx;\n            synchronized (m_lockNextWriteHandler)\n            {\n               idx = m_nextWriteHandler = (m_nextWriteHandler + 1) % m_writeHandlers.length;\n            }\n            conn.setupWriteHandler(m_writeHandlers[idx]);\n\n            // Put the new connection to the queue\n            try\n            {\n               synchronized (m_lockNextReadHandler)\n               {\n                  idx = m_nextReadHandler = (m_nextReadHandler + 1) % m_readHandlers.length;\n               }\n               m_readHandlers[idx].add(conn);\n\n            } catch (InterruptedException e)\n            {\n               if (LOG.isWarnEnabled())\n                  LOG.warn(\"Thread (\" +Thread.currentThread().getName() + \") was interrupted, closing connection\", e);\n               // What can we do? Remove it from table then.\n               conn.destroy();\n               throw e;\n            }\n\n            // Add connection to table\n            addConnection(dest, conn);\n\n            notifyConnectionOpened(dest);\n            if (LOG.isInfoEnabled()) LOG.info(\"created socket to \" + dest);\n         }\n         return conn;\n      }\n   }","commit_id":"7f130a350fecc62ce608e5faf5f28e6786430352","url":"https://github.com/belaban/JGroups"},{"original_method":"private static void align(File referenceFile, File bwtFile, File rbwtFile, File suffixArrayFile, File reverseSuffixArrayFile, File bamFile) throws FileNotFoundException {\n        Aligner aligner = new BWAAligner(bwtFile,rbwtFile,suffixArrayFile,reverseSuffixArrayFile);\n        int count = 0;\n\n        SAMFileReader reader = new SAMFileReader(bamFile);\n        reader.setValidationStringency(SAMFileReader.ValidationStringency.SILENT);\n\n        for(SAMRecord read: reader) {\n            count++;\n            //if( count > 25000 ) break;\n            //if( count != 39 ) continue;\n            //if( !read.getReadName().endsWith(\"1507:1636#0\") )\n            //    continue;\n\n            SAMRecord alignmentCleaned = null;\n            try {\n                alignmentCleaned = (SAMRecord)read.clone();\n            }\n            catch( CloneNotSupportedException ex ) {\n                throw new StingException(\"SAMRecord clone not supported\", ex);\n            }\n\n            if( alignmentCleaned.getReadNegativeStrandFlag() )\n                alignmentCleaned.setReadBases(BaseUtils.simpleReverseComplement(alignmentCleaned.getReadBases()));\n\n            alignmentCleaned.setReferenceIndex(SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX);\n            alignmentCleaned.setAlignmentStart(SAMRecord.NO_ALIGNMENT_START);\n            alignmentCleaned.setMappingQuality(SAMRecord.NO_MAPPING_QUALITY);\n            alignmentCleaned.setCigarString(SAMRecord.NO_ALIGNMENT_CIGAR);\n\n            // Clear everything except flags pertaining to pairing and set 'unmapped' status to true.\n            alignmentCleaned.setFlags(alignmentCleaned.getFlags() & 0x00A1 | 0x000C);\n\n            List<Alignment> alignments = aligner.align(alignmentCleaned);\n            if(alignments.size() == 0 )\n                throw new StingException(String.format(\"Unable to align read %s to reference; count = %d\",read.getReadName(),count));\n\n            Alignment alignment = alignments.get(0);\n\n            System.out.printf(\"%s: Aligned read to reference at position %d with %d mismatches, %d gap opens, and %d gap extensions.%n\", read.getReadName(), alignment.getAlignmentStart(), alignment.getMismatches(), alignment.getGapOpens(), alignment.getGapExtensions());\n\n            if( read.getReadNegativeStrandFlag() != alignment.isNegativeStrand() )\n                throw new StingException(\"Read has been aligned in wrong direction\");\n\n            if( read.getAlignmentStart() != alignment.getAlignmentStart() ) {\n                IndexedFastaSequenceFile reference = new IndexedFastaSequenceFile(referenceFile);\n                String expectedRef = new String(reference.getSubsequenceAt(reference.getSequenceDictionary().getSequences().get(0).getSequenceName(),read.getAlignmentStart(),read.getAlignmentStart()+read.getReadLength()-1).getBases());\n                int expectedMismatches = 0;\n                for( int i = 0; i < read.getReadLength(); i++ ) {\n                    if( read.getReadBases()[i] != expectedRef.charAt(i) )\n                        expectedMismatches++;\n                }\n\n                String alignedRef = new String(reference.getSubsequenceAt(reference.getSequenceDictionary().getSequences().get(0).getSequenceName(),alignments.get(0).getAlignmentStart(),alignments.get(0).getAlignmentStart()+read.getReadLength()-1).getBases());\n                int actualMismatches = 0;\n                for( int i = 0; i < read.getReadLength(); i++ ) {\n                    if( read.getReadBases()[i] != alignedRef.charAt(i) )\n                        actualMismatches++;\n                }\n\n                if( expectedMismatches != actualMismatches ) {\n                    System.out.printf(\"read          = %s%n\", read.getReadString());\n                    System.out.printf(\"expected ref  = %s%n\", expectedRef);\n                    System.out.printf(\"actual ref    = %s%n\", alignedRef);\n                    throw new StingException(String.format(\"Read %s was placed at incorrect location; target alignment = %d; actual alignment = %d%n\",read.getReadName(),read.getAlignmentStart(),alignment.getAlignmentStart()));\n                }\n            }\n\n            if( count % 1000 == 0 )\n                System.out.printf(\"%d reads examined.%n\",count);                \n        }\n\n        System.out.printf(\"%d reads examined.%n\",count);\n    }","id":67598,"modified_method":"private static void align(File referenceFile, File bwtFile, File rbwtFile, File suffixArrayFile, File reverseSuffixArrayFile, File bamFile) throws FileNotFoundException {\n        Aligner aligner = new BWAAligner(bwtFile,rbwtFile,suffixArrayFile,reverseSuffixArrayFile);\n        int count = 0;\n\n        SAMFileReader reader = new SAMFileReader(bamFile);\n        reader.setValidationStringency(SAMFileReader.ValidationStringency.SILENT);\n\n        int mismatches = 0;        \n\n        for(SAMRecord read: reader) {\n            count++;\n            if( count > 10000 ) break;\n            //if( count != 2 ) continue;\n            //if( !read.getReadName().endsWith(\"1507:1636#0\") )\n            //    continue;\n\n            SAMRecord alignmentCleaned = null;\n            try {\n                alignmentCleaned = (SAMRecord)read.clone();\n            }\n            catch( CloneNotSupportedException ex ) {\n                throw new StingException(\"SAMRecord clone not supported\", ex);\n            }\n\n            if( alignmentCleaned.getReadNegativeStrandFlag() )\n                alignmentCleaned.setReadBases(BaseUtils.simpleReverseComplement(alignmentCleaned.getReadBases()));\n\n            alignmentCleaned.setReferenceIndex(SAMRecord.NO_ALIGNMENT_REFERENCE_INDEX);\n            alignmentCleaned.setAlignmentStart(SAMRecord.NO_ALIGNMENT_START);\n            alignmentCleaned.setMappingQuality(SAMRecord.NO_MAPPING_QUALITY);\n            alignmentCleaned.setCigarString(SAMRecord.NO_ALIGNMENT_CIGAR);\n\n            // Clear everything except flags pertaining to pairing and set 'unmapped' status to true.\n            alignmentCleaned.setFlags(alignmentCleaned.getFlags() & 0x00A1 | 0x000C);\n\n            List<Alignment> alignments = aligner.align(alignmentCleaned);\n            if(alignments.size() == 0 )\n                throw new StingException(String.format(\"Unable to align read %s to reference; count = %d\",read.getReadName(),count));\n\n            Alignment alignment = alignments.get(0);\n\n            System.out.printf(\"%s: Aligned read to reference at position %d with %d mismatches, %d gap opens, and %d gap extensions.%n\", read.getReadName(), alignment.getAlignmentStart(), alignment.getMismatches(), alignment.getGapOpens(), alignment.getGapExtensions());\n\n            if( read.getReadNegativeStrandFlag() != alignment.isNegativeStrand() ) {\n                System.out.println(\"Read has been aligned in wrong direction\");\n                mismatches++;\n            }\n\n            if( read.getAlignmentStart() != alignment.getAlignmentStart() ) {\n                IndexedFastaSequenceFile reference = new IndexedFastaSequenceFile(referenceFile);\n                String expectedRef = new String(reference.getSubsequenceAt(reference.getSequenceDictionary().getSequences().get(0).getSequenceName(),read.getAlignmentStart(),read.getAlignmentStart()+read.getReadLength()-1).getBases());\n                int expectedMismatches = 0;\n                for( int i = 0; i < read.getReadLength(); i++ ) {\n                    if( read.getReadBases()[i] != expectedRef.charAt(i) )\n                        expectedMismatches++;\n                }\n\n                String alignedRef = new String(reference.getSubsequenceAt(reference.getSequenceDictionary().getSequences().get(0).getSequenceName(),alignments.get(0).getAlignmentStart(),alignments.get(0).getAlignmentStart()+read.getReadLength()-1).getBases());\n                int actualMismatches = 0;\n                for( int i = 0; i < read.getReadLength(); i++ ) {\n                    if( read.getReadBases()[i] != alignedRef.charAt(i) )\n                        actualMismatches++;\n                }\n\n                if( expectedMismatches != actualMismatches ) {\n                    System.out.printf(\"read          = %s%n\", read.getReadString());\n                    System.out.printf(\"expected ref  = %s%n\", expectedRef);\n                    System.out.printf(\"actual ref    = %s%n\", alignedRef);\n                    mismatches++;\n                    //throw new StingException(String.format(\"Read %s was placed at incorrect location; target alignment = %d; actual alignment = %d; count = %d%n\",read.getReadName(),read.getAlignmentStart(),alignment.getAlignmentStart(),count));\n                }\n            }\n\n            if( count % 1000 == 0 )\n                System.out.printf(\"%d reads examined.%n\",count);                \n        }\n\n        System.out.printf(\"%d reads examined; %d mismatches.%n\",count,mismatches);\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create an seeding alignment to use as a starting point when traversing.\n     * @param bwt source BWT.\n     * @return Seed alignment.\n     */\n    private BWAAlignment createSeedAlignment(BWT bwt) {\n        BWAAlignment seed = new BWAAlignment(this);\n        seed.negativeStrand = (bwt == forwardBWT);\n        seed.position = 0;\n        seed.loBound = 0;\n        seed.hiBound = bwt.length();\n        seed.state = AlignmentState.MATCH_MISMATCH;\n        seed.mismatches = 0;\n        return seed;\n    }","id":67599,"modified_method":"/**\n     * Create an seeding alignment to use as a starting point when traversing.\n     * @param bwt source BWT.\n     * @return Seed alignment.\n     */\n    private BWAAlignment createSeedAlignment(BWT bwt) {\n        BWAAlignment seed = new BWAAlignment(this);\n        seed.negativeStrand = (bwt == forwardBWT);\n        seed.position = -1;\n        seed.loBound = 0;\n        seed.hiBound = bwt.length();\n        seed.mismatches = 0;\n        return seed;\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"public List<Alignment> align( SAMRecord read ) {\n        byte[] uncomplementedBases = read.getReadBases();\n        byte[] complementedBases = BaseUtils.reverse(BaseUtils.simpleReverseComplement(uncomplementedBases));\n\n        List<LowerBound> forwardLowerBounds = LowerBound.create(uncomplementedBases,forwardBWT);\n        List<LowerBound> reverseLowerBounds = LowerBound.create(complementedBases,reverseBWT);\n\n        /*\n        for( int i = 0; i < forwardLowerBounds.size(); i++ )\n            System.out.printf(\"ForwardBWT: lb[%d] = %s%n\",i,forwardLowerBounds.get(i));\n        for( int i = 0; i < reverseLowerBounds.size(); i++ )\n            System.out.printf(\"ReverseBWT: lb[%d] = %s%n\",i,reverseLowerBounds.get(i));\n            */\n\n        PriorityQueue<BWAAlignment> alignments = new PriorityQueue<BWAAlignment>();\n\n        // Create a fictional initial alignment, with the position just off the end of the read, and the limits\n        // set as the entire BWT.\n        alignments.add(createSeedAlignment(forwardBWT));\n        alignments.add(createSeedAlignment(reverseBWT));\n\n        while(!alignments.isEmpty()) {\n            BWAAlignment alignment = alignments.remove();\n\n            byte[] bases = alignment.negativeStrand ? complementedBases : uncomplementedBases;\n            BWT bwt = alignment.negativeStrand ? forwardBWT : reverseBWT;\n            List<LowerBound> lowerBounds = alignment.negativeStrand ? reverseLowerBounds : forwardLowerBounds;\n\n            // Done with this particular alignment.\n            if(alignment.position == read.getReadLength()-1) {\n                if( !alignment.isNegativeStrand() )\n                    alignment.alignmentStart = reverseBWT.length() - (reverseSuffixArray.get(alignment.loBound)+read.getReadLength()-alignment.gapOpens-alignment.gapExtensions) + 1;\n                else\n                    alignment.alignmentStart = forwardSuffixArray.get(alignment.loBound) + 1;\n                return Collections.<Alignment>singletonList(alignment);\n            }\n\n            //System.out.printf(\"Processing alignments; queue size = %d, alignment = %s, bound = %d%n\", alignments.size(), alignment, lowerBounds.get(alignment.position+1).value);\n\n            // if z < D(i) then return {}\n            int mismatches = MAXIMUM_EDIT_DISTANCE - alignment.mismatches - alignment.gapOpens;            \n            if( mismatches < lowerBounds.get(alignment.position+1).value )\n                continue;\n\n            if( alignment.mismatches > MAXIMUM_EDIT_DISTANCE )\n                continue;\n\n            if( alignment.state == AlignmentState.MATCH_MISMATCH ) {\n                if( alignment.gapOpens < MAXIMUM_GAP_OPENS ) {\n                    // Add a potential insertion.\n                    // Add a potential insertion extension.\n                    BWAAlignment insertionAlignment = createInsertionAlignment(alignment);\n                    insertionAlignment.gapOpens++;\n                    alignments.add(insertionAlignment);\n\n                    // Add a potential deletion by marking a deletion and augmenting the position.\n                    List<BWAAlignment> newAlignments = createDeletionAlignments(bwt,alignment);\n                    for( BWAAlignment deletionAlignment: newAlignments )\n                        deletionAlignment.gapOpens++;\n                    alignments.addAll(newAlignments);\n                }\n            }\n            else if( alignment.state == AlignmentState.INSERTION ) {\n                if( alignment.gapExtensions < MAXIMUM_GAP_EXTENSIONS ) {\n                    // Add a potential insertion extension.\n                    BWAAlignment newAlignment = createInsertionAlignment(alignment);\n                    newAlignment.gapExtensions++;\n                    alignments.add(newAlignment);\n                }\n            }\n            else if( alignment.state == AlignmentState.DELETION ) {\n                if( alignment.gapExtensions < MAXIMUM_GAP_EXTENSIONS ) {\n                    // Add a potential deletion by marking a deletion and augmenting the position.\n                    List<BWAAlignment> newAlignments = createDeletionAlignments(bwt,alignment);\n                    for( BWAAlignment newAlignment: newAlignments )\n                        newAlignment.gapExtensions++;\n                    alignments.addAll(newAlignments);\n                }\n            }\n\n            // Mismatches\n            alignments.addAll(createMatchedAlignments(bwt,alignment,bases));\n        }\n\n        return Collections.emptyList();\n    }","id":67600,"modified_method":"public List<Alignment> align( SAMRecord read ) {\n        List<Alignment> successfulMatches = new ArrayList<Alignment>();\n\n        byte[] uncomplementedBases = read.getReadBases();\n        byte[] complementedBases = BaseUtils.reverse(BaseUtils.simpleReverseComplement(uncomplementedBases));\n\n        List<LowerBound> forwardLowerBounds = LowerBound.create(uncomplementedBases,forwardBWT);\n        List<LowerBound> reverseLowerBounds = LowerBound.create(complementedBases,reverseBWT);\n\n        /*\n        for( int i = 0; i < forwardLowerBounds.size(); i++ )\n            System.out.printf(\"ForwardBWT: lb[%d] = %s%n\",i,forwardLowerBounds.get(i));\n        for( int i = 0; i < reverseLowerBounds.size(); i++ )\n            System.out.printf(\"ReverseBWT: lb[%d] = %s%n\",i,reverseLowerBounds.get(i));\n            */\n\n        // Seed the best score with any score that won't overflow on comparison.\n        int bestScore = Integer.MAX_VALUE - MISMATCH_PENALTY;\n        int bestDiff = MAXIMUM_EDIT_DISTANCE+1;\n        int maxDiff = MAXIMUM_EDIT_DISTANCE;\n\n        PriorityQueue<BWAAlignment> alignments = new PriorityQueue<BWAAlignment>();\n\n        // Create a fictional initial alignment, with the position just off the end of the read, and the limits\n        // set as the entire BWT.\n        alignments.add(createSeedAlignment(reverseBWT));\n        alignments.add(createSeedAlignment(forwardBWT));\n\n        while(!alignments.isEmpty()) {\n            BWAAlignment alignment = alignments.remove();\n\n            // From bwtgap.c in the original BWT; if the rank is worse than the best score + the mismatch PENALTY, move on.\n            if( alignment.getScore() > bestScore + MISMATCH_PENALTY )\n                break;\n\n            byte[] bases = alignment.negativeStrand ? complementedBases : uncomplementedBases;\n            BWT bwt = alignment.negativeStrand ? forwardBWT : reverseBWT;\n            List<LowerBound> lowerBounds = alignment.negativeStrand ? reverseLowerBounds : forwardLowerBounds;\n\n            // Found a valid alignment; store it and move on.\n            if(alignment.position == read.getReadLength()-1) {\n                if( !alignment.isNegativeStrand() ) {\n                    int sizeAlongReference = alignment.getNumberOfBasesMatchingState(AlignmentState.MATCH_MISMATCH)+alignment.getNumberOfBasesMatchingState(AlignmentState.DELETION);\n                    alignment.alignmentStart = reverseBWT.length() - reverseSuffixArray.get(alignment.loBound) - sizeAlongReference + 1;\n                }\n                else\n                    alignment.alignmentStart = forwardSuffixArray.get(alignment.loBound) + 1;\n                successfulMatches.add(alignment);\n\n                bestScore = Math.min(alignment.getScore(),bestScore);\n                bestDiff = Math.min(alignment.mismatches+alignment.gapOpens+alignment.gapExtensions,bestDiff);\n                maxDiff = bestDiff + 1;\n\n                continue;\n            }\n\n            //System.out.printf(\"Processing alignments; queue size = %d, alignment = %s, bound = %d, base = %s%n\", alignments.size(), alignment, lowerBounds.get(alignment.position+1).value, alignment.position >= 0 ? (char)bases[alignment.position] : \"\");\n\n            // if z < D(i) then return {}\n            int mismatches = maxDiff - alignment.mismatches - alignment.gapOpens - alignment.gapExtensions;            \n            if( mismatches < lowerBounds.get(alignment.position+1).value )\n                continue;\n\n            if( mismatches > 0 &&\n                alignment.position+1 >= INDEL_END_SKIP-1+alignment.gapOpens+alignment.gapExtensions &&\n                read.getReadLength()-1-(alignment.position+1) >= INDEL_END_SKIP+alignment.gapOpens+alignment.gapExtensions ) {\n                if( alignment.getCurrentState() == AlignmentState.MATCH_MISMATCH ) {\n                    if( alignment.gapOpens < MAXIMUM_GAP_OPENS ) {\n                        // Add a potential insertion extension.\n                        BWAAlignment insertionAlignment = createInsertionAlignment(alignment);\n                        insertionAlignment.gapOpens++;\n                        alignments.add(insertionAlignment);\n\n                        // Add a potential deletion by marking a deletion and augmenting the position.\n                        List<BWAAlignment> deletionAlignments = createDeletionAlignments(bwt,alignment);\n                        for( BWAAlignment deletionAlignment: deletionAlignments )\n                            deletionAlignment.gapOpens++;\n                        alignments.addAll(deletionAlignments);\n                    }\n                }\n                else if( alignment.getCurrentState() == AlignmentState.INSERTION ) {\n                    if( alignment.gapExtensions < MAXIMUM_GAP_EXTENSIONS && mismatches > 0 ) {\n                        // Add a potential insertion extension.\n                        BWAAlignment insertionAlignment = createInsertionAlignment(alignment);\n                        insertionAlignment.gapExtensions++;\n                        alignments.add(insertionAlignment);\n                    }\n                }\n                else if( alignment.getCurrentState() == AlignmentState.DELETION ) {\n                    if( alignment.gapExtensions < MAXIMUM_GAP_EXTENSIONS && mismatches > 0 ) {\n                        // Add a potential deletion by marking a deletion and augmenting the position.\n                        List<BWAAlignment> deletionAlignments = createDeletionAlignments(bwt,alignment);\n                        for( BWAAlignment deletionAlignment: deletionAlignments )\n                            deletionAlignment.gapExtensions++;\n                        alignments.addAll(deletionAlignments);\n                    }\n                }\n            }\n\n            // Mismatches\n            // Temporary -- look ahead to see if the next alignment is bounded.\n            boolean allowMismatches = mismatches > 0;\n            if( alignment.position+1 < read.getReadLength()-1 )\n                allowMismatches &= \n                    !(lowerBounds.get(alignment.position+2).value == mismatches-1 && lowerBounds.get(alignment.position+1).value == mismatches-1 &&\n                      lowerBounds.get(alignment.position+2).width == lowerBounds.get(alignment.position+1).width);\n            alignments.addAll(createMatchedAlignments(bwt,alignment,bases,allowMismatches));\n        }\n\n        return successfulMatches;\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Creates a new alignments representing direct matches / mismatches.\n     * @param bwt Source BWT with which to work.\n     * @param alignment Alignment for the previous position.\n     * @param bases The bases in the read.\n     * @return New alignment representing this position if valid; null otherwise.\n     */\n    private List<BWAAlignment> createMatchedAlignments( BWT bwt, BWAAlignment alignment, byte[] bases ) {\n        List<BWAAlignment> newAlignments = new ArrayList<BWAAlignment>();\n        for(Base base: EnumSet.allOf(Base.class)) {\n            BWAAlignment newAlignment = alignment.clone();\n\n            newAlignment.loBound = bwt.counts(base) + bwt.occurrences(base,alignment.loBound-1) + 1;\n            newAlignment.hiBound = bwt.counts(base) + bwt.occurrences(base,alignment.hiBound);\n\n            // If this alignment is valid, skip it.\n            if( newAlignment.loBound > newAlignment.hiBound )\n                continue;\n\n            newAlignment.position++;\n            newAlignment.state = AlignmentState.MATCH_MISMATCH;\n            if( base.toASCII() != bases[newAlignment.position] )\n                newAlignment.mismatches++;\n\n            newAlignments.add(newAlignment);\n        }\n\n        return newAlignments;\n    }","id":67601,"modified_method":"/**\n     * Creates a new alignments representing direct matches / mismatches.\n     * @param bwt Source BWT with which to work.\n     * @param alignment Alignment for the previous position.\n     * @param bases The bases in the read.\n     * @param allowMismatch Should mismatching bases be allowed?\n     * @return New alignment representing this position if valid; null otherwise.\n     */\n    private List<BWAAlignment> createMatchedAlignments( BWT bwt, BWAAlignment alignment, byte[] bases, boolean allowMismatch ) {\n        List<BWAAlignment> newAlignments = new ArrayList<BWAAlignment>();\n\n        List<Base> baseChoices = new ArrayList<Base>();\n        Base thisBase = Base.fromASCII(bases[alignment.position+1]);\n\n        if( allowMismatch )\n            baseChoices.addAll(EnumSet.allOf(Base.class));\n        else\n            baseChoices.add(thisBase);\n\n        if( thisBase != null ) {\n            // Keep rotating the current base to the last position until we've hit the current base.\n            for( ;; ) {\n                baseChoices.add(baseChoices.remove(0));\n                if( thisBase.equals(baseChoices.get(baseChoices.size()-1)) )\n                    break;\n\n            }\n        }\n\n        for(Base base: baseChoices) {\n            BWAAlignment newAlignment = alignment.clone();\n\n            newAlignment.loBound = bwt.counts(base) + bwt.occurrences(base,alignment.loBound-1) + 1;\n            newAlignment.hiBound = bwt.counts(base) + bwt.occurrences(base,alignment.hiBound);\n\n            // If this alignment is valid, skip it.\n            if( newAlignment.loBound > newAlignment.hiBound )\n                continue;\n\n            newAlignment.position++;\n            newAlignment.addState(AlignmentState.MATCH_MISMATCH);\n            if( base.toASCII() != bases[newAlignment.position] )\n                newAlignment.mismatches++;\n\n            newAlignments.add(newAlignment);\n        }\n\n        return newAlignments;\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create new alignments representing a deletion a this point in the read.\n     * @param bwt source BWT for inferring deletion info.\n     * @param alignment Alignment from which to derive the deletion.\n     * @return New alignments reflecting all possible deletions.\n     */\n    private List<BWAAlignment> createDeletionAlignments( BWT bwt, BWAAlignment alignment) {\n        List<BWAAlignment> newAlignments = new ArrayList<BWAAlignment>();\n        for(Base base: EnumSet.allOf(Base.class)) {\n            BWAAlignment newAlignment = alignment.clone();\n\n            newAlignment.loBound = bwt.counts(base) + bwt.occurrences(base,alignment.loBound-1) + 1;\n            newAlignment.hiBound = bwt.counts(base) + bwt.occurrences(base,alignment.hiBound);\n\n            // If this alignment is valid, skip it.\n            if( newAlignment.loBound > newAlignment.hiBound )\n                continue;\n\n            newAlignment.state = AlignmentState.DELETION;            \n\n            newAlignments.add(newAlignment);\n        }\n\n        return newAlignments;\n    }","id":67602,"modified_method":"/**\n     * Create new alignments representing a deletion at this point in the read.\n     * @param bwt source BWT for inferring deletion info.\n     * @param alignment Alignment from which to derive the deletion.\n     * @return New alignments reflecting all possible deletions.\n     */\n    private List<BWAAlignment> createDeletionAlignments( BWT bwt, BWAAlignment alignment) {\n        List<BWAAlignment> newAlignments = new ArrayList<BWAAlignment>();\n        for(Base base: EnumSet.allOf(Base.class)) {\n            BWAAlignment newAlignment = alignment.clone();\n\n            newAlignment.loBound = bwt.counts(base) + bwt.occurrences(base,alignment.loBound-1) + 1;\n            newAlignment.hiBound = bwt.counts(base) + bwt.occurrences(base,alignment.hiBound);\n\n            // If this alignment is valid, skip it.\n            if( newAlignment.loBound > newAlignment.hiBound )\n                continue;\n\n            newAlignment.addState(AlignmentState.DELETION);\n\n            newAlignments.add(newAlignment);\n        }\n\n        return newAlignments;\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new alignment representing an insertion at this point in the read.\n     * @param alignment Alignment from which to derive the insertion.\n     * @return New alignment reflecting the insertion.\n     */\n    private BWAAlignment createInsertionAlignment( BWAAlignment alignment ) {\n        // Add a potential insertion extension.\n        BWAAlignment newAlignment = alignment.clone();\n        newAlignment.position++;\n        newAlignment.state = AlignmentState.INSERTION;\n        return newAlignment;\n    }","id":67603,"modified_method":"/**\n     * Create a new alignment representing an insertion at this point in the read.\n     * @param alignment Alignment from which to derive the insertion.\n     * @return New alignment reflecting the insertion.\n     */\n    private BWAAlignment createInsertionAlignment( BWAAlignment alignment ) {\n        // Add a potential insertion extension.\n        BWAAlignment newAlignment = alignment.clone();\n        newAlignment.position++;\n        newAlignment.addState(AlignmentState.INSERTION);\n        return newAlignment;\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Create a new alignment with the given parent aligner.\n     * @param aligner Aligner being used.\n     */\n    public BWAAlignment( BWAAligner aligner ) {\n        this.aligner = aligner;\n    }","id":67604,"modified_method":"/**\n     * Create a new alignment with the given parent aligner.\n     * @param aligner Aligner being used.\n     */\n    public BWAAlignment( BWAAligner aligner ) {\n        this.aligner = aligner;\n        this.creationNumber = numCreated++;\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Clone the alignment.\n     * @return New instance of the alignment.\n     */\n    public BWAAlignment clone() {\n        try {\n            return (BWAAlignment)super.clone();\n        }\n        catch( CloneNotSupportedException ex ) {\n            throw new StingException(\"Unable to clone BWAAlignment.\");\n        }\n    }","id":67605,"modified_method":"/**\n     * Clone the alignment.\n     * @return New instance of the alignment.\n     */\n    public BWAAlignment clone() {\n        BWAAlignment newAlignment = null;\n        try {\n            newAlignment = (BWAAlignment)super.clone();\n        }\n        catch( CloneNotSupportedException ex ) {\n            throw new StingException(\"Unable to clone BWAAlignment.\");\n        }\n        newAlignment.creationNumber = numCreated++;\n        newAlignment.alignmentMatchSequence = alignmentMatchSequence.clone();\n\n        return newAlignment;\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * Compare this alignment to another alignment.\n     * @param other Other alignment to which to compare.\n     * @return < 0 if this < other, == 0 if this == other, > 0 if this > other\n     */\n    public int compareTo(Alignment other) {\n        // If the scores are equal, use the position to disambiguate order.\n        int scoreComparison = Integer.valueOf(getScore()).compareTo(other.getScore());\n        if( scoreComparison != 0 )\n            return scoreComparison;\n        else\n            return -Integer.valueOf(position).compareTo(((BWAAlignment)other).position);\n    }","id":67606,"modified_method":"/**\n     * Compare this alignment to another alignment.\n     * @param rhs Other alignment to which to compare.\n     * @return < 0 if this < other, == 0 if this == other, > 0 if this > other\n     */\n    public int compareTo(Alignment rhs) {\n        BWAAlignment other = (BWAAlignment)rhs;\n\n        // If the scores are equal, use the score to disambiguate.\n        int scoreComparison = Integer.valueOf(getScore()).compareTo(other.getScore());\n        if( scoreComparison != 0 )\n            return scoreComparison;\n\n        return -Long.valueOf(this.creationNumber).compareTo(other.creationNumber);\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"public String toString() {\n        return String.format(\"position: %d, state: %s, mismatches: %d, gap opens: %d, gap extensions: %d, loBound: %d, hiBound: %d, score: %d\", position, state, mismatches, gapOpens, gapExtensions, loBound, hiBound, getScore());\n    }","id":67607,"modified_method":"public String toString() {\n        return String.format(\"position: %d, state: %s, mismatches: %d, gap opens: %d, gap extensions: %d, loBound: %d, hiBound: %d, score: %d, creationNumber: %d\", position, alignmentMatchSequence.getCurrentState(), mismatches, gapOpens, gapExtensions, loBound, hiBound, getScore(), creationNumber);\n    }","commit_id":"05aa928e3e68b84d1aa01521936a042aef99c0cc","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Override\n    public Void call() throws Exception {\n\n      List<ODocument> result = null;\n      final ODatabaseDocumentTx dbServer1 = new ODatabaseDocumentTx(getPlocalDatabaseURL(serverInstance.get(0))).open(\"admin\", \"admin\");\n\n      try {\n\n        /*\n         * Test with quorum = 2\n         */\n\n        banner(\"Test with quorum = 2\");\n\n        // checking distributed configuration\n        OHazelcastPlugin manager = (OHazelcastPlugin) serverInstance.get(0).getServerInstance().getDistributedManager();\n        ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n        ODocument cfg = databaseConfiguration.serialize();\n        cfg.field(\"failureAvailableNodesLessQuorum\", true);\n        cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n        manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n        assertEquals(\"majority\", cfg.field(\"writeQuorum\"));\n\n        // network fault on server2\n        System.out.println(\"Network fault on server2.\\n\");\n        simulateServerFault(serverInstance.get(1), \"net-fault\");\n        assertFalse(serverInstance.get(1).isActive());\n\n        // network fault on server3\n        System.out.println(\"Network fault on server3.\\n\");\n        simulateServerFault(serverInstance.get(SERVERS - 1), \"net-fault\");\n        assertFalse(serverInstance.get(2).isActive());\n\n        // writes on server1\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n        try {\n          new ODocument(\"Person\").fields(\"name\", \"Jay\", \"surname\", \"Miner\").save();\n          new ODocument(\"Person\").fields(\"name\", \"Luke\", \"surname\", \"Skywalker\").save();\n          new ODocument(\"Person\").fields(\"name\", \"Yoda\", \"surname\", \"Nothing\").save();\n          assertTrue(\"Record inserted with server1 running and writeQuorum=2\", false);\n        } catch (Exception e) {\n          e.printStackTrace();\n          assertTrue(true);\n        }\n\n        // check that no records were inserted\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select count(*) from Person\"));\n        assertEquals(1, result.size());\n        assertEquals(0, ((Number) result.get(0).field(\"count\")).intValue());\n\n        // restarting server2\n        try {\n          serverInstance.get(1).startServer(getDistributedServerConfiguration(serverInstance.get(1)));\n          System.out.println(\"Server 2 restarted.\");\n          assertTrue(serverInstance.get(1).isActive());\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n\n        // writes on server1 and server2\n        executeWritesOnServers.remove(2);\n        executeMultipleWrites(executeWritesOnServers, \"plocal\");\n\n        // check consistency on server1 and server2\n        checkWritesAboveCluster(executeWritesOnServers, executeWritesOnServers);\n\n        // restarting server3\n        try {\n          serverInstance.get(2).startServer(getDistributedServerConfiguration(serverInstance.get(2)));\n          System.out.println(\"Server 2 restarted.\");\n          assertTrue(serverInstance.get(2).isActive());\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n\n        // writes on server3\n        executeWritesOnServers.add(serverInstance.get(2));\n        executeWritesOnServers.remove(serverInstance.get(0));\n        executeWritesOnServers.remove(serverInstance.get(1));\n        executeMultipleWrites(executeWritesOnServers, \"plocal\");\n\n        // check consistency\n        executeWritesOnServers.remove(serverInstance.get(2));\n        executeWritesOnServers.addAll(serverInstance);\n        checkWritesAboveCluster(serverInstance, executeWritesOnServers);\n\n      } catch (Exception e) {\n        e.printStackTrace();\n        assertTrue(e.getMessage(), false);\n      } finally {\n        if(dbServer1 != null) {\n          ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n          dbServer1.close();\n          ODatabaseRecordThreadLocal.INSTANCE.set(null);\n        }\n      }\n\n      return null;\n    }","id":67608,"modified_method":"@Override\n    public Void call() throws Exception {\n\n      List<ODocument> result = null;\n      final ODatabaseDocumentTx dbServer1 = new ODatabaseDocumentTx(getPlocalDatabaseURL(serverInstance.get(0))).open(\"admin\", \"admin\");\n\n      try {\n\n        /*\n         * Test with quorum = 2\n         */\n\n        banner(\"Test with quorum = 2\");\n\n        // checking distributed configuration\n        OHazelcastPlugin manager = (OHazelcastPlugin) serverInstance.get(0).getServerInstance().getDistributedManager();\n        ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n        ODocument cfg = databaseConfiguration.serialize();\n        cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n        manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n        assertEquals(\"majority\", cfg.field(\"writeQuorum\"));\n\n        // network fault on server2\n        System.out.println(\"Network fault on server2.\\n\");\n        simulateServerFault(serverInstance.get(1), \"net-fault\");\n        assertFalse(serverInstance.get(1).isActive());\n\n        // network fault on server3\n        System.out.println(\"Network fault on server3.\\n\");\n        simulateServerFault(serverInstance.get(SERVERS - 1), \"net-fault\");\n        assertFalse(serverInstance.get(2).isActive());\n\n        // writes on server1\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n        try {\n          new ODocument(\"Person\").fields(\"name\", \"Jay\", \"surname\", \"Miner\").save();\n          new ODocument(\"Person\").fields(\"name\", \"Luke\", \"surname\", \"Skywalker\").save();\n          new ODocument(\"Person\").fields(\"name\", \"Yoda\", \"surname\", \"Nothing\").save();\n          assertTrue(\"Record inserted with server1 running and writeQuorum=2\", false);\n        } catch (Exception e) {\n          e.printStackTrace();\n          assertTrue(true);\n        }\n\n        // check that no records were inserted\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select count(*) from Person\"));\n        assertEquals(1, result.size());\n        assertEquals(0, ((Number) result.get(0).field(\"count\")).intValue());\n\n        // restarting server2\n        try {\n          serverInstance.get(1).startServer(getDistributedServerConfiguration(serverInstance.get(1)));\n          System.out.println(\"Server 2 restarted.\");\n          assertTrue(serverInstance.get(1).isActive());\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n\n        // writes on server1 and server2\n        executeWritesOnServers.remove(2);\n        executeMultipleWrites(executeWritesOnServers, \"plocal\");\n\n        // check consistency on server1 and server2\n        checkWritesAboveCluster(executeWritesOnServers, executeWritesOnServers);\n\n        // restarting server3\n        try {\n          serverInstance.get(2).startServer(getDistributedServerConfiguration(serverInstance.get(2)));\n          System.out.println(\"Server 2 restarted.\");\n          assertTrue(serverInstance.get(2).isActive());\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n\n        // writes on server3\n        executeWritesOnServers.add(serverInstance.get(2));\n        executeWritesOnServers.remove(serverInstance.get(0));\n        executeWritesOnServers.remove(serverInstance.get(1));\n        executeMultipleWrites(executeWritesOnServers, \"plocal\");\n\n        // check consistency\n        executeWritesOnServers.remove(serverInstance.get(2));\n        executeWritesOnServers.addAll(serverInstance);\n        checkWritesAboveCluster(serverInstance, executeWritesOnServers);\n\n      } catch (Exception e) {\n        e.printStackTrace();\n        assertTrue(e.getMessage(), false);\n      } finally {\n        if(dbServer1 != null) {\n          ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n          dbServer1.close();\n          ODatabaseRecordThreadLocal.INSTANCE.set(null);\n        }\n      }\n\n      return null;\n    }","commit_id":"a83d07fe2727af07dea34a2e46bd0bfa1cbf4a05","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  protected void onServerStarted(ServerRun server) {\n    super.onServerStarted(server);\n\n    if (serverStarted++ == (SERVERS - 1)) {\n//      startQueueMonitorTask();\n      startCountMonitorTask(\"Person\");\n\n      // BACKUP LAST SERVER, RUN ASYNCHRONOUSLY\n      new Thread(new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // CRASH LAST SERVER try {\n            executeWhen(new Callable<Boolean>() {\n                          // CONDITION\n                          @Override\n                          public Boolean call() throws Exception {\n                            final ODatabaseDocumentTx database = poolFactory.get(getDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\")\n                                .acquire();\n                            try {\n                              long recordCount = database.countClass(\"Person\");\n                              boolean condition = recordCount > (count * writerCount) * 1 / 3;\n                              return condition;\n                            } finally {\n                              database.close();\n                            }\n                          }\n                        }, // ACTION\n                new Callable() {\n                  @Override\n                  public Object call() throws Exception {\n                    Assert.assertTrue(\"Insert was too fast\", inserting);\n\n                    banner(\"STARTING BACKUP SERVER \" + (SERVERS - 1));\n\n                    OrientGraphFactory factory = new OrientGraphFactory(\n                        \"plocal:target/server\" + (SERVERS - 1) + \"/databases/\" + getDatabaseName());\n                    OrientGraphNoTx g = factory.getNoTx();\n\n                    backupInProgress = true;\n                    File file = null;\n                    try {\n                      file = File.createTempFile(\"orientdb_test_backup\", \".zip\");\n                      if (file.exists())\n                        Assert.assertTrue(file.delete());\n\n                      g.getRawGraph().backup(new FileOutputStream(file), null, new Callable<Object>() {\n                        @Override\n                        public Object call() throws Exception {\n\n                          // SIMULATE LONG BACKUP UP TO 2/3 OF RECORDS\n                          while (totalVertices.get() < (count * SERVERS) * 2 / 3) {\n                            Thread.sleep(1000);\n                          }\n\n                          return null;\n                        }\n                      }, null, 9, 1000000);\n\n                    } catch (IOException e) {\n                      e.printStackTrace();\n                    } finally {\n                      banner(\"COMPLETED BACKUP SERVER \" + (SERVERS - 1));\n                      backupInProgress = false;\n\n                      g.shutdown();\n\n                      if (file != null)\n                        file.delete();\n                    }\n                    return null;\n                  }\n                });\n\n          } catch (Exception e) {\n            e.printStackTrace();\n            Assert.fail(\"Error on execution flow\");\n          }\n        }\n      }).start();\n    }\n  }","id":67609,"modified_method":"@Override\n  protected void onServerStarted(ServerRun server) {\n    super.onServerStarted(server);\n\n    if (serverStarted++ == (SERVERS - 1)) {\n//      startQueueMonitorTask();\n      startCountMonitorTask(\"Person\");\n\n      // BACKUP LAST SERVER, RUN ASYNCHRONOUSLY\n      new Thread(new Runnable() {\n        @Override\n        public void run() {\n          try {\n            // CRASH LAST SERVER try {\n            executeWhen(new Callable<Boolean>() {\n                          // CONDITION\n                          @Override\n                          public Boolean call() throws Exception {\n                            final ODatabaseDocumentTx database = poolFactory.get(getDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\")\n                                .acquire();\n                            try {\n                              long recordCount = database.countClass(\"Person\");\n                              boolean condition = recordCount > (count * writerCount * SERVERS) * 1 / 3;\n                              return condition;\n                            } finally {\n                              database.close();\n                            }\n                          }\n                        }, // ACTION\n                new Callable() {\n                  @Override\n                  public Object call() throws Exception {\n                    Assert.assertTrue(\"Insert was too fast\", inserting);\n\n                    banner(\"STARTING BACKUP SERVER \" + (SERVERS - 1));\n\n                    OrientGraphFactory factory = new OrientGraphFactory(\n                        \"plocal:target/server\" + (SERVERS - 1) + \"/databases/\" + getDatabaseName());\n                    OrientGraphNoTx g = factory.getNoTx();\n\n                    backupInProgress = true;\n                    File file = null;\n                    try {\n                      file = File.createTempFile(\"orientdb_test_backup\", \".zip\");\n                      if (file.exists())\n                        Assert.assertTrue(file.delete());\n\n                      g.getRawGraph().backup(new FileOutputStream(file), null, new Callable<Object>() {\n                        @Override\n                        public Object call() throws Exception {\n\n                          // SIMULATE LONG BACKUP UP TO 2/3 OF RECORDS\n                          while (totalVertices.get() < (count * writerCount * SERVERS) * 2 / 3) {\n                            Thread.sleep(1000);\n                          }\n\n                          return null;\n                        }\n                      }, null, 9, 1000000);\n\n                    } catch (IOException e) {\n                      e.printStackTrace();\n                    } finally {\n                      banner(\"COMPLETED BACKUP SERVER \" + (SERVERS - 1));\n                      backupInProgress = false;\n\n                      g.shutdown();\n\n                      if (file != null)\n                        file.delete();\n                    }\n                    return null;\n                  }\n                });\n\n          } catch (Exception e) {\n            e.printStackTrace();\n            Assert.fail(\"Error on execution flow\");\n          }\n        }\n      }).start();\n    }\n  }","commit_id":"a83d07fe2727af07dea34a2e46bd0bfa1cbf4a05","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void executeTest() throws Exception {\n\n    /*\n     * Test with quorum = 1\n     */\n\n    banner(\"Test with quorum = 1\");\n\n    // changing configuration: writeQuorum=1, autoDeploy=false, hotAlignment=true\n    System.out.print(\"\\nChanging configuration (writeQuorum=1, autoDeploy=false, hotAlignment=true)...\");\n\n    ODocument cfg = null;\n    ServerRun server = serverInstance.get(2);\n    OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n    ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n    cfg = databaseConfiguration.serialize();\n    cfg.field(\"writeQuorum\", 1);\n    cfg.field(\"failureAvailableNodesLessQuorum\", true);\n    cfg.field(\"autoDeploy\", true);\n    cfg.field(\"hotAlignment\", true);\n    cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n    manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n    System.out.println(\"\\nConfiguration updated.\");\n\n    // creating class \"Hero\"\n    ODatabaseDocumentTx dbServer1 = poolFactory.get(getPlocalDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer2 = poolFactory.get(getPlocalDatabaseURL(serverInstance.get(1)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer3 = poolFactory.get(getPlocalDatabaseURL(serverInstance.get(2)), \"admin\", \"admin\").acquire();\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    dbServer1.getMetadata().getSchema().createClass(\"Hero\");\n\n    // checking the cluster \"Hero\" is present on each server\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    HashSet<String> clustersOnServer1 = (HashSet<String>) dbServer1.getClusterNames();\n    assertTrue(clustersOnServer1.contains(\"hero\"));\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    HashSet<String> clustersOnServer2 = (HashSet<String>) dbServer2.getClusterNames();\n    assertTrue(clustersOnServer2.contains(\"hero\"));\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    HashSet<String> clustersOnServer3 = (HashSet<String>) dbServer3.getClusterNames();\n    assertTrue(clustersOnServer3.contains(\"hero\"));\n\n    // isolating server3\n    System.out.println(\"Network fault on server3.\\n\");\n    simulateServerFault(serverInstance.get(2), \"net-fault\");\n    assertFalse(serverInstance.get(2).isActive());\n\n    // first insert with server3 isolated from the cluster\n    banner(\"First insert on server3 (isolated from the the cluster)\");\n    ODocument firstInsert = null;\n    ORID rid1 = null;\n    try {\n      dbServer3 = new ODatabaseDocumentTx(getPlocalDatabaseURL(serverInstance.get(2))).open(\"admin\",\"admin\");\n      firstInsert = new ODocument(\"Hero\").fields(\"id\", \"R001\", \"firstName\", \"Luke\", \"lastName\", \"Skywalker\").save();\n      System.out.println(\"First insert: \" + firstInsert.getRecord().toString());\n      rid1 = firstInsert.getRecord().getIdentity();\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(false);\n    }\n\n    // the record was inserted on server3\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    long recordCount = dbServer3.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n\n    // checking the record was not inserted on server1 and server2 (checking the record amount)\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(0, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    recordCount = dbServer2.countClass(\"Hero\");\n    assertEquals(0, recordCount);\n\n    // server3 joins the cluster\n    try {\n      serverInstance.get(2).startServer(getDistributedServerConfiguration(server));\n    } catch (Exception e) {\n      assertTrue(false);\n    }\n\n    Thread.sleep(1000);\n\n    // the first record was replicated on server1 and server2\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    recordCount = dbServer2.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n\n    // second insert with server3 joining the cluster that must fail\n    banner(\"Second insert on server1 (server3 joining the cluster)\");\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    ODocument secondInsert = null;\n    ORID rid2 = null;\n    try {\n      secondInsert = new ODocument(\"Hero\").fields(\"id\", \"R002\", \"firstName\", \"Han\", \"lastName\", \"Solo\").save();\n      System.out.println(\"Second insert: \" + secondInsert.getRecord().toString());\n      rid2 = secondInsert.getRecord().getIdentity();\n    } catch (Exception e) {\n      System.out.println(\"Insert failed.\");\n      e.printStackTrace();\n    }\n\n    // the record wasn't inserted\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n    System.out.println(\"The second record was inserted.\");\n\n    // waiting for the hotAlignment\n    Thread.sleep(500);\n\n    // third insert with server3 joining the cluster that must succeed\n    banner(\"Third insert on server1 (server3 joining the cluster)\");\n    ODocument thirdInsert = null;\n    ORID rid3 = null;\n    try {\n      thirdInsert = new ODocument(\"Hero\").fields(\"id\", \"R002\", \"firstName\", \"Han\", \"lastName\", \"Solo\").save();\n      System.out.println(\"Third insert: \" + thirdInsert.getRecord().toString());\n      rid3 = thirdInsert.getRecord().getIdentity();\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(true);\n    }\n\n    // the record was inserted\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n    System.out.println(\"The third record was inserted.\");\n\n    // check consistency above the cluster\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    List<ODocument> result1 = dbServer1.query(new OSQLSynchQuery<ODocument>(\"select from Hero\"));\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    List<ODocument> result2 = dbServer2.query(new OSQLSynchQuery<ODocument>(\"select from Hero\"));\n    recordCount = dbServer2.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    List<ODocument> result3 = dbServer3.query(new OSQLSynchQuery<ODocument>(\"select from Hero\"));\n    recordCount = dbServer3.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n\n    ODocument firstInsertServer1 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(0)), \"R001\");\n    ODocument firstInsertServer2 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(1)), \"R001\");\n    ODocument firstInsertServer3 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R001\");\n\n    assertEquals(firstInsertServer1.field(\"firstName\"), firstInsertServer2.field(\"firstName\"));\n    assertEquals(firstInsertServer1.field(\"lastName\"), firstInsertServer2.field(\"lastName\"));\n    assertEquals(firstInsertServer2.field(\"firstName\"), firstInsertServer3.field(\"firstName\"));\n    assertEquals(firstInsertServer2.field(\"lastName\"), firstInsertServer3.field(\"lastName\"));\n\n    ODocument secondInsertServer1 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(0)), \"R002\");\n    ODocument secondInsertServer2 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(1)), \"R002\");\n    ODocument secondInsertServer3 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R002\");\n\n    assertEquals(secondInsertServer1.field(\"firstName\"), secondInsertServer2.field(\"firstName\"));\n    assertEquals(secondInsertServer1.field(\"lastName\"), secondInsertServer2.field(\"lastName\"));\n    assertEquals(secondInsertServer2.field(\"firstName\"), secondInsertServer3.field(\"firstName\"));\n    assertEquals(secondInsertServer2.field(\"lastName\"), secondInsertServer3.field(\"lastName\"));\n\n  }","id":67610,"modified_method":"@Override\n  public void executeTest() throws Exception {\n\n    /*\n     * Test with quorum = 1\n     */\n\n    banner(\"Test with quorum = 1\");\n\n    // changing configuration: writeQuorum=1, autoDeploy=false, hotAlignment=true\n    System.out.print(\"\\nChanging configuration (writeQuorum=1, autoDeploy=false, hotAlignment=true)...\");\n\n    ODocument cfg = null;\n    ServerRun server = serverInstance.get(2);\n    OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n    ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n    cfg = databaseConfiguration.serialize();\n    cfg.field(\"writeQuorum\", 1);\n    cfg.field(\"autoDeploy\", true);\n    cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n    manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n    System.out.println(\"\\nConfiguration updated.\");\n\n    // creating class \"Hero\"\n    ODatabaseDocumentTx dbServer1 = poolFactory.get(getPlocalDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer2 = poolFactory.get(getPlocalDatabaseURL(serverInstance.get(1)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer3 = poolFactory.get(getPlocalDatabaseURL(serverInstance.get(2)), \"admin\", \"admin\").acquire();\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    dbServer1.getMetadata().getSchema().createClass(\"Hero\");\n\n    // checking the cluster \"Hero\" is present on each server\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    HashSet<String> clustersOnServer1 = (HashSet<String>) dbServer1.getClusterNames();\n    assertTrue(clustersOnServer1.contains(\"hero\"));\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    HashSet<String> clustersOnServer2 = (HashSet<String>) dbServer2.getClusterNames();\n    assertTrue(clustersOnServer2.contains(\"hero\"));\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    HashSet<String> clustersOnServer3 = (HashSet<String>) dbServer3.getClusterNames();\n    assertTrue(clustersOnServer3.contains(\"hero\"));\n\n    // isolating server3\n    System.out.println(\"Network fault on server3.\\n\");\n    simulateServerFault(serverInstance.get(2), \"net-fault\");\n    assertFalse(serverInstance.get(2).isActive());\n\n    // first insert with server3 isolated from the cluster\n    banner(\"First insert on server3 (isolated from the the cluster)\");\n    ODocument firstInsert = null;\n    ORID rid1 = null;\n    try {\n      dbServer3 = new ODatabaseDocumentTx(getPlocalDatabaseURL(serverInstance.get(2))).open(\"admin\",\"admin\");\n      firstInsert = new ODocument(\"Hero\").fields(\"id\", \"R001\", \"firstName\", \"Luke\", \"lastName\", \"Skywalker\").save();\n      System.out.println(\"First insert: \" + firstInsert.getRecord().toString());\n      rid1 = firstInsert.getRecord().getIdentity();\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(false);\n    }\n\n    // the record was inserted on server3\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    long recordCount = dbServer3.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n\n    // checking the record was not inserted on server1 and server2 (checking the record amount)\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(0, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    recordCount = dbServer2.countClass(\"Hero\");\n    assertEquals(0, recordCount);\n\n    // server3 joins the cluster\n    try {\n      serverInstance.get(2).startServer(getDistributedServerConfiguration(server));\n    } catch (Exception e) {\n      assertTrue(false);\n    }\n\n    Thread.sleep(1000);\n\n    // the first record was replicated on server1 and server2\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    recordCount = dbServer2.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n\n    // second insert with server3 joining the cluster that must fail\n    banner(\"Second insert on server1 (server3 joining the cluster)\");\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    ODocument secondInsert = null;\n    ORID rid2 = null;\n    try {\n      secondInsert = new ODocument(\"Hero\").fields(\"id\", \"R002\", \"firstName\", \"Han\", \"lastName\", \"Solo\").save();\n      System.out.println(\"Second insert: \" + secondInsert.getRecord().toString());\n      rid2 = secondInsert.getRecord().getIdentity();\n    } catch (Exception e) {\n      System.out.println(\"Insert failed.\");\n      e.printStackTrace();\n    }\n\n    // the record wasn't inserted\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(1, recordCount);\n    System.out.println(\"The second record was inserted.\");\n\n    // waiting for the hotAlignment\n    Thread.sleep(500);\n\n    // third insert with server3 joining the cluster that must succeed\n    banner(\"Third insert on server1 (server3 joining the cluster)\");\n    ODocument thirdInsert = null;\n    ORID rid3 = null;\n    try {\n      thirdInsert = new ODocument(\"Hero\").fields(\"id\", \"R002\", \"firstName\", \"Han\", \"lastName\", \"Solo\").save();\n      System.out.println(\"Third insert: \" + thirdInsert.getRecord().toString());\n      rid3 = thirdInsert.getRecord().getIdentity();\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(true);\n    }\n\n    // the record was inserted\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n    System.out.println(\"The third record was inserted.\");\n\n    // check consistency above the cluster\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    List<ODocument> result1 = dbServer1.query(new OSQLSynchQuery<ODocument>(\"select from Hero\"));\n    recordCount = dbServer1.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    List<ODocument> result2 = dbServer2.query(new OSQLSynchQuery<ODocument>(\"select from Hero\"));\n    recordCount = dbServer2.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    List<ODocument> result3 = dbServer3.query(new OSQLSynchQuery<ODocument>(\"select from Hero\"));\n    recordCount = dbServer3.countClass(\"Hero\");\n    assertEquals(2, recordCount);\n\n    ODocument firstInsertServer1 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(0)), \"R001\");\n    ODocument firstInsertServer2 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(1)), \"R001\");\n    ODocument firstInsertServer3 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R001\");\n\n    assertEquals(firstInsertServer1.field(\"firstName\"), firstInsertServer2.field(\"firstName\"));\n    assertEquals(firstInsertServer1.field(\"lastName\"), firstInsertServer2.field(\"lastName\"));\n    assertEquals(firstInsertServer2.field(\"firstName\"), firstInsertServer3.field(\"firstName\"));\n    assertEquals(firstInsertServer2.field(\"lastName\"), firstInsertServer3.field(\"lastName\"));\n\n    ODocument secondInsertServer1 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(0)), \"R002\");\n    ODocument secondInsertServer2 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(1)), \"R002\");\n    ODocument secondInsertServer3 = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R002\");\n\n    assertEquals(secondInsertServer1.field(\"firstName\"), secondInsertServer2.field(\"firstName\"));\n    assertEquals(secondInsertServer1.field(\"lastName\"), secondInsertServer2.field(\"lastName\"));\n    assertEquals(secondInsertServer2.field(\"firstName\"), secondInsertServer3.field(\"firstName\"));\n    assertEquals(secondInsertServer2.field(\"lastName\"), secondInsertServer3.field(\"lastName\"));\n\n  }","commit_id":"a83d07fe2727af07dea34a2e46bd0bfa1cbf4a05","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void executeTest() throws Exception {\n\n    /*\n     * Test with readQuorum = 2\n     */\n\n    banner(\"Test with readQuorum = 2\");\n\n    ODatabaseDocumentTx dbServer1 = poolFactory.get(getDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\").acquire();\n\n    // changing configuration: readQuorum=2, autoDeploy=false\n    System.out.print(\"\\nChanging configuration (readQuorum=2, autoDeploy=false)...\");\n\n    ODocument cfg = null;\n    ServerRun server = serverInstance.get(2);\n    OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n    ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n    cfg = databaseConfiguration.serialize();\n    cfg.field(\"readQuorum\", 2);\n    cfg.field(\"failureAvailableNodesLessQuorum\", true);\n    cfg.field(\"autoDeploy\", false);\n    cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n    manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n    System.out.println(\"\\nConfiguration updated.\");\n\n    // inserting record r1 and checking consistency on all the servers\n    System.out.print(\"Inserting record r1 and checking consistency...\");\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    new ODocument(\"Person\").fields(\"id\", \"R001\", \"firstName\", \"Luke\", \"lastName\", \"Skywalker\").save();\n    Thread.sleep(200);\n    ODocument r1onServer1 = retrieveRecord(getDatabaseURL(serverInstance.get(0)), \"R001\");\n    ODocument r1onServer2 = retrieveRecord(getDatabaseURL(serverInstance.get(1)), \"R001\");\n    ODocument r1onServer3 = retrieveRecord(getDatabaseURL(serverInstance.get(2)), \"R001\");\n\n    assertEquals(r1onServer1.field(\"@version\"), r1onServer2.field(\"@version\"));\n    assertEquals(r1onServer1.field(\"id\"), r1onServer2.field(\"id\"));\n    assertEquals(r1onServer1.field(\"firstName\"), r1onServer2.field(\"firstName\"));\n    assertEquals(r1onServer1.field(\"lastName\"), r1onServer2.field(\"lastName\"));\n\n    assertEquals(r1onServer2.field(\"@version\"), r1onServer3.field(\"@version\"));\n    assertEquals(r1onServer2.field(\"id\"), r1onServer3.field(\"id\"));\n    assertEquals(r1onServer2.field(\"firstName\"), r1onServer3.field(\"firstName\"));\n    assertEquals(r1onServer2.field(\"lastName\"), r1onServer3.field(\"lastName\"));\n\n    System.out.println(\"\\tDone.\");\n\n    // initial version of the record r1\n    int initialVersion = r1onServer1.field(\"@version\");\n\n    // isolating server3\n    System.out.println(\"Network fault on server3.\\n\");\n    simulateServerFault(serverInstance.get(2), \"net-fault\");\n    assertFalse(serverInstance.get(2).isActive());\n\n    // updaing r1 in r1* on server3\n    banner(\"Updaing r1 in r1* on server3 (isolated from the the cluster)\");\n    ODatabaseDocumentTx dbServer3 = null;\n    ODocument retrievedRecord = null;\n    try {\n      dbServer3 = new ODatabaseDocumentTx(getPlocalDatabaseURL(serverInstance.get(2))).open(\"admin\",\"admin\");\n      retrievedRecord = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R001\");\n      retrievedRecord.field(\"firstName\",\"Darth\");\n      retrievedRecord.field(\"lastName\",\"Vader\");\n      retrievedRecord.save();\n      System.out.println(retrievedRecord.getRecord().toString());\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(false);\n    }\n\n    // restarting server3\n    serverInstance.get(2).startServer(getDistributedServerConfiguration(serverInstance.get(SERVERS - 1)));\n    System.out.println(\"Server 3 restarted.\");\n    assertTrue(serverInstance.get(2).isActive());\n\n    // reading r1* on server3\n    dbServer3 = poolFactory.get(getDatabaseURL(serverInstance.get(2)), \"admin\", \"admin\").acquire();\n    try {\n      retrievedRecord = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R001\");\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // the retrieved record must be r1 (if fix was applied)\n    assertEquals(\"R001\", retrievedRecord.field(\"id\"));\n    assertEquals(\"Luke\", retrievedRecord.field(\"firstName\"));\n    assertEquals(\"Skywalker\", retrievedRecord.field(\"lastName\"));\n\n  }","id":67611,"modified_method":"@Override\n  public void executeTest() throws Exception {\n\n    /*\n     * Test with readQuorum = 2\n     */\n\n    banner(\"Test with readQuorum = 2\");\n\n    ODatabaseDocumentTx dbServer1 = poolFactory.get(getDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\").acquire();\n\n    // changing configuration: readQuorum=2, autoDeploy=false\n    System.out.print(\"\\nChanging configuration (readQuorum=2, autoDeploy=false)...\");\n\n    ODocument cfg = null;\n    ServerRun server = serverInstance.get(2);\n    OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n    ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n    cfg = databaseConfiguration.serialize();\n    cfg.field(\"readQuorum\", 2);\n    cfg.field(\"autoDeploy\", false);\n    cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n    manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n    System.out.println(\"\\nConfiguration updated.\");\n\n    // inserting record r1 and checking consistency on all the servers\n    System.out.print(\"Inserting record r1 and checking consistency...\");\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    new ODocument(\"Person\").fields(\"id\", \"R001\", \"firstName\", \"Luke\", \"lastName\", \"Skywalker\").save();\n    Thread.sleep(200);\n    ODocument r1onServer1 = retrieveRecord(getDatabaseURL(serverInstance.get(0)), \"R001\");\n    ODocument r1onServer2 = retrieveRecord(getDatabaseURL(serverInstance.get(1)), \"R001\");\n    ODocument r1onServer3 = retrieveRecord(getDatabaseURL(serverInstance.get(2)), \"R001\");\n\n    assertEquals(r1onServer1.field(\"@version\"), r1onServer2.field(\"@version\"));\n    assertEquals(r1onServer1.field(\"id\"), r1onServer2.field(\"id\"));\n    assertEquals(r1onServer1.field(\"firstName\"), r1onServer2.field(\"firstName\"));\n    assertEquals(r1onServer1.field(\"lastName\"), r1onServer2.field(\"lastName\"));\n\n    assertEquals(r1onServer2.field(\"@version\"), r1onServer3.field(\"@version\"));\n    assertEquals(r1onServer2.field(\"id\"), r1onServer3.field(\"id\"));\n    assertEquals(r1onServer2.field(\"firstName\"), r1onServer3.field(\"firstName\"));\n    assertEquals(r1onServer2.field(\"lastName\"), r1onServer3.field(\"lastName\"));\n\n    System.out.println(\"\\tDone.\");\n\n    // initial version of the record r1\n    int initialVersion = r1onServer1.field(\"@version\");\n\n    // isolating server3\n    System.out.println(\"Network fault on server3.\\n\");\n    simulateServerFault(serverInstance.get(2), \"net-fault\");\n    assertFalse(serverInstance.get(2).isActive());\n\n    // updaing r1 in r1* on server3\n    banner(\"Updaing r1 in r1* on server3 (isolated from the the cluster)\");\n    ODatabaseDocumentTx dbServer3 = null;\n    ODocument retrievedRecord = null;\n    try {\n      dbServer3 = new ODatabaseDocumentTx(getPlocalDatabaseURL(serverInstance.get(2))).open(\"admin\",\"admin\");\n      retrievedRecord = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R001\");\n      retrievedRecord.field(\"firstName\",\"Darth\");\n      retrievedRecord.field(\"lastName\",\"Vader\");\n      retrievedRecord.save();\n      System.out.println(retrievedRecord.getRecord().toString());\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(false);\n    }\n\n    // restarting server3\n    serverInstance.get(2).startServer(getDistributedServerConfiguration(serverInstance.get(SERVERS - 1)));\n    System.out.println(\"Server 3 restarted.\");\n    assertTrue(serverInstance.get(2).isActive());\n\n    // reading r1* on server3\n    dbServer3 = poolFactory.get(getDatabaseURL(serverInstance.get(2)), \"admin\", \"admin\").acquire();\n    try {\n      retrievedRecord = retrieveRecord(getPlocalDatabaseURL(serverInstance.get(2)), \"R001\");\n    } catch (Exception e) {\n      e.printStackTrace();\n    }\n\n    // the retrieved record must be r1 (if fix was applied)\n    assertEquals(\"R001\", retrievedRecord.field(\"id\"));\n    assertEquals(\"Luke\", retrievedRecord.field(\"firstName\"));\n    assertEquals(\"Skywalker\", retrievedRecord.field(\"lastName\"));\n\n  }","commit_id":"a83d07fe2727af07dea34a2e46bd0bfa1cbf4a05","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public Void call() throws Exception {\n\n      List<ODocument> result = null;\n      final ODatabaseDocumentTx dbServer1 = new ODatabaseDocumentTx(databaseUrl1).open(\"admin\", \"admin\");\n\n      try {\n\n        /*\n         * Test with quorum = 3\n         */\n\n        banner(\"Test with quorum = 3\");\n\n        // deleting all\n        OCommandSQL sqlCommand = new OCommandSQL(\"delete from Person\");\n        dbServer1.command(sqlCommand).execute();\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person\"));\n        assertEquals(0, result.size());\n        this.initialCount = 0;\n\n        // changing configuration\n        System.out.print(\"\\nChanging quorum...\");\n\n        ODocument cfg = null;\n        ServerRun server = serverInstance.get(0);\n        OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n        ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n        cfg = databaseConfiguration.serialize();\n        cfg.field(\"writeQuorum\", 3);\n        cfg.field(\"failureAvailableNodesLessQuorum\", true);\n        cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n        manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n\n        System.out.println(\"\\nConfiguration updated.\");\n\n        // network fault on server3\n        System.out.println(\"Network fault on server3.\\n\");\n        simulateServerFault(this.serverInstances.get(SERVERS - 1),\"net-fault\");\n        assertFalse(serverInstance.get(2).isActive());\n\n        // single write\n        System.out.print(\"Insert operation in the database...\");\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n        try {\n          new ODocument(\"Person\").fields(\"id\", \"L-001\", \"name\", \"John\", \"surname\", \"Black\").save();\n          assertTrue(\"Error: record inserted with 2 server running and writeWuorum=3.\", false);\n        } catch (Exception e) {\n          e.printStackTrace();\n          assertTrue(\"Record not inserted because there are 2 server running and writeWuorum=3.\", true);\n        }\n        System.out.println(\"Done.\\n\");\n\n        System.out.print(\"Checking the last record wasn't inserted in the db because the quorum was not reached...\");\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person where id='L-001'\"));\n        assertEquals(0, result.size());\n\n        final ODatabaseDocumentTx dbServer2 = new ODatabaseDocumentTx(databaseUrl2).open(\"admin\", \"admin\");\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n        result = dbServer2.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person where id='L-001'\"));\n        assertEquals(0, result.size());\n\n        System.out.println(\"Done.\\n\");\n        ODatabaseRecordThreadLocal.INSTANCE.set(null);\n\n        // restarting server3\n        serverInstance.get(2).startServer(getDistributedServerConfiguration(serverInstance.get(SERVERS - 1)));\n        System.out.println(\"Server 3 restarted.\");\n        assertTrue(serverInstance.get(2).isActive());\n\n        // writes on server1, server2 and server3\n        executeMultipleWrites(this.executeWritesOnServers, \"plocal\");\n\n        // check consistency\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n        dbServer1.getMetadata().getSchema().reload();\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person\"));\n        assertEquals(1500, result.size());\n        checkWritesAboveCluster(serverInstance, executeWritesOnServers);\n        ODatabaseRecordThreadLocal.INSTANCE.set(null);\n\n      } catch (Exception e) {\n        e.printStackTrace();\n        assertTrue(e.getMessage(), false);\n      } finally {\n        if(dbServer1 != null) {\n          ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n          dbServer1.close();\n          ODatabaseRecordThreadLocal.INSTANCE.set(null);\n        }\n      }\n\n      return null;\n    }","id":67612,"modified_method":"@Override\n    public Void call() throws Exception {\n\n      List<ODocument> result = null;\n      final ODatabaseDocumentTx dbServer1 = new ODatabaseDocumentTx(databaseUrl1).open(\"admin\", \"admin\");\n\n      try {\n\n        /*\n         * Test with quorum = 3\n         */\n\n        banner(\"Test with quorum = 3\");\n\n        // deleting all\n        OCommandSQL sqlCommand = new OCommandSQL(\"delete from Person\");\n        dbServer1.command(sqlCommand).execute();\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person\"));\n        assertEquals(0, result.size());\n        this.initialCount = 0;\n\n        // changing configuration\n        System.out.print(\"\\nChanging quorum...\");\n\n        ODocument cfg = null;\n        ServerRun server = serverInstance.get(0);\n        OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n        ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n        cfg = databaseConfiguration.serialize();\n        cfg.field(\"writeQuorum\", 3);\n        cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n        manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n\n        System.out.println(\"\\nConfiguration updated.\");\n\n        // network fault on server3\n        System.out.println(\"Network fault on server3.\\n\");\n        simulateServerFault(this.serverInstances.get(SERVERS - 1),\"net-fault\");\n        assertFalse(serverInstance.get(2).isActive());\n\n        // single write\n        System.out.print(\"Insert operation in the database...\");\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n        try {\n          new ODocument(\"Person\").fields(\"id\", \"L-001\", \"name\", \"John\", \"surname\", \"Black\").save();\n          assertTrue(\"Error: record inserted with 2 server running and writeWuorum=3.\", false);\n        } catch (Exception e) {\n          e.printStackTrace();\n          assertTrue(\"Record not inserted because there are 2 server running and writeWuorum=3.\", true);\n        }\n        System.out.println(\"Done.\\n\");\n\n        System.out.print(\"Checking the last record wasn't inserted in the db because the quorum was not reached...\");\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person where id='L-001'\"));\n        assertEquals(0, result.size());\n\n        final ODatabaseDocumentTx dbServer2 = new ODatabaseDocumentTx(databaseUrl2).open(\"admin\", \"admin\");\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n        result = dbServer2.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person where id='L-001'\"));\n        assertEquals(0, result.size());\n\n        System.out.println(\"Done.\\n\");\n        ODatabaseRecordThreadLocal.INSTANCE.set(null);\n\n        // restarting server3\n        serverInstance.get(2).startServer(getDistributedServerConfiguration(serverInstance.get(SERVERS - 1)));\n        System.out.println(\"Server 3 restarted.\");\n        assertTrue(serverInstance.get(2).isActive());\n\n        // writes on server1, server2 and server3\n        executeMultipleWrites(this.executeWritesOnServers, \"plocal\");\n\n        // check consistency\n        ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n        dbServer1.getMetadata().getSchema().reload();\n        result = dbServer1.query(new OSQLSynchQuery<OIdentifiable>(\"select from Person\"));\n        assertEquals(1500, result.size());\n        checkWritesAboveCluster(serverInstance, executeWritesOnServers);\n        ODatabaseRecordThreadLocal.INSTANCE.set(null);\n\n      } catch (Exception e) {\n        e.printStackTrace();\n        assertTrue(e.getMessage(), false);\n      } finally {\n        if(dbServer1 != null) {\n          ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n          dbServer1.close();\n          ODatabaseRecordThreadLocal.INSTANCE.set(null);\n        }\n      }\n\n      return null;\n    }","commit_id":"a83d07fe2727af07dea34a2e46bd0bfa1cbf4a05","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  public void executeTest() throws Exception {\n\n    /*\n     * Test with quorum = 1\n     */\n\n    banner(\"Test with quorum = 1\");\n\n    ODatabaseDocumentTx dbServer1 = poolFactory.get(getDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer2 = poolFactory.get(getDatabaseURL(serverInstance.get(1)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer3 = poolFactory.get(getDatabaseURL(serverInstance.get(2)), \"admin\", \"admin\").acquire();\n\n    // changing configuration: writeQuorum=1, autoDeploy=false\n    System.out.print(\"\\nChanging configuration (writeQuorum=1, autoDeploy=false)...\");\n\n    ODocument cfg = null;\n    ServerRun server = serverInstance.get(2);\n    OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n    ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n    cfg = databaseConfiguration.serialize();\n    cfg.field(\"writeQuorum\", 1);\n    cfg.field(\"failureAvailableNodesLessQuorum\", true);\n    cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n    manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n    System.out.println(\"\\nConfiguration updated.\");\n\n    // deadlock on server3\n    this.server3inDeadlock = true;\n    Thread.sleep(200);  // waiting for deadlock\n\n    // inserting record r1 and checking consistency on server1 and server2\n    System.out.print(\"Inserting record r1 and checking consistency...\");\n    ODocument r1onServer1 = new ODocument(\"Person\").fields(\"id\", \"R001\", \"firstName\", \"Han\", \"lastName\", \"Solo\");\n    r1onServer1.save();\n    Thread.sleep(200);\n    ODocument r1onServer2 = retrieveRecord(getDatabaseURL(serverInstance.get(1)), \"R001\");\n\n    assertEquals(r1onServer1.field(\"@version\"), r1onServer2.field(\"@version\"));\n    assertEquals(r1onServer1.field(\"id\"), r1onServer2.field(\"id\"));\n    assertEquals(r1onServer1.field(\"firstName\"), r1onServer2.field(\"firstName\"));\n    assertEquals(r1onServer1.field(\"lastName\"), r1onServer2.field(\"lastName\"));\n\n    System.out.println(\"\\tDone.\");\n\n    // initial version of the record r1\n    int initialVersion = r1onServer1.field(\"@version\");\n\n    // creating and executing two clients c1 and c2 (updating r1)\n    System.out.print(\"Building client c1 and client c2...\");\n    List<Callable<Void>> clients = new LinkedList<Callable<Void>>();\n    clients.add(new ClientWriter(getDatabaseURL(serverInstance.get(0)), \"R001\", \"Luke\", \"Skywalker\"));\n    clients.add(new ClientWriter(getDatabaseURL(serverInstance.get(1)), \"R001\", \"Darth\", \"Vader\"));\n    System.out.println(\"\\tDone.\");\n    ExecutorService executor = Executors.newCachedThreadPool();\n    System.out.println(\"Concurrent update:\");\n    List<Future<Void>> futures = executor.invokeAll(clients);\n\n    try {\n      for (Future f : futures) {\n        f.get();\n      }\n      assertTrue(\"Concurrent update NOT detected!\", false);\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(true);\n      System.out.println(\"Concurrent update detected!\");\n    }\n    // wait for propagation\n    Thread.sleep(500);\n\n    // end of deadlock on server3\n    this.server3inDeadlock = false;\n    Thread.sleep(1000);  // waiting for sync of server3\n\n    // check consistency\n    r1onServer1 = retrieveRecord(getDatabaseURL(serverInstance.get(0)), \"R001\");\n    r1onServer2 = retrieveRecord(getDatabaseURL(serverInstance.get(1)), \"R001\");\n    ODocument r1onServer3  = retrieveRecord(getDatabaseURL(serverInstance.get(2)), \"R001\");\n\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    r1onServer1.reload();\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    r1onServer2.reload();\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    r1onServer3.reload();\n\n    if( (r1onServer1.field(\"firstName\").equals(\"Luke\") && r1onServer1.field(\"lastName\").equals(\"Skywalker\")) ||\n        r1onServer1.field(\"firstName\").equals(\"Darth\") && r1onServer1.field(\"lastName\").equals(\"Vader\")) {\n      assertTrue(\"The record has been updated by a client!\", true);\n    }\n    else {\n      assertTrue(\"The record has not been updated by any client!\", false);\n    }\n\n    System.out.printf(\"Checking consistency among servers...\");\n    assertEquals(r1onServer1.field(\"@version\"), r1onServer2.field(\"@version\"));\n    assertEquals(r1onServer1.field(\"id\"), r1onServer2.field(\"id\"));\n    assertEquals(r1onServer1.field(\"firstName\"), r1onServer2.field(\"firstName\"));\n    assertEquals(r1onServer1.field(\"lastName\"), r1onServer2.field(\"lastName\"));\n\n    assertEquals(r1onServer2.field(\"@version\"), r1onServer3.field(\"@version\"));\n    assertEquals(r1onServer2.field(\"id\"), r1onServer3.field(\"id\"));\n    assertEquals(r1onServer2.field(\"firstName\"), r1onServer3.field(\"firstName\"));\n    assertEquals(r1onServer2.field(\"lastName\"), r1onServer3.field(\"lastName\"));\n    System.out.println(\"The records are consistent in the cluster.\");\n\n    // final version of the record r1\n    System.out.print(\"Checking versioning...\");\n    int finalVersion = r1onServer1.field(\"@version\");\n\n    assertEquals(finalVersion, initialVersion +1);\n    System.out.println(\"\\tDone.\");\n\n  }","id":67613,"modified_method":"@Override\n  public void executeTest() throws Exception {\n\n    /*\n     * Test with quorum = 1\n     */\n\n    banner(\"Test with quorum = 1\");\n\n    ODatabaseDocumentTx dbServer1 = poolFactory.get(getDatabaseURL(serverInstance.get(0)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer2 = poolFactory.get(getDatabaseURL(serverInstance.get(1)), \"admin\", \"admin\").acquire();\n    ODatabaseDocumentTx dbServer3 = poolFactory.get(getDatabaseURL(serverInstance.get(2)), \"admin\", \"admin\").acquire();\n\n    // changing configuration: writeQuorum=1, autoDeploy=false\n    System.out.print(\"\\nChanging configuration (writeQuorum=1, autoDeploy=false)...\");\n\n    ODocument cfg = null;\n    ServerRun server = serverInstance.get(2);\n    OHazelcastPlugin manager = (OHazelcastPlugin) server.getServerInstance().getDistributedManager();\n    ODistributedConfiguration databaseConfiguration = manager.getDatabaseConfiguration(getDatabaseName());\n    cfg = databaseConfiguration.serialize();\n    cfg.field(\"writeQuorum\", 1);\n    cfg.field(\"version\", (Integer) cfg.field(\"version\") + 1);\n    manager.updateCachedDatabaseConfiguration(getDatabaseName(), cfg, true, true);\n    System.out.println(\"\\nConfiguration updated.\");\n\n    // deadlock on server3\n    this.server3inDeadlock = true;\n    Thread.sleep(200);  // waiting for deadlock\n\n    // inserting record r1 and checking consistency on server1 and server2\n    System.out.print(\"Inserting record r1 and on server1 and checking consistency on both server1 and server2...\");\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    ODocument r1onServer1 = new ODocument(\"Person\").fields(\"id\", \"R001\", \"firstName\", \"Han\", \"lastName\", \"Solo\");\n    r1onServer1.save();\n    Thread.sleep(200);\n    ODocument r1onServer2 = retrieveRecord(getDatabaseURL(serverInstance.get(1)), \"R001\");\n\n    assertEquals(r1onServer1.field(\"@version\"), r1onServer2.field(\"@version\"));\n    assertEquals(r1onServer1.field(\"id\"), r1onServer2.field(\"id\"));\n    assertEquals(r1onServer1.field(\"firstName\"), r1onServer2.field(\"firstName\"));\n    assertEquals(r1onServer1.field(\"lastName\"), r1onServer2.field(\"lastName\"));\n\n    System.out.println(\"\\tDone.\");\n\n    // initial version of the record r1\n    int initialVersion = r1onServer1.field(\"@version\");\n\n    // creating and executing two clients c1 and c2 (updating r1)\n    System.out.print(\"Building client c1 and client c2...\");\n    List<Callable<Void>> clients = new LinkedList<Callable<Void>>();\n    clients.add(new ClientWriter(getDatabaseURL(serverInstance.get(0)), \"R001\", \"Luke\", \"Skywalker\"));\n    clients.add(new ClientWriter(getDatabaseURL(serverInstance.get(1)), \"R001\", \"Darth\", \"Vader\"));\n    System.out.println(\"\\tDone.\");\n    ExecutorService executor = Executors.newCachedThreadPool();\n    System.out.println(\"Concurrent update:\");\n    List<Future<Void>> futures = executor.invokeAll(clients);\n\n    try {\n      for (Future f : futures) {\n        f.get();\n      }\n      assertTrue(\"Concurrent update correctly managed!\", true);\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(false);\n      System.out.println(\"Exception was thrown!\");\n    }\n    // wait for propagation\n    Thread.sleep(500);\n\n    // end of deadlock on server3 and sync\n    try {\n      this.server3inDeadlock = false;\n      Thread.sleep(500);  // waiting for sync of server3\n    } catch (Exception e) {\n      e.printStackTrace();\n      assertTrue(false);\n      System.out.println(\"Exception was thrown!\");\n    }\n\n    // check consistency\n    r1onServer1 = retrieveRecord(getDatabaseURL(serverInstance.get(0)), \"R001\");\n    r1onServer2 = retrieveRecord(getDatabaseURL(serverInstance.get(1)), \"R001\");\n    ODocument r1onServer3  = retrieveRecord(getDatabaseURL(serverInstance.get(2)), \"R001\");\n\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer1);\n    r1onServer1.reload();\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer2);\n    r1onServer2.reload();\n    ODatabaseRecordThreadLocal.INSTANCE.set(dbServer3);\n    r1onServer3.reload();\n\n    // r1 on server1 has the values set by the client c1\n    if(r1onServer1.field(\"firstName\").equals(\"Luke\") && r1onServer1.field(\"lastName\").equals(\"Skywalker\")) {\n      assertTrue(\"The record on server1 has been updated by the client c1 without exceptions!\", true);\n    }\n    else {\n      assertTrue(\"The record on server1 has not been updated by any client!\", false);\n    }\n\n    // r1 on server2 has the values set by the client c2\n    if(r1onServer2.field(\"firstName\").equals(\"Darth\") && r1onServer2.field(\"lastName\").equals(\"Vader\")) {\n      assertTrue(\"The record on server1 has been updated by the client c2 without exceptions!\", true);\n    }\n    else {\n      assertTrue(\"The record on server2 has not been updated by any client!\", false);\n    }\n\n    // r1 on server3 has the values set by the client c1 or the values set by the client c2, but not the old one\n    if( (r1onServer3.field(\"firstName\").equals(\"Luke\") && r1onServer3.field(\"lastName\").equals(\"Skywalker\")) ||\n        r1onServer3.field(\"firstName\").equals(\"Darth\") && r1onServer3.field(\"lastName\").equals(\"Vader\")) {\n      assertTrue(\"The record on server3 has been updated by a client without exceptions!\", true);\n    }\n    else {\n      assertTrue(\"The record on server3 has not been updated by any client!\", false);\n    }\n\n    // r1 has version x+1 on all the servers\n    System.out.printf(\"Checking version consistency among servers...\");\n\n    int finalVersion = r1onServer1.field(\"@version\");\n    assertEquals(finalVersion, initialVersion +1);\n\n    assertEquals(r1onServer1.field(\"@version\"), r1onServer2.field(\"@version\"));\n    assertEquals(r1onServer2.field(\"@version\"), r1onServer3.field(\"@version\"));\n    System.out.println(\"Done.\");\n\n  }","commit_id":"a83d07fe2727af07dea34a2e46bd0bfa1cbf4a05","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public int kPercentileLatency(double percentile) {\n        if ((percentile >= 1.0) || (percentile < 0.0)) {\n            throw new RuntimeException(\n                    \"KPercentileLatency accepts values greater than 0 and less than 1\");\n        }\n        if (invocationsCompleted == 0) return -1;\n\n        // find the number of calls with less than percentile latency\n        long k = (long) (invocationsCompleted * percentile);\n\n        long sum = 0;\n        // check if the latency requested is in the 0-100ms bins\n        if (k <= latencyBy100ms[0]) {\n\n            // check if the latency requested is in the 0-10ms bins\n            if (k <= latencyBy10ms[0]) {\n                // sum up the counts in the bins until k is subsumed\n                for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {\n                    sum += latencyBy1ms[i];\n                    if (sum >= k) {\n                        return i+1;\n                    }\n                }\n                // should have found it by now\n                assert(false);\n            }\n\n            // sum up the counts in the bins until k is subsumed\n            for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {\n                sum += latencyBy10ms[i];\n                if (sum >= k) {\n                    return i * 10 + 5;\n                }\n            }\n            // should have found it by now\n            assert(false);\n        }\n\n        // sum up the counts in the bins until k is subsumed\n        for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {\n            sum += latencyBy100ms[i];\n            if (sum >= k) {\n                return i * 100 + 50;\n            }\n        }\n\n        // too much latency\n        return Integer.MAX_VALUE;\n    }","id":67614,"modified_method":"public int kPercentileLatency(double percentile) {\n        if ((percentile >= 1.0) || (percentile < 0.0)) {\n            throw new RuntimeException(\n                    \"KPercentileLatency accepts values greater than 0 and less than 1\");\n        }\n        if (invocationsCompleted == 0) return -1;\n\n        // find the number of calls with less than percentile latency\n        long k = (long) (invocationsCompleted * percentile);\n        if (k == 0) ++k; // ensure k=0 gives min latency\n\n        long sum = 0;\n        // check if the latency requested is in the 0-100ms bins\n        if (k <= latencyBy100ms[0]) {\n\n            // check if the latency requested is in the 0-10ms bins\n            if (k <= latencyBy10ms[0]) {\n                // sum up the counts in the bins until k is subsumed\n                for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {\n                    sum += latencyBy1ms[i];\n                    if (sum >= k) {\n                        return i+1;\n                    }\n                }\n                // should have found it by now\n                assert(false);\n            }\n\n            // sum up the counts in the bins until k is subsumed\n            for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {\n                sum += latencyBy10ms[i];\n                if (sum >= k) {\n                    return i * 10 + 5;\n                }\n            }\n            // should have found it by now\n            assert(false);\n        }\n\n        // sum up the counts in the bins until k is subsumed\n        for (int i = 0; i < NUMBER_OF_BUCKETS; i++) {\n            sum += latencyBy100ms[i];\n            if (sum >= k) {\n                return i * 100 + 50;\n            }\n        }\n\n        // too much latency\n        return Integer.MAX_VALUE;\n    }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void parse(String[] args) {\n        try {\n            for (Field field : getClass().getFields()) {\n                if (field.isAnnotationPresent(Option.class) == false) {\n                    continue;\n                }\n\n                Option option = field.getAnnotation(Option.class);\n\n                String opt = option.opt();\n                if (opt == null) opt = field.getName();\n\n                options.addOption(opt, option.hasArg(), option.desc());\n            }\n\n            CommandLineParser parser = new GnuParser();\n            CommandLine cmd = parser.parse(options, args);\n\n            for (Field field : getClass().getFields()) {\n                if (field.isAnnotationPresent(Option.class) == false) {\n                    continue;\n                }\n\n                Option option = field.getAnnotation(Option.class);\n\n                String opt = option.opt();\n                if (opt == null) opt = field.getName();\n\n                if (cmd.hasOption(opt)) {\n                    if (option.hasArg()) {\n                        assignValueToField(field, cmd.getOptionValue(opt));\n                    }\n                    else {\n                        if (field.getClass().equals(boolean.class) || field.getClass().equals(Boolean.class)) {\n                            try {\n                                field.set(this, true);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        else {\n                            printUsage();\n                        }\n                    }\n                }\n                else {\n                    if (option.required()) {\n                        printUsage();\n                    }\n                }\n            }\n\n            // check that the values read are valid\n            // this code is specific to your app\n            validate();\n        }\n\n        catch (Exception e) {\n            System.err.println(\"Parsing failed. Reason: \" + e.getMessage());\n            printUsage();\n        }\n    }","id":67615,"modified_method":"public void parse(String[] args) {\n        try {\n            for (Field field : getClass().getDeclaredFields()) {\n                if (field.isAnnotationPresent(Option.class) == false) {\n                    continue;\n                }\n\n                Option option = field.getAnnotation(Option.class);\n\n                String opt = option.opt();\n                if (opt == null) opt = field.getName();\n\n                options.addOption(opt, option.hasArg(), option.desc());\n            }\n\n            CommandLineParser parser = new GnuParser();\n            CommandLine cmd = parser.parse(options, args);\n\n            // string key-value pairs\n            Map<String, String> kvMap = new TreeMap<String, String>();\n\n            for (Field field : getClass().getDeclaredFields()) {\n                if (field.isAnnotationPresent(Option.class) == false) {\n                    continue;\n                }\n\n                Option option = field.getAnnotation(Option.class);\n\n                String opt = option.opt();\n                if ((opt == null) || (opt.length() == 0)) {\n                    opt = field.getName();\n                }\n\n                if (cmd.hasOption(opt)) {\n                    if (option.hasArg()) {\n                        assignValueToField(field, cmd.getOptionValue(opt));\n                    }\n                    else {\n                        if (field.getClass().equals(boolean.class) || field.getClass().equals(Boolean.class)) {\n                            try {\n                                field.set(this, true);\n                            } catch (Exception e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        else {\n                            printUsage();\n                        }\n                    }\n                }\n                else {\n                    if (option.required()) {\n                        printUsage();\n                    }\n                }\n\n                kvMap.put(opt, field.get(this).toString());\n            }\n\n            // check that the values read are valid\n            // this code is specific to your app\n            validate();\n\n            // build a debug string\n            StringBuilder sb = new StringBuilder();\n            for (Entry<String, String> e : kvMap.entrySet()) {\n                sb.append(e.getKey()).append(\" = \").append(e.getValue()).append(\"\\n\");\n            }\n            configDump = sb.toString();\n        }\n\n        catch (Exception e) {\n            System.err.println(\"Parsing failed. Reason: \" + e.getMessage());\n            printUsage();\n        }\n    }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public abstract void validate();","id":67616,"modified_method":"public void validate() {}","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            // TODO Auto-generated method stub\n            super.connectionLost(hostname, port, connectionsLeft, cause);\n        }","id":67617,"modified_method":"@Override\n        public void connectionLost(String hostname, int port, int connectionsLeft, DisconnectCause cause) {\n            System.out.printf(\"Connection to %s:%d was lost.\\n\", hostname, port);\n        }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void connect(String server, int port) {\n        int sleep = 1000;\n        while (true) {\n            try {\n                client.createConnection(server, port);\n                break;\n            }\n            catch (Exception e) {\n                System.err.printf(\"Connection failed - retrying in %d second(s).\\n\", sleep / 1000);\n                try { Thread.sleep(sleep); } catch (Exception interruted) {}\n                if (sleep < 8000) sleep += sleep;\n            }\n        }\n        System.out.printf(\"Connected to %s on port %d.\\n\", server, port);\n    }","id":67618,"modified_method":"/**\n     *\n     * @param servers\n     * @throws InterruptedException\n     */\n    void connect(String servers) throws InterruptedException {\n        System.out.println(\"Connecting to VoltDB...\");\n\n        String[] serverArray = servers.split(\",\");\n        final CountDownLatch connections = new CountDownLatch(serverArray.length);\n        for (final String server : serverArray) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    connectToOneServerWithRetry(server);\n                    connections.countDown();\n                }\n            }).start();\n        }\n        connections.await();\n    }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public static void main(String[] args) throws Exception {\n        VoterConfig config = new VoterConfig();\n        config.parse(args);\n        config.validate();\n\n        VoterBenchmark benchmark = new VoterBenchmark(config);\n        benchmark.runBenchmark();\n    }","id":67619,"modified_method":"public static void main(String[] args) throws Exception {\n        VoterConfig config = new VoterConfig();\n        config.parse(args);\n\n        VoterBenchmark benchmark = new VoterBenchmark(config);\n        benchmark.runBenchmark();\n    }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public synchronized void printResults() {\n        ClientStats stats = client.getStats(false, true, true)[0];\n\n        // 1. Voting Board statistics, Voting results and performance statistics\n        String display = \"\\n\" +\n                         HORIZONTAL_RULE +\n                         \" Voting Results\\n\" +\n                         HORIZONTAL_RULE +\n                         \"A total of %d votes were received...\\n\" +\n                         \" - %,9d Accepted\\n\" +\n                         \" - %,9d Rejected (Invalid Contestant)\\n\" +\n                         \" - %,9d Rejected (Maximum Vote Count Reached)\\n\" +\n                         \" - %,9d Failed (Transaction Error)\\n\\n\";\n\n        System.out.printf(display, stats.invocationsCompleted,\n                acceptedVotes.get(), badContestantVotes.get(),\n                badVoteCountVotes.get(), failedVotes.get());\n\n        long now = System.currentTimeMillis();\n        System.out.printf(\"For %.1f seconds, an average throughput of %d txns/sec was sustained.\\n\",\n                (now - stats.since) / 1000.0, stats.throughput(now));\n        System.out.printf(\"Average latency was %d ms per procedure.\\n\", stats.averageLatency());\n        System.out.printf(\"Average internal latency, as reported by the server was %d ms.\\n\", stats.averageInternalLatency());\n        System.out.printf(\"Measured 95th and 99th percentile latencies were %d and %d ms respectively\\n\",\n                stats.kPercentileLatency(.95), stats.kPercentileLatency(.99));\n    }","id":67620,"modified_method":"/**\n     *\n     * @throws Exception\n     */\n    public synchronized void printResults() throws Exception {\n        ClientStats stats = client.getStats(false, true, true)[0];\n\n        // 1. Voting Board statistics, Voting results and performance statistics\n        String display = \"\\n\" +\n                         HORIZONTAL_RULE +\n                         \" Voting Results\\n\" +\n                         HORIZONTAL_RULE +\n                         \"\\nA total of %d votes were received...\\n\" +\n                         \" - %,9d Accepted\\n\" +\n                         \" - %,9d Rejected (Invalid Contestant)\\n\" +\n                         \" - %,9d Rejected (Maximum Vote Count Reached)\\n\" +\n                         \" - %,9d Failed (Transaction Error)\\n\\n\";\n        System.out.printf(display, stats.invocationsCompleted,\n                acceptedVotes.get(), badContestantVotes.get(),\n                badVoteCountVotes.get(), failedVotes.get());\n\n        // 2. Voting results\n        VoltTable result = client.callProcedure(\"Results\").getResults()[0];\n\n        System.out.println(\"Contestant Name\\t\\tVotes Received\");\n        while(result.advanceRow()) {\n            System.out.printf(\"%s\\t\\t%,14d\\n\", result.getString(0), result.getLong(2));\n        }\n        System.out.printf(\"\\nThe Winner is: %s\\n\\n\", result.fetchRow(0).getString(0));\n\n        // 3. Performance statistics\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" System Statistics\");\n        System.out.println(HORIZONTAL_RULE);\n\n        long now = System.currentTimeMillis();\n        System.out.printf(\"For %.1f seconds, an average throughput of %d txns/sec was sustained.\\n\",\n                (now - stats.since) / 1000.0, stats.throughput(now));\n        System.out.printf(\"Average latency was %d ms per procedure.\\n\", stats.averageLatency());\n        System.out.printf(\"Average internal latency, as reported by the server(s) was %d ms.\\n\", stats.averageInternalLatency());\n        System.out.printf(\"Measured 95th and 99th percentile latencies were %d and %d ms respectively\\n\",\n                stats.kPercentileLatency(.95), stats.kPercentileLatency(.99));\n\n        // 4. Write stats to file if requested\n        if ((config.stats != null) && (config.stats.length() > 0)) {\n            client.writeSummaryCSV(config.stats);\n        }\n    }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public VoterBenchmark(VoterConfig config) {\n        this.config = config;\n\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", new StatusListener());\n        if (config.autoTune) {\n            clientConfig.enableAutoTune();\n            clientConfig.setAutoTuneTargetInternalLatency(config.latencyTarget);\n        }\n        else {\n            clientConfig.setMaxTransactionsPerSecond(config.rateLimit);\n        }\n        client = ClientFactory.createClient(clientConfig);\n        switchboard = new PhoneCallGenerator(config.contestantCount);\n    }","id":67621,"modified_method":"/**\n     *\n     * @param config\n     */\n    public VoterBenchmark(VoterConfig config) {\n        this.config = config;\n\n        ClientConfig clientConfig = new ClientConfig(\"\", \"\", new StatusListener());\n        if (config.autoTune) {\n            clientConfig.enableAutoTune();\n            clientConfig.setAutoTuneTargetInternalLatency(config.latencyTarget);\n        }\n        else {\n            clientConfig.setMaxTransactionsPerSecond(config.rateLimit);\n        }\n        client = ClientFactory.createClient(clientConfig);\n        switchboard = new PhoneCallGenerator(config.contestantCount);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Command Line Configuration\");\n        System.out.println(HORIZONTAL_RULE);\n        System.out.println(config.getConfigDumpString());\n    }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void runBenchmark() throws Exception {\n        // connect\n        connect(\"localhost\", VoltDB.DEFAULT_PORT);\n\n\n        // initialize using synchronous call\n        ClientResponse response = client.callProcedure(\"Initialize\",\n                                                       config.contestantCount,\n                                                       CONTESTANT_NAMES_CSV);\n\n\n        // Create a Timer task to display performance data on the Vote procedure\n        // It calls printStatistics() every displayInterval seconds\n        Timer timer = new Timer();\n        TimerTask statsPrinting = new TimerTask() {\n            @Override\n            public void run() { printStatistics(); }\n        };\n        timer.scheduleAtFixedRate(statsPrinting,\n                                  config.displayInterval * 1000,\n                                  config.displayInterval * 1000);\n\n\n        // Run the benchmark loop for the requested duration\n        final long endTime = System.currentTimeMillis() + (1000l * config.duration);\n        while (endTime > System.currentTimeMillis()) {\n            // Get the next phone call\n            PhoneCallGenerator.PhoneCall call = switchboard.receive();\n\n            client.callProcedure(callback,\n                                 \"Vote\",\n                                 call.phoneNumber,\n                                 call.contestantNumber,\n                                 config.maxVoteCount);\n        }\n\n        timer.cancel(); // cancel periodic stats printing\n\n        // print the summary results\n        printResults();\n\n        // close down the client connections\n        client.close();\n    }","id":67622,"modified_method":"/**\n     *\n     * @throws Exception\n     */\n    public void runBenchmark() throws Exception {\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\" Setup & Initialization\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // connect\n        connect(config.servers);\n\n        // initialize using synchronous call\n        System.out.println(\"\\nPopulating Static Tables\\n\");\n        client.callProcedure(\"Initialize\", config.contestantCount, CONTESTANT_NAMES_CSV);\n\n        System.out.print(HORIZONTAL_RULE);\n        System.out.println(\"Starting Benchmark\");\n        System.out.println(HORIZONTAL_RULE);\n\n        // print periodic statistics to the console\n        schedulePeriodicStats();\n\n        // Run the benchmark loop for the requested duration\n        final long endTime = System.currentTimeMillis() + (1000l * config.duration);\n        while (endTime > System.currentTimeMillis()) {\n            // Get the next phone call\n            PhoneCallGenerator.PhoneCall call = switchboard.receive();\n\n            client.callProcedure(callback,\n                                 \"Vote\",\n                                 call.phoneNumber,\n                                 call.contestantNumber,\n                                 config.maxVoteCount);\n        }\n\n        // cancel periodic stats printing\n        timer.cancel();\n\n        // print the summary results\n        printResults();\n\n        // close down the client connections\n        client.close();\n    }","commit_id":"69b3a46ca6cfa00e646cb764a14b89f755f1c569","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Serialize more tuples from the specified table that has an active stream of the specified type\n     * @param pointer Pointer to an engine instance\n     * @param tableId Catalog ID of the table to serialize\n     * @param streamType type of stream to pull data from\n     * @param data Serialized buffer count and array\n     * @return remaining tuple count, 0 when done, or -1 for an error.\n     * array of per-buffer byte counts with an extra leading int that is set to\n     *         the count of unstreamed tuples, 0 when done, or -1 indicating an error\n     *         (such as the table not being COW mode).\n     */\n    protected native long nativeTableStreamSerializeMore(long pointer, int tableId, int streamType, byte[] data);","id":67623,"modified_method":"/**\n     * Serialize more tuples from the specified table that has an active stream of the specified type\n     * @param pointer Pointer to an engine instance\n     * @param bufferPointer Buffer to serialize data to\n     * @param offset Offset into the buffer to start serializing to\n     * @param length length of the buffer\n     * @param tableId Catalog ID of the table to serialize\n     * @param streamType type of stream to pull data from\n     * @return A positive number indicating the number of bytes serialized or 0 if there is no more data.\n     *         -1 is returned if there is an error (such as the table not being COW mode).\n     */\n    protected native int nativeTableStreamSerializeMore(long pointer, long bufferPointer, int offset, int length, int tableId, int streamType);","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Serialize more tuples from the specified table that already has a stream enabled\n     * @param bbcontainers Buffers to receive serialized tuple data\n     * @param tableId Catalog ID of the table to serialize\n     * @return A positive number indicating the number of bytes serialized or 0 if there is no more data.\n     *        -1 is returned if there is an error (such as the table not having the specified stream type activated).\n     */\n    public abstract int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType type);","id":67624,"modified_method":"/**\n     * Serialize more tuples from the specified table that already has a stream enabled\n     * @param c Buffer to serialize tuple data too\n     * @param tableId Catalog ID of the table to serialize\n     * @return A positive number indicating the number of bytes serialized or 0 if there is no more data.\n     *        -1 is returned if there is an error (such as the table not having the specified stream type activated).\n     */\n    public abstract int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType type);","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Active a table stream of the specified type for a table.\n     * @param pointer Pointer to an engine instance\n     * @param tableId Catalog ID of the table\n     * @param streamType type of stream to activate\n     * @param data serialized predicates\n     * @return <code>true<\/code> on success and <code>false<\/code> on failure\n     */\n    protected native boolean nativeActivateTableStream(long pointer, int tableId, int streamType, byte[] data);","id":67625,"modified_method":"/**\n     * Active a table stream of the specified type for a table.\n     * @param pointer Pointer to an engine instance\n     * @param tableId Catalog ID of the table\n     * @param streamType type of stream to activate\n     * @return <code>true<\/code> on success and <code>false<\/code> on failure\n     */\n    protected native boolean nativeActivateTableStream(long pointer, int tableId, int streamType);","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        int bytesReturned = -1;\n        ByteBuffer view = c.b.duplicate();\n        try {\n            m_data.clear();\n            m_data.putInt(Commands.TableStreamSerializeMore.m_id);\n            m_data.putInt(tableId);\n            m_data.putInt(streamType.ordinal());\n            m_data.putInt(1);                   // Number of buffers\n            m_data.putInt(c.b.remaining());     // Byte limit\n\n            m_data.flip();\n            m_connection.write();\n\n            m_connection.readStatusByte();\n\n            // Get the count.\n            ByteBuffer countBuffer = ByteBuffer.allocate(4);\n            while (countBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(countBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            countBuffer.flip();\n            final int count = countBuffer.getInt();\n\n            /*\n             * Error or no more tuple data for this table.\n             */\n            if (count == -1 || count == 0) {\n                return count;\n            }\n\n            // Get the remaining tuple count.\n            ByteBuffer remainingBuffer = ByteBuffer.allocate(8);\n            while (remainingBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(remainingBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            remainingBuffer.flip();\n            //TODO: Do something useful with the remaining count.\n            /*final long remaining = */ remainingBuffer.getLong();\n\n            // Get the first length.\n            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n            while (lengthBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(lengthBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            lengthBuffer.flip();\n            final int length = lengthBuffer.getInt();\n\n            bytesReturned = length;\n            view.limit(view.position() + length);\n            while (view.hasRemaining()) {\n                m_connection.m_socketChannel.read(view);\n            }\n        } catch (final IOException e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        return bytesReturned;\n    }","id":67626,"modified_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        int bytesReturned = -1;\n        ByteBuffer view = c.b.duplicate();\n        try {\n            m_data.clear();\n            m_data.putInt(Commands.TableStreamSerializeMore.m_id);\n            m_data.putInt(tableId);\n            m_data.putInt(streamType.ordinal());\n            m_data.putInt(c.b.remaining());\n\n            m_data.flip();\n            m_connection.write();\n\n            m_connection.readStatusByte();\n\n            ByteBuffer lengthBuffer = ByteBuffer.allocate(4);\n            while (lengthBuffer.hasRemaining()) {\n                int read = m_connection.m_socketChannel.read(lengthBuffer);\n                if (read == -1) {\n                    throw new EOFException();\n                }\n            }\n            lengthBuffer.flip();\n            final int length = lengthBuffer.getInt();\n            bytesReturned = length;\n            /*\n             * Error or no more tuple data for this table.\n             */\n            if (length == -1 || length == 0) {\n                return length;\n            }\n            view.limit(view.position() + length);\n            while (view.hasRemaining()) {\n                m_connection.m_socketChannel.read(view);\n            }\n        } catch (final IOException e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        return bytesReturned;\n    }","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        m_data.clear();\n        m_data.putInt(Commands.ActivateTableStream.m_id);\n        m_data.putInt(tableId);\n        m_data.putInt(streamType.ordinal());\n        m_data.putInt(0);       // Predicate count\n\n        try {\n            m_data.flip();\n            m_connection.write();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        int result = ExecutionEngine.ERRORCODE_ERROR;\n        try {\n            result = m_connection.readStatusByte();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        if (result != ExecutionEngine.ERRORCODE_SUCCESS) {\n            return false;\n        }\n        return true;\n    }","id":67627,"modified_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        m_data.clear();\n        m_data.putInt(Commands.ActivateTableStream.m_id);\n        m_data.putInt(tableId);\n        m_data.putInt(streamType.ordinal());\n\n        try {\n            m_data.flip();\n            m_connection.write();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        int result = ExecutionEngine.ERRORCODE_ERROR;\n        try {\n            result = m_connection.readStatusByte();\n        } catch (final Exception e) {\n            System.out.println(\"Exception: \" + e.getMessage());\n            throw new RuntimeException(e);\n        }\n\n        if (result != ExecutionEngine.ERRORCODE_SUCCESS) {\n            return false;\n        }\n        return true;\n    }","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"Connection(BackendTarget target, int port) {\n            boolean connected = false;\n            int retries = 0;\n            while (!connected) {\n                try {\n                    System.out.println(\"Connecting to localhost:\" + port);\n                    m_socketChannel = SocketChannel.open(new InetSocketAddress(\n                            \"localhost\", port));\n                    m_socketChannel.configureBlocking(true);\n                    m_socket = m_socketChannel.socket();\n                    m_socket.setTcpNoDelay(true);\n                    connected = true;\n                } catch (final Exception e) {\n                    System.out.println(e.getMessage());\n                    if (retries++ <= 10) {\n                        if (retries > 1) {\n                            System.out.printf(\"Failed to connect to IPC EE on port %d. Retry #%d of 10\\n\", port, retries-1);\n                            try {\n                                Thread.sleep(10000);\n                            }\n                            catch (InterruptedException e1) {}\n                        }\n                    }\n                    else {\n                        System.out.printf(\"Failed to initialize IPC EE connection on port %d. Quitting.\\n\", port);\n                        System.exit(-1);\n                    }\n                }\n                if (!connected && retries == 1 && target == BackendTarget.NATIVE_EE_IPC) {\n                    System.out.printf(\"Ready to connect to voltdbipc process on port %d\\n\", port);\n                    System.out.println(\"Press Enter after you have started the EE process to initiate the connection to the EE\");\n                    try {\n                        System.in.read();\n                    } catch (final IOException e1) {\n                        e1.printStackTrace();\n                    }\n                }\n            }\n            System.out.println(\"Created IPC connection for site.\");\n        }","id":67628,"modified_method":"Connection(BackendTarget target, int port) {\n            if (target == BackendTarget.NATIVE_EE_IPC) {\n                System.out.printf(\"Ready to connect to voltdbipc process on port %d\\n\", port);\n                System.out\n                        .println(\"Press enter after you have started the EE process to initiate the connection to the EE\");\n                try {\n                    System.in.read();\n                } catch (final IOException e1) {\n                    e1.printStackTrace();\n                }\n            }\n            try {\n                System.out.println(\"Connecting to localhost:\" + port);\n                m_socketChannel = SocketChannel.open(new InetSocketAddress(\n                        \"localhost\", port));\n                m_socketChannel.configureBlocking(true);\n                m_socket = m_socketChannel.socket();\n                m_socket.setTcpNoDelay(true);\n            } catch (final Exception e) {\n                System.out.println(e.getMessage());\n                System.out\n                        .println(\"Failed to initialize IPC EE connection. Quitting.\");\n                while (true) {}\n\n                //System.exit(-1);\n            }\n            System.out.println(\"Created IPC connection for site.\");\n        }","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        FastSerializer fs = new FastSerializer();\n        try {\n            fs.writeInt(0);                 // Predicate count\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return nativeActivateTableStream(pointer, tableId, streamType.ordinal(), fs.getBytes());\n    }","id":67629,"modified_method":"@Override\n    public boolean activateTableStream(int tableId, TableStreamType streamType) {\n        return nativeActivateTableStream( pointer, tableId, streamType.ordinal());\n    }","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        FastSerializer fs = new FastSerializer();\n        try {\n            fs.writeInt(1);                 // Buffer count\n            fs.writeLong(c.address);        // Pointer\n            fs.writeInt(c.b.position());    // Offset\n            fs.writeInt(c.b.remaining());   // Length\n        }\n        catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        long remaining = nativeTableStreamSerializeMore(pointer, tableId, streamType.ordinal(), fs.getBytes());\n        int[] positions = null;\n        //TODO: Pass remaining count back to caller.\n        // -1 is end of stream.\n        if (remaining == -1) {\n            return 0;\n        }\n        // -2 is an error.\n        if (remaining == -2) {\n            return -1;\n        }\n        assert(deserializer != null);\n        deserializer.clear();\n        int count;\n        try {\n            count = deserializer.readInt();\n            if (count > 0) {\n                positions = new int[count];\n                for (int i = 0; i < count; i++) {\n                    positions[i] = deserializer.readInt();\n                }\n                //TODO: Support multiple streams.\n                assert(positions.length == 1);\n                return positions[0];\n            }\n        } catch (final IOException ex) {\n            LOG.error(\"Failed to deserialize position array\" + ex);\n            throw new EEException(ERRORCODE_WRONG_SERIALIZED_BYTES);\n        }\n\n        return 0;\n    }","id":67630,"modified_method":"@Override\n    public int tableStreamSerializeMore(BBContainer c, int tableId, TableStreamType streamType) {\n        return nativeTableStreamSerializeMore(pointer, c.address, c.b.position(), c.b.remaining(), tableId, streamType.ordinal());\n    }","commit_id":"bd1084555d4c55d3c3d3693775bdf76888ab5cf1","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void passivateObject(Object key, Object obj) throws Exception\n    {\n        // nothing to do\n    }","id":67631,"modified_method":"public void passivateObject(Object obj) throws Exception\n    {\n        // nothing to do\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void activateObject(Object key, Object obj) throws Exception\n    {\n        // nothing to do\n    }","id":67632,"modified_method":"public void activateObject(Object obj) throws Exception\n    {\n        // nothing to do\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public boolean validateObject(Object key, Object obj)\n    {\n        return true;\n    }","id":67633,"modified_method":"public boolean validateObject(Object obj)\n    {\n        return true;\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void initialise() throws InitialisationException\n    {\n        GenericKeyedObjectPool.Config config = new GenericKeyedObjectPool.Config();\n        if (poolingProfile != null)\n        {\n            config.maxIdle = poolingProfile.getMaxIdle();\n            config.maxActive = poolingProfile.getMaxActive();\n            config.maxWait = poolingProfile.getMaxWait();\n            config.whenExhaustedAction = (byte) poolingProfile.getExhaustedAction();\n        }\n        pool = new GenericKeyedObjectPool(this, config);\n\n        try\n        {\n            applyInitialisationPolicy();\n        }\n        catch (Exception e)\n        {\n            throw new InitialisationException(e, this);\n        }\n    }","id":67634,"modified_method":"protected void initialisePool() \n    {\n        GenericObjectPool.Config config = new GenericObjectPool.Config();\n        if (poolingProfile != null)\n        {\n            config.maxIdle = poolingProfile.getMaxIdle();\n            config.maxActive = poolingProfile.getMaxActive();\n            config.maxWait = poolingProfile.getMaxWait();\n            config.whenExhaustedAction = (byte) poolingProfile.getExhaustedAction();\n        }\n        pool = new GenericObjectPool(this, config);\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public PooledObjectFactory(Class objectClass, Map properties, PoolingProfile poolingProfile) \n    { \n        super(objectClass, properties); \n        this.poolingProfile = poolingProfile;\n    }","id":67635,"modified_method":"public PooledObjectFactory(Class objectClass, Map properties, PoolingProfile poolingProfile) { super(objectClass, properties, poolingProfile); }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public void destroyObject(Object key, Object obj) throws Exception\n    {\n        if (obj instanceof Disposable)\n        {\n            ((Disposable) obj).dispose();\n        }\n    }","id":67636,"modified_method":"public void destroyObject(Object obj) throws Exception\n    {\n        if (obj instanceof Disposable)\n        {\n            ((Disposable) obj).dispose();\n        }\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"/** {@inheritDoc} */\n    public Object lookup(String id) throws Exception\n    {\n        return pool.borrowObject(id);\n    }","id":67637,"modified_method":"/** {@inheritDoc} */\n    public Object lookup(String id) throws Exception\n    {\n        throw new UnsupportedOperationException(\"This operation is only supported by the PooledIdentifiableObjectFactory\");\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object makeObject(Object key) throws Exception\n    {\n        Object obj = super.getOrCreate();\n        if (obj instanceof Identifiable)\n        {\n            ((Identifiable) obj).setId((String) key);\n        }\n        return obj;\n    }","id":67638,"modified_method":"public Object makeObject() throws Exception\n    {\n        return super.getOrCreate();\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"/** \n     * Returns the object instance to the pool.\n     */\n    public void release(Object object) throws Exception\n    {\n        if (object instanceof Identifiable)\n        {\n            pool.returnObject(((Identifiable) object).getId(), object);\n        }\n    }","id":67639,"modified_method":"/** \n     * Returns the object instance to the pool.\n     */\n    public void release(Object object) throws Exception\n    {\n        pool.returnObject(object);\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates a new instance of the object on each call.\n     */\n    public Object getOrCreate() throws Exception\n    {\n        return pool.borrowObject(UUID.getUUID());\n    }","id":67640,"modified_method":"/**\n     * Creates a new instance of the object on each call.\n     */\n    public Object getOrCreate() throws Exception\n    {\n        return pool.borrowObject();\n    }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public PooledObjectFactory(Class objectClass, PoolingProfile poolingProfile) \n    { \n        super(objectClass);\n        this.poolingProfile = poolingProfile;\n    }","id":67641,"modified_method":"public PooledObjectFactory(Class objectClass, PoolingProfile poolingProfile) { super(objectClass, poolingProfile); }","commit_id":"3bfa5be015538a374db4349c0f9f0ae52b646ad0","url":"https://github.com/mulesoft/mule"},{"original_method":"public PooledObjectFactory(Class objectClass, Map properties, PoolingProfile poolingProfile) { super(objectClass, properties, poolingProfile); }","id":67642,"modified_method":"public PooledObjectFactory(Class objectClass, Map properties, PoolingProfile poolingProfile) \n    { \n        super(objectClass, properties); \n        this.poolingProfile = poolingProfile;\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public Object makeObject() throws Exception\n    {\n        return super.getOrCreate();\n    }","id":67643,"modified_method":"public Object makeObject(Object key) throws Exception\n    {\n        Object obj = super.getOrCreate();\n        if (obj instanceof Identifiable)\n        {\n            ((Identifiable) obj).setId((String) key);\n        }\n        return obj;\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"/** \n     * Returns the object instance to the pool.\n     */\n    public void release(Object object) throws Exception\n    {\n        pool.returnObject(object);\n    }","id":67644,"modified_method":"/** \n     * Returns the object instance to the pool.\n     */\n    public void release(Object object) throws Exception\n    {\n        if (object instanceof Identifiable)\n        {\n            pool.returnObject(((Identifiable) object).getId(), object);\n        }\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public PooledObjectFactory(Class objectClass, PoolingProfile poolingProfile) { super(objectClass, poolingProfile); }","id":67645,"modified_method":"public PooledObjectFactory(Class objectClass, PoolingProfile poolingProfile) \n    { \n        super(objectClass);\n        this.poolingProfile = poolingProfile;\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public boolean validateObject(Object obj)\n    {\n        return true;\n    }","id":67646,"modified_method":"public boolean validateObject(Object key, Object obj)\n    {\n        return true;\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"protected void initialisePool() \n    {\n        GenericObjectPool.Config config = new GenericObjectPool.Config();\n        if (poolingProfile != null)\n        {\n            config.maxIdle = poolingProfile.getMaxIdle();\n            config.maxActive = poolingProfile.getMaxActive();\n            config.maxWait = poolingProfile.getMaxWait();\n            config.whenExhaustedAction = (byte) poolingProfile.getExhaustedAction();\n        }\n        pool = new GenericObjectPool(this, config);\n    }","id":67647,"modified_method":"public void initialise() throws InitialisationException\n    {\n        GenericKeyedObjectPool.Config config = new GenericKeyedObjectPool.Config();\n        if (poolingProfile != null)\n        {\n            config.maxIdle = poolingProfile.getMaxIdle();\n            config.maxActive = poolingProfile.getMaxActive();\n            config.maxWait = poolingProfile.getMaxWait();\n            config.whenExhaustedAction = (byte) poolingProfile.getExhaustedAction();\n        }\n        pool = new GenericKeyedObjectPool(this, config);\n\n        try\n        {\n            applyInitialisationPolicy();\n        }\n        catch (Exception e)\n        {\n            throw new InitialisationException(e, this);\n        }\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"/** {@inheritDoc} */\n    public Object lookup(String id) throws Exception\n    {\n        throw new UnsupportedOperationException(\"This operation is only supported by the PooledIdentifiableObjectFactory\");\n    }","id":67648,"modified_method":"/** {@inheritDoc} */\n    public Object lookup(String id) throws Exception\n    {\n        return pool.borrowObject(id);\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public void passivateObject(Object obj) throws Exception\n    {\n        // nothing to do\n    }","id":67649,"modified_method":"public void passivateObject(Object key, Object obj) throws Exception\n    {\n        // nothing to do\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public void destroyObject(Object obj) throws Exception\n    {\n        if (obj instanceof Disposable)\n        {\n            ((Disposable) obj).dispose();\n        }\n    }","id":67650,"modified_method":"public void destroyObject(Object key, Object obj) throws Exception\n    {\n        if (obj instanceof Disposable)\n        {\n            ((Disposable) obj).dispose();\n        }\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"/**\n     * Creates a new instance of the object on each call.\n     */\n    public Object getOrCreate() throws Exception\n    {\n        return pool.borrowObject();\n    }","id":67651,"modified_method":"/**\n     * Creates a new instance of the object on each call.\n     */\n    public Object getOrCreate() throws Exception\n    {\n        return pool.borrowObject(UUID.getUUID());\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public void activateObject(Object obj) throws Exception\n    {\n        // nothing to do\n    }","id":67652,"modified_method":"public void activateObject(Object key, Object obj) throws Exception\n    {\n        // nothing to do\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testSingleMessage() throws Exception\n    {\n        if (client == null)\n        {\n            client = new MuleClient();\n        }\n        Map properties = new HashMap();\n        properties.put(MuleProperties.MULE_REPLY_TO_PROPERTY, \"receive\");\n        client.dispatch(\"dispatch\", \"Message\", properties);\n        UMOMessage response = client.receive(\"receive\", 3000L);\n        assertNotNull(\"Response is null\", response);\n        assertEquals(\"Message Received\", response.getPayload());\n    }","id":67653,"modified_method":"public void testSingleMessage() throws Exception\n    {\n        MuleClient client = new MuleClient();\n        Map properties = new HashMap();\n        properties.put(MuleProperties.MULE_REPLY_TO_PROPERTY, \"receive\");\n        client.dispatch(\"dispatch\", \"Message\", properties);\n        UMOMessage response = client.receive(\"receive\", 3000L);\n        assertNotNull(\"Response is null\", response);\n        assertEquals(\"Message Received\", response.getPayload());\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"public void testManyMessage() throws Exception\n    {\n        int NUM_MESSAGES = 1000;\n        int msg = 0;\n        try\n        {\n            while (msg < NUM_MESSAGES)\n            {\n                testSingleMessage();\n                msg++;\n            }\n        }\n        finally \n        {\n            logger.info(msg + \" messages out of \" + NUM_MESSAGES + \" processed sucessfully.\");\n        }\n    }","id":67654,"modified_method":"public void testManyMessage() throws Exception\n    {\n        for (int i = 0; i < 1000; i++)\n        {\n            testSingleMessage();\n        }\n    }","commit_id":"0ebf2a20ac10dd0adbb5c2ee5dcc606c966fa429","url":"https://github.com/mulesoft/mule"},{"original_method":"GetOrCreateTask( GraphDatabaseService db, Node lockNode, int numUsers, GetOrCreate impl, String name )\n        {\n            super( name );\n            this.db = db;\n            this.lockNode = lockNode;\n            this.numUsers = numUsers;\n            this.impl = impl;\n        }","id":67655,"modified_method":"GetOrCreateTask( GraphDatabaseService db, Node lockNode, int numUsers, GetOrCreate impl, String name,\n                UniqueFactory<Node> uniqueFactory )\n        {\n            super( name );\n            this.db = db;\n            this.lockNode = lockNode;\n            this.numUsers = numUsers;\n            this.impl = impl;\n            this.uniqueFactory = uniqueFactory;\n        }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public Node getOrCreateUser( String username, GraphDatabaseService graphDb, Node lockNode )\n        {\n            return getOrCreateUserPessimistically( username, graphDb, lockNode );\n        }","id":67656,"modified_method":"@Override\n        public Node getOrCreateUser( String username, GraphDatabaseService graphDb, Node lockNode,\n                UniqueFactory<Node> uniqueFactory )\n        {\n            return getOrCreateUserPessimistically( username, graphDb, lockNode );\n        }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"private Node createNode()\n        {\n            Transaction tx = graphdb().beginTx();\n            try\n            {\n                final Node node = graphdb().createNode();\n                tx.success();\n                return node;\n            }\n            finally\n            {\n                tx.finish();\n            }\n        }","id":67657,"modified_method":"private Node createLockNode()\n        {\n            // START SNIPPET: prepareLockNode\n            Transaction tx = graphdb().beginTx();\n            try\n            {\n                final Node lockNode = graphdb().createNode();\n                tx.success();\n                return lockNode;\n            }\n            finally\n            {\n                tx.finish();\n            }\n            // END SNIPPET: prepareLockNode\n        }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Node getOrCreateUserPessimistically( String username, GraphDatabaseService graphDb, \n                                                Node lockNode )\n    {\n        Index<Node> usersIndex = graphDb.index().forNodes( \"users\" );\n        Node userNode = usersIndex.get( \"name\", username ).getSingle();\n        if ( userNode != null ) return userNode;\n        Transaction tx = graphDb.beginTx();\n        try\n        {\n            tx.acquireWriteLock( lockNode );\n            userNode = usersIndex.get( \"name\", username ).getSingle();\n            if ( userNode == null )\n            {\n                userNode = graphDb.createNode();\n                userNode.setProperty( \"name\", username );\n                usersIndex.add( userNode, \"name\", username );\n            }\n            tx.success();\n            return userNode;\n        }\n        finally\n        {\n            tx.finish();\n        }\n    }","id":67658,"modified_method":"public Node getOrCreateUserPessimistically( String username, GraphDatabaseService graphDb, Node lockNode )\n    {\n        // START SNIPPET: pessimisticLocking\n        Transaction tx = graphDb.beginTx();\n        try\n        {\n            Index<Node> usersIndex = graphDb.index().forNodes( \"users\" );\n            Node userNode = usersIndex.get( \"name\", username ).getSingle();\n            if ( userNode != null ) return userNode;\n\n            tx.acquireWriteLock( lockNode );\n            userNode = usersIndex.get( \"name\", username ).getSingle();\n            if ( userNode == null )\n            {\n                userNode = graphDb.createNode();\n                userNode.setProperty( \"name\", username );\n                usersIndex.add( userNode, \"name\", username );\n            }\n            tx.success();\n            return userNode;\n        }\n        finally\n        {\n            tx.finish();\n        }\n        // END SNIPPET: pessimisticLocking\n    }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void run()\n        {\n            try\n            {\n                List<Node> subresult = new ArrayList<Node>();\n                for ( int j = 0; j < numUsers; j++ )\n                {\n                    subresult.add( impl.getOrCreateUser( getUsername( j ), db, lockNode ) );\n                }\n                this.result = subresult;\n            }\n            catch ( RuntimeException e )\n            {\n                failure = e;\n                throw e;\n            }\n        }","id":67659,"modified_method":"@Override\n        public void run()\n        {\n            try\n            {\n                List<Node> subresult = new ArrayList<Node>();\n                for ( int j = 0; j < numUsers; j++ )\n                {\n                    subresult.add( impl.getOrCreateUser( getUsername( j ), db, lockNode, uniqueFactory ) );\n                }\n                this.result = subresult;\n            }\n            catch ( RuntimeException e )\n            {\n                failure = e;\n                throw e;\n            }\n        }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public void run()\n        {\n            final Node lockNode = createNode();\n            final List<GetOrCreateTask> threads = new ArrayList<GetOrCreateTask>();\n            int numThreads = Runtime.getRuntime().availableProcessors()*2;\n            for ( int i = 0; i < numThreads; i++ )\n            {\n                threads.add( new GetOrCreateTask( db, lockNode, NUM_USERS, impl,\n                        GetOrCreateDocIT.class.getSimpleName() + \" thread \" + i ) );\n            }\n            for ( Thread thread : threads )\n            {\n                thread.start();\n            }\n            \n            RuntimeException failure = null;\n            List<List<Node>> results = new ArrayList<List<Node>>();\n            for ( GetOrCreateTask thread : threads )\n            {\n                try\n                {\n                    thread.join();\n                    if ( failure == null )\n                        failure = thread.failure;\n                    \n                    results.add( thread.result );\n                }\n                catch ( InterruptedException e )\n                {\n                    e.printStackTrace();\n                }\n            }\n            \n            if ( failure != null )\n                throw failure;\n\n            assertEquals( numThreads, results.size() );\n            List<Node> firstResult = results.remove( 0 );\n            for ( List<Node> subresult : results )\n            {\n                assertEquals( firstResult, subresult );\n            }\n            for ( int i = 0; i < NUM_USERS; i++ )\n            {\n                final String username = getUsername( i );\n                impl.getOrCreateUser( username, graphdb(), lockNode );\n                assertUserExistsUniquely( username );\n            }\n        }","id":67660,"modified_method":"@Override\n        public void run()\n        {\n            final Node lockNode = createLockNode();\n            final UniqueFactory<Node> uniqueFactory = createUniqueFactory();\n            final List<GetOrCreateTask> threads = new ArrayList<GetOrCreateTask>();\n            int numThreads = Runtime.getRuntime()\n                    .availableProcessors() * 2;\n            for ( int i = 0; i < numThreads; i++ )\n            {\n                threads.add( new GetOrCreateTask( db, lockNode, NUM_USERS, impl, GetOrCreateDocIT.class.getSimpleName()\n                                                                                 + \" thread \" + i, uniqueFactory ) );\n            }\n            for ( Thread thread : threads )\n            {\n                thread.start();\n            }\n\n            RuntimeException failure = null;\n            List<List<Node>> results = new ArrayList<List<Node>>();\n            for ( GetOrCreateTask thread : threads )\n            {\n                try\n                {\n                    thread.join();\n                    if ( failure == null ) failure = thread.failure;\n\n                    results.add( thread.result );\n                }\n                catch ( InterruptedException e )\n                {\n                    e.printStackTrace();\n                }\n            }\n\n            if ( failure != null ) throw failure;\n\n            assertEquals( numThreads, results.size() );\n            List<Node> firstResult = results.remove( 0 );\n            for ( List<Node> subresult : results )\n            {\n                assertEquals( firstResult, subresult );\n            }\n            for ( int i = 0; i < NUM_USERS; i++ )\n            {\n                final String username = getUsername( i );\n                impl.getOrCreateUser( username, graphdb(), lockNode, uniqueFactory );\n                assertUserExistsUniquely( username );\n            }\n        }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"@Override\n        public Node getOrCreateUser( String username, GraphDatabaseService graphDb, Node lockNode )\n        {\n            return getOrCreateUserWithUniqueFactory( username, graphDb );\n        }","id":67661,"modified_method":"@Override\n        public Node getOrCreateUser( String username, GraphDatabaseService graphDb, Node lockNode,\n                UniqueFactory<Node> uniqueFactory )\n        {\n            return getOrCreateUserWithUniqueFactory( username, graphDb, uniqueFactory );\n        }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"public Node getOrCreateUserWithUniqueFactory( String username, GraphDatabaseService graphDb )\n    {\n        UniqueFactory<Node> factory = new UniqueFactory.UniqueNodeFactory( graphDb, \"users\" )\n        {\n            @Override\n            protected void initialize( Node created, Map<String, Object> properties )\n            {\n                created.setProperty( \"name\", properties.get( \"name\" ) );\n            }\n        };\n\n        return factory.getOrCreate( \"name\", username );\n    }","id":67662,"modified_method":"public Node getOrCreateUserWithUniqueFactory( String username, GraphDatabaseService graphDb,\n            UniqueFactory<Node> factory )\n    {\n        // START SNIPPET: getOrCreate\n        Transaction transaction = graphDb.beginTx();\n        try\n        {\n            Node node = factory.getOrCreate( \"name\", username );\n            transaction.success();\n            return node;\n        }\n        finally\n        {\n            transaction.finish();\n        }\n        // END SNIPPET: getOrCreate\n    }","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"Node getOrCreateUser( String username, GraphDatabaseService graphDb, Node lockNode );","id":67663,"modified_method":"Node getOrCreateUser( String username, GraphDatabaseService graphDb, Node lockNode,\n                UniqueFactory<Node> uniqueFactory );","commit_id":"5412743061fec69560ae7c1995f6f2f264cea151","url":"https://github.com/neo4j/neo4j"},{"original_method":"public static void deploy(final OperationContext context, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            // Create the deployment model utils\n            final DeploymentModelUtils model = DeploymentModelUtils.create(context, PathAddress.EMPTY_ADDRESS);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n                    final ServiceController<?> deploymentController = serviceRegistry.getService(deploymentUnitServiceName);\n                    if (deploymentController != null) {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        deploymentController.addListener(verificationHandler);\n                        deploymentController.setMode(ServiceController.Mode.ACTIVE);\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            deploymentController.setMode(ServiceController.Mode.NEVER);\n                        }\n                    } else {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, model, contents);\n\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            for(ServiceController<?> controller : controllers) {\n                                context.removeService(controller.getName());\n                            }\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","id":67664,"modified_method":"public static void deploy(final OperationContext context, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (context.getType() == OperationContext.Type.SERVER) {\n            //\n            final Resource deployment = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = context.getResourceRegistration();\n            DeploymentModelUtils.cleanup(deployment);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    final ServiceRegistry serviceRegistry = context.getServiceRegistry(true);\n                    final ServiceController<?> deploymentController = serviceRegistry.getService(deploymentUnitServiceName);\n                    if (deploymentController != null) {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        deploymentController.addListener(verificationHandler);\n                        deploymentController.setMode(ServiceController.Mode.ACTIVE);\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            deploymentController.setMode(ServiceController.Mode.NEVER);\n                        }\n                    } else {\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, contents);\n\n                        context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                        if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                            for(ServiceController<?> controller : controllers) {\n                                context.removeService(controller.getName());\n                            }\n                        }\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void replace(final OperationContext operationContext, final ModelNode originalDeployment, final String deploymentUnitName, final String managementName,\n                               final String replacedDeploymentUnitName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            // Create the deployment model utils\n            final DeploymentModelUtils model = DeploymentModelUtils.create(operationContext, PathAddress.EMPTY_ADDRESS.append(PathElement.pathElement(DEPLOYMENT, managementName)));\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName replacedDeploymentUnitServiceName = Services.deploymentUnitName(replacedDeploymentUnitName);\n                    final ServiceName replacedContentsServiceName = replacedDeploymentUnitServiceName.append(\"contents\");\n                    operationContext.removeService(replacedContentsServiceName);\n                    operationContext.removeService(replacedDeploymentUnitServiceName);\n\n                    ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, model, contents);\n                    context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        for(ServiceController<?> controller : controllers) {\n                            context.removeService(controller.getName());\n                        }\n\n                        final String name = originalDeployment.require(NAME).asString();\n                        final String runtimeName = originalDeployment.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(originalDeployment.require(CONTENT));\n                        verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, model, contents);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","id":67665,"modified_method":"public static void replace(final OperationContext operationContext, final ModelNode originalDeployment, final String deploymentUnitName, final String managementName,\n                               final String replacedDeploymentUnitName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            //\n            final PathElement path = PathElement.pathElement(DEPLOYMENT, managementName);\n            final Resource deployment = operationContext.readResourceForUpdate(PathAddress.EMPTY_ADDRESS.append(path));\n            final ImmutableManagementResourceRegistration registration = operationContext.getResourceRegistration().getSubModel(PathAddress.EMPTY_ADDRESS.append(path));\n            DeploymentModelUtils.cleanup(deployment);\n\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName replacedDeploymentUnitServiceName = Services.deploymentUnitName(replacedDeploymentUnitName);\n                    final ServiceName replacedContentsServiceName = replacedDeploymentUnitServiceName.append(\"contents\");\n                    operationContext.removeService(replacedContentsServiceName);\n                    operationContext.removeService(replacedDeploymentUnitServiceName);\n\n                    ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                    final Collection<ServiceController<?>> controllers = doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration, contents);\n                    context.addStep(verificationHandler, OperationContext.Stage.VERIFY);\n\n                    if (context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        for(ServiceController<?> controller : controllers) {\n                            context.removeService(controller.getName());\n                        }\n\n                        DeploymentModelUtils.cleanup(deployment);\n                        final String name = originalDeployment.require(NAME).asString();\n                        final String runtimeName = originalDeployment.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(originalDeployment.require(CONTENT));\n                        verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, deployment, registration, contents);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void redeploy(final OperationContext operationContext, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            // Create the deployment model utils\n            final DeploymentModelUtils model = DeploymentModelUtils.create(operationContext, PathAddress.EMPTY_ADDRESS);\n\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    context.addStep(new OperationStepHandler() {\n                        @Override\n                        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                            ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                            doDeploy(context, deploymentUnitName, managementName, verificationHandler, model, contents);\n                            context.completeStep();\n                        }\n                    }, OperationContext.Stage.IMMEDIATE);\n                    context.completeStep();\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        operationContext.completeStep();\n    }","id":67666,"modified_method":"public static void redeploy(final OperationContext operationContext, final String deploymentUnitName, final String managementName, final ContentItem... contents) throws OperationFailedException {\n        assert contents != null : \"contents is null\";\n\n        if (operationContext.getType() == OperationContext.Type.SERVER) {\n            //\n            final Resource deployment = operationContext.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = operationContext.getResourceRegistration();\n            DeploymentModelUtils.cleanup(deployment);\n\n            operationContext.addStep(new OperationStepHandler() {\n                public void execute(final OperationContext context, ModelNode operation) throws OperationFailedException {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    context.addStep(new OperationStepHandler() {\n                        @Override\n                        public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                            ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                            doDeploy(context, deploymentUnitName, managementName, verificationHandler, deployment, registration,  contents);\n                            context.completeStep();\n                        }\n                    }, OperationContext.Stage.IMMEDIATE);\n                    context.completeStep();\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n        operationContext.completeStep();\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static Collection<ServiceController<?>> doDeploy(final OperationContext context, final String deploymentUnitName, final String managementName, final ServiceVerificationHandler verificationHandler, final DeploymentModelUtils model, final ContentItem... contents) {\n        final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n        final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final ServiceController<?> contentService;\n        // TODO: overlay service\n        final ServiceName contentsServiceName = deploymentUnitServiceName.append(\"contents\");\n        if (contents[0].hash != null)\n            contentService = ContentServitor.addService(serviceTarget, contentsServiceName, contents[0].hash, verificationHandler);\n        else {\n            final String path = contents[0].path;\n            final String relativeTo = contents[0].relativeTo;\n\n            final ServiceName relativeToPathServiceName = relativeTo != null ? RelativePathService.pathNameOf(relativeTo) : null;\n            contentService = PathContentServitor.addService(serviceTarget, contentsServiceName, path, relativeToPathServiceName, verificationHandler);\n        }\n        controllers.add(contentService);\n\n        final RootDeploymentUnitService service = new RootDeploymentUnitService(deploymentUnitName, managementName, null, model);\n        final ServiceController<DeploymentUnit> deploymentUnitController = serviceTarget.addService(deploymentUnitServiceName, service)\n                .addDependency(Services.JBOSS_DEPLOYMENT_CHAINS, DeployerChains.class, service.getDeployerChainsInjector())\n                .addDependency(ServerDeploymentRepository.SERVICE_NAME, ServerDeploymentRepository.class, service.getServerDeploymentRepositoryInjector())\n                .addDependency(contentsServiceName, VirtualFile.class, service.contentsInjector)\n                .addListener(ServiceListener.Inheritance.ALL, verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        controllers.add(deploymentUnitController);\n\n        contentService.addListener(new AbstractServiceListener<Object>() {\n            @Override\n            public void transition(final ServiceController<? extends Object> controller, final ServiceController.Transition transition) {\n                if (transition == ServiceController.Transition.REMOVING_to_REMOVED) {\n                    deploymentUnitController.setMode(REMOVE);\n                }\n            }\n        });\n        return controllers;\n    }","id":67667,"modified_method":"private static Collection<ServiceController<?>> doDeploy(final OperationContext context, final String deploymentUnitName, final String managementName, final ServiceVerificationHandler verificationHandler,\n                                                             final Resource deploymentResource, final ImmutableManagementResourceRegistration registration, final ContentItem... contents) {\n        final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n        final List<ServiceController<?>> controllers = new ArrayList<ServiceController<?>>();\n\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final ServiceController<?> contentService;\n        // TODO: overlay service\n        final ServiceName contentsServiceName = deploymentUnitServiceName.append(\"contents\");\n        if (contents[0].hash != null)\n            contentService = ContentServitor.addService(serviceTarget, contentsServiceName, contents[0].hash, verificationHandler);\n        else {\n            final String path = contents[0].path;\n            final String relativeTo = contents[0].relativeTo;\n\n            final ServiceName relativeToPathServiceName = relativeTo != null ? RelativePathService.pathNameOf(relativeTo) : null;\n            contentService = PathContentServitor.addService(serviceTarget, contentsServiceName, path, relativeToPathServiceName, verificationHandler);\n        }\n        controllers.add(contentService);\n\n        final RootDeploymentUnitService service = new RootDeploymentUnitService(deploymentUnitName, managementName, null, registration, deploymentResource);\n        final ServiceController<DeploymentUnit> deploymentUnitController = serviceTarget.addService(deploymentUnitServiceName, service)\n                .addDependency(Services.JBOSS_DEPLOYMENT_CHAINS, DeployerChains.class, service.getDeployerChainsInjector())\n                .addDependency(ServerDeploymentRepository.SERVICE_NAME, ServerDeploymentRepository.class, service.getServerDeploymentRepositoryInjector())\n                .addDependency(contentsServiceName, VirtualFile.class, service.contentsInjector)\n                .addListener(ServiceListener.Inheritance.ALL, verificationHandler)\n                .setInitialMode(ServiceController.Mode.ACTIVE)\n                .install();\n        controllers.add(deploymentUnitController);\n\n        contentService.addListener(new AbstractServiceListener<Object>() {\n            @Override\n            public void transition(final ServiceController<? extends Object> controller, final ServiceController.Transition transition) {\n                if (transition == ServiceController.Transition.REMOVING_to_REMOVED) {\n                    deploymentUnitController.setMode(REMOVE);\n                }\n            }\n        });\n        return controllers;\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static void undeploy(final OperationContext context, final String deploymentUnitName) {\n        if (context.getType() == OperationContext.Type.SERVER) {\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n                        final String name = model.require(NAME).asString();\n                        final String runtimeName = model.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(model.require(CONTENT));\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, null, contents);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","id":67668,"modified_method":"public static void undeploy(final OperationContext context, final String deploymentUnitName) {\n        if (context.getType() == OperationContext.Type.SERVER) {\n            final Resource deployment = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS);\n            final ImmutableManagementResourceRegistration registration = context.getResourceRegistration();\n            DeploymentModelUtils.cleanup(deployment);\n\n            context.addStep(new OperationStepHandler() {\n                public void execute(OperationContext context, ModelNode operation) {\n                    final ServiceName deploymentUnitServiceName = Services.deploymentUnitName(deploymentUnitName);\n\n                    context.removeService(deploymentUnitServiceName);\n                    context.removeService(deploymentUnitServiceName.append(\"contents\"));\n\n                    if(context.completeStep() == OperationContext.ResultAction.ROLLBACK) {\n                        final ModelNode model = context.readModel(PathAddress.EMPTY_ADDRESS);\n                        final String name = model.require(NAME).asString();\n                        final String runtimeName = model.require(RUNTIME_NAME).asString();\n                        final DeploymentHandlerUtil.ContentItem[] contents = getContents(model.require(CONTENT));\n                        final ServiceVerificationHandler verificationHandler = new ServiceVerificationHandler();\n                        doDeploy(context, runtimeName, name, verificationHandler, deployment, registration, contents);\n                    }\n                }\n            }, OperationContext.Stage.RUNTIME);\n        }\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"DeploymentModelUtils createSubDeployment(final String deploymentName) {\n        final Resource subDeploymentRoot = getOrCreate(root, PathElement.pathElement(SUB_DEPLOYMENT,deploymentName));\n        final DeploymentModelUtils utils = new DeploymentModelUtils(subDeploymentRoot, registration);\n        utils.initialize();\n        return utils;\n    }","id":67669,"modified_method":"static Resource createSubDeployment(final String deploymentName, DeploymentUnit parent) {\n        final Resource root = parent.getAttachment(DEPLOYMENT_RESOURCE);\n        return getOrCreate(root, PathElement.pathElement(SUB_DEPLOYMENT, deploymentName));\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"static Resource getOrCreate(final Resource parent, final PathElement element) {\n        if(parent.hasChild(element)) {\n            return parent.requireChild(element);\n        } else {\n            final Resource resource = Resource.Factory.create();\n            parent.registerChild(element, resource);\n            return resource;\n        }\n    }","id":67670,"modified_method":"static Resource getOrCreate(final Resource parent, final PathElement element) {\n        synchronized(parent) {\n            if(parent.hasChild(element)) {\n                return parent.requireChild(element);\n            } else {\n                final Resource resource = Resource.Factory.create();\n                parent.registerChild(element, resource);\n                return resource;\n            }\n        }\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"ModelNode createDeploymentSubModel(final String subsystemName, final PathElement address) {\n        final Resource subsystem = getOrCreate(root, PathElement.pathElement(SUBSYSTEM, subsystemName));\n        final ImmutableManagementResourceRegistration subModel = registration.getSubModel(getExtensionAddress(subsystemName, address));\n        if(subModel == null) {\n            throw new IllegalStateException(address.toString());\n        }\n        return getOrCreate(subsystem, address).getModel();\n    }","id":67671,"modified_method":"static ModelNode createDeploymentSubModel(final String subsystemName, final PathElement address, final DeploymentUnit unit) {\n        final Resource root = unit.getAttachment(DEPLOYMENT_RESOURCE);\n        synchronized (root) {\n            final ImmutableManagementResourceRegistration registration = unit.getAttachment(REGISTRATION_ATTACHMENT);\n            final Resource subsystem = getOrCreate(root, PathElement.pathElement(SUBSYSTEM, subsystemName));\n            final ImmutableManagementResourceRegistration subModel = registration.getSubModel(getExtensionAddress(subsystemName, address));\n            if(subModel == null) {\n                throw new IllegalStateException(address.toString());\n            }\n            return getOrCreate(subsystem, address).getModel();\n        }\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param parent the parent (enclosing) deployment unit, if any\n     * @param name the deployment unit name\n     * @param serviceRegistry the service registry\n     */\n    DeploymentUnitImpl(final DeploymentUnit parent, final String name, final ServiceRegistry serviceRegistry, final DeploymentModelUtils model) {\n        this.parent = parent;\n        this.name = name;\n        this.serviceRegistry = serviceRegistry;\n        this.model = model;\n    }","id":67672,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param parent the parent (enclosing) deployment unit, if any\n     * @param name the deployment unit name\n     * @param serviceRegistry the service registry\n     * @param registration the resource registration\n     */\n    DeploymentUnitImpl(final DeploymentUnit parent, final String name, final ServiceRegistry serviceRegistry) {\n        this.parent = parent;\n        this.name = name;\n        this.serviceRegistry = serviceRegistry;\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public ModelNode createDeploymentSubModel(final String subsystemName, final PathElement address) {\n        return this.model.createDeploymentSubModel(subsystemName, address);\n    }","id":67673,"modified_method":"@Override\n    public ModelNode createDeploymentSubModel(final String subsystemName, final PathElement address) {\n        return DeploymentModelUtils.createDeploymentSubModel(subsystemName, address, this);\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Construct a new instance.\n     *\n     * @param name the deployment unit simple name\n     * @param managementName the deployment's domain-wide unique name\n     * @param parent the parent deployment unit\n     */\n    public RootDeploymentUnitService(final String name, final String managementName, final DeploymentUnit parent, final DeploymentModelUtils model) {\n        assert name != null : \"name is null\";\n        this.name = name;\n        this.managementName = managementName;\n        this.parent = parent;\n        this.model = model;\n    }","id":67674,"modified_method":"/**\n     * Construct a new instance.\n     *\n     * @param name the deployment unit simple name\n     * @param managementName the deployment's domain-wide unique name\n     * @param parent the parent deployment unit\n     * @param registration the registration\n     * @param resource the model\n     */\n    public RootDeploymentUnitService(final String name, final String managementName, final DeploymentUnit parent, final ImmutableManagementResourceRegistration registration, Resource resource) {\n        assert name != null : \"name is null\";\n        this.name = name;\n        this.managementName = managementName;\n        this.parent = parent;\n        this.registration = registration;\n        this.resource = resource;\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected DeploymentUnit createAndInitializeDeploymentUnit(final ServiceRegistry registry) {\n        model.initialize();\n        final DeploymentUnit deploymentUnit = new DeploymentUnitImpl(parent, name, registry, model);\n        deploymentUnit.putAttachment(Attachments.RUNTIME_NAME, name);\n        deploymentUnit.putAttachment(Attachments.MANAGEMENT_NAME, managementName);\n        deploymentUnit.putAttachment(Attachments.DEPLOYMENT_CONTENTS, contentsInjector.getValue());\n        deploymentUnit.putAttachment(DeploymentModelUtils.KEY, model);\n\n        // Attach the deployment repo\n        deploymentUnit.putAttachment(Attachments.SERVER_DEPLOYMENT_REPOSITORY, serverDeploymentRepositoryInjector.getValue());\n\n        return deploymentUnit;\n    }","id":67675,"modified_method":"protected DeploymentUnit createAndInitializeDeploymentUnit(final ServiceRegistry registry) {\n        final DeploymentUnit deploymentUnit = new DeploymentUnitImpl(parent, name, registry);\n        deploymentUnit.putAttachment(Attachments.RUNTIME_NAME, name);\n        deploymentUnit.putAttachment(Attachments.MANAGEMENT_NAME, managementName);\n        deploymentUnit.putAttachment(Attachments.DEPLOYMENT_CONTENTS, contentsInjector.getValue());\n        deploymentUnit.putAttachment(DeploymentModelUtils.REGISTRATION_ATTACHMENT, registration);\n        deploymentUnit.putAttachment(DeploymentModelUtils.DEPLOYMENT_RESOURCE, resource);\n\n        // Attach the deployment repo\n        deploymentUnit.putAttachment(Attachments.SERVER_DEPLOYMENT_REPOSITORY, serverDeploymentRepositoryInjector.getValue());\n\n        return deploymentUnit;\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> childRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (childRoots != null) {\n            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n            ServiceName previous = null;\n            for (final ResourceRoot childRoot : childRoots) {\n                if (!SubDeploymentMarker.isSubDeployment(childRoot)) {\n                    continue;\n                }\n                final SubDeploymentUnitService service = new SubDeploymentUnitService(childRoot, deploymentUnit);\n\n                final ResourceRoot parentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n                final String relativePath = childRoot.getRoot().getPathNameRelativeTo(parentRoot.getRoot());\n                final ServiceName serviceName = Services.deploymentUnitName(deploymentUnit.getName(), relativePath);\n\n                serviceTarget.addService(serviceName, service)\n                        .addDependency(Services.JBOSS_DEPLOYMENT_CHAINS, DeployerChains.class, service.getDeployerChainsInjector())\n                        .setInitialMode(ServiceController.Mode.ACTIVE)\n                        .install();\n                phaseContext.addDeploymentDependency(serviceName, Attachments.SUB_DEPLOYMENTS);\n                //we also need a dep on the first phase of the sub deployments\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS,serviceName.append(ServiceName.of(Phase.STRUCTURE.name())));\n                previous = serviceName;\n            }\n\n        }\n    }","id":67676,"modified_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> childRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (childRoots != null) {\n            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n            ServiceName previous = null;\n            for (final ResourceRoot childRoot : childRoots) {\n                if (!SubDeploymentMarker.isSubDeployment(childRoot)) {\n                    continue;\n                }\n                final Resource resource = DeploymentModelUtils.createSubDeployment(childRoot.getRootName(), deploymentUnit);\n                final ImmutableManagementResourceRegistration registration = deploymentUnit.getAttachment(DeploymentModelUtils.REGISTRATION_ATTACHMENT);\n                final SubDeploymentUnitService service = new SubDeploymentUnitService(childRoot, deploymentUnit, registration, resource);\n\n                final ResourceRoot parentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n                final String relativePath = childRoot.getRoot().getPathNameRelativeTo(parentRoot.getRoot());\n                final ServiceName serviceName = Services.deploymentUnitName(deploymentUnit.getName(), relativePath);\n\n                serviceTarget.addService(serviceName, service)\n                        .addDependency(Services.JBOSS_DEPLOYMENT_CHAINS, DeployerChains.class, service.getDeployerChainsInjector())\n                        .setInitialMode(ServiceController.Mode.ACTIVE)\n                        .install();\n                phaseContext.addDeploymentDependency(serviceName, Attachments.SUB_DEPLOYMENTS);\n                //we also need a dep on the first phase of the sub deployments\n                phaseContext.addToAttachmentList(Attachments.NEXT_PHASE_DEPS,serviceName.append(ServiceName.of(Phase.STRUCTURE.name())));\n                previous = serviceName;\n            }\n        }\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"public SubDeploymentUnitService(ResourceRoot deploymentRoot, DeploymentUnit parent) {\n        if (deploymentRoot == null) throw new IllegalArgumentException(\"Deployment root is required\");\n        this.deploymentRoot = deploymentRoot;\n        if (parent == null) throw new IllegalArgumentException(\"Sub-deployments require a parent deployment unit\");\n        this.parent = parent;\n    }","id":67677,"modified_method":"public SubDeploymentUnitService(ResourceRoot deploymentRoot, DeploymentUnit parent, ImmutableManagementResourceRegistration registration, Resource resource) {\n        if (deploymentRoot == null) throw new IllegalArgumentException(\"Deployment root is required\");\n        this.deploymentRoot = deploymentRoot;\n        if (parent == null) throw new IllegalArgumentException(\"Sub-deployments require a parent deployment unit\");\n        this.parent = parent;\n        this.registration = registration;\n        this.resource = resource;\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected DeploymentUnit createAndInitializeDeploymentUnit(ServiceRegistry registry) {\n        final String deploymentName = deploymentRoot.getRootName();\n        final DeploymentModelUtils parentModel = parent.getAttachment(DeploymentModelUtils.KEY);\n        final DeploymentUnit deploymentUnit = new DeploymentUnitImpl(parent, deploymentName, registry, parentModel.createSubDeployment(deploymentName));\n        deploymentUnit.putAttachment(Attachments.DEPLOYMENT_ROOT, deploymentRoot);\n        deploymentUnit.putAttachment(Attachments.MODULE_SPECIFICATION, new ModuleSpecification());\n        return deploymentUnit;\n    }","id":67678,"modified_method":"protected DeploymentUnit createAndInitializeDeploymentUnit(ServiceRegistry registry) {\n        final String deploymentName = deploymentRoot.getRootName();\n        final DeploymentUnit deploymentUnit = new DeploymentUnitImpl(parent, deploymentName, registry);\n        deploymentUnit.putAttachment(Attachments.DEPLOYMENT_ROOT, deploymentRoot);\n        deploymentUnit.putAttachment(Attachments.MODULE_SPECIFICATION, new ModuleSpecification());\n        deploymentUnit.putAttachment(DeploymentModelUtils.REGISTRATION_ATTACHMENT, registration);\n        deploymentUnit.putAttachment(DeploymentModelUtils.DEPLOYMENT_RESOURCE, resource);\n        this.resource = null;\n        return deploymentUnit;\n    }","commit_id":"c557191bf641418cf63314979f298b0e27a3dbde","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Locale getLocaleFromString(String localeString) {\n        String[] locValues = (localeString == null ? new String[0] : localeString.trim().split(\"_\"));\n        if (locValues.length >= 3) {\n            return new Locale(locValues[0], locValues[1], locValues[2]); // language, country, variant\n        } else if (locValues.length == 2) {\n            return new Locale(locValues[0], locValues[1]); // language, country\n        } else if (locValues.length == 1) {\n            return new Locale(locValues[0]); // language\n        } else {\n            return Locale.getDefault();\n        }\n    }","id":67679,"modified_method":"public Locale getLocaleFromString(String localeString) {\n        // should this just use LocalUtils.toLocale()?\n        if (localeString != null) {\n            // force en-US (dash separated) values into underscore style\n            localeString = StringUtils.replaceChars(localeString, '-', '_');\n        }\n        String[] locValues = (localeString == null ? new String[0] : localeString.trim().split(\"_\"));\n        if (locValues.length >= 3) {\n            return new Locale(locValues[0], locValues[1], locValues[2]); // language, country, variant\n        } else if (locValues.length == 2) {\n            return new Locale(locValues[0], locValues[1]); // language, country\n        } else if (locValues.length == 1) {\n            return new Locale(locValues[0]); // language\n        } else {\n            return Locale.getDefault();\n        }\n    }","commit_id":"f2f020ef90e21cba9af1260d93f35778346eeb1f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * Get the list of allowed locales as controlled by config params for {@value #SAKAI_LOCALES_KEY} and {@value #SAKAI_LOCALES_MORE}\n     * @return an array of all allowed Locales for this installation\n     */\n    public Locale[] getSakaiLocales() {\n        org.sakaiproject.component.api.ServerConfigurationService scs = (org.sakaiproject.component.api.ServerConfigurationService) ComponentManager.get(org.sakaiproject.component.api.ServerConfigurationService.class);\n        String localesStr = scs.getString(SAKAI_LOCALES_KEY, SakaiLocales.SAKAI_LOCALES_DEFAULT);\n        if (StringUtils.isEmpty(localesStr)) {\n            localesStr = SakaiLocales.SAKAI_LOCALES_DEFAULT;\n        }\n        String[] locales = StringUtils.split(localesStr, ','); // NOTE: these need to be trimmed (which getLocaleFromString will do)\n        String[] localesMore = scs.getStrings(SAKAI_LOCALES_MORE);\n\n        locales = (String[]) ArrayUtils.addAll(locales, localesMore);\n        Locale[] localesArray;\n        if (ArrayUtils.isEmpty(locales)) {\n            // if no locales then use the default only\n            localesArray = new Locale[] { Locale.getDefault() };\n        } else {\n            // convert from strings to Locales\n            localesArray = new Locale[locales.length + 1];\n            for (int i = 0; i < locales.length; i++) {\n                localesArray[i] = getLocaleFromString(locales[i]);\n            }\n            // add default in on the end\n            localesArray[localesArray.length - 1] = Locale.getDefault();\n        }\n\n        // Sort Locales and remove duplicates\n        Arrays.sort(localesArray, new LocaleComparator());\n        return localesArray;\n    }","id":67680,"modified_method":"/**\n     * Get the list of allowed locales as controlled by config params for {@value #SAKAI_LOCALES_KEY} and {@value #SAKAI_LOCALES_MORE}\n     * @return an array of all allowed Locales for this installation\n     */\n    public Locale[] getSakaiLocales() {\n        String localesStr = getString(SAKAI_LOCALES_KEY, SakaiLocales.SAKAI_LOCALES_DEFAULT);\n        if (StringUtils.isEmpty(localesStr)) {\n            localesStr = SakaiLocales.SAKAI_LOCALES_DEFAULT;\n        }\n        String[] locales = StringUtils.split(localesStr, ','); // NOTE: these need to be trimmed (which getLocaleFromString will do)\n        String[] localesMore = getStrings(SAKAI_LOCALES_MORE);\n\n        locales = (String[]) ArrayUtils.addAll(locales, localesMore);\n        HashSet<Locale> localesSet = new HashSet<Locale>();\n        // always include the default locale\n        localesSet.add(Locale.getDefault());\n        if (!ArrayUtils.isEmpty(locales)) {\n            // convert from strings to Locales\n            for (int i = 0; i < locales.length; i++) {\n                localesSet.add(getLocaleFromString(locales[i]));\n            }\n        }\n        // Sort Locales and remove duplicates\n        Locale[] localesArray = localesSet.toArray(new Locale[localesSet.size()]);\n        Arrays.sort(localesArray, new LocaleComparator());\n        return localesArray;\n    }","commit_id":"f2f020ef90e21cba9af1260d93f35778346eeb1f","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected void addDDMTemplate(\n\t\t\tlong groupId, long userId, String ddmTemplateKey, String name,\n\t\t\tString description, String fileName, ServiceContext serviceContext)\n\t\tthrows SystemException, PortalException {\n\n\t\tDDMTemplate ddmTemplate = DDMTemplateLocalServiceUtil.fetchTemplate(\n\t\t\tgroupId, ddmTemplateKey);\n\n\t\tif (ddmTemplate != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString script = ContentUtil.get(\n\t\t\t\"com/liferay/portal/events/dependencies/assetpublisher\" + fileName);\n\n\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\n\t\tnameMap.put(LocaleUtil.getDefault(), name);\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(LocaleUtil.getDefault(), description);\n\n\t\tlong classNameId = PortalUtil.getClassNameId(AssetEntry.class);\n\t\tlong classPK = groupId;\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, classNameId, classPK, ddmTemplateKey, nameMap,\n\t\t\tdescriptionMap, \"list\", null, \"vm\", script, serviceContext);\n\t}","id":67681,"modified_method":"protected void addDDMTemplate(\n\t\t\tlong groupId, long userId, String ddmTemplateKey, String name,\n\t\t\tString description, String fileName, ServiceContext serviceContext)\n\t\tthrows SystemException, PortalException {\n\n\t\tDDMTemplate ddmTemplate = DDMTemplateLocalServiceUtil.fetchTemplate(\n\t\t\tgroupId, ddmTemplateKey);\n\n\t\tif (ddmTemplate != null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString script = ContentUtil.get(\n\t\t\t\"com/liferay/portal/events/dependencies/\" + fileName);\n\n\t\tMap<Locale, String> nameMap = new HashMap<Locale, String>();\n\n\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\tnameMap.put(locale, LanguageUtil.get(locale, name));\n\n\t\tMap<Locale, String> descriptionMap = new HashMap<Locale, String>();\n\n\t\tdescriptionMap.put(locale, LanguageUtil.get(locale, description));\n\n\t\tlong classNameId = PortalUtil.getClassNameId(AssetEntry.class);\n\t\tlong classPK = groupId;\n\n\t\tDDMTemplateLocalServiceUtil.addTemplate(\n\t\t\tuserId, groupId, classNameId, classPK, ddmTemplateKey, nameMap,\n\t\t\tdescriptionMap, \"list\", null, \"vm\", script, serviceContext);\n\t}","commit_id":"9370b973b9727a2c3bd86960339c4c2652e53b5c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addDefaultDDMTemplates(\n\t\t\tlong userId, long groupId, ServiceContext serviceContext)\n\t\tthrows SystemException, PortalException {\n\n\t\t// Custom Abstracts\n\n\t\tString ddmTemplateKey =\n\t\t\tDDMTemplateConstants.CUSTOM_ABSTRACTS_TEMPLATE_KEY;\n\t\tString name = LanguageUtil.get(\n\t\t\tserviceContext.getLocale(), \"custom-abstracts\");\n\t\tString description = LanguageUtil.get(\n\t\t\tserviceContext.getLocale(), \"custom-abstracts-description\");\n\n\t\taddDDMTemplate(\n\t\t\tgroupId, userId, ddmTemplateKey, name, description,\n\t\t\t\"custom-abstracts.vm\", serviceContext);\n\n\t\t// Custom Title List\n\n\t\tddmTemplateKey =\n\t\t\tDDMTemplateConstants.CUSTOM_TITLE_LIST_TEMPLATE_KEY;\n\t\tname = LanguageUtil.get(\n\t\t\tserviceContext.getLocale(), \"custom-title-list\");\n\t\tdescription = LanguageUtil.get(\n\t\t\tserviceContext.getLocale(), \"custom-title-list-description\");\n\n\t\taddDDMTemplate(\n\t\t\tgroupId, userId, ddmTemplateKey, name, description,\n\t\t\t\"custom-title-list.vm\", serviceContext);\n\t}","id":67682,"modified_method":"protected void addDefaultDDMTemplates(\n\t\t\tlong userId, long groupId, ServiceContext serviceContext)\n\t\tthrows SystemException, PortalException {\n\n\t\t// Custom Abstracts\n\n\t\taddDDMTemplate(\n        \tgroupId, userId, DDMTemplateConstants.TEMPLATE_KEY_CUSTOM_ABSTRACTS,\n        \t\"custom-abstracts\", \"custom-abstracts-description\",\n        \t\"asset-publisher-custom-abstracts.vm\", serviceContext);\n\n\t\t// Custom Title List\n\n    \taddDDMTemplate(\n\t\t\tgroupId, userId,\n\t\t\tDDMTemplateConstants.TEMPLATE_KEY_CUSTOM_TITLE_LIST,\n\t\t\t\"custom-title-list\", \"custom-title-list-description\",\n\t\t\t\"asset-publisher-custom-title-list.vm\", serviceContext);\n\t}","commit_id":"9370b973b9727a2c3bd86960339c4c2652e53b5c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deleteMappedFolder(\n\t\t\torg.apache.chemistry.opencmis.client.api.Folder cmisFolder)\n\t\tthrows SystemException {\n\n\t\tif (PropsValues.DL_REPOSITORY_CMIS_DELETE_DEPTH == DELETE_NONE) {\n\t\t\treturn;\n\t\t}\n\n\t\tIterator<CmisObject> children = cmisFolder.getChildren().iterator();\n\n\t\twhile (children.hasNext()) {\n\t\t\tCmisObject child = children.next();\n\n\t\t\tif (child instanceof Document) {\n\t\t\t\tDocument document = (Document)child;\n\n\t\t\t\tdeleteMappedFileEntry(document);\n\t\t\t}\n\t\t\telse if (child instanceof\n\t\t\t\t\t\torg.apache.chemistry.opencmis.client.api.Folder) {\n\n\t\t\t\torg.apache.chemistry.opencmis.client.api.Folder subFolder =\n\t\t\t\t\t(org.apache.chemistry.opencmis.client.api.Folder)child;\n\n\t\t\t\ttry {\n\t\t\t\t\tRepositoryEntryUtil.removeByR_M(\n\t\t\t\t\t\tgetRepositoryId(), child.getId());\n\n\t\t\t\t\tif (PropsValues.DL_REPOSITORY_CMIS_DELETE_DEPTH ==\n\t\t\t\t\t\t\tDELETE_DEEP) {\n\n\t\t\t\t\t\tdeleteMappedFolder(subFolder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchRepositoryEntryException nsree) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":67683,"modified_method":"protected void deleteMappedFolder(\n\t\t\torg.apache.chemistry.opencmis.client.api.Folder cmisFolder)\n\t\tthrows SystemException {\n\n\t\tif (PropsValues.DL_REPOSITORY_CMIS_DELETE_DEPTH == _DELETE_NONE) {\n\t\t\treturn;\n\t\t}\n\n\t\tItemIterable<CmisObject> cmisObjects = cmisFolder.getChildren();\n\n\t\tIterator<CmisObject> itr = cmisObjects.iterator();\n\n\t\twhile (itr.hasNext()) {\n\t\t\tCmisObject cmisObject = itr.next();\n\n\t\t\tif (cmisObject instanceof Document) {\n\t\t\t\tDocument document = (Document)cmisObject;\n\n\t\t\t\tdeleteMappedFileEntry(document);\n\t\t\t}\n\t\t\telse if (cmisObject instanceof\n\t\t\t\t\t\torg.apache.chemistry.opencmis.client.api.Folder) {\n\n\t\t\t\torg.apache.chemistry.opencmis.client.api.Folder cmisSubfolder =\n\t\t\t\t\t(org.apache.chemistry.opencmis.client.api.Folder)cmisObject;\n\n\t\t\t\ttry {\n\t\t\t\t\tRepositoryEntryUtil.removeByR_M(\n\t\t\t\t\t\tgetRepositoryId(), cmisObject.getId());\n\n\t\t\t\t\tif (PropsValues.DL_REPOSITORY_CMIS_DELETE_DEPTH ==\n\t\t\t\t\t\t\t_DELETE_DEEP) {\n\n\t\t\t\t\t\tdeleteMappedFolder(cmisSubfolder);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (NoSuchRepositoryEntryException nsree) {\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"b6fb36b2daee6eb020ef7fbcc95dac185a59c85e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void deleteMappedFileEntry(Document document)\n\t\tthrows SystemException {\n\n\t\tif (PropsValues.DL_REPOSITORY_CMIS_DELETE_DEPTH == DELETE_NONE) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<Document> versions = document.getAllVersions();\n\n\t\tfor (Document version : versions) {\n\t\t\ttry {\n\t\t\t\tRepositoryEntryUtil.removeByR_M(\n\t\t\t\t\tgetRepositoryId(), version.getId());\n\t\t\t}\n\t\t\tcatch (NoSuchRepositoryEntryException nsree) {\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tRepositoryEntryUtil.removeByR_M(\n\t\t\t\tgetRepositoryId(), document.getId());\n\t\t}\n\t\tcatch (NoSuchRepositoryEntryException nsree) {\n\t\t}\n\t}","id":67684,"modified_method":"protected void deleteMappedFileEntry(Document document)\n\t\tthrows SystemException {\n\n\t\tif (PropsValues.DL_REPOSITORY_CMIS_DELETE_DEPTH == _DELETE_NONE) {\n\t\t\treturn;\n\t\t}\n\n\t\tList<Document> documentVersions = document.getAllVersions();\n\n\t\tfor (Document version : documentVersions) {\n\t\t\ttry {\n\t\t\t\tRepositoryEntryUtil.removeByR_M(\n\t\t\t\t\tgetRepositoryId(), version.getId());\n\t\t\t}\n\t\t\tcatch (NoSuchRepositoryEntryException nsree) {\n\t\t\t}\n\t\t}\n\n\t\ttry {\n\t\t\tRepositoryEntryUtil.removeByR_M(\n\t\t\t\tgetRepositoryId(), document.getId());\n\t\t}\n\t\tcatch (NoSuchRepositoryEntryException nsree) {\n\t\t}\n\t}","commit_id":"b6fb36b2daee6eb020ef7fbcc95dac185a59c85e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public Session getSession() throws PortalException, RepositoryException {\n\t\tSession session = getCachedSession();\n\n\t\tif (session != null) {\n\t\t\treturn session;\n\t\t}\n\n\t\tString password = PrincipalThreadLocal.getPassword();\n\t\tString login = getLogin();\n\n\t\tMap<String, String> parameters = new HashMap<String, String>();\n\n\t\tparameters.put(SessionParameter.USER, login);\n\t\tparameters.put(SessionParameter.PASSWORD, password);\n\t\tparameters.put(SessionParameter.LOCALE_ISO3166_COUNTRY,\n\t\t\tLocaleUtil.getDefault().getCountry());\n\t\tparameters.put(SessionParameter.LOCALE_ISO639_LANGUAGE,\n\t\t\tLocaleUtil.getDefault().getLanguage());\n\n\t\tUnicodeProperties typeSettingsProperties = getTypeSettingsProperties();\n\n\t\tif (isAtomPub()) {\n\t\t\tparameters.put(\n\t\t\t\tSessionParameter.BINDING_TYPE, BindingType.ATOMPUB.value());\n\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.ATOMPUB_URL,\n\t\t\t\tCMISAtomPubRepository.ATOMPUB_URL);\n\t\t}\n\t\telse {\n\t\t\tparameters.put(\n\t\t\t\tSessionParameter.BINDING_TYPE, BindingType.WEBSERVICES.value());\n\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_ACL_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_ACL_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_DISCOVERY_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_DISCOVERY_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_MULTIFILING_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_MULTIFILING_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_NAVIGATION_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_NAVIGATION_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_OBJECT_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_OBJECT_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_POLICY_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_POLICY_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_RELATIONSHIP_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_RELATIONSHIP_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_REPOSITORY_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_REPOSITORY_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_VERSIONING_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_VERSIONING_SERVICE);\n\t\t}\n\n\t\tcheckRepository(parameters, typeSettingsProperties);\n\n\t\tsession = _sessionFactory.createSession(parameters);\n\n\t\tsession.setDefaultContext(getOperationContext());\n\n\t\tsetCachedSession(session);\n\n\t\treturn session;\n\t}","id":67685,"modified_method":"public Session getSession() throws PortalException, RepositoryException {\n\t\tSession session = getCachedSession();\n\n\t\tif (session != null) {\n\t\t\treturn session;\n\t\t}\n\n\t\tMap<String, String> parameters = new HashMap<String, String>();\n\n\t\tLocale locale = LocaleUtil.getDefault();\n\n\t\tparameters.put(\n\t\t\tSessionParameter.LOCALE_ISO3166_COUNTRY,\n\t\t\tlocale.getCountry());\n\t\tparameters.put(SessionParameter.LOCALE_ISO639_LANGUAGE,\n\t\t\tlocale.getLanguage());\n\n\t\tString password = PrincipalThreadLocal.getPassword();\n\n\t\tparameters.put(SessionParameter.PASSWORD, password);\n\n\t\tString login = getLogin();\n\n\t\tparameters.put(SessionParameter.USER, login);\n\n\t\tUnicodeProperties typeSettingsProperties = getTypeSettingsProperties();\n\n\t\tif (isAtomPub()) {\n\t\t\tparameters.put(\n\t\t\t\tSessionParameter.BINDING_TYPE, BindingType.ATOMPUB.value());\n\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.ATOMPUB_URL,\n\t\t\t\tCMISAtomPubRepository.ATOMPUB_URL);\n\t\t}\n\t\telse {\n\t\t\tparameters.put(\n\t\t\t\tSessionParameter.BINDING_TYPE, BindingType.WEBSERVICES.value());\n\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_ACL_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_ACL_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_DISCOVERY_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_DISCOVERY_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_MULTIFILING_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_MULTIFILING_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_NAVIGATION_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_NAVIGATION_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_OBJECT_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_OBJECT_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_POLICY_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_POLICY_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_RELATIONSHIP_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_RELATIONSHIP_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_REPOSITORY_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_REPOSITORY_SERVICE);\n\t\t\tputParameter(\n\t\t\t\tparameters, SessionParameter.WEBSERVICES_VERSIONING_SERVICE,\n\t\t\t\tCMISWebServicesRepository.WEBSERVICES_VERSIONING_SERVICE);\n\t\t}\n\n\t\tcheckRepository(parameters, typeSettingsProperties);\n\n\t\tsession = _sessionFactory.createSession(parameters);\n\n\t\tsession.setDefaultContext(getOperationContext());\n\n\t\tsetCachedSession(session);\n\n\t\treturn session;\n\t}","commit_id":"b6fb36b2daee6eb020ef7fbcc95dac185a59c85e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public List<Long> getSubfolderIds(long folderId, boolean recurse)\n\t\tthrows SystemException {\n\n\t\ttry {\n\t\t\tList<Long> subfolderIds = new ArrayList<Long>();\n\n\t\t\tList<Folder> subFolders = getFolders(\n\t\t\t\tfolderId, QueryUtil.ALL_POS, QueryUtil.ALL_POS, null);\n\n\t\t\tgetSubfolderIds(subfolderIds, subFolders, recurse);\n\n\t\t\treturn subfolderIds;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RepositoryException(e);\n\t\t}\n\t}","id":67686,"modified_method":"public List<Long> getSubfolderIds(long folderId, boolean recurse)\n\t\tthrows SystemException {\n\n\t\ttry {\n\t\t\tList<Long> subfolderIds = new ArrayList<Long>();\n\n\t\t\tList<Folder> subfolders = getFolders(\n\t\t\t\tfolderId, QueryUtil.ALL_POS, QueryUtil.ALL_POS, null);\n\n\t\t\tgetSubfolderIds(subfolderIds, subfolders, recurse);\n\n\t\t\treturn subfolderIds;\n\t\t}\n\t\tcatch (SystemException se) {\n\t\t\tthrow se;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RepositoryException(e);\n\t\t}\n\t}","commit_id":"b6fb36b2daee6eb020ef7fbcc95dac185a59c85e","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addWebContentPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"layout-prototype-web-content-title\",\n\t\t\t\"layout-prototype-web-content-description\", \"2_columns_ii\",\n\t\t\tlayoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString portletId = DefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, AssetPublisherPortletKeys.ASSET_PUBLISHER, \"column-2\");\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tlayout.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\tLayoutTypePortletConstants.DEFAULT_ASSET_PUBLISHER_PORTLET_ID,\n\t\t\tportletId);\n\n\t\t_layoutLocalService.updateLayout(\n\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), layout.getLayoutId(),\n\t\t\tlayout.getTypeSettings());\n\t}","id":67687,"modified_method":"protected void addWebContentPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = AddLayoutPrototypeAction.class;\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"layout-prototype-web-content-title\",\n\t\t\t\"layout-prototype-web-content-description\", \"2_columns_ii\",\n\t\t\tlayoutPrototypes, clazz.getClassLoader());\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString portletId = DefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, AssetPublisherPortletKeys.ASSET_PUBLISHER, \"column-2\");\n\n\t\tUnicodeProperties typeSettingsProperties =\n\t\t\tlayout.getTypeSettingsProperties();\n\n\t\ttypeSettingsProperties.setProperty(\n\t\t\tLayoutTypePortletConstants.DEFAULT_ASSET_PUBLISHER_PORTLET_ID,\n\t\t\tportletId);\n\n\t\t_layoutLocalService.updateLayout(\n\t\t\tlayout.getGroupId(), layout.isPrivateLayout(), layout.getLayoutId(),\n\t\t\tlayout.getTypeSettings());\n\t}","commit_id":"adc389d043b283d55395523775ccecea3c307d25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addBlogPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tResourceBundle resourceBundle = ResourceBundle.getBundle(\n\t\t\t\"content.Language\", LocaleUtil.getDefault());\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId,\n\t\t\tLanguageUtil.get(resourceBundle, \"layout-prototype-blog-title\"),\n\t\t\tLanguageUtil.get(\n\t\t\t\tresourceBundle, \"layout-prototype-blog-description\"),\n\t\t\t\"2_columns_iii\", layoutPrototypes);\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, BlogsPortletKeys.BLOGS, \"column-1\");\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, AssetTagsNavigationPortletKeys.ASSET_TAGS_CLOUD,\n\t\t\t\"column-2\");\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, RecentBloggersPortletKeys.RECENT_BLOGGERS, \"column-2\");\n\t}","id":67688,"modified_method":"protected void addBlogPage(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = AddLayoutPrototypeAction.class;\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayoutPrototype(\n\t\t\tcompanyId, defaultUserId, \"layout-prototype-blog-title\",\n\t\t\t\"layout-prototype-blog-description\", \"2_columns_iii\",\n\t\t\tlayoutPrototypes, clazz.getClassLoader());\n\n\t\tif (layout == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, BlogsPortletKeys.BLOGS, \"column-1\");\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, AssetTagsNavigationPortletKeys.ASSET_TAGS_CLOUD,\n\t\t\t\"column-2\");\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, RecentBloggersPortletKeys.RECENT_BLOGGERS, \"column-2\");\n\t}","commit_id":"adc389d043b283d55395523775ccecea3c307d25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addPrivateSite(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutSetPrototype> layoutSetPrototypes)\n\t\tthrows Exception {\n\n\t\tResourceBundle resourceBundle = ResourceBundle.getBundle(\n\t\t\t\"content.Language\", LocaleUtil.getDefault());\n\n\t\tLayoutSet layoutSet =\n\t\t\tDefaultLayoutSetPrototypesUtil.addLayoutSetPrototype(\n\t\t\t\tcompanyId, defaultUserId,\n\t\t\t\tLanguageUtil.get(\n\t\t\t\t\tresourceBundle, \"layout-set-prototype-intranet-site-title\"),\n\t\t\t\tLanguageUtil.get(\n\t\t\t\t\tresourceBundle,\n\t\t\t\t\t\"layout-set-prototype-intranet-site-description\"),\n\t\t\t\tlayoutSetPrototypes);\n\n\t\tif (layoutSet == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Home layout\n\n\t\tDefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"home\", \"/home\", \"2_columns_i\");\n\n\t\t// Documents layout\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"documents-and-media\", \"/documents\", \"1_column\");\n\n\t\tString portletId = DefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, DLPortletKeys.DOCUMENT_LIBRARY, \"column-1\");\n\n\t\tMap<String, String> preferences = new HashMap<>();\n\n\t\tpreferences.put(\"portletSetupShowBorders\", Boolean.FALSE.toString());\n\n\t\tDefaultLayoutPrototypesUtil.updatePortletSetup(\n\t\t\tlayout, portletId, preferences);\n\t}","id":67689,"modified_method":"protected void addPrivateSite(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutSetPrototype> layoutSetPrototypes)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = AddLayoutSetPrototypeAction.class;\n\n\t\tLayoutSet layoutSet =\n\t\t\tDefaultLayoutSetPrototypesUtil.addLayoutSetPrototype(\n\t\t\t\tcompanyId, defaultUserId,\n\t\t\t\t\"layout-set-prototype-intranet-site-title\",\n\t\t\t\t\"layout-set-prototype-intranet-site-description\",\n\t\t\t\tlayoutSetPrototypes, clazz.getClassLoader());\n\n\t\tif (layoutSet == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Home layout\n\n\t\tDefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"home\", \"/home\", \"2_columns_i\");\n\n\t\t// Documents layout\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"documents-and-media\", \"/documents\", \"1_column\");\n\n\t\tString portletId = DefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, DLPortletKeys.DOCUMENT_LIBRARY, \"column-1\");\n\n\t\tMap<String, String> preferences = new HashMap<>();\n\n\t\tpreferences.put(\"portletSetupShowBorders\", Boolean.FALSE.toString());\n\n\t\tDefaultLayoutPrototypesUtil.updatePortletSetup(\n\t\t\tlayout, portletId, preferences);\n\t}","commit_id":"adc389d043b283d55395523775ccecea3c307d25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void addPublicSite(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutSetPrototype> layoutSetPrototypes)\n\t\tthrows Exception {\n\n\t\tResourceBundle resourceBundle = ResourceBundle.getBundle(\n\t\t\t\"content.Language\", LocaleUtil.getDefault());\n\n\t\tLayoutSet layoutSet =\n\t\t\tDefaultLayoutSetPrototypesUtil.addLayoutSetPrototype(\n\t\t\t\tcompanyId, defaultUserId,\n\t\t\t\tLanguageUtil.get(\n\t\t\t\t\tresourceBundle,\n\t\t\t\t\t\"layout-set-prototype-community-site-title\"),\n\t\t\t\tLanguageUtil.get(\n\t\t\t\t\tresourceBundle,\n\t\t\t\t\t\"layout-set-prototype-community-site-description\"),\n\t\t\t\tlayoutSetPrototypes);\n\n\t\tif (layoutSet == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Home layout\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"home\", \"/home\", \"2_columns_iii\");\n\t\tString portletId = PortletProviderUtil.getPortletId(\n\t\t\tMBMessage.class.getName(), PortletProvider.Action.EDIT);\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(layout, portletId, \"column-1\");\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, SocialUserStatisticsPortletKeys.SOCIAL_USER_STATISTICS,\n\t\t\t\"column-2\");\n\n\t\t// Wiki layout\n\n\t\tDefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"wiki\", \"/wiki\", \"2_columns_iii\");\n\t}","id":67690,"modified_method":"protected void addPublicSite(\n\t\t\tlong companyId, long defaultUserId,\n\t\t\tList<LayoutSetPrototype> layoutSetPrototypes)\n\t\tthrows Exception {\n\n\t\tClass<?> clazz = AddLayoutSetPrototypeAction.class;\n\n\t\tLayoutSet layoutSet =\n\t\t\tDefaultLayoutSetPrototypesUtil.addLayoutSetPrototype(\n\t\t\t\tcompanyId, defaultUserId,\n\t\t\t\t\"layout-set-prototype-community-site-title\",\n\t\t\t\t\"layout-set-prototype-community-site-description\",\n\t\t\t\tlayoutSetPrototypes, clazz.getClassLoader());\n\n\t\tif (layoutSet == null) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Home layout\n\n\t\tLayout layout = DefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"home\", \"/home\", \"2_columns_iii\");\n\t\tString portletId = PortletProviderUtil.getPortletId(\n\t\t\tMBMessage.class.getName(), PortletProvider.Action.EDIT);\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(layout, portletId, \"column-1\");\n\n\t\tDefaultLayoutPrototypesUtil.addPortletId(\n\t\t\tlayout, SocialUserStatisticsPortletKeys.SOCIAL_USER_STATISTICS,\n\t\t\t\"column-2\");\n\n\t\t// Wiki layout\n\n\t\tDefaultLayoutPrototypesUtil.addLayout(\n\t\t\tlayoutSet, \"wiki\", \"/wiki\", \"2_columns_iii\");\n\t}","commit_id":"adc389d043b283d55395523775ccecea3c307d25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static Layout addLayoutPrototype(\n\t\t\tlong companyId, long defaultUserId, String nameKey,\n\t\t\tString descriptionKey, String layouteTemplateId,\n\t\t\tList<LayoutPrototype> layoutPrototypes)\n\t\tthrows Exception {\n\n\t\tString name = LanguageUtil.get(LocaleUtil.getDefault(), nameKey);\n\t\tString description = LanguageUtil.get(\n\t\t\tLocaleUtil.getDefault(), descriptionKey);\n\n\t\tfor (LayoutPrototype layoutPrototype : layoutPrototypes) {\n\t\t\tString curName = layoutPrototype.getName(LocaleUtil.getDefault());\n\t\t\tString curDescription = layoutPrototype.getDescription(\n\t\t\t\tLocaleUtil.getDefault());\n\n\t\t\tif (name.equals(curName) && description.equals(curDescription)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tMap<Locale, String> nameMap = new HashMap<>();\n\t\tMap<Locale, String> descriptionMap = new HashMap<>();\n\n\t\tfor (Locale locale : LanguageUtil.getAvailableLocales()) {\n\t\t\tnameMap.put(locale, LanguageUtil.get(locale, nameKey));\n\t\t\tdescriptionMap.put(\n\t\t\t\tlocale, LanguageUtil.get(locale, descriptionKey));\n\t\t}\n\n\t\tLayoutPrototype layoutPrototype =\n\t\t\tLayoutPrototypeLocalServiceUtil.addLayoutPrototype(\n\t\t\t\tdefaultUserId, companyId, nameMap, descriptionMap, true,\n\t\t\t\tnew ServiceContext());\n\n\t\tLayout layout = layoutPrototype.getLayout();\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tlayoutTypePortlet.setLayoutTemplateId(0, layouteTemplateId, false);\n\n\t\treturn layout;\n\t}","id":67691,"modified_method":"public static Layout addLayoutPrototype(\n\t\t\tlong companyId, long defaultUserId, String nameKey,\n\t\t\tString descriptionKey, String layouteTemplateId,\n\t\t\tList<LayoutPrototype> layoutPrototypes, ClassLoader classLoader)\n\t\tthrows Exception {\n\n\t\tResourceBundle resourceBundle = ResourceBundle.getBundle(\n\t\t\t\"content.Language\", LocaleUtil.getDefault(), classLoader,\n\t\t\tUTF8Control.INSTANCE);\n\n\t\tString name = LanguageUtil.get(resourceBundle, nameKey);\n\t\tString description = LanguageUtil.get(resourceBundle, descriptionKey);\n\n\t\tfor (LayoutPrototype layoutPrototype : layoutPrototypes) {\n\t\t\tString curName = layoutPrototype.getName(LocaleUtil.getDefault());\n\t\t\tString curDescription = layoutPrototype.getDescription(\n\t\t\t\tLocaleUtil.getDefault());\n\n\t\t\tif (name.equals(curName) && description.equals(curDescription)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tMap<Locale, String> nameMap = new HashMap<>();\n\t\tMap<Locale, String> descriptionMap = new HashMap<>();\n\n\t\tfor (Locale locale : LanguageUtil.getAvailableLocales()) {\n\t\t\tresourceBundle = ResourceBundle.getBundle(\n\t\t\t\t\"content.Language\", locale, classLoader, UTF8Control.INSTANCE);\n\n\t\t\tnameMap.put(locale, LanguageUtil.get(resourceBundle, nameKey));\n\t\t\tdescriptionMap.put(\n\t\t\t\tlocale, LanguageUtil.get(resourceBundle, descriptionKey));\n\t\t}\n\n\t\tLayoutPrototype layoutPrototype =\n\t\t\tLayoutPrototypeLocalServiceUtil.addLayoutPrototype(\n\t\t\t\tdefaultUserId, companyId, nameMap, descriptionMap, true,\n\t\t\t\tnew ServiceContext());\n\n\t\tLayout layout = layoutPrototype.getLayout();\n\n\t\tLayoutTypePortlet layoutTypePortlet =\n\t\t\t(LayoutTypePortlet)layout.getLayoutType();\n\n\t\tlayoutTypePortlet.setLayoutTemplateId(0, layouteTemplateId, false);\n\n\t\treturn layout;\n\t}","commit_id":"adc389d043b283d55395523775ccecea3c307d25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static LayoutSet addLayoutSetPrototype(\n\t\t\tlong companyId, long defaultUserId, String nameKey,\n\t\t\tString descriptionKey, List<LayoutSetPrototype> layoutSetPrototypes)\n\t\tthrows Exception {\n\n\t\tString name = LanguageUtil.get(LocaleUtil.getDefault(), nameKey);\n\t\tString description = LanguageUtil.get(\n\t\t\tLocaleUtil.getDefault(), descriptionKey);\n\n\t\tfor (LayoutSetPrototype layoutSetPrototype : layoutSetPrototypes) {\n\t\t\tString curName = layoutSetPrototype.getName(\n\t\t\t\tLocaleUtil.getDefault());\n\t\t\tString curDescription = layoutSetPrototype.getDescription(\n\t\t\t\tLocaleUtil.getDefault());\n\n\t\t\tif (name.equals(curName) && description.equals(curDescription)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tMap<Locale, String> nameMap = new HashMap<>();\n\t\tMap<Locale, String> descriptionMap = new HashMap<>();\n\n\t\tfor (Locale locale : LanguageUtil.getAvailableLocales()) {\n\t\t\tnameMap.put(locale, LanguageUtil.get(locale, nameKey));\n\t\t\tdescriptionMap.put(\n\t\t\t\tlocale, LanguageUtil.get(locale, descriptionKey));\n\t\t}\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.addLayoutSetPrototype(\n\t\t\t\tdefaultUserId, companyId, nameMap, descriptionMap, true, true,\n\t\t\t\tnew ServiceContext());\n\n\t\tLayoutSet layoutSet = layoutSetPrototype.getLayoutSet();\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tLayoutLocalServiceUtil.deleteLayouts(\n\t\t\tlayoutSet.getGroupId(), layoutSet.isPrivateLayout(),\n\t\t\tserviceContext);\n\n\t\treturn layoutSetPrototype.getLayoutSet();\n\t}","id":67692,"modified_method":"public static LayoutSet addLayoutSetPrototype(\n\t\t\tlong companyId, long defaultUserId, String nameKey,\n\t\t\tString descriptionKey, List<LayoutSetPrototype> layoutSetPrototypes,\n\t\t\tClassLoader classLoader)\n\t\tthrows Exception {\n\n\t\tResourceBundle resourceBundle = ResourceBundle.getBundle(\n\t\t\t\"content.Language\", LocaleUtil.getDefault(), classLoader,\n\t\t\tUTF8Control.INSTANCE);\n\n\t\tString name = LanguageUtil.get(resourceBundle, nameKey);\n\t\tString description = LanguageUtil.get(resourceBundle, descriptionKey);\n\n\t\tfor (LayoutSetPrototype layoutSetPrototype : layoutSetPrototypes) {\n\t\t\tString curName = layoutSetPrototype.getName(\n\t\t\t\tLocaleUtil.getDefault());\n\t\t\tString curDescription = layoutSetPrototype.getDescription(\n\t\t\t\tLocaleUtil.getDefault());\n\n\t\t\tif (name.equals(curName) && description.equals(curDescription)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\n\t\tMap<Locale, String> nameMap = new HashMap<>();\n\t\tMap<Locale, String> descriptionMap = new HashMap<>();\n\n\t\tfor (Locale locale : LanguageUtil.getAvailableLocales()) {\n\t\t\tresourceBundle = ResourceBundle.getBundle(\n\t\t\t\t\"content.Language\", locale, classLoader, UTF8Control.INSTANCE);\n\n\t\t\tnameMap.put(locale, LanguageUtil.get(resourceBundle, nameKey));\n\t\t\tdescriptionMap.put(\n\t\t\t\tlocale, LanguageUtil.get(resourceBundle, descriptionKey));\n\t\t}\n\n\t\tLayoutSetPrototype layoutSetPrototype =\n\t\t\tLayoutSetPrototypeLocalServiceUtil.addLayoutSetPrototype(\n\t\t\t\tdefaultUserId, companyId, nameMap, descriptionMap, true, true,\n\t\t\t\tnew ServiceContext());\n\n\t\tLayoutSet layoutSet = layoutSetPrototype.getLayoutSet();\n\n\t\tServiceContext serviceContext = new ServiceContext();\n\n\t\tLayoutLocalServiceUtil.deleteLayouts(\n\t\t\tlayoutSet.getGroupId(), layoutSet.isPrivateLayout(),\n\t\t\tserviceContext);\n\n\t\treturn layoutSetPrototype.getLayoutSet();\n\t}","commit_id":"adc389d043b283d55395523775ccecea3c307d25","url":"https://github.com/liferay/liferay-portal"},{"original_method":"/**\n     * Replies the a localized name for this primitive given by the value of the tags (in this order)\n     * <ul>\n     *   <li>name:lang_COUNTRY_Variant  of the current locale<\/li>\n     *   <li>name:lang_COUNTRY of the current locale<\/li>\n     *   <li>name:lang of the current locale<\/li>\n     *   <li>name of the current locale<\/li>\n     * <\/ul>\n     *\n     * null, if no such tag exists\n     *\n     * @return the name of this primitive\n     */\n    @Override\n    public String getLocalName() {\n        String key = \"name:\" + Locale.getDefault().toString();\n        if (get(key) != null)\n            return get(key);\n        key = \"name:\" + Locale.getDefault().getLanguage() + \"_\" + Locale.getDefault().getCountry();\n        if (get(key) != null)\n            return get(key);\n        key = \"name:\" + Locale.getDefault().getLanguage();\n        if (get(key) != null)\n            return get(key);\n        return getName();\n    }","id":67693,"modified_method":"/**\n     * Replies the a localized name for this primitive given by the value of the tags (in this order)\n     * <ul>\n     *   <li>name:lang_COUNTRY_Variant  of the current locale<\/li>\n     *   <li>name:lang_COUNTRY of the current locale<\/li>\n     *   <li>name:lang of the current locale<\/li>\n     *   <li>name of the current locale<\/li>\n     * <\/ul>\n     *\n     * null, if no such tag exists\n     *\n     * @return the name of this primitive\n     */\n    @Override\n    public String getLocalName() {\n        final Locale locale = Locale.getDefault();\n        String key = \"name:\" + locale.toString();\n        String val = get(key);\n        if (val != null)\n            return val;\n\n        final String language = locale.getLanguage();\n        key = \"name:\" + language + \"_\" + locale.getCountry();\n        val = get(key);\n        if (val != null)\n            return val;\n\n        key = \"name:\" + language;\n        val = get(key);\n        if (val != null)\n            return val;\n\n        return getName();\n    }","commit_id":"e5b36dd6d1ee00cfc745d0684bee83a30735890a","url":"https://github.com/openstreetmap/josm"},{"original_method":"public boolean check(OsmPrimitive primitive)\n    {\n        if(conditions == null)\n            return true;\n        for(XmlCondition r : conditions)\n        {\n            String k = primitive.get(r.key);\n            String bv = OsmUtils.getNamedOsmBoolean(r.boolValue);\n            if(k == null || (r.value != null && !k.equals(r.value))\n                    || (bv != null && !bv.equals(OsmUtils.getNamedOsmBoolean(k))))\n                return false;\n        }\n        return true;\n    }","id":67694,"modified_method":"public boolean check(OsmPrimitive primitive)\n    {\n        if(conditions == null)\n            return true;\n        for(XmlCondition r : conditions)\n        {\n            String k = primitive.get(r.key);\n\n            if (k == null || (r.value != null && !k.equals(r.value)))\n                return false;\n\n            String bv = OsmUtils.getNamedOsmBoolean(r.boolValue);\n\n            if (bv != null && !bv.equals(OsmUtils.getNamedOsmBoolean(k)))\n                return false;\n        }\n        return true;\n    }","commit_id":"e5b36dd6d1ee00cfc745d0684bee83a30735890a","url":"https://github.com/openstreetmap/josm"},{"original_method":"public String getCode() {\n        if(code == null) {\n            code = \"\";\n            if (conditions != null) {\n                for(XmlCondition r: conditions) {\n                    code += r.toCode();\n                }\n            }\n        }\n        return code;\n    }","id":67695,"modified_method":"public String getCode() {\n        if(code == null) {\n            if (conditions == null || conditions.isEmpty()) {\n                code = \"\";\n            } else {\n                final StringBuilder sb = new StringBuilder();\n                for(XmlCondition r: conditions) {\n                    r.appendCode(sb);\n                }\n                code = sb.toString();\n            }\n        }\n        return code;\n    }","commit_id":"e5b36dd6d1ee00cfc745d0684bee83a30735890a","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Test\n    public void testTransactionBegin_whenBeginThrowsException() throws Exception {\n\n        TransactionImpl transaction;\n        TransactionManagerServiceImpl transactionManagerService = mock(TransactionManagerServiceImpl.class);\n        RuntimeException expectedException = new RuntimeException(\"example exception\");\n        when(transactionManagerService.pickBackupAddresses(anyInt()))\n                .thenThrow(expectedException);\n\n        NodeEngine nodeEngine = mock(NodeEngine.class);\n        when(nodeEngine.getLocalMember()).thenReturn(new MemberImpl());\n        when(nodeEngine.getLogger(TransactionImpl.class)).thenReturn(new DummyLogger());\n\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, TransactionOptions.getDefault(), null);\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n\n        // other independent transaction in same thread\n        // should behave identically\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, TransactionOptions.getDefault(), \"123\");\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n\n    }","id":67696,"modified_method":"@Test\n    public void testTransactionBegin_whenBeginThrowsException() throws Exception {\n\n        TransactionImpl transaction;\n        TransactionManagerServiceImpl transactionManagerService = mock(TransactionManagerServiceImpl.class);\n        RuntimeException expectedException = new RuntimeException(\"example exception\");\n        when(transactionManagerService.pickBackupAddresses(anyInt()))\n                .thenThrow(expectedException);\n\n        NodeEngine nodeEngine = mock(NodeEngine.class);\n        when(nodeEngine.getLocalMember()).thenReturn(new MemberImpl());\n        when(nodeEngine.getLogger(TransactionImpl.class)).thenReturn(new DummyLogger());\n\n        TransactionOptions options = TransactionOptions.getDefault();\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, options, null);\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n\n        // other independent transaction in same thread\n        // should behave identically\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, options, \"123\");\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n    }","commit_id":"103b2212a26fe6d732524b3d868526d09aa30d33","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Override\n    public void commit() throws TransactionException, IllegalStateException {\n        try {\n            if (transactionType.equals(TransactionType.TWO_PHASE) && state != PREPARED) {\n                throw new IllegalStateException(\"Transaction is not prepared\");\n            }\n            if (transactionType.equals(TransactionType.LOCAL) && state != ACTIVE) {\n                throw new IllegalStateException(\"Transaction is not active\");\n            }\n            checkThread();\n            checkTimeout();\n            try {\n                final List<Future> futures = new ArrayList<Future>(txLogs.size());\n                state = COMMITTING;\n                for (TransactionLog txLog : txLogs) {\n                    futures.add(txLog.commit(nodeEngine));\n                }\n                waitWithDeadline(futures, COMMIT_TIMEOUT_MINUTES, TimeUnit.MINUTES, commitExceptionHandler);\n\n                state = COMMITTED;\n\n                // purge tx backup\n                purgeTxBackups();\n            } catch (Throwable e) {\n                state = COMMIT_FAILED;\n                throw ExceptionUtil.rethrow(e, TransactionException.class);\n            }\n        } finally {\n            setThreadFlag(null);\n        }\n    }","id":67697,"modified_method":"@Override\n    public void commit() throws TransactionException, IllegalStateException {\n        try {\n            if (transactionType.equals(TransactionType.TWO_PHASE) && state != PREPARED) {\n                throw new IllegalStateException(\"Transaction is not prepared\");\n            }\n            if (transactionType.equals(TransactionType.LOCAL) && state != ACTIVE) {\n                throw new IllegalStateException(\"Transaction is not active\");\n            }\n            checkThread();\n            checkTimeout();\n            try {\n                final List<Future> futures = new ArrayList<Future>(txLogs.size());\n                state = COMMITTING;\n                for (TransactionLog txLog : txLogs) {\n                    futures.add(txLog.commit(nodeEngine));\n                }\n                // We should rethrow exception if transaction is not TWO_PHASE\n                ExceptionHandler exceptionHandler = transactionType.equals(TransactionType.TWO_PHASE)\n                        ? commitExceptionHandler : FutureUtil.RETHROW_TRANSACTION_EXCEPTION;\n                waitWithDeadline(futures, COMMIT_TIMEOUT_MINUTES, TimeUnit.MINUTES, exceptionHandler);\n\n                state = COMMITTED;\n\n                // purge tx backup\n                purgeTxBackups();\n            } catch (Throwable e) {\n                state = COMMIT_FAILED;\n                throw ExceptionUtil.rethrow(e, TransactionException.class);\n            }\n        } finally {\n            setThreadFlag(null);\n        }\n    }","commit_id":"5b88893b0d8c6e52194f1b00dbcbd412fe20ab37","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"@Test\n    public void testTransactionBegin_whenBeginThrowsException() throws Exception {\n\n        TransactionImpl transaction;\n        TransactionManagerServiceImpl transactionManagerService = mock(TransactionManagerServiceImpl.class);\n        RuntimeException expectedException = new RuntimeException(\"example exception\");\n        when(transactionManagerService.pickBackupAddresses(anyInt()))\n                .thenThrow(expectedException);\n\n        NodeEngine nodeEngine = mock(NodeEngine.class);\n        when(nodeEngine.getLocalMember()).thenReturn(new MemberImpl());\n        when(nodeEngine.getLogger(TransactionImpl.class)).thenReturn(new DummyLogger());\n\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, TransactionOptions.getDefault(), null);\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n\n        // other independent transaction in same thread\n        // should behave identically\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, TransactionOptions.getDefault(), \"123\");\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n\n    }","id":67698,"modified_method":"@Test\n    public void testTransactionBegin_whenBeginThrowsException() throws Exception {\n        TransactionImpl transaction;\n        TransactionManagerServiceImpl transactionManagerService = mock(TransactionManagerServiceImpl.class);\n        RuntimeException expectedException = new RuntimeException(\"example exception\");\n        when(transactionManagerService.pickBackupAddresses(anyInt()))\n                .thenThrow(expectedException);\n        NodeEngine nodeEngine = mock(NodeEngine.class);\n        when(nodeEngine.getLocalMember()).thenReturn(new MemberImpl());\n        when(nodeEngine.getLogger(TransactionImpl.class)).thenReturn(new DummyLogger());\n        TransactionOptions options = TransactionOptions.getDefault();\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, options, null);\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n// other independent transaction in same thread\n// should behave identically\n        transaction = new TransactionImpl(transactionManagerService, nodeEngine, options, \"123\");\n        try {\n            transaction.begin();\n            fail(\"Transaction expected to fail\");\n        } catch (Exception e) {\n            assertEquals(expectedException, e);\n        }\n    }","commit_id":"5b88893b0d8c6e52194f1b00dbcbd412fe20ab37","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"/**\n     * Finds all plugin color resources, matching the \"images-*.properties\"\n     * pattern and adds them to this resource pack.\n     */\n    private void initPluginResources(Map<String, String> resources,\n                                    Locale locale)\n    {\n        Iterator<String> pluginProperties = DefaultResourcePackActivator\n            .findResourcePaths(   \"resources/languages\",\n                                    \"strings-*.properties\");\n\n        while (pluginProperties.hasNext())\n        {\n            String resourceBundleName = pluginProperties.next();\n\n            if (resourceBundleName.indexOf(\"_\") == -1)\n            {\n                ResourceBundle resourceBundle\n                    = ResourceBundle.getBundle(\n                        resourceBundleName.substring(\n                            0, resourceBundleName.indexOf(\".properties\")),\n                            locale);\n\n                initResources(resourceBundle, resources);\n            }\n        }\n    }","id":67699,"modified_method":"/**\n     * Finds all plugin color resources, matching the \"images-*.properties\"\n     * pattern and adds them to this resource pack.\n     */\n    private void initPluginResources(Map<String, String> resources,\n                                    Locale locale)\n    {\n        Iterator<String> pluginProperties = DefaultResourcePackActivator\n            .findResourcePaths(   \"resources/languages\",\n                                    \"strings-*.properties\");\n\n        while (pluginProperties.hasNext())\n        {\n            String resourceBundleName = pluginProperties.next();\n\n            if (resourceBundleName.indexOf('_') == -1)\n            {\n                ResourceBundle resourceBundle\n                    = ResourceBundle.getBundle(\n                        resourceBundleName.substring(\n                            0, resourceBundleName.indexOf(\".properties\")),\n                            locale);\n\n                initResources(resourceBundle, resources);\n            }\n        }\n    }","commit_id":"21b0d9fb0912a8737a8a8236c8cd66abef736535","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Fills the given resource map with all (key,value) pairs obtained from the\n     * given <tt>ResourceBundle<\/tt>. This method will look in the properties\n     * files for references to other properties files and will include in the\n     * final map data from all referenced files.\n     * \n     * @param resourceBundle The initial <tt>ResourceBundle<\/tt>, corresponding\n     * to the \"main\" properties file.\n     * @param locale The locale we're looking for.\n     * @param resources A <tt>Map<\/tt> that would store the data.\n     */\n    private void initResources( ResourceBundle resourceBundle,\n                                Map<String, String> resources)\n    {\n        Enumeration colorKeys = resourceBundle.getKeys();\n\n        while (colorKeys.hasMoreElements())\n        {\n            String key = (String) colorKeys.nextElement();\n            String value = resourceBundle.getString(key);\n\n            resources.put(key, value);\n        }\n    }","id":67700,"modified_method":"/**\n     * Fills the given resource map with all (key,value) pairs obtained from the\n     * given <tt>ResourceBundle<\/tt>. This method will look in the properties\n     * files for references to other properties files and will include in the\n     * final map data from all referenced files.\n     * \n     * @param resourceBundle The initial <tt>ResourceBundle<\/tt>, corresponding\n     * to the \"main\" properties file.\n     * @param resources A <tt>Map<\/tt> that would store the data.\n     */\n    private void initResources( ResourceBundle resourceBundle,\n                                Map<String, String> resources)\n    {\n        Enumeration<String> colorKeys = resourceBundle.getKeys();\n\n        while (colorKeys.hasMoreElements())\n        {\n            String key = colorKeys.nextElement();\n            String value = resourceBundle.getString(key);\n\n            resources.put(key, value);\n        }\n    }","commit_id":"21b0d9fb0912a8737a8a8236c8cd66abef736535","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns a <tt>Map<\/tt>, containing all [key, value] pairs for this\n     * resource pack.\n     * \n     * @return a <tt>Map<\/tt>, containing all [key, value] pairs for this\n     * resource pack.\n     */\n    public Map<String, String> getResources()\n    {\n        ResourceBundle resourceBundle\n            = ResourceBundle.getBundle( DEFAULT_RESOURCE_PATH,\n                                        Locale.getDefault());\n\n        Map<String, String> resources = new TreeMap<String, String>();\n\n        this.initResources(resourceBundle, resources);\n\n        this.initPluginResources(resources, Locale.getDefault());\n\n        return resources;\n    }","id":67701,"modified_method":"/**\n     * Returns a <tt>Map<\/tt>, containing all [key, value] pairs for this\n     * resource pack.\n     * \n     * @return a <tt>Map<\/tt>, containing all [key, value] pairs for this\n     * resource pack.\n     */\n    public Map<String, String> getResources()\n    {\n        return getResources(Locale.getDefault());\n    }","commit_id":"21b0d9fb0912a8737a8a8236c8cd66abef736535","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Initializes already registered default resource packs.\n     */\n    ResourceManagementServiceImpl()\n    {\n        ResourceManagementActivator.bundleContext.addServiceListener(this);\n\n        colorPack = \n            getDefaultResourcePack(ColorPack.class.getName(),\n                ColorPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (colorPack != null)\n            colorResources = getResources(colorPack);\n\n        imagePack = \n            getDefaultResourcePack(ImagePack.class.getName(),\n                ImagePack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (imagePack != null)\n            imageResources = getResources(imagePack);\n\n        languagePack = \n            (LanguagePack) getDefaultResourcePack(LanguagePack.class.getName(),\n                LanguagePack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        settingsPack = \n            getDefaultResourcePack(SettingsPack.class.getName(),\n                SettingsPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (settingsPack != null)\n            settingsResources = getResources(settingsPack);\n\n        soundPack = \n            getDefaultResourcePack(SoundPack.class.getName(),\n                SoundPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (soundPack != null)\n            soundResources = getResources(soundPack);\n    }","id":67702,"modified_method":"/**\n     * Initializes already registered default resource packs.\n     */\n    ResourceManagementServiceImpl()\n    {\n        ResourceManagementActivator.bundleContext.addServiceListener(this);\n\n        colorPack = \n            getDefaultResourcePack(ColorPack.class.getName(),\n                ColorPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (colorPack != null)\n            colorResources = getResources(colorPack);\n\n        imagePack = \n            getDefaultResourcePack(ImagePack.class.getName(),\n                ImagePack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (imagePack != null)\n            imageResources = getResources(imagePack);\n\n        languagePack = \n            (LanguagePack) getDefaultResourcePack(LanguagePack.class.getName(),\n                LanguagePack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (languagePack != null)\n        {\n            languageLocale = Locale.getDefault();\n            languageResources = languagePack.getResources(languageLocale);\n        }\n\n        settingsPack = \n            getDefaultResourcePack(SettingsPack.class.getName(),\n                SettingsPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (settingsPack != null)\n            settingsResources = getResources(settingsPack);\n\n        soundPack = \n            getDefaultResourcePack(SoundPack.class.getName(),\n                SoundPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n        if (soundPack != null)\n            soundResources = getResources(soundPack);\n    }","commit_id":"21b0d9fb0912a8737a8a8236c8cd66abef736535","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Handles all <tt>ServiceEvent<\/tt>s corresponding to <tt>ResourcePack<\/tt>\n     * being registered or unregistered.\n     */\n    public void serviceChanged(ServiceEvent event)\n    {\n        Object sService = ResourceManagementActivator.bundleContext.getService(\n            event.getServiceReference());\n\n        if (!(sService instanceof ResourcePack))\n        {\n            return;\n        }\n\n        ResourcePack resourcePack = (ResourcePack) sService;\n\n        if (event.getType() == ServiceEvent.REGISTERED)\n        {\n            logger.info(\"Resource registered \" + resourcePack);\n\n            Map<String, String> resources = getResources(resourcePack);\n\n            if(resourcePack instanceof ColorPack && colorPack == null)\n            {\n                colorPack = resourcePack;\n                colorResources = resources;\n            }\n            else if(resourcePack instanceof ImagePack && imagePack == null)\n            {\n                imagePack = resourcePack;\n                imageResources = resources;\n            }\n            else if(resourcePack instanceof LanguagePack && languagePack == null)\n            {\n                languagePack = (LanguagePack) resourcePack;\n            }\n            else if(resourcePack instanceof SettingsPack && settingsPack == null)\n            {\n                settingsPack = resourcePack;\n                settingsResources = resources;\n            }\n            else if(resourcePack instanceof SoundPack && soundPack == null)\n            {\n                soundPack = resourcePack;\n                soundResources = resources;\n            }\n        }\n        else if (event.getType() == ServiceEvent.UNREGISTERING)\n        {\n            if(resourcePack instanceof ColorPack\n                    && colorPack.equals(resourcePack))\n            {\n                colorPack = \n                    getDefaultResourcePack(ColorPack.class.getName(),\n                        ColorPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (colorPack != null)\n                    colorResources = getResources(colorPack);\n            }\n            else if(resourcePack instanceof ImagePack\n                    && imagePack.equals(resourcePack))\n            {\n                imagePack = \n                    getDefaultResourcePack(ImagePack.class.getName(),\n                        ImagePack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (imagePack != null)\n                    imageResources = getResources(imagePack);\n            }\n            else if(resourcePack instanceof LanguagePack\n                    && languagePack.equals(resourcePack))\n            {\n                languagePack = \n                    (LanguagePack) getDefaultResourcePack(\n                        LanguagePack.class.getName(),\n                        LanguagePack.RESOURCE_NAME_DEFAULT_VALUE);\n            }\n            else if(resourcePack instanceof SettingsPack\n                    && settingsPack.equals(resourcePack))\n            {\n                settingsPack = \n                    getDefaultResourcePack(SettingsPack.class.getName(),\n                        SettingsPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (settingsPack != null)\n                    settingsResources = getResources(settingsPack);\n            }\n            else if(resourcePack instanceof SoundPack\n                    && soundPack.equals(resourcePack))\n            {\n                soundPack = \n                    getDefaultResourcePack(SoundPack.class.getName(),\n                        SoundPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (soundPack != null)\n                    soundResources = getResources(soundPack);\n            }\n        }\n    }","id":67703,"modified_method":"/**\n     * Handles all <tt>ServiceEvent<\/tt>s corresponding to <tt>ResourcePack<\/tt>\n     * being registered or unregistered.\n     */\n    public void serviceChanged(ServiceEvent event)\n    {\n        Object sService = ResourceManagementActivator.bundleContext.getService(\n            event.getServiceReference());\n\n        if (!(sService instanceof ResourcePack))\n        {\n            return;\n        }\n\n        ResourcePack resourcePack = (ResourcePack) sService;\n\n        if (event.getType() == ServiceEvent.REGISTERED)\n        {\n            logger.info(\"Resource registered \" + resourcePack);\n\n            Map<String, String> resources = getResources(resourcePack);\n\n            if(resourcePack instanceof ColorPack && colorPack == null)\n            {\n                colorPack = resourcePack;\n                colorResources = resources;\n            }\n            else if(resourcePack instanceof ImagePack && imagePack == null)\n            {\n                imagePack = resourcePack;\n                imageResources = resources;\n            }\n            else if(resourcePack instanceof LanguagePack && languagePack == null)\n            {\n                languagePack = (LanguagePack) resourcePack;\n                languageLocale = Locale.getDefault();\n                languageResources = resources;\n            }\n            else if(resourcePack instanceof SettingsPack && settingsPack == null)\n            {\n                settingsPack = resourcePack;\n                settingsResources = resources;\n            }\n            else if(resourcePack instanceof SoundPack && soundPack == null)\n            {\n                soundPack = resourcePack;\n                soundResources = resources;\n            }\n        }\n        else if (event.getType() == ServiceEvent.UNREGISTERING)\n        {\n            if(resourcePack instanceof ColorPack\n                    && colorPack.equals(resourcePack))\n            {\n                colorPack = \n                    getDefaultResourcePack(ColorPack.class.getName(),\n                        ColorPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (colorPack != null)\n                    colorResources = getResources(colorPack);\n            }\n            else if(resourcePack instanceof ImagePack\n                    && imagePack.equals(resourcePack))\n            {\n                imagePack = \n                    getDefaultResourcePack(ImagePack.class.getName(),\n                        ImagePack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (imagePack != null)\n                    imageResources = getResources(imagePack);\n            }\n            else if(resourcePack instanceof LanguagePack\n                    && languagePack.equals(resourcePack))\n            {\n                languagePack = \n                    (LanguagePack) getDefaultResourcePack(\n                        LanguagePack.class.getName(),\n                        LanguagePack.RESOURCE_NAME_DEFAULT_VALUE);\n            }\n            else if(resourcePack instanceof SettingsPack\n                    && settingsPack.equals(resourcePack))\n            {\n                settingsPack = \n                    getDefaultResourcePack(SettingsPack.class.getName(),\n                        SettingsPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (settingsPack != null)\n                    settingsResources = getResources(settingsPack);\n            }\n            else if(resourcePack instanceof SoundPack\n                    && soundPack.equals(resourcePack))\n            {\n                soundPack = \n                    getDefaultResourcePack(SoundPack.class.getName(),\n                        SoundPack.RESOURCE_NAME_DEFAULT_VALUE);\n\n                if (soundPack != null)\n                    soundResources = getResources(soundPack);\n            }\n        }\n    }","commit_id":"21b0d9fb0912a8737a8a8236c8cd66abef736535","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns an internationalized string corresponding to the given key.\n     * \n     * @param key The identifier of the string in the resources properties\n     * file.\n     * @param locale The locale.\n     * @return An internationalized string corresponding to the given key.\n     */\n    public String getI18NString(String key, String[] params, Locale locale)\n    {\n        Map<String, String> stringResources\n            = languagePack.getResources(locale);\n\n        String resourceString = stringResources.get(key);\n\n        if (resourceString == null)\n        {\n            logger.warn(\"Missing resource for key: \" + key);\n            return '!' + key + '!';\n        }\n\n        int mnemonicIndex = resourceString.indexOf('&');\n\n        if (mnemonicIndex > -1)\n        {\n            String firstPart = resourceString.substring(0, mnemonicIndex);\n            String secondPart = resourceString.substring(mnemonicIndex + 1);\n\n            resourceString = firstPart.concat(secondPart);\n        }\n        \n        if(params != null)\n             resourceString \n                = MessageFormat.format(resourceString, (Object[])params);\n\n        return resourceString;\n    }","id":67704,"modified_method":"/**\n     * Returns an internationalized string corresponding to the given key.\n     * \n     * @param key The identifier of the string in the resources properties\n     * file.\n     * @param locale The locale.\n     * @return An internationalized string corresponding to the given key.\n     */\n    public String getI18NString(String key, String[] params, Locale locale)\n    {\n        Map<String, String> stringResources;\n        if ((locale != null) && locale.equals(languageLocale))\n        {\n            stringResources = languageResources;\n        }\n        else\n        {\n            stringResources = languagePack.getResources(locale);\n        }\n\n        String resourceString = stringResources.get(key);\n\n        if (resourceString == null)\n        {\n            logger.warn(\"Missing resource for key: \" + key);\n            return '!' + key + '!';\n        }\n\n        int mnemonicIndex = resourceString.indexOf('&');\n\n        if (mnemonicIndex > -1)\n        {\n            String firstPart = resourceString.substring(0, mnemonicIndex);\n            String secondPart = resourceString.substring(mnemonicIndex + 1);\n\n            resourceString = firstPart.concat(secondPart);\n        }\n        \n        if(params != null)\n             resourceString \n                = MessageFormat.format(resourceString, (Object[])params);\n\n        return resourceString;\n    }","commit_id":"21b0d9fb0912a8737a8a8236c8cd66abef736535","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Returns an internationalized string corresponding to the given key.\n     * \n     * @param key The identifier of the string in the resources properties file.\n     * @param locale The locale that we'd like to receive the result in.\n     * @return An internationalized string corresponding to the given key.\n     */\n    public char getI18nMnemonic(String key, Locale locale)\n    {\n        Map<String,String> stringResources\n            = languagePack.getResources(locale);\n\n        String resourceString = stringResources.get(key);\n\n        if (resourceString == null)\n        {\n            logger.warn(\"Missing resource for key: \" + key);\n            return 0;\n        }\n\n        int mnemonicIndex = resourceString.indexOf('&');\n\n        if (mnemonicIndex > -1)\n        {\n            return resourceString.charAt(mnemonicIndex + 1);\n        }\n\n        return 0;\n    }","id":67705,"modified_method":"/**\n     * Returns an internationalized string corresponding to the given key.\n     * \n     * @param key The identifier of the string in the resources properties file.\n     * @param locale The locale that we'd like to receive the result in.\n     * @return An internationalized string corresponding to the given key.\n     */\n    public char getI18nMnemonic(String key, Locale locale)\n    {\n        Map<String, String> stringResources;\n        if ((locale != null) && locale.equals(languageLocale))\n        {\n            stringResources = languageResources;\n        }\n        else\n        {\n            stringResources = languagePack.getResources(locale);\n        }\n\n        String resourceString = stringResources.get(key);\n\n        if (resourceString == null)\n        {\n            logger.warn(\"Missing resource for key: \" + key);\n            return 0;\n        }\n\n        int mnemonicIndex = resourceString.indexOf('&');\n\n        if (mnemonicIndex > -1)\n        {\n            return resourceString.charAt(mnemonicIndex + 1);\n        }\n\n        return 0;\n    }","commit_id":"21b0d9fb0912a8737a8a8236c8cd66abef736535","url":"https://github.com/jitsi/jitsi"},{"original_method":"public void generateIndexes(File readFile, IProgress progress, IOsmStorageFilter addFilter, MapZooms mapZooms, MapRenderingTypes renderingTypes) \r\n\tthrows IOException, SAXException,\r\n\t\t\tSQLException {\r\n\t\tif(renderingTypes != null){\r\n\t\t\tthis.renderingTypes = renderingTypes;\r\n\t\t}\r\n\r\n\t\tthis.mapZooms = mapZooms;\r\n\t\tmultiPolygonsWays = new Map[mapZooms.size()];\r\n\t\tfor (int i = 0; i < multiPolygonsWays.length; i++) {\r\n\t\t\tmultiPolygonsWays[i] = new LinkedHashMap<Long, Set<Integer>>();\r\n\t\t}\r\n\t\t\r\n\t\t// clear previous results and setting variables\r\n\t\tif (readFile != null && regionName == null) {\r\n\t\t\tint i = readFile.getName().indexOf('.');\r\n\t\t\tif (i > -1) {\r\n\t\t\t\tregionName = Algoritms.capitalizeFirstLetterAndLowercase(readFile.getName().substring(0, i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcities.clear();\r\n\t\tcityManager.clear();\r\n\t\tlowLevelWays = -1;\r\n\t\tpostalCodeRelations.clear();\r\n\t\tif (normalizeStreets) {\r\n\t\t\tnormalizeDefaultSuffixes = DataExtractionSettings.getSettings().getDefaultSuffixesToNormalizeStreets();\r\n\t\t\tnormalizeSuffixes = DataExtractionSettings.getSettings().getSuffixesToNormalizeStreets();\r\n\t\t}\r\n\r\n\t\t// Main generation method\r\n\t\ttry {\r\n\t\t\t// ////////////////////////////////////////////////////////////////////////\r\n\t\t\t// 1. creating nodes db to fast access for all nodes and simply import all relations, ways, nodes to it\r\n\t\t\tboolean loadFromPath = dbFile == null || !databaseFileExists(dbFile);\r\n\t\t\tif (dbFile == null) {\r\n\t\t\t\tdbFile = new File(workingDir, TEMP_NODES_DB);\r\n\t\t\t\t// to save space\r\n\t\t\t\tif (databaseFileExists(dbFile)) {\r\n\t\t\t\t\tremoveDatabase(dbFile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdbConn = getDatabaseConnection(dbFile.getAbsolutePath());\r\n\r\n\t\t\tint allRelations = 100000;\r\n\t\t\tint allWays = 1000000;\r\n\t\t\tint allNodes = 10000000;\r\n\t\t\tif (loadFromPath) {\r\n\t\t\t\tprogress.setGeneralProgress(\"[35 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.LOADING_FILE\") + readFile.getAbsolutePath(), -1); //$NON-NLS-1$\r\n\r\n\t\t\t\tNewDataExtractionOsmFilter filter = extractOsmToNodesDB(readFile, progress, addFilter);\r\n\t\t\t\tif (filter != null) {\r\n\t\t\t\t\tallNodes = filter.getAllNodes();\r\n\t\t\t\t\tallWays = filter.getAllWays();\r\n\t\t\t\t\tallRelations = filter.getAllRelations();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpselectNode = dbConn.prepareStatement(\"select n.latitude, n.longitude, t.skeys, t.value from node n left join tags t on n.id = t.id and t.type = 0 where n.id = ?\"); //$NON-NLS-1$\r\n\t\t\tpselectWay = dbConn.prepareStatement(\"select w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"where w.id = ? order by w.ord\"); //$NON-NLS-1$\r\n\t\t\tpselectRelation = dbConn.prepareStatement(\"select r.member, r.type, r.role, r.ord, t.skeys, t.value \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"from relations r left join tags t on r.id = t.id and t.type = 2 and r.ord = 0 \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"where r.id = ? order by r.ord\"); //$NON-NLS-1$\r\n\t\t\tpselectTags = dbConn.prepareStatement(\"select skeys, value from tags where id = ? and type = ?\"); //$NON-NLS-1$\r\n\r\n\t\t\t// do not create temp map file and rtree files\r\n\t\t\tif (recreateOnlyBinaryFile) {\r\n\t\t\t\tmapFile = new File(workingDir, getMapFileName());\r\n\t\t\t\tFile tempDBMapFile = new File(workingDir, getTempMapDBFileName());\r\n\t\t\t\tmapConnection = getDatabaseConnection(tempDBMapFile.getAbsolutePath());\r\n\t\t\t\tmapConnection.setAutoCommit(false);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (indexMap) {\r\n\t\t\t\t\t\tmapTree = new RTree[mapZooms.size()];\r\n\t\t\t\t\t\tfor (int i = 0; i < mapZooms.size(); i++) {\r\n\t\t\t\t\t\t\tmapTree[i] = new RTree(getRTreeMapIndexPackFileName() + i);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\t\ttransportStopsTree = new RTree(getRTreeTransportStopsPackFileName());\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (RTreeException e) {\r\n\t\t\t\t\tlog.error(\"Error flushing\", e); //$NON-NLS-1$\r\n\t\t\t\t\tthrow new IOException(e);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// 2. Create index connections and index structure\r\n\t\t\t\tcreateDatabaseIndexesStructure();\r\n\r\n\t\t\t\t// 3. Processing all entries\r\n\t\t\t\t// 3.1 write all cities\r\n\r\n\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.INDEX_CITIES\"), allNodes); //$NON-NLS-1$\r\n\t\t\t\t\tif (!loadFromPath) {\r\n\t\t\t\t\t\tallNodes = iterateOverEntities(progress, EntityType.NODE, allNodes, STEP_CITY_NODES);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (City c : cities.values()) {\r\n\t\t\t\t\t\tDataIndexWriter.writeCity(addressCityStat, pStatements, c, BATCH_SIZE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// commit to put all cities\r\n\t\t\t\t\tif (pStatements.get(addressCityStat) > 0) {\r\n\t\t\t\t\t\taddressCityStat.executeBatch();\r\n\t\t\t\t\t\tpStatements.put(addressCityStat, 0);\r\n\t\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.2 index address relations\r\n\t\t\t\tif (indexAddress || indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PREINDEX_ADRESS_MAP\"), allRelations); //$NON-NLS-1$\r\n\t\t\t\t\tallRelations = iterateOverEntities(progress, EntityType.RELATION, allRelations,\r\n\t\t\t\t\t\t\tSTEP_ADDRESS_RELATIONS_AND_MULTYPOLYGONS);\r\n\t\t\t\t\t// commit to put all cities\r\n\t\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\t\tif (pStatements.get(addressBuildingStat) > 0) {\r\n\t\t\t\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (pStatements.get(addressStreetNodeStat) > 0) {\r\n\t\t\t\t\t\t\taddressStreetNodeStat.executeBatch();\r\n\t\t\t\t\t\t\tpStatements.put(addressStreetNodeStat, 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.3 MAIN iterate over all entities\r\n\t\t\t\tif (indexPOI || indexAddress || indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[50 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Processing osm nodes...\", allNodes);\r\n\t\t\t\t\titerateOverEntities(progress, EntityType.NODE, allNodes, STEP_MAIN);\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[70 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Processing osm ways...\", allWays);\r\n\t\t\t\t\titerateOverEntities(progress, EntityType.WAY, allWays, STEP_MAIN);\r\n\t\t\t\t}\r\n\t\t\t\tprogress.setGeneralProgress(\"[85 of 100]\");\r\n\t\t\t\tprogress.startTask(\"Processing osm relations...\", allRelations);\r\n\t\t\t\titerateOverEntities(progress, EntityType.RELATION, allRelations, STEP_MAIN);\r\n\t\t\t\t\r\n\t\t\t\t// 3.4 combine all low level ways and simplify them\r\n\t\t\t\tif(indexMap){\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Indexing low level ways...\", lowLevelWays);\r\n\t\t\t\t\tprocessingLowLevelWays(progress);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.5 update all postal codes from relations\r\n\t\t\t\tif (indexAddress && !postalCodeRelations.isEmpty()) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Registering postcodes...\", -1);\r\n\t\t\t\t\tif (pStatements.get(addressBuildingStat) > 0) {\r\n\t\t\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprocessingPostcodes();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 4. packing map rtree indexes\r\n\t\t\t\tif (indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_MAP\"), -1); //$NON-NLS-1$\r\n\t\t\t\t\tfor (int i = 0; i < mapZooms.size(); i++) {\r\n\t\t\t\t\t\tmapTree[i] = packRtreeFile(mapTree[i], getRTreeMapIndexNonPackFileName() + i, getRTreeMapIndexPackFileName() + i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_TRANSP\"), -1); //$NON-NLS-1$\r\n\t\t\t\t\ttransportStopsTree = packRtreeFile(transportStopsTree, getRTreeTransportStopsFileName(), getRTreeTransportStopsPackFileName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 5. Writing binary file\r\n\t\t\tif (indexMap || indexAddress || indexTransport) {\r\n\t\t\t\tif (mapFile.exists()) {\r\n\t\t\t\t\tmapFile.delete();\r\n\t\t\t\t}\r\n\t\t\t\tmapRAFile = new RandomAccessFile(mapFile, \"rw\");\r\n\t\t\t\tBinaryMapIndexWriter writer = new BinaryMapIndexWriter(mapRAFile);\r\n\t\t\t\tif (indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Writing map index to binary file...\", -1);\r\n\t\t\t\t\tclosePreparedStatements(mapBinaryStat, mapLowLevelBinaryStat);\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\twriteBinaryMapIndex(writer);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Writing address index to binary file...\", -1);\r\n\t\t\t\t\tclosePreparedStatements(addressCityStat, addressStreetStat, addressStreetNodeStat, addressBuildingStat);\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\twriteBinaryAddressIndex(writer, progress);\r\n\t\t\t\t}\r\n\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Writing transport index to binary file...\", -1);\r\n\t\t\t\t\tclosePreparedStatements(transRouteStat, transRouteStopsStat, transStopsStat);\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\twriteBinaryTransportIndex(writer);\r\n\t\t\t\t}\r\n\t\t\t\tprogress.finishTask();\r\n\t\t\t\twriter.close();\r\n\t\t\t\tmapRAFile.close();\r\n\t\t\t\tlog.info(\"Finish writing binary file\"); //$NON-NLS-1$\r\n\t\t\t}\r\n\t\t} catch (RuntimeException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} catch (SQLException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} catch (IOException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} catch (SAXException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\tif (pselectNode != null) {\r\n\t\t\t\t\tpselectNode.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (pselectWay != null) {\r\n\t\t\t\t\tpselectWay.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (pselectRelation != null) {\r\n\t\t\t\t\tpselectRelation.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (pselectTags != null) {\r\n\t\t\t\t\tpselectTags.close();\r\n\t\t\t\t}\r\n\t\t\t\tfor (PreparedStatement p : pStatements.keySet()) {\r\n\t\t\t\t\tif (pStatements.get(p) > 0) {\r\n\t\t\t\t\t\tp.executeBatch();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tp.close();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (poiConnection != null) {\r\n\t\t\t\t\tpoiConnection.commit();\r\n\t\t\t\t\tpoiConnection.close();\r\n\t\t\t\t\tpoiConnection = null;\r\n\t\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\t\tpoiIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (mapConnection != null) {\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\tmapConnection.close();\r\n\t\t\t\t\tmapConnection = null;\r\n\t\t\t\t\tFile tempDBFile = new File(workingDir, getTempMapDBFileName());\r\n\t\t\t\t\tif (databaseFileExists(tempDBFile) && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\t// do not delete it for now\r\n\t\t\t\t\t\tremoveDatabase(tempDBFile);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// delete map rtree files\r\n\t\t\t\tif (mapTree != null) {\r\n\t\t\t\t\tfor (int i = 0; i < mapTree.length; i++) {\r\n\t\t\t\t\t\tif (mapTree[i] != null) {\r\n\t\t\t\t\t\t\tRandomAccessFile file = mapTree[i].getFileHdr().getFile();\r\n\t\t\t\t\t\t\tfile.close();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (int i = 0; i < mapTree.length; i++) {\r\n\t\t\t\t\t\tFile f = new File(getRTreeMapIndexNonPackFileName() + i);\r\n\t\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tf = new File(getRTreeMapIndexPackFileName() + i);\r\n\t\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// delete transport rtree files\r\n\t\t\t\tif (transportStopsTree != null) {\r\n\t\t\t\t\ttransportStopsTree.getFileHdr().getFile().close();\r\n\t\t\t\t\tFile f = new File(getRTreeTransportStopsFileName());\r\n\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tf = new File(getRTreeTransportStopsPackFileName());\r\n\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// do not delete first db connection\r\n\t\t\t\tif (dbConn != null) {\r\n\t\t\t\t\tif (usingH2()) {\r\n\t\t\t\t\t\tdbConn.createStatement().execute(\"SHUTDOWN COMPACT\"); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdbConn.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (deleteOsmDB) {\r\n\t\t\t\t\tif (usingDerby()) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tDriverManager.getConnection(\"jdbc:derby:;shutdown=true\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t} catch (SQLException e) {\r\n\t\t\t\t\t\t\t// ignore exception\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tremoveDatabase(dbFile);\r\n\t\t\t\t}\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":67706,"modified_method":"public void generateIndexes(File readFile, IProgress progress, IOsmStorageFilter addFilter, MapZooms mapZooms, MapRenderingTypes renderingTypes) \r\n\tthrows IOException, SAXException,\r\n\t\t\tSQLException {\r\n\t\tif(renderingTypes != null){\r\n\t\t\tthis.renderingTypes = renderingTypes;\r\n\t\t}\r\n\r\n\t\tthis.mapZooms = mapZooms;\r\n\t\tmultiPolygonsWays = new Map[mapZooms.size()];\r\n\t\tfor (int i = 0; i < multiPolygonsWays.length; i++) {\r\n\t\t\tmultiPolygonsWays[i] = new LinkedHashMap<Long, Set<Integer>>();\r\n\t\t}\r\n\t\t\r\n\t\t// clear previous results and setting variables\r\n\t\tif (readFile != null && regionName == null) {\r\n\t\t\tint i = readFile.getName().indexOf('.');\r\n\t\t\tif (i > -1) {\r\n\t\t\t\tregionName = Algoritms.capitalizeFirstLetterAndLowercase(readFile.getName().substring(0, i));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tcities.clear();\r\n\t\tcityManager.clear();\r\n\t\tlowLevelWays = -1;\r\n\t\tpostalCodeRelations.clear();\r\n\t\tif (normalizeStreets) {\r\n\t\t\tnormalizeDefaultSuffixes = DataExtractionSettings.getSettings().getDefaultSuffixesToNormalizeStreets();\r\n\t\t\tnormalizeSuffixes = DataExtractionSettings.getSettings().getSuffixesToNormalizeStreets();\r\n\t\t}\r\n\r\n\t\t// Main generation method\r\n\t\ttry {\r\n\t\t\t// ////////////////////////////////////////////////////////////////////////\r\n\t\t\t// 1. creating nodes db to fast access for all nodes and simply import all relations, ways, nodes to it\r\n\t\t\tboolean loadFromPath = dbFile == null || !databaseFileExists(dbFile);\r\n\t\t\tif (dbFile == null) {\r\n\t\t\t\tdbFile = new File(workingDir, TEMP_NODES_DB);\r\n\t\t\t\t// to save space\r\n\t\t\t\tif (databaseFileExists(dbFile)) {\r\n\t\t\t\t\tremoveDatabase(dbFile);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tdbConn = getDatabaseConnection(dbFile.getAbsolutePath());\r\n\r\n\t\t\tint allRelations = 100000;\r\n\t\t\tint allWays = 1000000;\r\n\t\t\tint allNodes = 10000000;\r\n\t\t\tif (loadFromPath) {\r\n\t\t\t\tprogress.setGeneralProgress(\"[35 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.LOADING_FILE\") + readFile.getAbsolutePath(), -1); //$NON-NLS-1$\r\n\r\n\t\t\t\tNewDataExtractionOsmFilter filter = extractOsmToNodesDB(readFile, progress, addFilter);\r\n\t\t\t\tif (filter != null) {\r\n\t\t\t\t\tallNodes = filter.getAllNodes();\r\n\t\t\t\t\tallWays = filter.getAllWays();\r\n\t\t\t\t\tallRelations = filter.getAllRelations();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tpselectNode = dbConn.prepareStatement(\"select n.latitude, n.longitude, t.skeys, t.value from node n left join tags t on n.id = t.id and t.type = 0 where n.id = ?\"); //$NON-NLS-1$\r\n\t\t\tpselectWay = dbConn.prepareStatement(\"select w.node, w.ord, t.skeys, t.value, n.latitude, n.longitude \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"from ways w left join tags t on w.id = t.id and t.type = 1 and w.ord = 0 inner join node n on w.node = n.id \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"where w.id = ? order by w.ord\"); //$NON-NLS-1$\r\n\t\t\tpselectRelation = dbConn.prepareStatement(\"select r.member, r.type, r.role, r.ord, t.skeys, t.value \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"from relations r left join tags t on r.id = t.id and t.type = 2 and r.ord = 0 \" + //$NON-NLS-1$\r\n\t\t\t\t\t\"where r.id = ? order by r.ord\"); //$NON-NLS-1$\r\n\t\t\tpselectTags = dbConn.prepareStatement(\"select skeys, value from tags where id = ? and type = ?\"); //$NON-NLS-1$\r\n\r\n\t\t\t// do not create temp map file and rtree files\r\n\t\t\tif (recreateOnlyBinaryFile) {\r\n\t\t\t\tmapFile = new File(workingDir, getMapFileName());\r\n\t\t\t\tFile tempDBMapFile = new File(workingDir, getTempMapDBFileName());\r\n\t\t\t\tmapConnection = getDatabaseConnection(tempDBMapFile.getAbsolutePath());\r\n\t\t\t\tmapConnection.setAutoCommit(false);\r\n\t\t\t\ttry {\r\n\t\t\t\t\tif (indexMap) {\r\n\t\t\t\t\t\tmapTree = new RTree[mapZooms.size()];\r\n\t\t\t\t\t\tfor (int i = 0; i < mapZooms.size(); i++) {\r\n\t\t\t\t\t\t\tmapTree[i] = new RTree(getRTreeMapIndexPackFileName() + i);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\t\ttransportStopsTree = new RTree(getRTreeTransportStopsPackFileName());\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (RTreeException e) {\r\n\t\t\t\t\tlog.error(\"Error flushing\", e); //$NON-NLS-1$\r\n\t\t\t\t\tthrow new IOException(e);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// 2. Create index connections and index structure\r\n\t\t\t\tcreateDatabaseIndexesStructure();\r\n\r\n\t\t\t\t// 3. Processing all entries\r\n\t\t\t\t// 3.1 write all cities\r\n\r\n\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.INDEX_CITIES\"), allNodes); //$NON-NLS-1$\r\n\t\t\t\t\tif (!loadFromPath) {\r\n\t\t\t\t\t\tallNodes = iterateOverEntities(progress, EntityType.NODE, allNodes, STEP_CITY_NODES);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tfor (City c : cities.values()) {\r\n\t\t\t\t\t\tDataIndexWriter.writeCity(addressCityStat, pStatements, c, BATCH_SIZE);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// commit to put all cities\r\n\t\t\t\t\tif (pStatements.get(addressCityStat) > 0) {\r\n\t\t\t\t\t\taddressCityStat.executeBatch();\r\n\t\t\t\t\t\tpStatements.put(addressCityStat, 0);\r\n\t\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.2 index address relations\r\n\t\t\t\tif (indexAddress || indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[40 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PREINDEX_ADRESS_MAP\"), allRelations); //$NON-NLS-1$\r\n\t\t\t\t\tallRelations = iterateOverEntities(progress, EntityType.RELATION, allRelations,\r\n\t\t\t\t\t\t\tSTEP_ADDRESS_RELATIONS_AND_MULTYPOLYGONS);\r\n\t\t\t\t\t// commit to put all cities\r\n\t\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\t\tif (pStatements.get(addressBuildingStat) > 0) {\r\n\t\t\t\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (pStatements.get(addressStreetNodeStat) > 0) {\r\n\t\t\t\t\t\t\taddressStreetNodeStat.executeBatch();\r\n\t\t\t\t\t\t\tpStatements.put(addressStreetNodeStat, 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.3 MAIN iterate over all entities\r\n\t\t\t\tif (indexPOI || indexAddress || indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[50 / 100]\");\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_NODES\"), allNodes);\r\n\t\t\t\t\titerateOverEntities(progress, EntityType.NODE, allNodes, STEP_MAIN);\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[70 / 100]\");\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_WAYS\"), allWays);\r\n\t\t\t\t\titerateOverEntities(progress, EntityType.WAY, allWays, STEP_MAIN);\r\n\t\t\t\t}\r\n\t\t\t\tprogress.setGeneralProgress(\"[85 / 100]\");\r\n\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PROCESS_OSM_REL\"), allRelations);\r\n\t\t\t\titerateOverEntities(progress, EntityType.RELATION, allRelations, STEP_MAIN);\r\n\t\t\t\t\r\n\t\t\t\t// 3.4 combine all low level ways and simplify them\r\n\t\t\t\tif(indexMap){\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\");\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.INDEX_LO_LEVEL_WAYS\"), lowLevelWays);\r\n\t\t\t\t\tprocessingLowLevelWays(progress);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.5 update all postal codes from relations\r\n\t\t\t\tif (indexAddress && !postalCodeRelations.isEmpty()) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\");\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.REGISTER_PCODES\"), -1);\r\n\t\t\t\t\tif (pStatements.get(addressBuildingStat) > 0) {\r\n\t\t\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tprocessingPostcodes();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 4. packing map rtree indexes\r\n\t\t\t\tif (indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_MAP\"), -1); //$NON-NLS-1$\r\n\t\t\t\t\tfor (int i = 0; i < mapZooms.size(); i++) {\r\n\t\t\t\t\t\tmapTree[i] = packRtreeFile(mapTree[i], getRTreeMapIndexNonPackFileName() + i, getRTreeMapIndexPackFileName() + i);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[90 / 100]\"); //$NON-NLS-1$\r\n\t\t\t\t\tprogress.startTask(Messages.getString(\"IndexCreator.PACK_RTREE_TRANSP\"), -1); //$NON-NLS-1$\r\n\t\t\t\t\ttransportStopsTree = packRtreeFile(transportStopsTree, getRTreeTransportStopsFileName(), getRTreeTransportStopsPackFileName());\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// 5. Writing binary file\r\n\t\t\tif (indexMap || indexAddress || indexTransport) {\r\n\t\t\t\tif (mapFile.exists()) {\r\n\t\t\t\t\tmapFile.delete();\r\n\t\t\t\t}\r\n\t\t\t\tmapRAFile = new RandomAccessFile(mapFile, \"rw\");\r\n\t\t\t\tBinaryMapIndexWriter writer = new BinaryMapIndexWriter(mapRAFile);\r\n\t\t\t\tif (indexMap) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Writing map index to binary file...\", -1);\r\n\t\t\t\t\tclosePreparedStatements(mapBinaryStat, mapLowLevelBinaryStat);\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\twriteBinaryMapIndex(writer);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (indexAddress) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Writing address index to binary file...\", -1);\r\n\t\t\t\t\tclosePreparedStatements(addressCityStat, addressStreetStat, addressStreetNodeStat, addressBuildingStat);\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\twriteBinaryAddressIndex(writer, progress);\r\n\t\t\t\t}\r\n\t\t\t\tif (indexTransport) {\r\n\t\t\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\t\t\t\tprogress.startTask(\"Writing transport index to binary file...\", -1);\r\n\t\t\t\t\tclosePreparedStatements(transRouteStat, transRouteStopsStat, transStopsStat);\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\twriteBinaryTransportIndex(writer);\r\n\t\t\t\t}\r\n\t\t\t\tprogress.finishTask();\r\n\t\t\t\twriter.close();\r\n\t\t\t\tmapRAFile.close();\r\n\t\t\t\tlog.info(\"Finish writing binary file\"); //$NON-NLS-1$\r\n\t\t\t}\r\n\t\t} catch (RuntimeException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} catch (SQLException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} catch (IOException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} catch (SAXException e) {\r\n\t\t\tlog.error(\"Log exception\", e); //$NON-NLS-1$\r\n\t\t\tthrow e;\r\n\t\t} finally {\r\n\t\t\ttry {\r\n\t\t\t\tif (pselectNode != null) {\r\n\t\t\t\t\tpselectNode.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (pselectWay != null) {\r\n\t\t\t\t\tpselectWay.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (pselectRelation != null) {\r\n\t\t\t\t\tpselectRelation.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (pselectTags != null) {\r\n\t\t\t\t\tpselectTags.close();\r\n\t\t\t\t}\r\n\t\t\t\tfor (PreparedStatement p : pStatements.keySet()) {\r\n\t\t\t\t\tif (pStatements.get(p) > 0) {\r\n\t\t\t\t\t\tp.executeBatch();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tp.close();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (poiConnection != null) {\r\n\t\t\t\t\tpoiConnection.commit();\r\n\t\t\t\t\tpoiConnection.close();\r\n\t\t\t\t\tpoiConnection = null;\r\n\t\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\t\tpoiIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (mapConnection != null) {\r\n\t\t\t\t\tmapConnection.commit();\r\n\t\t\t\t\tmapConnection.close();\r\n\t\t\t\t\tmapConnection = null;\r\n\t\t\t\t\tFile tempDBFile = new File(workingDir, getTempMapDBFileName());\r\n\t\t\t\t\tif (databaseFileExists(tempDBFile) && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\t// do not delete it for now\r\n\t\t\t\t\t\tremoveDatabase(tempDBFile);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// delete map rtree files\r\n\t\t\t\tif (mapTree != null) {\r\n\t\t\t\t\tfor (int i = 0; i < mapTree.length; i++) {\r\n\t\t\t\t\t\tif (mapTree[i] != null) {\r\n\t\t\t\t\t\t\tRandomAccessFile file = mapTree[i].getFileHdr().getFile();\r\n\t\t\t\t\t\t\tfile.close();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor (int i = 0; i < mapTree.length; i++) {\r\n\t\t\t\t\t\tFile f = new File(getRTreeMapIndexNonPackFileName() + i);\r\n\t\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tf = new File(getRTreeMapIndexPackFileName() + i);\r\n\t\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// delete transport rtree files\r\n\t\t\t\tif (transportStopsTree != null) {\r\n\t\t\t\t\ttransportStopsTree.getFileHdr().getFile().close();\r\n\t\t\t\t\tFile f = new File(getRTreeTransportStopsFileName());\r\n\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t}\r\n\t\t\t\t\tf = new File(getRTreeTransportStopsPackFileName());\r\n\t\t\t\t\tif (f.exists() && deleteDatabaseIndexes) {\r\n\t\t\t\t\t\tf.delete();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// do not delete first db connection\r\n\t\t\t\tif (dbConn != null) {\r\n\t\t\t\t\tif (usingH2()) {\r\n\t\t\t\t\t\tdbConn.createStatement().execute(\"SHUTDOWN COMPACT\"); //$NON-NLS-1$\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdbConn.close();\r\n\t\t\t\t}\r\n\t\t\t\tif (deleteOsmDB) {\r\n\t\t\t\t\tif (usingDerby()) {\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tDriverManager.getConnection(\"jdbc:derby:;shutdown=true\"); //$NON-NLS-1$\r\n\t\t\t\t\t\t} catch (SQLException e) {\r\n\t\t\t\t\t\t\t// ignore exception\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tremoveDatabase(dbFile);\r\n\t\t\t\t}\r\n\t\t\t} catch (SQLException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"6aca10398660d1e9bdc4c1c4bf6081c6cd55b882","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void generateIndexes(File readFile, IProgress progress, IOsmStorageFilter addFilter) throws IOException, SAXException,\r\n\tSQLException {\r\n\t\tif (readFile != null && regionName == null) {\r\n\t\t\tint i = readFile.getName().indexOf('.');\r\n\t\t\tif(i > -1){\r\n\t\t\t\tregionName = Algoritms.capitalizeFirstLetterAndLowercase(readFile.getName().substring(0, i));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tClass.forName(\"org.sqlite.JDBC\");\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\tlog.error(\"Illegal configuration\", e);\r\n\t\t\tthrow new IllegalStateException(e);\r\n\t\t}\r\n\t\tboolean loadFromPath = dbFile == null || !dbFile.exists();\r\n\t\tif (dbFile == null) {\r\n\t\t\tdbFile = new File(workingDir, TEMP_NODES_DB);\r\n\t\t\t// to save space\r\n\t\t\tif (dbFile.exists()) {\r\n\t\t\t\tdbFile.delete();\r\n\t\t\t}\r\n\t\t}\r\n\t\t// creating nodes db to fast access for all nodes\r\n\t\tdbConn = DriverManager.getConnection(\"jdbc:sqlite:\" + dbFile.getAbsolutePath());\r\n\t\t\r\n\t\t// clear previous results\r\n\t\tcities.clear();\r\n\t\tcityManager.clear();\r\n\t\tpostalCodeRelations.clear();\r\n\t\t\r\n\t\tint allRelations = 100000;\r\n\t\tint allWays = 1000000;\r\n\t\tint allNodes = 10000000;\r\n\t\tif (loadFromPath) {\r\n\t\t\tInputStream stream = new FileInputStream(readFile);\r\n\t\t\tInputStream streamFile = stream;\r\n\t\t\tlong st = System.currentTimeMillis();\r\n\t\t\tif (readFile.getName().endsWith(\".bz2\")) {\r\n\t\t\t\tif (stream.read() != 'B' || stream.read() != 'Z') {\r\n\t\t\t\t\tthrow new RuntimeException(\"The source stream must start with the characters BZ if it is to be read as a BZip2 stream.\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream = new CBZip2InputStream(stream);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (progress != null) {\r\n\t\t\t\tprogress.startTask(\"Loading file \" + readFile.getAbsolutePath(), -1);\r\n\t\t\t}\r\n\r\n\t\t\tOsmBaseStorage storage = new OsmBaseStorage();\r\n\t\t\tstorage.setSupressWarnings(DataExtractionSettings.getSettings().isSupressWarningsForDuplicatedId());\r\n\t\t\tif (addFilter != null) {\r\n\t\t\t\tstorage.getFilters().add(addFilter);\r\n\t\t\t}\r\n\r\n\t\t\t// 1. Loading osm file\r\n\t\t\tNewDataExtractionOsmFilter filter = new NewDataExtractionOsmFilter();\r\n\t\t\ttry {\r\n\t\t\t\t// 1 init database to store temporary data\r\n\t\t\t\tprogress.setGeneralProgress(\"[50 of 100]\");\r\n\r\n\t\t\t\tfilter.initDatabase();\r\n\t\t\t\tstorage.getFilters().add(filter);\r\n\t\t\t\tstorage.parseOSM(stream, progress, streamFile, false);\r\n\t\t\t\tfilter.finishLoading();\r\n\t\t\t\tallNodes = filter.getAllNodes();\r\n\t\t\t\tallWays = filter.getAllWays();\r\n\t\t\t\tallRelations = filter.getAllRelations();\r\n\r\n\t\t\t\tif (log.isInfoEnabled()) {\r\n\t\t\t\t\tlog.info(\"File parsed : \" + (System.currentTimeMillis() - st));\r\n\t\t\t\t}\r\n\t\t\t\tprogress.finishTask();\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tif (log.isInfoEnabled()) {\r\n\t\t\t\t\tlog.info(\"File indexed : \" + (System.currentTimeMillis() - st));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\r\n\r\n\t\t// 2. Processing all entries\r\n\t\tprogress.setGeneralProgress(\"[90 of 100]\");\r\n\r\n\t\tpselectNode = dbConn.prepareStatement(\"select * from node where id = ?\");\r\n\t\tpselectWay = dbConn.prepareStatement(\"select * from ways where id = ? order by ord\");\r\n\t\tpselectRelation = dbConn.prepareStatement(\"select * from relations where id = ? order by ord\");\r\n\t\tpselectTags = dbConn.prepareStatement(\"select key, value from tags where id = ? and type = ?\");\r\n\t\t\r\n\t\tif(indexMap){\r\n\t\t\tmapFile = new File(workingDir, getMapFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (mapFile.exists()) {\r\n\t\t\t\tmapFile.delete();\r\n\t\t\t}\r\n\t\t\tmapFile.getParentFile().mkdirs();\r\n\t\t\tmapConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + mapFile.getAbsolutePath());\r\n\t\t\t\r\n\t\t\tDataIndexWriter.createMapIndexStructure(mapConnection);\r\n\t\t\tmapObjStat = DataIndexWriter.createStatementMapWaysInsert(mapConnection);\r\n\t\t\tmapLocsStatLevel0 = DataIndexWriter.createStatementMapWaysLocationsInsert(mapConnection);\r\n\t\t\tmapLocsStatLevel1 = DataIndexWriter.createStatementMapWaysLocationsInsertLevel2(mapConnection);\r\n\t\t\tmapLocsStatLevel2 = DataIndexWriter.createStatementMapWaysLocationsInsertLevel3(mapConnection);\r\n//\t\t\ttry {\r\n//\t\t\t\tmapTree = new RTree(mapFile.getAbsolutePath()+\"_ind\");\r\n//\t\t\t} catch (RTreeException e) {\r\n//\t\t\t\t// TODO\r\n//\t\t\t\te.printStackTrace();\r\n//\t\t\t}\r\n\t\t\tpStatements.put(mapObjStat, 0);\r\n\t\t\tpStatements.put(mapLocsStatLevel0, 0);\r\n\t\t\tpStatements.put(mapLocsStatLevel1, 0);\r\n\t\t\tpStatements.put(mapLocsStatLevel2, 0);\r\n\t\t\tmapConnection.setAutoCommit(false);\r\n\t\t}\r\n\r\n\t\tif (indexPOI) {\r\n\t\t\tpoiIndexFile = new File(workingDir, getPoiFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (poiIndexFile.exists()) {\r\n\t\t\t\tpoiIndexFile.delete();\r\n\t\t\t}\r\n\t\t\tpoiIndexFile.getParentFile().mkdirs();\r\n\t\t\t// creating nodes db to fast access for all nodes\r\n\t\t\tpoiConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + poiIndexFile.getAbsolutePath());\r\n\t\t\tDataIndexWriter.createPoiIndexStructure(poiConnection);\r\n\t\t\tpoiPreparedStatement = DataIndexWriter.createStatementAmenityInsert(poiConnection);\r\n\t\t\tpStatements.put(poiPreparedStatement, 0);\r\n\t\t\tpoiConnection.setAutoCommit(false);\r\n\t\t}\r\n\r\n\t\tif (indexTransport) {\r\n\t\t\ttransportIndexFile = new File(workingDir, getTransportFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (transportIndexFile.exists()) {\r\n\t\t\t\ttransportIndexFile.delete();\r\n\t\t\t}\r\n\t\t\ttransportIndexFile.getParentFile().mkdirs();\r\n\t\t\t// creating nodes db to fast access for all nodes\r\n\t\t\ttransportConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + transportIndexFile.getAbsolutePath());\r\n\r\n\t\t\tDataIndexWriter.createTransportIndexStructure(transportConnection);\r\n\t\t\ttransRouteStat = transportConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexTransportRoute\r\n\t\t\t\t\t.getTable(), IndexTransportRoute.values().length));\r\n\t\t\ttransRouteStopsStat = transportConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(\r\n\t\t\t\t\tIndexTransportRouteStop.getTable(), IndexTransportRouteStop.values().length));\r\n\t\t\ttransStopsStat = transportConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexTransportStop\r\n\t\t\t\t\t.getTable(), IndexTransportStop.values().length));\r\n\t\t\tpStatements.put(transRouteStat, 0);\r\n\t\t\tpStatements.put(transRouteStopsStat, 0);\r\n\t\t\tpStatements.put(transStopsStat, 0);\r\n\t\t\ttransportConnection.setAutoCommit(false);\r\n\r\n\t\t}\r\n\t\t\r\n\t\tif (indexAddress) {\r\n\t\t\taddressIndexFile = new File(workingDir, getAddressFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (addressIndexFile.exists()) {\r\n\t\t\t\taddressIndexFile.delete();\r\n\t\t\t}\r\n\t\t\taddressIndexFile.getParentFile().mkdirs();\r\n\t\t\t// creating nodes db to fast access for all nodes\r\n\t\t\taddressConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + addressIndexFile.getAbsolutePath());\r\n\r\n\t\t\tDataIndexWriter.createAddressIndexStructure(addressConnection);\r\n\t\t\taddressCityStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexCityTable.getTable(),\r\n\t\t\t\t\tIndexCityTable.values().length));\r\n\t\t\taddressStreetStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexStreetTable\r\n\t\t\t\t\t.getTable(), IndexStreetTable.values().length));\r\n\t\t\taddressSearchStreetStat = addressConnection.prepareStatement(\"SELECT \" + IndexStreetTable.ID.name() + \" FROM \" + \r\n\t\t\t\t\tIndexStreetTable.getTable() + \" WHERE ? = \" + IndexStreetTable.CITY.name() + \" AND ? =\" + IndexStreetTable.NAME.name());\r\n\t\t\taddressSearchBuildingStat = addressConnection.prepareStatement(\"SELECT \" + IndexBuildingTable.ID.name() + \" FROM \" + \r\n\t\t\t\t\tIndexBuildingTable.getTable() + \" WHERE ? = \" + IndexBuildingTable.ID.name());\r\n\t\t\taddressSearchStreetNodeStat = addressConnection.prepareStatement(\"SELECT \" + IndexStreetNodeTable.WAY.name() + \" FROM \" + \r\n\t\t\t\t\tIndexStreetNodeTable.getTable() + \" WHERE ? = \" + IndexStreetNodeTable.WAY.name());\r\n\t\t\taddressBuildingStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexBuildingTable\r\n\t\t\t\t\t.getTable(), IndexBuildingTable.values().length));\r\n\t\t\taddressStreetNodeStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(\r\n\t\t\t\t\tIndexStreetNodeTable.getTable(), IndexStreetNodeTable.values().length));\r\n\t\t\tpStatements.put(addressCityStat, 0);\r\n\t\t\tpStatements.put(addressStreetStat, 0);\r\n\t\t\tpStatements.put(addressStreetNodeStat, 0);\r\n\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t// put search statements to close them after all\r\n\t\t\tpStatements.put(addressSearchBuildingStat, 0);\r\n\t\t\tpStatements.put(addressSearchStreetNodeStat, 0);\r\n\t\t\tpStatements.put(addressSearchStreetStat, 0);\r\n\t\t\t\r\n\t\t\taddressConnection.setAutoCommit(false);\r\n\t\t}\r\n\r\n\t\tif(normalizeStreets){\r\n\t\t\tnormalizeDefaultSuffixes = DataExtractionSettings.getSettings().getDefaultSuffixesToNormalizeStreets();\r\n\t\t\tnormalizeSuffixes = DataExtractionSettings.getSettings().getSuffixesToNormalizeStreets();\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// 1. write all cities\r\n\t\tif(indexAddress){\r\n\t\t\tif(!loadFromPath){\r\n\t\t\t\tallNodes = iterateOverEntities(progress, EntityType.NODE, allNodes, STEP_CITY_NODES);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(City c : cities.values()){\r\n\t\t\t\tDataIndexWriter.writeCity(addressCityStat, pStatements, c, BATCH_SIZE);\r\n\t\t\t}\r\n\t\t\t// commit to put all cities\r\n\t\t\tif(pStatements.get(addressCityStat) > 0){\r\n\t\t\t\taddressCityStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressCityStat, 0);\r\n\t\t\t\taddressConnection.commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// 2. index address relations\r\n\t\tif(indexAddress){\r\n\t\t\tallRelations = iterateOverEntities(progress, EntityType.RELATION, allRelations, STEP_ADDRESS_RELATIONS);\r\n\t\t\t// commit to put all cities\r\n\t\t\tif(pStatements.get(addressBuildingStat) > 0){\r\n\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t}\r\n\t\t\tif(pStatements.get(addressStreetNodeStat) > 0){\r\n\t\t\t\taddressStreetNodeStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressStreetNodeStat, 0);\r\n\t\t\t}\r\n\t\t\taddressConnection.commit();\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// 3. iterate over all entities\r\n\t\titerateOverAllEntities(progress, allNodes, allWays, allRelations, STEP_MAIN);\r\n\t\t\r\n\t\t\r\n\t\t// 4. update all postal codes from relations\r\n\t\tif(indexAddress && !postalCodeRelations.isEmpty()){\r\n\t\t\tprogress.startTask(\"Registering postcodes...\", -1);\r\n\t\t\tif(pStatements.get(addressBuildingStat) > 0){\r\n\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t\taddressConnection.commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tPreparedStatement pstat = addressConnection.prepareStatement(\"UPDATE \" + IndexBuildingTable.getTable() + \r\n\t\t\t\t\t\" SET \" + IndexBuildingTable.POSTCODE.name() + \" = ? WHERE \" + IndexBuildingTable.ID.name() + \" = ?\");\r\n\t\t\tpStatements.put(pstat, 0);\r\n\t\t\tfor(Relation r : postalCodeRelations){\r\n\t\t\t\tString tag = r.getTag(OSMTagKey.POSTAL_CODE);\r\n\t\t\t\tfor(EntityId l : r.getMemberIds()){\r\n\t\t\t\t\tpstat.setString(1, tag);\r\n\t\t\t\t\tpstat.setLong(2, l.getId());\r\n\t\t\t\t\tDataIndexWriter.addBatch(pStatements, pstat, BATCH_SIZE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t// 5. writing low level maps\r\n\t\tif(indexMap){\r\n\t\t\tfor(Long l : lowLevelWaysSt.keySet()){\r\n\t\t\t\tfor(Way w : lowLevelWaysSt.get(l)){\r\n\t\t\t\t\tint level = (int) (w.getId() & 3);\r\n\t\t\t\t\twriteEntityToMapDatabase(w, w.getId() >> 2, false, level);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tif (pselectNode != null) {\r\n\t\t\t\tpselectNode.close();\r\n\t\t\t}\r\n\t\t\tif (pselectWay != null) {\r\n\t\t\t\tpselectWay.close();\r\n\t\t\t}\r\n\t\t\tif (pselectRelation != null) {\r\n\t\t\t\tpselectRelation.close();\r\n\t\t\t}\r\n\t\t\tif (pselectTags != null) {\r\n\t\t\t\tpselectTags.close();\r\n\t\t\t}\r\n\t\t\tfor (PreparedStatement p : pStatements.keySet()) {\r\n\t\t\t\tif (pStatements.get(p) > 0) {\r\n\t\t\t\t\tp.executeBatch();\r\n\t\t\t\t}\r\n\t\t\t\tp.close();\r\n\t\t\t}\r\n\r\n\t\t\tif (poiConnection != null) {\r\n\t\t\t\tpoiConnection.commit();\r\n\t\t\t\tpoiConnection.close();\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\tpoiIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (transportConnection != null) {\r\n\t\t\t\ttransportConnection.commit();\r\n\t\t\t\ttransportConnection.close();\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\ttransportIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (mapConnection != null) {\r\n\t\t\t\tmapConnection.commit();\r\n\t\t\t\tmapConnection.close();\r\n//\t\t\t\ttry {\r\n//\t\t\t\t\tmapTree.flush();\r\n//\t\t\t\t} catch (RTreeException e) {\r\n//\t\t\t\t\t// TODO Auto-generated catch block\r\n//\t\t\t\t\te.printStackTrace();\r\n//\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\tmapFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (addressConnection != null) {\r\n\t\t\t\taddressConnection.commit();\r\n\t\t\t\taddressConnection.close();\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\taddressIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tdbConn.close();\r\n\t\t} catch (SQLException e) {\r\n\t\t}\r\n\t}","id":67707,"modified_method":"public void generateIndexes(File readFile, IProgress progress, IOsmStorageFilter addFilter) throws IOException, SAXException,\r\n\tSQLException {\r\n\t\tif (readFile != null && regionName == null) {\r\n\t\t\tint i = readFile.getName().indexOf('.');\r\n\t\t\tif(i > -1){\r\n\t\t\t\tregionName = Algoritms.capitalizeFirstLetterAndLowercase(readFile.getName().substring(0, i));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\ttry {\r\n\t\t\tClass.forName(\"org.sqlite.JDBC\");\r\n\t\t} catch (ClassNotFoundException e) {\r\n\t\t\tlog.error(\"Illegal configuration\", e);\r\n\t\t\tthrow new IllegalStateException(e);\r\n\t\t}\r\n\t\tboolean loadFromPath = dbFile == null || !dbFile.exists();\r\n\t\tif (dbFile == null) {\r\n\t\t\tdbFile = new File(workingDir, TEMP_NODES_DB);\r\n\t\t\t// to save space\r\n\t\t\tif (dbFile.exists()) {\r\n\t\t\t\tdbFile.delete();\r\n\t\t\t}\r\n\t\t}\r\n\t\t// creating nodes db to fast access for all nodes\r\n\t\tdbConn = DriverManager.getConnection(\"jdbc:sqlite:\" + dbFile.getAbsolutePath());\r\n\t\t\r\n\t\t// clear previous results\r\n\t\tcities.clear();\r\n\t\tcityManager.clear();\r\n\t\tpostalCodeRelations.clear();\r\n\t\t\r\n\t\tint allRelations = 100000;\r\n\t\tint allWays = 1000000;\r\n\t\tint allNodes = 10000000;\r\n\t\tif (loadFromPath) {\r\n\t\t\tInputStream stream = new FileInputStream(readFile);\r\n\t\t\tInputStream streamFile = stream;\r\n\t\t\tlong st = System.currentTimeMillis();\r\n\t\t\tif (readFile.getName().endsWith(\".bz2\")) {\r\n\t\t\t\tif (stream.read() != 'B' || stream.read() != 'Z') {\r\n\t\t\t\t\tthrow new RuntimeException(\"The source stream must start with the characters BZ if it is to be read as a BZip2 stream.\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstream = new CBZip2InputStream(stream);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (progress != null) {\r\n\t\t\t\tprogress.startTask(\"Loading file \" + readFile.getAbsolutePath(), -1);\r\n\t\t\t}\r\n\r\n\t\t\tOsmBaseStorage storage = new OsmBaseStorage();\r\n\t\t\tstorage.setSupressWarnings(DataExtractionSettings.getSettings().isSupressWarningsForDuplicatedId());\r\n\t\t\tif (addFilter != null) {\r\n\t\t\t\tstorage.getFilters().add(addFilter);\r\n\t\t\t}\r\n\r\n\t\t\t// 1. Loading osm file\r\n\t\t\tNewDataExtractionOsmFilter filter = new NewDataExtractionOsmFilter();\r\n\t\t\ttry {\r\n\t\t\t\t// 1 init database to store temporary data\r\n\t\t\t\tprogress.setGeneralProgress(\"[50 of 100]\");\r\n\r\n\t\t\t\tfilter.initDatabase();\r\n\t\t\t\tstorage.getFilters().add(filter);\r\n\t\t\t\tstorage.parseOSM(stream, progress, streamFile, false);\r\n\t\t\t\tfilter.finishLoading();\r\n\t\t\t\tallNodes = filter.getAllNodes();\r\n\t\t\t\tallWays = filter.getAllWays();\r\n\t\t\t\tallRelations = filter.getAllRelations();\r\n\r\n\t\t\t\tif (log.isInfoEnabled()) {\r\n\t\t\t\t\tlog.info(\"File parsed : \" + (System.currentTimeMillis() - st));\r\n\t\t\t\t}\r\n\t\t\t\tprogress.finishTask();\r\n\r\n\t\t\t} finally {\r\n\t\t\t\tif (log.isInfoEnabled()) {\r\n\t\t\t\t\tlog.info(\"File indexed : \" + (System.currentTimeMillis() - st));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\r\n\r\n\t\t// 2. Processing all entries\r\n\r\n\t\tpselectNode = dbConn.prepareStatement(\"select * from node where id = ?\");\r\n\t\tpselectWay = dbConn.prepareStatement(\"select * from ways where id = ? order by ord\");\r\n\t\tpselectRelation = dbConn.prepareStatement(\"select * from relations where id = ? order by ord\");\r\n\t\tpselectTags = dbConn.prepareStatement(\"select key, value from tags where id = ? and type = ?\");\r\n\t\t\r\n\t\tif(indexMap){\r\n\t\t\tmapFile = new File(workingDir, getMapFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (mapFile.exists()) {\r\n\t\t\t\tmapFile.delete();\r\n\t\t\t}\r\n\t\t\tmapFile.getParentFile().mkdirs();\r\n\t\t\tmapConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + mapFile.getAbsolutePath());\r\n\t\t\t\r\n\t\t\tDataIndexWriter.createMapIndexStructure(mapConnection);\r\n\t\t\tmapObjStat = DataIndexWriter.createStatementMapWaysInsert(mapConnection);\r\n\t\t\tmapLocsStatLevel0 = DataIndexWriter.createStatementMapWaysLocationsInsert(mapConnection);\r\n\t\t\tmapLocsStatLevel1 = DataIndexWriter.createStatementMapWaysLocationsInsertLevel2(mapConnection);\r\n\t\t\tmapLocsStatLevel2 = DataIndexWriter.createStatementMapWaysLocationsInsertLevel3(mapConnection);\r\n//\t\t\ttry {\r\n//\t\t\t\tmapTree = new RTree(mapFile.getAbsolutePath()+\"_ind\");\r\n//\t\t\t} catch (RTreeException e) {\r\n//\t\t\t\t// TODO\r\n//\t\t\t\te.printStackTrace();\r\n//\t\t\t}\r\n\t\t\tpStatements.put(mapObjStat, 0);\r\n\t\t\tpStatements.put(mapLocsStatLevel0, 0);\r\n\t\t\tpStatements.put(mapLocsStatLevel1, 0);\r\n\t\t\tpStatements.put(mapLocsStatLevel2, 0);\r\n\t\t\tmapConnection.setAutoCommit(false);\r\n\t\t}\r\n\r\n\t\tif (indexPOI) {\r\n\t\t\tpoiIndexFile = new File(workingDir, getPoiFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (poiIndexFile.exists()) {\r\n\t\t\t\tpoiIndexFile.delete();\r\n\t\t\t}\r\n\t\t\tpoiIndexFile.getParentFile().mkdirs();\r\n\t\t\t// creating nodes db to fast access for all nodes\r\n\t\t\tpoiConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + poiIndexFile.getAbsolutePath());\r\n\t\t\tDataIndexWriter.createPoiIndexStructure(poiConnection);\r\n\t\t\tpoiPreparedStatement = DataIndexWriter.createStatementAmenityInsert(poiConnection);\r\n\t\t\tpStatements.put(poiPreparedStatement, 0);\r\n\t\t\tpoiConnection.setAutoCommit(false);\r\n\t\t}\r\n\r\n\t\tif (indexTransport) {\r\n\t\t\ttransportIndexFile = new File(workingDir, getTransportFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (transportIndexFile.exists()) {\r\n\t\t\t\ttransportIndexFile.delete();\r\n\t\t\t}\r\n\t\t\ttransportIndexFile.getParentFile().mkdirs();\r\n\t\t\t// creating nodes db to fast access for all nodes\r\n\t\t\ttransportConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + transportIndexFile.getAbsolutePath());\r\n\r\n\t\t\tDataIndexWriter.createTransportIndexStructure(transportConnection);\r\n\t\t\ttransRouteStat = transportConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexTransportRoute\r\n\t\t\t\t\t.getTable(), IndexTransportRoute.values().length));\r\n\t\t\ttransRouteStopsStat = transportConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(\r\n\t\t\t\t\tIndexTransportRouteStop.getTable(), IndexTransportRouteStop.values().length));\r\n\t\t\ttransStopsStat = transportConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexTransportStop\r\n\t\t\t\t\t.getTable(), IndexTransportStop.values().length));\r\n\t\t\tpStatements.put(transRouteStat, 0);\r\n\t\t\tpStatements.put(transRouteStopsStat, 0);\r\n\t\t\tpStatements.put(transStopsStat, 0);\r\n\t\t\ttransportConnection.setAutoCommit(false);\r\n\r\n\t\t}\r\n\t\t\r\n\t\tif (indexAddress) {\r\n\t\t\taddressIndexFile = new File(workingDir, getAddressFileName());\r\n\t\t\t// to save space\r\n\t\t\tif (addressIndexFile.exists()) {\r\n\t\t\t\taddressIndexFile.delete();\r\n\t\t\t}\r\n\t\t\taddressIndexFile.getParentFile().mkdirs();\r\n\t\t\t// creating nodes db to fast access for all nodes\r\n\t\t\taddressConnection = DriverManager.getConnection(\"jdbc:sqlite:\" + addressIndexFile.getAbsolutePath());\r\n\r\n\t\t\tDataIndexWriter.createAddressIndexStructure(addressConnection);\r\n\t\t\taddressCityStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexCityTable.getTable(),\r\n\t\t\t\t\tIndexCityTable.values().length));\r\n\t\t\taddressStreetStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexStreetTable\r\n\t\t\t\t\t.getTable(), IndexStreetTable.values().length));\r\n\t\t\taddressSearchStreetStat = addressConnection.prepareStatement(\"SELECT \" + IndexStreetTable.ID.name() + \" FROM \" + \r\n\t\t\t\t\tIndexStreetTable.getTable() + \" WHERE ? = \" + IndexStreetTable.CITY.name() + \" AND ? =\" + IndexStreetTable.NAME.name());\r\n\t\t\taddressSearchBuildingStat = addressConnection.prepareStatement(\"SELECT \" + IndexBuildingTable.ID.name() + \" FROM \" + \r\n\t\t\t\t\tIndexBuildingTable.getTable() + \" WHERE ? = \" + IndexBuildingTable.ID.name());\r\n\t\t\taddressSearchStreetNodeStat = addressConnection.prepareStatement(\"SELECT \" + IndexStreetNodeTable.WAY.name() + \" FROM \" + \r\n\t\t\t\t\tIndexStreetNodeTable.getTable() + \" WHERE ? = \" + IndexStreetNodeTable.WAY.name());\r\n\t\t\taddressBuildingStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(IndexBuildingTable\r\n\t\t\t\t\t.getTable(), IndexBuildingTable.values().length));\r\n\t\t\taddressStreetNodeStat = addressConnection.prepareStatement(IndexConstants.generatePrepareStatementToInsert(\r\n\t\t\t\t\tIndexStreetNodeTable.getTable(), IndexStreetNodeTable.values().length));\r\n\t\t\tpStatements.put(addressCityStat, 0);\r\n\t\t\tpStatements.put(addressStreetStat, 0);\r\n\t\t\tpStatements.put(addressStreetNodeStat, 0);\r\n\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t// put search statements to close them after all\r\n\t\t\tpStatements.put(addressSearchBuildingStat, 0);\r\n\t\t\tpStatements.put(addressSearchStreetNodeStat, 0);\r\n\t\t\tpStatements.put(addressSearchStreetStat, 0);\r\n\t\t\t\r\n\t\t\taddressConnection.setAutoCommit(false);\r\n\t\t}\r\n\r\n\t\tif(normalizeStreets){\r\n\t\t\tnormalizeDefaultSuffixes = DataExtractionSettings.getSettings().getDefaultSuffixesToNormalizeStreets();\r\n\t\t\tnormalizeSuffixes = DataExtractionSettings.getSettings().getSuffixesToNormalizeStreets();\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// 1. write all cities\r\n\t\t\r\n\t\tif(indexAddress){\r\n\t\t\tprogress.setGeneralProgress(\"[55 of 100]\");\r\n\t\t\tprogress.startTask(\"Indexing cities...\", -1);\r\n\t\t\tif(!loadFromPath){\r\n\t\t\t\tallNodes = iterateOverEntities(progress, EntityType.NODE, allNodes, STEP_CITY_NODES);\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfor(City c : cities.values()){\r\n\t\t\t\tDataIndexWriter.writeCity(addressCityStat, pStatements, c, BATCH_SIZE);\r\n\t\t\t}\r\n\t\t\t// commit to put all cities\r\n\t\t\tif(pStatements.get(addressCityStat) > 0){\r\n\t\t\t\taddressCityStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressCityStat, 0);\r\n\t\t\t\taddressConnection.commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\t// 2. index address relations\r\n\t\tif(indexAddress){\r\n\t\t\tprogress.setGeneralProgress(\"[55 of 100]\");\r\n\t\t\tprogress.startTask(\"Preindexing address...\", -1);\r\n\t\t\tallRelations = iterateOverEntities(progress, EntityType.RELATION, allRelations, STEP_ADDRESS_RELATIONS);\r\n\t\t\t// commit to put all cities\r\n\t\t\tif(pStatements.get(addressBuildingStat) > 0){\r\n\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t}\r\n\t\t\tif(pStatements.get(addressStreetNodeStat) > 0){\r\n\t\t\t\taddressStreetNodeStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressStreetNodeStat, 0);\r\n\t\t\t}\r\n\t\t\taddressConnection.commit();\r\n\t\t}\r\n\t\t\r\n\r\n\t\t// 3. iterate over all entities\r\n\t\titerateOverAllEntities(progress, allNodes, allWays, allRelations, STEP_MAIN);\r\n\t\t\r\n\t\t\r\n\t\t// 4. update all postal codes from relations\r\n\t\tif(indexAddress && !postalCodeRelations.isEmpty()){\r\n\t\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\t\tprogress.startTask(\"Registering postcodes...\", -1);\r\n\t\t\tif(pStatements.get(addressBuildingStat) > 0){\r\n\t\t\t\taddressBuildingStat.executeBatch();\r\n\t\t\t\tpStatements.put(addressBuildingStat, 0);\r\n\t\t\t\taddressConnection.commit();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tPreparedStatement pstat = addressConnection.prepareStatement(\"UPDATE \" + IndexBuildingTable.getTable() + \r\n\t\t\t\t\t\" SET \" + IndexBuildingTable.POSTCODE.name() + \" = ? WHERE \" + IndexBuildingTable.ID.name() + \" = ?\");\r\n\t\t\tpStatements.put(pstat, 0);\r\n\t\t\tfor(Relation r : postalCodeRelations){\r\n\t\t\t\tString tag = r.getTag(OSMTagKey.POSTAL_CODE);\r\n\t\t\t\tfor(EntityId l : r.getMemberIds()){\r\n\t\t\t\t\tpstat.setString(1, tag);\r\n\t\t\t\t\tpstat.setLong(2, l.getId());\r\n\t\t\t\t\tDataIndexWriter.addBatch(pStatements, pstat, BATCH_SIZE);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t// 5. writing low level maps\r\n\t\tprogress.setGeneralProgress(\"[95 of 100]\");\r\n\t\tprogress.startTask(\"Indexing low levels for map ...\", -1);\r\n\t\tif(indexMap){\r\n\t\t\tfor(Long l : lowLevelWaysSt.keySet()){\r\n\t\t\t\tfor(Way w : lowLevelWaysSt.get(l)){\r\n\t\t\t\t\tint level = (int) (w.getId() & 3);\r\n\t\t\t\t\twriteEntityToMapDatabase(w, w.getId() >> 2, false, level);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tif (pselectNode != null) {\r\n\t\t\t\tpselectNode.close();\r\n\t\t\t}\r\n\t\t\tif (pselectWay != null) {\r\n\t\t\t\tpselectWay.close();\r\n\t\t\t}\r\n\t\t\tif (pselectRelation != null) {\r\n\t\t\t\tpselectRelation.close();\r\n\t\t\t}\r\n\t\t\tif (pselectTags != null) {\r\n\t\t\t\tpselectTags.close();\r\n\t\t\t}\r\n\t\t\tfor (PreparedStatement p : pStatements.keySet()) {\r\n\t\t\t\tif (pStatements.get(p) > 0) {\r\n\t\t\t\t\tp.executeBatch();\r\n\t\t\t\t}\r\n\t\t\t\tp.close();\r\n\t\t\t}\r\n\r\n\t\t\tif (poiConnection != null) {\r\n\t\t\t\tpoiConnection.commit();\r\n\t\t\t\tpoiConnection.close();\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\tpoiIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (transportConnection != null) {\r\n\t\t\t\ttransportConnection.commit();\r\n\t\t\t\ttransportConnection.close();\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\ttransportIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (mapConnection != null) {\r\n\t\t\t\tmapConnection.commit();\r\n\t\t\t\tmapConnection.close();\r\n//\t\t\t\ttry {\r\n//\t\t\t\t\tmapTree.flush();\r\n//\t\t\t\t} catch (RTreeException e) {\r\n//\t\t\t\t\t// TODO Auto-generated catch block\r\n//\t\t\t\t\te.printStackTrace();\r\n//\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\tmapFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (addressConnection != null) {\r\n\t\t\t\taddressConnection.commit();\r\n\t\t\t\taddressConnection.close();\r\n\t\t\t\tif (lastModifiedDate != null) {\r\n\t\t\t\t\taddressIndexFile.setLastModified(lastModifiedDate);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tdbConn.close();\r\n\t\t} catch (SQLException e) {\r\n\t\t}\r\n\t}","commit_id":"8dd40fc1d168be2ab7513d49bbe0de2b2f8f08a1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void iterateOverAllEntities(IProgress progress, int allNodes, int allWays, int allRelations, int step) throws SQLException{\r\n\t\titerateOverEntities(progress, EntityType.NODE, allNodes, step);\r\n\t\titerateOverEntities(progress, EntityType.WAY, allWays, step);\r\n\t\titerateOverEntities(progress, EntityType.RELATION, allRelations, step);\r\n\t}","id":67708,"modified_method":"public void iterateOverAllEntities(IProgress progress, int allNodes, int allWays, int allRelations, int step) throws SQLException{\r\n\t\tprogress.setGeneralProgress(\"[65 of 100]\");\r\n\t\titerateOverEntities(progress, EntityType.NODE, allNodes, step);\r\n\t\tprogress.setGeneralProgress(\"[85 of 100]\");\r\n\t\titerateOverEntities(progress, EntityType.WAY, allWays, step);\r\n\t\tprogress.setGeneralProgress(\"[90 of 100]\");\r\n\t\titerateOverEntities(progress, EntityType.RELATION, allRelations, step);\r\n\t}","commit_id":"8dd40fc1d168be2ab7513d49bbe0de2b2f8f08a1","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void formulateBindingFromWebRequest(Binding binding, HttpServletRequest request, HttpServletResponse response, Writer out, GroovyObject controller) {\n        // if there is no controller in the request configure using existing attributes, creating objects where necessary\n        GrailsWebRequest webRequest = GrailsWebRequest.lookup(request);\n        binding.setVariable(GroovyPage.WEB_REQUEST, webRequest);\n        binding.setVariable(GroovyPage.REQUEST, request);\n        binding.setVariable(GroovyPage.RESPONSE, response);\n        binding.setVariable(GroovyPage.FLASH, webRequest.getFlashScope());\n        binding.setVariable(GroovyPage.SERVLET_CONTEXT, context);\n\n        ApplicationContext appCtx = webRequest.getAttributes().getApplicationContext();\n        binding.setVariable(GroovyPage.APPLICATION_CONTEXT, appCtx);\n        if(appCtx!=null) {\n            GrailsApplication app = appCtx.getBean(GrailsApplication.APPLICATION_ID, GrailsApplication.class);\n            binding.setVariable(GrailsApplication.APPLICATION_ID, app);\n            // GSPs aren't in any package anymore, so this isn't required\n            /*\n            Map<String,Class> domainClassesWithoutPackage = getDomainClassMap(app);            \n            final Map variables = binding.getVariables();\n            variables.putAll(domainClassesWithoutPackage);\n            */\n        }\n        binding.setVariable(GroovyPage.SESSION, webRequest.getSession());\n        binding.setVariable(GroovyPage.PARAMS, webRequest.getParams());\n        binding.setVariable(GroovyPage.ACTION_NAME, webRequest.getActionName());\n        binding.setVariable(GroovyPage.CONTROLLER_NAME, webRequest.getControllerName());\n        if(controller!= null) {\n            binding.setVariable(GrailsApplicationAttributes.CONTROLLER, controller);\n        }\n        \n        binding.setVariable(GroovyPage.OUT, out);\n    }","id":67709,"modified_method":"private void formulateBindingFromWebRequest(Binding binding, HttpServletRequest request, HttpServletResponse response, Writer out, GroovyObject controller) {\n        // if there is no controller in the request configure using existing attributes, creating objects where necessary\n        GrailsWebRequest webRequest = GrailsWebRequest.lookup(request);\n        binding.setVariable(GroovyPage.WEB_REQUEST, webRequest);\n        binding.setVariable(GroovyPage.REQUEST, request);\n        binding.setVariable(GroovyPage.RESPONSE, response);\n        binding.setVariable(GroovyPage.FLASH, webRequest.getFlashScope());\n        binding.setVariable(GroovyPage.SERVLET_CONTEXT, context);\n\n        ApplicationContext appCtx = webRequest.getAttributes().getApplicationContext();\n        binding.setVariable(GroovyPage.APPLICATION_CONTEXT, appCtx);\n        if(appCtx!=null) {\n            GrailsApplication app = appCtx.getBean(GrailsApplication.APPLICATION_ID, GrailsApplication.class);\n            binding.setVariable(GrailsApplication.APPLICATION_ID, app);\n            Map<String,Class> domainClassesWithoutPackage = getDomainClassMap(app);            \n            final Map variables = binding.getVariables();\n            variables.putAll(domainClassesWithoutPackage);\n        }\n        binding.setVariable(GroovyPage.SESSION, webRequest.getSession());\n        binding.setVariable(GroovyPage.PARAMS, webRequest.getParams());\n        binding.setVariable(GroovyPage.ACTION_NAME, webRequest.getActionName());\n        binding.setVariable(GroovyPage.CONTROLLER_NAME, webRequest.getControllerName());\n        if(controller!= null) {\n            binding.setVariable(GrailsApplicationAttributes.CONTROLLER, controller);\n        }\n        \n        binding.setVariable(GroovyPage.OUT, out);\n    }","commit_id":"c68f307938104bb7626785933beebd9dbab0901e","url":"https://github.com/grails/grails-core"},{"original_method":"CacheEvaluationContext(Object rootObject, Method method, Object[] args,\n\t\t\tParameterNameDiscoverer paramDiscoverer) {\n\n\t\tsuper(rootObject, method, args, paramDiscoverer);\n\t\tthis.unavailableVariables = new ArrayList<>();\n\t}","id":67710,"modified_method":"CacheEvaluationContext(Object rootObject, Method method, Object[] arguments,\n\t\t\tParameterNameDiscoverer parameterNameDiscoverer) {\n\n\t\tsuper(rootObject, method, arguments, parameterNameDiscoverer);\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Load the param information only when needed.\n\t */\n\tprotected void lazyLoadArguments() {\n\t\t// shortcut if no args need to be loaded\n\t\tif (ObjectUtils.isEmpty(this.args)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// save arguments as indexed variables\n\t\tfor (int i = 0; i < this.args.length; i++) {\n\t\t\tsetVariable(\"a\" + i, this.args[i]);\n\t\t\tsetVariable(\"p\" + i, this.args[i]);\n\t\t}\n\n\t\tString[] parameterNames = this.paramDiscoverer.getParameterNames(this.method);\n\t\t// save parameter names (if discovered)\n\t\tif (parameterNames != null) {\n\t\t\tfor (int i = 0; i < this.args.length; i++) {\n\t\t\t\tsetVariable(parameterNames[i], this.args[i]);\n\t\t\t}\n\t\t}\n\t}","id":67711,"modified_method":"/**\n\t * Load the param information only when needed.\n\t */\n\tprotected void lazyLoadArguments() {\n\t\t// Shortcut if no args need to be loaded\n\t\tif (ObjectUtils.isEmpty(this.arguments)) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Expose indexed variables as well as parameter names (if discoverable)\n\t\tString[] paramNames = this.parameterNameDiscoverer.getParameterNames(this.method);\n\t\tint paramCount = (paramNames != null ? paramNames.length : this.method.getParameterCount());\n\t\tint argsCount = this.arguments.length;\n\n\t\tfor (int i = 0; i < paramCount; i++) {\n\t\t\tObject value = null;\n\t\t\tif (argsCount > paramCount && i == paramCount - 1) {\n\t\t\t\t// Expose remaining arguments as vararg array for last parameter\n\t\t\t\tvalue = Arrays.copyOfRange(this.arguments, i, argsCount);\n\t\t\t}\n\t\t\telse if (argsCount > i) {\n\t\t\t\t// Actual argument found - otherwise left as null\n\t\t\t\tvalue = this.arguments[i];\n\t\t\t}\n\t\t\tsetVariable(\"a\" + i, value);\n\t\t\tsetVariable(\"p\" + i, value);\n\t\t\tif (paramNames != null) {\n\t\t\t\tsetVariable(paramNames[i], value);\n\t\t\t}\n\t\t}\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Override\n\tpublic Object lookupVariable(String name) {\n\t\tObject variable = super.lookupVariable(name);\n\t\tif (variable != null) {\n\t\t\treturn variable;\n\t\t}\n\t\tif (!this.paramLoaded) {\n\t\t\tlazyLoadArguments();\n\t\t\tthis.paramLoaded = true;\n\t\t\tvariable = super.lookupVariable(name);\n\t\t}\n\t\treturn variable;\n\t}","id":67712,"modified_method":"@Override\n\tpublic Object lookupVariable(String name) {\n\t\tObject variable = super.lookupVariable(name);\n\t\tif (variable != null) {\n\t\t\treturn variable;\n\t\t}\n\t\tif (!this.argumentsLoaded) {\n\t\t\tlazyLoadArguments();\n\t\t\tthis.argumentsLoaded = true;\n\t\t\tvariable = super.lookupVariable(name);\n\t\t}\n\t\treturn variable;\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"public MethodBasedEvaluationContext(Object rootObject, Method method, Object[] args,\n\t\t\tParameterNameDiscoverer paramDiscoverer) {\n\n\t\tsuper(rootObject);\n\t\tthis.method = method;\n\t\tthis.args = args;\n\t\tthis.paramDiscoverer = paramDiscoverer;\n\t}","id":67713,"modified_method":"public MethodBasedEvaluationContext(Object rootObject, Method method, Object[] arguments,\n\t\t\tParameterNameDiscoverer parameterNameDiscoverer) {\n\n\t\tsuper(rootObject);\n\t\tthis.method = method;\n\t\tthis.arguments = arguments;\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void varArgNull() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, new Object[] {null, null});\n\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertNull(context.lookupVariable(\"p1\"));\n\t}","id":67714,"modified_method":"@Test\n\tpublic void varArgNull() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, null, null);\n\n\t\tassertNull(context.lookupVariable(\"a0\"));\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertNull(context.lookupVariable(\"flag\"));\n\n\t\tassertNull(context.lookupVariable(\"a1\"));\n\t\tassertNull(context.lookupVariable(\"p1\"));\n\t\tassertNull(context.lookupVariable(\"vararg\"));\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void simpleArguments() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\",\n\t\t\t\tString.class, Boolean.class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, new Object[] {\"test\", true});\n\n\t\tassertEquals(\"test\", context.lookupVariable(\"a0\"));\n\t\tassertEquals(\"test\", context.lookupVariable(\"p0\"));\n\t\tassertEquals(\"test\", context.lookupVariable(\"foo\"));\n\n\t\tassertEquals(true, context.lookupVariable(\"a1\"));\n\t\tassertEquals(true, context.lookupVariable(\"p1\"));\n\t\tassertEquals(true, context.lookupVariable(\"flag\"));\n\n\t\tassertNull(context.lookupVariable(\"a2\"));\n\t}","id":67715,"modified_method":"@Test\n\tpublic void simpleArguments() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", String.class, Boolean.class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, \"test\", true);\n\n\t\tassertEquals(\"test\", context.lookupVariable(\"a0\"));\n\t\tassertEquals(\"test\", context.lookupVariable(\"p0\"));\n\t\tassertEquals(\"test\", context.lookupVariable(\"foo\"));\n\n\t\tassertEquals(true, context.lookupVariable(\"a1\"));\n\t\tassertEquals(true, context.lookupVariable(\"p1\"));\n\t\tassertEquals(true, context.lookupVariable(\"flag\"));\n\n\t\tassertNull(context.lookupVariable(\"a2\"));\n\t\tassertNull(context.lookupVariable(\"p2\"));\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void nullArgument() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\",\n\t\t\t\tString.class, Boolean.class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, new Object[] {null, null});\n\n\t\tassertNull(context.lookupVariable(\"a0\"));\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t}","id":67716,"modified_method":"@Test\n\tpublic void nullArgument() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", String.class, Boolean.class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, null, null);\n\n\t\tassertNull(context.lookupVariable(\"a0\"));\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertNull(context.lookupVariable(\"foo\"));\n\n\t\tassertNull(context.lookupVariable(\"a1\"));\n\t\tassertNull(context.lookupVariable(\"p1\"));\n\t\tassertNull(context.lookupVariable(\"flag\"));\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void varArgSingle() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, new Object[] {null, \"hello\"});\n\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertEquals(\"hello\", context.lookupVariable(\"p1\"));\n\t}","id":67717,"modified_method":"@Test\n\tpublic void varArgSingle() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, null, \"hello\");\n\n\t\tassertNull(context.lookupVariable(\"a0\"));\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertNull(context.lookupVariable(\"flag\"));\n\n\t\tassertEquals(\"hello\", context.lookupVariable(\"a1\"));\n\t\tassertEquals(\"hello\", context.lookupVariable(\"p1\"));\n\t\tassertEquals(\"hello\", context.lookupVariable(\"vararg\"));\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void varArgEmpty() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, new Object[] {null});\n\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertNull(context.lookupVariable(\"p1\"));\n\t}","id":67718,"modified_method":"@Test\n\tpublic void varArgEmpty() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, new Object[] {null});\n\n\t\tassertNull(context.lookupVariable(\"a0\"));\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertNull(context.lookupVariable(\"flag\"));\n\n\t\tassertNull(context.lookupVariable(\"a1\"));\n\t\tassertNull(context.lookupVariable(\"p1\"));\n\t\tassertNull(context.lookupVariable(\"vararg\"));\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"@Test\n\tpublic void varArgMultiple() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method,\n\t\t\t\tnew Object[] {null, new String[]{\"hello\", \"hi\"}});\n\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertArrayEquals(new String[]{\"hello\", \"hi\"}, (String[]) context.lookupVariable(\"p1\"));\n\t}","id":67719,"modified_method":"@Test\n\tpublic void varArgMultiple() {\n\t\tMethod method = ReflectionUtils.findMethod(SampleMethods.class, \"hello\", Boolean.class, String[].class);\n\t\tMethodBasedEvaluationContext context = createEvaluationContext(method, null, \"hello\", \"hi\");\n\n\t\tassertNull(context.lookupVariable(\"a0\"));\n\t\tassertNull(context.lookupVariable(\"p0\"));\n\t\tassertNull(context.lookupVariable(\"flag\"));\n\n\t\tassertArrayEquals(new Object[] {\"hello\", \"hi\"}, (Object[]) context.lookupVariable(\"a1\"));\n\t\tassertArrayEquals(new Object[] {\"hello\", \"hi\"}, (Object[]) context.lookupVariable(\"p1\"));\n\t\tassertArrayEquals(new Object[] {\"hello\", \"hi\"}, (Object[]) context.lookupVariable(\"vararg\"));\n\t}","commit_id":"fae503d5681f0c08936e68bf9bb6f61713adc84f","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"private void lazyInit() {\n        if (initialized) return;\n        initialized = true;\n        HttpServletResponse response = (HttpServletResponse) super.getVariable(\"response\");\n        ServletOutput output = new ServletOutput(response);\n        super.setVariable(\"out\", output.getWriter());\n        super.setVariable(\"sout\", output.getOutputStream());\n        MarkupBuilder builder = new MarkupBuilder(output.getWriter());\n        builder.setExpandEmptyElements(true);\n        super.setVariable(\"html\", builder);\n\t\tJsonBuilder jsonBuilder = new JsonBuilder();\n        super.setVariable(\"json\", jsonBuilder);\n\n        // bind forward method\n        MethodClosure c = new MethodClosure(this, \"forward\");\n        super.setVariable(\"forward\", c);\n        \n        // bind include method\n        c = new MethodClosure(this, \"include\");\n        super.setVariable(\"include\", c);\n        \n        // bind redirect method\n        c = new MethodClosure(this, \"redirect\");\n        super.setVariable(\"redirect\", c);\n    }","id":67720,"modified_method":"private void lazyInit() {\n        if (initialized) return;\n        initialized = true;\n\n        HttpServletResponse response = (HttpServletResponse) super.getVariable(\"response\");\n        ServletOutput output = new ServletOutput(response);\n        super.setVariable(\"out\", output.getWriter());\n        super.setVariable(\"sout\", output.getOutputStream());\n\n        MarkupBuilder builder = new MarkupBuilder(output.getWriter());\n        builder.setExpandEmptyElements(true);\n        super.setVariable(\"html\", builder);\n\n        try {\n            Object jsonBuilder = null;\n            jsonBuilder = this.getClass().getClassLoader().loadClass(\"groovy.json.JsonBuilder\").newInstance();\n            super.setVariable(\"json\", jsonBuilder);\n        } catch (Throwable t) { }\n\n        // bind forward method\n        MethodClosure c = new MethodClosure(this, \"forward\");\n        super.setVariable(\"forward\", c);\n        \n        // bind include method\n        c = new MethodClosure(this, \"include\");\n        super.setVariable(\"include\", c);\n        \n        // bind redirect method\n        c = new MethodClosure(this, \"redirect\");\n        super.setVariable(\"redirect\", c);\n    }","commit_id":"d09be2dbc424260d0eab7a295dca2fb3b5fa0b98","url":"https://github.com/apache/groovy"},{"original_method":"public Dialect.AnalysisResult analyzeExpression(RuleBuildContext context,\r\n                                                    BaseDescr descr,\r\n                                                    Object content) {\r\n        Dialect.AnalysisResult result = null;\r\n        try {\r\n            result = this.analyzer.analyzeExpression( (String) content,\r\n                                                      new Set[]{context.getDeclarationResolver().getDeclarations().keySet(), context.getPkg().getGlobals().keySet()} );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    descr,\r\n                                                    null,\r\n                                                    \"Unable to determine the used declarations\" ) );\r\n        }\r\n        return result;\r\n    }","id":67721,"modified_method":"public Dialect.AnalysisResult analyzeExpression(RuleBuildContext context,\r\n                                                    BaseDescr descr,\r\n                                                    Object content) {\r\n        Dialect.AnalysisResult result = null;\r\n        try {\r\n            result = this.analyzer.analyzeExpression( context,\r\n                                                      (String) content,\r\n                                                      new Set[]{context.getDeclarationResolver().getDeclarations().keySet(), context.getPkg().getGlobals().keySet()} );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    descr,\r\n                                                    null,\r\n                                                    \"Unable to determine the used declarations\" ) );\r\n        }\r\n        return result;\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Dialect.AnalysisResult analyzeBlock(RuleBuildContext context,\r\n                                               BaseDescr descr,\r\n                                               String text) {\r\n        Dialect.AnalysisResult result = null;\r\n        try {\r\n            result = this.analyzer.analyzeExpression( text,\r\n                                                      new Set[]{context.getDeclarationResolver().getDeclarations().keySet(), context.getPkg().getGlobals().keySet()} );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    descr,\r\n                                                    null,\r\n                                                    \"Unable to determine the used declarations\" ) );\r\n        }\r\n        return result;\r\n    }","id":67722,"modified_method":"public Dialect.AnalysisResult analyzeBlock(RuleBuildContext context,\r\n                                               BaseDescr descr,\r\n                                               String text) {\r\n        Dialect.AnalysisResult result = null;\r\n        try {\r\n            result = this.analyzer.analyzeExpression( context,\r\n                                                      text,\r\n                                                      new Set[]{context.getDeclarationResolver().getDeclarations().keySet(), context.getPkg().getGlobals().keySet()} );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    descr,\r\n                                                    null,\r\n                                                    \"Unable to determine the used declarations\" ) );\r\n        }\r\n        return result;\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Builds and returns an Eval Conditional Element\r\n     * \r\n     * @param context The current build context\r\n     * @param utils The current build utils instance\r\n     * @param patternBuilder not used by EvalBuilder\r\n     * @param descr The Eval Descriptor to build the eval conditional element from\r\n     * \r\n     * @return the Eval Conditional Element\r\n     */\r\n    public RuleConditionElement build(final RuleBuildContext context,\r\n                                      final BaseDescr descr,\r\n                                      final Pattern prefixPattern) {\r\n        // it must be an EvalDescr\r\n        final EvalDescr evalDescr = (EvalDescr) descr;\r\n\r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( context.getDeclarationResolver().getDeclarations(),\r\n                                                                     null,\r\n                                                                     context.getPkg().getGlobals() );\r\n            factory.setNextFactory( ((MVELDialect) context.getDialect()).getClassImportResolverFactory() );\r\n\r\n            Dialect.AnalysisResult analysis = context.getDialect().analyzeExpression( context,\r\n                                                                                      evalDescr,\r\n                                                                                      evalDescr.getContent() );\r\n            final List[] usedIdentifiers = analysis.getBoundIdentifiers();\r\n\r\n            final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n            for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n                declarations[i] = context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n            }\r\n\r\n            final EvalCondition eval = new EvalCondition( declarations );\r\n            final Serializable expr = MVEL.compileExpression( (String) evalDescr.getContent(),\r\n                                                              ((MVELDialect) context.getDialect()).getClassImportResolverFactory().getImportedClasses() );\r\n\r\n            eval.setEvalExpression( new MVELEvalExpression( expr,\r\n                                                            factory ) );\r\n\r\n            return eval;\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    evalDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'predicate' node '\" + evalDescr.getContent() + \"'\" ) );\r\n            return null;\r\n        }\r\n    }","id":67723,"modified_method":"/**\r\n     * Builds and returns an Eval Conditional Element\r\n     * \r\n     * @param context The current build context\r\n     * @param utils The current build utils instance\r\n     * @param patternBuilder not used by EvalBuilder\r\n     * @param descr The Eval Descriptor to build the eval conditional element from\r\n     * \r\n     * @return the Eval Conditional Element\r\n     */\r\n    public RuleConditionElement build(final RuleBuildContext context,\r\n                                      final BaseDescr descr,\r\n                                      final Pattern prefixPattern) {\r\n        // it must be an EvalDescr\r\n        final EvalDescr evalDescr = (EvalDescr) descr;\r\n\r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( context.getDeclarationResolver().getDeclarations(),\r\n                                                                     null,\r\n                                                                     context.getPkg().getGlobals() );\r\n            factory.setNextFactory( ((MVELDialect) context.getDialect()).getClassImportResolverFactory() );\r\n\r\n            Dialect.AnalysisResult analysis = context.getDialect().analyzeExpression( context,\r\n                                                                                      evalDescr,\r\n                                                                                      evalDescr.getContent() );\r\n            final List[] usedIdentifiers = analysis.getBoundIdentifiers();\r\n\r\n            final Declaration[] declarations = new Declaration[usedIdentifiers[0].size()];\r\n            for ( int i = 0, size = usedIdentifiers[0].size(); i < size; i++ ) {\r\n                declarations[i] = context.getDeclarationResolver().getDeclaration( (String) usedIdentifiers[0].get( i ) );\r\n            }\r\n\r\n            final EvalCondition eval = new EvalCondition( declarations );                        \r\n            \r\n            Serializable expr = ((MVELDialect) context.getDialect()).compile( (String) evalDescr.getContent(), analysis, context );\r\n\r\n            eval.setEvalExpression( new MVELEvalExpression( expr,\r\n                                                            factory ) );\r\n\r\n            return eval;\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    evalDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'predicate' node '\" + evalDescr.getContent() + \"'\" ) );\r\n            return null;\r\n        }\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testSimpleExpression() {\r\n        final Package pkg = new Package( \"pkg1\" );\r\n        final RuleDescr ruleDescr = new RuleDescr( \"rule 1\" );\r\n\r\n        MVELDialect mvelDialect = new MVELDialect( new PackageBuilder( pkg ) );\r\n        DialectRegistry registry = new DialectRegistry();\r\n        registry.addDialect( \"default\",\r\n                             mvelDialect );\r\n        final PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n\r\n        final InstrumentedBuildContent context = new InstrumentedBuildContent( conf,\r\n                                                                               pkg,\r\n                                                                               ruleDescr,\r\n                                                                               registry,\r\n                                                                               mvelDialect );\r\n\r\n        final InstrumentedDeclarationScopeResolver declarationResolver = new InstrumentedDeclarationScopeResolver();\r\n        \r\n        final FieldExtractor extractor = ClassFieldExtractorCache.getExtractor( Cheese.class, \"price\",\r\n                                                                                getClass().getClassLoader() );\r\n        \r\n        final Pattern pattern = new Pattern( 0,\r\n                                             new ClassObjectType( int.class ) );\r\n        final Declaration declaration = new Declaration( \"a\",\r\n                                                         extractor,\r\n                                                         pattern );\r\n        final Map map = new HashMap();\r\n        map.put( \"a\",\r\n                 declaration );\r\n        declarationResolver.setDeclarations( map );\r\n        context.setDeclarationResolver( declarationResolver );\r\n\r\n        final EvalDescr evalDescr = new EvalDescr();\r\n        evalDescr.setContent( \"a == 10\" );\r\n\r\n        final MVELEvalBuilder builder = new MVELEvalBuilder();\r\n        final EvalCondition eval = (EvalCondition) builder.build( context,\r\n                                                                  evalDescr );\r\n\r\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n        final WorkingMemory wm = ruleBase.newStatefulSession();\r\n\r\n        final Cheese cheddar = new Cheese( \"cheddar\",\r\n                                           10 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) wm.insert( cheddar );\r\n        final ReteTuple tuple = new ReteTuple( f0 );\r\n\r\n        assertTrue( eval.isAllowed( tuple,\r\n                                    wm ) );\r\n\r\n        cheddar.setPrice( 9 );\r\n        wm.update( f0,\r\n                         cheddar );\r\n        assertFalse( eval.isAllowed( tuple,\r\n                                     wm ) );\r\n    }","id":67724,"modified_method":"public void testSimpleExpression() {\r\n        final Package pkg = new Package( \"pkg1\" );\r\n        final RuleDescr ruleDescr = new RuleDescr( \"rule 1\" );\r\n\r\n        MVELDialect mvelDialect = new MVELDialect( new PackageBuilder( pkg ) );\r\n        DialectRegistry registry = new DialectRegistry();\r\n        registry.addDialect( \"mvel\",\r\n                             mvelDialect );\r\n        final PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n\r\n        final InstrumentedBuildContent context = new InstrumentedBuildContent( conf,\r\n                                                                               pkg,\r\n                                                                               ruleDescr,\r\n                                                                               registry,\r\n                                                                               mvelDialect );\r\n\r\n        final InstrumentedDeclarationScopeResolver declarationResolver = new InstrumentedDeclarationScopeResolver();\r\n        \r\n        final FieldExtractor extractor = ClassFieldExtractorCache.getExtractor( Cheese.class, \"price\",\r\n                                                                                getClass().getClassLoader() );\r\n        \r\n        final Pattern pattern = new Pattern( 0,\r\n                                             new ClassObjectType( int.class ) );\r\n        final Declaration declaration = new Declaration( \"a\",\r\n                                                         extractor,\r\n                                                         pattern );\r\n        final Map map = new HashMap();\r\n        map.put( \"a\",\r\n                 declaration );\r\n        declarationResolver.setDeclarations( map );\r\n        context.setDeclarationResolver( declarationResolver );\r\n\r\n        final EvalDescr evalDescr = new EvalDescr();\r\n        evalDescr.setContent( \"a == 10\" );\r\n\r\n        final MVELEvalBuilder builder = new MVELEvalBuilder();\r\n        final EvalCondition eval = (EvalCondition) builder.build( context,\r\n                                                                  evalDescr );\r\n\r\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n        final WorkingMemory wm = ruleBase.newStatefulSession();\r\n\r\n        final Cheese cheddar = new Cheese( \"cheddar\",\r\n                                           10 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) wm.insert( cheddar );\r\n        final ReteTuple tuple = new ReteTuple( f0 );\r\n\r\n        assertTrue( eval.isAllowed( tuple,\r\n                                    wm ) );\r\n\r\n        cheddar.setPrice( 9 );\r\n        wm.update( f0,\r\n                         cheddar );\r\n        assertFalse( eval.isAllowed( tuple,\r\n                                     wm ) );\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\r\n     * Analyze an expression.\r\n     * \r\n     * @param expr\r\n     *            The expression to analyze.\r\n     * @param availDecls\r\n     *            Total set of declarations available.\r\n     * \r\n     * @return The <code>Set<\/code> of declarations used by the expression.\r\n     * @throws RecognitionException \r\n     *             If an error occurs in the parser.\r\n     */\r\n    public MVELAnalysisResult analyzeExpression(final String expr,\r\n                                    final Set[] availableIdentifiers) throws RecognitionException {\r\n        ExpressionCompiler compiler = new ExpressionCompiler( expr);\r\n        compiler.compile();  \r\n        \r\n        return analyze( compiler.getParserContextState().getInputs().keySet(),\r\n                        availableIdentifiers );\r\n    }","id":67725,"modified_method":"/**\r\n     * Analyze an expression.\r\n     * \r\n     * @param expr\r\n     *            The expression to analyze.\r\n     * @param availDecls\r\n     *            Total set of declarations available.\r\n     * \r\n     * @return The <code>Set<\/code> of declarations used by the expression.\r\n     * @throws RecognitionException \r\n     *             If an error occurs in the parser.\r\n     */\r\n    public MVELAnalysisResult analyzeExpression(final RuleBuildContext context,\r\n                                                final String expr,\r\n                                                final Set[] availableIdentifiers) throws RecognitionException {\r\n        ExpressionCompiler compiler = new ExpressionCompiler( expr);\r\n        \r\n        ParserContext parserContext = new ParserContext();\r\n        parserContext.setStrictTypeEnforcement( false );       \r\n        MVELDialect dialect = (MVELDialect) context.getDialect( \"mvel\" );\r\n        parserContext.setImports( dialect.getClassImportResolverFactory().getImportedClasses() );        \r\n        \r\n        compiler.compile(parserContext);  \r\n        \r\n        return analyze( compiler.getParserContextState().getInputs().keySet(),\r\n                        availableIdentifiers );\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public RuleConditionElement build(final RuleBuildContext context,\r\n                                      final BaseDescr descr,\r\n                                      final Pattern prefixPattern) {\r\n        final FromDescr fromDescr = (FromDescr) descr;\r\n\r\n        final AccessorDescr accessor = (AccessorDescr) fromDescr.getDataSource();\r\n        DataProvider dataProvider = null;\r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( context.getDeclarationResolver().getDeclarations(),\r\n                                                                     null,\r\n                                                                     context.getPkg().getGlobals() );\r\n\r\n            // This builder is re-usable in other dialects, so specify by name\r\n            final ClassImportResolverFactory classImportResolverFactory = ((MVELDialect) context.getDialect( \"mvel\" )).getClassImportResolverFactory();\r\n            factory.setNextFactory( classImportResolverFactory );\r\n\r\n            //parser.setValueHandlerFactory( factory );\r\n            final Serializable compiled = MVEL.compileExpression( accessor.toString(),\r\n                                                                  classImportResolverFactory.getImportedClasses() );\r\n\r\n            dataProvider = new MVELDataProvider( compiled,\r\n                                                 factory );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    fromDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'from' node '\" + accessor + \"'\" ) );\r\n            return null;\r\n        }\r\n\r\n        return new From( dataProvider );\r\n    }","id":67726,"modified_method":"public RuleConditionElement build(final RuleBuildContext context,\r\n                                      final BaseDescr descr,\r\n                                      final Pattern prefixPattern) {\r\n        final FromDescr fromDescr = (FromDescr) descr;\r\n\r\n        final AccessorDescr accessor = (AccessorDescr) fromDescr.getDataSource();\r\n        DataProvider dataProvider = null;\r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( context.getDeclarationResolver().getDeclarations(),\r\n                                                                     null,\r\n                                                                     context.getPkg().getGlobals() );\r\n\r\n            // This builder is re-usable in other dialects, so specify by name\r\n            MVELDialect dialect = (MVELDialect) context.getDialect( \"mvel\" );\r\n\r\n            final ClassImportResolverFactory classImportResolverFactory = dialect.getClassImportResolverFactory();\r\n            factory.setNextFactory( classImportResolverFactory );\r\n\r\n            String text = (String) accessor.toString();\r\n            Dialect.AnalysisResult analysis = dialect.analyzeExpression( context,\r\n                                                                         descr,\r\n                                                                         text );\r\n\r\n            final Serializable expr = dialect.compile( text,\r\n                                                       analysis,\r\n                                                       context );\r\n\r\n            dataProvider = new MVELDataProvider( expr,\r\n                                                 factory );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    fromDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'from' node '\" + accessor + \"'\" ) );\r\n            return null;\r\n        }\r\n\r\n        return new From( dataProvider );\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final PredicateConstraint predicate,\r\n                      final PredicateDescr predicateDescr) {\r\n        Map previousMap = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            previousMap.put( previousDeclarations[i].getIdentifier(),\r\n                             previousDeclarations[i] );\r\n        }\r\n\r\n        Map localMap = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            localMap.put( localDeclarations[i].getIdentifier(),\r\n                          localDeclarations[i] );\r\n        }\r\n        \r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( previousMap,\r\n                                                                     localMap,\r\n                                                                     context.getPkg().getGlobals() );\r\n            factory.setNextFactory( ((MVELDialect) context.getDialect()).getClassImportResolverFactory() );\r\n\r\n            final Serializable expr = MVEL.compileExpression( (String) predicateDescr.getContent(),\r\n                                                              ((MVELDialect) context.getDialect()).getClassImportResolverFactory().getImportedClasses() );\r\n            predicate.setPredicateExpression( new MVELPredicateExpression( expr,\r\n                                                                           factory ) );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    predicateDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'predicate' node '\" + predicateDescr.getContent() + \"'\" ) );\r\n        }\r\n    }","id":67727,"modified_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final PredicateConstraint predicate,\r\n                      final PredicateDescr predicateDescr) {\r\n        Map previousMap = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            previousMap.put( previousDeclarations[i].getIdentifier(),\r\n                             previousDeclarations[i] );\r\n        }\r\n\r\n        Map localMap = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            localMap.put( localDeclarations[i].getIdentifier(),\r\n                          localDeclarations[i] );\r\n        }\r\n        \r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( previousMap,\r\n                                                                     localMap,\r\n                                                                     context.getPkg().getGlobals() );\r\n            factory.setNextFactory( ((MVELDialect) context.getDialect()).getClassImportResolverFactory() );\r\n            \r\n            final ParserContext parserContext = new ParserContext(((MVELDialect) context.getDialect()).getClassImportResolverFactory().getImportedClasses(), null, null);\r\n            parserContext.setStrictTypeEnforcement( true );           \r\n            \r\n            Dialect.AnalysisResult analysis = context.getDialect().analyzeExpression( context,\r\n                                                                                      predicateDescr,\r\n                                                                                      predicateDescr.getContent() );\r\n            \r\n            final Serializable expr = ((MVELDialect) context.getDialect()).compile( (String) predicateDescr.getContent(), analysis, context );            \r\n            \r\n            predicate.setPredicateExpression( new MVELPredicateExpression( expr,\r\n                                                                           factory ) );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    predicateDescr,\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'predicate' node '\" + predicateDescr.getContent() + \"'\" ) );\r\n        }\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testSimpleExpression() {\r\n        final Package pkg = new Package( \"pkg1\" );\r\n        final RuleDescr ruleDescr = new RuleDescr( \"rule 1\" );\r\n\r\n        MVELDialect mvelDialect = new MVELDialect( new PackageBuilder( pkg ) );\r\n        DialectRegistry registry = new DialectRegistry();\r\n        registry.addDialect( \"default\",\r\n                             mvelDialect );\r\n        final PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n\r\n        final InstrumentedBuildContent context = new InstrumentedBuildContent( conf,\r\n                                                                               pkg,\r\n                                                                               ruleDescr,\r\n                                                                               registry,\r\n                                                                               mvelDialect );\r\n        \r\n        final InstrumentedDeclarationScopeResolver declarationResolver = new InstrumentedDeclarationScopeResolver();\r\n        final FieldExtractor extractor = ClassFieldExtractorCache.getExtractor( Cheese.class, \"price\",\r\n                                                                                getClass().getClassLoader() );\r\n        \r\n        final Pattern patternA = new Pattern( 0,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Pattern patternB = new Pattern( 1,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Declaration a = new Declaration( \"a\",\r\n                                               extractor,\r\n                                               patternA );\r\n        final Declaration b = new Declaration( \"b\",\r\n                                               extractor,\r\n                                               patternB );\r\n\r\n        final Map map = new HashMap();\r\n        map.put( \"a\",\r\n                 a );\r\n        map.put( \"b\",\r\n                 b );\r\n        declarationResolver.setDeclarations( map );\r\n        context.setDeclarationResolver( declarationResolver );\r\n\r\n        final PredicateDescr predicateDescr = new PredicateDescr();\r\n        predicateDescr.setContent( \"a == b\" );\r\n\r\n        final MVELPredicateBuilder builder = new MVELPredicateBuilder();\r\n\r\n        final List[] usedIdentifiers = new ArrayList[2];\r\n        final List list = new ArrayList();\r\n        usedIdentifiers[1] = list;\r\n\r\n        final Declaration[] previousDeclarations = new Declaration[]{a};\r\n        final Declaration[] localDeclarations = new Declaration[]{b};\r\n\r\n        final PredicateConstraint predicate = new PredicateConstraint( null,\r\n                                                                       localDeclarations );\r\n\r\n        builder.build( context,\r\n                       usedIdentifiers,\r\n                       previousDeclarations,\r\n                       localDeclarations,\r\n                       predicate,\r\n                       predicateDescr );\r\n\r\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory wm = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final Cheese stilton = new Cheese( \"stilton\",\r\n                                           10 );\r\n\r\n        final Cheese cheddar = new Cheese( \"cheddar\",\r\n                                           10 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) wm.insert( cheddar );\r\n        final ReteTuple tuple = new ReteTuple( f0 );\r\n\r\n        final PredicateContextEntry predicateContext = new PredicateContextEntry();\r\n        predicateContext.leftTuple = tuple;\r\n\r\n        assertTrue( predicate.isAllowedCachedLeft( predicateContext,\r\n                                                   stilton ) );\r\n\r\n        cheddar.setPrice( 9 );\r\n        wm.update( f0,\r\n                         cheddar );\r\n\r\n        assertFalse( predicate.isAllowedCachedLeft( predicateContext,\r\n                                                    stilton ) );\r\n    }","id":67728,"modified_method":"public void testSimpleExpression() {\r\n        final Package pkg = new Package( \"pkg1\" );\r\n        final RuleDescr ruleDescr = new RuleDescr( \"rule 1\" );\r\n\r\n        MVELDialect mvelDialect = new MVELDialect( new PackageBuilder( pkg ) );\r\n        DialectRegistry registry = new DialectRegistry();\r\n        registry.addDialect( \"mvel\",\r\n                             mvelDialect );\r\n        final PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n\r\n        final InstrumentedBuildContent context = new InstrumentedBuildContent( conf,\r\n                                                                               pkg,\r\n                                                                               ruleDescr,\r\n                                                                               registry,\r\n                                                                               mvelDialect );\r\n        \r\n        final InstrumentedDeclarationScopeResolver declarationResolver = new InstrumentedDeclarationScopeResolver();\r\n        final FieldExtractor extractor = ClassFieldExtractorCache.getExtractor( Cheese.class, \"price\",\r\n                                                                                getClass().getClassLoader() );\r\n        \r\n        final Pattern patternA = new Pattern( 0,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Pattern patternB = new Pattern( 1,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Declaration a = new Declaration( \"a\",\r\n                                               extractor,\r\n                                               patternA );\r\n        final Declaration b = new Declaration( \"b\",\r\n                                               extractor,\r\n                                               patternB );\r\n\r\n        final Map map = new HashMap();\r\n        map.put( \"a\",\r\n                 a );\r\n        map.put( \"b\",\r\n                 b );\r\n        declarationResolver.setDeclarations( map );\r\n        context.setDeclarationResolver( declarationResolver );\r\n\r\n        final PredicateDescr predicateDescr = new PredicateDescr();\r\n        predicateDescr.setContent( \"a == b\" );\r\n\r\n        final MVELPredicateBuilder builder = new MVELPredicateBuilder();\r\n\r\n        final List[] usedIdentifiers = new ArrayList[2];\r\n        final List list = new ArrayList();\r\n        usedIdentifiers[1] = list;\r\n\r\n        final Declaration[] previousDeclarations = new Declaration[]{a};\r\n        final Declaration[] localDeclarations = new Declaration[]{b};\r\n\r\n        final PredicateConstraint predicate = new PredicateConstraint( null,\r\n                                                                       localDeclarations );\r\n\r\n        builder.build( context,\r\n                       usedIdentifiers,\r\n                       previousDeclarations,\r\n                       localDeclarations,\r\n                       predicate,\r\n                       predicateDescr );\r\n\r\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory wm = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final Cheese stilton = new Cheese( \"stilton\",\r\n                                           10 );\r\n\r\n        final Cheese cheddar = new Cheese( \"cheddar\",\r\n                                           10 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) wm.insert( cheddar );\r\n        final ReteTuple tuple = new ReteTuple( f0 );\r\n\r\n        final PredicateContextEntry predicateContext = new PredicateContextEntry();\r\n        predicateContext.leftTuple = tuple;\r\n\r\n        assertTrue( predicate.isAllowedCachedLeft( predicateContext,\r\n                                                   stilton ) );\r\n\r\n        cheddar.setPrice( 9 );\r\n        wm.update( f0,\r\n                         cheddar );\r\n\r\n        assertFalse( predicate.isAllowedCachedLeft( predicateContext,\r\n                                                    stilton ) );\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final ReturnValueRestriction returnValueRestriction,\r\n                      final ReturnValueRestrictionDescr returnValueRestrictionDescr) {\r\n\r\n        Map previousMap = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            previousMap.put( previousDeclarations[i].getIdentifier(),\r\n                     previousDeclarations[i] );\r\n        }\r\n\r\n        Map localMap = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            localMap.put( localDeclarations[i].getIdentifier(),\r\n                     localDeclarations[i] );\r\n        }             \r\n        \r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(previousMap, localMap,  context.getPkg().getGlobals() );\r\n        factory.setNextFactory( ((MVELDialect)context.getDialect()).getClassImportResolverFactory() );\r\n\r\n        final Serializable expr = MVEL.compileExpression( (String) returnValueRestrictionDescr.getContent(), ((MVELDialect)context.getDialect()).getClassImportResolverFactory().getImportedClasses() );\r\n        returnValueRestriction.setReturnValueExpression( new MVELReturnValueExpression( expr,\r\n                                                                                        factory ) );\r\n    }","id":67729,"modified_method":"public void build(final RuleBuildContext context,\r\n                      final List[] usedIdentifiers,\r\n                      final Declaration[] previousDeclarations,\r\n                      final Declaration[] localDeclarations,\r\n                      final ReturnValueRestriction returnValueRestriction,\r\n                      final ReturnValueRestrictionDescr returnValueRestrictionDescr) {\r\n\r\n        Map previousMap = new HashMap();\r\n        for ( int i = 0, length = previousDeclarations.length; i < length; i++ ) {\r\n            previousMap.put( previousDeclarations[i].getIdentifier(),\r\n                     previousDeclarations[i] );\r\n        }\r\n\r\n        Map localMap = new HashMap();\r\n        for ( int i = 0, length = localDeclarations.length; i < length; i++ ) {\r\n            localMap.put( localDeclarations[i].getIdentifier(),\r\n                     localDeclarations[i] );\r\n        }             \r\n        \r\n        final DroolsMVELFactory factory = new DroolsMVELFactory(previousMap, localMap,  context.getPkg().getGlobals() );\r\n        factory.setNextFactory( ((MVELDialect)context.getDialect()).getClassImportResolverFactory() );\r\n\r\n        final ParserContext parserContext = new ParserContext(((MVELDialect) context.getDialect()).getClassImportResolverFactory().getImportedClasses(), null, null);\r\n        parserContext.setStrictTypeEnforcement( true );\r\n        \r\n//        ExpressionCompiler compiler = new ExpressionCompiler( (String) returnValueRestrictionDescr.getContent() );\r\n//        final Serializable expr = compiler.compile( parserContext );\r\n        \r\n        Dialect.AnalysisResult analysis = context.getDialect().analyzeExpression( context,\r\n                                                                                  returnValueRestrictionDescr,\r\n                                                                                  returnValueRestrictionDescr.getContent() );\r\n        \r\n        final Serializable expr = ((MVELDialect) context.getDialect()).compile( (String) returnValueRestrictionDescr.getContent(), analysis, context );        \r\n        \r\n        returnValueRestriction.setReturnValueExpression( new MVELReturnValueExpression( expr,\r\n                                                                                        factory ) );\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void testSimpleExpression() {\r\n        final Package pkg = new Package( \"pkg1\" );\r\n        final RuleDescr ruleDescr = new RuleDescr( \"rule 1\" );\r\n\r\n        MVELDialect mvelDialect = new MVELDialect( new PackageBuilder( pkg ) );\r\n        DialectRegistry registry = new DialectRegistry();\r\n        registry.addDialect( \"default\",\r\n                             mvelDialect );\r\n        final PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n\r\n        final InstrumentedBuildContent context = new InstrumentedBuildContent( conf,\r\n                                                                               pkg,\r\n                                                                               ruleDescr,\r\n                                                                               registry,\r\n                                                                               mvelDialect );\r\n        \r\n        final InstrumentedDeclarationScopeResolver declarationResolver = new InstrumentedDeclarationScopeResolver();\r\n        final FieldExtractor extractor = ClassFieldExtractorCache.getExtractor( Cheese.class, \"price\",\r\n                                                                                getClass().getClassLoader() );\r\n        \r\n        final Pattern patternA = new Pattern( 0,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Pattern patternB = new Pattern( 1,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Declaration a = new Declaration( \"a\",\r\n                                               extractor,\r\n                                               patternA );\r\n        final Declaration b = new Declaration( \"b\",\r\n                                               extractor,\r\n                                               patternB );\r\n\r\n        final Map map = new HashMap();\r\n        map.put( \"a\",\r\n                 a );\r\n        map.put( \"b\",\r\n                 b );\r\n        declarationResolver.setDeclarations( map );\r\n        context.setDeclarationResolver( declarationResolver );\r\n\r\n        final ReturnValueRestrictionDescr returnValueDescr = new ReturnValueRestrictionDescr( \"=\" );\r\n        returnValueDescr.setContent( \"a + b\" );\r\n\r\n        final MVELReturnValueBuilder builder = new MVELReturnValueBuilder();\r\n\r\n        final List[] usedIdentifiers = new ArrayList[2];\r\n        final List list = new ArrayList();\r\n        usedIdentifiers[1] = list;\r\n\r\n        final Declaration[] previousDeclarations = new Declaration[]{a, b};\r\n        final Declaration[] localDeclarations = new Declaration[]{};\r\n        final String[] requiredGlobals = new String[]{};\r\n\r\n        final ReturnValueRestriction returnValue = new ReturnValueRestriction( extractor,\r\n                                                                               previousDeclarations,\r\n                                                                               localDeclarations,\r\n                                                                               requiredGlobals,\r\n                                                                               ValueType.PINTEGER_TYPE.getEvaluator( Operator.EQUAL ) );\r\n\r\n        builder.build( context,\r\n                       usedIdentifiers,\r\n                       previousDeclarations,\r\n                       localDeclarations,\r\n                       returnValue,\r\n                       returnValueDescr );\r\n\r\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory wm = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final Cheese stilton = new Cheese( \"stilton\",\r\n                                           10 );\r\n\r\n        final Cheese cheddar = new Cheese( \"cheddar\",\r\n                                           10 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) wm.insert( cheddar );\r\n        ReteTuple tuple = new ReteTuple( f0 );\r\n\r\n        final InternalFactHandle f1 = (InternalFactHandle) wm.insert( stilton );\r\n        tuple = new ReteTuple( tuple,\r\n                               f1 );\r\n\r\n        final PredicateContextEntry predicateContext = new PredicateContextEntry();\r\n        predicateContext.leftTuple = tuple;\r\n\r\n        final Cheese brie = new Cheese( \"brie\",\r\n                                        20 );\r\n        assertTrue( returnValue.isAllowed( extractor,\r\n                                           brie,\r\n                                           tuple,\r\n                                           wm ) );\r\n\r\n        brie.setPrice( 18 );\r\n        assertFalse( returnValue.isAllowed( extractor,\r\n                                            brie,\r\n                                            tuple,\r\n                                            wm ) );\r\n    }","id":67730,"modified_method":"public void testSimpleExpression() {\r\n        final Package pkg = new Package( \"pkg1\" );\r\n        final RuleDescr ruleDescr = new RuleDescr( \"rule 1\" );\r\n\r\n        MVELDialect mvelDialect = new MVELDialect( new PackageBuilder( pkg ) );\r\n        DialectRegistry registry = new DialectRegistry();\r\n        registry.addDialect( \"mvel\",\r\n                             mvelDialect );\r\n        final PackageBuilderConfiguration conf = new PackageBuilderConfiguration();\r\n\r\n        final InstrumentedBuildContent context = new InstrumentedBuildContent( conf,\r\n                                                                               pkg,\r\n                                                                               ruleDescr,\r\n                                                                               registry,\r\n                                                                               mvelDialect );\r\n        \r\n        final InstrumentedDeclarationScopeResolver declarationResolver = new InstrumentedDeclarationScopeResolver();\r\n        final FieldExtractor extractor = ClassFieldExtractorCache.getExtractor( Cheese.class, \"price\",\r\n                                                                                getClass().getClassLoader() );\r\n        \r\n        final Pattern patternA = new Pattern( 0,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Pattern patternB = new Pattern( 1,\r\n                                              new ClassObjectType( int.class ) );\r\n\r\n        final Declaration a = new Declaration( \"a\",\r\n                                               extractor,\r\n                                               patternA );\r\n        final Declaration b = new Declaration( \"b\",\r\n                                               extractor,\r\n                                               patternB );\r\n\r\n        final Map map = new HashMap();\r\n        map.put( \"a\",\r\n                 a );\r\n        map.put( \"b\",\r\n                 b );\r\n        declarationResolver.setDeclarations( map );\r\n        context.setDeclarationResolver( declarationResolver );\r\n\r\n        final ReturnValueRestrictionDescr returnValueDescr = new ReturnValueRestrictionDescr( \"=\" );\r\n        returnValueDescr.setContent( \"a + b\" );\r\n\r\n        final MVELReturnValueBuilder builder = new MVELReturnValueBuilder();\r\n\r\n        final List[] usedIdentifiers = new ArrayList[2];\r\n        final List list = new ArrayList();\r\n        usedIdentifiers[1] = list;\r\n\r\n        final Declaration[] previousDeclarations = new Declaration[]{a, b};\r\n        final Declaration[] localDeclarations = new Declaration[]{};\r\n        final String[] requiredGlobals = new String[]{};\r\n\r\n        final ReturnValueRestriction returnValue = new ReturnValueRestriction( extractor,\r\n                                                                               previousDeclarations,\r\n                                                                               localDeclarations,\r\n                                                                               requiredGlobals,\r\n                                                                               ValueType.PINTEGER_TYPE.getEvaluator( Operator.EQUAL ) );\r\n\r\n        builder.build( context,\r\n                       usedIdentifiers,\r\n                       previousDeclarations,\r\n                       localDeclarations,\r\n                       returnValue,\r\n                       returnValueDescr );\r\n\r\n        final RuleBase ruleBase = RuleBaseFactory.newRuleBase();\r\n        final InternalWorkingMemory wm = (InternalWorkingMemory) ruleBase.newStatefulSession();\r\n\r\n        final Cheese stilton = new Cheese( \"stilton\",\r\n                                           10 );\r\n\r\n        final Cheese cheddar = new Cheese( \"cheddar\",\r\n                                           10 );\r\n        final InternalFactHandle f0 = (InternalFactHandle) wm.insert( cheddar );\r\n        ReteTuple tuple = new ReteTuple( f0 );\r\n\r\n        final InternalFactHandle f1 = (InternalFactHandle) wm.insert( stilton );\r\n        tuple = new ReteTuple( tuple,\r\n                               f1 );\r\n\r\n        final Cheese brie = new Cheese( \"brie\",\r\n                                        20 );\r\n        assertTrue( returnValue.isAllowed( extractor,\r\n                                           brie,\r\n                                           tuple,\r\n                                           wm ) );\r\n\r\n        brie.setPrice( 18 );\r\n        assertFalse( returnValue.isAllowed( extractor,\r\n                                            brie,\r\n                                            tuple,\r\n                                            wm ) );\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public void build(RuleBuildContext context) {\r\n        // pushing consequence LHS into the stack for variable resolution\r\n        context.getBuildStack().push( context.getRule().getLhs() );\r\n\r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( context.getDeclarationResolver().getDeclarations(),\r\n                                                                     null,\r\n                                                                     context.getPkg().getGlobals() );\r\n            // This builder is re-usable in other dialects, so specify by name\r\n            final ClassImportResolverFactory classImportResolverFactory = ((MVELDialect) context.getDialect( \"mvel\" )).getClassImportResolverFactory();\r\n            factory.setNextFactory( classImportResolverFactory );\r\n\r\n            final Serializable expr = MVEL.compileExpression( (String) context.getRuleDescr().getSalience(),\r\n                                                              classImportResolverFactory.getImportedClasses() );\r\n\r\n            MVELSalienceExpression salience = new MVELSalienceExpression( expr,\r\n                                                                          factory );\r\n\r\n            context.getRule().setSalience( salience );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    context.getRuleDescr(),\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'salience' node '\" + context.getRuleDescr().getSalience() + \"'\" ) );\r\n        }\r\n    }","id":67731,"modified_method":"public void build(RuleBuildContext context) {\r\n        // pushing consequence LHS into the stack for variable resolution\r\n        context.getBuildStack().push( context.getRule().getLhs() );\r\n\r\n        try {\r\n            final DroolsMVELFactory factory = new DroolsMVELFactory( context.getDeclarationResolver().getDeclarations(),\r\n                                                                     null,\r\n                                                                     context.getPkg().getGlobals() );\r\n            MVELDialect dialect = (MVELDialect) context.getDialect( \"mvel\" );\r\n            // This builder is re-usable in other dialects, so specify by name\r\n            final ClassImportResolverFactory classImportResolverFactory = dialect.getClassImportResolverFactory();\r\n            factory.setNextFactory( classImportResolverFactory );\r\n\r\n            Dialect.AnalysisResult analysis = dialect.analyzeExpression( context,\r\n                                                                         context.getRuleDescr(),\r\n                                                                         (String) context.getRuleDescr().getSalience() );\r\n\r\n            final Serializable expr = dialect.compile( (String) context.getRuleDescr().getSalience(),\r\n                                                                                    analysis,\r\n                                                                                    context );\r\n\r\n            MVELSalienceExpression salience = new MVELSalienceExpression( expr,\r\n                                                                          factory );\r\n\r\n            context.getRule().setSalience( salience );\r\n        } catch ( final Exception e ) {\r\n            context.getErrors().add( new RuleError( context.getRule(),\r\n                                                    context.getRuleDescr(),\r\n                                                    null,\r\n                                                    \"Unable to build expression for 'salience' node '\" + context.getRuleDescr().getSalience() + \"'\" ) );\r\n        }\r\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"private void rewriteToEval(final RuleBuildContext context,\n                               final Pattern pattern,\n                               final FieldConstraintDescr fieldConstraintDescr,\n                               final AbstractCompositeConstraint container) {\n        // it is a complex expression, so we need to turn it into an MVEL predicate\n        Dialect dialect = context.getDialect();\n        // switch to MVEL dialect\n        context.setDialect( context.getDialect( \"mvel\" ) );\n\n        PredicateDescr predicateDescr = new PredicateDescr();\n        DrlDumper dumper = new DrlDumper();\n        dumper.visitFieldConstraintDescr( fieldConstraintDescr );\n        predicateDescr.setContent( dumper.getTemplate() );\n\n        this.build( context,\n                    pattern,\n                    predicateDescr,\n                    container );\n\n        // fall back to original dialect\n        context.setDialect( dialect );\n    }","id":67732,"modified_method":"private void rewriteToEval(final RuleBuildContext context,\n                               final Pattern pattern,\n                               final FieldConstraintDescr fieldConstraintDescr,\n                               final AbstractCompositeConstraint container) {\n        // it is a complex expression, so we need to turn it into an MVEL predicate\n        Dialect dialect = context.getDialect();\n        // switch to MVEL dialect\n        context.setDialect( context.getDialect( \"mvel\" ) );\n\n        PredicateDescr predicateDescr = new PredicateDescr();\n        DrlDumper dumper = new DrlDumper();\n        dumper.visitFieldConstraintDescr( fieldConstraintDescr );\n        predicateDescr.setContent( dumper.getTemplate() );\n\n        build( context,\n               pattern,\n               predicateDescr,\n               container );\n\n        // fall back to original dialect\n        context.setDialect( dialect );\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"/**\n     * @param context\n     * @param utils\n     * @param pattern\n     * @param usedIdentifiers\n     * @param NOT_BOUND_INDEX\n     * @param factDeclarations\n     */\n    private void createImplicitBindings(final RuleBuildContext context,\n                                        final Pattern pattern,\n                                        final List unboundIdentifiers,\n                                        final List factDeclarations) {\n        // the following will create the implicit bindings\n        for ( int i = 0, size = unboundIdentifiers.size(); i < size; i++ ) {\n            final String identifier = (String) unboundIdentifiers.get( i );\n\n            Declaration declaration = this.createDeclarationObject( context,\n                                                                    identifier,\n                                                                    pattern );\n\n            if ( declaration != null ) {\n                factDeclarations.add( declaration );\n            }\n        }\n    }","id":67733,"modified_method":"/**\n     * @param context\n     * @param utils\n     * @param pattern\n     * @param usedIdentifiers\n     * @param NOT_BOUND_INDEX\n     * @param factDeclarations\n     */\n    private void createImplicitBindings(final RuleBuildContext context,\n                                        final Pattern pattern,\n                                        final List unboundIdentifiers,\n                                        final List factDeclarations) {\n        // the following will create the implicit bindings\n        for ( int i = 0, size = unboundIdentifiers.size(); i < size; i++ ) {\n            final String identifier = (String) unboundIdentifiers.get( i );\n\n            Declaration declaration = createDeclarationObject( context,\n                                                               identifier,\n                                                               pattern );\n\n            if ( declaration != null ) {\n                factDeclarations.add( declaration );\n            }\n        }\n    }","commit_id":"5f05ec50b3c8d93016e96bfdf97b44feff48521e","url":"https://github.com/droolsjbpm/drools"},{"original_method":"public Expression parseExpression(XelContext ctx, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\tfinal List frags = ExpressionFragment.parse(expression);\n\t\tfinal Object[] fs = new Object[frags.size()];\n\t\tint j = 0;\n\t\tfor (Iterator it = frags.iterator(); it.hasNext();) {\n\t\t\tfinal Object o = it.next();\n\t\t\tfs[j++] = o instanceof ExpressionFragment ?\n\t\t\t\t\tMVEL.compileExpression(((ExpressionFragment)o).getExpression()):\n\t\t\t\t\to;\n\t\t}\n\t\treturn new MVELXelExpression(fs, expectedType);\n\t}","id":67734,"modified_method":"public Expression parseExpression(XelContext ctx, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\tfinal ParserContext pctx = getParserContext(ctx);\n\t\tfinal List frags = ExpressionFragment.parse(expression);\n\t\tfinal Object[] fs = new Object[frags.size()];\n\t\tint j = 0;\n\t\tfor (Iterator it = frags.iterator(); it.hasNext(); ++j) {\n\t\t\tfinal Object o = it.next();\n\t\t\tif (o instanceof ExpressionFragment) {\n\t\t\t\tfs[j] = compile(((ExpressionFragment)o).getExpression(), pctx);\n\t\t\t} else {\n\t\t\t\tfs[j] = o;\n\t\t\t}\n\t\t}\n\t\treturn new MVELXelExpression(fs, expectedType);\n\t}","commit_id":"564c5b3141f3de24466285fec7d58079ef9b480e","url":"https://github.com/zkoss/zk"},{"original_method":"public Object evaluate(XelContext ctx, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\tfinal XelMVELResolver resolver =\n\t\t\tnew XelMVELResolver(ctx.getVariableResolver());\n\n\t\tfinal List frags = ExpressionFragment.parse(expression);\n\t\tif (frags.size() == 1) { //optimize this most common case\n\t\t\tfinal Object o = frags.get(0);\n\t\t\treturn Classes.coerce(expectedType,\n\t\t\t\to instanceof String ? o:\n\t\t\t\t\tMVEL.eval(((ExpressionFragment)o).getExpression(), resolver));\n\t\t}\n\n\t\tfinal StringBuffer sb = new StringBuffer(256);\n\t\tfor (Iterator it = frags.iterator(); it.hasNext();) {\n\t\t\tfinal Object o = it.next();\n\t\t\tif (o instanceof String) {\n\t\t\t\tsb.append(o);\n\t\t\t} else {\n\t\t\t\tObject val = MVEL.eval(((ExpressionFragment)o).getExpression(), resolver);\n\t\t\t\tif (val != null)\n\t\t\t\t\tsb.append(val);\n\t\t\t}\t\n\t\t}\n\t\treturn Classes.coerce(expectedType, sb.toString());\n\t}","id":67735,"modified_method":"public Object evaluate(XelContext ctx, String expression,\n\tClass expectedType)\n\tthrows XelException {\n\t\tfinal XelMVELResolver resolver =\n\t\t\tnew XelMVELResolver(ctx.getVariableResolver());\n\n\t\tfinal ParserContext pctx = getParserContext(ctx);\n\n\t\tfinal List frags = ExpressionFragment.parse(expression);\n\t\tif (frags.size() == 1) { //optimize this most common case\n\t\t\tfinal Object o = frags.get(0);\n\t\t\treturn Classes.coerce(expectedType,\n\t\t\t\to instanceof String ? o:\n\t\t\t\t\teval(((ExpressionFragment)o).getExpression(), resolver, pctx));\n\t\t}\n\n\t\tfinal StringBuffer sb = new StringBuffer(256);\n\t\tfor (Iterator it = frags.iterator(); it.hasNext();) {\n\t\t\tfinal Object o = it.next();\n\t\t\tif (o instanceof String) {\n\t\t\t\tsb.append(o);\n\t\t\t} else {\n\t\t\t\tObject val = eval(((ExpressionFragment)o).getExpression(), resolver, pctx);\n\t\t\t\tif (val != null)\n\t\t\t\t\tsb.append(val);\n\t\t\t}\t\n\t\t}\n\t\treturn Classes.coerce(expectedType, sb.toString());\n\t}","commit_id":"564c5b3141f3de24466285fec7d58079ef9b480e","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Reads a property list (key and element pairs) from the input stream,\n\t * by specifying the charset.\n\t * <p>Like java.util.Properties, it translates \\\\u, \\n, \\r, \\t and \\f.\n\t * However, it enhanced Properties as follows.\n\t *\n\t * <ul>\n\t *  <li>It accepts any charset, not just 8859-1.<\/li>\n\t *  <li>It uses a different syntax to let value spread over multiple\n\t *  lines, descrubed below.<\/li>\n\t *  <li>Whitespace is trimmed around '=' and at the beginning of\n\t * the key and the ending of the value.<\/li>\n\t *  <li>Illegal lines are ignored (Properties.load considers it\n\t * as a key with an empty value).<\/li>\n\t *  <li>Only '=' is accepted as the separator of key and value.<\/li>\n\t *  <li>Only '#' is accepted as comment lines.<\/li>\n\t * <\/ul>\n\t *\n\t * <p>To spead a value over multiple lines, you could,\n\t * unlike java.util.Properties.load, append '{' to the end of a line.\n\t * Then, all the following lines are considerred as part of a value,\n\t * unless encountering a line containing only one '}'.<br>\n\t * Example:\n\t * <pre><code>abc = {\n\t *line 1\n\t *line 2\n\t *}\n\t *xyz = {\n\t *line 1\n\t *line 2\n\t *}<\/code><\/pre>\n\t *\n\t * <p>Moreover, you could prefix a group of keys with certain prefix:\n\t * <pre><code>org.zkoss.some. {\n\t * a = aaa\n\t * b = bbb\n\t *}<\/code><\/pre>\n\t *\n\t * It actually defines two keys: \"org.zkoss.some.a\" and \"org.zkoss.some.b\".\n\t *\n\t * <p>Note: (1) whitespace in the {...} block are all preserved.<br>\n\t * (2) if only whitespaces is between '=' and '{', they are ignored.\n\t *\n\t * @param charset the charset; if null, it detects UTF-16 BOM (0xfe 0xff\n\t * or 0xff 0xfe). If no UTF-16 BOM, UTF-8 is always assumed.\n\t * Note 1: UTF-8's BOM (0xef 0xbb 0xbf) is optional, so we don't count on it.\n\t * Note 2: ISO-8859-1 is not used because we cannot tell its difference\n\t * from UTF-8 (while some of our properties files are in UTF-8).\n\t *\n\t * @param caseInsensitive whether the key used to access the map\n\t * is case-insensitive. If true, all keys are converted to lower cases.\n\t */\n\tpublic final static void load(Map map, InputStream sm, String charset,\n\tboolean caseInsensitive) throws IOException {\n\t\tfinal PushbackInputStream pis = new PushbackInputStream(sm, 3);\n\t\tif (charset == null || charset.startsWith(\"UTF\")) {\n\t\t\tfinal byte[] ahead = new byte[3];\n\t\t\tint n = pis.read(ahead);\n\t\t\tif (n >= 2\n\t\t\t&& ((ahead[0] == (byte)0xfe && ahead[1] == (byte)0xff)\n\t\t\t\t|| (ahead[0] == (byte)0xff && ahead[1] == (byte)0xfe))) {\n\t\t\t\tcharset = \"UTF-16\";\n\t\t\t\t//don't eat UTF-16 BOM, since Java use it to know endian\n\t\t\t} else if (n == 3 && ahead[0] == (byte)0xef\n\t\t\t&& ahead[1] == (byte)0xbb && ahead[2] == (byte)0xbf) {\n\t\t\t\tcharset = \"UTF-8\";\n\t\t\t\tn = 0; //eat UTF-8 BOM since Java won't handle it\n\t\t\t} else if (charset == null) {\n\t\t\t\tcharset = \"UTF-8\";\n\t\t\t}\n\t\t\tif (n > 0)\n\t\t\t\tpis.unread(ahead, 0, n);\n\t\t}\n\n\t\tfinal BufferedReader in =\n\t\t\tnew BufferedReader(new InputStreamReader(pis, charset));\n\n\t\tfinal List prefixes = new LinkedList();\n\t\tString prefix = null;\n\t\tString line;\n\t\tfor (int lno = 1; (line = in.readLine()) != null; ++lno) {\n\t\t\tint len = line.length();\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\n\t\t\tfinal Strings.Result res =\n\t\t\t\tStrings.nextToken(line, 0, new char[] {'=', '{', '}'}, true, false);\n\t\t\tif (res == null || res.token.startsWith(\"#\"))\n\t\t\t\tcontinue; //nothing found\n\t\t\tif (res.separator == (char)0) {\n\t\t\t\tif (res.token.length() > 0)\n\t\t\t\t\tlog.warning(\">>Igored: a key, \"+res.token+\", without value, line \"+lno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res.separator == '{') {\n\t\t\t\t//res.token.lenth() could be zero\n\t\t\t\tif (Strings.skipWhitespaces(line, res.next) < len) //non-space following '{'\n\t\t\t\t\tthrow new IllegalSyntaxException(\"Invalid nest: '{' must be the last character, line \"+lno);\n\t\t\t\tprefixes.add(new Integer(res.token.length()));\n\t\t\t\tprefix = prefix != null ? prefix + res.token: res.token;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res.separator == '}' ) {\n\t\t\t\tif (Strings.skipWhitespaces(line, res.next) < len) //non-space following '}'\n\t\t\t\t\tthrow new IllegalSyntaxException(\"Invalid nesting: '}' must be the last character, line \"+lno);\n\t\t\t\tif (prefixes.isEmpty())\n\t\t\t\t\tthrow new IllegalSyntaxException(\"Invalid nesting: '}' does have any preceding '{', line \"+lno);\n\t\t\t\tfinal Integer i = (Integer)prefixes.remove(prefixes.size() - 1); //pop\n\t\t\t\tprefix = prefixes.isEmpty() ?\n\t\t\t\t\tnull: prefix.substring(0, prefix.length() - i.intValue());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res.token.length() == 0) {\n\t\t\t\tlog.warning(\">>Ignored: wihout key, line \"+lno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tassert res.separator == '=': \"Wrong separator: \"+res.separator;\n\t\t\tfinal String val;\n\t\t\tString key = caseInsensitive ? res.token.toLowerCase(): res.token;\n\t\t\tint j = Strings.skipWhitespaces(line, res.next);\n\t\t\tint k = Strings.skipWhitespacesBackward(line, len - 1);\n\t\t\tif (j == k && line.charAt(k) == '{') { //pack multiple lines\n\t\t\t\tfinal StringBuffer sb = new StringBuffer();\n\t\t\t\tfor (int lnoFrom = lno;;) {\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\t++lno;\n\t\t\t\t\tif (line == null){\n\t\t\t\t\t\tlog.warning(\n\t\t\t\t\t\t\t\">>Ignored: invalid multiple-line format: '={' does not have following '}', \"+lnoFrom);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = line.length();\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tj = Strings.skipWhitespacesBackward(line, len - 1);\n\t\t\t\t\t\tif (j >= 0 && line.charAt(j) == '}') {\n\t\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\t\tj = 1 + Strings.skipWhitespacesBackward(line, j - 1);\n\t\t\t\t\t\t\tif (j == 0) //no non-space before }\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (sb.length() > 0)\n\t\t\t\t\t\tsb.append('\\n');\n\t\t\t\t\tsb.append(line);\n\t\t\t\t}\n\t\t\t\tval = sb.toString();\n\t\t\t} else {\n\t\t\t\tval = j <= k ? line.substring(j, k + 1): \"\";\n\t\t\t}\n\t\t\tmap.put(prefix != null ? prefix + key: key, val);\n\t\t}\n\n\t\tif (!prefixes.isEmpty())\n\t\t\tlog.warning(\">>Ignored: unclosed nesting '{': \"+prefixes.size());\n\t}","id":67736,"modified_method":"/**\n\t * Reads a property list (key and element pairs) from the input stream,\n\t * by specifying the charset.\n\t * <p>Like java.util.Properties, it translates \\\\u, \\n, \\r, \\t and \\f.\n\t * However, it enhanced Properties as follows.\n\t *\n\t * <ul>\n\t *  <li>It accepts any charset, not just 8859-1.<\/li>\n\t *  <li>It uses a different syntax to let value spread over multiple\n\t *  lines, descrubed below.<\/li>\n\t *  <li>Whitespace is trimmed around '=' and at the beginning of\n\t * the key and the ending of the value.<\/li>\n\t *  <li>Illegal lines are ignored (Properties.load considers it\n\t * as a key with an empty value).<\/li>\n\t *  <li>Only '=' is accepted as the separator of key and value.<\/li>\n\t *  <li>Only '#' is accepted as comment lines.<\/li>\n\t * <\/ul>\n\t *\n\t * <p>To spead a value over multiple lines, you could,\n\t * unlike java.util.Properties.load, append '{' to the end of a line.\n\t * Then, all the following lines are considerred as part of a value,\n\t * unless encountering a line containing only one '}'.<br>\n\t * Example:\n\t * <pre><code>abc = {\n\t *line 1\n\t *line 2\n\t *}\n\t *xyz = {\n\t *line 1\n\t *line 2\n\t *}<\/code><\/pre>\n\t *\n\t * <p>Moreover, you could prefix a group of keys with certain prefix:\n\t * <pre><code>org.zkoss.some. {\n\t * a = aaa\n\t * b = bbb\n\t *}<\/code><\/pre>\n\t *\n\t * It actually defines two keys: \"org.zkoss.some.a\" and \"org.zkoss.some.b\".\n\t *\n\t * <p>Note: (1) whitespace in the {...} block are all preserved.<br>\n\t * (2) if only whitespaces is between '=' and '{', they are ignored.\n\t *\n\t * @param charset the charset; if null, it detects UTF-16 BOM (0xfe 0xff\n\t * or 0xff 0xfe). If no UTF-16 BOM, UTF-8 is always assumed.\n\t * Note 1: UTF-8's BOM (0xef 0xbb 0xbf) is optional, so we don't count on it.\n\t * Note 2: ISO-8859-1 is not used because we cannot tell its difference\n\t * from UTF-8 (while some of our properties files are in UTF-8).\n\t *\n\t * @param caseInsensitive whether the key used to access the map\n\t * is case-insensitive. If true, all keys are converted to lower cases.\n\t */\n\tpublic final static void load(Map map, InputStream sm, String charset,\n\tboolean caseInsensitive) throws IOException {\n\t\tfinal PushbackInputStream pis = new PushbackInputStream(sm, 3);\n\t\tif (charset == null || charset.startsWith(\"UTF\")) {\n\t\t\tfinal byte[] ahead = new byte[3];\n\t\t\tint n = pis.read(ahead);\n\t\t\tif (n >= 2\n\t\t\t&& ((ahead[0] == (byte)0xfe && ahead[1] == (byte)0xff)\n\t\t\t\t|| (ahead[0] == (byte)0xff && ahead[1] == (byte)0xfe))) {\n\t\t\t\tcharset = \"UTF-16\";\n\t\t\t\t//don't eat UTF-16 BOM, since Java use it to know endian\n\t\t\t} else if (n == 3 && ahead[0] == (byte)0xef\n\t\t\t&& ahead[1] == (byte)0xbb && ahead[2] == (byte)0xbf) {\n\t\t\t\tcharset = \"UTF-8\";\n\t\t\t\tn = 0; //eat UTF-8 BOM since Java won't handle it\n\t\t\t} else if (charset == null) {\n\t\t\t\tcharset = \"UTF-8\";\n\t\t\t}\n\t\t\tif (n > 0)\n\t\t\t\tpis.unread(ahead, 0, n);\n\t\t}\n\n\t\tfinal BufferedReader in =\n\t\t\tnew BufferedReader(new InputStreamReader(pis, charset));\n\n\t\tfinal List prefixes = new LinkedList();\n\t\tString prefix = null;\n\t\tString line;\n\t\tfor (int lno = 1; (line = in.readLine()) != null; ++lno) {\n\t\t\tint len = line.length();\n\t\t\tif (len == 0)\n\t\t\t\tcontinue;\n\n\t\t\tfinal Strings.Result res =\n\t\t\t\tStrings.nextToken(line, 0, new char[] {'=', '{', '}'}, true, false);\n\t\t\tif (res == null || res.token.startsWith(\"#\"))\n\t\t\t\tcontinue; //nothing found\n\t\t\tif (res.separator == (char)0) {\n\t\t\t\tif (res.token.length() > 0)\n\t\t\t\t\tlog.warning(\">>Igored: a key, \"+res.token+\", without value, line \"+lno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res.separator == '{') {\n\t\t\t\t//res.token.lenth() could be zero\n\t\t\t\tif (Strings.skipWhitespaces(line, res.next) < len) //non-space following '{'\n\t\t\t\t\tthrow new IllegalSyntaxException(\"Invalid nest: '{' must be the last character, line \"+lno);\n\t\t\t\tprefixes.add(new Integer(res.token.length()));\n\t\t\t\tprefix = prefix != null ? prefix + res.token: res.token;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res.separator == '}' ) {\n\t\t\t\tif (Strings.skipWhitespaces(line, res.next) < len) //non-space following '}'\n\t\t\t\t\tthrow new IllegalSyntaxException(\"Invalid nesting: '}' must be the last character, line \"+lno);\n\t\t\t\tif (prefixes.isEmpty())\n\t\t\t\t\tthrow new IllegalSyntaxException(\"Invalid nesting: '}' does have any preceding '{', line \"+lno);\n\t\t\t\tfinal Integer i = (Integer)prefixes.remove(prefixes.size() - 1); //pop\n\t\t\t\tprefix = prefixes.isEmpty() ?\n\t\t\t\t\tnull: prefix.substring(0, prefix.length() - i.intValue());\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (res.token.length() == 0) {\n\t\t\t\tlog.warning(\">>Ignored: wihout key, line \"+lno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n//\t\t\tassert res.separator == '=': \"Wrong separator: \"+res.separator;\n\t\t\tfinal String val;\n\t\t\tString key = caseInsensitive ? res.token.toLowerCase(): res.token;\n\t\t\tint j = Strings.skipWhitespaces(line, res.next);\n\t\t\tint k = Strings.skipWhitespacesBackward(line, len - 1);\n\t\t\tif (j == k && line.charAt(k) == '{') { //pack multiple lines\n\t\t\t\tfinal StringBuffer sb = new StringBuffer();\n\t\t\t\tfor (int lnoFrom = lno;;) {\n\t\t\t\t\tline = in.readLine();\n\t\t\t\t\t++lno;\n\t\t\t\t\tif (line == null){\n\t\t\t\t\t\tlog.warning(\n\t\t\t\t\t\t\t\">>Ignored: invalid multiple-line format: '={' does not have following '}', \"+lnoFrom);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen = line.length();\n\t\t\t\t\tif (len > 0) {\n\t\t\t\t\t\tj = Strings.skipWhitespacesBackward(line, len - 1);\n\t\t\t\t\t\tif (j >= 0 && line.charAt(j) == '}') {\n\t\t\t\t\t\t\tif (j > 0)\n\t\t\t\t\t\t\t\tj = 1 + Strings.skipWhitespacesBackward(line, j - 1);\n\t\t\t\t\t\t\tif (j == 0) //no non-space before }\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (sb.length() > 0)\n\t\t\t\t\t\tsb.append('\\n');\n\t\t\t\t\tsb.append(line);\n\t\t\t\t}\n\t\t\t\tval = sb.toString();\n\t\t\t} else {\n\t\t\t\tval = j <= k ? line.substring(j, k + 1): \"\";\n\t\t\t}\n\t\t\tmap.put(prefix != null ? prefix + key: key, val);\n\t\t}\n\n\t\tif (!prefixes.isEmpty())\n\t\t\tlog.warning(\">>Ignored: unclosed nesting '{': \"+prefixes.size());\n\t}","commit_id":"564c5b3141f3de24466285fec7d58079ef9b480e","url":"https://github.com/zkoss/zk"},{"original_method":"/**\n\t * Parses a string into a map.\n\t *\n\t * <p>If = is omitted, whether it is considered as a key with the null\n\t * value or a value with the null key depends on\n\t * the asValue argument. If true, it is considered as a value with\n\t * the null key.\n\t *\n\t * <p>For example, if the following string is parsed with asValue=false:<br/>\n\t * a12=12,b3,c6=abc=125,x=y\n\t *\n\t * <p>Then, a map with the following content is returned:<br/>\n\t * (\"a12\", \"12\"), (\"b3\", null), (\"c6\", \"abc=125\"), (\"x\", \"y\")\n\t *\n\t * <p>Notice: only the first = after separator is meaningful,\n\t * so you don't have to escape the following =.\n\t * <p>Beside specifying the quote character, you could use back slash\n\t * quote a single character (as Java does).\n\t *\n\t * @param map the map to put parsed results to; null to create a\n\t * new hash map\n\t * @param src the string to parse\n\t * @param separator the separator, e.g., ' ' or ','.\n\t * @param quote the quote character to surrounding value, e.g.,\n\t * name = 'value'. If (char)0, no quotation is recognized.\n\t * Notice: if value is an expression, it is better to specify (char)0\n\t * because expression might contain strings.\n\t * @param asValue whether to consider the substring without = as\n\t * a value (with the null key), or as a key (with the null value)\n\t * @return the map being generated\n\t *\n\t * @exception IllegalSyntaxException if syntax errors\n\t * @see CollectionsX#parse\n\t * @see #toString(Map, char, char)\n\t * @since 2.4.0\n\t */\n\tpublic static final Map \n\tparse(Map map, String src, char separator, char quote, boolean asValue)\n\tthrows IllegalSyntaxException {\n\t\tif (separator == (char)0)\n\t\t\tthrow new IllegalArgumentException(\"Separator cannot be 0\");\n\t\tif (map == null)\n\t\t\tmap = new HashMap();\n\t\tif (src == null || src.length() == 0)\n\t\t\treturn map; //nothing to do\n\n\t\t//prepare delimiters for keys and values.\n\t\tfinal String delimValue, delimKey;\n\t\t{\tfinal StringBuffer delimsb =\n\t\t\t\tnew StringBuffer().append(separator);\n\t\t\tif (quote != (char)0)\n\t\t\t\tdelimsb.append(quote);\n\t\t\tdelimValue = delimsb.toString();\n\t\t\tdelimKey = delimsb.append('=').toString();\n\t\t}\n\n\t\t//parase\n\t\tfor (int j = 0, len = src.length();;) {\n\t\t\t//handle name\n\t\t\tToken tk = next(src, delimKey, j, true);\n\t\t\tif (D.ON && log.finerable()) log.finer(\"name: \"+tk.token+\" \"+tk.cc);\n\t\t\tj = tk.next;\n\t\t\tfinal String name = tk.token;\n\t\t\tswitch (tk.cc) {\n\t\t\tcase '=':\n\t\t\t\tif (name.length() == 0)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.UNEXPECTED_CHARACTER, tk.cc, src);\n\t\t\t\t++j; //skip =\n\t\t\t\tbreak;\n\t\t\tcase (char)0:\n\t\t\t\tassert tk.next >= len;\n\t\t\t\tif (name.length() > 0)\n\t\t\t\t\tif (asValue) map.put(null, name);\n\t\t\t\t\telse map.put(name, null);\n\t\t\t\treturn map;//done\n\t\t\tdefault:\n\t\t\t\t//If separator is ' ', tk.cc can be anything; see next()\n\t\t\t\tif ((separator != ' ' && tk.cc != separator)\n\t\t\t\t|| name.length() == 0)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.UNEXPECTED_CHARACTER, tk.cc, src);\n\n\t\t\t\tif (asValue) map.put(null, name);\n\t\t\t\telse map.put(name, null);\n\t\t\t\tif (tk.cc == separator)\n\t\t\t\t\t++j; //skip separator\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//handle value\n\t\t\ttk = next(src, delimValue, j, false);\n\t\t\tif (D.ON && log.finerable()) log.finer(\"value: \"+tk.token+\" \"+tk.cc);\n\t\t\tj = tk.next;\n\t\t\tfinal String value = tk.token;\n\t\t\tif (quote != (char)0 && tk.cc == quote) {\n\t\t\t\tif (value.length() > 0)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.UNEXPECTED_CHARACTER, tk.cc, src);\n\n\t\t\t\tfinal StringBuffer valsb = new StringBuffer(32);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (++j == len)\n\t\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.EXPECTING_CHARACTER, tk.cc, src);\n\n\t\t\t\t\tfinal char cc = src.charAt(j);\n\t\t\t\t\tif (cc == tk.cc)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tvalsb.append(cc == '\\\\' ? escape(src, ++j): cc);\n\t\t\t\t}\n\t\t\t\tmap.put(name, valsb.toString());\n\t\t\t\t++j; //skip the closing ' or \"\n\t\t\t} else {\n\t\t\t\tmap.put(name, value);\n\t\t\t}\n\n\t\t\tif (separator != ' ') {\n\t\t\t\t//If not ' ', ensure the following is a separator\n\t\t\t\tj = Strings.skipWhitespaces(src, j);\n\t\t\t\tif (j >= len)\n\t\t\t\t\treturn map;\n\t\t\t\tif (src.charAt(j) != separator)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.EXPECTING_CHARACTER, separator, src);\n\t\t\t\t++j; //skip separator\n\t\t\t}\n\t\t}\n\t}","id":67737,"modified_method":"/**\n\t * Parses a string into a map.\n\t *\n\t * <p>If = is omitted, whether it is considered as a key with the null\n\t * value or a value with the null key depends on\n\t * the asValue argument. If true, it is considered as a value with\n\t * the null key.\n\t *\n\t * <p>For example, if the following string is parsed with asValue=false:<br/>\n\t * a12=12,b3,c6=abc=125,x=y\n\t *\n\t * <p>Then, a map with the following content is returned:<br/>\n\t * (\"a12\", \"12\"), (\"b3\", null), (\"c6\", \"abc=125\"), (\"x\", \"y\")\n\t *\n\t * <p>Notice: only the first = after separator is meaningful,\n\t * so you don't have to escape the following =.\n\t * <p>Beside specifying the quote character, you could use back slash\n\t * quote a single character (as Java does).\n\t *\n\t * @param map the map to put parsed results to; null to create a\n\t * new hash map\n\t * @param src the string to parse\n\t * @param separator the separator, e.g., ' ' or ','.\n\t * @param quote the quote character to surrounding value, e.g.,\n\t * name = 'value'. If (char)0, no quotation is recognized.\n\t * Notice: if value is an expression, it is better to specify (char)0\n\t * because expression might contain strings.\n\t * @param asValue whether to consider the substring without = as\n\t * a value (with the null key), or as a key (with the null value)\n\t * @return the map being generated\n\t *\n\t * @exception IllegalSyntaxException if syntax errors\n\t * @see CollectionsX#parse\n\t * @see #toString(Map, char, char)\n\t * @since 2.4.0\n\t */\n\tpublic static final Map \n\tparse(Map map, String src, char separator, char quote, boolean asValue)\n\tthrows IllegalSyntaxException {\n\t\tif (separator == (char)0)\n\t\t\tthrow new IllegalArgumentException(\"Separator cannot be 0\");\n\t\tif (map == null)\n\t\t\tmap = new HashMap();\n\t\tif (src == null || src.length() == 0)\n\t\t\treturn map; //nothing to do\n\n\t\t//prepare delimiters for keys and values.\n\t\tfinal String delimValue, delimKey;\n\t\t{\tfinal StringBuffer delimsb =\n\t\t\t\tnew StringBuffer().append(separator);\n\t\t\tif (quote != (char)0)\n\t\t\t\tdelimsb.append(quote);\n\t\t\tdelimValue = delimsb.toString();\n\t\t\tdelimKey = delimsb.append('=').toString();\n\t\t}\n\n\t\t//parase\n\t\tfor (int j = 0, len = src.length();;) {\n\t\t\t//handle name\n\t\t\tToken tk = next(src, delimKey, j, true);\n//\t\t\tif (D.ON && log.finerable()) log.finer(\"name: \"+tk.token+\" \"+tk.cc);\n\t\t\tj = tk.next;\n\t\t\tfinal String name = tk.token;\n\t\t\tswitch (tk.cc) {\n\t\t\tcase '=':\n\t\t\t\tif (name.length() == 0)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.UNEXPECTED_CHARACTER, tk.cc, src);\n\t\t\t\t++j; //skip =\n\t\t\t\tbreak;\n\t\t\tcase (char)0:\n//\t\t\t\tassert tk.next >= len;\n\t\t\t\tif (name.length() > 0)\n\t\t\t\t\tif (asValue) map.put(null, name);\n\t\t\t\t\telse map.put(name, null);\n\t\t\t\treturn map;//done\n\t\t\tdefault:\n\t\t\t\t//If separator is ' ', tk.cc can be anything; see next()\n\t\t\t\tif ((separator != ' ' && tk.cc != separator)\n\t\t\t\t|| name.length() == 0)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.UNEXPECTED_CHARACTER, tk.cc, src);\n\n\t\t\t\tif (asValue) map.put(null, name);\n\t\t\t\telse map.put(name, null);\n\t\t\t\tif (tk.cc == separator)\n\t\t\t\t\t++j; //skip separator\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t//handle value\n\t\t\ttk = next(src, delimValue, j, false);\n//\t\t\tif (D.ON && log.finerable()) log.finer(\"value: \"+tk.token+\" \"+tk.cc);\n\t\t\tj = tk.next;\n\t\t\tfinal String value = tk.token;\n\t\t\tif (quote != (char)0 && tk.cc == quote) {\n\t\t\t\tif (value.length() > 0)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.UNEXPECTED_CHARACTER, tk.cc, src);\n\n\t\t\t\tfinal StringBuffer valsb = new StringBuffer(32);\n\t\t\t\tfor (;;) {\n\t\t\t\t\tif (++j == len)\n\t\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.EXPECTING_CHARACTER, tk.cc, src);\n\n\t\t\t\t\tfinal char cc = src.charAt(j);\n\t\t\t\t\tif (cc == tk.cc)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tvalsb.append(cc == '\\\\' ? escape(src, ++j): cc);\n\t\t\t\t}\n\t\t\t\tmap.put(name, valsb.toString());\n\t\t\t\t++j; //skip the closing ' or \"\n\t\t\t} else {\n\t\t\t\tmap.put(name, value);\n\t\t\t}\n\n\t\t\tif (separator != ' ') {\n\t\t\t\t//If not ' ', ensure the following is a separator\n\t\t\t\tj = Strings.skipWhitespaces(src, j);\n\t\t\t\tif (j >= len)\n\t\t\t\t\treturn map;\n\t\t\t\tif (src.charAt(j) != separator)\n\t\t\t\t\tthrow newIllegalSyntaxException(MCommon.EXPECTING_CHARACTER, separator, src);\n\t\t\t\t++j; //skip separator\n\t\t\t}\n\t\t}\n\t}","commit_id":"564c5b3141f3de24466285fec7d58079ef9b480e","url":"https://github.com/zkoss/zk"},{"original_method":"private void load0(String prefix, Map[] loaded) {\n\t\tif (!loaded[0].isEmpty()) {\n\t\t\tif (_mtds == null)\n\t\t\t\t_mtds = new HashMap();\n\t\t\tfor (Iterator e = loaded[0].entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\t_mtds.put(prefix + \":\" + me.getKey(), me.getValue());\n\t\t\t}\n\t\t}\n\t\tif (!loaded[1].isEmpty()) {\n\t\t\tif (_clses == null)\n\t\t\t\t_clses = new HashMap();\n\t\t\t_clses.putAll(loaded[1]);\n\t\t}\n\t}","id":67738,"modified_method":"private void load0(String prefix, Map[] loaded) {\n\t\tif (!loaded[0].isEmpty()) {\n\t\t\tif (_mtds == null)\n\t\t\t\t_mtds = new HashMap(8);\n\t\t\tfor (Iterator e = loaded[0].entrySet().iterator(); e.hasNext();) {\n\t\t\t\tfinal Map.Entry me = (Map.Entry)e.next();\n\t\t\t\taddFunction(prefix, (String)me.getKey(), (Function)me.getValue());\n\t\t\t}\n\t\t}\n\n\t\tif (!loaded[1].isEmpty()) {\n\t\t\tif (_clses == null)\n\t\t\t\t_clses = new HashMap(4);\n\t\t\t_clses.putAll(loaded[1]);\n\t\t}\n\t}","commit_id":"564c5b3141f3de24466285fec7d58079ef9b480e","url":"https://github.com/zkoss/zk"},{"original_method":"/** Retursn the function mapper representing a list of {@link Taglib},\n\t * or null if taglibs is null or empty.\n\t *\n\t * <p>The returned mapper is serializable.\n\t *\n\t * @param loc the locator used to load taglib\n\t */\n\tpublic static final\n\tFunctionMapper getFunctionMapper(List taglibs, Locator loc) {\n\t\tif (taglibs == null || taglibs.isEmpty())\n\t\t\treturn null;\n\n\t\tfinal TaglibMapper mapper = new TaglibMapper();\n\t\tfor (Iterator it = taglibs.iterator(); it.hasNext();)\n\t\t\tmapper.load((Taglib)it.next(), loc);\n\t\treturn mapper;\n\t}","id":67739,"modified_method":"/** Retursn the function mapper representing a list of {@link Taglib},\n\t * or null if nothin is loaded.\n\t *\n\t * <p>The returned mapper is serializable.\n\t *\n\t * @param taglibs a list of {@link Taglib}.\n\t * @param loc the locator used to load taglib\n\t */\n\tpublic static final\n\tFunctionMapper getFunctionMapper(List taglibs, Locator loc) {\n\t\treturn getFunctionMapper(taglibs, null, loc);\n\t}","commit_id":"564c5b3141f3de24466285fec7d58079ef9b480e","url":"https://github.com/zkoss/zk"},{"original_method":"protected MBMessage updateMessage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString permissionClassName = ParamUtil.getString(\n\t\t\tactionRequest, \"permissionClassName\");\n\t\tlong permissionClassPK = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionClassPK\");\n\t\tlong permissionOwnerId = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionOwnerId\");\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\n\t\t\t// Add message\n\n\t\t\tmessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\tserviceContext.getScopeGroupId(), className, classPK,\n\t\t\t\tpermissionClassName, permissionClassPK, permissionOwnerId,\n\t\t\t\tthreadId, parentMessageId, subject, body, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\tclassName, classPK, permissionClassName, permissionClassPK,\n\t\t\t\tpermissionOwnerId, messageId, subject, body, serviceContext);\n\t\t}\n\n\t\treturn message;\n\t}","id":67740,"modified_method":"protected MBMessage updateMessage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString permissionClassName = ParamUtil.getString(\n\t\t\tactionRequest, \"permissionClassName\");\n\t\tlong permissionClassPK = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionClassPK\");\n\t\tlong permissionOwnerId = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionOwnerId\");\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\t\tboolean subscribe = ParamUtil.getBoolean(actionRequest, \"subscribe\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\n\t\t\t// Add message\n\n\t\t\tmessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\tserviceContext.getScopeGroupId(), className, classPK,\n\t\t\t\tpermissionClassName, permissionClassPK, permissionOwnerId,\n\t\t\t\tthreadId, parentMessageId, subject, body, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\tclassName, classPK, permissionClassName, permissionClassPK,\n\t\t\t\tpermissionOwnerId, messageId, subject, body, serviceContext);\n\t\t}\n\n\t\t// Subscription\n\n\t\tif (subscribe) {\n\t\t\tSubscriptionLocalServiceUtil.addSubscription(\n\t\t\t\tthemeDisplay.getUserId(), themeDisplay.getScopeGroupId(),\n\t\t\t\tclassName, classPK);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"dcab565274834376bb8d1af4798002b76b2a2fdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":67741,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE_TO_COMMENTS)) {\n\t\t\t\tsubscribeToComments(actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE_FROM_COMMENTS)) {\n\t\t\t\tsubscribeToComments(actionRequest, false);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"dcab565274834376bb8d1af4798002b76b2a2fdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (Validator.isNull(layoutFullURL) || message.isDiscussion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tboolean update = GetterUtil.getBoolean(\n\t\t\t(String)serviceContext.getAttribute(\"update\"));\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(message.getGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tString categoryName = category.getName();\n\n\t\tif (category.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tcategoryName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\t\"message-boards-home\") + StringPool.SPACE + StringPool.DASH +\n\t\t\t\tStringPool.SPACE + group.getName();\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\n\t\tif ((message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\t\t}\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/view_message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","id":67742,"modified_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED ||\n\t\t\t\tValidator.isNull(layoutFullURL)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (message.isDiscussion()) {\n\t\t\ttry{\n\t\t\t\tsendCommentsEmail(message.getUserId(), message, serviceContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tboolean update = GetterUtil.getBoolean(\n\t\t\t(String)serviceContext.getAttribute(\"update\"));\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(message.getGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tString categoryName = category.getName();\n\n\t\tif (category.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tcategoryName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\t\"message-boards-home\") + StringPool.SPACE + StringPool.DASH +\n\t\t\t\tStringPool.SPACE + group.getName();\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\n\t\tif ((message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\t\t}\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/view_message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","commit_id":"dcab565274834376bb8d1af4798002b76b2a2fdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendBlogsCommentsEmail(\n\t\t\tlong userId, BlogsEntry entry, MBMessage message,\n\t\t\tServiceContext serviceContext)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tlong companyId = message.getCompanyId();\n\n\t\tif (!PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_ENABLED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tString blogsEntryURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR + \"blogs/\" +\n\t\t\t\tentry.getUrlTitle();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_NAME);\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_SUBJECT);\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_BODY);\n\n\t\tsubject = StringUtil.replace(\n\t\t\tsubject,\n\t\t\tnew String[] {\n\t\t\t\t\"[$BLOGS_COMMENTS_BODY$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$BLOGS_ENTRY_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tblogsEntryURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$BLOGS_COMMENTS_BODY$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$BLOGS_ENTRY_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tblogsEntryURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tList<MBMessage> messages = mbMessagePersistence.findByThreadId(\n\t\t\tmessage.getThreadId());\n\n\t\tfor (MBMessage curMessage : messages) {\n\t\t\tlong curMessageUserId = curMessage.getUserId();\n\n\t\t\tif (curMessageUserId == userId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sent.contains(curMessageUserId)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Do not send a duplicate email to user \" +\n\t\t\t\t\t\t\tcurMessageUserId);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Add user \" + curMessageUserId +\n\t\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t\t}\n\n\t\t\t\tsent.add(curMessageUserId);\n\t\t\t}\n\n\t\t\tUser curMessageUser = null;\n\n\t\t\ttry {\n\t\t\t\tcurMessageUser = userLocalService.getUserById(curMessageUserId);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!curMessageUser.isActive()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tInternetAddress from = new InternetAddress(fromAddress, fromName);\n\n\t\t\tInternetAddress to = new InternetAddress(\n\t\t\t\tcurMessageUser.getEmailAddress(), curMessageUser.getFullName());\n\n\t\t\tString curSubject = StringUtil.replace(\n\t\t\t\tsubject,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tString curBody = StringUtil.replace(\n\t\t\t\tbody,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tMailMessage mailMessage = new MailMessage(\n\t\t\t\tfrom, to, curSubject, curBody, true);\n\n\t\t\tmailService.sendEmail(mailMessage);\n\t\t}\n\t}","id":67743,"modified_method":"protected void sendCommentsEmail(\n\t\t\tlong userId, MBMessage message, ServiceContext serviceContext)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tString className =\n\t\t\t(String)serviceContext.getAttribute(\"className\");\n\t\tlong classPK =\n\t\t\tGetterUtil.getLong((String)serviceContext.getAttribute(\"classPK\"));\n\n\t\tlong companyId = message.getCompanyId();\n\n\t\tString contentURL =\n\t\t\tserviceContext.getPortalURL().concat(\n\t\t\t\tserviceContext.getCurrentURL());\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_NAME);\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.DISCUSSION_EMAIL_SUBJECT);\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.DISCUSSION_EMAIL_BODY);\n\n\t\tsubject = StringUtil.replace(\n\t\t\tsubject,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMMENTS_BODY$]\",\n\t\t\t\t\"[$COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$CONTENT_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tcontentURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMMENTS_BODY$]\",\n\t\t\t\t\"[$COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$ASSET_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tcontentURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tList<Subscription> subscriptions =\n\t\t\tSubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\t\tcompanyId, className, classPK);\n\n\t\tfor (Subscription subscription : subscriptions) {\n\n\t\t\tlong subscriptorUserId = subscription.getUserId();\n\n\t\t\tif (userId == subscriptorUserId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Add user \" + subscriptorUserId +\n\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t}\n\n\t\t\tsent.add(subscriptorUserId);\n\n\t\t\tUser curMessageUser = null;\n\n\t\t\ttry {\n\t\t\t\tcurMessageUser =\n\t\t\t\t\tuserLocalService.getUserById(subscriptorUserId);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!curMessageUser.isActive()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tInternetAddress from = new InternetAddress(fromAddress, fromName);\n\n\t\t\tInternetAddress to = new InternetAddress(\n\t\t\t\tcurMessageUser.getEmailAddress(), curMessageUser.getFullName());\n\n\t\t\tString curSubject = StringUtil.replace(\n\t\t\t\tsubject,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tString curBody = StringUtil.replace(\n\t\t\t\tbody,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tMailMessage mailMessage = new MailMessage(\n\t\t\t\tfrom, to, curSubject, curBody, true);\n\n\t\t\tmailService.sendEmail(mailMessage);\n\t\t}\n\t}","commit_id":"dcab565274834376bb8d1af4798002b76b2a2fdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif ((thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tif (oldStatus != WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t\t// Thread\n\n\t\t\t\tif ((category != null) &&\n\t\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t\t}\n\n\t\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\t\tif (message.isAnonymous()) {\n\t\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t\t}\n\n\t\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\t// Category\n\n\t\t\t\tif (category != null) {\n\t\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\t\tcategory.setLastPostDate(\n\t\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((message.getClassNameId() == 0) ||\n\t\t\t\t\t(message.getParentMessageId() != 0)) {\n\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\t\t\ttrue);\n\t\t\t\t}\n\n\t\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\t\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\t\tlong receiverUserId = 0;\n\t\t\t\t\t\tString actionId = ActionKeys.ADD_MESSAGE;\n\n\t\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\n\t\t\t\t\t\t\tif (receiverUserId != userId) {\n\t\t\t\t\t\t\t\tactionId = ActionKeys.REPLY_TO_MESSAGE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, message.getGroupId(),\n\t\t\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(),\n\t\t\t\t\t\t\tactivityType, StringPool.BLANK, receiverUserId);\n\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, MBMessage.class.getName(), messageId,\n\t\t\t\t\t\t\tactionId, StringPool.BLANK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString className = (String)serviceContext.getAttribute(\n\t\t\t\t\t\t\"className\");\n\t\t\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isRoot()) {\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, className, classPK,\n\t\t\t\t\t\t\tActionKeys.ADD_DISCUSSION, StringPool.BLANK);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong parentMessageId = message.getParentMessageId();\n\n\t\t\t\t\tif (className.equals(BlogsEntry.class.getName()) &&\n\t\t\t\t\t\t(parentMessageId !=\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\t\t\t\t// Social\n\n\t\t\t\t\t\tBlogsEntry entry =\n\t\t\t\t\t\t\tblogsEntryPersistence.findByPrimaryKey(classPK);\n\n\t\t\t\t\t\tJSONObject extraData =\n\t\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\t\textraData.put(\"messageId\", message.getMessageId());\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, entry.getGroupId(),\n\t\t\t\t\t\t\tBlogsEntry.class.getName(), classPK,\n\t\t\t\t\t\t\tBlogsActivityKeys.ADD_COMMENT, extraData.toString(),\n\t\t\t\t\t\t\tentry.getUserId());\n\n\t\t\t\t\t\t// Email\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsendBlogsCommentsEmail(\n\t\t\t\t\t\t\t\tuserId, entry, message, serviceContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Subscriptions\n\n\t\t\t\tnotifySubscribers(message, serviceContext);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), false);\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","id":67744,"modified_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif ((thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tif (oldStatus != WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t\t// Thread\n\n\t\t\t\tif ((category != null) &&\n\t\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t\t}\n\n\t\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\t\tif (message.isAnonymous()) {\n\t\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t\t}\n\n\t\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\t// Category\n\n\t\t\t\tif (category != null) {\n\t\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\t\tcategory.setLastPostDate(\n\t\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((message.getClassNameId() == 0) ||\n\t\t\t\t\t(message.getParentMessageId() != 0)) {\n\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\t\t\ttrue);\n\t\t\t\t}\n\n\t\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\t\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\t\tlong receiverUserId = 0;\n\t\t\t\t\t\tString actionId = ActionKeys.ADD_MESSAGE;\n\n\t\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\n\t\t\t\t\t\t\tif (receiverUserId != userId) {\n\t\t\t\t\t\t\t\tactionId = ActionKeys.REPLY_TO_MESSAGE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, message.getGroupId(),\n\t\t\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(),\n\t\t\t\t\t\t\tactivityType, StringPool.BLANK, receiverUserId);\n\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, MBMessage.class.getName(), messageId,\n\t\t\t\t\t\t\tactionId, StringPool.BLANK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString className = (String)serviceContext.getAttribute(\n\t\t\t\t\t\t\"className\");\n\t\t\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isRoot()) {\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, className, classPK,\n\t\t\t\t\t\t\tActionKeys.ADD_DISCUSSION, StringPool.BLANK);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong parentMessageId = message.getParentMessageId();\n\n\t\t\t\t\tif (className.equals(BlogsEntry.class.getName()) &&\n\t\t\t\t\t\t(parentMessageId !=\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\t\t\t\t// Social\n\n\t\t\t\t\t\tBlogsEntry entry =\n\t\t\t\t\t\t\tblogsEntryPersistence.findByPrimaryKey(classPK);\n\n\t\t\t\t\t\tJSONObject extraData =\n\t\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\t\textraData.put(\"messageId\", message.getMessageId());\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, entry.getGroupId(),\n\t\t\t\t\t\t\tBlogsEntry.class.getName(), classPK,\n\t\t\t\t\t\t\tBlogsActivityKeys.ADD_COMMENT, extraData.toString(),\n\t\t\t\t\t\t\tentry.getUserId());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Subscriptions\n\n\t\t\t\tnotifySubscribers(message, serviceContext);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), false);\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"dcab565274834376bb8d1af4798002b76b2a2fdb","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected MBMessage updateMessage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString permissionClassName = ParamUtil.getString(\n\t\t\tactionRequest, \"permissionClassName\");\n\t\tlong permissionClassPK = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionClassPK\");\n\t\tlong permissionOwnerId = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionOwnerId\");\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\t\tboolean subscribe = ParamUtil.getBoolean(actionRequest, \"subscribe\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\n\t\t\t// Add message\n\n\t\t\tmessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\tserviceContext.getScopeGroupId(), className, classPK,\n\t\t\t\tpermissionClassName, permissionClassPK, permissionOwnerId,\n\t\t\t\tthreadId, parentMessageId, subject, body, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\tclassName, classPK, permissionClassName, permissionClassPK,\n\t\t\t\tpermissionOwnerId, messageId, subject, body, serviceContext);\n\t\t}\n\n\t\t// Subscription\n\n\t\tif (subscribe) {\n\t\t\tSubscriptionLocalServiceUtil.addSubscription(\n\t\t\t\tthemeDisplay.getUserId(), themeDisplay.getScopeGroupId(),\n\t\t\t\tclassName, classPK);\n\t\t}\n\n\t\treturn message;\n\t}","id":67745,"modified_method":"protected MBMessage updateMessage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString permissionClassName = ParamUtil.getString(\n\t\t\tactionRequest, \"permissionClassName\");\n\t\tlong permissionClassPK = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionClassPK\");\n\t\tlong permissionOwnerId = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionOwnerId\");\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\n\t\t\t// Add message\n\n\t\t\tmessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\tserviceContext.getScopeGroupId(), className, classPK,\n\t\t\t\tpermissionClassName, permissionClassPK, permissionOwnerId,\n\t\t\t\tthreadId, parentMessageId, subject, body, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\tclassName, classPK, permissionClassName, permissionClassPK,\n\t\t\t\tpermissionOwnerId, messageId, subject, body, serviceContext);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"5daf18f085e3a142408307014a3f07235fa9907c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE_TO_COMMENTS)) {\n\t\t\t\tsubscribeToComments(actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE_FROM_COMMENTS)) {\n\t\t\t\tsubscribeToComments(actionRequest, false);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":67746,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"5daf18f085e3a142408307014a3f07235fa9907c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif ((thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tif (oldStatus != WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t\t// Thread\n\n\t\t\t\tif ((category != null) &&\n\t\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t\t}\n\n\t\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\t\tif (message.isAnonymous()) {\n\t\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t\t}\n\n\t\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\t// Category\n\n\t\t\t\tif (category != null) {\n\t\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\t\tcategory.setLastPostDate(\n\t\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((message.getClassNameId() == 0) ||\n\t\t\t\t\t(message.getParentMessageId() != 0)) {\n\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\t\t\ttrue);\n\t\t\t\t}\n\n\t\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\t\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\t\tlong receiverUserId = 0;\n\t\t\t\t\t\tString actionId = ActionKeys.ADD_MESSAGE;\n\n\t\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\n\t\t\t\t\t\t\tif (receiverUserId != userId) {\n\t\t\t\t\t\t\t\tactionId = ActionKeys.REPLY_TO_MESSAGE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, message.getGroupId(),\n\t\t\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(),\n\t\t\t\t\t\t\tactivityType, StringPool.BLANK, receiverUserId);\n\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, MBMessage.class.getName(), messageId,\n\t\t\t\t\t\t\tactionId, StringPool.BLANK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString className = (String)serviceContext.getAttribute(\n\t\t\t\t\t\t\"className\");\n\t\t\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isRoot()) {\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, className, classPK,\n\t\t\t\t\t\t\tActionKeys.ADD_DISCUSSION, StringPool.BLANK);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong parentMessageId = message.getParentMessageId();\n\n\t\t\t\t\tif (className.equals(BlogsEntry.class.getName()) &&\n\t\t\t\t\t\t(parentMessageId !=\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\t\t\t\t// Social\n\n\t\t\t\t\t\tBlogsEntry entry =\n\t\t\t\t\t\t\tblogsEntryPersistence.findByPrimaryKey(classPK);\n\n\t\t\t\t\t\tJSONObject extraData =\n\t\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\t\textraData.put(\"messageId\", message.getMessageId());\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, entry.getGroupId(),\n\t\t\t\t\t\t\tBlogsEntry.class.getName(), classPK,\n\t\t\t\t\t\t\tBlogsActivityKeys.ADD_COMMENT, extraData.toString(),\n\t\t\t\t\t\t\tentry.getUserId());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Subscriptions\n\n\t\t\t\tnotifySubscribers(message, serviceContext);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), false);\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","id":67747,"modified_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif ((thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tif (oldStatus != WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t\t// Thread\n\n\t\t\t\tif ((category != null) &&\n\t\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t\t}\n\n\t\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\t\tif (message.isAnonymous()) {\n\t\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t\t}\n\n\t\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\t// Category\n\n\t\t\t\tif (category != null) {\n\t\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\t\tcategory.setLastPostDate(\n\t\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((message.getClassNameId() == 0) ||\n\t\t\t\t\t(message.getParentMessageId() != 0)) {\n\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\t\t\ttrue);\n\t\t\t\t}\n\n\t\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\t\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\t\tlong receiverUserId = 0;\n\t\t\t\t\t\tString actionId = ActionKeys.ADD_MESSAGE;\n\n\t\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\n\t\t\t\t\t\t\tif (receiverUserId != userId) {\n\t\t\t\t\t\t\t\tactionId = ActionKeys.REPLY_TO_MESSAGE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, message.getGroupId(),\n\t\t\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(),\n\t\t\t\t\t\t\tactivityType, StringPool.BLANK, receiverUserId);\n\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, MBMessage.class.getName(), messageId,\n\t\t\t\t\t\t\tactionId, StringPool.BLANK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString className = (String)serviceContext.getAttribute(\n\t\t\t\t\t\t\"className\");\n\t\t\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isRoot()) {\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, className, classPK,\n\t\t\t\t\t\t\tActionKeys.ADD_DISCUSSION, StringPool.BLANK);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong parentMessageId = message.getParentMessageId();\n\n\t\t\t\t\tif (className.equals(BlogsEntry.class.getName()) &&\n\t\t\t\t\t\t(parentMessageId !=\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\t\t\t\t// Social\n\n\t\t\t\t\t\tBlogsEntry entry =\n\t\t\t\t\t\t\tblogsEntryPersistence.findByPrimaryKey(classPK);\n\n\t\t\t\t\t\tJSONObject extraData =\n\t\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\t\textraData.put(\"messageId\", message.getMessageId());\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, entry.getGroupId(),\n\t\t\t\t\t\t\tBlogsEntry.class.getName(), classPK,\n\t\t\t\t\t\t\tBlogsActivityKeys.ADD_COMMENT, extraData.toString(),\n\t\t\t\t\t\t\tentry.getUserId());\n\n\t\t\t\t\t\t// Email\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsendBlogsCommentsEmail(\n\t\t\t\t\t\t\t\tuserId, entry, message, serviceContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Subscriptions\n\n\t\t\t\tnotifySubscribers(message, serviceContext);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), false);\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"5daf18f085e3a142408307014a3f07235fa9907c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendCommentsEmail(\n\t\t\tlong userId, MBMessage message, ServiceContext serviceContext)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tString className =\n\t\t\t(String)serviceContext.getAttribute(\"className\");\n\t\tlong classPK =\n\t\t\tGetterUtil.getLong((String)serviceContext.getAttribute(\"classPK\"));\n\n\t\tlong companyId = message.getCompanyId();\n\n\t\tString contentURL =\n\t\t\tserviceContext.getPortalURL().concat(\n\t\t\t\tserviceContext.getCurrentURL());\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_NAME);\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.DISCUSSION_EMAIL_SUBJECT);\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.DISCUSSION_EMAIL_BODY);\n\n\t\tsubject = StringUtil.replace(\n\t\t\tsubject,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMMENTS_BODY$]\",\n\t\t\t\t\"[$COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$CONTENT_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tcontentURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMMENTS_BODY$]\",\n\t\t\t\t\"[$COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$ASSET_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tcontentURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tList<Subscription> subscriptions =\n\t\t\tSubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\t\tcompanyId, className, classPK);\n\n\t\tfor (Subscription subscription : subscriptions) {\n\n\t\t\tlong subscriptorUserId = subscription.getUserId();\n\n\t\t\tif (userId == subscriptorUserId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Add user \" + subscriptorUserId +\n\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t}\n\n\t\t\tsent.add(subscriptorUserId);\n\n\t\t\tUser curMessageUser = null;\n\n\t\t\ttry {\n\t\t\t\tcurMessageUser =\n\t\t\t\t\tuserLocalService.getUserById(subscriptorUserId);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!curMessageUser.isActive()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tInternetAddress from = new InternetAddress(fromAddress, fromName);\n\n\t\t\tInternetAddress to = new InternetAddress(\n\t\t\t\tcurMessageUser.getEmailAddress(), curMessageUser.getFullName());\n\n\t\t\tString curSubject = StringUtil.replace(\n\t\t\t\tsubject,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tString curBody = StringUtil.replace(\n\t\t\t\tbody,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tMailMessage mailMessage = new MailMessage(\n\t\t\t\tfrom, to, curSubject, curBody, true);\n\n\t\t\tmailService.sendEmail(mailMessage);\n\t\t}\n\t}","id":67748,"modified_method":"protected void sendBlogsCommentsEmail(\n\t\t\tlong userId, BlogsEntry entry, MBMessage message,\n\t\t\tServiceContext serviceContext)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tlong companyId = message.getCompanyId();\n\n\t\tif (!PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_ENABLED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tString blogsEntryURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR + \"blogs/\" +\n\t\t\t\tentry.getUrlTitle();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_NAME);\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_SUBJECT);\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_BODY);\n\n\t\tsubject = StringUtil.replace(\n\t\t\tsubject,\n\t\t\tnew String[] {\n\t\t\t\t\"[$BLOGS_COMMENTS_BODY$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$BLOGS_ENTRY_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tblogsEntryURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$BLOGS_COMMENTS_BODY$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$BLOGS_ENTRY_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tblogsEntryURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tList<MBMessage> messages = mbMessagePersistence.findByThreadId(\n\t\t\tmessage.getThreadId());\n\n\t\tfor (MBMessage curMessage : messages) {\n\t\t\tlong curMessageUserId = curMessage.getUserId();\n\n\t\t\tif (curMessageUserId == userId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sent.contains(curMessageUserId)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Do not send a duplicate email to user \" +\n\t\t\t\t\t\t\tcurMessageUserId);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Add user \" + curMessageUserId +\n\t\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t\t}\n\n\t\t\t\tsent.add(curMessageUserId);\n\t\t\t}\n\n\t\t\tUser curMessageUser = null;\n\n\t\t\ttry {\n\t\t\t\tcurMessageUser = userLocalService.getUserById(curMessageUserId);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!curMessageUser.isActive()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tInternetAddress from = new InternetAddress(fromAddress, fromName);\n\n\t\t\tInternetAddress to = new InternetAddress(\n\t\t\t\tcurMessageUser.getEmailAddress(), curMessageUser.getFullName());\n\n\t\t\tString curSubject = StringUtil.replace(\n\t\t\t\tsubject,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tString curBody = StringUtil.replace(\n\t\t\t\tbody,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tMailMessage mailMessage = new MailMessage(\n\t\t\t\tfrom, to, curSubject, curBody, true);\n\n\t\t\tmailService.sendEmail(mailMessage);\n\t\t}\n\t}","commit_id":"5daf18f085e3a142408307014a3f07235fa9907c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED ||\n\t\t\t\tValidator.isNull(layoutFullURL)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (message.isDiscussion()) {\n\t\t\ttry{\n\t\t\t\tsendCommentsEmail(message.getUserId(), message, serviceContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tboolean update = GetterUtil.getBoolean(\n\t\t\t(String)serviceContext.getAttribute(\"update\"));\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(message.getGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tString categoryName = category.getName();\n\n\t\tif (category.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tcategoryName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\t\"message-boards-home\") + StringPool.SPACE + StringPool.DASH +\n\t\t\t\tStringPool.SPACE + group.getName();\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\n\t\tif ((message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\t\t}\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/view_message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","id":67749,"modified_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (Validator.isNull(layoutFullURL) || message.isDiscussion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tboolean update = GetterUtil.getBoolean(\n\t\t\t(String)serviceContext.getAttribute(\"update\"));\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(message.getGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tString categoryName = category.getName();\n\n\t\tif (category.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tcategoryName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\t\"message-boards-home\") + StringPool.SPACE + StringPool.DASH +\n\t\t\t\tStringPool.SPACE + group.getName();\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\n\t\tif ((message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\t\t}\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/view_message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","commit_id":"5daf18f085e3a142408307014a3f07235fa9907c","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void setAttributes(HttpServletRequest request) {\n\t\tString permissionClassName = _permissionClassName;\n\n\t\tif (Validator.isNull(permissionClassName)) {\n\t\t\tpermissionClassName = _className;\n\t\t}\n\n\t\tlong permissionClassPK = _permissionClassPK;\n\n\t\tif (permissionClassPK == 0) {\n\t\t\tpermissionClassPK = _classPK;\n\t\t}\n\n\t\trequest.setAttribute(\"liferay-ui:discussion:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:classPK\", String.valueOf(_classPK));\n\t\trequest.setAttribute(\"liferay-ui:discussion:formAction\", _formAction);\n\t\trequest.setAttribute(\"liferay-ui:discussion:formName\", _formName);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:permissionClassName\", permissionClassName);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:permissionClassPK\",\n\t\t\tString.valueOf(permissionClassPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:ratingsEnabled\",\n\t\t\tString.valueOf(_ratingsEnabled));\n\t\trequest.setAttribute(\"liferay-ui:discussion:redirect\", _redirect);\n\t\trequest.setAttribute(\"liferay-ui:discussion:subject\", _subject);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:userId\", String.valueOf(_userId));\n\t}","id":67750,"modified_method":"protected void setAttributes(HttpServletRequest request) {\n\t\tString permissionClassName = _permissionClassName;\n\n\t\tif (Validator.isNull(permissionClassName)) {\n\t\t\tpermissionClassName = _className;\n\t\t}\n\n\t\tlong permissionClassPK = _permissionClassPK;\n\n\t\tif (permissionClassPK == 0) {\n\t\t\tpermissionClassPK = _classPK;\n\t\t}\n\n\t\trequest.setAttribute(\"liferay-ui:discussion:className\", _className);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:classPK\", String.valueOf(_classPK));\n\t\trequest.setAttribute(\"liferay-ui:discussion:formAction\", _formAction);\n\t\trequest.setAttribute(\"liferay-ui:discussion:formName\", _formName);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:moderateEnabled\",\n\t\t\tString.valueOf(_moderateEnabled));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:permissionClassName\", permissionClassName);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:permissionClassPK\",\n\t\t\tString.valueOf(permissionClassPK));\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:ratingsEnabled\",\n\t\t\tString.valueOf(_ratingsEnabled));\n\t\trequest.setAttribute(\"liferay-ui:discussion:redirect\", _redirect);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:status\", String.valueOf(_status));\n\t\trequest.setAttribute(\"liferay-ui:discussion:subject\", _subject);\n\t\trequest.setAttribute(\n\t\t\t\"liferay-ui:discussion:userId\", String.valueOf(_userId));\n\t}","commit_id":"717373e7f1288afda1eb1a5a3e88dc897e1fbe09","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":67751,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.APPROVE)) {\n\t\t\t\tupdateMessageStatus(actionRequest, StatusConstants.APPROVED);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DENY)) {\n\t\t\t\tupdateMessageStatus(actionRequest, StatusConstants.DENIED);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNAPPROVE)) {\n\t\t\t\tupdateMessageStatus(actionRequest, StatusConstants.PENDING);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"717373e7f1288afda1eb1a5a3e88dc897e1fbe09","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateStatus(\n\t\t\tlong userId, MBMessage message, ServiceContext serviceContext,\n\t\t\tboolean reindex)\n\t\tthrows PortalException, SystemException {\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(now);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != serviceContext.getStatus())) {\n\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\t\t}\n\n\t\tif (serviceContext.getStatus() != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Category\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tthread.getCategoryId());\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\t// Asset\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\n\t\t\tif (reindex) {\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tMBMessage.class);\n\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()  &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\t\t\tMBMessage parentMessage =\n\t\t\t\tmbMessagePersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\tif (parentMessage !=  null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessage.getMessageId(), activityType, StringPool.BLANK,\n\t\t\t\treceiverUserId);\n\t\t}\n\n\t\treturn message;\n\t}","id":67752,"modified_method":"public MBMessage updateStatus(\n\t\t\tlong userId, MBMessage message, ServiceContext serviceContext,\n\t\t\tboolean reindex)\n\t\tthrows PortalException, SystemException {\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(serviceContext.getStatus());\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(now);\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != serviceContext.getStatus())) {\n\n\t\t\tthread.setStatus(serviceContext.getStatus());\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\tif (message.isAnonymous()) {\n\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t}\n\n\t\t\tthread.setLastPostDate(now);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\t\t}\n\n\t\tif (serviceContext.getStatus() != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Category\n\n\t\tMBCategory category = mbCategoryPersistence.findByPrimaryKey(\n\t\t\tthread.getCategoryId());\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\tcategory.setLastPostDate(now);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\tmbCategoryPersistence.update(category, false);\n\t\t}\n\n\t\tif (message.isDiscussion()) {\n\t\t\treturn message;\n\t\t}\n\n\t\t// Asset\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), true);\n\n\t\t\tif (reindex) {\n\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\tMBMessage.class);\n\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\t\t}\n\n\t\tif ((serviceContext.getStatus() != StatusConstants.APPROVED) &&\n\t\t\t(oldStatus == StatusConstants.APPROVED)) {\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tMBMessage.class.getName(), message.getMessageId(), false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif ((serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId, now);\n\t\t}\n\n\t\t// Social\n\n\t\tif (!message.isDiscussion() && !message.isAnonymous() &&\n\t\t\t!user.isDefaultUser() &&\n\t\t\t(serviceContext.getStatus() == StatusConstants.APPROVED) &&\n\t\t\t(oldStatus != StatusConstants.APPROVED)) {\n\n\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\tlong receiverUserId = 0;\n\t\t\tMBMessage parentMessage =\n\t\t\t\tmbMessagePersistence.findByPrimaryKey(\n\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\tif (parentMessage !=  null) {\n\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\treceiverUserId = parentMessage.getUserId();\n\t\t\t}\n\n\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\tuserId, message.getGroupId(), MBMessage.class.getName(),\n\t\t\t\tmessage.getMessageId(), activityType, StringPool.BLANK,\n\t\t\t\treceiverUserId);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"717373e7f1288afda1eb1a5a3e88dc897e1fbe09","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","id":67753,"modified_method":"public void processAction(\n\t\t\tActionMapping mapping, ActionForm form, PortletConfig portletConfig,\n\t\t\tActionRequest actionRequest, ActionResponse actionResponse)\n\t\tthrows Exception {\n\n\t\tActionResponseImpl actionResponseImpl =\n\t\t\t(ActionResponseImpl)actionResponse;\n\n\t\tString cmd = ParamUtil.getString(actionRequest, Constants.CMD);\n\n\t\ttry {\n\t\t\tString redirect = ParamUtil.getString(actionRequest, \"redirect\");\n\n\t\t\tif (cmd.equals(Constants.ADD) || cmd.equals(Constants.UPDATE)) {\n\t\t\t\tMBMessage message = updateMessage(actionRequest);\n\n\t\t\t\tredirect +=\n\t\t\t\t\t\"#\" + actionResponseImpl.getNamespace() + \"messageScroll\" +\n\t\t\t\t\t\tmessage.getMessageId();\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.DELETE)) {\n\t\t\t\tdeleteMessage(actionRequest);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.SUBSCRIBE_TO_COMMENTS)) {\n\t\t\t\tsubscribeToComments(actionRequest, true);\n\t\t\t}\n\t\t\telse if (cmd.equals(Constants.UNSUBSCRIBE_FROM_COMMENTS)) {\n\t\t\t\tsubscribeToComments(actionRequest, false);\n\t\t\t}\n\n\t\t\tsendRedirect(actionRequest, actionResponse, redirect);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tif (e instanceof NoSuchMessageException ||\n\t\t\t\te instanceof PrincipalException ||\n\t\t\t\te instanceof RequiredMessageException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsetForward(actionRequest, \"portlet.message_boards.error\");\n\t\t\t}\n\t\t\telse if (e instanceof FileNameException ||\n\t\t\t\t\t e instanceof FileSizeException ||\n\t\t\t\t\t e instanceof MessageBodyException ||\n\t\t\t\t\t e instanceof MessageSubjectException) {\n\n\t\t\t\tSessionErrors.add(actionRequest, e.getClass().getName());\n\n\t\t\t\tsendRedirect(actionRequest, actionResponse);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\t}","commit_id":"4dcf9d15248b884f0db08eb46528008a13f5064d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected MBMessage updateMessage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString permissionClassName = ParamUtil.getString(\n\t\t\tactionRequest, \"permissionClassName\");\n\t\tlong permissionClassPK = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionClassPK\");\n\t\tlong permissionOwnerId = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionOwnerId\");\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\n\t\t\t// Add message\n\n\t\t\tmessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\tserviceContext.getScopeGroupId(), className, classPK,\n\t\t\t\tpermissionClassName, permissionClassPK, permissionOwnerId,\n\t\t\t\tthreadId, parentMessageId, subject, body, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\tclassName, classPK, permissionClassName, permissionClassPK,\n\t\t\t\tpermissionOwnerId, messageId, subject, body, serviceContext);\n\t\t}\n\n\t\treturn message;\n\t}","id":67754,"modified_method":"protected MBMessage updateMessage(ActionRequest actionRequest)\n\t\tthrows Exception {\n\t\tThemeDisplay themeDisplay = (ThemeDisplay)actionRequest.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tString className = ParamUtil.getString(actionRequest, \"className\");\n\t\tlong classPK = ParamUtil.getLong(actionRequest, \"classPK\");\n\t\tString permissionClassName = ParamUtil.getString(\n\t\t\tactionRequest, \"permissionClassName\");\n\t\tlong permissionClassPK = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionClassPK\");\n\t\tlong permissionOwnerId = ParamUtil.getLong(\n\t\t\tactionRequest, \"permissionOwnerId\");\n\n\t\tlong messageId = ParamUtil.getLong(actionRequest, \"messageId\");\n\n\t\tlong threadId = ParamUtil.getLong(actionRequest, \"threadId\");\n\t\tlong parentMessageId = ParamUtil.getLong(\n\t\t\tactionRequest, \"parentMessageId\");\n\t\tString subject = ParamUtil.getString(actionRequest, \"subject\");\n\t\tString body = ParamUtil.getString(actionRequest, \"body\");\n\t\tboolean subscribe = ParamUtil.getBoolean(actionRequest, \"subscribe\");\n\n\t\tServiceContext serviceContext = ServiceContextFactory.getInstance(\n\t\t\tMBMessage.class.getName(), actionRequest);\n\n\t\tMBMessage message = null;\n\n\t\tif (messageId <= 0) {\n\n\t\t\t// Add message\n\n\t\t\tmessage = MBMessageServiceUtil.addDiscussionMessage(\n\t\t\t\tserviceContext.getScopeGroupId(), className, classPK,\n\t\t\t\tpermissionClassName, permissionClassPK, permissionOwnerId,\n\t\t\t\tthreadId, parentMessageId, subject, body, serviceContext);\n\t\t}\n\t\telse {\n\n\t\t\t// Update message\n\n\t\t\tmessage = MBMessageServiceUtil.updateDiscussionMessage(\n\t\t\t\tclassName, classPK, permissionClassName, permissionClassPK,\n\t\t\t\tpermissionOwnerId, messageId, subject, body, serviceContext);\n\t\t}\n\n\t\t// Subscription\n\n\t\tif (subscribe) {\n\t\t\tSubscriptionLocalServiceUtil.addSubscription(\n\t\t\t\tthemeDisplay.getUserId(), themeDisplay.getScopeGroupId(),\n\t\t\t\tclassName, classPK);\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"4dcf9d15248b884f0db08eb46528008a13f5064d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED) {\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (Validator.isNull(layoutFullURL) || message.isDiscussion()) {\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tboolean update = GetterUtil.getBoolean(\n\t\t\t(String)serviceContext.getAttribute(\"update\"));\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(message.getGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tString categoryName = category.getName();\n\n\t\tif (category.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tcategoryName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\t\"message-boards-home\") + StringPool.SPACE + StringPool.DASH +\n\t\t\t\tStringPool.SPACE + group.getName();\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\n\t\tif ((message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\t\t}\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/view_message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","id":67755,"modified_method":"protected void notifySubscribers(\n\t\t\tMBMessage message, ServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tif (message.getStatus() != WorkflowConstants.STATUS_APPROVED ||\n\t\t\t\tValidator.isNull(layoutFullURL)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (message.isDiscussion()) {\n\t\t\ttry{\n\t\t\t\tsendCommentsEmail(message.getUserId(), message, serviceContext);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\t_log.error(e, e);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tPortletPreferences preferences =\n\t\t\tServiceContextUtil.getPortletPreferences(serviceContext);\n\n\t\tif (preferences == null) {\n\t\t\tlong ownerId = message.getGroupId();\n\t\t\tint ownerType = PortletKeys.PREFS_OWNER_TYPE_GROUP;\n\t\t\tlong plid = PortletKeys.PREFS_PLID_SHARED;\n\t\t\tString portletId = PortletKeys.MESSAGE_BOARDS;\n\t\t\tString defaultPreferences = null;\n\n\t\t\tpreferences = portletPreferencesLocalService.getPreferences(\n\t\t\t\tmessage.getCompanyId(), ownerId, ownerType, plid, portletId,\n\t\t\t\tdefaultPreferences);\n\t\t}\n\n\t\tboolean update = GetterUtil.getBoolean(\n\t\t\t(String)serviceContext.getAttribute(\"update\"));\n\n\t\tif (!update && MBUtil.getEmailMessageAddedEnabled(preferences)) {\n\t\t}\n\t\telse if (update && MBUtil.getEmailMessageUpdatedEnabled(preferences)) {\n\t\t}\n\t\telse {\n\t\t\treturn;\n\t\t}\n\n\t\tCompany company = companyPersistence.findByPrimaryKey(\n\t\t\tmessage.getCompanyId());\n\n\t\tGroup group = groupPersistence.findByPrimaryKey(message.getGroupId());\n\n\t\tString emailAddress = StringPool.BLANK;\n\t\tString fullName = message.getUserName();\n\n\t\ttry {\n\t\t\tUser user = userPersistence.findByPrimaryKey(message.getUserId());\n\n\t\t\temailAddress = user.getEmailAddress();\n\t\t\tfullName = user.getFullName();\n\t\t}\n\t\tcatch (NoSuchUserException nsue) {\n\t\t}\n\n\t\tMBCategory category = message.getCategory();\n\n\t\tif (message.isAnonymous()) {\n\t\t\temailAddress = StringPool.BLANK;\n\t\t\tfullName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext), \"anonymous\");\n\t\t}\n\n\t\tString categoryName = category.getName();\n\n\t\tif (category.getCategoryId() ==\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) {\n\n\t\t\tcategoryName = LanguageUtil.get(\n\t\t\t\tServiceContextUtil.getLocale(serviceContext),\n\t\t\t\t\"message-boards-home\") + StringPool.SPACE + StringPool.DASH +\n\t\t\t\tStringPool.SPACE + group.getName();\n\t\t}\n\n\t\tList<Long> categoryIds = new ArrayList<Long>();\n\n\t\tcategoryIds.add(message.getCategoryId());\n\n\t\tif ((message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(message.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategoryIds.addAll(category.getAncestorCategoryIds());\n\t\t}\n\n\t\tString messageURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR +\n\t\t\t\t\"message_boards/view_message/\" + message.getMessageId();\n\n\t\tString portletName = PortalUtil.getPortletTitle(\n\t\t\tPortletKeys.MESSAGE_BOARDS, LocaleUtil.getDefault());\n\n\t\tString fromName = MBUtil.getEmailFromName(preferences);\n\t\tString fromAddress = MBUtil.getEmailFromAddress(preferences);\n\n\t\tString mailingListAddress = StringPool.BLANK;\n\n\t\tif (PropsValues.POP_SERVER_NOTIFICATIONS_ENABLED) {\n\t\t\tmailingListAddress = MBUtil.getMailingListAddress(\n\t\t\t\tmessage.getGroupId(), message.getCategoryId(),\n\t\t\t\tmessage.getMessageId(), company.getMx(), fromAddress);\n\t\t}\n\n\t\tString replyToAddress = mailingListAddress;\n\t\tString mailId = MBUtil.getMailId(\n\t\t\tcompany.getMx(), message.getCategoryId(), message.getMessageId());\n\n\t\tfromName = StringUtil.replace(\n\t\t\tfromName,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tfromAddress = StringUtil.replace(\n\t\t\tfromAddress,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tmailingListAddress,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subjectPrefix = null;\n\t\tString body = null;\n\t\tString signature = null;\n\t\tboolean htmlFormat = MBUtil.getEmailHtmlFormat(preferences);\n\n\t\tif (update) {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageUpdatedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageUpdatedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageUpdatedSignature(preferences);\n\t\t}\n\t\telse {\n\t\t\tsubjectPrefix = MBUtil.getEmailMessageAddedSubjectPrefix(\n\t\t\t\tpreferences);\n\t\t\tbody = MBUtil.getEmailMessageAddedBody(preferences);\n\t\t\tsignature = MBUtil.getEmailMessageAddedSignature(preferences);\n\t\t}\n\n\t\tif (Validator.isNotNull(signature)) {\n\t\t\tbody +=  \"\\n--\\n\" + signature;\n\t\t}\n\n\t\tsubjectPrefix = StringUtil.replace(\n\t\t\tsubjectPrefix,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$CATEGORY_NAME$]\",\n\t\t\t\t\"[$COMPANY_ID$]\",\n\t\t\t\t\"[$COMPANY_MX$]\",\n\t\t\t\t\"[$COMPANY_NAME$]\",\n\t\t\t\t\"[$COMMUNITY_NAME$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\",\n\t\t\t\t\"[$MAILING_LIST_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_BODY$]\",\n\t\t\t\t\"[$MESSAGE_ID$]\",\n\t\t\t\t\"[$MESSAGE_SUBJECT$]\",\n\t\t\t\t\"[$MESSAGE_URL$]\",\n\t\t\t\t\"[$MESSAGE_USER_ADDRESS$]\",\n\t\t\t\t\"[$MESSAGE_USER_NAME$]\",\n\t\t\t\t\"[$PORTAL_URL$]\",\n\t\t\t\t\"[$PORTLET_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tcategoryName,\n\t\t\t\tString.valueOf(company.getCompanyId()),\n\t\t\t\tcompany.getMx(),\n\t\t\t\tcompany.getName(),\n\t\t\t\tgroup.getName(),\n\t\t\t\tfromAddress,\n\t\t\t\tfromName,\n\t\t\t\tmailingListAddress,\n\t\t\t\tmessage.getBody(),\n\t\t\t\tString.valueOf(message.getMessageId()),\n\t\t\t\tmessage.getSubject(),\n\t\t\t\tmessageURL,\n\t\t\t\temailAddress,\n\t\t\t\tfullName,\n\t\t\t\tcompany.getVirtualHostname(),\n\t\t\t\tportletName\n\t\t\t});\n\n\t\tString subject = message.getSubject();\n\n\t\tif (subject.indexOf(subjectPrefix) == -1) {\n\t\t\tsubject = subjectPrefix.trim() + \" \" + subject.trim();\n\t\t}\n\n\t\tString inReplyTo = null;\n\n\t\tif (message.getParentMessageId() !=\n\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID) {\n\n\t\t\tinReplyTo = MBUtil.getMailId(\n\t\t\t\tcompany.getMx(), message.getCategoryId(),\n\t\t\t\tmessage.getParentMessageId());\n\t\t}\n\n\t\tcom.liferay.portal.kernel.messaging.Message messagingObj =\n\t\t\tnew com.liferay.portal.kernel.messaging.Message();\n\n\t\tmessagingObj.put(\"companyId\", message.getCompanyId());\n\t\tmessagingObj.put(\"userId\", message.getUserId());\n\t\tmessagingObj.put(\"groupId\", message.getGroupId());\n\t\tmessagingObj.put(\"categoryIds\", StringUtil.merge(categoryIds));\n\t\tmessagingObj.put(\"threadId\", message.getThreadId());\n\t\tmessagingObj.put(\"fromName\", fromName);\n\t\tmessagingObj.put(\"fromAddress\", fromAddress);\n\t\tmessagingObj.put(\"subject\", subject);\n\t\tmessagingObj.put(\"body\", body);\n\t\tmessagingObj.put(\"replyToAddress\", replyToAddress);\n\t\tmessagingObj.put(\"mailId\", mailId);\n\t\tmessagingObj.put(\"inReplyTo\", inReplyTo);\n\t\tmessagingObj.put(\"htmlFormat\", htmlFormat);\n\t\tmessagingObj.put(\n\t\t\t\"sourceMailingList\", MailingListThreadLocal.isSourceMailingList());\n\n\t\tMessageBusUtil.sendMessage(\n\t\t\tDestinationNames.MESSAGE_BOARDS, messagingObj);\n\t}","commit_id":"4dcf9d15248b884f0db08eb46528008a13f5064d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif ((thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tif (oldStatus != WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t\t// Thread\n\n\t\t\t\tif ((category != null) &&\n\t\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t\t}\n\n\t\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\t\tif (message.isAnonymous()) {\n\t\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t\t}\n\n\t\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\t// Category\n\n\t\t\t\tif (category != null) {\n\t\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\t\tcategory.setLastPostDate(\n\t\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((message.getClassNameId() == 0) ||\n\t\t\t\t\t(message.getParentMessageId() != 0)) {\n\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\t\t\ttrue);\n\t\t\t\t}\n\n\t\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\t\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\t\tlong receiverUserId = 0;\n\t\t\t\t\t\tString actionId = ActionKeys.ADD_MESSAGE;\n\n\t\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\n\t\t\t\t\t\t\tif (receiverUserId != userId) {\n\t\t\t\t\t\t\t\tactionId = ActionKeys.REPLY_TO_MESSAGE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, message.getGroupId(),\n\t\t\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(),\n\t\t\t\t\t\t\tactivityType, StringPool.BLANK, receiverUserId);\n\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, MBMessage.class.getName(), messageId,\n\t\t\t\t\t\t\tactionId, StringPool.BLANK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString className = (String)serviceContext.getAttribute(\n\t\t\t\t\t\t\"className\");\n\t\t\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isRoot()) {\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, className, classPK,\n\t\t\t\t\t\t\tActionKeys.ADD_DISCUSSION, StringPool.BLANK);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong parentMessageId = message.getParentMessageId();\n\n\t\t\t\t\tif (className.equals(BlogsEntry.class.getName()) &&\n\t\t\t\t\t\t(parentMessageId !=\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\t\t\t\t// Social\n\n\t\t\t\t\t\tBlogsEntry entry =\n\t\t\t\t\t\t\tblogsEntryPersistence.findByPrimaryKey(classPK);\n\n\t\t\t\t\t\tJSONObject extraData =\n\t\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\t\textraData.put(\"messageId\", message.getMessageId());\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, entry.getGroupId(),\n\t\t\t\t\t\t\tBlogsEntry.class.getName(), classPK,\n\t\t\t\t\t\t\tBlogsActivityKeys.ADD_COMMENT, extraData.toString(),\n\t\t\t\t\t\t\tentry.getUserId());\n\n\t\t\t\t\t\t// Email\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsendBlogsCommentsEmail(\n\t\t\t\t\t\t\t\tuserId, entry, message, serviceContext);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (Exception e) {\n\t\t\t\t\t\t\t_log.error(e, e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Subscriptions\n\n\t\t\t\tnotifySubscribers(message, serviceContext);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), false);\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","id":67756,"modified_method":"public MBMessage updateStatus(\n\t\t\tlong userId, long messageId, int status,\n\t\t\tServiceContext serviceContext)\n\t\tthrows PortalException, SystemException {\n\n\t\tMBMessage message = getMessage(messageId);\n\n\t\tint oldStatus = message.getStatus();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\t\tDate now = new Date();\n\n\t\tmessage.setStatus(status);\n\t\tmessage.setStatusByUserId(userId);\n\t\tmessage.setStatusByUserName(user.getFullName());\n\t\tmessage.setStatusDate(serviceContext.getModifiedDate(now));\n\n\t\tmbMessagePersistence.update(message, false);\n\n\t\t// Thread\n\n\t\tMBThread thread = mbThreadPersistence.findByPrimaryKey(\n\t\t\tmessage.getThreadId());\n\n\t\tMBCategory category = null;\n\n\t\tif ((thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DEFAULT_PARENT_CATEGORY_ID) &&\n\t\t\t(thread.getCategoryId() !=\n\t\t\t\tMBCategoryConstants.DISCUSSION_CATEGORY_ID)) {\n\n\t\t\tcategory = mbCategoryPersistence.findByPrimaryKey(\n\t\t\t\tthread.getCategoryId());\n\t\t}\n\n\t\tif ((thread.getRootMessageId() == message.getMessageId()) &&\n\t\t\t(oldStatus != status)) {\n\n\t\t\tthread.setStatus(status);\n\t\t\tthread.setStatusByUserId(userId);\n\t\t\tthread.setStatusByUserName(user.getFullName());\n\t\t\tthread.setStatusDate(serviceContext.getModifiedDate(now));\n\t\t}\n\n\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(MBMessage.class);\n\n\t\tif (status == WorkflowConstants.STATUS_APPROVED) {\n\t\t\tif (oldStatus != WorkflowConstants.STATUS_APPROVED) {\n\n\t\t\t\t// Thread\n\n\t\t\t\tif ((category != null) &&\n\t\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\t\tcategory.setThreadCount(category.getThreadCount() + 1);\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t\t}\n\n\t\t\t\tthread.setMessageCount(thread.getMessageCount() + 1);\n\n\t\t\t\tif (message.isAnonymous()) {\n\t\t\t\t\tthread.setLastPostByUserId(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthread.setLastPostByUserId(message.getUserId());\n\t\t\t\t}\n\n\t\t\t\tthread.setLastPostDate(serviceContext.getModifiedDate(now));\n\n\t\t\t\t// Category\n\n\t\t\t\tif (category != null) {\n\t\t\t\t\tcategory.setMessageCount(category.getMessageCount() + 1);\n\t\t\t\t\tcategory.setLastPostDate(\n\t\t\t\t\t\tserviceContext.getModifiedDate(now));\n\n\t\t\t\t\tmbCategoryPersistence.update(category, false);\n\n\t\t\t\t}\n\n\t\t\t\t// Asset\n\n\t\t\t\tif ((message.getClassNameId() == 0) ||\n\t\t\t\t\t(message.getParentMessageId() != 0)) {\n\n\t\t\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(),\n\t\t\t\t\t\ttrue);\n\t\t\t\t}\n\n\t\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isAnonymous() && !user.isDefaultUser()) {\n\t\t\t\t\t\tint activityType = MBActivityKeys.ADD_MESSAGE;\n\t\t\t\t\t\tlong receiverUserId = 0;\n\t\t\t\t\t\tString actionId = ActionKeys.ADD_MESSAGE;\n\n\t\t\t\t\t\tMBMessage parentMessage =\n\t\t\t\t\t\t\tmbMessagePersistence.fetchByPrimaryKey(\n\t\t\t\t\t\t\t\tmessage.getParentMessageId());\n\n\t\t\t\t\t\tif (parentMessage != null) {\n\t\t\t\t\t\t\tactivityType = MBActivityKeys.REPLY_MESSAGE;\n\t\t\t\t\t\t\treceiverUserId = parentMessage.getUserId();\n\n\t\t\t\t\t\t\tif (receiverUserId != userId) {\n\t\t\t\t\t\t\t\tactionId = ActionKeys.REPLY_TO_MESSAGE;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, message.getGroupId(),\n\t\t\t\t\t\t\tMBMessage.class.getName(), message.getMessageId(),\n\t\t\t\t\t\t\tactivityType, StringPool.BLANK, receiverUserId);\n\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, MBMessage.class.getName(), messageId,\n\t\t\t\t\t\t\tactionId, StringPool.BLANK);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tString className = (String)serviceContext.getAttribute(\n\t\t\t\t\t\t\"className\");\n\t\t\t\t\tlong classPK = GetterUtil.getLong(\n\t\t\t\t\t\t(String)serviceContext.getAttribute(\"classPK\"));\n\n\t\t\t\t\t// Social\n\n\t\t\t\t\tif (!message.isRoot()) {\n\t\t\t\t\t\tsocialEquityLogLocalService.addEquityLogs(\n\t\t\t\t\t\t\tuserId, className, classPK,\n\t\t\t\t\t\t\tActionKeys.ADD_DISCUSSION, StringPool.BLANK);\n\t\t\t\t\t}\n\n\t\t\t\t\tlong parentMessageId = message.getParentMessageId();\n\n\t\t\t\t\tif (className.equals(BlogsEntry.class.getName()) &&\n\t\t\t\t\t\t(parentMessageId !=\n\t\t\t\t\t\t\tMBMessageConstants.DEFAULT_PARENT_MESSAGE_ID)) {\n\n\t\t\t\t\t\t// Social\n\n\t\t\t\t\t\tBlogsEntry entry =\n\t\t\t\t\t\t\tblogsEntryPersistence.findByPrimaryKey(classPK);\n\n\t\t\t\t\t\tJSONObject extraData =\n\t\t\t\t\t\t\tJSONFactoryUtil.createJSONObject();\n\n\t\t\t\t\t\textraData.put(\"messageId\", message.getMessageId());\n\n\t\t\t\t\t\tsocialActivityLocalService.addActivity(\n\t\t\t\t\t\t\tuserId, entry.getGroupId(),\n\t\t\t\t\t\t\tBlogsEntry.class.getName(), classPK,\n\t\t\t\t\t\t\tBlogsActivityKeys.ADD_COMMENT, extraData.toString(),\n\t\t\t\t\t\t\tentry.getUserId());\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Subscriptions\n\n\t\t\t\tnotifySubscribers(message, serviceContext);\n\t\t\t}\n\n\t\t\t// Indexer\n\n\t\t\tif (!message.isDiscussion()) {\n\t\t\t\tindexer.reindex(message);\n\t\t\t}\n\n\t\t\t// Ping\n\n\t\t\tpingPingback(message, serviceContext);\n\t\t}\n\t\telse if ((oldStatus == WorkflowConstants.STATUS_APPROVED) &&\n\t\t\t\t (status != WorkflowConstants.STATUS_APPROVED)) {\n\n\t\t\t// Thread\n\n\t\t\tif ((category != null) &&\n\t\t\t\t(thread.getRootMessageId() == message.getMessageId())) {\n\n\t\t\t\tcategory.setThreadCount(category.getThreadCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\tthread.setMessageCount(thread.getMessageCount() - 1);\n\n\t\t\t// Category\n\n\t\t\tif (category != null) {\n\t\t\t\tcategory.setMessageCount(category.getMessageCount() - 1);\n\n\t\t\t\tmbCategoryPersistence.update(category, false);\n\t\t\t}\n\n\t\t\t// Asset\n\n\t\t\tassetEntryLocalService.updateVisible(\n\t\t\t\tmessage.getWorkflowClassName(), message.getMessageId(), false);\n\n\t\t\tif (!message.isDiscussion()) {\n\n\t\t\t\t// Indexer\n\n\t\t\t\tindexer.delete(message);\n\t\t\t}\n\t\t}\n\n\t\tif (status != oldStatus) {\n\t\t\tmbThreadPersistence.update(thread, false);\n\t\t}\n\n\t\t// Statistics\n\n\t\tif (!message.isDiscussion()) {\n\t\t\tmbStatsUserLocalService.updateStatsUser(\n\t\t\t\tmessage.getGroupId(), userId,\n\t\t\t\tserviceContext.getModifiedDate(now));\n\t\t}\n\n\t\treturn message;\n\t}","commit_id":"4dcf9d15248b884f0db08eb46528008a13f5064d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void sendBlogsCommentsEmail(\n\t\t\tlong userId, BlogsEntry entry, MBMessage message,\n\t\t\tServiceContext serviceContext)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tlong companyId = message.getCompanyId();\n\n\t\tif (!PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_ENABLED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tString layoutFullURL = serviceContext.getLayoutFullURL();\n\n\t\tString blogsEntryURL =\n\t\t\tlayoutFullURL + Portal.FRIENDLY_URL_SEPARATOR + \"blogs/\" +\n\t\t\t\tentry.getUrlTitle();\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_NAME);\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_SUBJECT);\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.BLOGS_EMAIL_COMMENTS_ADDED_BODY);\n\n\t\tsubject = StringUtil.replace(\n\t\t\tsubject,\n\t\t\tnew String[] {\n\t\t\t\t\"[$BLOGS_COMMENTS_BODY$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$BLOGS_ENTRY_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tblogsEntryURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$BLOGS_COMMENTS_BODY$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$BLOGS_COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$BLOGS_ENTRY_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tblogsEntryURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tList<MBMessage> messages = mbMessagePersistence.findByThreadId(\n\t\t\tmessage.getThreadId());\n\n\t\tfor (MBMessage curMessage : messages) {\n\t\t\tlong curMessageUserId = curMessage.getUserId();\n\n\t\t\tif (curMessageUserId == userId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (sent.contains(curMessageUserId)) {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Do not send a duplicate email to user \" +\n\t\t\t\t\t\t\tcurMessageUserId);\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t\t_log.debug(\n\t\t\t\t\t\t\"Add user \" + curMessageUserId +\n\t\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t\t}\n\n\t\t\t\tsent.add(curMessageUserId);\n\t\t\t}\n\n\t\t\tUser curMessageUser = null;\n\n\t\t\ttry {\n\t\t\t\tcurMessageUser = userLocalService.getUserById(curMessageUserId);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!curMessageUser.isActive()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tInternetAddress from = new InternetAddress(fromAddress, fromName);\n\n\t\t\tInternetAddress to = new InternetAddress(\n\t\t\t\tcurMessageUser.getEmailAddress(), curMessageUser.getFullName());\n\n\t\t\tString curSubject = StringUtil.replace(\n\t\t\t\tsubject,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tString curBody = StringUtil.replace(\n\t\t\t\tbody,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tMailMessage mailMessage = new MailMessage(\n\t\t\t\tfrom, to, curSubject, curBody, true);\n\n\t\t\tmailService.sendEmail(mailMessage);\n\t\t}\n\t}","id":67757,"modified_method":"protected void sendCommentsEmail(\n\t\t\tlong userId, MBMessage message, ServiceContext serviceContext)\n\t\tthrows IOException, PortalException, SystemException {\n\n\t\tlong companyId = message.getCompanyId();\n\n\t\tif (!PrefsPropsUtil.getBoolean(\n\t\t\t\tcompanyId, PropsKeys.DISCUSSION_EMAIL_COMMENTS_ADDED_ENABLED)) {\n\n\t\t\treturn;\n\t\t}\n\n\t\tString className =\n\t\t\t(String)serviceContext.getAttribute(\"className\");\n\t\tlong classPK =\n\t\t\tGetterUtil.getLong((String)serviceContext.getAttribute(\"classPK\"));\n\n\t\tString contentURL =\n\t\t\tserviceContext.getPortalURL().concat(\n\t\t\t\tserviceContext.getCurrentURL());\n\n\t\tUser user = userPersistence.findByPrimaryKey(userId);\n\n\t\tString fromName = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_NAME);\n\t\tString fromAddress = PrefsPropsUtil.getString(\n\t\t\tcompanyId, PropsKeys.ADMIN_EMAIL_FROM_ADDRESS);\n\n\t\tString subject = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.DISCUSSION_EMAIL_SUBJECT);\n\t\tString body = PrefsPropsUtil.getContent(\n\t\t\tcompanyId, PropsKeys.DISCUSSION_EMAIL_BODY);\n\n\t\tsubject = StringUtil.replace(\n\t\t\tsubject,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMMENTS_BODY$]\",\n\t\t\t\t\"[$COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$CONTENT_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tcontentURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tbody = StringUtil.replace(\n\t\t\tbody,\n\t\t\tnew String[] {\n\t\t\t\t\"[$COMMENTS_BODY$]\",\n\t\t\t\t\"[$COMMENTS_USER_ADDRESS$]\",\n\t\t\t\t\"[$COMMENTS_USER_NAME$]\",\n\t\t\t\t\"[$ASSET_URL$]\",\n\t\t\t\t\"[$FROM_ADDRESS$]\",\n\t\t\t\t\"[$FROM_NAME$]\"\n\t\t\t},\n\t\t\tnew String[] {\n\t\t\t\tmessage.getBody(),\n\t\t\t\tuser.getEmailAddress(),\n\t\t\t\tuser.getFullName(),\n\t\t\t\tcontentURL,\n\t\t\t\tfromAddress,\n\t\t\t\tfromName\n\t\t\t});\n\n\t\tSet<Long> sent = new HashSet<Long>();\n\n\t\tList<Subscription> subscriptions =\n\t\t\tSubscriptionLocalServiceUtil.getSubscriptions(\n\t\t\t\tcompanyId, className, classPK);\n\n\t\tfor (Subscription subscription : subscriptions) {\n\t\t\tlong subscriptorUserId = subscription.getUserId();\n\n\t\t\tif (subscriptorUserId == userId) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (_log.isDebugEnabled()) {\n\t\t\t\t_log.debug(\n\t\t\t\t\t\"Add user \" + subscriptorUserId +\n\t\t\t\t\t\t\" to the list of users who have received an email\");\n\t\t\t}\n\n\t\t\tsent.add(subscriptorUserId);\n\n\t\t\tUser curMessageUser = null;\n\n\t\t\ttry {\n\t\t\t\tcurMessageUser =\n\t\t\t\t\tuserLocalService.getUserById(subscriptorUserId);\n\t\t\t}\n\t\t\tcatch (NoSuchUserException nsue) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!curMessageUser.isActive()) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tInternetAddress from = new InternetAddress(fromAddress, fromName);\n\n\t\t\tInternetAddress to = new InternetAddress(\n\t\t\t\tcurMessageUser.getEmailAddress(), curMessageUser.getFullName());\n\n\t\t\tString curSubject = StringUtil.replace(\n\t\t\t\tsubject,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tString curBody = StringUtil.replace(\n\t\t\t\tbody,\n\t\t\t\tnew String[] {\n\t\t\t\t\t\"[$TO_ADDRESS$]\",\n\t\t\t\t\t\"[$TO_NAME$]\"\n\t\t\t\t},\n\t\t\t\tnew String[] {\n\t\t\t\t\tcurMessageUser.getFullName(),\n\t\t\t\t\tcurMessageUser.getEmailAddress()\n\t\t\t\t});\n\n\t\t\tMailMessage mailMessage = new MailMessage(\n\t\t\t\tfrom, to, curSubject, curBody, true);\n\n\t\t\tmailService.sendEmail(mailMessage);\n\t\t}\n\t}","commit_id":"4dcf9d15248b884f0db08eb46528008a13f5064d","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public ContentAssistResult createProposalsWithUpdate(final XtextWebDocumentAccess document, final String deltaText, final int deltaOffset, final int deltaReplaceLength, final ITextRegion textSelection, final int caretOffset) {\n    ContentAssistContextFactory _get = this.contextFactoryProvider.get();\n    final Procedure1<ContentAssistContextFactory> _function = new Procedure1<ContentAssistContextFactory>() {\n      @Override\n      public void apply(final ContentAssistContextFactory it) {\n        it.setPool(ContentAssistService.this.pool);\n      }\n    };\n    final ContentAssistContextFactory contextFactory = ObjectExtensions.<ContentAssistContextFactory>operator_doubleArrow(_get, _function);\n    final String[] stateIdWrapper = new String[1];\n    final CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument> _function_1 = new CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument>() {\n      @Override\n      public ContentAssistContext[] exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ContentAssistContext[] _xblockexpression = null;\n        {\n          it.setDirty(true);\n          it.setProcessingCompleted(false);\n          it.createNewStateId();\n          String _stateId = it.getStateId();\n          stateIdWrapper[0] = _stateId;\n          it.updateText(deltaText, deltaOffset, deltaReplaceLength);\n          String _text = it.getText();\n          XtextResource _resource = it.getResource();\n          _xblockexpression = contextFactory.create(_text, textSelection, caretOffset, _resource);\n        }\n        return _xblockexpression;\n      }\n    };\n    final CancelableUnitOfWork<Object, IXtextWebDocument> _function_2 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n      @Override\n      public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ContentAssistService.this.updateDocumentService.processUpdatedDocument(it, cancelIndicator);\n        return null;\n      }\n    };\n    XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_2);\n    final ContentAssistContext[] contexts = document.<ContentAssistContext[]>modify(_function_1, _xtextWorkerThread);\n    String _get_1 = stateIdWrapper[0];\n    return this.createProposals(contexts, _get_1);\n  }","id":67758,"modified_method":"public ContentAssistResult createProposalsWithUpdate(final XtextWebDocumentAccess document, final String deltaText, final int deltaOffset, final int deltaReplaceLength, final ITextRegion textSelection, final int caretOffset) {\n    this.LOG.trace(\"Xtext Service: createProposalsWithUpdate\");\n    ContentAssistContextFactory _get = this.contextFactoryProvider.get();\n    final Procedure1<ContentAssistContextFactory> _function = new Procedure1<ContentAssistContextFactory>() {\n      @Override\n      public void apply(final ContentAssistContextFactory it) {\n        it.setPool(ContentAssistService.this.pool);\n      }\n    };\n    final ContentAssistContextFactory contextFactory = ObjectExtensions.<ContentAssistContextFactory>operator_doubleArrow(_get, _function);\n    final String[] stateIdWrapper = new String[1];\n    final CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument> _function_1 = new CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument>() {\n      @Override\n      public ContentAssistContext[] exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ContentAssistContext[] _xblockexpression = null;\n        {\n          it.setDirty(true);\n          it.setProcessingCompleted(false);\n          it.createNewStateId();\n          String _stateId = it.getStateId();\n          stateIdWrapper[0] = _stateId;\n          it.updateText(deltaText, deltaOffset, deltaReplaceLength);\n          String _text = it.getText();\n          XtextResource _resource = it.getResource();\n          _xblockexpression = contextFactory.create(_text, textSelection, caretOffset, _resource);\n        }\n        return _xblockexpression;\n      }\n    };\n    final CancelableUnitOfWork<Object, IXtextWebDocument> _function_2 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n      @Override\n      public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ContentAssistService.this.updateDocumentService.processUpdatedDocument(it, cancelIndicator);\n        return null;\n      }\n    };\n    XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_2);\n    final ContentAssistContext[] contexts = document.<ContentAssistContext[]>modify(_function_1, _xtextWorkerThread);\n    String _get_1 = stateIdWrapper[0];\n    return this.createProposals(contexts, _get_1);\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public ContentAssistResult createProposals(final XtextWebDocumentAccess document, final ITextRegion selection, final int offset) throws InvalidRequestException {\n    ContentAssistContextFactory _get = this.contextFactoryProvider.get();\n    final Procedure1<ContentAssistContextFactory> _function = new Procedure1<ContentAssistContextFactory>() {\n      @Override\n      public void apply(final ContentAssistContextFactory it) {\n        it.setPool(ContentAssistService.this.pool);\n      }\n    };\n    final ContentAssistContextFactory contextFactory = ObjectExtensions.<ContentAssistContextFactory>operator_doubleArrow(_get, _function);\n    final CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument> _function_1 = new CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument>() {\n      @Override\n      public ContentAssistContext[] exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        String _text = it.getText();\n        XtextResource _resource = it.getResource();\n        return contextFactory.create(_text, selection, offset, _resource);\n      }\n    };\n    final CancelableUnitOfWork<Object, IXtextWebDocument> _function_2 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n      @Override\n      public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ContentAssistService.this.updateDocumentService.processUpdatedDocument(it, cancelIndicator);\n        return null;\n      }\n    };\n    XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_2);\n    final ContentAssistContext[] contexts = document.<ContentAssistContext[]>priorityReadOnly(_function_1, _xtextWorkerThread);\n    return this.createProposals(contexts, null);\n  }","id":67759,"modified_method":"public ContentAssistResult createProposals(final XtextWebDocumentAccess document, final ITextRegion selection, final int offset) throws InvalidRequestException {\n    this.LOG.trace(\"Xtext Service: createProposals\");\n    ContentAssistContextFactory _get = this.contextFactoryProvider.get();\n    final Procedure1<ContentAssistContextFactory> _function = new Procedure1<ContentAssistContextFactory>() {\n      @Override\n      public void apply(final ContentAssistContextFactory it) {\n        it.setPool(ContentAssistService.this.pool);\n      }\n    };\n    final ContentAssistContextFactory contextFactory = ObjectExtensions.<ContentAssistContextFactory>operator_doubleArrow(_get, _function);\n    final CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument> _function_1 = new CancelableUnitOfWork<ContentAssistContext[], IXtextWebDocument>() {\n      @Override\n      public ContentAssistContext[] exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        String _text = it.getText();\n        XtextResource _resource = it.getResource();\n        return contextFactory.create(_text, selection, offset, _resource);\n      }\n    };\n    final CancelableUnitOfWork<Object, IXtextWebDocument> _function_2 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n      @Override\n      public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ContentAssistService.this.updateDocumentService.processUpdatedDocument(it, cancelIndicator);\n        return null;\n      }\n    };\n    XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_2);\n    final ContentAssistContext[] contexts = document.<ContentAssistContext[]>priorityReadOnly(_function_1, _xtextWorkerThread);\n    return this.createProposals(contexts, null);\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public DocumentStateResult save(final XtextWebDocumentAccess document, final IServerResourceHandler resourceHandler) throws InvalidRequestException {\n    final CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument> _function = new CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument>() {\n      @Override\n      public DocumentStateResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        try {\n          resourceHandler.put(it);\n          it.setDirty(false);\n        } catch (final Throwable _t) {\n          if (_t instanceof IOException) {\n            final IOException ioe = (IOException)_t;\n            String _message = ioe.getMessage();\n            throw new InvalidRequestException(InvalidRequestException.Type.RESOURCE_NOT_FOUND, _message);\n          } else {\n            throw Exceptions.sneakyThrow(_t);\n          }\n        }\n        String _stateId = it.getStateId();\n        return new DocumentStateResult(_stateId);\n      }\n    };\n    return document.<DocumentStateResult>readOnly(_function);\n  }","id":67760,"modified_method":"public DocumentStateResult save(final XtextWebDocumentAccess document, final IServerResourceHandler resourceHandler) throws InvalidRequestException {\n    DocumentStateResult _xblockexpression = null;\n    {\n      this.LOG.trace(\"Xtext Service: save\");\n      final CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument> _function = new CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument>() {\n        @Override\n        public DocumentStateResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n          try {\n            resourceHandler.put(it);\n            it.setDirty(false);\n          } catch (final Throwable _t) {\n            if (_t instanceof IOException) {\n              final IOException ioe = (IOException)_t;\n              String _message = ioe.getMessage();\n              throw new InvalidRequestException(InvalidRequestException.Type.RESOURCE_NOT_FOUND, _message);\n            } else {\n              throw Exceptions.sneakyThrow(_t);\n            }\n          }\n          String _stateId = it.getStateId();\n          return new DocumentStateResult(_stateId);\n        }\n      };\n      _xblockexpression = document.<DocumentStateResult>readOnly(_function);\n    }\n    return _xblockexpression;\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public ResourceContentResult load(final String resourceId, final IServerResourceHandler resourceHandler, final ISessionStore sessionStore) throws InvalidRequestException {\n    ResourceContentResult _xblockexpression = null;\n    {\n      Pair<Class<XtextWebDocument>, String> _mappedTo = Pair.<Class<XtextWebDocument>, String>of(XtextWebDocument.class, resourceId);\n      final Function0<XtextWebDocument> _function = new Function0<XtextWebDocument>() {\n        @Override\n        public XtextWebDocument apply() {\n          try {\n            XtextWebDocument _xtrycatchfinallyexpression = null;\n            try {\n              _xtrycatchfinallyexpression = resourceHandler.get(resourceId);\n            } catch (final Throwable _t) {\n              if (_t instanceof IOException) {\n                final IOException ioe = (IOException)_t;\n                throw new InvalidRequestException(InvalidRequestException.Type.RESOURCE_NOT_FOUND, \"The requested resource was not found.\");\n              } else {\n                throw Exceptions.sneakyThrow(_t);\n              }\n            }\n            return _xtrycatchfinallyexpression;\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      final XtextWebDocument document = sessionStore.<XtextWebDocument>get(_mappedTo, _function);\n      XtextWebDocumentAccess _xtextWebDocumentAccess = new XtextWebDocumentAccess(document);\n      final CancelableUnitOfWork<ResourceContentResult, IXtextWebDocument> _function_1 = new CancelableUnitOfWork<ResourceContentResult, IXtextWebDocument>() {\n        @Override\n        public ResourceContentResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n          String _text = it.getText();\n          final ResourceContentResult result = new ResourceContentResult(_text);\n          boolean _isDirty = it.isDirty();\n          result.setDirty(_isDirty);\n          String _stateId = it.getStateId();\n          result.setStateId(_stateId);\n          return result;\n        }\n      };\n      _xblockexpression = _xtextWebDocumentAccess.<ResourceContentResult>readOnly(_function_1);\n    }\n    return _xblockexpression;\n  }","id":67761,"modified_method":"public ResourceContentResult load(final String resourceId, final IServerResourceHandler resourceHandler, final ISessionStore sessionStore) throws InvalidRequestException {\n    ResourceContentResult _xblockexpression = null;\n    {\n      this.LOG.trace(\"Xtext Service: load\");\n      Pair<Class<XtextWebDocument>, String> _mappedTo = Pair.<Class<XtextWebDocument>, String>of(XtextWebDocument.class, resourceId);\n      final Function0<XtextWebDocument> _function = new Function0<XtextWebDocument>() {\n        @Override\n        public XtextWebDocument apply() {\n          try {\n            XtextWebDocument _xtrycatchfinallyexpression = null;\n            try {\n              _xtrycatchfinallyexpression = resourceHandler.get(resourceId);\n            } catch (final Throwable _t) {\n              if (_t instanceof IOException) {\n                final IOException ioe = (IOException)_t;\n                throw new InvalidRequestException(InvalidRequestException.Type.RESOURCE_NOT_FOUND, \"The requested resource was not found.\");\n              } else {\n                throw Exceptions.sneakyThrow(_t);\n              }\n            }\n            return _xtrycatchfinallyexpression;\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        }\n      };\n      final XtextWebDocument document = sessionStore.<XtextWebDocument>get(_mappedTo, _function);\n      XtextWebDocumentAccess _xtextWebDocumentAccess = new XtextWebDocumentAccess(document);\n      final CancelableUnitOfWork<ResourceContentResult, IXtextWebDocument> _function_1 = new CancelableUnitOfWork<ResourceContentResult, IXtextWebDocument>() {\n        @Override\n        public ResourceContentResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n          String _text = it.getText();\n          final ResourceContentResult result = new ResourceContentResult(_text);\n          boolean _isDirty = it.isDirty();\n          result.setDirty(_isDirty);\n          String _stateId = it.getStateId();\n          result.setStateId(_stateId);\n          return result;\n        }\n      };\n      _xblockexpression = _xtextWebDocumentAccess.<ResourceContentResult>readOnly(_function_1);\n    }\n    return _xblockexpression;\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public ResourceContentResult revert(final String resourceId, final IServerResourceHandler resourceHandler, final ISessionStore sessionStore) throws InvalidRequestException {\n    try {\n      final XtextWebDocument document = resourceHandler.get(resourceId);\n      String _text = document.getText();\n      final ResourceContentResult result = new ResourceContentResult(_text);\n      String _stateId = document.getStateId();\n      result.setStateId(_stateId);\n      Pair<Class<XtextWebDocument>, String> _mappedTo = Pair.<Class<XtextWebDocument>, String>of(XtextWebDocument.class, resourceId);\n      sessionStore.put(_mappedTo, document);\n      return result;\n    } catch (final Throwable _t) {\n      if (_t instanceof IOException) {\n        final IOException ioe = (IOException)_t;\n        throw new InvalidRequestException(InvalidRequestException.Type.RESOURCE_NOT_FOUND, \"The requested resource was not found.\");\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n  }","id":67762,"modified_method":"public ResourceContentResult revert(final String resourceId, final IServerResourceHandler resourceHandler, final ISessionStore sessionStore) throws InvalidRequestException {\n    this.LOG.trace(\"Xtext Service: revert\");\n    try {\n      final XtextWebDocument document = resourceHandler.get(resourceId);\n      String _text = document.getText();\n      final ResourceContentResult result = new ResourceContentResult(_text);\n      String _stateId = document.getStateId();\n      result.setStateId(_stateId);\n      Pair<Class<XtextWebDocument>, String> _mappedTo = Pair.<Class<XtextWebDocument>, String>of(XtextWebDocument.class, resourceId);\n      sessionStore.put(_mappedTo, document);\n      return result;\n    } catch (final Throwable _t) {\n      if (_t instanceof IOException) {\n        final IOException ioe = (IOException)_t;\n        throw new InvalidRequestException(InvalidRequestException.Type.RESOURCE_NOT_FOUND, \"The requested resource was not found.\");\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public DocumentStateResult updateFullText(final XtextWebDocumentAccess document, final String fullText) throws InvalidRequestException {\n    final CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument> _function = new CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument>() {\n      @Override\n      public DocumentStateResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        it.setDirty(true);\n        it.setProcessingCompleted(false);\n        it.createNewStateId();\n        String _stateId = it.getStateId();\n        return new DocumentStateResult(_stateId);\n      }\n    };\n    final CancelableUnitOfWork<Object, IXtextWebDocument> _function_1 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n      @Override\n      public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        it.setText(fullText);\n        UpdateDocumentService.this.processUpdatedDocument(it, cancelIndicator);\n        return null;\n      }\n    };\n    XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_1);\n    return document.<DocumentStateResult>modify(_function, _xtextWorkerThread);\n  }","id":67763,"modified_method":"public DocumentStateResult updateFullText(final XtextWebDocumentAccess document, final String fullText) throws InvalidRequestException {\n    DocumentStateResult _xblockexpression = null;\n    {\n      this.LOG.trace(\"Xtext Service: updateFullText\");\n      final CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument> _function = new CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument>() {\n        @Override\n        public DocumentStateResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n          it.setDirty(true);\n          it.setProcessingCompleted(false);\n          it.createNewStateId();\n          String _stateId = it.getStateId();\n          return new DocumentStateResult(_stateId);\n        }\n      };\n      final CancelableUnitOfWork<Object, IXtextWebDocument> _function_1 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n        @Override\n        public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n          it.setText(fullText);\n          UpdateDocumentService.this.processUpdatedDocument(it, cancelIndicator);\n          return null;\n        }\n      };\n      XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_1);\n      _xblockexpression = document.<DocumentStateResult>modify(_function, _xtextWorkerThread);\n    }\n    return _xblockexpression;\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public DocumentStateResult updateDeltaText(final XtextWebDocumentAccess document, final String deltaText, final int offset, final int replaceLength) throws InvalidRequestException {\n    final CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument> _function = new CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument>() {\n      @Override\n      public DocumentStateResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        it.setDirty(true);\n        it.setProcessingCompleted(false);\n        it.createNewStateId();\n        String _stateId = it.getStateId();\n        return new DocumentStateResult(_stateId);\n      }\n    };\n    final CancelableUnitOfWork<Object, IXtextWebDocument> _function_1 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n      @Override\n      public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        it.updateText(deltaText, offset, replaceLength);\n        UpdateDocumentService.this.processUpdatedDocument(it, cancelIndicator);\n        return null;\n      }\n    };\n    XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_1);\n    return document.<DocumentStateResult>modify(_function, _xtextWorkerThread);\n  }","id":67764,"modified_method":"public DocumentStateResult updateDeltaText(final XtextWebDocumentAccess document, final String deltaText, final int offset, final int replaceLength) throws InvalidRequestException {\n    DocumentStateResult _xblockexpression = null;\n    {\n      this.LOG.trace(\"Xtext Service: updateDeltaText\");\n      final CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument> _function = new CancelableUnitOfWork<DocumentStateResult, IXtextWebDocument>() {\n        @Override\n        public DocumentStateResult exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n          it.setDirty(true);\n          it.setProcessingCompleted(false);\n          it.createNewStateId();\n          String _stateId = it.getStateId();\n          return new DocumentStateResult(_stateId);\n        }\n      };\n      final CancelableUnitOfWork<Object, IXtextWebDocument> _function_1 = new CancelableUnitOfWork<Object, IXtextWebDocument>() {\n        @Override\n        public Object exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n          it.updateText(deltaText, offset, replaceLength);\n          UpdateDocumentService.this.processUpdatedDocument(it, cancelIndicator);\n          return null;\n        }\n      };\n      XtextWorkerThread _xtextWorkerThread = new XtextWorkerThread(_function_1);\n      _xblockexpression = document.<DocumentStateResult>modify(_function, _xtextWorkerThread);\n    }\n    return _xblockexpression;\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public ValidationResult validate(final XtextWebDocumentAccess document) throws InvalidRequestException {\n    final CancelableUnitOfWork<Collection<Issue>, IXtextWebDocument> _function = new CancelableUnitOfWork<Collection<Issue>, IXtextWebDocument>() {\n      @Override\n      public Collection<Issue> exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ValidationService.this.updateDocumentService.processUpdatedDocument(it, cancelIndicator);\n        return it.getIssues();\n      }\n    };\n    final Collection<Issue> issues = document.<Collection<Issue>>readOnly(_function);\n    final ValidationResult result = new ValidationResult();\n    final Function1<Issue, Boolean> _function_1 = new Function1<Issue, Boolean>() {\n      @Override\n      public Boolean apply(final Issue it) {\n        Severity _severity = it.getSeverity();\n        return Boolean.valueOf((!Objects.equal(_severity, Severity.IGNORE)));\n      }\n    };\n    Iterable<Issue> _filter = IterableExtensions.<Issue>filter(issues, _function_1);\n    final Procedure1<Issue> _function_2 = new Procedure1<Issue>() {\n      @Override\n      public void apply(final Issue issue) {\n        ArrayList<ValidationResult.Entry> _entries = result.getEntries();\n        String _message = issue.getMessage();\n        Severity _severity = issue.getSeverity();\n        String _translate = ValidationService.this.translate(_severity);\n        Integer _lineNumber = issue.getLineNumber();\n        int _plus = ((_lineNumber).intValue() + 1);\n        Integer _offset = issue.getOffset();\n        Integer _offset_1 = issue.getOffset();\n        Integer _length = issue.getLength();\n        int _plus_1 = ((_offset_1).intValue() + (_length).intValue());\n        ValidationResult.Entry _entry = new ValidationResult.Entry(_message, _translate, Integer.valueOf(_plus), _offset, Integer.valueOf(_plus_1));\n        _entries.add(_entry);\n      }\n    };\n    IterableExtensions.<Issue>forEach(_filter, _function_2);\n    return result;\n  }","id":67765,"modified_method":"public ValidationResult validate(final XtextWebDocumentAccess document) throws InvalidRequestException {\n    this.LOG.trace(\"Xtext Service: validate\");\n    final CancelableUnitOfWork<Collection<Issue>, IXtextWebDocument> _function = new CancelableUnitOfWork<Collection<Issue>, IXtextWebDocument>() {\n      @Override\n      public Collection<Issue> exec(final IXtextWebDocument it, final CancelIndicator cancelIndicator) throws Exception {\n        ValidationService.this.updateDocumentService.processUpdatedDocument(it, cancelIndicator);\n        return it.getIssues();\n      }\n    };\n    final Collection<Issue> issues = document.<Collection<Issue>>readOnly(_function);\n    final ValidationResult result = new ValidationResult();\n    final Function1<Issue, Boolean> _function_1 = new Function1<Issue, Boolean>() {\n      @Override\n      public Boolean apply(final Issue it) {\n        Severity _severity = it.getSeverity();\n        return Boolean.valueOf((!Objects.equal(_severity, Severity.IGNORE)));\n      }\n    };\n    Iterable<Issue> _filter = IterableExtensions.<Issue>filter(issues, _function_1);\n    final Procedure1<Issue> _function_2 = new Procedure1<Issue>() {\n      @Override\n      public void apply(final Issue issue) {\n        ArrayList<ValidationResult.Entry> _entries = result.getEntries();\n        String _message = issue.getMessage();\n        Severity _severity = issue.getSeverity();\n        String _translate = ValidationService.this.translate(_severity);\n        Integer _lineNumber = issue.getLineNumber();\n        int _plus = ((_lineNumber).intValue() + 1);\n        Integer _offset = issue.getOffset();\n        Integer _offset_1 = issue.getOffset();\n        Integer _length = issue.getLength();\n        int _plus_1 = ((_offset_1).intValue() + (_length).intValue());\n        ValidationResult.Entry _entry = new ValidationResult.Entry(_message, _translate, Integer.valueOf(_plus), _offset, Integer.valueOf(_plus_1));\n        _entries.add(_entry);\n      }\n    };\n    IterableExtensions.<Issue>forEach(_filter, _function_2);\n    return result;\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n    try {\n      super.service(req, resp);\n    } catch (final Throwable _t) {\n      if (_t instanceof InvalidRequestException) {\n        final InvalidRequestException exception = (InvalidRequestException)_t;\n        int _switchResult = (int) 0;\n        InvalidRequestException.Type _type = exception.getType();\n        if (_type != null) {\n          switch (_type) {\n            case RESOURCE_NOT_FOUND:\n              _switchResult = 404;\n              break;\n            case INVALID_DOCUMENT_STATE:\n              _switchResult = 409;\n              break;\n            default:\n              _switchResult = 400;\n              break;\n          }\n        } else {\n          _switchResult = 400;\n        }\n        final int statusCode = _switchResult;\n        String _message = exception.getMessage();\n        resp.sendError(statusCode, _message);\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n  }","id":67766,"modified_method":"@Override\n  protected void service(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException {\n    try {\n      super.service(req, resp);\n    } catch (final Throwable _t) {\n      if (_t instanceof InvalidRequestException) {\n        final InvalidRequestException exception = (InvalidRequestException)_t;\n        String _message = exception.getMessage();\n        String _plus = (\"Invalid Xtext Request: \" + _message);\n        this.LOG.trace(_plus);\n        int _switchResult = (int) 0;\n        InvalidRequestException.Type _type = exception.getType();\n        if (_type != null) {\n          switch (_type) {\n            case RESOURCE_NOT_FOUND:\n              _switchResult = 404;\n              break;\n            case INVALID_DOCUMENT_STATE:\n              _switchResult = 409;\n              break;\n            default:\n              _switchResult = 400;\n              break;\n          }\n        } else {\n          _switchResult = 400;\n        }\n        final int statusCode = _switchResult;\n        String _message_1 = exception.getMessage();\n        resp.sendError(statusCode, _message_1);\n      } else {\n        throw Exceptions.sneakyThrow(_t);\n      }\n    }\n  }","commit_id":"1196dd44028d871f6a8f028501808f113e573b8f","url":"https://github.com/eclipse/xtext"},{"original_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test for org.eclipse.xtext.ui.common.tests\");\n\t\t// $JUnit-BEGIN$\n\t\tsuite.addTestSuite(DefaultContentAssistProcessorTest.class);\n\n\t\tsuite.addTestSuite(DefaultSemanticModelTransformerTest.class);\n\t\t// $JUnit-END$\n\t\treturn suite;\n\t}","id":67767,"modified_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test for org.eclipse.xtext.ui.common.tests\");\n\t\t// $JUnit-BEGIN$\n\t\tsuite.addTestSuite(DefaultContentAssistProcessorTest.class);\n\t\tsuite.addTestSuite(DefaultSemanticModelTransformerTest.class);\n\t\tsuite.addTestSuite(HyperlinkHelperTest.class);\n\t\t// $JUnit-END$\n\t\treturn suite;\n\t}","commit_id":"b81822043e2220fedb396c80066c27ef5f12bea5","url":"https://github.com/eclipse/xtext"},{"original_method":"public Object execute(ExecutionEvent event) throws ExecutionException {\n\t\tXtextEditor activeEditor = (XtextEditor) HandlerUtil.getActiveEditor(event);\n\t\tfinal IXtextDocument document = activeEditor.getDocument();\n\t\tfinal int offset = ((StyledText) activeEditor.getAdapter(Control.class)).getCaretOffset();\n\t\tdocument.readOnly(new UnitOfWork<Object>() {\n\t\t\tpublic Object exec(XtextResource resource) throws Exception {\n\t\t\t\tAbstractNode node = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(resource\n\t\t\t\t\t\t.getParseResult().getRootNode(), offset);\n\t\t\t\tList<EObject> crossLinkedEObject = findCrossLinkedEObject(node);\n\t\t\t\tif (crossLinkedEObject.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tURI uri = EcoreUtil.getURI(crossLinkedEObject.get(0));\n\t\t\t\tnew OpenDeclarationAction(uri, locationProvider).run();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}","id":67768,"modified_method":"public Object execute(ExecutionEvent event) throws ExecutionException {\n\t\tXtextEditor activeEditor = (XtextEditor) HandlerUtil.getActiveEditor(event);\n\t\tfinal IXtextDocument document = activeEditor.getDocument();\n\t\tfinal int offset = ((StyledText) activeEditor.getAdapter(Control.class)).getCaretOffset();\n\t\tdocument.readOnly(new UnitOfWork<Object>() {\n\t\t\tpublic Void exec(XtextResource resource) throws Exception {\n\t\t\t\tOpenDeclarationAction action = helper.getOpenDeclarationAction(resource, offset);\n\t\t\t\taction.run();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}","commit_id":"b81822043e2220fedb396c80066c27ef5f12bea5","url":"https://github.com/eclipse/xtext"},{"original_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\tAbstractNode abstractNode = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(parseResult.getRootNode(),\n\t\t\t\t\t\tregion.getOffset());\n\t\t\t\tfinal Region location = new Region(abstractNode.getOffset(), abstractNode.getLength());\n\t\t\t\tList<EObject> crossLinkedEObjects = findCrossLinkedEObject(abstractNode);\n\t\t\t\tif (crossLinkedEObjects.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tList<IHyperlink> links = new ArrayList<IHyperlink>();\n\t\t\t\tfor (EObject crossReffed : crossLinkedEObjects) {\n\t\t\t\t\tfinal String label = labelProvider.getText(crossReffed);\n\t\t\t\t\tfinal URI uri = EcoreUtil.getURI(crossReffed);\n\t\t\t\t\tfinal URI normalized = crossReffed.eResource().getResourceSet().getURIConverter().normalize(uri);\n\t\t\t\t\tlinks.add(new IHyperlink() {\n\n\t\t\t\t\t\t\tpublic IRegion getHyperlinkRegion() {\n\t\t\t\t\t\t\t\treturn location;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getHyperlinkText() {\n\t\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getTypeLabel() {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic void open() {\n\t\t\t\t\t\t\t\tnew OpenDeclarationAction(normalized, locationProvider).run();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn links.toArray(new IHyperlink[links.size()]);\n\t\t\t}\n\t\t});\n\t}","id":67769,"modified_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, final boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\treturn helper.createHyperlinksByOffset(resource, region.getOffset(), canShowMultipleHyperlinks);\n\t\t\t}\n\t\t});\n\t}","commit_id":"b81822043e2220fedb396c80066c27ef5f12bea5","url":"https://github.com/eclipse/xtext"},{"original_method":"private List<CLICommand> discover(final Hudson hudson) {\n        LOGGER.fine(\"Listing up @CLIMethod\");\n        List<CLICommand> r = new ArrayList<CLICommand>();\n\n        try {\n            for ( final Method m : Util.filter(Index.list(CLIMethod.class, hudson.getPluginManager().uberClassLoader),Method.class)) {\n                try {\n                    // command name\n                    final String name = m.getAnnotation(CLIMethod.class).name();\n\n                    final ResourceBundleHolder res = loadMessageBundle(m);\n                    res.format(\"CLI.\"+name+\".shortDescription\");   // make sure we have the resource, to fail early\n\n                    r.add(new CloneableCLICommand() {\n                        @Override\n                        public String getName() {\n                            return name;\n                        }\n\n                        public String getShortDescription() {\n                            // format by using the right locale\n                            return res.format(\"CLI.\"+name+\".shortDescription\");\n                        }\n\n                        @Override\n                        public int main(List<String> args, Locale locale, InputStream stdin, PrintStream stdout, PrintStream stderr) {\n                            CmdLineParser parser = new CmdLineParser(null);\n                            try {\n                                SecurityContext sc = SecurityContextHolder.getContext();\n                                Authentication old = sc.getAuthentication();\n                                try {\n                                    //  build up the call sequence\n                                    Stack<Method> chains = new Stack<Method>();\n                                    Method method = m;\n                                    while (true) {\n                                        chains.push(method);\n                                        if (Modifier.isStatic(method.getModifiers()))\n                                            break; // the chain is complete.\n\n                                        // the method in question is an instance method, so we need to resolve the instance by using another resolver\n                                        Class<?> type = method.getDeclaringClass();\n                                        method = findResolver(type);\n                                        if (method==null) {\n                                            stderr.println(\"Unable to find the resolver method annotated with @CLIResolver for \"+type);\n                                            return 1;\n                                        }\n                                    }\n\n                                    List<MethodBinder> binders = new ArrayList<MethodBinder>();\n\n                                    while (!chains.isEmpty())\n                                        binders.add(new MethodBinder(chains.pop(),parser));\n\n                                    // authentication\n                                    CliAuthenticator authenticator = Hudson.getInstance().getSecurityRealm().createCliAuthenticator(this);\n                                    new ClassParser().parse(authenticator,parser);\n\n                                    // fill up all the binders\n                                    parser.parseArgument(args);\n\n                                    sc.setAuthentication(authenticator.authenticate()); // run the CLI with the right credential\n\n                                    // resolve them\n                                    Object instance = null;\n                                    for (MethodBinder binder : binders)\n                                        instance = binder.call(instance);\n\n                                    if (instance instanceof Integer)\n                                        return (Integer) instance;\n                                    else\n                                        return 0;\n                                } catch (InvocationTargetException e) {\n                                    Throwable t = e.getTargetException();\n                                    if (t instanceof Exception)\n                                        throw (Exception) t;\n                                    throw e;\n                                } finally {\n                                    sc.setAuthentication(old); // restore\n                                }\n                            } catch (CmdLineException e) {\n                                stderr.println(e.getMessage());\n                                printUsage(stderr,parser);\n                                return 1;\n                            } catch (Exception e) {\n                                e.printStackTrace(stderr);\n                                return 1;\n                            }\n                        }\n\n                        protected int run() throws Exception {\n                            throw new UnsupportedOperationException();\n                        }\n                    });\n                } catch (ClassNotFoundException e) {\n                    LOGGER.log(SEVERE,\"Failed to process @CLIMethod: \"+m,e);\n                }\n            }\n        } catch (IOException e) {\n            LOGGER.log(SEVERE, \"Failed to discvoer @CLIMethod\",e);\n        }\n\n        return r;\n    }","id":67770,"modified_method":"private List<ExtensionComponent<CLICommand>> discover(final Hudson hudson) {\n        LOGGER.fine(\"Listing up @CLIMethod\");\n        List<ExtensionComponent<CLICommand>> r = new ArrayList<ExtensionComponent<CLICommand>>();\n\n        try {\n            for ( final Method m : Util.filter(Index.list(CLIMethod.class, hudson.getPluginManager().uberClassLoader),Method.class)) {\n                try {\n                    // command name\n                    final String name = m.getAnnotation(CLIMethod.class).name();\n\n                    final ResourceBundleHolder res = loadMessageBundle(m);\n                    res.format(\"CLI.\"+name+\".shortDescription\");   // make sure we have the resource, to fail early\n\n                    r.add(new ExtensionComponent<CLICommand>(new CloneableCLICommand() {\n                        @Override\n                        public String getName() {\n                            return name;\n                        }\n\n                        public String getShortDescription() {\n                            // format by using the right locale\n                            return res.format(\"CLI.\"+name+\".shortDescription\");\n                        }\n\n                        @Override\n                        public int main(List<String> args, Locale locale, InputStream stdin, PrintStream stdout, PrintStream stderr) {\n                            CmdLineParser parser = new CmdLineParser(null);\n                            try {\n                                SecurityContext sc = SecurityContextHolder.getContext();\n                                Authentication old = sc.getAuthentication();\n                                try {\n                                    //  build up the call sequence\n                                    Stack<Method> chains = new Stack<Method>();\n                                    Method method = m;\n                                    while (true) {\n                                        chains.push(method);\n                                        if (Modifier.isStatic(method.getModifiers()))\n                                            break; // the chain is complete.\n\n                                        // the method in question is an instance method, so we need to resolve the instance by using another resolver\n                                        Class<?> type = method.getDeclaringClass();\n                                        method = findResolver(type);\n                                        if (method==null) {\n                                            stderr.println(\"Unable to find the resolver method annotated with @CLIResolver for \"+type);\n                                            return 1;\n                                        }\n                                    }\n\n                                    List<MethodBinder> binders = new ArrayList<MethodBinder>();\n\n                                    while (!chains.isEmpty())\n                                        binders.add(new MethodBinder(chains.pop(),parser));\n\n                                    // authentication\n                                    CliAuthenticator authenticator = Hudson.getInstance().getSecurityRealm().createCliAuthenticator(this);\n                                    new ClassParser().parse(authenticator,parser);\n\n                                    // fill up all the binders\n                                    parser.parseArgument(args);\n\n                                    sc.setAuthentication(authenticator.authenticate()); // run the CLI with the right credential\n\n                                    // resolve them\n                                    Object instance = null;\n                                    for (MethodBinder binder : binders)\n                                        instance = binder.call(instance);\n\n                                    if (instance instanceof Integer)\n                                        return (Integer) instance;\n                                    else\n                                        return 0;\n                                } catch (InvocationTargetException e) {\n                                    Throwable t = e.getTargetException();\n                                    if (t instanceof Exception)\n                                        throw (Exception) t;\n                                    throw e;\n                                } finally {\n                                    sc.setAuthentication(old); // restore\n                                }\n                            } catch (CmdLineException e) {\n                                stderr.println(e.getMessage());\n                                printUsage(stderr,parser);\n                                return 1;\n                            } catch (Exception e) {\n                                e.printStackTrace(stderr);\n                                return 1;\n                            }\n                        }\n\n                        protected int run() throws Exception {\n                            throw new UnsupportedOperationException();\n                        }\n                    }));\n                } catch (ClassNotFoundException e) {\n                    LOGGER.log(SEVERE,\"Failed to process @CLIMethod: \"+m,e);\n                }\n            }\n        } catch (IOException e) {\n            LOGGER.log(SEVERE, \"Failed to discvoer @CLIMethod\",e);\n        }\n\n        return r;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"public <T> Collection<T> findExtensions(Class<T> type, Hudson hudson) {\n        if (type==CLICommand.class)\n            return (List<T>)discover(hudson);\n        else\n            return Collections.emptyList();\n    }","id":67771,"modified_method":"public <T> Collection<ExtensionComponent<T>> find(Class<T> type, Hudson hudson) {\n        if (type==CLICommand.class)\n            return (List)discover(hudson);\n        else\n            return Collections.emptyList();\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Loading the descriptors in this case means filtering the descriptor from the master {@link ExtensionList}.\n     */\n    @Override\n    protected List<D> load() {\n        List r = new ArrayList();\n        for( Descriptor d : hudson.getExtensionList(Descriptor.class) ) {\n            Type subTyping = Types.getBaseClass(d.getClass(), Descriptor.class);\n            if (!(subTyping instanceof ParameterizedType)) {\n                LOGGER.severe(d.getClass()+\" doesn't extend Descriptor with a type parameter\");\n                continue;   // skip this one\n            }\n            if(Types.erasure(Types.getTypeArgument(subTyping,0))==(Class)describableType)\n                r.add(d);\n        }\n        return r;\n    }","id":67772,"modified_method":"/**\n     * Loading the descriptors in this case means filtering the descriptor from the master {@link ExtensionList}.\n     */\n    @Override\n    protected List<ExtensionComponent<D>> load() {\n        List<ExtensionComponent<D>> r = new ArrayList<ExtensionComponent<D>>();\n        for( ExtensionComponent<Descriptor> c : hudson.getExtensionList(Descriptor.class).getComponents() ) {\n            Descriptor d = c.getInstance();\n            Type subTyping = Types.getBaseClass(d.getClass(), Descriptor.class);\n            if (!(subTyping instanceof ParameterizedType)) {\n                LOGGER.severe(d.getClass()+\" doesn't extend Descriptor with a type parameter\");\n                continue;   // skip this one\n            }\n            if(Types.erasure(Types.getTypeArgument(subTyping,0))==(Class)describableType)\n                r.add((ExtensionComponent)c);\n        }\n        return r;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected DescriptorExtensionList(Hudson hudson, Class<T> describableType) {\n        super(hudson, (Class)Descriptor.class, legacyDescriptors.get(describableType));\n        this.describableType = describableType;\n    }","id":67773,"modified_method":"protected DescriptorExtensionList(Hudson hudson, Class<T> describableType) {\n        super(hudson, (Class)Descriptor.class, (CopyOnWriteArrayList)getLegacyDescriptors(describableType));\n        this.describableType = describableType;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * List up all the legacy instances currently in use.\n     */\n    public static Iterable<Descriptor> listLegacyInstances() {\n        return new Iterable<Descriptor>() {\n            public Iterator<Descriptor> iterator() {\n                return new FlattenIterator<Descriptor,CopyOnWriteArrayList>(legacyDescriptors.values()) {\n                    protected Iterator expand(CopyOnWriteArrayList v) {\n                        return v.iterator();\n                    }\n                };\n            }\n        };\n    }","id":67774,"modified_method":"/**\n     * List up all the legacy instances currently in use.\n     */\n    public static Iterable<Descriptor> listLegacyInstances() {\n        return new Iterable<Descriptor>() {\n            public Iterator<Descriptor> iterator() {\n                return new AdaptedIterator<ExtensionComponent<Descriptor>,Descriptor>(\n                    new FlattenIterator<ExtensionComponent<Descriptor>,CopyOnWriteArrayList<ExtensionComponent<Descriptor>>>(legacyDescriptors.values()) {\n                        protected Iterator<ExtensionComponent<Descriptor>> expand(CopyOnWriteArrayList<ExtensionComponent<Descriptor>> v) {\n                            return v.iterator();\n                        }\n                    }) {\n\n                    protected Descriptor adapt(ExtensionComponent<Descriptor> item) {\n                        return item.getInstance();\n                    }\n                };\n            }\n        };\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Discover extensions of the given type.\n     *\n     * <p>\n     * This method is called only once per the given type after all the plugins are loaded,\n     * so implementations need not worry about caching.\n     *\n     * @param <T>\n     *      The type of the extension points. This is not bound to {@link ExtensionPoint} because\n     *      of {@link Descriptor}, which by itself doesn't implement {@link ExtensionPoint} for\n     *      a historical reason.\n     * @param hudson\n     *      Hudson whose behalf this extension finder is performing lookup.\n     * @return\n     *      Can be empty but never null.\n     */\n    public abstract <T> Collection<T> findExtensions(Class<T> type, Hudson hudson);","id":67775,"modified_method":"/**\n     * @deprecated as of 1.356\n     *      Use and implement {@link #find(Class, Hudson)} that allows us to put some metadata.\n     */\n    @Restricted(NoExternalUse.class)\n    public <T> Collection<T> findExtensions(Class<T> type, Hudson hudson) {\n        return Collections.emptyList();\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"public <T> Collection<T> findExtensions(Class<T> type, Hudson hudson) {\n            List<T> result = new ArrayList<T>();\n\n            ClassLoader cl = hudson.getPluginManager().uberClassLoader;\n            for (IndexItem<Extension,Object> item : Index.load(Extension.class, Object.class, cl)) {\n                try {\n                    AnnotatedElement e = item.element();\n                    Class<?> extType;\n                    if (e instanceof Class) {\n                        extType = (Class) e;\n                    } else\n                    if (e instanceof Field) {\n                        extType = ((Field)e).getType();\n                    } else\n                    if (e instanceof Method) {\n                        extType = ((Method)e).getReturnType();\n                    } else\n                        throw new AssertionError();\n\n                    if(type.isAssignableFrom(extType)) {\n                        Object instance = item.instance();\n                        if(instance!=null)\n                            result.add(type.cast(instance));\n                    }\n                } catch (InstantiationException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to load \"+item.className(),e);\n                } catch (LinkageError e) {\n                    // work around for SEZPOZ-11: https://sezpoz.dev.java.net/issues/show_bug.cgi?id=11\n                    LOGGER.log(Level.WARNING, \"Failed to load \"+item.className(),e);\n                }\n            }\n\n            return result;\n        }","id":67776,"modified_method":"public <T> Collection<ExtensionComponent<T>> find(Class<T> type, Hudson hudson) {\n            List<ExtensionComponent<T>> result = new ArrayList<ExtensionComponent<T>>();\n\n            ClassLoader cl = hudson.getPluginManager().uberClassLoader;\n            for (IndexItem<Extension,Object> item : Index.load(Extension.class, Object.class, cl)) {\n                try {\n                    AnnotatedElement e = item.element();\n                    Class<?> extType;\n                    if (e instanceof Class) {\n                        extType = (Class) e;\n                    } else\n                    if (e instanceof Field) {\n                        extType = ((Field)e).getType();\n                    } else\n                    if (e instanceof Method) {\n                        extType = ((Method)e).getReturnType();\n                    } else\n                        throw new AssertionError();\n\n                    if(type.isAssignableFrom(extType)) {\n                        Object instance = item.instance();\n                        if(instance!=null)\n                            result.add(new ExtensionComponent<T>(type.cast(instance),item.annotation()));\n                    }\n                } catch (InstantiationException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to load \"+item.className(),e);\n                } catch (LinkageError e) {\n                    // work around for SEZPOZ-11: https://sezpoz.dev.java.net/issues/show_bug.cgi?id=11\n                    LOGGER.log(Level.WARNING, \"Failed to load \"+item.className(),e);\n                }\n            }\n\n            return result;\n        }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public synchronized boolean remove(Object o) {\n        legacyInstances.remove(o);\n        if(extensions!=null) {\n            List<T> r = new ArrayList<T>(extensions);\n            r.remove(o);\n            extensions = sort(r);\n        }\n        return true;\n    }","id":67777,"modified_method":"@Override\n    public synchronized boolean remove(Object o) {\n        legacyInstances.remove(o);\n        if(extensions!=null) {\n            List<ExtensionComponent<T>> r = new ArrayList<ExtensionComponent<T>>(extensions);\n\n            for (Iterator<ExtensionComponent<T>> itr = r.iterator(); itr.hasNext();) {\n                ExtensionComponent<T> c = itr.next();\n                if (c.getInstance().equals(o))\n                    itr.remove();\n            }\n            r.remove(o);\n            extensions = sort(r);\n        }\n        return true;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"private List<T> ensureLoaded() {\n        if(extensions!=null)\n            return extensions; // already loaded\n        if(Hudson.getInstance().getInitLevel().compareTo(InitMilestone.PLUGINS_PREPARED)<0)\n            return legacyInstances; // can't perform the auto discovery until all plugins are loaded, so just make the legacy instances visible\n\n        synchronized (this) {\n            if(extensions==null) {\n                List<T> r = load();\n                r.addAll(legacyInstances);\n                extensions = sort(r);\n            }\n            return extensions;\n        }\n    }","id":67778,"modified_method":"private List<ExtensionComponent<T>> ensureLoaded() {\n        if(extensions!=null)\n            return extensions; // already loaded\n        if(Hudson.getInstance().getInitLevel().compareTo(InitMilestone.PLUGINS_PREPARED)<0)\n            return legacyInstances; // can't perform the auto discovery until all plugins are loaded, so just make the legacy instances visible\n\n        synchronized (this) {\n            if(extensions==null) {\n                List<ExtensionComponent<T>> r = load();\n                r.addAll(legacyInstances);\n                extensions = sort(r);\n            }\n            return extensions;\n        }\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public Iterator<T> iterator() {\n        // we need to intercept mutation, so for now don't allow Iterator.remove \n        return Iterators.readOnly(ensureLoaded().iterator());\n    }","id":67779,"modified_method":"@Override\n    public Iterator<T> iterator() {\n        // we need to intercept mutation, so for now don't allow Iterator.remove \n        return new AdaptedIterator<ExtensionComponent<T>,T>(Iterators.readOnly(ensureLoaded().iterator())) {\n            protected T adapt(ExtensionComponent<T> item) {\n                return item.getInstance();\n            }\n        };\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected ExtensionList(Hudson hudson, Class<T> extensionType) {\n        this(hudson,extensionType,new CopyOnWriteArrayList<T>());\n    }","id":67780,"modified_method":"protected ExtensionList(Hudson hudson, Class<T> extensionType) {\n        this(hudson,extensionType,new CopyOnWriteArrayList<ExtensionComponent<T>>());\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     *\n     * @param legacyStore\n     *      Place to store manually registered instances. The version of the constructor that\n     *      omits this uses a new {@link Vector}, making the storage lifespan tied to the life of  {@link ExtensionList}.\n     *      If the manually registered instances are scoped to VM level, the caller should pass in a static list. \n     */\n    protected ExtensionList(Hudson hudson, Class<T> extensionType, CopyOnWriteArrayList<T> legacyStore) {\n        this.hudson = hudson;\n        this.extensionType = extensionType;\n        this.legacyInstances = legacyStore;\n    }","id":67781,"modified_method":"/**\n     *\n     * @param legacyStore\n     *      Place to store manually registered instances. The version of the constructor that\n     *      omits this uses a new {@link Vector}, making the storage lifespan tied to the life of  {@link ExtensionList}.\n     *      If the manually registered instances are scoped to VM level, the caller should pass in a static list. \n     */\n    protected ExtensionList(Hudson hudson, Class<T> extensionType, CopyOnWriteArrayList<ExtensionComponent<T>> legacyStore) {\n        this.hudson = hudson;\n        this.extensionType = extensionType;\n        this.legacyInstances = legacyStore;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Write access will put the instance into a legacy store.\n     *\n     * @deprecated since 2009-02-23.\n     *      Prefer automatic registration.\n     */\n    @Override\n    public synchronized boolean add(T t) {\n        legacyInstances.add(t);\n        // if we've already filled extensions, add it\n        if(extensions!=null) {\n            List<T> r = new ArrayList<T>(extensions);\n            r.add(t);\n            extensions = sort(r);\n        }\n        return true;\n    }","id":67782,"modified_method":"/**\n     * Write access will put the instance into a legacy store.\n     *\n     * @deprecated since 2009-02-23.\n     *      Prefer automatic registration.\n     */\n    @Override\n    public synchronized boolean add(T t) {\n        legacyInstances.add(new ExtensionComponent<T>(t));\n        // if we've already filled extensions, add it\n        if(extensions!=null) {\n            List<ExtensionComponent<T>> r = new ArrayList<ExtensionComponent<T>>(extensions);\n            r.add(new ExtensionComponent<T>(t));\n            extensions = sort(r);\n        }\n        return true;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Loads all the extensions.\n     */\n    protected List<T> load() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.log(Level.FINE,\"Loading ExtensionList: \"+extensionType, new Throwable());\n\n        List<T> r = new ArrayList<T>();\n        for (ExtensionFinder finder : finders())\n            r.addAll(finder.findExtensions(extensionType, hudson));\n        return r;\n    }","id":67783,"modified_method":"/**\n     * Loads all the extensions.\n     */\n    protected List<ExtensionComponent<T>> load() {\n        if (LOGGER.isLoggable(Level.FINE))\n            LOGGER.log(Level.FINE,\"Loading ExtensionList: \"+extensionType, new Throwable());\n\n        List<ExtensionComponent<T>> r = new ArrayList<ExtensionComponent<T>>();\n        for (ExtensionFinder finder : finders()) {\n            try {\n                r.addAll(finder.find(extensionType, hudson));\n            } catch (AbstractMethodError e) {\n                // backward compatibility\n                for (T t : finder.findExtensions(extensionType, hudson))\n                    r.add(new ExtensionComponent<T>(t));\n            }\n        }\n        return r;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"public T get(int index) {\n        return ensureLoaded().get(index);\n    }","id":67784,"modified_method":"public T get(int index) {\n        return ensureLoaded().get(index).getInstance();\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"public int compare(Descriptor<Publisher> lhs, Descriptor<Publisher> rhs) {\n            return classify(lhs)-classify(rhs);\n        }","id":67785,"modified_method":"public int compare(ExtensionComponent<Descriptor<Publisher>> lhs, ExtensionComponent<Descriptor<Publisher>> rhs) {\n            int r = classify(lhs.getInstance())-classify(rhs.getInstance());\n            if (r!=0)   return r;\n            return lhs.compareTo(rhs);\n        }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n        protected List<Descriptor<Publisher>> sort(List<Descriptor<Publisher>> r) {\n            List<Descriptor<Publisher>> copy = new ArrayList<Descriptor<Publisher>>(r);\n            Collections.sort(copy,this);\n            return copy;\n        }","id":67786,"modified_method":"@Override\n        protected List<ExtensionComponent<Descriptor<Publisher>>> sort(List<ExtensionComponent<Descriptor<Publisher>>> r) {\n            List<ExtensionComponent<Descriptor<Publisher>>> copy = new ArrayList<ExtensionComponent<Descriptor<Publisher>>>(r);\n            Collections.sort(copy,this);\n            return copy;\n        }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"@Override\n    public <T> Collection<T> findExtensions(Class<T> type, Hudson hudson) {\n        TestEnvironment env = TestEnvironment.get();\n\n        List<T> result = new ArrayList<T>();\n\n        ClassLoader cl = hudson.getPluginManager().uberClassLoader;\n        for (IndexItem<TestExtension,Object> item : Index.load(TestExtension.class, Object.class, cl)) {\n            try {\n                AnnotatedElement e = item.element();\n                Class<?> extType;\n                if (e instanceof Class) {\n                    extType = (Class) e;\n                    if (!isActive(env, extType)) continue;\n                } else\n                if (e instanceof Field) {\n                    Field f = (Field) e;\n                    if (!f.getDeclaringClass().isInstance(env.testCase))\n                        continue;      // not executing the enclosing test\n                    extType = f.getType();\n                } else\n                if (e instanceof Method) {\n                    Method m = (Method) e;\n                    if (!m.getDeclaringClass().isInstance(env.testCase))\n                        continue;      // not executing the enclosing test\n                    extType = m.getReturnType();\n                } else\n                    throw new AssertionError();\n\n                String testName = item.annotation().value();\n                if (testName.length()>0 && !env.testCase.getName().equals(testName))\n                    continue;   // doesn't apply to this test\n\n                if(type.isAssignableFrom(extType)) {\n                    Object instance = item.instance();\n                    if(instance!=null)\n                        result.add(type.cast(instance));\n                }\n            } catch (InstantiationException e) {\n                LOGGER.log(Level.WARNING, \"Failed to load \"+item.className(),e);\n            }\n        }\n\n        return result;\n    }","id":67787,"modified_method":"@Override\n    public <T> Collection<ExtensionComponent<T>> find(Class<T> type, Hudson hudson) {\n        TestEnvironment env = TestEnvironment.get();\n\n        List<ExtensionComponent<T>> result = new ArrayList<ExtensionComponent<T>>();\n\n        ClassLoader cl = hudson.getPluginManager().uberClassLoader;\n        for (IndexItem<TestExtension,Object> item : Index.load(TestExtension.class, Object.class, cl)) {\n            try {\n                AnnotatedElement e = item.element();\n                Class<?> extType;\n                if (e instanceof Class) {\n                    extType = (Class) e;\n                    if (!isActive(env, extType)) continue;\n                } else\n                if (e instanceof Field) {\n                    Field f = (Field) e;\n                    if (!f.getDeclaringClass().isInstance(env.testCase))\n                        continue;      // not executing the enclosing test\n                    extType = f.getType();\n                } else\n                if (e instanceof Method) {\n                    Method m = (Method) e;\n                    if (!m.getDeclaringClass().isInstance(env.testCase))\n                        continue;      // not executing the enclosing test\n                    extType = m.getReturnType();\n                } else\n                    throw new AssertionError();\n\n                String testName = item.annotation().value();\n                if (testName.length()>0 && !env.testCase.getName().equals(testName))\n                    continue;   // doesn't apply to this test\n\n                if(type.isAssignableFrom(extType)) {\n                    Object instance = item.instance();\n                    if(instance!=null)\n                        result.add(new ExtensionComponent<T>(type.cast(instance)));\n                }\n            } catch (InstantiationException e) {\n                LOGGER.log(Level.WARNING, \"Failed to load \"+item.className(),e);\n            }\n        }\n\n        return result;\n    }","commit_id":"000a7c33b1995b3219b6df2ec09dffd712710904","url":"https://github.com/kohsuke/hudson"},{"original_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test for org.eclipse.xtext.ui.common.tests\");\n\t\t// $JUnit-BEGIN$\n\t\tsuite.addTestSuite(DefaultContentAssistProcessorTest.class);\n\n\t\tsuite.addTestSuite(DefaultSemanticModelTransformerTest.class);\n\t\t// $JUnit-END$\n\t\treturn suite;\n\t}","id":67788,"modified_method":"public static Test suite() {\n\t\tTestSuite suite = new TestSuite(\"Test for org.eclipse.xtext.ui.common.tests\");\n\t\t// $JUnit-BEGIN$\n\t\tsuite.addTestSuite(DefaultContentAssistProcessorTest.class);\n\t\tsuite.addTestSuite(DefaultSemanticModelTransformerTest.class);\n\t\tsuite.addTestSuite(HyperlinkHelperTest.class);\n\t\t// $JUnit-END$\n\t\treturn suite;\n\t}","commit_id":"43a263198000497b75e20df49396e036dde88501","url":"https://github.com/eclipse/xtext"},{"original_method":"public Object execute(ExecutionEvent event) throws ExecutionException {\n\t\tXtextEditor activeEditor = (XtextEditor) HandlerUtil.getActiveEditor(event);\n\t\tfinal IXtextDocument document = activeEditor.getDocument();\n\t\tfinal int offset = ((StyledText) activeEditor.getAdapter(Control.class)).getCaretOffset();\n\t\tdocument.readOnly(new UnitOfWork<Object>() {\n\t\t\tpublic Object exec(XtextResource resource) throws Exception {\n\t\t\t\tAbstractNode node = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(resource\n\t\t\t\t\t\t.getParseResult().getRootNode(), offset);\n\t\t\t\tList<EObject> crossLinkedEObject = findCrossLinkedEObject(node);\n\t\t\t\tif (crossLinkedEObject.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tURI uri = EcoreUtil.getURI(crossLinkedEObject.get(0));\n\t\t\t\tnew OpenDeclarationAction(uri, locationProvider).run();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}","id":67789,"modified_method":"public Object execute(ExecutionEvent event) throws ExecutionException {\n\t\tXtextEditor activeEditor = (XtextEditor) HandlerUtil.getActiveEditor(event);\n\t\tfinal IXtextDocument document = activeEditor.getDocument();\n\t\tfinal int offset = ((StyledText) activeEditor.getAdapter(Control.class)).getCaretOffset();\n\t\tdocument.readOnly(new UnitOfWork<Object>() {\n\t\t\tpublic Void exec(XtextResource resource) throws Exception {\n\t\t\t\tOpenDeclarationAction action = helper.getOpenDeclarationAction(resource, offset);\n\t\t\t\taction.run();\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}","commit_id":"43a263198000497b75e20df49396e036dde88501","url":"https://github.com/eclipse/xtext"},{"original_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\tIParseResult parseResult = resource.getParseResult();\n\t\t\t\tAssert.isNotNull(parseResult);\n\t\t\t\tAbstractNode abstractNode = ParseTreeUtil.getCurrentOrFollowingNodeByOffset(parseResult.getRootNode(),\n\t\t\t\t\t\tregion.getOffset());\n\t\t\t\tfinal Region location = new Region(abstractNode.getOffset(), abstractNode.getLength());\n\t\t\t\tList<EObject> crossLinkedEObjects = findCrossLinkedEObject(abstractNode);\n\t\t\t\tif (crossLinkedEObjects.isEmpty())\n\t\t\t\t\treturn null;\n\t\t\t\tList<IHyperlink> links = new ArrayList<IHyperlink>();\n\t\t\t\tfor (EObject crossReffed : crossLinkedEObjects) {\n\t\t\t\t\tfinal String label = labelProvider.getText(crossReffed);\n\t\t\t\t\tfinal URI uri = EcoreUtil.getURI(crossReffed);\n\t\t\t\t\tfinal URI normalized = crossReffed.eResource().getResourceSet().getURIConverter().normalize(uri);\n\t\t\t\t\tlinks.add(new IHyperlink() {\n\n\t\t\t\t\t\t\tpublic IRegion getHyperlinkRegion() {\n\t\t\t\t\t\t\t\treturn location;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getHyperlinkText() {\n\t\t\t\t\t\t\t\treturn label;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic String getTypeLabel() {\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpublic void open() {\n\t\t\t\t\t\t\t\tnew OpenDeclarationAction(normalized, locationProvider).run();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn links.toArray(new IHyperlink[links.size()]);\n\t\t\t}\n\t\t});\n\t}","id":67790,"modified_method":"public IHyperlink[] detectHyperlinks(ITextViewer textViewer, final IRegion region, final boolean canShowMultipleHyperlinks) {\n\t\treturn ((IXtextDocument)textViewer.getDocument()).readOnly(new UnitOfWork<IHyperlink[]>() {\n\t\t\tpublic IHyperlink[] exec(XtextResource resource) throws Exception {\n\t\t\t\treturn helper.createHyperlinksByOffset(resource, region.getOffset(), canShowMultipleHyperlinks);\n\t\t\t}\n\t\t});\n\t}","commit_id":"43a263198000497b75e20df49396e036dde88501","url":"https://github.com/eclipse/xtext"},{"original_method":"/** Copies the files from {@code tmpBinDir} into {@code destBinDir}, along with permissions from dest dirs parent. */\n    private void installBin(PluginInfo info, Path tmpBinDir, Path destBinDir) throws Exception {\n        if (Files.isDirectory(tmpBinDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"bin in plugin \" + info.getName() + \" is not a directory\");\n        }\n        Files.createDirectory(destBinDir);\n\n        // setup file attributes for the installed files to those of the parent dir\n        Set<PosixFilePermission> perms = new HashSet<>();\n        PosixFileAttributeView binAttrs = Files.getFileAttributeView(destBinDir.getParent(), PosixFileAttributeView.class);\n        if (binAttrs != null) {\n            perms = new HashSet<>(binAttrs.readAttributes().permissions());\n            // setting execute bits, since this just means \"the file is executable\", and actual execution requires read\n            perms.add(PosixFilePermission.OWNER_EXECUTE);\n            perms.add(PosixFilePermission.GROUP_EXECUTE);\n            perms.add(PosixFilePermission.OTHERS_EXECUTE);\n        }\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpBinDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(ExitCodes.DATA_ERROR, \"Directories not allowed in bin dir for plugin \" + info.getName() + \", found \" + srcFile.getFileName());\n                }\n\n                Path destFile = destBinDir.resolve(tmpBinDir.relativize(srcFile));\n                Files.copy(srcFile, destFile);\n\n                if (perms.isEmpty() == false) {\n                    PosixFileAttributeView view = Files.getFileAttributeView(destFile, PosixFileAttributeView.class);\n                    view.setPermissions(perms);\n                }\n            }\n        }\n        IOUtils.rm(tmpBinDir); // clean up what we just copied\n    }","id":67791,"modified_method":"/** Copies the files from {@code tmpBinDir} into {@code destBinDir}, along with permissions from dest dirs parent. */\n    private void installBin(PluginInfo info, Path tmpBinDir, Path destBinDir) throws Exception {\n        if (Files.isDirectory(tmpBinDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"bin in plugin \" + info.getName() + \" is not a directory\");\n        }\n        Files.createDirectory(destBinDir);\n\n        Set<PosixFilePermission> perms = new HashSet<>();\n        if (Constants.WINDOWS == false) {\n            // setup file attributes for the installed files to those of the parent dir\n            PosixFileAttributeView binAttrs = Files.getFileAttributeView(destBinDir.getParent(), PosixFileAttributeView.class);\n            if (binAttrs != null) {\n                perms = new HashSet<>(binAttrs.readAttributes().permissions());\n                // setting execute bits, since this just means \"the file is executable\", and actual execution requires read\n                perms.add(PosixFilePermission.OWNER_EXECUTE);\n                perms.add(PosixFilePermission.GROUP_EXECUTE);\n                perms.add(PosixFilePermission.OTHERS_EXECUTE);\n            }\n        }\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpBinDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(ExitCodes.DATA_ERROR, \"Directories not allowed in bin dir for plugin \" + info.getName() + \", found \" + srcFile.getFileName());\n                }\n\n                Path destFile = destBinDir.resolve(tmpBinDir.relativize(srcFile));\n                Files.copy(srcFile, destFile);\n\n                if (perms.isEmpty() == false) {\n                    PosixFileAttributeView view = Files.getFileAttributeView(destFile, PosixFileAttributeView.class);\n                    view.setPermissions(perms);\n                }\n            }\n        }\n        IOUtils.rm(tmpBinDir); // clean up what we just copied\n    }","commit_id":"ef4293a993014379c54e2399e692c6387d80f0ca","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Copies the files from {@code tmpConfigDir} into {@code destConfigDir}.\n     * Any files existing in both the source and destination will be skipped.\n     */\n    private void installConfig(PluginInfo info, Path tmpConfigDir, Path destConfigDir) throws Exception {\n        if (Files.isDirectory(tmpConfigDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"config in plugin \" + info.getName() + \" is not a directory\");\n        }\n\n        // create the plugin's config dir \"if necessary\"\n        Files.createDirectories(destConfigDir);\n\n        final PosixFileAttributes destConfigDirAttributes =\n                Files.getFileAttributeView(destConfigDir.getParent(), PosixFileAttributeView.class).readAttributes();\n        setOwnerGroup(destConfigDir, destConfigDirAttributes);\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpConfigDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(ExitCodes.DATA_ERROR, \"Directories not allowed in config dir for plugin \" + info.getName());\n                }\n\n                Path destFile = destConfigDir.resolve(tmpConfigDir.relativize(srcFile));\n                if (Files.exists(destFile) == false) {\n                    Files.copy(srcFile, destFile);\n                    setOwnerGroup(destFile, destConfigDirAttributes);\n                }\n            }\n        }\n        IOUtils.rm(tmpConfigDir); // clean up what we just copied\n    }","id":67792,"modified_method":"/**\n     * Copies the files from {@code tmpConfigDir} into {@code destConfigDir}.\n     * Any files existing in both the source and destination will be skipped.\n     */\n    private void installConfig(PluginInfo info, Path tmpConfigDir, Path destConfigDir) throws Exception {\n        if (Files.isDirectory(tmpConfigDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"config in plugin \" + info.getName() + \" is not a directory\");\n        }\n\n        // create the plugin's config dir \"if necessary\"\n        Files.createDirectories(destConfigDir);\n\n        final PosixFileAttributes destConfigDirAttributes;\n        if (Constants.WINDOWS) {\n            destConfigDirAttributes = null;\n        } else {\n            destConfigDirAttributes =\n                    Files.getFileAttributeView(destConfigDir.getParent(), PosixFileAttributeView.class).readAttributes();\n            setOwnerGroup(destConfigDir, destConfigDirAttributes);\n\n        }\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpConfigDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(ExitCodes.DATA_ERROR, \"Directories not allowed in config dir for plugin \" + info.getName());\n                }\n\n                Path destFile = destConfigDir.resolve(tmpConfigDir.relativize(srcFile));\n                if (Files.exists(destFile) == false) {\n                    Files.copy(srcFile, destFile);\n                    if (Constants.WINDOWS == false) {\n                        setOwnerGroup(destFile, destConfigDirAttributes);\n                    }\n                }\n            }\n        }\n        IOUtils.rm(tmpConfigDir); // clean up what we just copied\n    }","commit_id":"ef4293a993014379c54e2399e692c6387d80f0ca","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private Path unzip(Path zip, Path pluginsDir) throws IOException, UserError {\n        // unzip plugin to a staging temp dir\n        final Path target;\n        if (Constants.WINDOWS) {\n            target = Files.createTempDirectory(pluginsDir, \".installing-\");\n        } else {\n            Set<PosixFilePermission> perms = new HashSet<>();\n            perms.add(PosixFilePermission.OWNER_EXECUTE);\n            perms.add(PosixFilePermission.OWNER_READ);\n            perms.add(PosixFilePermission.OWNER_WRITE);\n            perms.add(PosixFilePermission.GROUP_READ);\n            perms.add(PosixFilePermission.GROUP_EXECUTE);\n            perms.add(PosixFilePermission.OTHERS_READ);\n            perms.add(PosixFilePermission.OTHERS_EXECUTE);\n            target = Files.createTempDirectory(pluginsDir, \".installing-\", PosixFilePermissions.asFileAttribute(perms));\n        }\n        Files.createDirectories(target);\n\n        boolean hasEsDir = false;\n        // TODO: we should wrap this in a try/catch and try deleting the target dir on failure?\n        try (ZipInputStream zipInput = new ZipInputStream(Files.newInputStream(zip))) {\n            ZipEntry entry;\n            byte[] buffer = new byte[8192];\n            while ((entry = zipInput.getNextEntry()) != null) {\n                if (entry.getName().startsWith(\"elasticsearch/\") == false) {\n                    // only extract the elasticsearch directory\n                    continue;\n                }\n                hasEsDir = true;\n                Path targetFile = target.resolve(entry.getName().substring(\"elasticsearch/\".length()));\n\n                // Using the entry name as a path can result in an entry outside of the plugin dir, either if the\n                // name starts with the root of the filesystem, or it is a relative entry like ../whatever.\n                // This check attempts to identify both cases by first normalizing the path (which removes foo/..)\n                // and ensuring the normalized entry is still rooted with the target plugin directory.\n                if (targetFile.normalize().startsWith(target) == false) {\n                    throw new IOException(\"Zip contains entry name '\" + entry.getName() + \"' resolving outside of plugin directory\");\n                }\n\n                // be on the safe side: do not rely on that directories are always extracted\n                // before their children (although this makes sense, but is it guaranteed?)\n                Files.createDirectories(targetFile.getParent());\n                if (entry.isDirectory() == false) {\n                    try (OutputStream out = Files.newOutputStream(targetFile)) {\n                        int len;\n                        while ((len = zipInput.read(buffer)) >= 0) {\n                            out.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zipInput.closeEntry();\n            }\n        }\n        Files.delete(zip);\n        if (hasEsDir == false) {\n            IOUtils.rm(target);\n            throw new UserError(ExitCodes.DATA_ERROR, \"`elasticsearch` directory is missing in the plugin zip\");\n        }\n        return target;\n    }","id":67793,"modified_method":"private Path unzip(Path zip, Path pluginsDir) throws IOException, UserError {\n        // unzip plugin to a staging temp dir\n\n        final Path target = stagingDirectory(pluginsDir);\n\n        boolean hasEsDir = false;\n        // TODO: we should wrap this in a try/catch and try deleting the target dir on failure?\n        try (ZipInputStream zipInput = new ZipInputStream(Files.newInputStream(zip))) {\n            ZipEntry entry;\n            byte[] buffer = new byte[8192];\n            while ((entry = zipInput.getNextEntry()) != null) {\n                if (entry.getName().startsWith(\"elasticsearch/\") == false) {\n                    // only extract the elasticsearch directory\n                    continue;\n                }\n                hasEsDir = true;\n                Path targetFile = target.resolve(entry.getName().substring(\"elasticsearch/\".length()));\n\n                // Using the entry name as a path can result in an entry outside of the plugin dir, either if the\n                // name starts with the root of the filesystem, or it is a relative entry like ../whatever.\n                // This check attempts to identify both cases by first normalizing the path (which removes foo/..)\n                // and ensuring the normalized entry is still rooted with the target plugin directory.\n                if (targetFile.normalize().startsWith(target) == false) {\n                    throw new IOException(\"Zip contains entry name '\" + entry.getName() + \"' resolving outside of plugin directory\");\n                }\n\n                // be on the safe side: do not rely on that directories are always extracted\n                // before their children (although this makes sense, but is it guaranteed?)\n                Files.createDirectories(targetFile.getParent());\n                if (entry.isDirectory() == false) {\n                    try (OutputStream out = Files.newOutputStream(targetFile)) {\n                        int len;\n                        while ((len = zipInput.read(buffer)) >= 0) {\n                            out.write(buffer, 0, len);\n                        }\n                    }\n                }\n                zipInput.closeEntry();\n            }\n        }\n        Files.delete(zip);\n        if (hasEsDir == false) {\n            IOUtils.rm(target);\n            throw new UserError(ExitCodes.DATA_ERROR, \"`elasticsearch` directory is missing in the plugin zip\");\n        }\n        return target;\n    }","commit_id":"554eb8aa87fbd7d516b8b30b88d5008b04b91796","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/** Copies the files from {@code tmpBinDir} into {@code destBinDir}, along with permissions from dest dirs parent. */\n    private void installBin(PluginInfo info, Path tmpBinDir, Path destBinDir) throws Exception {\n        if (Files.isDirectory(tmpBinDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"bin in plugin \" + info.getName() + \" is not a directory\");\n        }\n        Files.createDirectory(destBinDir);\n\n        Set<PosixFilePermission> perms = new HashSet<>();\n        if (Constants.WINDOWS == false) {\n            // setup file attributes for the installed files to those of the parent dir\n            PosixFileAttributeView binAttrs = Files.getFileAttributeView(destBinDir.getParent(), PosixFileAttributeView.class);\n            if (binAttrs != null) {\n                perms = new HashSet<>(binAttrs.readAttributes().permissions());\n                // setting execute bits, since this just means \"the file is executable\", and actual execution requires read\n                perms.add(PosixFilePermission.OWNER_EXECUTE);\n                perms.add(PosixFilePermission.GROUP_EXECUTE);\n                perms.add(PosixFilePermission.OTHERS_EXECUTE);\n            }\n        }\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpBinDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(\n                        ExitCodes.DATA_ERROR,\n                        \"Directories not allowed in bin dir for plugin \" + info.getName() + \", found \" + srcFile.getFileName());\n                }\n\n                Path destFile = destBinDir.resolve(tmpBinDir.relativize(srcFile));\n                Files.copy(srcFile, destFile);\n\n                if (perms.isEmpty() == false) {\n                    PosixFileAttributeView view = Files.getFileAttributeView(destFile, PosixFileAttributeView.class);\n                    view.setPermissions(perms);\n                }\n            }\n        }\n        IOUtils.rm(tmpBinDir); // clean up what we just copied\n    }","id":67794,"modified_method":"/** Copies the files from {@code tmpBinDir} into {@code destBinDir}, along with permissions from dest dirs parent. */\n    private void installBin(PluginInfo info, Path tmpBinDir, Path destBinDir) throws Exception {\n        if (Files.isDirectory(tmpBinDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"bin in plugin \" + info.getName() + \" is not a directory\");\n        }\n        Files.createDirectory(destBinDir);\n\n        // setup file attributes for the installed files to those of the parent dir\n        final Set<PosixFilePermission> perms = new HashSet<>();\n        final PosixFileAttributeView binAttributeView = Files.getFileAttributeView(destBinDir.getParent(), PosixFileAttributeView.class);\n        if (binAttributeView != null) {\n            perms.addAll(binAttributeView.readAttributes().permissions());\n            // setting execute bits, since this just means \"the file is executable\", and actual execution requires read\n            perms.add(PosixFilePermission.OWNER_EXECUTE);\n            perms.add(PosixFilePermission.GROUP_EXECUTE);\n            perms.add(PosixFilePermission.OTHERS_EXECUTE);\n        }\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpBinDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(\n                        ExitCodes.DATA_ERROR,\n                        \"Directories not allowed in bin dir for plugin \" + info.getName() + \", found \" + srcFile.getFileName());\n                }\n\n                Path destFile = destBinDir.resolve(tmpBinDir.relativize(srcFile));\n                Files.copy(srcFile, destFile);\n\n                final PosixFileAttributeView view = Files.getFileAttributeView(destFile, PosixFileAttributeView.class);\n                if (view != null) {\n                    view.setPermissions(perms);\n                }\n            }\n        }\n        IOUtils.rm(tmpBinDir); // clean up what we just copied\n    }","commit_id":"554eb8aa87fbd7d516b8b30b88d5008b04b91796","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private static void setOwnerGroup(Path path, PosixFileAttributes attributes) throws IOException {\n        PosixFileAttributeView fileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class);\n        fileAttributeView.setOwner(attributes.owner());\n        fileAttributeView.setGroup(attributes.group());\n    }","id":67795,"modified_method":"private static void setOwnerGroup(final Path path, final PosixFileAttributes attributes) throws IOException {\n        Objects.requireNonNull(attributes);\n        PosixFileAttributeView fileAttributeView = Files.getFileAttributeView(path, PosixFileAttributeView.class);\n        assert fileAttributeView != null;\n        fileAttributeView.setOwner(attributes.owner());\n        fileAttributeView.setGroup(attributes.group());\n    }","commit_id":"554eb8aa87fbd7d516b8b30b88d5008b04b91796","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Copies the files from {@code tmpConfigDir} into {@code destConfigDir}.\n     * Any files existing in both the source and destination will be skipped.\n     */\n    private void installConfig(PluginInfo info, Path tmpConfigDir, Path destConfigDir) throws Exception {\n        if (Files.isDirectory(tmpConfigDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"config in plugin \" + info.getName() + \" is not a directory\");\n        }\n\n        // create the plugin's config dir \"if necessary\"\n        Files.createDirectories(destConfigDir);\n\n        final PosixFileAttributes destConfigDirAttributes;\n        if (Constants.WINDOWS) {\n            destConfigDirAttributes = null;\n        } else {\n            destConfigDirAttributes =\n                    Files.getFileAttributeView(destConfigDir.getParent(), PosixFileAttributeView.class).readAttributes();\n            setOwnerGroup(destConfigDir, destConfigDirAttributes);\n\n        }\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpConfigDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(ExitCodes.DATA_ERROR, \"Directories not allowed in config dir for plugin \" + info.getName());\n                }\n\n                Path destFile = destConfigDir.resolve(tmpConfigDir.relativize(srcFile));\n                if (Files.exists(destFile) == false) {\n                    Files.copy(srcFile, destFile);\n                    if (Constants.WINDOWS == false) {\n                        setOwnerGroup(destFile, destConfigDirAttributes);\n                    }\n                }\n            }\n        }\n        IOUtils.rm(tmpConfigDir); // clean up what we just copied\n    }","id":67796,"modified_method":"/**\n     * Copies the files from {@code tmpConfigDir} into {@code destConfigDir}.\n     * Any files existing in both the source and destination will be skipped.\n     */\n    private void installConfig(PluginInfo info, Path tmpConfigDir, Path destConfigDir) throws Exception {\n        if (Files.isDirectory(tmpConfigDir) == false) {\n            throw new UserError(ExitCodes.IO_ERROR, \"config in plugin \" + info.getName() + \" is not a directory\");\n        }\n\n        // create the plugin's config dir \"if necessary\"\n        Files.createDirectories(destConfigDir);\n        final PosixFileAttributeView destConfigDirAttributesView =\n            Files.getFileAttributeView(destConfigDir.getParent(), PosixFileAttributeView.class);\n        final PosixFileAttributes destConfigDirAttributes =\n            destConfigDirAttributesView != null ? destConfigDirAttributesView.readAttributes() : null;\n        if (destConfigDirAttributes != null) {\n            setOwnerGroup(destConfigDir, destConfigDirAttributes);\n        }\n\n        try (DirectoryStream<Path> stream = Files.newDirectoryStream(tmpConfigDir)) {\n            for (Path srcFile : stream) {\n                if (Files.isDirectory(srcFile)) {\n                    throw new UserError(ExitCodes.DATA_ERROR, \"Directories not allowed in config dir for plugin \" + info.getName());\n                }\n\n                Path destFile = destConfigDir.resolve(tmpConfigDir.relativize(srcFile));\n                if (Files.exists(destFile) == false) {\n                    Files.copy(srcFile, destFile);\n                    if (destConfigDirAttributes != null) {\n                        setOwnerGroup(destFile, destConfigDirAttributes);\n                    }\n                }\n            }\n        }\n        IOUtils.rm(tmpConfigDir); // clean up what we just copied\n    }","commit_id":"554eb8aa87fbd7d516b8b30b88d5008b04b91796","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static void main(String[] args) throws IOException {\n        DLN ids[] = {\n                new DLN(\"1.1.7.2.1\"),\n                new DLN(\"1.1.7.2.2\"),\n                new DLN(\"1.1.8\"),\n                new DLN(\"1.1.8.1.1\"),\n                new DLN(\"1.1.8.1.1/1\"),\n                new DLN(\"1.1.8.1.1/2\"),\n                new DLN(\"1.1.8.1.2.1.5\"),\n                new DLN(\"1.1.8.1.2.1.7\"),\n                new DLN(\"1.2\")\n    };\n\n        VariableByteOutputStream os = new VariableByteOutputStream();\n        DLN previous = null;\n        for (int i = 0; i < ids.length; i++) {\n            DLN id = ids[i];\n            System.out.println(id.debug());\n            id.write(previous, os);\n            previous = id;\n        }\n\n        byte[] data = os.toByteArray();\n        System.out.println(\"Data length: \" + data.length);\n\n        VariableByteArrayInput is = new VariableByteArrayInput(data);\n        DLNFactory fact = new DLNFactory();\n        previous = null;\n        for (int i = 0; i < ids.length; i++) {\n            previous = (DLN) fact.createFromStream(previous, is);\n            System.out.println(previous.debug());\n        }\n\n        os = new VariableByteOutputStream();\n        for (int i = 0; i < ids.length; i++) {\n            DLN id = ids[i];\n            System.out.println(id.debug());\n            id.write(os);\n        }\n\n        data = os.toByteArray();\n        System.out.println(\"Data length: \" + data.length);\n    }","id":67797,"modified_method":"public static void main(String[] args) throws IOException {\n        NodeId ids[] = {\n                new DLN(\"1.1.7.2.1\"),\n                new DLN(\"1.1.7.2.2\"),\n                new DLN(\"1.1.8\"),\n                new DLN(\"1.1.8.1.1\"),\n                new DLN(\"1.1.8.1.1/1\"),\n                new DLN(\"1.1.8.1.1/2\"),\n                new DLN(\"1.1.8.1.2.1.5\"),\n                new DLN(\"1.1.8.1.2.1.7\"),\n                new DLN(\"1.2\"),\n                DLN.END_OF_DOCUMENT,\n                DLN.END_OF_DOCUMENT\n    };\n\n        VariableByteOutputStream os = new VariableByteOutputStream();\n        NodeId previous = null;\n        for (int i = 0; i < ids.length; i++) {\n            NodeId id = ids[i];\n            System.out.println(id.toString());\n            id.write(previous, os);\n            previous = id;\n        }\n\n        byte[] data = os.toByteArray();\n        System.out.println(\"Data length: \" + data.length);\n\n        VariableByteArrayInput is = new VariableByteArrayInput(data);\n        DLNFactory fact = new DLNFactory();\n        previous = null;\n        for (int i = 0; i < ids.length; i++) {\n            previous = fact.createFromStream(previous, is);\n            System.out.println(previous.toString());\n        }\n\n        os = new VariableByteOutputStream();\n        for (int i = 0; i < ids.length; i++) {\n            NodeId id = ids[i];\n            System.out.println(id.toString());\n            id.write(os);\n        }\n\n        data = os.toByteArray();\n        System.out.println(\"Data length: \" + data.length);\n    }","commit_id":"7c1db398f18c4c4b352db74e2f37d2471cf52155","url":"https://github.com/eXist-db/exist"},{"original_method":"public void writeEndOfDocument(VariableByteOutputStream os) {\n        os.writeShort(0);\n    }","id":67798,"modified_method":"public void writeEndOfDocument(VariableByteOutputStream os) {\n        os.writeByte((byte) 0);\n        os.writeShort(0);\n    }","commit_id":"7c1db398f18c4c4b352db74e2f37d2471cf52155","url":"https://github.com/eXist-db/exist"},{"original_method":"public void remove() {      \n        //TODO : return if doc == null? -pb  \n        if (pending.size() == 0) \n            return; \n        final short collectionId = this.doc.getCollection().getId();\n        final Lock lock = dbNodes.getLock();\n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            Map.Entry entry = (Map.Entry) i.next();\n            List storedGIDList = (ArrayList) entry.getValue();\n            QName qname = (QName) entry.getKey();\n            final Value key = computeKey(collectionId, qname);     \n            List newGIDList = new ArrayList();\n            os.clear();             \n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                Value value = dbNodes.get(key);\n                //Does the node already exist in the index ?\n                if (value != null) {\n                    //Add its data to the new list                    \n                    VariableByteArrayInput is = new VariableByteArrayInput(value.getData());\n                    try {\n                        while (is.available() > 0) {\n                            int storedDocId = is.readInt();\n                            byte isOrdered = is.readByte();\n                            int gidsCount = is.readInt();\n                            //TOUNDERSTAND -pb\n                            int size = is.readFixedInt();\n                            if (storedDocId != this.doc.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(storedDocId);\n                                os.writeByte(isOrdered);\n                                os.writeInt(gidsCount);\n                                os.writeFixedInt(size);\n                                try {\n                                    is.copyRaw(os, size);\n                                } catch(EOFException e) {\n                                    LOG.error(e.getMessage(), e);\n                                    //TODO : data will be saved although os is probably corrupted ! -pb\n                                }\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs\n                                for (int j = 0; j < gidsCount; j++) {\n                                \tNodeId nodeId = \n                                \t\tbroker.getBrokerPool().getNodeFactory().createFromStream(is);                                        \n                                    long address = StorageAddress.read(is);\n                                    // add the node to the new list if it is not \n                                    // in the list of removed nodes\n                                    if (!containsNode(storedGIDList, nodeId)) {\n                                        newGIDList.add(new NodeProxy(doc, nodeId, address));\n                                    }\n                                }\n                                broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                            }\n                        }\n                    } catch (EOFException e) {\n                        //TODO : remove this block if unexpected -pb\n                        LOG.warn(\"REPORT ME \" + e.getMessage(), e);\n                    }\n                    //append the data from the new list\n                    if (newGIDList.size() > 0 ) {                        \n                        int gidsCount = newGIDList.size();\n                        //Don't forget this one\n                        FastQSort.sort(newGIDList, 0, gidsCount - 1);                \n                        os.writeInt(this.doc.getDocId());\n                        os.writeByte(ENTRIES_ORDERED);\n                        os.writeInt(gidsCount);\n                        //TOUNDERSTAND -pb\n                        int lenOffset = os.position();\n                        os.writeFixedInt(0);\n                        for (int j = 0; j < gidsCount; j++) {\n                            NodeProxy storedNode = (NodeProxy) newGIDList.get(j);\n                            if (doc.getDocId() != storedNode.getDocument().getDocId()) {\n                                throw new IllegalArgumentException(\"Document id ('\" + doc.getDocId() + \"') and proxy id ('\" + \n                                        storedNode.getDocument().getDocId() + \"') differ !\");\n                            }\n                            try {\n                                storedNode.getNodeId().write(os);\n                            } catch (IOException e) {\n                                LOG.warn(\"IO error while writing structural index: \" + e.getMessage(), e);\n                                //TODO : throw exception ?\n                            }\n                            StorageAddress.write(storedNode.getInternalAddress(), os);\n                        }\n                        broker.getBrokerPool().getNodeFactory().writeEndOfDocument(os);\n                        //What does this 4 stand for ?\n                        os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);    \n                    }\n                }                \n                //Store the data\n                if (value == null) {\n                    if (dbNodes.put(key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not put index data for node '\" +  qname + \"'\"); \n                        //TODO : throw exception ?\n                    }                    \n                } else {\n                    if (dbNodes.update(value.getAddress(), key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not put index data for node '\" +  qname + \"'\");\n                        //TODO : throw exception ?\n                    }                    \n                }\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);                \n            } catch (ReadOnlyException e) {\n                LOG.warn(\"Read-only error on '\" + dbNodes.getFile().getName() + \"'\", e);   \n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n                os.clear();\n            }\n        }\n        pending.clear();\n    }","id":67799,"modified_method":"public void remove() {      \n        //TODO : return if doc == null? -pb  \n        if (pending.size() == 0) \n            return; \n        final short collectionId = this.doc.getCollection().getId();\n        final Lock lock = dbNodes.getLock();\n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            Map.Entry entry = (Map.Entry) i.next();\n            List storedGIDList = (ArrayList) entry.getValue();\n            QName qname = (QName) entry.getKey();\n            final Value key = computeKey(collectionId, qname);     \n            List newGIDList = new ArrayList();\n            os.clear();             \n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                Value value = dbNodes.get(key);\n                //Does the node already exist in the index ?\n                if (value != null) {\n                    //Add its data to the new list                    \n                    VariableByteArrayInput is = new VariableByteArrayInput(value.getData());\n                    try {\n                        while (is.available() > 0) {\n                            int storedDocId = is.readInt();\n                            byte isOrdered = is.readByte();\n                            int gidsCount = is.readInt();\n                            //TOUNDERSTAND -pb\n                            int size = is.readFixedInt();\n                            if (storedDocId != this.doc.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(storedDocId);\n                                os.writeByte(isOrdered);\n                                os.writeInt(gidsCount);\n                                os.writeFixedInt(size);\n                                try {\n                                    is.copyRaw(os, size);\n                                } catch(EOFException e) {\n                                    LOG.error(e.getMessage(), e);\n                                    //TODO : data will be saved although os is probably corrupted ! -pb\n                                }\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs\n                                NodeId previous = null;\n                                NodeId nodeId;\n                                long address;\n                                for (int j = 0; j < gidsCount; j++) {\n                                    nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(previous, is);\n                                    previous = nodeId;\n                                    address = StorageAddress.read(is);\n                                    // add the node to the new list if it is not \n                                    // in the list of removed nodes\n                                    if (!containsNode(storedGIDList, nodeId)) {\n                                        newGIDList.add(new NodeProxy(doc, nodeId, address));\n                                    }\n                                }\n                                broker.getBrokerPool().getNodeFactory().createFromStream(NodeId.ROOT_NODE, is);\n                            }\n                        }\n                    } catch (EOFException e) {\n                        //TODO : remove this block if unexpected -pb\n                        LOG.warn(\"REPORT ME \" + e.getMessage(), e);\n                    }\n                    //append the data from the new list\n                    if (newGIDList.size() > 0 ) {                        \n                        int gidsCount = newGIDList.size();\n                        //Don't forget this one\n                        FastQSort.sort(newGIDList, 0, gidsCount - 1);                \n                        os.writeInt(this.doc.getDocId());\n                        os.writeByte(ENTRIES_ORDERED);\n                        os.writeInt(gidsCount);\n                        //TOUNDERSTAND -pb\n                        int lenOffset = os.position();\n                        os.writeFixedInt(0);\n                        NodeId previous = null;\n                        NodeProxy storedNode;\n                        for (int j = 0; j < gidsCount; j++) {\n                            storedNode = (NodeProxy) newGIDList.get(j);\n                            if (doc.getDocId() != storedNode.getDocument().getDocId()) {\n                                throw new IllegalArgumentException(\"Document id ('\" + doc.getDocId() + \"') and proxy id ('\" + \n                                        storedNode.getDocument().getDocId() + \"') differ !\");\n                            }\n                            try {\n                                previous = storedNode.getNodeId().write(previous, os);\n                            } catch (IOException e) {\n                                LOG.warn(\"IO error while writing structural index: \" + e.getMessage(), e);\n                                //TODO : throw exception ?\n                            }\n                            StorageAddress.write(storedNode.getInternalAddress(), os);\n                        }\n                        broker.getBrokerPool().getNodeFactory().writeEndOfDocument(os);\n                        //What does this 4 stand for ?\n                        os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);    \n                    }\n                }                \n                //Store the data\n                if (value == null) {\n                    if (dbNodes.put(key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not put index data for node '\" +  qname + \"'\"); \n                        //TODO : throw exception ?\n                    }                    \n                } else {\n                    if (dbNodes.update(value.getAddress(), key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not put index data for node '\" +  qname + \"'\");\n                        //TODO : throw exception ?\n                    }                    \n                }\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);                \n            } catch (ReadOnlyException e) {\n                LOG.warn(\"Read-only error on '\" + dbNodes.getFile().getName() + \"'\", e);   \n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n                os.clear();\n            }\n        }\n        pending.clear();\n    }","commit_id":"7c1db398f18c4c4b352db74e2f37d2471cf52155","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Lookup elements or attributes in the index matching a given {@link QName} and\n     * {@link NodeSelector}. The NodeSelector argument is optional. If selector is\n     * null, all elements or attributes matching qname will be returned.\n     * \n     * @param type either {@link ElementValue#ATTRIBUTE}, {@link ElementValue#ELEMENT}\n     *      or {@link ElementValue#ATTRIBUTE_ID}\n     * @param docs the set of documents to look up in the index\n     * @param qname the QName of the attribute or element\n     * @param selector an (optional) NodeSelector\n     */\n    public NodeSet findElementsByTagName(byte type, DocumentSet docs, QName qname, NodeSelector selector) {\n        short nodeType = getIndexType(type);\n        final ExtArrayNodeSet result = new ExtArrayNodeSet(docs.getLength(), 256);\n        final Lock lock = dbNodes.getLock();\n        // true if the output document set is the same as the input document set\n        boolean sameDocSet = true;\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            //Compute a key for the node\n            Collection collection = (Collection) i.next();\n            short collectionId = collection.getId();\n            final Value key = computeTypedKey(type, collectionId, qname);\n            try {\n                lock.acquire(Lock.READ_LOCK);\n                VariableByteInput is = dbNodes.getAsStream(key); \n                //Does the node already has data in the index ?\n                if (is == null) {\n                \tsameDocSet = false;\n                    continue;\n                }\n                while (is.available() > 0) {\n                    int storedDocId = is.readInt();\n                    byte ordered = is.readByte();\n                    int gidsCount = is.readInt();\n                    //TOUNDERSTAND -pb\n                    int size = is.readFixedInt();\n                    DocumentImpl storedDocument = docs.getDoc(storedDocId);\n                    //Exit if the document is not concerned\n                    if (storedDocument == null) {\n                        is.skipBytes(size);\n                        continue;\n                    }               \n                    //Process the nodes\n                    NodeId nodeId;\n                    for (int k = 0; k < gidsCount; k++) {\n                        nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                        if (selector == null) {\n                            long address = StorageAddress.read(is);\n                            NodeProxy storedNode = new NodeProxy(storedDocument, nodeId, nodeType, address);\n                            result.add(storedNode, gidsCount);                        \n                        } else {\n                            //Filter out the node if requested to do so\n                            NodeProxy storedNode = selector.match(storedDocument, nodeId);\n                            if (storedNode != null) {\n                                long address = StorageAddress.read(is);\n                                storedNode.setInternalAddress(address);\n                                storedNode.setNodeType(nodeType);\n                                result.add(storedNode, gidsCount);\n                            } else {\n                            \t//What does this 3 stand for ?\n                                is.skip(3);\n                                sameDocSet = false;\n                            }\n                        }\n                    }\n                    nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                    result.setSorted(storedDocument, ordered == ENTRIES_ORDERED);\n                }\n            } catch (EOFException e) {\n                //EOFExceptions are expected here\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);               \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.READ_LOCK);\n            }\n        }\n//        LOG.debug(\"Found: \" + result.getLength() + \" for \" + qname);\n        if (sameDocSet) {\n        \tresult.setDocumentSet(docs);\n        }\n        return result;\n    }","id":67800,"modified_method":"/**\n     * Lookup elements or attributes in the index matching a given {@link QName} and\n     * {@link NodeSelector}. The NodeSelector argument is optional. If selector is\n     * null, all elements or attributes matching qname will be returned.\n     * \n     * @param type either {@link ElementValue#ATTRIBUTE}, {@link ElementValue#ELEMENT}\n     *      or {@link ElementValue#ATTRIBUTE_ID}\n     * @param docs the set of documents to look up in the index\n     * @param qname the QName of the attribute or element\n     * @param selector an (optional) NodeSelector\n     */\n    public NodeSet findElementsByTagName(byte type, DocumentSet docs, QName qname, NodeSelector selector) {\n        short nodeType = getIndexType(type);\n        final ExtArrayNodeSet result = new ExtArrayNodeSet(docs.getLength(), 256);\n        final Lock lock = dbNodes.getLock();\n        // true if the output document set is the same as the input document set\n        boolean sameDocSet = true;\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            //Compute a key for the node\n            Collection collection = (Collection) i.next();\n            short collectionId = collection.getId();\n            final Value key = computeTypedKey(type, collectionId, qname);\n            try {\n                lock.acquire(Lock.READ_LOCK);\n                VariableByteInput is = dbNodes.getAsStream(key); \n                //Does the node already has data in the index ?\n                if (is == null) {\n                \tsameDocSet = false;\n                    continue;\n                }\n                while (is.available() > 0) {\n                    int storedDocId = is.readInt();\n                    byte ordered = is.readByte();\n                    int gidsCount = is.readInt();\n                    //TOUNDERSTAND -pb\n                    int size = is.readFixedInt();\n                    DocumentImpl storedDocument = docs.getDoc(storedDocId);\n                    //Exit if the document is not concerned\n                    if (storedDocument == null) {\n                        is.skipBytes(size);\n                        continue;\n                    }               \n                    //Process the nodes\n                    NodeId nodeId;\n                    NodeId previous = null;\n                    for (int k = 0; k < gidsCount; k++) {\n                        nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(previous, is);\n                        previous = nodeId;\n                        if (selector == null) {\n                            long address = StorageAddress.read(is);\n                            NodeProxy storedNode = new NodeProxy(storedDocument, nodeId, nodeType, address);\n                            result.add(storedNode, gidsCount);                        \n                        } else {\n                            //Filter out the node if requested to do so\n                            NodeProxy storedNode = selector.match(storedDocument, nodeId);\n                            if (storedNode != null) {\n                                long address = StorageAddress.read(is);\n                                storedNode.setInternalAddress(address);\n                                storedNode.setNodeType(nodeType);\n                                result.add(storedNode, gidsCount);\n                            } else {\n                            \t//What does this 3 stand for ?\n                                is.skip(3);\n                                sameDocSet = false;\n                            }\n                        }\n                    }\n                    nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(NodeId.ROOT_NODE, is);\n                    result.setSorted(storedDocument, ordered == ENTRIES_ORDERED);\n                }\n            } catch (EOFException e) {\n                //EOFExceptions are expected here\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);               \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.READ_LOCK);\n            }\n        }\n//        LOG.debug(\"Found: \" + result.getLength() + \" for \" + qname);\n        if (sameDocSet) {\n        \tresult.setDocumentSet(docs);\n        }\n        return result;\n    }","commit_id":"7c1db398f18c4c4b352db74e2f37d2471cf52155","url":"https://github.com/eXist-db/exist"},{"original_method":"public void consistencyCheck(DocumentImpl document) throws EXistException {\n        final SymbolTable symbols = broker.getSymbols();\n        final short collectionId = document.getCollection().getId();\n        final Value ref = new ElementValue(collectionId);\n        final IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        final StringBuffer msg = new StringBuffer();    \n        final Lock lock = dbNodes.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            //TODO : NativeValueIndex uses LongLinkedLists -pb\n            ArrayList elements = dbNodes.findKeys(query);           \n            for (int i = 0; i < elements.size(); i++) {\n                Value key = (Value) elements.get(i);\n                Value value = dbNodes.get(key);\n                short sym = ByteConversion.byteToShort(key.data(), key.start() + OFFSET_SYMBOL);\n                String nodeName = symbols.getName(sym);\n                msg.setLength(0);\n                msg.append(\"Checking \").append(nodeName).append(\": \");                \n                VariableByteArrayInput is = new VariableByteArrayInput(value.getData());\n                try {\n                    while (is.available() > 0) {\n                        int storedDocId = is.readInt();\n                        is.readByte();\n                        int gidsCount = is.readInt();\n                        //TOUNDERSTAND -pb\n                        is.readFixedInt(); //unused\n                        if (storedDocId != document.getDocId()) {\n                            // data are related to another document:\n                            // ignore them \n                            is.skip(gidsCount * 4);\n                        } else {\n                            // data are related to our document:\n                            // check   \n                            for (int j = 0; j < gidsCount; j++) {\n                            \tNodeId nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(is);                                \n                                long address = StorageAddress.read(is);\n                                Node storedNode = broker.objectWith(new NodeProxy(doc, nodeId, address));\n                                if (storedNode == null) {\n                                    throw new EXistException(\"Node \" + nodeId + \" in document \" + document.getFileURI() + \" not found.\");\n                                }\n                                if (storedNode.getNodeType() != Node.ELEMENT_NODE && storedNode.getNodeType() != Node.ATTRIBUTE_NODE) {\n                                    LOG.error(\"Node \" + nodeId + \" in document \" +  document.getFileURI() + \" is not an element or attribute node.\");\n                                    LOG.error(\"Type = \" + storedNode.getNodeType() + \"; name = \" + storedNode.getNodeName() + \"; value = \" + storedNode.getNodeValue());\n                                    throw new EXistException(\"Node \" + nodeId + \" in document \" + document.getURI() + \" is not an element or attribute node.\");\n                                }\n                                if(!storedNode.getLocalName().equals(nodeName)) {\n                                    LOG.error(\"Node name does not correspond to index entry. Expected \" + nodeName + \"; found \" + storedNode.getLocalName());\n                                    //TODO : also throw an exception here ?\n                                }\n                                //TODO : better message (see above) -pb\n                                msg.append(StorageAddress.toString(address)).append(\" \");\n                            }\n                        }                            \n                    }                \n                } catch (EOFException e) {\n                    //TODO : remove this block if unexpected -pb\n                    LOG.warn(\"REPORT ME \" + e.getMessage(), e);\n                }\n                LOG.debug(msg.toString());\n            }\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);   \n            //TODO : throw an exception ? -pb\n        } catch (BTreeException e) {\n            LOG.error(e.getMessage(), e);\n            //TODO : throw an exception ? -pb\n        } catch (IOException e) {\n            LOG.error(e.getMessage(), e);\n            //TODO : throw an exception ? -pb\n        } catch (TerminatedException e) {\n            LOG.warn(e.getMessage(), e);\n            //TODO : throw an exception ? -pb\n        } finally {\n            lock.release(Lock.WRITE_LOCK);\n        }\n    }","id":67801,"modified_method":"public void consistencyCheck(DocumentImpl document) throws EXistException {\n        final SymbolTable symbols = broker.getSymbols();\n        final short collectionId = document.getCollection().getId();\n        final Value ref = new ElementValue(collectionId);\n        final IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        final StringBuffer msg = new StringBuffer();    \n        final Lock lock = dbNodes.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            //TODO : NativeValueIndex uses LongLinkedLists -pb\n            ArrayList elements = dbNodes.findKeys(query);           \n            for (int i = 0; i < elements.size(); i++) {\n                Value key = (Value) elements.get(i);\n                Value value = dbNodes.get(key);\n                short sym = ByteConversion.byteToShort(key.data(), key.start() + OFFSET_SYMBOL);\n                String nodeName = symbols.getName(sym);\n                msg.setLength(0);\n                msg.append(\"Checking \").append(nodeName).append(\": \");                \n                VariableByteArrayInput is = new VariableByteArrayInput(value.getData());\n                try {\n                    while (is.available() > 0) {\n                        int storedDocId = is.readInt();\n                        is.readByte();\n                        int gidsCount = is.readInt();\n                        //TOUNDERSTAND -pb\n                        is.readFixedInt(); //unused\n                        if (storedDocId != document.getDocId()) {\n                            // data are related to another document:\n                            // ignore them \n                            is.skip(gidsCount * 4);\n                        } else {\n                            // data are related to our document:\n                            // check\n                            NodeId previous = null;\n                            NodeId nodeId;\n                            for (int j = 0; j < gidsCount; j++) {\n                                nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(previous, is);\n                                previous = nodeId;\n                                long address = StorageAddress.read(is);\n                                Node storedNode = broker.objectWith(new NodeProxy(doc, nodeId, address));\n                                if (storedNode == null) {\n                                    throw new EXistException(\"Node \" + nodeId + \" in document \" + document.getFileURI() + \" not found.\");\n                                }\n                                if (storedNode.getNodeType() != Node.ELEMENT_NODE && storedNode.getNodeType() != Node.ATTRIBUTE_NODE) {\n                                    LOG.error(\"Node \" + nodeId + \" in document \" +  document.getFileURI() + \" is not an element or attribute node.\");\n                                    LOG.error(\"Type = \" + storedNode.getNodeType() + \"; name = \" + storedNode.getNodeName() + \"; value = \" + storedNode.getNodeValue());\n                                    throw new EXistException(\"Node \" + nodeId + \" in document \" + document.getURI() + \" is not an element or attribute node.\");\n                                }\n                                if(!storedNode.getLocalName().equals(nodeName)) {\n                                    LOG.error(\"Node name does not correspond to index entry. Expected \" + nodeName + \"; found \" + storedNode.getLocalName());\n                                    //TODO : also throw an exception here ?\n                                }\n                                //TODO : better message (see above) -pb\n                                msg.append(StorageAddress.toString(address)).append(\" \");\n                            }\n                        }                            \n                    }                \n                } catch (EOFException e) {\n                    //TODO : remove this block if unexpected -pb\n                    LOG.warn(\"REPORT ME \" + e.getMessage(), e);\n                }\n                LOG.debug(msg.toString());\n            }\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);   \n            //TODO : throw an exception ? -pb\n        } catch (BTreeException e) {\n            LOG.error(e.getMessage(), e);\n            //TODO : throw an exception ? -pb\n        } catch (IOException e) {\n            LOG.error(e.getMessage(), e);\n            //TODO : throw an exception ? -pb\n        } catch (TerminatedException e) {\n            LOG.warn(e.getMessage(), e);\n            //TODO : throw an exception ? -pb\n        } finally {\n            lock.release(Lock.WRITE_LOCK);\n        }\n    }","commit_id":"7c1db398f18c4c4b352db74e2f37d2471cf52155","url":"https://github.com/eXist-db/exist"},{"original_method":"public void flush() {\n        //TODO : return if doc == null? -pb\n        if (pending.size() == 0) \n            return;\n        final ProgressIndicator progress = new ProgressIndicator(pending.size(), 5); \n        final short collectionId = this.doc.getCollection().getId(); \n        final Lock lock = dbNodes.getLock();   \n        int count = 0;\n        for (Iterator i = pending.entrySet().iterator(); i.hasNext(); count++) {\n            Map.Entry entry = (Map.Entry) i.next();\n            QName qname = (QName) entry.getKey();\n            //TODO : NativeValueIndex uses LongLinkedLists -pb\n            ArrayList gids = (ArrayList) entry.getValue();            \n            int gidsCount = gids.size();\n            //Don't forget this one\n            FastQSort.sort(gids, 0, gidsCount - 1);\n            os.clear();\n            os.writeInt(this.doc.getDocId());\n            os.writeByte(inUpdateMode ? ENTRIES_UNORDERED : ENTRIES_ORDERED);            \n            os.writeInt(gidsCount);\n            //TOUNDERSTAND -pb\n            int lenOffset = os.position();\n            os.writeFixedInt(0);  \n            //Compute the GIDs list\n            for (int j = 0; j < gidsCount; j++) {\n                NodeProxy storedNode = (NodeProxy) gids.get(j);\n                if (doc.getDocId() != storedNode.getDocument().getDocId()) {\n                    throw new IllegalArgumentException(\"Document id ('\" + doc.getDocId() + \"') and proxy id ('\" + \n                            storedNode.getDocument().getDocId() + \"') differ !\");\n                }\n                try {\n                    storedNode.getNodeId().write(os);\n                } catch (IOException e) {\n                    LOG.warn(\"IO error while writing structural index: \" + e.getMessage(), e);\n                }\n                StorageAddress.write(storedNode.getInternalAddress(), os);\n            }\n            broker.getBrokerPool().getNodeFactory().writeEndOfDocument(os);\n            //What does this 4 stand for ?\n            os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                //Store the data\n                final Value key = computeKey(collectionId, qname);\n                if (dbNodes.append(key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                    LOG.error(\"Could not put index data for node '\" +  qname + \"'\");\n                    //TODO : throw an exception ?\n                }\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);\n                //TODO : return ?\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);   \n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(\"Read-only error on '\" + dbNodes.getFile().getName() + \"'\", e);\n                //Return without clearing the pending entries\n                return;                 \n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n                os.clear();\n            }\n            progress.setValue(count);\n            if (progress.changed()) {\n                setChanged();\n                notifyObservers(progress);\n            }            \n        }        \n        progress.finish();\n        setChanged();\n        notifyObservers(progress);\n        pending.clear();\n        inUpdateMode = false;\n    }","id":67802,"modified_method":"public void flush() {\n        //TODO : return if doc == null? -pb\n        if (pending.size() == 0) \n            return;\n        final ProgressIndicator progress = new ProgressIndicator(pending.size(), 5); \n        final short collectionId = this.doc.getCollection().getId(); \n        final Lock lock = dbNodes.getLock();   \n        int count = 0;\n        for (Iterator i = pending.entrySet().iterator(); i.hasNext(); count++) {\n            Map.Entry entry = (Map.Entry) i.next();\n            QName qname = (QName) entry.getKey();\n            //TODO : NativeValueIndex uses LongLinkedLists -pb\n            ArrayList gids = (ArrayList) entry.getValue();            \n            int gidsCount = gids.size();\n            //Don't forget this one\n            FastQSort.sort(gids, 0, gidsCount - 1);\n            os.clear();\n            os.writeInt(this.doc.getDocId());\n            os.writeByte(inUpdateMode ? ENTRIES_UNORDERED : ENTRIES_ORDERED);            \n            os.writeInt(gidsCount);\n            //TOUNDERSTAND -pb\n            int lenOffset = os.position();\n            os.writeFixedInt(0);  \n            //Compute the GIDs list\n            NodeId previous = null;\n            for (int j = 0; j < gidsCount; j++) {\n                NodeProxy storedNode = (NodeProxy) gids.get(j);\n                if (doc.getDocId() != storedNode.getDocument().getDocId()) {\n                    throw new IllegalArgumentException(\"Document id ('\" + doc.getDocId() + \"') and proxy id ('\" + \n                            storedNode.getDocument().getDocId() + \"') differ !\");\n                }\n                try {\n                    previous = storedNode.getNodeId().write(previous, os);\n                } catch (IOException e) {\n                    LOG.warn(\"IO error while writing structural index: \" + e.getMessage(), e);\n                }\n                StorageAddress.write(storedNode.getInternalAddress(), os);\n            }\n            broker.getBrokerPool().getNodeFactory().writeEndOfDocument(os);\n            //What does this 4 stand for ?\n            os.writeFixedInt(lenOffset, os.position() - lenOffset - 4);\n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                //Store the data\n                final Value key = computeKey(collectionId, qname);\n                if (dbNodes.append(key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                    LOG.error(\"Could not put index data for node '\" +  qname + \"'\");\n                    //TODO : throw an exception ?\n                }\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);\n                //TODO : return ?\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);   \n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(\"Read-only error on '\" + dbNodes.getFile().getName() + \"'\", e);\n                //Return without clearing the pending entries\n                return;                 \n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n                os.clear();\n            }\n            progress.setValue(count);\n            if (progress.changed()) {\n                setChanged();\n                notifyObservers(progress);\n            }            \n        }        \n        progress.finish();\n        setChanged();\n        notifyObservers(progress);\n        pending.clear();\n        inUpdateMode = false;\n    }","commit_id":"7c1db398f18c4c4b352db74e2f37d2471cf52155","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n     * Optimized lookup method which directly implements the ancestor-descendant join. The algorithm\n     * does directly operate on the input stream containing the potential descendant nodes. It thus needs\n     * less comparisons than {@link #findElementsByTagName(byte, DocumentSet, QName, NodeSelector)}.\n     * \n     * @param type either {@link ElementValue#ATTRIBUTE}, {@link ElementValue#ELEMENT}\n     *      or {@link ElementValue#ATTRIBUTE_ID}\n     * @param docs the set of documents to look up in the index\n     * @param contextSet the set of ancestor nodes for which the method will try to find descendants\n     * @param contextId id of the current context expression as passed by the query engine\n     * @param qname the QName to search for\n     */\n    public NodeSet findDescendantsByTagName(byte type, QName qname, int axis,\n    \t\tDocumentSet docs, ExtArrayNodeSet contextSet,  int contextId) {\n//        LOG.debug(contextSet.toString());\n        short nodeType = getIndexType(type);\n        ByDocumentIterator citer = contextSet.iterateByDocument();\n        final ExtArrayNodeSet result = new ExtArrayNodeSet(docs.getLength(), 256);\n        final Lock lock = dbNodes.getLock();\n        // true if the output document set is the same as the input document set\n        boolean sameDocSet = true;\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            //Compute a key for the node\n            Collection collection = (Collection) i.next();\n            short collectionId = collection.getId();\n            final Value key = computeTypedKey(type, collectionId, qname);\n            try {\n                lock.acquire(Lock.READ_LOCK);\n                VariableByteInput is;\n                /*\n                //TODO : uncomment and implement properly\n                //TODO : beware of null NS prefix : it looks to be polysemic (none vs. all)\n                //Test for \"*\" prefix\n                if (qname.getPrefix() == null) {\n                \ttry {\n\t                    final IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, key);\n\t                    ArrayList elements = dbNodes.findKeys(query);\t                     \n                    } catch (BTreeException e) {\n                        LOG.error(e.getMessage(), e);\n                        //TODO : throw an exception ? -pb\n                    } catch (TerminatedException e) {\n                        LOG.warn(e.getMessage(), e);                        \n                    }\n                    //TODO : iterate over the keys \n                } else */                \n                \tis = dbNodes.getAsStream(key); \n                //Does the node already has data in the index ?\n                if (is == null) {\n                \tsameDocSet = false;\n                    continue;\n                }\n                int lastDocId = DocumentImpl.UNKNOWN_DOCUMENT_ID;\n                NodeProxy ancestor = null;\n                \n                while (is.available() > 0) {\n                    int storedDocId = is.readInt();\n                    byte ordered = is.readByte();\n                    int gidsCount = is.readInt();\n                    //TOUNDERSTAND -pb\n                    int size = is.readFixedInt();\n                    DocumentImpl storedDocument = docs.getDoc(storedDocId);\n                    //Exit if the document is not concerned\n                    if (storedDocument == null) {\n                        is.skipBytes(size);\n                        continue;\n                    }\n                    // position the context iterator on the next document\n                    if (storedDocId != lastDocId || ordered == ENTRIES_UNORDERED) {\n                    \tciter.nextDocument(storedDocument);\n                    \tlastDocId = storedDocId;\n                    \tancestor = citer.nextNode();\n                    }\n                    // no ancestor node in the context set, skip the document\n                    if (ancestor == null || gidsCount == 0) {\n                    \tis.skipBytes(size);\n                        continue;\n                    }\n\n                    NodeId ancestorId = ancestor.getNodeId();\n                    long prevPosition = ((BFile.PageInputStream)is).position();\n                    long markedPosition = prevPosition;\n                    NodeId lastMarked = ancestorId;\n                    NodeProxy lastAncestor = null;\n\n                    // Process the nodes for the current document\n                    NodeId nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                    long address = StorageAddress.read(is);\n \n                    while (true) {\n                        int relation = nodeId.computeRelation(ancestorId);\n//                        System.out.println(ancestorId + \" -> \" + nodeId + \": \" + relation);\n                        if (relation != -1) {\n                            // current node is a descendant. walk through the descendants\n                            // and add them to the result\n                            if (((axis == Constants.CHILD_AXIS || axis == Constants.ATTRIBUTE_AXIS) && relation == NodeId.IS_CHILD) || \n                            \t\t(axis == Constants.DESCENDANT_AXIS && relation == NodeId.IS_DESCENDANT) ||\n                            \t\taxis == Constants.DESCENDANT_SELF_AXIS || axis == Constants.DESCENDANT_ATTRIBUTE_AXIS\n                        \t\t) {\n                                NodeProxy storedNode = new NodeProxy(storedDocument, nodeId, nodeType, address);\n                                result.add(storedNode, gidsCount);\n                                if (Expression.NO_CONTEXT_ID != contextId) {\n                                    storedNode.deepCopyContext(ancestor, contextId);\n                                } else\n                                    storedNode.copyContext(ancestor);\n                            }\n                            prevPosition = ((BFile.PageInputStream)is).position();\n                            NodeId next = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                            if (next != DLN.END_OF_DOCUMENT) {\n                                // retrieve the next descendant from the stream\n                                nodeId = next;\n                                address = StorageAddress.read(is);\n                            } else {\n                                // no more descendants. check if there are more ancestors\n                                if (citer.hasNextNode()) {\n                                    NodeProxy nextNode = citer.peekNode();\n                                    // reached the end of the input stream:\n                                    // if the ancestor set has more nodes and the following ancestor\n                                    // is a descendant of the previous one, we have to rescan the input stream\n                                    // for further matches\n                                    if (nextNode.getNodeId().isDescendantOf(ancestorId)) {\n                                        prevPosition = markedPosition;\n                                        ((BFile.PageInputStream)is).seek(markedPosition);\n                                        nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                                        address = StorageAddress.read(is);\n                                        ancestor = citer.nextNode();\n                                        ancestorId = ancestor.getNodeId();\n                                    } else {\n//                                        ancestorId = ancestor.getNodeId();\n                                        break;\n                                    }\n                                } else {\n                                    break;\n                                }\n                            }\n                        } else {\n                            // current node is not a descendant of the ancestor node. Compare the\n                            // node ids and proceed with next descendant or ancestor.\n                            int cmp = ancestorId.compareTo(nodeId);\n                            if (cmp < 0) {\n                                // check if we have more ancestors\n                                if (citer.hasNextNode()) {\n                                    NodeProxy next = citer.nextNode();\n                                    // if the ancestor set has more nodes and the following ancestor\n                                    // is a descendant of the previous one, we have to rescan the input stream\n                                    // for further matches\n                                    if (next.getNodeId().isDescendantOf(ancestorId)) {\n                                        // rewind the input stream to the position from where we started\n                                        // for the previous ancestor node\n                                        ((BFile.PageInputStream)is).seek(markedPosition);\n                                        nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                                        address = StorageAddress.read(is);\n                                    } else {\n                                        // mark the current position in the input stream\n                                        if (!next.getNodeId().isDescendantOf(lastMarked)) {\n                                            lastMarked = next.getNodeId();\n                                            markedPosition = prevPosition;\n                                        }\n                                    }\n                                    ancestor = next;\n                                    ancestorId = ancestor.getNodeId();\n                                } else {\n                                    // no more ancestors: skip the remaining descendants for this document\n                                    while (broker.getBrokerPool().getNodeFactory().createFromStream(is) \n                                            != DLN.END_OF_DOCUMENT) {\n                                        StorageAddress.read(is);\n                                    }\n                                    break;\n                                }\n                            } else {\n                                // load the next descendant from the input stream\n                                prevPosition = ((BFile.PageInputStream)is).position();\n                                NodeId nextId = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                                if (nextId != DLN.END_OF_DOCUMENT) {\n                                    nodeId = nextId;\n                                    address = StorageAddress.read(is);\n                                } else {\n                                    // We need to remember the last ancestor in case there are more docs to process.\n                                    // Next document should start with this ancestor.\n                                    if (lastAncestor == null)\n                                        lastAncestor = ancestor;\n                                    \n                                    // check if we have more ancestors\n                                    if (citer.hasNextNode()) {\n                                        ancestor = citer.nextNode();\n                                        // if the ancestor set has more nodes and the following ancestor\n                                        // is a descendant of the previous one, we have to rescan the input stream\n                                        // for further matches\n                                        if (ancestor.getNodeId().isDescendantOf(ancestorId)) {\n                                            // rewind the input stream to the position from where we started\n                                            // for the previous ancestor node\n                                            prevPosition = markedPosition;\n                                            ((BFile.PageInputStream)is).seek(markedPosition);\n                                            nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(is);\n                                            address = StorageAddress.read(is);\n                                            ancestorId = ancestor.getNodeId();\n                                        } else {\n                                            ancestorId = ancestor.getNodeId();\n                                            break;\n                                        }\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    result.setSorted(storedDocument, ordered == ENTRIES_ORDERED);\n                    if (lastAncestor != null) {\n                        ancestor = lastAncestor;\n                        citer.setPosition(ancestor);\n                    }\n                }\n            } catch (EOFException e) {\n                //EOFExceptions are expected here\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);           \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.READ_LOCK);\n            }\n        }\n//        LOG.debug(\"Found: \" + result.getLength() + \" for \" + qname);\n        if (sameDocSet) {\n        \tresult.setDocumentSet(docs);\n        }\n        return result;\n    }","id":67803,"modified_method":"/**\n     * Optimized lookup method which directly implements the ancestor-descendant join. The algorithm\n     * does directly operate on the input stream containing the potential descendant nodes. It thus needs\n     * less comparisons than {@link #findElementsByTagName(byte, DocumentSet, QName, NodeSelector)}.\n     * \n     * @param type either {@link ElementValue#ATTRIBUTE}, {@link ElementValue#ELEMENT}\n     *      or {@link ElementValue#ATTRIBUTE_ID}\n     * @param docs the set of documents to look up in the index\n     * @param contextSet the set of ancestor nodes for which the method will try to find descendants\n     * @param contextId id of the current context expression as passed by the query engine\n     * @param qname the QName to search for\n     */\n    public NodeSet findDescendantsByTagName(byte type, QName qname, int axis,\n    \t\tDocumentSet docs, ExtArrayNodeSet contextSet,  int contextId) {\n//        LOG.debug(contextSet.toString());\n        short nodeType = getIndexType(type);\n        ByDocumentIterator citer = contextSet.iterateByDocument();\n        final ExtArrayNodeSet result = new ExtArrayNodeSet(docs.getLength(), 256);\n        final Lock lock = dbNodes.getLock();\n        // true if the output document set is the same as the input document set\n        boolean sameDocSet = true;\n        for (Iterator i = docs.getCollectionIterator(); i.hasNext();) {\n            //Compute a key for the node\n            Collection collection = (Collection) i.next();\n            short collectionId = collection.getId();\n            final Value key = computeTypedKey(type, collectionId, qname);\n            try {\n                lock.acquire(Lock.READ_LOCK);\n                VariableByteInput is;\n                /*\n                //TODO : uncomment and implement properly\n                //TODO : beware of null NS prefix : it looks to be polysemic (none vs. all)\n                //Test for \"*\" prefix\n                if (qname.getPrefix() == null) {\n                \ttry {\n\t                    final IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, key);\n\t                    ArrayList elements = dbNodes.findKeys(query);\t                     \n                    } catch (BTreeException e) {\n                        LOG.error(e.getMessage(), e);\n                        //TODO : throw an exception ? -pb\n                    } catch (TerminatedException e) {\n                        LOG.warn(e.getMessage(), e);                        \n                    }\n                    //TODO : iterate over the keys \n                } else */                \n                \tis = dbNodes.getAsStream(key); \n                //Does the node already has data in the index ?\n                if (is == null) {\n                \tsameDocSet = false;\n                    continue;\n                }\n                int lastDocId = DocumentImpl.UNKNOWN_DOCUMENT_ID;\n                NodeProxy ancestor = null;\n                \n                while (is.available() > 0) {\n                    int storedDocId = is.readInt();\n                    byte ordered = is.readByte();\n                    int gidsCount = is.readInt();\n                    //TOUNDERSTAND -pb\n                    int size = is.readFixedInt();\n                    DocumentImpl storedDocument = docs.getDoc(storedDocId);\n                    //Exit if the document is not concerned\n                    if (storedDocument == null) {\n                        is.skipBytes(size);\n                        continue;\n                    }\n                    // position the context iterator on the next document\n                    if (storedDocId != lastDocId || ordered == ENTRIES_UNORDERED) {\n                    \tciter.nextDocument(storedDocument);\n                    \tlastDocId = storedDocId;\n                    \tancestor = citer.nextNode();\n                    }\n                    // no ancestor node in the context set, skip the document\n                    if (ancestor == null || gidsCount == 0) {\n                    \tis.skipBytes(size);\n                        continue;\n                    }\n\n                    NodeId ancestorId = ancestor.getNodeId();\n                    long prevPosition = ((BFile.PageInputStream)is).position();\n                    long markedPosition = prevPosition;\n                    NodeId markedId = null;\n                    NodeId lastMarked = ancestorId;\n                    NodeId previousId = null;\n                    NodeProxy lastAncestor = null;\n\n                    // Process the nodes for the current document\n                    NodeId nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(previousId, is);\n                    previousId = nodeId;\n                    long address = StorageAddress.read(is);\n \n                    while (true) {\n                        int relation = nodeId.computeRelation(ancestorId);\n//                        System.out.println(ancestorId + \" -> \" + nodeId + \": \" + relation);\n                        if (relation != -1) {\n                            // current node is a descendant. walk through the descendants\n                            // and add them to the result\n                            if (((axis == Constants.CHILD_AXIS || axis == Constants.ATTRIBUTE_AXIS) && relation == NodeId.IS_CHILD) || \n                            \t\t(axis == Constants.DESCENDANT_AXIS && relation == NodeId.IS_DESCENDANT) ||\n                            \t\taxis == Constants.DESCENDANT_SELF_AXIS || axis == Constants.DESCENDANT_ATTRIBUTE_AXIS\n                        \t\t) {\n                                NodeProxy storedNode = new NodeProxy(storedDocument, nodeId, nodeType, address);\n                                result.add(storedNode, gidsCount);\n                                if (Expression.NO_CONTEXT_ID != contextId) {\n                                    storedNode.deepCopyContext(ancestor, contextId);\n                                } else\n                                    storedNode.copyContext(ancestor);\n                            }\n                            prevPosition = ((BFile.PageInputStream)is).position();\n                            NodeId next = broker.getBrokerPool().getNodeFactory().createFromStream(previousId, is);\n                            previousId = next;\n                            if (next != DLN.END_OF_DOCUMENT) {\n                                // retrieve the next descendant from the stream\n                                nodeId = next;\n                                address = StorageAddress.read(is);\n                            } else {\n                                // no more descendants. check if there are more ancestors\n                                if (citer.hasNextNode()) {\n                                    NodeProxy nextNode = citer.peekNode();\n                                    // reached the end of the input stream:\n                                    // if the ancestor set has more nodes and the following ancestor\n                                    // is a descendant of the previous one, we have to rescan the input stream\n                                    // for further matches\n                                    if (nextNode.getNodeId().isDescendantOf(ancestorId)) {\n                                        prevPosition = markedPosition;\n                                        ((BFile.PageInputStream)is).seek(markedPosition);\n                                        nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(markedId, is);\n                                        previousId = nodeId;\n                                        address = StorageAddress.read(is);\n                                        ancestor = citer.nextNode();\n                                        ancestorId = ancestor.getNodeId();\n                                    } else {\n//                                        ancestorId = ancestor.getNodeId();\n                                        break;\n                                    }\n                                } else {\n                                    break;\n                                }\n                            }\n                        } else {\n                            // current node is not a descendant of the ancestor node. Compare the\n                            // node ids and proceed with next descendant or ancestor.\n                            int cmp = ancestorId.compareTo(nodeId);\n                            if (cmp < 0) {\n                                // check if we have more ancestors\n                                if (citer.hasNextNode()) {\n                                    NodeProxy next = citer.nextNode();\n                                    // if the ancestor set has more nodes and the following ancestor\n                                    // is a descendant of the previous one, we have to rescan the input stream\n                                    // for further matches\n                                    if (next.getNodeId().isDescendantOf(ancestorId)) {\n                                        // rewind the input stream to the position from where we started\n                                        // for the previous ancestor node\n                                        ((BFile.PageInputStream)is).seek(markedPosition);\n                                        nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(markedId, is);\n                                        previousId = nodeId;\n                                        address = StorageAddress.read(is);\n                                    } else {\n                                        // mark the current position in the input stream\n                                        if (!next.getNodeId().isDescendantOf(lastMarked)) {\n                                            lastMarked = next.getNodeId();\n                                            markedPosition = prevPosition;\n                                            markedId = lastMarked;\n                                        }\n                                    }\n                                    ancestor = next;\n                                    ancestorId = ancestor.getNodeId();\n                                } else {\n                                    // no more ancestors: skip the remaining descendants for this document\n                                    while ((previousId = broker.getBrokerPool().getNodeFactory().createFromStream(previousId, is))\n                                            != DLN.END_OF_DOCUMENT) {\n                                        StorageAddress.read(is);\n                                    }\n                                    break;\n                                }\n                            } else {\n                                // load the next descendant from the input stream\n                                prevPosition = ((BFile.PageInputStream)is).position();\n                                NodeId nextId = broker.getBrokerPool().getNodeFactory().createFromStream(previousId, is);\n                                previousId = nextId;\n                                if (nextId != DLN.END_OF_DOCUMENT) {\n                                    nodeId = nextId;\n                                    address = StorageAddress.read(is);\n                                } else {\n                                    // We need to remember the last ancestor in case there are more docs to process.\n                                    // Next document should start with this ancestor.\n                                    if (lastAncestor == null)\n                                        lastAncestor = ancestor;\n                                    \n                                    // check if we have more ancestors\n                                    if (citer.hasNextNode()) {\n                                        ancestor = citer.nextNode();\n                                        // if the ancestor set has more nodes and the following ancestor\n                                        // is a descendant of the previous one, we have to rescan the input stream\n                                        // for further matches\n                                        if (ancestor.getNodeId().isDescendantOf(ancestorId)) {\n                                            // rewind the input stream to the position from where we started\n                                            // for the previous ancestor node\n                                            prevPosition = markedPosition;\n                                            ((BFile.PageInputStream)is).seek(markedPosition);\n                                            nodeId = broker.getBrokerPool().getNodeFactory().createFromStream(markedId, is);\n                                            previousId = nodeId;\n                                            address = StorageAddress.read(is);\n                                            ancestorId = ancestor.getNodeId();\n                                        } else {\n                                            ancestorId = ancestor.getNodeId();\n                                            break;\n                                        }\n                                    } else {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    result.setSorted(storedDocument, ordered == ENTRIES_ORDERED);\n                    if (lastAncestor != null) {\n                        ancestor = lastAncestor;\n                        citer.setPosition(ancestor);\n                    }\n                }\n            } catch (EOFException e) {\n                //EOFExceptions are expected here\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbNodes.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);           \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.READ_LOCK);\n            }\n        }\n//        LOG.debug(\"Found: \" + result.getLength() + \" for \" + qname);\n        if (sameDocSet) {\n        \tresult.setDocumentSet(docs);\n        }\n        return result;\n    }","commit_id":"7c1db398f18c4c4b352db74e2f37d2471cf52155","url":"https://github.com/eXist-db/exist"},{"original_method":"@Test\n    public void testRowIterationDeletionTime()\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE1);\n        String CF_NAME = \"Standard3\";\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF_NAME);\n        DecoratedKey key = Util.dk(\"key\");\n\n        // Delete row in first sstable\n        Mutation rm = new Mutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 0);\n        rm.add(CF_NAME, Util.cellname(\"c\"), ByteBufferUtil.bytes(\"values\"), 0L);\n        rm.apply();\n        store.forceBlockingFlush();\n\n        // Delete row in second sstable with higher timestamp\n        rm = new Mutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 1);\n        rm.add(CF_NAME, Util.cellname(\"c\"), ByteBufferUtil.bytes(\"values\"), 1L);\n        DeletionInfo delInfo2 = rm.getColumnFamilies().iterator().next().deletionInfo();\n        assert delInfo2.getTopLevelDeletion().markedForDeleteAt == 1L;\n        rm.apply();\n        store.forceBlockingFlush();\n\n        ColumnFamily cf = Util.getRangeSlice(store).iterator().next().cf;\n        assert cf.deletionInfo().equals(delInfo2);\n    }","id":67804,"modified_method":"@Test\n    public void testRowIterationDeletionTime()\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE1);\n        String CF_NAME = \"Standard3\";\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF_NAME);\n        DecoratedKey key = Util.dk(\"key\");\n\n        // Delete row in first sstable\n        Mutation rm = new Mutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 0);\n        rm.add(CF_NAME, Util.cellname(\"c\"), ByteBufferUtil.bytes(\"values\"), 0L);\n        rm.apply();\n        store.forceBlockingFlush();\n\n        // Delete row in second sstable with higher timestamp\n        rm = new Mutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 1);\n        rm.add(CF_NAME, Util.cellname(\"c\"), ByteBufferUtil.bytes(\"values\"), 1L);\n        DeletionInfo delInfo2 = rm.getColumnFamilies().iterator().next().deletionInfo();\n        assert delInfo2.getTopLevelDeletion().markedForDeleteAt == 1L;\n        rm.apply();\n        store.forceBlockingFlush();\n\n        ColumnFamily cf = Util.getRangeSlice(store).get(0).cf;\n        assert cf.deletionInfo().equals(delInfo2);\n    }","commit_id":"572d328762bee9100549963a6826fdb9f633af2a","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRowIterationDeletion()\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE1);\n        String CF_NAME = \"Standard3\";\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF_NAME);\n        DecoratedKey key = Util.dk(\"key\");\n\n        // Delete a row in first sstable\n        Mutation rm = new Mutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 0);\n        rm.apply();\n        store.forceBlockingFlush();\n\n        ColumnFamily cf = Util.getRangeSlice(store).iterator().next().cf;\n        assert cf != null;\n    }","id":67805,"modified_method":"@Test\n    public void testRowIterationDeletion()\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE1);\n        String CF_NAME = \"Standard3\";\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF_NAME);\n        DecoratedKey key = Util.dk(\"key\");\n\n        // Delete a row in first sstable\n        Mutation rm = new Mutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 0);\n        rm.apply();\n        store.forceBlockingFlush();\n\n        ColumnFamily cf = Util.getRangeSlice(store).get(0).cf;\n        assert cf != null;\n    }","commit_id":"572d328762bee9100549963a6826fdb9f633af2a","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testGetPositionsForRangesWithKeyCache() throws ExecutionException, InterruptedException\n    {\n        Keyspace keyspace = Keyspace.open(\"Keyspace1\");\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(\"Standard2\");\n        CacheService.instance.keyCache.setCapacity(100);\n\n        // insert data and compact to a single sstable\n        CompactionManager.instance.disableAutoCompaction();\n        for (int j = 0; j < 10; j++)\n        {\n            ByteBuffer key = ByteBufferUtil.bytes(String.valueOf(j));\n            Mutation rm = new Mutation(\"Keyspace1\", key);\n            rm.add(\"Standard2\", cellname(\"0\"), ByteBufferUtil.EMPTY_BYTE_BUFFER, j);\n            rm.apply();\n        }\n        store.forceBlockingFlush();\n        CompactionManager.instance.performMaximal(store);\n\n        SSTableReader sstable = store.getSSTables().iterator().next();\n        long p2 = sstable.getPosition(k(2), SSTableReader.Operator.EQ).position;\n        long p3 = sstable.getPosition(k(3), SSTableReader.Operator.EQ).position;\n        long p6 = sstable.getPosition(k(6), SSTableReader.Operator.EQ).position;\n        long p7 = sstable.getPosition(k(7), SSTableReader.Operator.EQ).position;\n\n        Pair<Long, Long> p = sstable.getPositionsForRanges(makeRanges(t(2), t(6))).iterator().next();\n\n        // range are start exclusive so we should start at 3\n        assert p.left == p3;\n\n        // to capture 6 we have to stop at the start of 7\n        assert p.right == p7;\n    }","id":67806,"modified_method":"@Test\n    public void testGetPositionsForRangesWithKeyCache() throws ExecutionException, InterruptedException\n    {\n        Keyspace keyspace = Keyspace.open(\"Keyspace1\");\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(\"Standard2\");\n        CacheService.instance.keyCache.setCapacity(100);\n\n        // insert data and compact to a single sstable\n        CompactionManager.instance.disableAutoCompaction();\n        for (int j = 0; j < 10; j++)\n        {\n            ByteBuffer key = ByteBufferUtil.bytes(String.valueOf(j));\n            Mutation rm = new Mutation(\"Keyspace1\", key);\n            rm.add(\"Standard2\", cellname(\"0\"), ByteBufferUtil.EMPTY_BYTE_BUFFER, j);\n            rm.apply();\n        }\n        store.forceBlockingFlush();\n        CompactionManager.instance.performMaximal(store);\n\n        SSTableReader sstable = store.getSSTables().iterator().next();\n        long p2 = sstable.getPosition(k(2), SSTableReader.Operator.EQ).position;\n        long p3 = sstable.getPosition(k(3), SSTableReader.Operator.EQ).position;\n        long p6 = sstable.getPosition(k(6), SSTableReader.Operator.EQ).position;\n        long p7 = sstable.getPosition(k(7), SSTableReader.Operator.EQ).position;\n\n        Pair<Long, Long> p = sstable.getPositionsForRanges(makeRanges(t(2), t(6))).get(0);\n\n        // range are start exclusive so we should start at 3\n        assert p.left == p3;\n\n        // to capture 6 we have to stop at the start of 7\n        assert p.right == p7;\n    }","commit_id":"572d328762bee9100549963a6826fdb9f633af2a","url":"https://github.com/apache/cassandra"},{"original_method":"public void addUpdateForKey(ColumnFamily cf, ByteBuffer key, Composite prefix, UpdateParameters params)\n    throws InvalidRequestException\n    {\n        // Inserting the CQL row marker (see #4361)\n        // We always need to insert a marker for INSERT, because of the following situation:\n        //   CREATE TABLE t ( k int PRIMARY KEY, c text );\n        //   INSERT INTO t(k, c) VALUES (1, 1)\n        //   DELETE c FROM t WHERE k = 1;\n        //   SELECT * FROM t;\n        // The last query should return one row (but with c == null). Adding the marker with the insert make sure\n        // the semantic is correct (while making sure a 'DELETE FROM t WHERE k = 1' does remove the row entirely)\n        //\n        // We do not insert the marker for UPDATE however, as this amount to updating the columns in the WHERE\n        // clause which is inintuitive (#6782)\n        //\n        // We never insert markers for Super CF as this would confuse the thrift side.\n        if (type == StatementType.INSERT && cfm.isCQL3Table() && !prefix.isStatic())\n            cf.addColumn(params.makeColumn(cfm.comparator.rowMarker(prefix), ByteBufferUtil.EMPTY_BYTE_BUFFER));\n\n        List<Operation> updates = getOperations();\n\n        if (cfm.comparator.isDense())\n        {\n            if (prefix.isEmpty())\n                throw new InvalidRequestException(String.format(\"Missing PRIMARY KEY part %s\", cfm.clusteringColumns().iterator().next()));\n\n            // An empty name for the compact value is what we use to recognize the case where there is not column\n            // outside the PK, see CreateStatement.\n            if (!cfm.compactValueColumn().name.bytes.hasRemaining())\n            {\n                // There is no column outside the PK. So no operation could have passed through validation\n                assert updates.isEmpty();\n                new Constants.Setter(cfm.compactValueColumn(), EMPTY).execute(key, cf, prefix, params);\n            }\n            else\n            {\n                // dense means we don't have a row marker, so don't accept to set only the PK. See CASSANDRA-5648.\n                if (updates.isEmpty())\n                    throw new InvalidRequestException(String.format(\"Column %s is mandatory for this COMPACT STORAGE table\", cfm.compactValueColumn().name));\n\n                for (Operation update : updates)\n                    update.execute(key, cf, prefix, params);\n            }\n        }\n        else\n        {\n            for (Operation update : updates)\n                update.execute(key, cf, prefix, params);\n        }\n    }","id":67807,"modified_method":"public void addUpdateForKey(ColumnFamily cf, ByteBuffer key, Composite prefix, UpdateParameters params)\n    throws InvalidRequestException\n    {\n        // Inserting the CQL row marker (see #4361)\n        // We always need to insert a marker for INSERT, because of the following situation:\n        //   CREATE TABLE t ( k int PRIMARY KEY, c text );\n        //   INSERT INTO t(k, c) VALUES (1, 1)\n        //   DELETE c FROM t WHERE k = 1;\n        //   SELECT * FROM t;\n        // The last query should return one row (but with c == null). Adding the marker with the insert make sure\n        // the semantic is correct (while making sure a 'DELETE FROM t WHERE k = 1' does remove the row entirely)\n        //\n        // We do not insert the marker for UPDATE however, as this amount to updating the columns in the WHERE\n        // clause which is inintuitive (#6782)\n        //\n        // We never insert markers for Super CF as this would confuse the thrift side.\n        if (type == StatementType.INSERT && cfm.isCQL3Table() && !prefix.isStatic())\n            cf.addColumn(params.makeColumn(cfm.comparator.rowMarker(prefix), ByteBufferUtil.EMPTY_BYTE_BUFFER));\n\n        List<Operation> updates = getOperations();\n\n        if (cfm.comparator.isDense())\n        {\n            if (prefix.isEmpty())\n                throw new InvalidRequestException(String.format(\"Missing PRIMARY KEY part %s\", cfm.clusteringColumns().get(0)));\n\n            // An empty name for the compact value is what we use to recognize the case where there is not column\n            // outside the PK, see CreateStatement.\n            if (!cfm.compactValueColumn().name.bytes.hasRemaining())\n            {\n                // There is no column outside the PK. So no operation could have passed through validation\n                assert updates.isEmpty();\n                new Constants.Setter(cfm.compactValueColumn(), EMPTY).execute(key, cf, prefix, params);\n            }\n            else\n            {\n                // dense means we don't have a row marker, so don't accept to set only the PK. See CASSANDRA-5648.\n                if (updates.isEmpty())\n                    throw new InvalidRequestException(String.format(\"Column %s is mandatory for this COMPACT STORAGE table\", cfm.compactValueColumn().name));\n\n                for (Operation update : updates)\n                    update.execute(key, cf, prefix, params);\n            }\n        }\n        else\n        {\n            for (Operation update : updates)\n                update.execute(key, cf, prefix, params);\n        }\n    }","commit_id":"572d328762bee9100549963a6826fdb9f633af2a","url":"https://github.com/apache/cassandra"},{"original_method":"private static void checkManifest(AbstractCompactionStrategy strategy, ColumnFamilyStore cfs, Collection<SSTableReader> sstables)\n    {\n        WrappingCompactionStrategy wrappingStrategy = (WrappingCompactionStrategy)strategy;\n        int maxSizeInMB = (int)((cfs.getCompactionStrategy().getMaxSSTableBytes()) / (1024L * 1024L));\n        if (wrappingStrategy.getWrappedStrategies().size() == 2 && wrappingStrategy.getWrappedStrategies().iterator().next() instanceof LeveledCompactionStrategy)\n        {\n            System.out.println(\"Checking leveled manifest\");\n            Predicate<SSTableReader> repairedPredicate = new Predicate<SSTableReader>()\n            {\n                @Override\n                public boolean apply(SSTableReader sstable)\n                {\n                    return sstable.isRepaired();\n                }\n            };\n\n            List<SSTableReader> repaired = Lists.newArrayList(Iterables.filter(sstables, repairedPredicate));\n            List<SSTableReader> unRepaired = Lists.newArrayList(Iterables.filter(sstables, Predicates.not(repairedPredicate)));\n\n            LeveledManifest repairedManifest = LeveledManifest.create(cfs, maxSizeInMB, repaired);\n            for (int i = 1; i < repairedManifest.getLevelCount(); i++)\n            {\n                repairedManifest.repairOverlappingSSTables(i);\n            }\n            LeveledManifest unRepairedManifest = LeveledManifest.create(cfs, maxSizeInMB, unRepaired);\n            for (int i = 1; i < unRepairedManifest.getLevelCount(); i++)\n            {\n                unRepairedManifest.repairOverlappingSSTables(i);\n            }\n        }\n    }","id":67808,"modified_method":"private static void checkManifest(AbstractCompactionStrategy strategy, ColumnFamilyStore cfs, Collection<SSTableReader> sstables)\n    {\n        WrappingCompactionStrategy wrappingStrategy = (WrappingCompactionStrategy)strategy;\n        int maxSizeInMB = (int)((cfs.getCompactionStrategy().getMaxSSTableBytes()) / (1024L * 1024L));\n        if (wrappingStrategy.getWrappedStrategies().size() == 2 && wrappingStrategy.getWrappedStrategies().get(0) instanceof LeveledCompactionStrategy)\n        {\n            System.out.println(\"Checking leveled manifest\");\n            Predicate<SSTableReader> repairedPredicate = new Predicate<SSTableReader>()\n            {\n                @Override\n                public boolean apply(SSTableReader sstable)\n                {\n                    return sstable.isRepaired();\n                }\n            };\n\n            List<SSTableReader> repaired = Lists.newArrayList(Iterables.filter(sstables, repairedPredicate));\n            List<SSTableReader> unRepaired = Lists.newArrayList(Iterables.filter(sstables, Predicates.not(repairedPredicate)));\n\n            LeveledManifest repairedManifest = LeveledManifest.create(cfs, maxSizeInMB, repaired);\n            for (int i = 1; i < repairedManifest.getLevelCount(); i++)\n            {\n                repairedManifest.repairOverlappingSSTables(i);\n            }\n            LeveledManifest unRepairedManifest = LeveledManifest.create(cfs, maxSizeInMB, unRepaired);\n            for (int i = 1; i < unRepairedManifest.getLevelCount(); i++)\n            {\n                unRepairedManifest.repairOverlappingSSTables(i);\n            }\n        }\n    }","commit_id":"3608bd2494a82ede56471f1cbe5356f90d0a95d1","url":"https://github.com/apache/cassandra"},{"original_method":"@Test\n    public void testRowIterationDeletionTime() throws IOException, ExecutionException, InterruptedException\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE1);\n        String CF_NAME = \"Standard3\";\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF_NAME);\n        DecoratedKey key = Util.dk(\"key\");\n\n        // Delete row in first sstable\n        RowMutation rm = new RowMutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 0);\n        rm.add(CF_NAME, ByteBufferUtil.bytes(\"c\"), ByteBufferUtil.bytes(\"values\"), 0L);\n        DeletionInfo delInfo1 = rm.getColumnFamilies().iterator().next().deletionInfo();\n        rm.apply();\n        store.forceBlockingFlush();\n\n        // Delete row in second sstable with higher timestamp\n        rm = new RowMutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 1);\n        rm.add(CF_NAME, ByteBufferUtil.bytes(\"c\"), ByteBufferUtil.bytes(\"values\"), 1L);\n        DeletionInfo delInfo2 = rm.getColumnFamilies().iterator().next().deletionInfo();\n        assert delInfo2.getTopLevelDeletion().markedForDeleteAt == 1L;\n        rm.apply();\n        store.forceBlockingFlush();\n\n        ColumnFamily cf = Util.getRangeSlice(store).iterator().next().cf;\n        assert cf.deletionInfo().equals(delInfo2);\n    }","id":67809,"modified_method":"@Test\n    public void testRowIterationDeletionTime() throws IOException, ExecutionException, InterruptedException\n    {\n        Keyspace keyspace = Keyspace.open(KEYSPACE1);\n        String CF_NAME = \"Standard3\";\n        ColumnFamilyStore store = keyspace.getColumnFamilyStore(CF_NAME);\n        DecoratedKey key = Util.dk(\"key\");\n\n        // Delete row in first sstable\n        RowMutation rm = new RowMutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 0);\n        rm.add(CF_NAME, ByteBufferUtil.bytes(\"c\"), ByteBufferUtil.bytes(\"values\"), 0L);\n        DeletionInfo delInfo1 = rm.getColumnFamilies().iterator().next().deletionInfo();\n        rm.apply();\n        store.forceBlockingFlush();\n\n        // Delete row in second sstable with higher timestamp\n        rm = new RowMutation(KEYSPACE1, key.key);\n        rm.delete(CF_NAME, 1);\n        rm.add(CF_NAME, ByteBufferUtil.bytes(\"c\"), ByteBufferUtil.bytes(\"values\"), 1L);\n        DeletionInfo delInfo2 = rm.getColumnFamilies().iterator().next().deletionInfo();\n        assert delInfo2.getTopLevelDeletion().markedForDeleteAt == 1L;\n        rm.apply();\n        store.forceBlockingFlush();\n\n        ColumnFamily cf = Util.getRangeSlice(store).get(0).cf;\n        assert cf.deletionInfo().equals(delInfo2);\n    }","commit_id":"c651f83627b4bc491e2ebe6c8f29c311d40ed2a6","url":"https://github.com/apache/cassandra"},{"original_method":"public void initializeParsers(ExtensionParsingContext context) {\n        for (Namespace namespace : Namespace.values()) {\n            if (namespace == Namespace.UNKNOWN) {\n                continue;\n            }\n            context.setSubsystemXmlMapping(SUBSYSTEM_NAME, namespace.getUriString(), MessagingSubsystemParser.getInstance());\n        }\n    }","id":67810,"modified_method":"public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, MESSAGING_1_0.getUriString(), MessagingSubsystemParser.getInstance());\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, MESSAGING_1_1.getUriString(), MessagingSubsystemParser.getInstance());\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, MESSAGING_1_2.getUriString(), Messaging12SubsystemParser.getInstance());\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0);\n        subsystem.registerXMLElementWriter(MessagingSubsystemParser.getInstance());\n\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        // Root resource\n        final ManagementResourceRegistration rootRegistration = subsystem.registerSubsystemModel(MessagingSubsystemRootResourceDefinition.INSTANCE);\n        rootRegistration.registerOperationHandler(DESCRIBE, MessagingSubsystemDescribeHandler.INSTANCE, MessagingSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        // HQ servers\n        final ManagementResourceRegistration serverRegistration = rootRegistration.registerSubModel(new HornetQServerResourceDefinition(registerRuntimeOnly));\n\n        // TODO convert the remaining resources to ResourceDefinition\n        // Runtime addresses\n        if (registerRuntimeOnly) {\n            final ManagementResourceRegistration coreAddress = serverRegistration.registerSubModel(CORE_ADDRESS_PATH, MessagingSubsystemProviders.CORE_ADDRESS);\n            coreAddress.setRuntimeOnly(true);\n            AddressControlHandler.INSTANCE.register(coreAddress);\n        }\n\n        // Address settings\n        final ManagementResourceRegistration addressSetting = serverRegistration.registerSubModel(ADDRESS_SETTING, MessagingSubsystemProviders.ADDRESS_SETTING);\n        addressSetting.registerOperationHandler(ADD, AddressSettingAdd.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_ADD);\n        addressSetting.registerOperationHandler(REMOVE, AddressSettingRemove.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_REMOVE);\n        AddressSettingsWriteHandler.INSTANCE.registerAttributes(addressSetting, registerRuntimeOnly);\n\n        // Broadcast groups\n        final ManagementResourceRegistration broadcastGroups = serverRegistration.registerSubModel(BROADCAST_GROUP_PATH, MessagingSubsystemProviders.BROADCAST_GROUP_RESOURCE);\n        broadcastGroups.registerOperationHandler(ADD, BroadcastGroupAdd.INSTANCE, BroadcastGroupAdd.INSTANCE);\n        broadcastGroups.registerOperationHandler(REMOVE, BroadcastGroupRemove.INSTANCE, BroadcastGroupRemove.INSTANCE);\n        BroadcastGroupWriteAttributeHandler.INSTANCE.registerAttributes(broadcastGroups, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BroadcastGroupControlHandler.INSTANCE.register(broadcastGroups);\n        }\n        // getConnectorPairs, -- no, this is just the same as attribute connector-refs\n\n        // Discovery groups\n        final ManagementResourceRegistration discoveryGroups = serverRegistration.registerSubModel(DISCOVERY_GROUP_PATH, MessagingSubsystemProviders.DISCOVERY_GROUP_RESOURCE);\n        discoveryGroups.registerOperationHandler(ADD, DiscoveryGroupAdd.INSTANCE, DiscoveryGroupAdd.INSTANCE);\n        discoveryGroups.registerOperationHandler(REMOVE, DiscoveryGroupRemove.INSTANCE, DiscoveryGroupRemove.INSTANCE);\n        DiscoveryGroupWriteAttributeHandler.INSTANCE.registerAttributes(discoveryGroups, registerRuntimeOnly);\n\n        // Diverts\n        final ManagementResourceRegistration diverts = serverRegistration.registerSubModel(DIVERT_PATH, MessagingSubsystemProviders.DIVERT_RESOURCE);\n        diverts.registerOperationHandler(ADD, DivertAdd.INSTANCE, DivertAdd.INSTANCE);\n        diverts.registerOperationHandler(REMOVE, DivertRemove.INSTANCE, DivertRemove.INSTANCE);\n        DivertConfigurationWriteHandler.INSTANCE.registerAttributes(diverts, registerRuntimeOnly);\n\n        // Core queues\n        final ManagementResourceRegistration queue = serverRegistration.registerSubModel(PathElement.pathElement(QUEUE), MessagingSubsystemProviders.QUEUE_RESOURCE);\n        queue.registerOperationHandler(ADD, QueueAdd.INSTANCE, QueueAdd.INSTANCE, false);\n        queue.registerOperationHandler(REMOVE, QueueRemove.INSTANCE, QueueRemove.INSTANCE, false);\n        QueueConfigurationWriteHandler.INSTANCE.registerAttributes(queue, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            QueueReadAttributeHandler.INSTANCE.registerAttributes(queue);\n            QueueControlHandler.INSTANCE.registerOperations(queue);\n        }\n        // getExpiryAddress, setExpiryAddress, getDeadLetterAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n\n        final ManagementResourceRegistration acceptor = serverRegistration.registerSubModel(GENERIC_ACCEPTOR, MessagingSubsystemProviders.ACCEPTOR);\n        acceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.ACCEPTOR_ADD);\n        acceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(acceptor, registerRuntimeOnly);\n        createParamRegistration(acceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(acceptor);\n        }\n\n\n        // remote acceptor\n        final ManagementResourceRegistration remoteAcceptor = serverRegistration.registerSubModel(REMOTE_ACCEPTOR, MessagingSubsystemProviders.REMOTE_ACCEPTOR);\n        remoteAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_ACCEPTOR_ADD);\n        remoteAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteAcceptor, registerRuntimeOnly);\n        createParamRegistration(remoteAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(remoteAcceptor);\n        }\n\n        // in-vm acceptor\n        final ManagementResourceRegistration inVMAcceptor = serverRegistration.registerSubModel(IN_VM_ACCEPTOR, MessagingSubsystemProviders.IN_VM_ACCEPTOR);\n        inVMAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_ACCEPTOR_ADD);\n        inVMAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMAcceptor, registerRuntimeOnly);\n        createParamRegistration(inVMAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(inVMAcceptor);\n        }\n\n        // connector\n        final ManagementResourceRegistration connector = serverRegistration.registerSubModel(GENERIC_CONNECTOR, MessagingSubsystemProviders.CONNECTOR);\n        connector.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.CONNECTOR_ADD);\n        connector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(connector, registerRuntimeOnly);\n        createParamRegistration(connector);\n\n        // remote connector\n        final ManagementResourceRegistration remoteConnector = serverRegistration.registerSubModel(REMOTE_CONNECTOR, MessagingSubsystemProviders.REMOTE_CONNECTOR);\n        remoteConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_CONNECTOR_ADD);\n        remoteConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteConnector, registerRuntimeOnly);\n        createParamRegistration(remoteConnector);\n\n        // in-vm connector\n        final ManagementResourceRegistration inVMConnector = serverRegistration.registerSubModel(IN_VM_CONNECTOR, MessagingSubsystemProviders.IN_VM_CONNECTOR);\n        inVMConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_CONNECTOR_ADD);\n        inVMConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMConnector, registerRuntimeOnly);\n        createParamRegistration(inVMConnector);\n\n        // Bridges\n        final ManagementResourceRegistration bridge = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.BRIDGE), MessagingSubsystemProviders.BRIDGE_RESOURCE);\n        bridge.registerOperationHandler(ADD, BridgeAdd.INSTANCE, BridgeAdd.INSTANCE, false);\n        bridge.registerOperationHandler(REMOVE, BridgeRemove.INSTANCE, BridgeRemove.INSTANCE, false);\n        BridgeWriteAttributeHandler.INSTANCE.registerAttributes(bridge, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BridgeControlHandler.INSTANCE.register(bridge);\n        }\n\n        // Cluster connections\n        final ManagementResourceRegistration cluster = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CLUSTER_CONNECTION),\n                MessagingSubsystemProviders.CLUSTER_CONNECTION_RESOURCE);\n        cluster.registerOperationHandler(ADD, ClusterConnectionAdd.INSTANCE, ClusterConnectionAdd.INSTANCE, false);\n        cluster.registerOperationHandler(REMOVE, ClusterConnectionRemove.INSTANCE, ClusterConnectionRemove.INSTANCE, false);\n        ClusterConnectionWriteAttributeHandler.INSTANCE.registerAttributes(cluster, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            ClusterConnectionControlHandler.INSTANCE.register(cluster);\n        }\n\n        // Grouping Handler\n        final ManagementResourceRegistration groupingHandler = serverRegistration.registerSubModel(GROUPING_HANDLER_PATH, MessagingSubsystemProviders.GROUPING_HANDLER_RESOURCE);\n        groupingHandler.registerOperationHandler(ADD, GroupingHandlerAdd.INSTANCE, GroupingHandlerAdd.INSTANCE);\n        groupingHandler.registerOperationHandler(REMOVE, GroupingHandlerRemove.INSTANCE, GroupingHandlerRemove.INSTANCE);\n        GroupingHandlerWriteAttributeHandler.INSTANCE.registerAttributes(groupingHandler, registerRuntimeOnly);\n\n        // Connector services\n        final ManagementResourceRegistration connectorService = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CONNECTOR_SERVICE),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_RESOURCE);\n        connectorService.registerOperationHandler(ADD, ConnectorServiceAdd.INSTANCE, ConnectorServiceAdd.INSTANCE, false);\n        connectorService.registerOperationHandler(REMOVE, ConnectorServiceRemove.INSTANCE, ConnectorServiceRemove.INSTANCE, false);\n        ConnectorServiceWriteAttributeHandler.INSTANCE.registerAttributes(connectorService, registerRuntimeOnly);\n\n        final ManagementResourceRegistration connectorServiceParam = connectorService.registerSubModel(PathElement.pathElement(CommonAttributes.PARAM),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_PARAM_RESOURCE);\n        connectorServiceParam.registerOperationHandler(ADD, ConnectorServiceParamAdd.INSTANCE, ConnectorServiceParamAdd.INSTANCE, false);\n        connectorServiceParam.registerOperationHandler(REMOVE, ConnectorServiceParamRemove.INSTANCE, ConnectorServiceParamRemove.INSTANCE, false);\n        connectorServiceParam.registerReadWriteAttribute(CommonAttributes.VALUE.getName(), null, ConnectorServiceParamWriteAttributeHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n\n        // Messaging paths\n        for (final String path : CommonAttributes.PATHS) {\n            ManagementResourceRegistration bindings = serverRegistration.registerSubModel(PathElement.pathElement(PATH, path),\n                    new MessagingSubsystemProviders.PathProvider(path));\n            MessagingPathHandlers.register(bindings);\n        }\n\n        // Connection factories\n        final ManagementResourceRegistration cfs = serverRegistration.registerSubModel(CFS_PATH, MessagingSubsystemProviders.CF);\n        cfs.registerOperationHandler(ADD, ConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.CF_ADD, false);\n        cfs.registerOperationHandler(REMOVE, ConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.CF_REMOVE, false);\n        ConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(cfs);\n        if (registerRuntimeOnly) {\n            ConnectionFactoryReadAttributeHandler.INSTANCE.registerAttributes(cfs);\n        }\n        ConnectionFactoryAddJndiHandler.INSTANCE.registerOperation(cfs);\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // Resource Adapter Pooled connection factories\n        final ManagementResourceRegistration resourceAdapters = serverRegistration.registerSubModel(RA_PATH, MessagingSubsystemProviders.RA);\n        resourceAdapters.registerOperationHandler(ADD, PooledConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.RA_ADD, false);\n        resourceAdapters.registerOperationHandler(REMOVE, PooledConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.RA_REMOVE);\n        PooledConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(resourceAdapters, registerRuntimeOnly);\n        // TODO how do ConnectionFactoryControl things relate?\n\n        // JMS Queues\n        final ManagementResourceRegistration queues = serverRegistration.registerSubModel(JMS_QUEUE_PATH, MessagingSubsystemProviders.JMS_QUEUE_RESOURCE);\n        queues.registerOperationHandler(ADD, JMSQueueAdd.INSTANCE, JMSQueueAdd.INSTANCE, false);\n        queues.registerOperationHandler(REMOVE, JMSQueueRemove.INSTANCE, JMSQueueRemove.INSTANCE, false);\n        JMSQueueConfigurationWriteHandler.INSTANCE.registerAttributes(queues, registerRuntimeOnly);\n        JMSQueueAddJndiHandler.INSTANCE.registerOperation(queues);\n        if (registerRuntimeOnly) {\n            JMSQueueReadAttributeHandler.INSTANCE.registerAttributes(queues);\n            JMSQueueControlHandler.INSTANCE.registerOperations(queues);\n        }\n        // setExpiryAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // JMS Topics\n        final ManagementResourceRegistration topics = serverRegistration.registerSubModel(TOPIC_PATH, MessagingSubsystemProviders.JMS_TOPIC_RESOURCE);\n        topics.registerOperationHandler(ADD, JMSTopicAdd.INSTANCE, JMSTopicAdd.INSTANCE, false);\n        topics.registerOperationHandler(REMOVE, JMSTopicRemove.INSTANCE, JMSTopicRemove.INSTANCE, false);\n        JMSTopicConfigurationWriteHandler.INSTANCE.registerAttributes(topics);\n        JMSTopicAddJndiHandler.INSTANCE.registerOperation(topics);\n        if (registerRuntimeOnly) {\n            JMSTopicReadAttributeHandler.INSTANCE.registerAttributes(topics);\n            JMSTopicControlHandler.INSTANCE.registerOperations(topics);\n        }\n        // getJNDIBindings (no -- same as \"entries\")\n\n        final ManagementResourceRegistration securitySettings = serverRegistration.registerSubModel(SECURITY_SETTING, MessagingSubsystemProviders.SECURITY_SETTING);\n        securitySettings.registerOperationHandler(ADD, SecuritySettingAdd.INSTANCE, SecuritySettingAdd.INSTANCE);\n        securitySettings.registerOperationHandler(REMOVE, SecuritySettingRemove.INSTANCE, SecuritySettingRemove.INSTANCE);\n\n        final ManagementResourceRegistration securityRole = securitySettings.registerSubModel(SECURITY_ROLE, MessagingSubsystemProviders.SECURITY_ROLE);\n        securityRole.registerOperationHandler(ADD, SecurityRoleAdd.INSTANCE, SecurityRoleAdd.INSTANCE);\n        securityRole.registerOperationHandler(REMOVE, SecurityRoleRemove.INSTANCE, SecurityRoleRemove.INSTANCE);\n        SecurityRoleAttributeHandler.INSTANCE.registerAttributes(securityRole, registerRuntimeOnly);\n\n        if (context.isRuntimeOnlyRegistrationValid()) {\n\n            ResourceDefinition deploymentsDef = new SimpleResourceDefinition(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, SUBSYSTEM_NAME), getResourceDescriptionResolver(\"deployed\"));\n            final ManagementResourceRegistration deploymentsRegistration = subsystem.registerDeploymentModel(deploymentsDef);\n            final ManagementResourceRegistration serverModel = deploymentsRegistration.registerSubModel(new HornetQServerResourceDefinition(true));\n\n            // JMS Queues\n            final ManagementResourceRegistration deploymentQueue = serverModel.registerSubModel(JMS_QUEUE_PATH, MessagingSubsystemProviders.JMS_QUEUE_RESOURCE);\n            JMSQueueReadAttributeHandler.INSTANCE.registerAttributes(deploymentQueue);\n            JMSQueueControlHandler.INSTANCE.registerOperations(deploymentQueue);\n            JMSQueueConfigurationRuntimeHandler.INSTANCE.registerAttributes(deploymentQueue);\n\n            // topics\n            final ManagementResourceRegistration deploymentTopics = serverModel.registerSubModel(TOPIC_PATH, MessagingSubsystemProviders.JMS_TOPIC_RESOURCE);\n            JMSTopicReadAttributeHandler.INSTANCE.registerAttributes(deploymentTopics);\n            JMSTopicControlHandler.INSTANCE.registerOperations(deploymentTopics);\n            JMSTopicConfigurationRuntimeHandler.INSTANCE.registerAttributes(deploymentTopics);\n\n        }\n    }","id":67811,"modified_method":"public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, 1, 0);\n        subsystem.registerXMLElementWriter(Messaging12SubsystemParser.getInstance());\n        boolean registerRuntimeOnly = context.isRuntimeOnlyRegistrationValid();\n\n        // Root resource\n        final ManagementResourceRegistration rootRegistration = subsystem.registerSubsystemModel(MessagingSubsystemRootResourceDefinition.INSTANCE);\n        rootRegistration.registerOperationHandler(DESCRIBE, MessagingSubsystemDescribeHandler.INSTANCE, MessagingSubsystemDescribeHandler.INSTANCE, false, OperationEntry.EntryType.PRIVATE);\n        // HQ servers\n        final ManagementResourceRegistration serverRegistration = rootRegistration.registerSubModel(new HornetQServerResourceDefinition(registerRuntimeOnly));\n\n        // TODO convert the remaining resources to ResourceDefinition\n        // Runtime addresses\n        if (registerRuntimeOnly) {\n            final ManagementResourceRegistration coreAddress = serverRegistration.registerSubModel(CORE_ADDRESS_PATH, MessagingSubsystemProviders.CORE_ADDRESS);\n            coreAddress.setRuntimeOnly(true);\n            AddressControlHandler.INSTANCE.register(coreAddress);\n        }\n\n        // Address settings\n        final ManagementResourceRegistration addressSetting = serverRegistration.registerSubModel(ADDRESS_SETTING, MessagingSubsystemProviders.ADDRESS_SETTING);\n        addressSetting.registerOperationHandler(ADD, AddressSettingAdd.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_ADD);\n        addressSetting.registerOperationHandler(REMOVE, AddressSettingRemove.INSTANCE, MessagingSubsystemProviders.ADDRESS_SETTING_REMOVE);\n        AddressSettingsWriteHandler.INSTANCE.registerAttributes(addressSetting, registerRuntimeOnly);\n\n        // Broadcast groups\n        final ManagementResourceRegistration broadcastGroups = serverRegistration.registerSubModel(BROADCAST_GROUP_PATH, MessagingSubsystemProviders.BROADCAST_GROUP_RESOURCE);\n        broadcastGroups.registerOperationHandler(ADD, BroadcastGroupAdd.INSTANCE, BroadcastGroupAdd.INSTANCE);\n        broadcastGroups.registerOperationHandler(REMOVE, BroadcastGroupRemove.INSTANCE, BroadcastGroupRemove.INSTANCE);\n        BroadcastGroupWriteAttributeHandler.INSTANCE.registerAttributes(broadcastGroups, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BroadcastGroupControlHandler.INSTANCE.register(broadcastGroups);\n        }\n        // getConnectorPairs, -- no, this is just the same as attribute connector-refs\n\n        // Discovery groups\n        final ManagementResourceRegistration discoveryGroups = serverRegistration.registerSubModel(DISCOVERY_GROUP_PATH, MessagingSubsystemProviders.DISCOVERY_GROUP_RESOURCE);\n        discoveryGroups.registerOperationHandler(ADD, DiscoveryGroupAdd.INSTANCE, DiscoveryGroupAdd.INSTANCE);\n        discoveryGroups.registerOperationHandler(REMOVE, DiscoveryGroupRemove.INSTANCE, DiscoveryGroupRemove.INSTANCE);\n        DiscoveryGroupWriteAttributeHandler.INSTANCE.registerAttributes(discoveryGroups, registerRuntimeOnly);\n\n        // Diverts\n        final ManagementResourceRegistration diverts = serverRegistration.registerSubModel(DIVERT_PATH, MessagingSubsystemProviders.DIVERT_RESOURCE);\n        diverts.registerOperationHandler(ADD, DivertAdd.INSTANCE, DivertAdd.INSTANCE);\n        diverts.registerOperationHandler(REMOVE, DivertRemove.INSTANCE, DivertRemove.INSTANCE);\n        DivertConfigurationWriteHandler.INSTANCE.registerAttributes(diverts, registerRuntimeOnly);\n\n        // Core queues\n        final ManagementResourceRegistration queue = serverRegistration.registerSubModel(PathElement.pathElement(QUEUE), MessagingSubsystemProviders.QUEUE_RESOURCE);\n        queue.registerOperationHandler(ADD, QueueAdd.INSTANCE, QueueAdd.INSTANCE, false);\n        queue.registerOperationHandler(REMOVE, QueueRemove.INSTANCE, QueueRemove.INSTANCE, false);\n        QueueConfigurationWriteHandler.INSTANCE.registerAttributes(queue, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            QueueReadAttributeHandler.INSTANCE.registerAttributes(queue);\n            QueueControlHandler.INSTANCE.registerOperations(queue);\n        }\n        // getExpiryAddress, setExpiryAddress, getDeadLetterAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n\n        final ManagementResourceRegistration acceptor = serverRegistration.registerSubModel(GENERIC_ACCEPTOR, MessagingSubsystemProviders.ACCEPTOR);\n        acceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.ACCEPTOR_ADD);\n        acceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(acceptor, registerRuntimeOnly);\n        createParamRegistration(acceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(acceptor);\n        }\n\n\n        // remote acceptor\n        final ManagementResourceRegistration remoteAcceptor = serverRegistration.registerSubModel(REMOTE_ACCEPTOR, MessagingSubsystemProviders.REMOTE_ACCEPTOR);\n        remoteAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_ACCEPTOR_ADD);\n        remoteAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteAcceptor, registerRuntimeOnly);\n        createParamRegistration(remoteAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(remoteAcceptor);\n        }\n\n        // in-vm acceptor\n        final ManagementResourceRegistration inVMAcceptor = serverRegistration.registerSubModel(IN_VM_ACCEPTOR, MessagingSubsystemProviders.IN_VM_ACCEPTOR);\n        inVMAcceptor.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_ACCEPTOR_ADD);\n        inVMAcceptor.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.ACCEPTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMAcceptor, registerRuntimeOnly);\n        createParamRegistration(inVMAcceptor);\n        if (registerRuntimeOnly) {\n            AcceptorControlHandler.INSTANCE.register(inVMAcceptor);\n        }\n\n        // connector\n        final ManagementResourceRegistration connector = serverRegistration.registerSubModel(GENERIC_CONNECTOR, MessagingSubsystemProviders.CONNECTOR);\n        connector.registerOperationHandler(ADD, TransportConfigOperationHandlers.GENERIC_ADD, MessagingSubsystemProviders.CONNECTOR_ADD);\n        connector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.GENERIC_ATTR.registerAttributes(connector, registerRuntimeOnly);\n        createParamRegistration(connector);\n\n        // remote connector\n        final ManagementResourceRegistration remoteConnector = serverRegistration.registerSubModel(REMOTE_CONNECTOR, MessagingSubsystemProviders.REMOTE_CONNECTOR);\n        remoteConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.REMOTE_ADD, MessagingSubsystemProviders.REMOTE_CONNECTOR_ADD);\n        remoteConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.REMOTE_ATTR.registerAttributes(remoteConnector, registerRuntimeOnly);\n        createParamRegistration(remoteConnector);\n\n        // in-vm connector\n        final ManagementResourceRegistration inVMConnector = serverRegistration.registerSubModel(IN_VM_CONNECTOR, MessagingSubsystemProviders.IN_VM_CONNECTOR);\n        inVMConnector.registerOperationHandler(ADD, TransportConfigOperationHandlers.IN_VM_ADD, MessagingSubsystemProviders.IN_VM_CONNECTOR_ADD);\n        inVMConnector.registerOperationHandler(REMOVE, TransportConfigOperationHandlers.REMOVE, MessagingSubsystemProviders.CONNECTOR_REMOVE);\n        TransportConfigOperationHandlers.IN_VM_ATTR.registerAttributes(inVMConnector, registerRuntimeOnly);\n        createParamRegistration(inVMConnector);\n\n        // Bridges\n        final ManagementResourceRegistration bridge = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.BRIDGE), MessagingSubsystemProviders.BRIDGE_RESOURCE);\n        bridge.registerOperationHandler(ADD, BridgeAdd.INSTANCE, BridgeAdd.INSTANCE, false);\n        bridge.registerOperationHandler(REMOVE, BridgeRemove.INSTANCE, BridgeRemove.INSTANCE, false);\n        BridgeWriteAttributeHandler.INSTANCE.registerAttributes(bridge, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            BridgeControlHandler.INSTANCE.register(bridge);\n        }\n\n        // Cluster connections\n        final ManagementResourceRegistration cluster = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CLUSTER_CONNECTION),\n                MessagingSubsystemProviders.CLUSTER_CONNECTION_RESOURCE);\n        cluster.registerOperationHandler(ADD, ClusterConnectionAdd.INSTANCE, ClusterConnectionAdd.INSTANCE, false);\n        cluster.registerOperationHandler(REMOVE, ClusterConnectionRemove.INSTANCE, ClusterConnectionRemove.INSTANCE, false);\n        ClusterConnectionWriteAttributeHandler.INSTANCE.registerAttributes(cluster, registerRuntimeOnly);\n        if (registerRuntimeOnly) {\n            ClusterConnectionControlHandler.INSTANCE.register(cluster);\n        }\n\n        // Grouping Handler\n        final ManagementResourceRegistration groupingHandler = serverRegistration.registerSubModel(GROUPING_HANDLER_PATH, MessagingSubsystemProviders.GROUPING_HANDLER_RESOURCE);\n        groupingHandler.registerOperationHandler(ADD, GroupingHandlerAdd.INSTANCE, GroupingHandlerAdd.INSTANCE);\n        groupingHandler.registerOperationHandler(REMOVE, GroupingHandlerRemove.INSTANCE, GroupingHandlerRemove.INSTANCE);\n        GroupingHandlerWriteAttributeHandler.INSTANCE.registerAttributes(groupingHandler, registerRuntimeOnly);\n\n        // Connector services\n        final ManagementResourceRegistration connectorService = serverRegistration.registerSubModel(PathElement.pathElement(CommonAttributes.CONNECTOR_SERVICE),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_RESOURCE);\n        connectorService.registerOperationHandler(ADD, ConnectorServiceAdd.INSTANCE, ConnectorServiceAdd.INSTANCE, false);\n        connectorService.registerOperationHandler(REMOVE, ConnectorServiceRemove.INSTANCE, ConnectorServiceRemove.INSTANCE, false);\n        ConnectorServiceWriteAttributeHandler.INSTANCE.registerAttributes(connectorService, registerRuntimeOnly);\n\n        final ManagementResourceRegistration connectorServiceParam = connectorService.registerSubModel(PathElement.pathElement(CommonAttributes.PARAM),\n                MessagingSubsystemProviders.CONNECTOR_SERVICE_PARAM_RESOURCE);\n        connectorServiceParam.registerOperationHandler(ADD, ConnectorServiceParamAdd.INSTANCE, ConnectorServiceParamAdd.INSTANCE, false);\n        connectorServiceParam.registerOperationHandler(REMOVE, ConnectorServiceParamRemove.INSTANCE, ConnectorServiceParamRemove.INSTANCE, false);\n        connectorServiceParam.registerReadWriteAttribute(CommonAttributes.VALUE.getName(), null, ConnectorServiceParamWriteAttributeHandler.INSTANCE, AttributeAccess.Storage.CONFIGURATION);\n\n        // Messaging paths\n        for (final String path : CommonAttributes.PATHS) {\n            ManagementResourceRegistration bindings = serverRegistration.registerSubModel(PathElement.pathElement(PATH, path),\n                    new MessagingSubsystemProviders.PathProvider(path));\n            MessagingPathHandlers.register(bindings);\n        }\n\n        // Connection factories\n        final ManagementResourceRegistration cfs = serverRegistration.registerSubModel(CFS_PATH, MessagingSubsystemProviders.CF);\n        cfs.registerOperationHandler(ADD, ConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.CF_ADD, false);\n        cfs.registerOperationHandler(REMOVE, ConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.CF_REMOVE, false);\n        ConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(cfs);\n        if (registerRuntimeOnly) {\n            ConnectionFactoryReadAttributeHandler.INSTANCE.registerAttributes(cfs);\n        }\n        ConnectionFactoryAddJndiHandler.INSTANCE.registerOperation(cfs);\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // Resource Adapter Pooled connection factories\n        final ManagementResourceRegistration resourceAdapters = serverRegistration.registerSubModel(RA_PATH, MessagingSubsystemProviders.RA);\n        resourceAdapters.registerOperationHandler(ADD, PooledConnectionFactoryAdd.INSTANCE, MessagingSubsystemProviders.RA_ADD, false);\n        resourceAdapters.registerOperationHandler(REMOVE, PooledConnectionFactoryRemove.INSTANCE, MessagingSubsystemProviders.RA_REMOVE);\n        PooledConnectionFactoryWriteAttributeHandler.INSTANCE.registerAttributes(resourceAdapters, registerRuntimeOnly);\n        // TODO how do ConnectionFactoryControl things relate?\n\n        // JMS Queues\n        final ManagementResourceRegistration queues = serverRegistration.registerSubModel(JMS_QUEUE_PATH, MessagingSubsystemProviders.JMS_QUEUE_RESOURCE);\n        queues.registerOperationHandler(ADD, JMSQueueAdd.INSTANCE, JMSQueueAdd.INSTANCE, false);\n        queues.registerOperationHandler(REMOVE, JMSQueueRemove.INSTANCE, JMSQueueRemove.INSTANCE, false);\n        JMSQueueConfigurationWriteHandler.INSTANCE.registerAttributes(queues, registerRuntimeOnly);\n        JMSQueueAddJndiHandler.INSTANCE.registerOperation(queues);\n        if (registerRuntimeOnly) {\n            JMSQueueReadAttributeHandler.INSTANCE.registerAttributes(queues);\n            JMSQueueControlHandler.INSTANCE.registerOperations(queues);\n        }\n        // setExpiryAddress, setDeadLetterAddress  -- no -- just toggle the 'queue-address', make this a mutable attr of address-setting\n        // getJNDIBindings (no -- same as \"entries\")\n\n        // JMS Topics\n        final ManagementResourceRegistration topics = serverRegistration.registerSubModel(TOPIC_PATH, MessagingSubsystemProviders.JMS_TOPIC_RESOURCE);\n        topics.registerOperationHandler(ADD, JMSTopicAdd.INSTANCE, JMSTopicAdd.INSTANCE, false);\n        topics.registerOperationHandler(REMOVE, JMSTopicRemove.INSTANCE, JMSTopicRemove.INSTANCE, false);\n        JMSTopicConfigurationWriteHandler.INSTANCE.registerAttributes(topics);\n        JMSTopicAddJndiHandler.INSTANCE.registerOperation(topics);\n        if (registerRuntimeOnly) {\n            JMSTopicReadAttributeHandler.INSTANCE.registerAttributes(topics);\n            JMSTopicControlHandler.INSTANCE.registerOperations(topics);\n        }\n        // getJNDIBindings (no -- same as \"entries\")\n\n        final ManagementResourceRegistration securitySettings = serverRegistration.registerSubModel(SECURITY_SETTING, MessagingSubsystemProviders.SECURITY_SETTING);\n        securitySettings.registerOperationHandler(ADD, SecuritySettingAdd.INSTANCE, SecuritySettingAdd.INSTANCE);\n        securitySettings.registerOperationHandler(REMOVE, SecuritySettingRemove.INSTANCE, SecuritySettingRemove.INSTANCE);\n\n        final ManagementResourceRegistration securityRole = securitySettings.registerSubModel(SECURITY_ROLE, MessagingSubsystemProviders.SECURITY_ROLE);\n        securityRole.registerOperationHandler(ADD, SecurityRoleAdd.INSTANCE, SecurityRoleAdd.INSTANCE);\n        securityRole.registerOperationHandler(REMOVE, SecurityRoleRemove.INSTANCE, SecurityRoleRemove.INSTANCE);\n        SecurityRoleAttributeHandler.INSTANCE.registerAttributes(securityRole, registerRuntimeOnly);\n\n        if (context.isRuntimeOnlyRegistrationValid()) {\n\n            ResourceDefinition deploymentsDef = new SimpleResourceDefinition(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, SUBSYSTEM_NAME), getResourceDescriptionResolver(\"deployed\"));\n            final ManagementResourceRegistration deploymentsRegistration = subsystem.registerDeploymentModel(deploymentsDef);\n            final ManagementResourceRegistration serverModel = deploymentsRegistration.registerSubModel(new HornetQServerResourceDefinition(true));\n\n            // JMS Queues\n            final ManagementResourceRegistration deploymentQueue = serverModel.registerSubModel(JMS_QUEUE_PATH, MessagingSubsystemProviders.JMS_QUEUE_RESOURCE);\n            JMSQueueReadAttributeHandler.INSTANCE.registerAttributes(deploymentQueue);\n            JMSQueueControlHandler.INSTANCE.registerOperations(deploymentQueue);\n            JMSQueueConfigurationRuntimeHandler.INSTANCE.registerAttributes(deploymentQueue);\n\n            // topics\n            final ManagementResourceRegistration deploymentTopics = serverModel.registerSubModel(TOPIC_PATH, MessagingSubsystemProviders.JMS_TOPIC_RESOURCE);\n            JMSTopicReadAttributeHandler.INSTANCE.registerAttributes(deploymentTopics);\n            JMSTopicControlHandler.INSTANCE.registerOperations(deploymentTopics);\n            JMSTopicConfigurationRuntimeHandler.INSTANCE.registerAttributes(deploymentTopics);\n\n        }\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void writeContent(final XMLExtendedStreamWriter writer, final SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(Namespace.CURRENT.getUriString(), false);\n        final ModelNode node = context.getModelNode();\n\n        final ModelNode servers = node.require(HORNETQ_SERVER);\n        boolean first = true;\n        for (Property prop : servers.asPropertyList()) {\n            writeHornetQServer(writer, prop.getName(), prop.getValue());\n            if (!first) {\n                writeNewLine(writer);\n            } else {\n                first = false;\n            }\n        }\n\n        writer.writeEndElement();\n    }","id":67812,"modified_method":"public void writeContent(final XMLExtendedStreamWriter writer, final SubsystemMarshallingContext context) throws XMLStreamException {\n        context.startSubsystemElement(getExpectedNamespace().getUriString(), false);\n        final ModelNode node = context.getModelNode();\n\n        final ModelNode servers = node.require(HORNETQ_SERVER);\n        boolean first = true;\n        for (Property prop : servers.asPropertyList()) {\n            writeHornetQServer(writer, prop.getName(), prop.getValue());\n            if (!first) {\n                writeNewLine(writer);\n            } else {\n                first = false;\n            }\n        }\n\n        writer.writeEndElement();\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writeConnectionFactory(XMLExtendedStreamWriter writer, String name, ModelNode factory) throws XMLStreamException\n    {\n        if(factory.hasDefined(INBOUND_CONFIG)) {\n            final ModelNode inboundConfigs = factory.get(INBOUND_CONFIG);\n            if (inboundConfigs.getType() == ModelType.LIST) {\n                writer.writeStartElement(Element.INBOUND_CONFIG.getLocalName());\n                for (ModelNode config : inboundConfigs.asList()) {\n                    if (config.isDefined()) {\n                        CommonAttributes.USE_JNDI.marshallAsElement(config, writer);\n                        CommonAttributes.JNDI_PARAMS.marshallAsElement(config, writer);\n                        CommonAttributes.USE_LOCAL_TX.marshallAsElement(config, writer);\n                        CommonAttributes.SETUP_ATTEMPTS.marshallAsElement(config, writer);\n                        CommonAttributes.SETUP_INTERVAL.marshallAsElement(config, writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n\n        if(factory.hasDefined(TRANSACTION)) {\n            writer.writeStartElement(Element.TRANSACTION.getLocalName());\n            writeTransactionTypeAttribute(writer, Element.MODE, factory.get(TRANSACTION));\n            writer.writeEndElement();\n        }\n\n        if (CommonAttributes.DISCOVERY_GROUP_NAME.isMarshallable(factory)) {\n            writer.writeStartElement(Element.DISCOVERY_GROUP_REF.getLocalName());\n            CommonAttributes.DISCOVERY_GROUP_NAME.marshallAsAttribute(factory, writer);\n            writer.writeEndElement();\n        }\n\n        CommonAttributes.DISCOVERY_INITIAL_WAIT_TIMEOUT.marshallAsElement(factory, writer);\n\n        if (factory.hasDefined(CONNECTOR)) {\n            writer.writeStartElement(Element.CONNECTORS.getLocalName());\n            for (Property connProp : factory.get(CONNECTOR).asPropertyList()) {\n                writer.writeStartElement(Element.CONNECTOR_REF.getLocalName());\n                writer.writeAttribute(Attribute.CONNECTOR_NAME.getLocalName(), connProp.getName());\n                final ModelNode conn = connProp.getValue();\n                if (conn.isDefined()) {\n                    writer.writeAttribute(Attribute.BACKUP_CONNECTOR_NAME.getLocalName(), connProp.getValue().asString());\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n        }\n\n        JndiEntriesAttribute.CONNECTION_FACTORY.marshallAsElement(factory, writer);\n\n        CommonAttributes.HA.marshallAsElement(factory, writer);\n        CommonAttributes.CLIENT_FAILURE_CHECK_PERIOD.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_TTL.marshallAsElement(factory, writer);\n        CommonAttributes.CALL_TIMEOUT.marshallAsElement(factory, writer);\n        CommonAttributes.CONSUMER_WINDOW_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.CONSUMER_MAX_RATE.marshallAsElement(factory, writer);\n        CommonAttributes.CONFIRMATION_WINDOW_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.PRODUCER_WINDOW_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.PRODUCER_MAX_RATE.marshallAsElement(factory, writer);\n        CommonAttributes.CACHE_LARGE_MESSAGE_CLIENT.marshallAsElement(factory, writer);\n        CommonAttributes.MIN_LARGE_MESSAGE_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.CLIENT_ID.marshallAsElement(factory, writer);\n        CommonAttributes.DUPS_OK_BATCH_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.TRANSACTION_BATCH_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.BLOCK_ON_ACK.marshallAsElement(factory, writer);\n        CommonAttributes.BLOCK_ON_NON_DURABLE_SEND.marshallAsElement(factory, writer);\n        CommonAttributes.BLOCK_ON_DURABLE_SEND.marshallAsElement(factory, writer);\n        CommonAttributes.AUTO_GROUP.marshallAsElement(factory, writer);\n        CommonAttributes.PRE_ACK.marshallAsElement(factory, writer);\n        CommonAttributes.RETRY_INTERVAL.marshallAsElement(factory, writer);\n        CommonAttributes.RETRY_INTERVAL_MULTIPLIER.marshallAsElement(factory, writer);\n        CommonAttributes.MAX_RETRY_INTERVAL.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_FACTORY_RECONNECT_ATTEMPTS.marshallAsElement(factory, writer);\n        CommonAttributes.FAILOVER_ON_INITIAL_CONNECTION.marshallAsElement(factory, writer);\n        CommonAttributes.FAILOVER_ON_SERVER_SHUTDOWN.marshallAsElement(factory, writer);\n        CommonAttributes.LOAD_BALANCING_CLASS_NAME.marshallAsElement(factory, writer);\n        CommonAttributes.USE_GLOBAL_POOLS.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_SCHEDULED_THREAD_POOL_MAX_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_THREAD_POOL_MAX_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.GROUP_ID.marshallAsElement(factory, writer);\n\n        writer.writeEndElement();\n    }","id":67813,"modified_method":"protected void writeConnectionFactory(XMLExtendedStreamWriter writer, String name, ModelNode factory) throws XMLStreamException\n    {\n        if(factory.hasDefined(INBOUND_CONFIG)) {\n            final ModelNode inboundConfigs = factory.get(INBOUND_CONFIG);\n            if (inboundConfigs.getType() == ModelType.LIST) {\n                writer.writeStartElement(Element.INBOUND_CONFIG.getLocalName());\n                for (ModelNode config : inboundConfigs.asList()) {\n                    if (config.isDefined()) {\n                        CommonAttributes.USE_JNDI.marshallAsElement(config, writer);\n                        CommonAttributes.JNDI_PARAMS.marshallAsElement(config, writer);\n                        CommonAttributes.USE_LOCAL_TX.marshallAsElement(config, writer);\n                        CommonAttributes.SETUP_ATTEMPTS.marshallAsElement(config, writer);\n                        CommonAttributes.SETUP_INTERVAL.marshallAsElement(config, writer);\n                    }\n                }\n                writer.writeEndElement();\n            }\n        }\n\n        if(factory.hasDefined(TRANSACTION)) {\n            writer.writeStartElement(Element.TRANSACTION.getLocalName());\n            writeTransactionTypeAttribute(writer, Element.MODE, factory.get(TRANSACTION));\n            writer.writeEndElement();\n        }\n\n        if (CommonAttributes.DISCOVERY_GROUP_NAME.isMarshallable(factory)) {\n            writer.writeStartElement(Element.DISCOVERY_GROUP_REF.getLocalName());\n            CommonAttributes.DISCOVERY_GROUP_NAME.marshallAsAttribute(factory, writer);\n            writer.writeEndElement();\n        }\n\n        CommonAttributes.DISCOVERY_INITIAL_WAIT_TIMEOUT.marshallAsElement(factory, writer);\n\n        if (factory.hasDefined(CONNECTOR)) {\n            writer.writeStartElement(Element.CONNECTORS.getLocalName());\n            for (Property connProp : factory.get(CONNECTOR).asPropertyList()) {\n                writer.writeStartElement(Element.CONNECTOR_REF.getLocalName());\n                writer.writeAttribute(Attribute.CONNECTOR_NAME.getLocalName(), connProp.getName());\n                final ModelNode conn = connProp.getValue();\n                if (conn.isDefined()) {\n                    writer.writeAttribute(Attribute.BACKUP_CONNECTOR_NAME.getLocalName(), connProp.getValue().asString());\n                }\n                writer.writeEndElement();\n            }\n            writer.writeEndElement();\n        }\n\n        JndiEntriesAttribute.CONNECTION_FACTORY.marshallAsElement(factory, writer);\n\n        CommonAttributes.HA.marshallAsElement(factory, writer);\n        CommonAttributes.CLIENT_FAILURE_CHECK_PERIOD.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_TTL.marshallAsElement(factory, writer);\n        CommonAttributes.CALL_TIMEOUT.marshallAsElement(factory, writer);\n        CommonAttributes.CONSUMER_WINDOW_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.CONSUMER_MAX_RATE.marshallAsElement(factory, writer);\n        CommonAttributes.CONFIRMATION_WINDOW_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.PRODUCER_WINDOW_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.PRODUCER_MAX_RATE.marshallAsElement(factory, writer);\n        CommonAttributes.CACHE_LARGE_MESSAGE_CLIENT.marshallAsElement(factory, writer);\n        CommonAttributes.MIN_LARGE_MESSAGE_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.CLIENT_ID.marshallAsElement(factory, writer);\n        CommonAttributes.DUPS_OK_BATCH_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.TRANSACTION_BATCH_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.BLOCK_ON_ACK.marshallAsElement(factory, writer);\n        CommonAttributes.BLOCK_ON_NON_DURABLE_SEND.marshallAsElement(factory, writer);\n        CommonAttributes.BLOCK_ON_DURABLE_SEND.marshallAsElement(factory, writer);\n        CommonAttributes.AUTO_GROUP.marshallAsElement(factory, writer);\n        CommonAttributes.PRE_ACK.marshallAsElement(factory, writer);\n        CommonAttributes.RETRY_INTERVAL.marshallAsElement(factory, writer);\n        CommonAttributes.RETRY_INTERVAL_MULTIPLIER.marshallAsElement(factory, writer);\n        CommonAttributes.MAX_RETRY_INTERVAL.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_FACTORY_RECONNECT_ATTEMPTS.marshallAsElement(factory, writer);\n        CommonAttributes.FAILOVER_ON_INITIAL_CONNECTION.marshallAsElement(factory, writer);\n        CommonAttributes.FAILOVER_ON_SERVER_SHUTDOWN.marshallAsElement(factory, writer);\n        CommonAttributes.LOAD_BALANCING_CLASS_NAME.marshallAsElement(factory, writer);\n        CommonAttributes.USE_GLOBAL_POOLS.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_SCHEDULED_THREAD_POOL_MAX_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.CONNECTION_THREAD_POOL_MAX_SIZE.marshallAsElement(factory, writer);\n        CommonAttributes.GROUP_ID.marshallAsElement(factory, writer);\n\n        writer.writeEndElement();\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> list) throws XMLStreamException {\n\n        final ModelNode address = new ModelNode();\n        address.add(SUBSYSTEM, MessagingExtension.SUBSYSTEM_NAME);\n        address.protect();\n\n        final ModelNode subsystemAdd = new ModelNode();\n        subsystemAdd.get(OP).set(ADD);\n        subsystemAdd.get(OP_ADDR).set(address);\n        list.add(subsystemAdd);\n\n        final Namespace schemaVer = Namespace.forUri(reader.getNamespaceURI());\n        switch (schemaVer) {\n            case MESSAGING_1_0:\n                processHornetQServer(reader, address, list, schemaVer);\n                break;\n            case MESSAGING_1_1:\n                processHornetQServers(reader, address, list);\n                break;\n            default:\n                throw unexpectedElement(reader);\n        }\n\n    }","id":67814,"modified_method":"public void readElement(final XMLExtendedStreamReader reader, final List<ModelNode> list) throws XMLStreamException {\n        final ModelNode address = new ModelNode();\n        address.add(SUBSYSTEM, MessagingExtension.SUBSYSTEM_NAME);\n        address.protect();\n\n        final ModelNode subsystemAdd = new ModelNode();\n        subsystemAdd.get(OP).set(ADD);\n        subsystemAdd.get(OP_ADDR).set(address);\n        list.add(subsystemAdd);\n\n        final Namespace schemaVer = Namespace.forUri(reader.getNamespaceURI());\n        switch (schemaVer) {\n            case MESSAGING_1_0:\n                processHornetQServer(reader, address, list, schemaVer);\n                break;\n            case MESSAGING_1_1:\n            case MESSAGING_1_2:\n                processHornetQServers(reader, address, list);\n                break;\n            default:\n                throw unexpectedElement(reader);\n        }\n\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void processConnectionFactories(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n       while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n          final Element element = Element.forName(reader.getLocalName());\n          switch(element) {\n             case CONNECTION_FACTORY:\n                processConnectionFactory(reader, address, updates);\n               break;\n             case POOLED_CONNECTION_FACTORY:\n                processPooledConnectionFactory(reader, address, updates);\n               break;\n             default:\n                    throw ParseUtils.unexpectedElement(reader);\n          }\n       }\n    }","id":67815,"modified_method":"void processConnectionFactories(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n       while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n          final Element element = Element.forName(reader.getLocalName());\n          switch(element) {\n             case CONNECTION_FACTORY:\n                processConnectionFactory(reader, address, updates);\n               break;\n             case POOLED_CONNECTION_FACTORY:\n                processPooledConnectionFactory(reader, address, updates);\n               break;\n             default:\n                    throw ParseUtils.unexpectedElement(reader);\n          }\n       }\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"private MessagingSubsystemParser() {\n        //\n    }","id":67816,"modified_method":"protected MessagingSubsystemParser() {\n        //\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void writePooledConnectionFactories(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode factory = prop.getValue();\n                if (factory.isDefined()) {\n                   writer.writeStartElement(Element.POOLED_CONNECTION_FACTORY.getLocalName());\n                   writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n                   MIN_POOL_SIZE.marshallAsElement(factory, writer);\n                   MAX_POOL_SIZE.marshallAsElement(factory, writer);\n\n                   writeConnectionFactory(writer, name, factory);\n                }\n            }\n        }\n    }","id":67817,"modified_method":"protected void writePooledConnectionFactories(final XMLExtendedStreamWriter writer, final ModelNode node) throws XMLStreamException {\n        List<Property> properties = node.asPropertyList();\n        if (!properties.isEmpty()) {\n            for (Property prop : properties) {\n                final String name = prop.getName();\n                final ModelNode factory = prop.getValue();\n                if (factory.isDefined()) {\n                   writer.writeStartElement(Element.POOLED_CONNECTION_FACTORY.getLocalName());\n                   writer.writeAttribute(Attribute.NAME.getLocalName(), name);\n\n                   writeConnectionFactory(writer, name, factory);\n                }\n            }\n        }\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch(element) {\n                case DISCOVERY_GROUP_REF: {\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                } case INBOUND_CONFIG: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw ParseUtils.unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(TRANSACTION).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case HA:\n                case CONNECTION_FACTORY_TYPE:\n                case DISCOVERY_INITIAL_WAIT_TIMEOUT:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CONNECTION_TTL:\n                case CALL_TIMEOUT:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case MAX_RETRY_INTERVAL:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                case MAX_POOL_SIZE:\n                case MIN_POOL_SIZE:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case RETRY_INTERVAL:\n                    // Use the \"default\" variant\n                    handleElementText(reader, element, \"default\", connectionFactory);\n                    break;\n                case RECONNECT_ATTEMPTS:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                case USER:\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    CommonAttributes.PCF_USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    CommonAttributes.PCF_PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        return connectionFactory;\n    }","id":67818,"modified_method":"protected ModelNode createConnectionFactory(XMLExtendedStreamReader reader, ModelNode connectionFactory, boolean pooled) throws XMLStreamException\n    {\n        while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n            final Element element = Element.forName(reader.getLocalName());\n            switch(element) {\n                case DISCOVERY_GROUP_REF: {\n                    final String groupRef = readStringAttributeElement(reader, DISCOVERY_GROUP_NAME.getXmlName());\n                    DISCOVERY_GROUP_NAME.parseAndSetParameter(groupRef, connectionFactory, reader);\n                    break;\n                } case CONNECTORS: {\n                    connectionFactory.get(CONNECTOR).set(processJmsConnectors(reader));\n                    break;\n                } case ENTRIES: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        if(local != Element.ENTRY ) {\n                            throw ParseUtils.unexpectedElement(reader);\n                        }\n                        final String entry = readStringAttributeElement(reader, CommonAttributes.NAME);\n                        JndiEntriesAttribute.CONNECTION_FACTORY.parseAndAddParameterElement(entry, connectionFactory, reader);\n                    }\n                    break;\n                } case INBOUND_CONFIG: {\n                    while(reader.hasNext() && reader.nextTag() != END_ELEMENT) {\n                        final Element local = Element.forName(reader.getLocalName());\n                        switch (local) {\n                            case USE_JNDI:\n                            case JNDI_PARAMS:\n                            case USE_LOCAL_TX:\n                            case SETUP_ATTEMPTS:\n                            case SETUP_INTERVAL:\n                                handleElementText(reader, local, connectionFactory);\n                                break;\n                            default:\n                                throw ParseUtils.unexpectedElement(reader);\n                        }\n                    }\n                    break;\n                } case TRANSACTION: {\n                    if(!pooled) {\n                        throw ParseUtils.unexpectedElement(reader);\n                    }\n                    final String txType = reader.getAttributeValue(0);\n                    if( txType != null) {\n                        connectionFactory.get(TRANSACTION).set(txType);\n                    }\n                    ParseUtils.requireNoContent(reader);\n                    break;\n                }\n                case HA:\n                case CONNECTION_FACTORY_TYPE:\n                case DISCOVERY_INITIAL_WAIT_TIMEOUT:\n                case CLIENT_FAILURE_CHECK_PERIOD:\n                case CONNECTION_TTL:\n                case CALL_TIMEOUT:\n                case CONSUMER_WINDOW_SIZE:\n                case CONSUMER_MAX_RATE:\n                case CONFIRMATION_WINDOW_SIZE:\n                case PRODUCER_WINDOW_SIZE:\n                case PRODUCER_MAX_RATE:\n                case CACHE_LARGE_MESSAGE_CLIENT:\n                case MIN_LARGE_MESSAGE_SIZE:\n                case CLIENT_ID:\n                case DUPS_OK_BATCH_SIZE:\n                case TRANSACTION_BATH_SIZE:\n                case BLOCK_ON_ACK:\n                case BLOCK_ON_NON_DURABLE_SEND:\n                case BLOCK_ON_DURABLE_SEND:\n                case AUTO_GROUP:\n                case PRE_ACK:\n                case RETRY_INTERVAL_MULTIPLIER:\n                case MAX_RETRY_INTERVAL:\n                case FAILOVER_ON_INITIAL_CONNECTION:\n                case FAILOVER_ON_SERVER_SHUTDOWN:\n                case LOAD_BALANCING_CLASS_NAME:\n                case USE_GLOBAL_POOLS:\n                case GROUP_ID:\n                    handleElementText(reader, element, connectionFactory);\n                    break;\n                case RETRY_INTERVAL:\n                    // Use the \"default\" variant\n                    handleElementText(reader, element, \"default\", connectionFactory);\n                    break;\n                case RECONNECT_ATTEMPTS:\n                case SCHEDULED_THREAD_POOL_MAX_SIZE:\n                case THREAD_POOL_MAX_SIZE:\n                    // Use the \"connection\" variant\n                    handleElementText(reader, element, \"connection\", connectionFactory);\n                    break;\n                case USER:\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    CommonAttributes.PCF_USER.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                case PASSWORD:\n                    // Element name is overloaded, handleElementText can not be used, we must use the correct attribute\n                    CommonAttributes.PCF_PASSWORD.parseAndSetParameter(reader.getElementText(), connectionFactory, reader);\n                    break;\n                default: {\n                    throw ParseUtils.unexpectedElement(reader);\n                }\n            }\n        }\n        return connectionFactory;\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void processPooledConnectionFactory(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n        final String name = reader.getAttributeValue(0);\n        if(name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode connectionFactory = new ModelNode();\n        connectionFactory.get(OP).set(ADD);\n        connectionFactory.get(OP_ADDR).set(address).add(POOLED_CONNECTION_FACTORY, name);\n\n        updates.add(createConnectionFactory(reader, connectionFactory, true));\n    }","id":67819,"modified_method":"void processPooledConnectionFactory(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n        final String name = reader.getAttributeValue(0);\n        if(name == null) {\n            ParseUtils.missingRequired(reader, Collections.singleton(\"name\"));\n        }\n\n        final ModelNode connectionFactory = new ModelNode();\n        connectionFactory.get(OP).set(ADD);\n        connectionFactory.get(OP_ADDR).set(address).add(POOLED_CONNECTION_FACTORY, name);\n\n        updates.add(createConnectionFactory(reader, connectionFactory, true));\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"static void processConnectionFactory(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        final String name = reader.getAttributeValue(0);\n\n        final ModelNode connectionFactory = new ModelNode();\n        connectionFactory.get(OP).set(ADD);\n        connectionFactory.get(OP_ADDR).set(address).add(CONNECTION_FACTORY, name);\n\n        updates.add(createConnectionFactory(reader, connectionFactory, false));\n    }","id":67820,"modified_method":"void processConnectionFactory(final XMLExtendedStreamReader reader, ModelNode address, List<ModelNode> updates) throws XMLStreamException {\n\n        requireSingleAttribute(reader, CommonAttributes.NAME);\n        final String name = reader.getAttributeValue(0);\n\n        final ModelNode connectionFactory = new ModelNode();\n        connectionFactory.get(OP).set(ADD);\n        connectionFactory.get(OP_ADDR).set(address).add(CONNECTION_FACTORY, name);\n\n        updates.add(createConnectionFactory(reader, connectionFactory, false));\n    }","commit_id":"2f08d5a2874926f7a139386fafe0bd1247397138","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n            return;\n        }\n\n        WeldLogger.DEPLOYMENT_LOGGER.processingWeldDeployment(deploymentUnit.getName());\n\n        final Map<ResourceRoot, Index> indexes = AnnotationIndexUtils.getAnnotationIndexes(deploymentUnit);\n        final Map<ResourceRoot, BeanDeploymentArchiveImpl> bdaMap = new HashMap<ResourceRoot, BeanDeploymentArchiveImpl>();\n\n        final Components components = new Components(deploymentUnit, indexes);\n\n        final ResourceRootHandler handler = new ResourceRootHandler(deploymentUnit, components, indexes);\n\n        for (ResourceRoot resourceRoot : deploymentUnit.getAttachmentList(Attachments.RESOURCE_ROOTS)) {\n            if (ModuleRootMarker.isModuleRoot(resourceRoot) && !SubDeploymentMarker.isSubDeployment(resourceRoot)) {\n                if (isClassesRoot(resourceRoot)) {\n                    continue; // this is handled below\n                }\n                handler.handleResourceRoot(bdaMap, resourceRoot);\n            }\n        }\n        if (!DeploymentTypeMarker.isType(DeploymentType.EAR, deploymentUnit)) {\n            handler.handleResourceRoot(bdaMap, handler.deploymentResourceRoot);\n        }\n        if (!bdaMap.containsKey(handler.deploymentResourceRoot)) {\n            // there is not root bda, let's create one\n            BeanDeploymentArchiveImpl bda = new BeanDeploymentArchiveImpl(Collections.<String>emptySet(), BeansXml.EMPTY_BEANS_XML, handler.module, getDeploymentUnitId(deploymentUnit), BeanArchiveType.SYNTHETIC, true);\n            WeldLogger.DEPLOYMENT_LOGGER.beanArchiveDiscovered(bda);\n            bdaMap.put(handler.deploymentResourceRoot, bda);\n        }\n        deploymentUnit.putAttachment(WeldAttachments.DEPLOYMENT_ROOT_BEAN_DEPLOYMENT_ARCHIVE, bdaMap.get(handler.deploymentResourceRoot));\n\n        /*\n         * Finish EE component processing\n         */\n        for (Map.Entry<ResourceRoot, ComponentDescription> entry : components.componentDescriptions.entries()) {\n            BeanDeploymentArchiveImpl bda = bdaMap.get(entry.getKey());\n            String id = null;\n            if (bda != null) {\n                id = bda.getId();\n            } else {\n                id = deploymentUnit.getAttachment(WeldAttachments.DEPLOYMENT_ROOT_BEAN_DEPLOYMENT_ARCHIVE).getId();\n            }\n            entry.getValue().setBeanDeploymentArchiveId(id);\n        }\n\n        final JpaInjectionServices jpaInjectionServices = new WeldJpaInjectionServices(deploymentUnit);\n        final JaxwsInjectionServices jaxwsInjectionServices = new WeldJaxwsInjectionServices(deploymentUnit);\n\n        final BeanDeploymentModule bdm = new BeanDeploymentModule(bdaMap.values());\n        bdm.addService(JpaInjectionServices.class, jpaInjectionServices);\n        bdm.addService(JaxwsInjectionServices.class, jaxwsInjectionServices);\n        deploymentUnit.putAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE, bdm);\n    }","id":67821,"modified_method":"public BeanArchiveProcessor(boolean requireBeanDescriptor) {\n        this.requireBeanDescriptor = requireBeanDescriptor;\n    }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n         * Process a resource root eventually creating a bean archive out of it if it matches requirements for either an\n         * implicit or explicit bean archive. There requirements are laid down by the CDI spec.\n         *\n         * If the resource root does not represent a bean archive, null is returned.\n         */\n        private BeanDeploymentArchiveImpl processResourceRoot(ResourceRoot resourceRoot) throws DeploymentUnitProcessingException {\n            ExplicitBeanArchiveMetadata metadata = null;\n            if (explicitBeanArchives != null) {\n                metadata = explicitBeanArchives.getBeanArchiveMetadata().get(resourceRoot);\n            }\n            BeanDeploymentArchiveImpl bda = null;\n            if (metadata == null || metadata.getBeansXml().getBeanDiscoveryMode().equals(BeanDiscoveryMode.ANNOTATED)) {\n                // this is either an implicit bean archive or not a bean archive at all!\n\n                Index index = null;\n                if (resourceRoot == deploymentResourceRoot && classesResourceRoot != null) {\n                    index = indexes.get(classesResourceRoot);\n                } else {\n                    index = indexes.get(resourceRoot);\n                }\n                if (index == null) {\n                    return null; // index may be null for some resource roots\n                }\n\n                /*\n                 * An archive which contains an extension and no beans.xml file is not a bean archive.\n                 */\n                if (metadata == null && !index.getAllKnownImplementors(EXTENSION_NAME).isEmpty()) {\n                    return null;\n                }\n\n                Set<String> beans = getImplicitBeanClasses(index);\n\n                if (beans.isEmpty() && components.ejbComponentDescriptions.get(resourceRoot).isEmpty()) {\n                    return null;\n                }\n\n                BeansXml beansXml = null;\n                if (metadata != null) {\n                    beansXml = metadata.getBeansXml();\n                }\n\n                final boolean isRootBda = resourceRoot.equals(deploymentResourceRoot);\n                bda = new BeanDeploymentArchiveImpl(beans, beansXml, module, resourceRoot.getRoot().getPathName(), BeanArchiveType.IMPLICIT, isRootBda);\n                WeldLogger.DEPLOYMENT_LOGGER.beanArchiveDiscovered(bda);\n            } else if (metadata.getBeansXml().getBeanDiscoveryMode().equals(BeanDiscoveryMode.NONE)) {\n                // scanning suppressed per spec in this archive\n                return null;\n            } else {\n                boolean isRootBda = metadata.isDeploymentRoot();\n                bda = createExplicitBeanDeploymentArchive(indexes.get(metadata.getResourceRoot()), metadata, isRootBda);\n                WeldLogger.DEPLOYMENT_LOGGER.beanArchiveDiscovered(bda);\n            }\n\n            Collection<EJBComponentDescription> ejbComponents = components.ejbComponentDescriptions.get(resourceRoot);\n\n            // register EJBs with the BDA\n            for (EJBComponentDescription ejb : ejbComponents) {\n                bda.addEjbDescriptor(new EjbDescriptorImpl<Object>(ejb, bda, reflectionIndex));\n                bda.addBeanClass(ejb.getComponentClassName());\n            }\n\n            return bda;\n        }","id":67822,"modified_method":"/**\n         * Process a resource root eventually creating a bean archive out of it if it matches requirements for either an\n         * implicit or explicit bean archive. There requirements are laid down by the CDI spec.\n         *\n         * If the resource root does not represent a bean archive, null is returned.\n         */\n        private BeanDeploymentArchiveImpl processResourceRoot(ResourceRoot resourceRoot) throws DeploymentUnitProcessingException {\n            ExplicitBeanArchiveMetadata metadata = null;\n            if (explicitBeanArchives != null) {\n                metadata = explicitBeanArchives.getBeanArchiveMetadata().get(resourceRoot);\n            }\n            BeanDeploymentArchiveImpl bda = null;\n            if (metadata == null && requireBeanDescriptor) {\n                /*\n                 * For compatibility with Contexts and Dependency 1.0, products must contain an option to cause an archive to be ignored by the\n                 * container when no beans.xml is present.\n                 */\n                return null;\n            }\n            if (metadata == null || metadata.getBeansXml().getBeanDiscoveryMode().equals(BeanDiscoveryMode.ANNOTATED)) {\n                // this is either an implicit bean archive or not a bean archive at all!\n\n                Index index = null;\n                if (resourceRoot == deploymentResourceRoot && classesResourceRoot != null) {\n                    index = indexes.get(classesResourceRoot);\n                } else {\n                    index = indexes.get(resourceRoot);\n                }\n                if (index == null) {\n                    return null; // index may be null for some resource roots\n                }\n\n                /*\n                 * An archive which contains an extension and no beans.xml file is not a bean archive.\n                 */\n                if (metadata == null && !index.getAllKnownImplementors(EXTENSION_NAME).isEmpty()) {\n                    return null;\n                }\n\n                Set<String> beans = getImplicitBeanClasses(index);\n\n                if (beans.isEmpty() && components.ejbComponentDescriptions.get(resourceRoot).isEmpty()) {\n                    return null;\n                }\n\n                BeansXml beansXml = null;\n                if (metadata != null) {\n                    beansXml = metadata.getBeansXml();\n                }\n\n                final boolean isRootBda = resourceRoot.equals(deploymentResourceRoot);\n                bda = new BeanDeploymentArchiveImpl(beans, beansXml, module, resourceRoot.getRoot().getPathName(), BeanArchiveType.IMPLICIT, isRootBda);\n                WeldLogger.DEPLOYMENT_LOGGER.beanArchiveDiscovered(bda);\n            } else if (metadata.getBeansXml().getBeanDiscoveryMode().equals(BeanDiscoveryMode.NONE)) {\n                // scanning suppressed per spec in this archive\n                return null;\n            } else {\n                boolean isRootBda = metadata.isDeploymentRoot();\n                bda = createExplicitBeanDeploymentArchive(indexes.get(metadata.getResourceRoot()), metadata, isRootBda);\n                WeldLogger.DEPLOYMENT_LOGGER.beanArchiveDiscovered(bda);\n            }\n\n            Collection<EJBComponentDescription> ejbComponents = components.ejbComponentDescriptions.get(resourceRoot);\n\n            // register EJBs with the BDA\n            for (EJBComponentDescription ejb : ejbComponents) {\n                bda.addEjbDescriptor(new EjbDescriptorImpl<Object>(ejb, bda, reflectionIndex));\n                bda.addBeanClass(ejb.getComponentClassName());\n            }\n\n            return bda;\n        }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit parent = Utils.getRootDeploymentUnit(deploymentUnit);\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n\n            //if there are CDI annotation present and this is the top level deployment we log a warning\n            if (deploymentUnit.getParent() == null && CdiAnnotationMarker.cdiAnnotationsPresent(deploymentUnit)) {\n                WeldLogger.DEPLOYMENT_LOGGER.cdiAnnotationsButNoBeansXML(deploymentUnit);\n            }\n\n            return;\n        }\n\n        //add a dependency on the weld service to web deployments\n        final ServiceName weldBootstrapServiceName = parent.getServiceName().append(WeldBootstrapService.SERVICE_NAME);\n        deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, weldBootstrapServiceName);\n\n        final Set<ServiceName> jpaServices = new HashSet<ServiceName>();\n\n\n        // we only start weld on top level deployments\n        if (deploymentUnit.getParent() != null) {\n            return;\n        }\n\n        WeldLogger.DEPLOYMENT_LOGGER.startingServicesForCDIDeployment(phaseContext.getDeploymentUnit().getName());\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final Set<BeanDeploymentArchiveImpl> beanDeploymentArchives = new HashSet<BeanDeploymentArchiveImpl>();\n        final Map<ModuleIdentifier, BeanDeploymentModule> bdmsByIdentifier = new HashMap<ModuleIdentifier, BeanDeploymentModule>();\n        final Map<ModuleIdentifier, ModuleSpecification> moduleSpecByIdentifier = new HashMap<ModuleIdentifier, ModuleSpecification>();\n\n        // the root module only has access to itself. For most deployments this will be the only module\n        // for ear deployments this represents the ear/lib directory.\n        // war and jar deployment visibility will depend on the dependencies that\n        // exist in the application, and mirror inter module dependencies\n        final BeanDeploymentModule rootBeanDeploymentModule = deploymentUnit.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationDescription eeApplicationDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_APPLICATION_DESCRIPTION);\n\n        bdmsByIdentifier.put(module.getIdentifier(), rootBeanDeploymentModule);\n\n        for (final BeanDeploymentModule additional : deploymentUnit.getAttachmentList(WeldAttachments.VISIBLE_ADDITIONAL_BEAN_DEPLOYMENT_MODULE)) {\n            additional.addBeanDeploymentModule(rootBeanDeploymentModule);\n            rootBeanDeploymentModule.addBeanDeploymentModule(additional);\n        }\n\n        moduleSpecByIdentifier.put(module.getIdentifier(), moduleSpecification);\n\n        beanDeploymentArchives.addAll(rootBeanDeploymentModule.getBeanDeploymentArchives());\n        final List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n\n        final Set<ClassLoader> subDeploymentLoaders = new HashSet<ClassLoader>();\n\n        getJpaDependencies(deploymentUnit, jpaServices);\n\n        for (DeploymentUnit subDeployment : subDeployments) {\n            getJpaDependencies(deploymentUnit, jpaServices);\n            final Module subDeploymentModule = subDeployment.getAttachment(Attachments.MODULE);\n            if (subDeploymentModule == null) {\n                continue;\n            }\n            subDeploymentLoaders.add(subDeploymentModule.getClassLoader());\n\n            final ModuleSpecification subDeploymentModuleSpec = subDeployment.getAttachment(Attachments.MODULE_SPECIFICATION);\n            final BeanDeploymentModule bdm = subDeployment.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n            if (bdm == null) {\n                continue;\n            }\n            // add the modules bdas to the global set of bdas\n            beanDeploymentArchives.addAll(bdm.getBeanDeploymentArchives());\n            List<BeanDeploymentModule> additionalModules = subDeployment.getAttachmentList(WeldAttachments.VISIBLE_ADDITIONAL_BEAN_DEPLOYMENT_MODULE);\n            bdmsByIdentifier.put(subDeploymentModule.getIdentifier(), bdm);\n            moduleSpecByIdentifier.put(subDeploymentModule.getIdentifier(), subDeploymentModuleSpec);\n\n            //we have to do this here as the aggregate components are not available in earlier phases\n            final ResourceRoot subDeploymentRoot = subDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription, eeApplicationDescription, subDeploymentRoot.getRoot());\n            bdm.addService(EjbInjectionServices.class, ejbInjectionServices);\n\n            final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n            bdm.addService(ResourceInjectionServices.class, resourceInjectionServices);\n\n            for (final BeanDeploymentModule additional : additionalModules) {\n                additional.addBeanDeploymentModule(bdm);\n                bdm.addBeanDeploymentModule(additional);\n                bdm.addService(EjbInjectionServices.class, ejbInjectionServices);\n                bdm.addService(ResourceInjectionServices.class, resourceInjectionServices);\n            }\n        }\n\n        for (Map.Entry<ModuleIdentifier, BeanDeploymentModule> entry : bdmsByIdentifier.entrySet()) {\n            final ModuleSpecification bdmSpec = moduleSpecByIdentifier.get(entry.getKey());\n            final BeanDeploymentModule bdm = entry.getValue();\n            if (bdm == rootBeanDeploymentModule) {\n                continue; // the root module only has access to itself\n            }\n            for (ModuleDependency dependency : bdmSpec.getSystemDependencies()) {\n                BeanDeploymentModule other = bdmsByIdentifier.get(dependency.getIdentifier());\n                if (other != null && other != bdm) {\n                    bdm.addBeanDeploymentModule(other);\n                }\n            }\n        }\n\n        final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(),\n                eeModuleDescription, eeApplicationDescription, deploymentRoot.getRoot());\n        final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n\n        rootBeanDeploymentModule.addService(EjbInjectionServices.class, ejbInjectionServices);\n        rootBeanDeploymentModule.addService(ResourceInjectionServices.class, resourceInjectionServices);\n\n        for (final BeanDeploymentModule additional : deploymentUnit.getAttachmentList(WeldAttachments.ADDITIONAL_BEAN_DEPLOYMENT_MODULES)) {\n            beanDeploymentArchives.addAll(additional.getBeanDeploymentArchives());\n            additional.addService(EjbInjectionServices.class, ejbInjectionServices);\n            additional.addService(ResourceInjectionServices.class, resourceInjectionServices);\n        }\n\n        final Collection<Metadata<Extension>> extensions = WeldPortableExtensions.getPortableExtensions(deploymentUnit).getExtensions();\n\n        final WeldDeployment deployment = new WeldDeployment(beanDeploymentArchives, extensions, module, subDeploymentLoaders, deploymentUnit);\n\n        final WeldBootstrapService weldBootstrapService = new WeldBootstrapService(deployment, Environments.EE_INJECT, deploymentUnit.getName());\n\n        weldBootstrapService.addWeldService(EjbInjectionServices.class, ejbInjectionServices);\n        weldBootstrapService.addWeldService(ResourceInjectionServices.class, resourceInjectionServices);\n        weldBootstrapService.addWeldService(EjbServices.class, new WeldEjbServices(deploymentUnit.getServiceRegistry()));\n\n\n        final JpaInjectionServices rootJpaInjectionServices = new WeldJpaInjectionServices(deploymentUnit);\n        final JaxwsInjectionServices rootJaxWsInjectionServices = new WeldJaxwsInjectionServices(deploymentUnit);\n        weldBootstrapService.addWeldService(JpaInjectionServices.class, rootJpaInjectionServices);\n        weldBootstrapService.addWeldService(JaxwsInjectionServices.class, rootJaxWsInjectionServices);\n\n        // add the weld service\n        final ServiceBuilder<WeldBootstrapService> weldBootstrapServiceBuilder = serviceTarget.addService(weldBootstrapServiceName, weldBootstrapService);\n\n        weldBootstrapServiceBuilder.addDependencies(TCCLSingletonService.SERVICE_NAME);\n\n        installSecurityService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n        installTransactionService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n\n        weldBootstrapServiceBuilder.install();\n\n        final List<SetupAction> setupActions  = new ArrayList<SetupAction>();\n        JavaNamespaceSetup naming = deploymentUnit.getAttachment(org.jboss.as.ee.naming.Attachments.JAVA_NAMESPACE_SETUP_ACTION);\n        if(naming != null) {\n            setupActions.add(naming);\n        }\n\n        final WeldStartService weldStartService = new WeldStartService(setupActions, module.getClassLoader());\n\n        serviceTarget.addService(deploymentUnit.getServiceName().append(WeldStartService.SERVICE_NAME), weldStartService)\n                .addDependency(weldBootstrapServiceName, WeldBootstrapService.class, weldStartService.getBootstrap())\n                // make sure JNDI bindings are up\n                .addDependency(JndiNamingDependencyProcessor.serviceName(deploymentUnit))\n                .addDependencies(jpaServices).install();\n\n    }","id":67823,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final DeploymentUnit parent = Utils.getRootDeploymentUnit(deploymentUnit);\n        final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        if (!WeldDeploymentMarker.isPartOfWeldDeployment(deploymentUnit)) {\n\n            //if there are CDI annotation present and this is the top level deployment we log a warning\n            if (deploymentUnit.getParent() == null && CdiAnnotationMarker.cdiAnnotationsPresent(deploymentUnit)) {\n                WeldLogger.DEPLOYMENT_LOGGER.cdiAnnotationsButNoBeansXML(deploymentUnit);\n            }\n\n            return;\n        }\n\n        //add a dependency on the weld service to web deployments\n        final ServiceName weldBootstrapServiceName = parent.getServiceName().append(WeldBootstrapService.SERVICE_NAME);\n        deploymentUnit.addToAttachmentList(Attachments.WEB_DEPENDENCIES, weldBootstrapServiceName);\n\n        final Set<ServiceName> jpaServices = new HashSet<ServiceName>();\n\n\n        // we only start weld on top level deployments\n        if (deploymentUnit.getParent() != null) {\n            return;\n        }\n\n        WeldLogger.DEPLOYMENT_LOGGER.startingServicesForCDIDeployment(phaseContext.getDeploymentUnit().getName());\n\n        final Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n        final ModuleSpecification moduleSpecification = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n\n        final Set<BeanDeploymentArchiveImpl> beanDeploymentArchives = new HashSet<BeanDeploymentArchiveImpl>();\n        final Map<ModuleIdentifier, BeanDeploymentModule> bdmsByIdentifier = new HashMap<ModuleIdentifier, BeanDeploymentModule>();\n        final Map<ModuleIdentifier, ModuleSpecification> moduleSpecByIdentifier = new HashMap<ModuleIdentifier, ModuleSpecification>();\n\n        // the root module only has access to itself. For most deployments this will be the only module\n        // for ear deployments this represents the ear/lib directory.\n        // war and jar deployment visibility will depend on the dependencies that\n        // exist in the application, and mirror inter module dependencies\n        final BeanDeploymentModule rootBeanDeploymentModule = deploymentUnit.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationDescription eeApplicationDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_APPLICATION_DESCRIPTION);\n\n        bdmsByIdentifier.put(module.getIdentifier(), rootBeanDeploymentModule);\n\n        for (final BeanDeploymentModule additional : deploymentUnit.getAttachmentList(WeldAttachments.VISIBLE_ADDITIONAL_BEAN_DEPLOYMENT_MODULE)) {\n            additional.addBeanDeploymentModule(rootBeanDeploymentModule);\n            rootBeanDeploymentModule.addBeanDeploymentModule(additional);\n        }\n\n        moduleSpecByIdentifier.put(module.getIdentifier(), moduleSpecification);\n\n        beanDeploymentArchives.addAll(rootBeanDeploymentModule.getBeanDeploymentArchives());\n        final List<DeploymentUnit> subDeployments = deploymentUnit.getAttachmentList(Attachments.SUB_DEPLOYMENTS);\n\n        final Set<ClassLoader> subDeploymentLoaders = new HashSet<ClassLoader>();\n\n        getJpaDependencies(deploymentUnit, jpaServices);\n\n        for (DeploymentUnit subDeployment : subDeployments) {\n            getJpaDependencies(deploymentUnit, jpaServices);\n            final Module subDeploymentModule = subDeployment.getAttachment(Attachments.MODULE);\n            if (subDeploymentModule == null) {\n                continue;\n            }\n            subDeploymentLoaders.add(subDeploymentModule.getClassLoader());\n\n            final ModuleSpecification subDeploymentModuleSpec = subDeployment.getAttachment(Attachments.MODULE_SPECIFICATION);\n            final BeanDeploymentModule bdm = subDeployment.getAttachment(WeldAttachments.BEAN_DEPLOYMENT_MODULE);\n            if (bdm == null) {\n                continue;\n            }\n            // add the modules bdas to the global set of bdas\n            beanDeploymentArchives.addAll(bdm.getBeanDeploymentArchives());\n            List<BeanDeploymentModule> additionalModules = subDeployment.getAttachmentList(WeldAttachments.VISIBLE_ADDITIONAL_BEAN_DEPLOYMENT_MODULE);\n            bdmsByIdentifier.put(subDeploymentModule.getIdentifier(), bdm);\n            moduleSpecByIdentifier.put(subDeploymentModule.getIdentifier(), subDeploymentModuleSpec);\n\n            //we have to do this here as the aggregate components are not available in earlier phases\n            final ResourceRoot subDeploymentRoot = subDeployment.getAttachment(Attachments.DEPLOYMENT_ROOT);\n            final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription, eeApplicationDescription, subDeploymentRoot.getRoot());\n            bdm.addService(EjbInjectionServices.class, ejbInjectionServices);\n\n            final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n            bdm.addService(ResourceInjectionServices.class, resourceInjectionServices);\n\n            for (final BeanDeploymentModule additional : additionalModules) {\n                additional.addBeanDeploymentModule(bdm);\n                bdm.addBeanDeploymentModule(additional);\n                bdm.addService(EjbInjectionServices.class, ejbInjectionServices);\n                bdm.addService(ResourceInjectionServices.class, resourceInjectionServices);\n            }\n        }\n\n        for (Map.Entry<ModuleIdentifier, BeanDeploymentModule> entry : bdmsByIdentifier.entrySet()) {\n            final ModuleSpecification bdmSpec = moduleSpecByIdentifier.get(entry.getKey());\n            final BeanDeploymentModule bdm = entry.getValue();\n            if (bdm == rootBeanDeploymentModule) {\n                continue; // the root module only has access to itself\n            }\n            for (ModuleDependency dependency : bdmSpec.getSystemDependencies()) {\n                BeanDeploymentModule other = bdmsByIdentifier.get(dependency.getIdentifier());\n                if (other != null && other != bdm) {\n                    bdm.addBeanDeploymentModule(other);\n                }\n            }\n        }\n\n        final EjbInjectionServices ejbInjectionServices = new WeldEjbInjectionServices(deploymentUnit.getServiceRegistry(),\n                eeModuleDescription, eeApplicationDescription, deploymentRoot.getRoot());\n        final ResourceInjectionServices resourceInjectionServices = new WeldResourceInjectionServices(deploymentUnit.getServiceRegistry(), eeModuleDescription);\n\n        rootBeanDeploymentModule.addService(EjbInjectionServices.class, ejbInjectionServices);\n        rootBeanDeploymentModule.addService(ResourceInjectionServices.class, resourceInjectionServices);\n\n        for (final BeanDeploymentModule additional : deploymentUnit.getAttachmentList(WeldAttachments.ADDITIONAL_BEAN_DEPLOYMENT_MODULES)) {\n            beanDeploymentArchives.addAll(additional.getBeanDeploymentArchives());\n            additional.addService(EjbInjectionServices.class, ejbInjectionServices);\n            additional.addService(ResourceInjectionServices.class, resourceInjectionServices);\n        }\n\n        final Collection<Metadata<Extension>> extensions = WeldPortableExtensions.getPortableExtensions(deploymentUnit).getExtensions();\n\n        final WeldDeployment deployment = new WeldDeployment(beanDeploymentArchives, extensions, module, subDeploymentLoaders, deploymentUnit);\n\n        final WeldBootstrapService weldBootstrapService = new WeldBootstrapService(deployment, Environments.EE_INJECT, deploymentUnit.getName());\n\n        installBootstrapConfigurationService(deployment);\n\n        weldBootstrapService.addWeldService(EjbInjectionServices.class, ejbInjectionServices);\n        weldBootstrapService.addWeldService(ResourceInjectionServices.class, resourceInjectionServices);\n        weldBootstrapService.addWeldService(EjbServices.class, new WeldEjbServices(deploymentUnit.getServiceRegistry()));\n\n\n        final JpaInjectionServices rootJpaInjectionServices = new WeldJpaInjectionServices(deploymentUnit);\n        final JaxwsInjectionServices rootJaxWsInjectionServices = new WeldJaxwsInjectionServices(deploymentUnit);\n        weldBootstrapService.addWeldService(JpaInjectionServices.class, rootJpaInjectionServices);\n        weldBootstrapService.addWeldService(JaxwsInjectionServices.class, rootJaxWsInjectionServices);\n\n        // add the weld service\n        final ServiceBuilder<WeldBootstrapService> weldBootstrapServiceBuilder = serviceTarget.addService(weldBootstrapServiceName, weldBootstrapService);\n\n        weldBootstrapServiceBuilder.addDependencies(TCCLSingletonService.SERVICE_NAME);\n\n        installSecurityService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n        installTransactionService(serviceTarget, deploymentUnit, weldBootstrapService, weldBootstrapServiceBuilder);\n\n        weldBootstrapServiceBuilder.install();\n\n        final List<SetupAction> setupActions  = new ArrayList<SetupAction>();\n        JavaNamespaceSetup naming = deploymentUnit.getAttachment(org.jboss.as.ee.naming.Attachments.JAVA_NAMESPACE_SETUP_ACTION);\n        if(naming != null) {\n            setupActions.add(naming);\n        }\n\n        final WeldStartService weldStartService = new WeldStartService(setupActions, module.getClassLoader());\n\n        serviceTarget.addService(deploymentUnit.getServiceName().append(WeldStartService.SERVICE_NAME), weldStartService)\n                .addDependency(weldBootstrapServiceName, WeldBootstrapService.class, weldStartService.getBootstrap())\n                // make sure JNDI bindings are up\n                .addDependency(JndiNamingDependencyProcessor.serviceName(deploymentUnit))\n                .addDependencies(jpaServices).install();\n\n    }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void initializeParsers(final ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, WeldExtension.NAMESPACE, parser);\n    }","id":67824,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void initializeParsers(final ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, WeldSubsystem10Parser.NAMESPACE, WeldSubsystem10Parser.INSTANCE);\n        context.setSubsystemXmlMapping(SUBSYSTEM_NAME, WeldSubsystem20Parser.NAMESPACE, WeldSubsystem20Parser.INSTANCE);\n    }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(final ExtensionContext context) {\n        WeldLogger.ROOT_LOGGER.debug(\"Activating Weld Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WELD_SUBSYSTEM_RESOURCE);\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        subsystem.registerXMLElementWriter(parser);\n    }","id":67825,"modified_method":"/** {@inheritDoc} */\n    @Override\n    public void initialize(final ExtensionContext context) {\n        WeldLogger.ROOT_LOGGER.debug(\"Activating Weld Extension\");\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,\n                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(WeldResourceDefinition.INSTANCE);\n        registration.registerOperationHandler(GenericSubsystemDescribeHandler.DEFINITION, GenericSubsystemDescribeHandler.INSTANCE);\n        subsystem.registerXMLElementWriter(WeldSubsystemPersister.INSTANCE);\n    }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) {\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CDI_ANNOTATIONS, new CdiAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CDI_BEAN_DEFINING_ANNOTATIONS, new BeanDefiningAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WELD_DEPLOYMENT, new BeansXmlProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WELD_IMPLICIT_DEPLOYMENT_DETECTION, new WeldImplicitDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_WELD, new WeldDependencyProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_WEB_INTEGRATION, new WebIntegrationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_BEAN_ARCHIVE, new BeanArchiveProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_EXTERNAL_BEAN_ARCHIVE, new ExternalBeanArchiveProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_PORTABLE_EXTENSIONS, new WeldPortableExtensionProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_COMPONENT_INTEGRATION, new WeldComponentIntegrationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WELD_DEPLOYMENT, new WeldDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_CDI_VALIDATOR_FACTORY, new CdiBeanValidationFactoryProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WELD_BEAN_MANAGER, new WeldBeanManagerServiceProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        TCCLSingletonService singleton = new TCCLSingletonService();\n        newControllers.add(context.getServiceTarget().addService(TCCLSingletonService.SERVICE_NAME, singleton).setInitialMode(\n                Mode.ON_DEMAND).install());\n    }","id":67826,"modified_method":"@Override\n    protected void performBoottime(OperationContext context, ModelNode operation, final ModelNode model, ServiceVerificationHandler verificationHandler, List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        final boolean requireBeanDescriptor = REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE.resolveModelAttribute(context, model).asBoolean();\n        final boolean nonPortableMode = WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE.resolveModelAttribute(context, model).asBoolean();\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CDI_ANNOTATIONS, new CdiAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_CDI_BEAN_DEFINING_ANNOTATIONS, new BeanDefiningAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WELD_DEPLOYMENT, new BeansXmlProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_WELD_IMPLICIT_DEPLOYMENT_DETECTION, new WeldImplicitDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_WELD, new WeldDependencyProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_WEB_INTEGRATION, new WebIntegrationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_BEAN_ARCHIVE, new BeanArchiveProcessor(requireBeanDescriptor));\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_EXTERNAL_BEAN_ARCHIVE, new ExternalBeanArchiveProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_PORTABLE_EXTENSIONS, new WeldPortableExtensionProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_WELD_COMPONENT_INTEGRATION, new WeldComponentIntegrationProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WELD_DEPLOYMENT, new WeldDeploymentProcessor(nonPortableMode));\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_CDI_VALIDATOR_FACTORY, new CdiBeanValidationFactoryProcessor());\n                processorTarget.addDeploymentProcessor(WeldExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_WELD_BEAN_MANAGER, new WeldBeanManagerServiceProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        TCCLSingletonService singleton = new TCCLSingletonService();\n        newControllers.add(context.getServiceTarget().addService(TCCLSingletonService.SERVICE_NAME, singleton).setInitialMode(\n                Mode.ON_DEMAND).install());\n    }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void populateModel(ModelNode operation, ModelNode model) {\n        model.setEmptyObject();\n    }","id":67827,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE.validateAndSet(operation, model);\n        WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE.validateAndSet(operation, model);\n    }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        //This is just copied from standalone.xml testing more combinations would be good\n        return\n            \"<subsystem xmlns=\\\"urn:jboss:domain:weld:1.0\\\" />\";\n    }","id":67828,"modified_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        //This is just copied from standalone.xml testing more combinations would be good\n        return\n            \"<subsystem xmlns=\\\"urn:jboss:domain:weld:2.0\\\" require-bean-descriptor=\\\"false\\\" non-portable-mode=\\\"false\\\" />\";\n    }","commit_id":"1c043e81321a6df3b2e7f06fb3d385099c793180","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        Activation val = Activation.valueOf(operation.require(ModelDescriptionConstants.VALUE).asString().toUpperCase());\n\n        ModelNode node = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel();\n        node.get(CommonAttributes.ACTIVATION).set(val.toString().toLowerCase());\n\n        if (val == Activation.EAGER) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    ServiceController<?> svc = context.getServiceRegistry(true).getRequiredService(Services.FRAMEWORK_ACTIVE);\n                    svc.setMode(Mode.ACTIVE);\n                    context.completeStep();\n                }\n            }, Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","id":67829,"modified_method":"@Override\n    public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n        Activation val = Activation.valueOf(operation.require(ModelDescriptionConstants.VALUE).asString().toUpperCase());\n\n        ModelNode node = context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS).getModel();\n        node.get(Constants.ACTIVATION).set(val.toString().toLowerCase());\n\n        if (val == Activation.EAGER) {\n            context.addStep(new OperationStepHandler() {\n                @Override\n                public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                    ServiceController<?> svc = context.getServiceRegistry(true).getRequiredService(Services.FRAMEWORK_ACTIVE);\n                    svc.setMode(Mode.ACTIVE);\n                    context.completeStep();\n                }\n            }, Stage.RUNTIME);\n        }\n        context.completeStep();\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void testHandlerEagerActivate() throws Exception {\n        ModelNode targetNode = new ModelNode();\n        targetNode.get(CommonAttributes.ACTIVATION).set(\"lazy\");\n\n        OperationContext context = Mockito.mock(OperationContext.class);\n        Resource resource = Mockito.mock(Resource.class);\n        Mockito.when(resource.getModel()).thenReturn(targetNode);\n        Mockito.when(context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS)).thenReturn(resource);\n\n        final List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        Mockito.doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                addedSteps.add((OperationStepHandler) invocation.getArguments()[0]);\n                return null;\n            }\n        }).when(context).addStep((OperationStepHandler) Mockito.any(), Mockito.eq(Stage.RUNTIME));\n\n        ActivationAttributeHandler handler = new ActivationAttributeHandler();\n\n        ModelNode operation = new ModelNode();\n        operation.get(ModelDescriptionConstants.VALUE).set(Activation.EAGER.toString().toLowerCase());\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        handler.execute(context, operation);\n        Mockito.verify(context).completeStep();\n        Assert.assertEquals(Activation.EAGER.toString().toLowerCase(), targetNode.get(CommonAttributes.ACTIVATION).asString());\n\n        // Now test the runtime piece...\n        ServiceRegistry registry = Mockito.mock(ServiceRegistry.class);\n        ServiceController svcCtrl = Mockito.mock(ServiceController.class);\n        Mockito.when(registry.getRequiredService(Services.FRAMEWORK_ACTIVE)).thenReturn(svcCtrl);\n\n        OperationContext context2 = Mockito.mock(OperationContext.class);\n        Mockito.when(context2.getServiceRegistry(true)).thenReturn(registry);\n\n        Assert.assertEquals(1, addedSteps.size());\n        addedSteps.get(0).execute(context2, operation);\n\n        Mockito.verify(svcCtrl).setMode(Mode.ACTIVE);\n        Mockito.verify(context2).completeStep();\n    }","id":67830,"modified_method":"@Test\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    public void testHandlerEagerActivate() throws Exception {\n        ModelNode targetNode = new ModelNode();\n        targetNode.get(Constants.ACTIVATION).set(\"lazy\");\n\n        OperationContext context = Mockito.mock(OperationContext.class);\n        Resource resource = Mockito.mock(Resource.class);\n        Mockito.when(resource.getModel()).thenReturn(targetNode);\n        Mockito.when(context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS)).thenReturn(resource);\n\n        final List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        Mockito.doAnswer(new Answer<Void>() {\n            @Override\n            public Void answer(InvocationOnMock invocation) throws Throwable {\n                addedSteps.add((OperationStepHandler) invocation.getArguments()[0]);\n                return null;\n            }\n        }).when(context).addStep((OperationStepHandler) Mockito.any(), Mockito.eq(Stage.RUNTIME));\n\n        ActivationAttributeHandler handler = new ActivationAttributeHandler();\n\n        ModelNode operation = new ModelNode();\n        operation.get(ModelDescriptionConstants.VALUE).set(Activation.EAGER.toString().toLowerCase());\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        handler.execute(context, operation);\n        Mockito.verify(context).completeStep();\n        Assert.assertEquals(Activation.EAGER.toString().toLowerCase(), targetNode.get(Constants.ACTIVATION).asString());\n\n        // Now test the runtime piece...\n        ServiceRegistry registry = Mockito.mock(ServiceRegistry.class);\n        ServiceController svcCtrl = Mockito.mock(ServiceController.class);\n        Mockito.when(registry.getRequiredService(Services.FRAMEWORK_ACTIVE)).thenReturn(svcCtrl);\n\n        OperationContext context2 = Mockito.mock(OperationContext.class);\n        Mockito.when(context2.getServiceRegistry(true)).thenReturn(registry);\n\n        Assert.assertEquals(1, addedSteps.size());\n        addedSteps.get(0).execute(context2, operation);\n\n        Mockito.verify(svcCtrl).setMode(Mode.ACTIVE);\n        Mockito.verify(context2).completeStep();\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testHandlerLazy() throws Exception {\n        ModelNode targetNode = new ModelNode();\n        targetNode.get(CommonAttributes.ACTIVATION).set(\"eager\");\n\n        OperationContext context = Mockito.mock(OperationContext.class);\n        Resource resource = Mockito.mock(Resource.class);\n        Mockito.when(resource.getModel()).thenReturn(targetNode);\n        Mockito.when(context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS)).thenReturn(resource);\n\n        ActivationAttributeHandler handler = new ActivationAttributeHandler();\n\n        ModelNode operation = new ModelNode();\n        operation.get(ModelDescriptionConstants.VALUE).set(Activation.LAZY.toString().toLowerCase());\n        handler.execute(context, operation);\n\n        Mockito.verify(context).completeStep();\n\n        Assert.assertEquals(Activation.LAZY.toString().toLowerCase(), targetNode.get(CommonAttributes.ACTIVATION).asString());\n    }","id":67831,"modified_method":"@Test\n    public void testHandlerLazy() throws Exception {\n        ModelNode targetNode = new ModelNode();\n        targetNode.get(Constants.ACTIVATION).set(\"eager\");\n\n        OperationContext context = Mockito.mock(OperationContext.class);\n        Resource resource = Mockito.mock(Resource.class);\n        Mockito.when(resource.getModel()).thenReturn(targetNode);\n        Mockito.when(context.readResourceForUpdate(PathAddress.EMPTY_ADDRESS)).thenReturn(resource);\n\n        ActivationAttributeHandler handler = new ActivationAttributeHandler();\n\n        ModelNode operation = new ModelNode();\n        operation.get(ModelDescriptionConstants.VALUE).set(Activation.LAZY.toString().toLowerCase());\n        handler.execute(context, operation);\n\n        Mockito.verify(context).completeStep();\n\n        Assert.assertEquals(Activation.LAZY.toString().toLowerCase(), targetNode.get(Constants.ACTIVATION).asString());\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        if (operation.has(CommonAttributes.STARTLEVEL)) {\n            model.get(CommonAttributes.STARTLEVEL).set(operation.get(CommonAttributes.STARTLEVEL));\n        }\n    }","id":67832,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        if (operation.has(Constants.STARTLEVEL)) {\n            model.get(Constants.STARTLEVEL).set(operation.get(Constants.STARTLEVEL));\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void rollbackRuntime(OperationContext context, ModelNode operation, ModelNode model, List<ServiceController<?>> controllers) {\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.CAPABILITY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.removeCapability(identifier);\n        }\n    }","id":67833,"modified_method":"@Override\n    protected void rollbackRuntime(OperationContext context, ModelNode operation, ModelNode model, List<ServiceController<?>> controllers) {\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.CAPABILITY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.removeCapability(identifier);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode slNode = null;\n        if (operation.has(CommonAttributes.STARTLEVEL)) {\n            slNode = operation.get(CommonAttributes.STARTLEVEL);\n            model.get(CommonAttributes.STARTLEVEL).set(slNode);\n        }\n        final Integer startLevel = (slNode != null ? slNode.asInt() : null);\n\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.CAPABILITY).asString();\n        OSGiCapability module = new OSGiCapability(ModuleIdentifier.fromString(identifier), startLevel);\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.addCapability(module);\n        }\n    }","id":67834,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode slNode = null;\n        if (operation.has(Constants.STARTLEVEL)) {\n            slNode = operation.get(Constants.STARTLEVEL);\n            model.get(Constants.STARTLEVEL).set(slNode);\n        }\n        final Integer startLevel = (slNode != null ? slNode.asInt() : null);\n\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.CAPABILITY).asString();\n        OSGiCapability module = new OSGiCapability(ModuleIdentifier.fromString(identifier), startLevel);\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.addCapability(module);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOSGiCapabilityAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(CommonAttributes.CAPABILITY, \"org.acme.module1\"));\n        ModelNode data = new ModelNode();\n        data.get(CommonAttributes.STARTLEVEL).set(\"4\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiCapabilityAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getCapabilities().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(1, stateService.getCapabilities().size());\n        OSGiCapability module = stateService.getCapabilities().get(0);\n        Assert.assertEquals(\"org.acme.module1:main\", module.getIdentifier().toString());\n        Assert.assertEquals(new Integer(4), module.getStartLevel());\n\n        OSGiCapabilityRemove.INSTANCE.execute(context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.ROLLBACK);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Module should have been kept as the operation was rolled back\", module, stateService.getCapabilities().get(0));\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.KEEP);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Module should have been removed\", 0, stateService.getCapabilities().size());\n    }","id":67835,"modified_method":"@Test\n    public void testOSGiCapabilityAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(Constants.CAPABILITY, \"org.acme.module1\"));\n        ModelNode data = new ModelNode();\n        data.get(Constants.STARTLEVEL).set(\"4\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiCapabilityAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getCapabilities().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(1, stateService.getCapabilities().size());\n        OSGiCapability module = stateService.getCapabilities().get(0);\n        Assert.assertEquals(\"org.acme.module1:main\", module.getIdentifier().toString());\n        Assert.assertEquals(new Integer(4), module.getStartLevel());\n\n        OSGiCapabilityRemove.INSTANCE.execute(context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.ROLLBACK);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Module should have been kept as the operation was rolled back\", module, stateService.getCapabilities().get(0));\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.KEEP);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Module should have been removed\", 0, stateService.getCapabilities().size());\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ModelNode getAddOperation(ModelNode address, ModelNode existing) {\n        ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.ADD, address);\n        if (existing.hasDefined(CommonAttributes.STARTLEVEL)) {\n            op.get(CommonAttributes.STARTLEVEL).set(existing.get(CommonAttributes.STARTLEVEL));\n        }\n        return op;\n    }","id":67836,"modified_method":"private ModelNode getAddOperation(ModelNode address, ModelNode existing) {\n        ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.ADD, address);\n        if (existing.hasDefined(Constants.STARTLEVEL)) {\n            op.get(Constants.STARTLEVEL).set(existing.get(Constants.STARTLEVEL));\n        }\n        return op;\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOSGiCapabilityAddRollback() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.ROLLBACK);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(CommonAttributes.CAPABILITY, \"org.acme.module1\"));\n        ModelNode data = new ModelNode();\n        data.get(CommonAttributes.STARTLEVEL).set(\"4\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiCapabilityAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getCapabilities().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(\"Operation should have been rolled back\", 0, stateService.getCapabilities().size());\n    }","id":67837,"modified_method":"@Test\n    public void testOSGiCapabilityAddRollback() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.ROLLBACK);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(Constants.CAPABILITY, \"org.acme.module1\"));\n        ModelNode data = new ModelNode();\n        data.get(Constants.STARTLEVEL).set(\"4\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiCapabilityAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getCapabilities().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(\"Operation should have been rolled back\", 0, stateService.getCapabilities().size());\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.CAPABILITY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null && context.completeStep() == OperationContext.ResultAction.KEEP) {\n            subsystemState.removeCapability(identifier);\n        }\n    }","id":67838,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        String identifier = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.CAPABILITY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null && context.completeStep() == OperationContext.ResultAction.KEEP) {\n            subsystemState.removeCapability(identifier);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode entries = operation.get(CommonAttributes.ENTRIES);\n        String pid = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.CONFIGURATION).asString();\n        Dictionary<String, String> dictionary = new Hashtable<String, String>();\n        for (String key : entries.keys()) {\n            dictionary.put(key, entries.get(key).asString());\n        }\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.putConfiguration(pid, dictionary);\n        }\n    }","id":67839,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        ModelNode entries = operation.get(Constants.ENTRIES);\n        String pid = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.CONFIGURATION).asString();\n        Dictionary<String, String> dictionary = new Hashtable<String, String>();\n        for (String key : entries.keys()) {\n            dictionary.put(key, entries.get(key).asString());\n        }\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.putConfiguration(pid, dictionary);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        model.get(CommonAttributes.ENTRIES).set(operation.get(CommonAttributes.ENTRIES));\n    }","id":67840,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        model.get(Constants.ENTRIES).set(operation.get(Constants.ENTRIES));\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void rollbackRuntime(OperationContext context, ModelNode operation, ModelNode model, List<ServiceController<?>> controllers) {\n        String pid = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.CONFIGURATION).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.removeConfiguration(pid);\n        }\n    }","id":67841,"modified_method":"@Override\n    protected void rollbackRuntime(OperationContext context, ModelNode operation, ModelNode model, List<ServiceController<?>> controllers) {\n        String pid = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.CONFIGURATION).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.removeConfiguration(pid);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testConfigurationAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(CommonAttributes.CONFIGURATION, \"org.acme.pid1\"));\n        ModelNode data = new ModelNode();\n        ModelNode entries = new ModelNode();\n        entries.get(\"mykey\").set(\"myval\");\n        data.get(CommonAttributes.ENTRIES).set(entries);\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiConfigurationAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getConfigurations().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(1, stateService.getConfigurations().size());\n        Dictionary<String, String> config = stateService.getConfiguration(\"org.acme.pid1\");\n        Assert.assertEquals(1, config.size());\n        Assert.assertEquals(\"myval\", config.get(\"mykey\"));\n\n        OSGiConfigurationRemove.INSTANCE.execute(context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.ROLLBACK);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Configuration rolled back\", 1, stateService.getConfiguration(\"org.acme.pid1\").size());\n        Assert.assertEquals(\"Configuration rolled back\", \"myval\", stateService.getConfiguration(\"org.acme.pid1\").get(\"mykey\"));\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.KEEP);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertNull(\"Configuration should have been removed\", stateService.getConfiguration(\"org.acme.pid1\"));\n    }","id":67842,"modified_method":"@Test\n    public void testConfigurationAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(Constants.CONFIGURATION, \"org.acme.pid1\"));\n        ModelNode data = new ModelNode();\n        ModelNode entries = new ModelNode();\n        entries.get(\"mykey\").set(\"myval\");\n        data.get(Constants.ENTRIES).set(entries);\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiConfigurationAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getConfigurations().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(1, stateService.getConfigurations().size());\n        Dictionary<String, String> config = stateService.getConfiguration(\"org.acme.pid1\");\n        Assert.assertEquals(1, config.size());\n        Assert.assertEquals(\"myval\", config.get(\"mykey\"));\n\n        OSGiConfigurationRemove.INSTANCE.execute(context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.ROLLBACK);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Configuration rolled back\", 1, stateService.getConfiguration(\"org.acme.pid1\").size());\n        Assert.assertEquals(\"Configuration rolled back\", \"myval\", stateService.getConfiguration(\"org.acme.pid1\").get(\"mykey\"));\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.KEEP);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertNull(\"Configuration should have been removed\", stateService.getConfiguration(\"org.acme.pid1\"));\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ModelNode getAddOperation(ModelNode address, ModelNode model) {\n        ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.ADD, address);\n        if (model.hasDefined(CommonAttributes.ENTRIES)) {\n            op.get(CommonAttributes.ENTRIES).set(model.get(CommonAttributes.ENTRIES));\n        }\n        return op;\n    }","id":67843,"modified_method":"private ModelNode getAddOperation(ModelNode address, ModelNode model) {\n        ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.ADD, address);\n        if (model.hasDefined(Constants.ENTRIES)) {\n            op.get(Constants.ENTRIES).set(model.get(Constants.ENTRIES));\n        }\n        return op;\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testConfigurationAddRollback() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.ROLLBACK);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(CommonAttributes.CONFIGURATION, \"org.acme.pid1\"));\n        ModelNode data = new ModelNode();\n        ModelNode entries = new ModelNode();\n        entries.get(\"mykey\").set(\"myval\");\n        data.get(CommonAttributes.ENTRIES).set(entries);\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiConfigurationAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getConfigurations().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(\"Operation should have been rolled back\", 0, stateService.getConfigurations().size());\n    }","id":67844,"modified_method":"@Test\n    public void testConfigurationAddRollback() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.ROLLBACK);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(Constants.CONFIGURATION, \"org.acme.pid1\"));\n        ModelNode data = new ModelNode();\n        ModelNode entries = new ModelNode();\n        entries.get(\"mykey\").set(\"myval\");\n        data.get(Constants.ENTRIES).set(entries);\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiConfigurationAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertEquals(\"Precondition\", 0, stateService.getConfigurations().size());\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(\"Operation should have been rolled back\", 0, stateService.getConfigurations().size());\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        String pid = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.CONFIGURATION).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null && context.completeStep() == OperationContext.ResultAction.KEEP) {\n            subsystemState.removeConfiguration(pid);\n        }\n    }","id":67845,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        String pid = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.CONFIGURATION).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null && context.completeStep() == OperationContext.ResultAction.KEEP) {\n            subsystemState.removeConfiguration(pid);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(Namespace.CURRENT.getUriString(), parser);\n    }","id":67846,"modified_method":"@Override\n    public void initializeParsers(ExtensionParsingContext context) {\n        context.setSubsystemXmlMapping(Namespace.OSGI_1_0.getUriString(), OSGiNamespace10Parser.INSTANCE);\n        context.setSubsystemXmlMapping(Namespace.OSGI_1_1.getUriString(), OSGiNamespace11Parser.INSTANCE);\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(OSGiSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiSubsystemAdd.INSTANCE, OSGiSubsystemAdd.DESCRIPTION, false);\n        registration.registerReadWriteAttribute(CommonAttributes.ACTIVATION, null, new ActivationAttributeHandler(), Storage.CONFIGURATION);\n        registration.registerOperationHandler(ModelDescriptionConstants.DESCRIBE, OSGiSubsystemDescribeHandler.INSTANCE, OSGiSubsystemAdd.DESCRIPTION, false, OperationEntry.EntryType.PRIVATE);\n\n        // Configuration Admin Setings\n        ManagementResourceRegistration configuration = registration.registerSubModel(PathElement.pathElement(CommonAttributes.CONFIGURATION), OSGiSubsystemProviders.CONFIGURATION_DESCRIPTION);\n        configuration.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiConfigurationAdd.INSTANCE, OSGiConfigurationAdd.DESCRIPTION, false);\n        configuration.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiConfigurationRemove.INSTANCE, OSGiConfigurationRemove.DESCRIPTION, false);\n\n        // Framework Properties\n        ManagementResourceRegistration properties = registration.registerSubModel(PathElement.pathElement(CommonAttributes.FRAMEWORK_PROPERTY), OSGiSubsystemProviders.FRAMEWORK_PROPERTY_DESCRIPTION);\n        properties.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiFrameworkPropertyAdd.INSTANCE, OSGiFrameworkPropertyAdd.DESCRIPTION, false);\n        properties.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiFrameworkPropertyRemove.INSTANCE, OSGiFrameworkPropertyRemove.DESCRIPTION, false);\n\n        // Pre loaded modules\n        ManagementResourceRegistration capabilities = registration.registerSubModel(PathElement.pathElement(CommonAttributes.CAPABILITY), OSGiSubsystemProviders.CAPABILITY_DESCRIPTION);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiCapabilityAdd.INSTANCE, OSGiCapabilityAdd.DESCRIPTION, false);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiCapabilityRemove.INSTANCE, OSGiCapabilityRemove.DESCRIPTION, false);\n\n        subsystem.registerXMLElementWriter(parser);\n    }","id":67847,"modified_method":"@Override\n    public void initialize(ExtensionContext context) {\n        final SubsystemRegistration subsystem = context.registerSubsystem(SUBSYSTEM_NAME);\n        final ManagementResourceRegistration registration = subsystem.registerSubsystemModel(OSGiSubsystemProviders.SUBSYSTEM);\n        registration.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiSubsystemAdd.INSTANCE, OSGiSubsystemAdd.DESCRIPTION, false);\n        registration.registerReadWriteAttribute(Constants.ACTIVATION, null, new ActivationAttributeHandler(), Storage.CONFIGURATION);\n        registration.registerOperationHandler(ModelDescriptionConstants.DESCRIBE, OSGiSubsystemDescribeHandler.INSTANCE, OSGiSubsystemAdd.DESCRIPTION, false, OperationEntry.EntryType.PRIVATE);\n\n        // Configuration Admin Setings\n        ManagementResourceRegistration configuration = registration.registerSubModel(PathElement.pathElement(Constants.CONFIGURATION), OSGiSubsystemProviders.CONFIGURATION_DESCRIPTION);\n        configuration.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiConfigurationAdd.INSTANCE, OSGiConfigurationAdd.DESCRIPTION, false);\n        configuration.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiConfigurationRemove.INSTANCE, OSGiConfigurationRemove.DESCRIPTION, false);\n\n        // Framework Properties\n        ManagementResourceRegistration properties = registration.registerSubModel(PathElement.pathElement(Constants.FRAMEWORK_PROPERTY), OSGiSubsystemProviders.FRAMEWORK_PROPERTY_DESCRIPTION);\n        properties.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiFrameworkPropertyAdd.INSTANCE, OSGiFrameworkPropertyAdd.DESCRIPTION, false);\n        properties.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiFrameworkPropertyRemove.INSTANCE, OSGiFrameworkPropertyRemove.DESCRIPTION, false);\n\n        // Pre loaded modules\n        ManagementResourceRegistration capabilities = registration.registerSubModel(PathElement.pathElement(Constants.CAPABILITY), OSGiSubsystemProviders.CAPABILITY_DESCRIPTION);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.ADD, OSGiCapabilityAdd.INSTANCE, OSGiCapabilityAdd.DESCRIPTION, false);\n        capabilities.registerOperationHandler(ModelDescriptionConstants.REMOVE, OSGiCapabilityRemove.INSTANCE, OSGiCapabilityRemove.DESCRIPTION, false);\n\n        subsystem.registerXMLElementWriter(OSGiSubsystemWriter.INSTANCE);\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        String propName = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.FRAMEWORK_PROPERTY).asString();\n        String propValue = model.get(CommonAttributes.VALUE).asString();\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.setProperty(propName, propValue);\n        }\n    }","id":67848,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model, ServiceVerificationHandler verificationHandler,\n            List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        String propName = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.FRAMEWORK_PROPERTY).asString();\n        String propValue = model.get(Constants.VALUE).asString();\n\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.setProperty(propName, propValue);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        model.get(CommonAttributes.VALUE).set(operation.get(CommonAttributes.VALUE));\n    }","id":67849,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        model.get(Constants.VALUE).set(operation.get(Constants.VALUE));\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void rollbackRuntime(OperationContext context, ModelNode operation, ModelNode model, List<ServiceController<?>> controllers) {\n        String propName = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.FRAMEWORK_PROPERTY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.setProperty(propName, null);\n        }\n    }","id":67850,"modified_method":"@Override\n    protected void rollbackRuntime(OperationContext context, ModelNode operation, ModelNode model, List<ServiceController<?>> controllers) {\n        String propName = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.FRAMEWORK_PROPERTY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null) {\n            subsystemState.setProperty(propName, null);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOSGiPropertyAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(CommonAttributes.FRAMEWORK_PROPERTY, \"PropertyX\"));\n        ModelNode data = new ModelNode();\n        data.get(CommonAttributes.VALUE).set(\"hi\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiFrameworkPropertyAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertNull(\"Precondition\", stateService.getProperties().get(\"PropertyX\"));\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(\"hi\", stateService.getProperties().get(\"PropertyX\"));\n\n        OSGiFrameworkPropertyRemove.INSTANCE.execute(context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.ROLLBACK);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Property should have been kept as the operation was rolled back\", \"hi\", stateService.getProperties().get(\"PropertyX\"));\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.KEEP);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertNull(\"Property should have been removed\", stateService.getProperties().get(\"PropertyX\"));\n    }","id":67851,"modified_method":"@Test\n    public void testOSGiPropertyAddRemove() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.KEEP);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(Constants.FRAMEWORK_PROPERTY, \"PropertyX\"));\n        ModelNode data = new ModelNode();\n        data.get(Constants.VALUE).set(\"hi\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiFrameworkPropertyAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertNull(\"Precondition\", stateService.getProperties().get(\"PropertyX\"));\n        addedSteps.get(0).execute(context, op);\n        Assert.assertEquals(\"hi\", stateService.getProperties().get(\"PropertyX\"));\n\n        OSGiFrameworkPropertyRemove.INSTANCE.execute(context, op);\n        Assert.assertEquals(\"Actual remove added as async step\", 2, addedSteps.size());\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.ROLLBACK);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertEquals(\"Property should have been kept as the operation was rolled back\", \"hi\", stateService.getProperties().get(\"PropertyX\"));\n\n        Mockito.when(context.completeStep()).thenReturn(OperationContext.ResultAction.KEEP);\n        addedSteps.get(1).execute(context, op);\n        Assert.assertNull(\"Property should have been removed\", stateService.getProperties().get(\"PropertyX\"));\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testOSGiPropertyAddRollback() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.ROLLBACK);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(CommonAttributes.FRAMEWORK_PROPERTY, \"PropertyX\"));\n        ModelNode data = new ModelNode();\n        data.get(CommonAttributes.VALUE).set(\"hi\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiFrameworkPropertyAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertNull(\"Precondition\", stateService.getProperties().get(\"PropertyX\"));\n        addedSteps.get(0).execute(context, op);\n        Assert.assertNull(\"Operation should have been rolled back\", stateService.getProperties().get(\"PropertyX\"));\n    }","id":67852,"modified_method":"@Test\n    public void testOSGiPropertyAddRollback() throws Exception {\n        SubsystemState stateService = new SubsystemState();\n        List<OperationStepHandler> addedSteps = new ArrayList<OperationStepHandler>();\n        OperationContext context = mockOperationContext(stateService, addedSteps, OperationContext.ResultAction.ROLLBACK);\n\n        ModelNode address = new ModelNode();\n        address.add(new ModelNode().set(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME));\n        address.add(new ModelNode().set(Constants.FRAMEWORK_PROPERTY, \"PropertyX\"));\n        ModelNode data = new ModelNode();\n        data.get(Constants.VALUE).set(\"hi\");\n        ModelNode op = getAddOperation(address, data);\n\n        Assert.assertEquals(\"Precondition\", 0, addedSteps.size());\n        OSGiFrameworkPropertyAdd.INSTANCE.execute(context, op);\n        Assert.assertEquals(1, addedSteps.size());\n\n        Assert.assertNull(\"Precondition\", stateService.getProperties().get(\"PropertyX\"));\n        addedSteps.get(0).execute(context, op);\n        Assert.assertNull(\"Operation should have been rolled back\", stateService.getProperties().get(\"PropertyX\"));\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"private ModelNode getAddOperation(ModelNode address, ModelNode existing) {\n        ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.ADD, address);\n        op.get(CommonAttributes.VALUE).set(existing.get(CommonAttributes.VALUE));\n        return op;\n    }","id":67853,"modified_method":"private ModelNode getAddOperation(ModelNode address, ModelNode existing) {\n        ModelNode op = Util.getEmptyOperation(ModelDescriptionConstants.ADD, address);\n        op.get(Constants.VALUE).set(existing.get(Constants.VALUE));\n        return op;\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        String propName = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(CommonAttributes.FRAMEWORK_PROPERTY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null && context.completeStep() == OperationContext.ResultAction.KEEP) {\n            subsystemState.setProperty(propName, null);\n        }\n    }","id":67854,"modified_method":"@Override\n    protected void performRuntime(OperationContext context, ModelNode operation, ModelNode model) throws OperationFailedException {\n        String propName = operation.get(ModelDescriptionConstants.OP_ADDR).asObject().get(Constants.FRAMEWORK_PROPERTY).asString();\n        SubsystemState subsystemState = SubsystemState.getSubsystemState(context);\n        if (subsystemState != null && context.completeStep() == OperationContext.ResultAction.KEEP) {\n            subsystemState.setProperty(propName, null);\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void populateModel(final ModelNode operation, final ModelNode subModel) {\n        if (operation.has(ACTIVATION)) {\n            subModel.get(ACTIVATION).set(operation.get(ACTIVATION));\n        }\n    }","id":67855,"modified_method":"protected void populateModel(final ModelNode operation, final ModelNode subModel) {\n        if (operation.has(Constants.ACTIVATION)) {\n            subModel.get(Constants.ACTIVATION).set(operation.get(Constants.ACTIVATION));\n        }\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"private Activation getActivationMode(ModelNode operation) {\n        Activation activation = SubsystemState.DEFAULT_ACTIVATION;\n        if (operation.has(ACTIVATION)) {\n            activation = Activation.valueOf(operation.get(ACTIVATION).asString().toUpperCase());\n        }\n        return activation;\n    }","id":67856,"modified_method":"private Activation getActivationMode(ModelNode operation) {\n        Activation activation = SubsystemState.DEFAULT_ACTIVATION;\n        if (operation.has(Constants.ACTIVATION)) {\n            activation = Activation.valueOf(operation.get(Constants.ACTIVATION).asString().toUpperCase());\n        }\n        return activation;\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testParseSubsystemWithProperties() throws Exception {\n        String subsystemXml =\n            \"<subsystem xmlns='urn:jboss:domain:osgi:1.0' activation='eager'>\" +\n            \"  <properties>\" +\n            \"    <property name='org.acme.myProperty'>\" +\n            \"      hi ho\" +\n            \"    <\/property>\" +\n            \"    <property name='org.acme.myProperty2'>\" +\n            \"      hi.ho\" +\n            \"    <\/property>\" +\n            \"  <\/properties>\" +\n            \"<\/subsystem>\";\n\n        List<ModelNode> operations = parse(subsystemXml);\n        Assert.assertEquals(3, operations.size());\n\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ModelDescriptionConstants.ADD, addSubsystem.get(ModelDescriptionConstants.OP).asString());\n        assertOSGiSubsystemAddress(addSubsystem.get(ModelDescriptionConstants.OP_ADDR));\n        Assert.assertEquals(\"eager\", addSubsystem.get(CommonAttributes.ACTIVATION).asString());\n\n        checkData(operations, 1, CommonAttributes.FRAMEWORK_PROPERTY, \"org.acme.myProperty\",\n                CommonAttributes.VALUE, \"hi ho\");\n        checkData(operations, 2, CommonAttributes.FRAMEWORK_PROPERTY, \"org.acme.myProperty2\",\n                CommonAttributes.VALUE, \"hi.ho\");\n    }","id":67857,"modified_method":"@Test\n    public void testParseSubsystemWithProperties() throws Exception {\n        String subsystemXml =\n            \"<subsystem xmlns='urn:jboss:domain:osgi:1.1' activation='eager'>\" +\n            \"  <properties>\" +\n            \"    <property name='org.acme.myProperty'>\" +\n            \"      hi ho\" +\n            \"    <\/property>\" +\n            \"    <property name='org.acme.myProperty2'>\" +\n            \"      hi.ho\" +\n            \"    <\/property>\" +\n            \"  <\/properties>\" +\n            \"<\/subsystem>\";\n\n        List<ModelNode> operations = parse(subsystemXml);\n        Assert.assertEquals(3, operations.size());\n\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ModelDescriptionConstants.ADD, addSubsystem.get(ModelDescriptionConstants.OP).asString());\n        assertOSGiSubsystemAddress(addSubsystem.get(ModelDescriptionConstants.OP_ADDR));\n        Assert.assertEquals(\"eager\", addSubsystem.get(Constants.ACTIVATION).asString());\n\n        checkData(operations, 1, Constants.FRAMEWORK_PROPERTY, \"org.acme.myProperty\", Constants.VALUE, \"hi ho\");\n        checkData(operations, 2, Constants.FRAMEWORK_PROPERTY, \"org.acme.myProperty2\", Constants.VALUE, \"hi.ho\");\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testDescribeHandler() throws Exception {\n        KernelServices servicesA = installInController(new AdditionalInitialization() {\n            @Override\n            protected Type getType() {\n                return Type.MANAGEMENT;\n            }\n        }, SUBSYSTEM_XML_1);\n        ModelNode modelA = servicesA.readWholeModel();\n        ModelNode describeOp = new ModelNode();\n        describeOp.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.DESCRIBE);\n        describeOp.get(ModelDescriptionConstants.OP_ADDR).set(\n            PathAddress.pathAddress(\n                PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME)).toModelNode());\n        List<ModelNode> operations = checkResultAndGetContents(servicesA.executeOperation(describeOp)).asList();\n\n        KernelServices servicesB = installInController(new AdditionalInitialization() {\n            @Override\n            public Type getType() {\n                return Type.MANAGEMENT;\n            }\n        }, operations);\n        ModelNode modelB = servicesB.readWholeModel();\n\n        compare(modelA, modelB);\n    }","id":67858,"modified_method":"@Test\n    public void testDescribeHandler() throws Exception {\n        KernelServices servicesA = installInController(new AdditionalInitialization() {\n            @Override\n            protected Type getType() {\n                return Type.MANAGEMENT;\n            }\n        }, SUBSYSTEM_XML_1_1);\n        ModelNode modelA = servicesA.readWholeModel();\n        ModelNode describeOp = new ModelNode();\n        describeOp.get(ModelDescriptionConstants.OP).set(ModelDescriptionConstants.DESCRIBE);\n        describeOp.get(ModelDescriptionConstants.OP_ADDR).set(\n                PathAddress.pathAddress(PathElement.pathElement(ModelDescriptionConstants.SUBSYSTEM, OSGiExtension.SUBSYSTEM_NAME)).toModelNode());\n        List<ModelNode> operations = checkResultAndGetContents(servicesA.executeOperation(describeOp)).asList();\n\n        KernelServices servicesB = installInController(new AdditionalInitialization() {\n            @Override\n            public Type getType() {\n                return Type.MANAGEMENT;\n            }\n        }, operations);\n        ModelNode modelB = servicesB.readWholeModel();\n\n        compare(modelA, modelB);\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testParseSubsystemWithConfiguration() throws Exception {\n        String subsystemXml =\n            \"<subsystem xmlns='urn:jboss:domain:osgi:1.0' activation='lazy'>\" +\n            \"  <configuration pid='org.acme.MyPid'>\" +\n            \"    <property name='propname' value='propval'/>\" +\n            \"  <\/configuration>\" +\n            \"  <configuration pid='org.acme.MyOtherPid'>\" +\n            \"    <property name='prop.name' value='prop.val'/>\" +\n            \"  <\/configuration>\" +\n            \"<\/subsystem>\";\n\n        List<ModelNode> operations = parse(subsystemXml);\n        Assert.assertEquals(3, operations.size());\n\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ModelDescriptionConstants.ADD, addSubsystem.get(ModelDescriptionConstants.OP).asString());\n        assertOSGiSubsystemAddress(addSubsystem.get(ModelDescriptionConstants.OP_ADDR));\n        Assert.assertEquals(\"lazy\", addSubsystem.get(CommonAttributes.ACTIVATION).asString());\n\n        checkData(operations, 1, CommonAttributes.CONFIGURATION, \"org.acme.MyPid\",\n                CommonAttributes.ENTRIES, \"{\\\"propname\\\" => \\\"propval\\\"}\");\n        checkData(operations, 2, CommonAttributes.CONFIGURATION, \"org.acme.MyOtherPid\",\n                CommonAttributes.ENTRIES, \"{\\\"prop.name\\\" => \\\"prop.val\\\"}\");\n    }","id":67859,"modified_method":"@Test\n    public void testParseSubsystemWithConfiguration() throws Exception {\n        String subsystemXml =\n            \"<subsystem xmlns='urn:jboss:domain:osgi:1.1' activation='lazy'>\" +\n            \"  <configuration pid='org.acme.MyPid'>\" +\n            \"    <property name='propname' value='propval'/>\" +\n            \"  <\/configuration>\" +\n            \"  <configuration pid='org.acme.MyOtherPid'>\" +\n            \"    <property name='prop.name' value='prop.val'/>\" +\n            \"  <\/configuration>\" +\n            \"<\/subsystem>\";\n\n        List<ModelNode> operations = parse(subsystemXml);\n        Assert.assertEquals(3, operations.size());\n\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ModelDescriptionConstants.ADD, addSubsystem.get(ModelDescriptionConstants.OP).asString());\n        assertOSGiSubsystemAddress(addSubsystem.get(ModelDescriptionConstants.OP_ADDR));\n        Assert.assertEquals(\"lazy\", addSubsystem.get(Constants.ACTIVATION).asString());\n\n        checkData(operations, 1, Constants.CONFIGURATION, \"org.acme.MyPid\", Constants.ENTRIES, \"{\\\"propname\\\" => \\\"propval\\\"}\");\n        checkData(operations, 2, Constants.CONFIGURATION, \"org.acme.MyOtherPid\", Constants.ENTRIES, \"{\\\"prop.name\\\" => \\\"prop.val\\\"}\");\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        return SUBSYSTEM_XML_1;\n    }","id":67860,"modified_method":"@Override\n    protected String getSubsystemXml() throws IOException {\n        return SUBSYSTEM_XML_1_1;\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Test\n    public void testParseSubsystemWithCapabilities() throws Exception {\n        String subsystemXml =\n            \"<subsystem xmlns='urn:jboss:domain:osgi:1.0' activation='lazy'>\" +\n            \"  <capabilities>\" +\n            \"    <capability name='org.acme.module1'/>\" +\n            \"    <capability name='org.acme.module2' startlevel='1'/>\" +\n            \"  <\/capabilities>\" +\n            \"<\/subsystem>\";\n\n        List<ModelNode> operations = parse(subsystemXml);\n        Assert.assertEquals(3, operations.size());\n\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ModelDescriptionConstants.ADD, addSubsystem.get(ModelDescriptionConstants.OP).asString());\n        assertOSGiSubsystemAddress(addSubsystem.get(ModelDescriptionConstants.OP_ADDR));\n\n        checkData(operations, 1, CommonAttributes.CAPABILITY, \"org.acme.module1\",\n                CommonAttributes.STARTLEVEL, \"undefined\");\n        checkData(operations, 2, CommonAttributes.CAPABILITY, \"org.acme.module2\",\n                CommonAttributes.STARTLEVEL, \"1\");\n    }","id":67861,"modified_method":"@Test\n    public void testParseSubsystemWithCapabilities() throws Exception {\n        String subsystemXml =\n            \"<subsystem xmlns='urn:jboss:domain:osgi:1.1' activation='lazy'>\" +\n            \"  <capabilities>\" +\n            \"    <capability name='org.acme.module1'/>\" +\n            \"    <capability name='org.acme.module2' startlevel='1'/>\" +\n            \"  <\/capabilities>\" +\n            \"<\/subsystem>\";\n\n        List<ModelNode> operations = parse(subsystemXml);\n        Assert.assertEquals(3, operations.size());\n\n        ModelNode addSubsystem = operations.get(0);\n        Assert.assertEquals(ModelDescriptionConstants.ADD, addSubsystem.get(ModelDescriptionConstants.OP).asString());\n        assertOSGiSubsystemAddress(addSubsystem.get(ModelDescriptionConstants.OP_ADDR));\n\n        checkData(operations, 1, Constants.CAPABILITY, \"org.acme.module1\",  Constants.STARTLEVEL, \"undefined\");\n        checkData(operations, 2, Constants.CAPABILITY, \"org.acme.module2\", Constants.STARTLEVEL, \"1\");\n    }","commit_id":"7e5c21cc46719542dbe5ca81dd38c39af9436223","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected SimpleNode checkRightSyntax(String query) {\n    return checkSyntax(query, true);\n  }","id":67862,"modified_method":"protected SimpleNode checkRightSyntax(String query) {\n    SimpleNode result = checkSyntax(query, true);\n    return checkSyntax(result.toString(), true);\n  }","commit_id":"b1da4f13825a1e5662ea4cf89713523df4d8828d","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void toString(Map<Object, Object> params, StringBuilder builder){\n\n    builder.append(\"SELECT\");\n    if (projection != null) {\n      builder.append(\" \");\n      projection.toString(params, builder);\n    }\n    if (target != null) {\n      builder.append(\" FROM \");\n      target.toString(params, builder);\n    }\n\n    if (letClause != null) {\n      builder.append(\" \");\n      letClause.toString(params, builder);\n    }\n\n    if (whereClause != null) {\n      builder.append(\" WHERE \");\n      whereClause.toString(params, builder);\n    }\n\n    if (groupBy != null) {\n      builder.append(\" \");\n      groupBy.toString(params, builder);\n    }\n\n    if (unwind != null) {\n      builder.append(\" \");\n      unwind.toString(params, builder);\n    }\n\n    if (orderBy != null) {\n      builder.append(\" \");\n      orderBy.toString(params, builder);\n    }\n\n    if (skip != null) {\n      skip.toString(params, builder);\n    }\n\n    if (limit != null) {\n      limit.toString(params, builder);\n    }\n\n    if (Boolean.TRUE.equals(lockRecord)) {\n      builder.append(\" LOCK RECORD\");\n    }\n\n    if (fetchPlan != null) {\n      builder.append(\" \");\n      fetchPlan.toString(params, builder);\n    }\n\n    if (timeout != null) {\n      timeout.toString(params, builder);\n    }\n\n    if (Boolean.TRUE.equals(parallel)) {\n      builder.append(\" PARALLEL\");\n    }\n\n    if (Boolean.TRUE.equals(noCache)) {\n      builder.append(\" NOCACHE\");\n    }\n  }","id":67863,"modified_method":"public void toString(Map<Object, Object> params, StringBuilder builder){\n\n    builder.append(\"SELECT\");\n    if (projection != null) {\n      builder.append(\" \");\n      projection.toString(params, builder);\n    }\n    if (target != null) {\n      builder.append(\" FROM \");\n      target.toString(params, builder);\n    }\n\n    if (letClause != null) {\n      builder.append(\" \");\n      letClause.toString(params, builder);\n    }\n\n    if (whereClause != null) {\n      builder.append(\" WHERE \");\n      whereClause.toString(params, builder);\n    }\n\n    if (groupBy != null) {\n      builder.append(\" \");\n      groupBy.toString(params, builder);\n    }\n\n    if (orderBy != null) {\n      builder.append(\" \");\n      orderBy.toString(params, builder);\n    }\n\n    if (unwind != null) {\n      builder.append(\" \");\n      unwind.toString(params, builder);\n    }\n\n    if (skip != null) {\n      skip.toString(params, builder);\n    }\n\n    if (limit != null) {\n      limit.toString(params, builder);\n    }\n\n    if (Boolean.TRUE.equals(lockRecord)) {\n      builder.append(\" LOCK RECORD\");\n    }\n\n    if (fetchPlan != null) {\n      builder.append(\" \");\n      fetchPlan.toString(params, builder);\n    }\n\n    if (timeout != null) {\n      timeout.toString(params, builder);\n    }\n\n    if (Boolean.TRUE.equals(parallel)) {\n      builder.append(\" PARALLEL\");\n    }\n\n    if (Boolean.TRUE.equals(noCache)) {\n      builder.append(\" NOCACHE\");\n    }\n  }","commit_id":"fff57f236a3a31871142f5db3c4b13df96547240","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected SimpleNode checkSyntax(String query, boolean isCorrect) {\n    OrientSql osql = getParserFor(query);\n    try {\n      SimpleNode result = osql.parse();\n      if (!isCorrect) {\n        fail();\n      }\n      System.out.println(query);\n      System.out.println(\"->\");\n      System.out.println(result.toString());\n      System.out.println(\"............\");\n      return result;\n    } catch (Exception e) {\n      if (isCorrect) {\n        e.printStackTrace();\n        fail();\n      }\n    }\n    return null;\n  }","id":67864,"modified_method":"protected SimpleNode checkSyntax(String query, boolean isCorrect) {\n    OrientSql osql = getParserFor(query);\n    try {\n      SimpleNode result = osql.parse();\n      if (!isCorrect) {\n        fail();\n      }\n      System.out.println(query);\n      System.out.println(\"->\");\n      StringBuilder builer = new StringBuilder();\n      result.toString(null, builer);\n      System.out.println(builer.toString());\n      System.out.println(\"............\");\n      return result;\n    } catch (Exception e) {\n      if (isCorrect) {\n        e.printStackTrace();\n        fail();\n      }\n    }\n    return null;\n  }","commit_id":"fff57f236a3a31871142f5db3c4b13df96547240","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected SimpleNode checkRightSyntax(String query) {\n    return checkSyntax(query, true);\n  }","id":67865,"modified_method":"protected SimpleNode checkRightSyntax(String query) {\n    SimpleNode result = checkSyntax(query, true);\n    StringBuilder builder = new StringBuilder();\n    result.toString(null, builder);\n    return checkSyntax(builder.toString(), true);\n  }","commit_id":"fff57f236a3a31871142f5db3c4b13df96547240","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Convert fields from text to real value. Supports: String, RID, Boolean, Float, Integer and NULL.\r\n   * \r\n   * @param iValue\r\n   *          Value to convert.\r\n   * @return The value converted if recognized, otherwise VALUE_NOT_PARSED\r\n   */\r\n  public static Object parseValue(String iValue, final OCommandContext iContext) {\r\n    if (iValue == null)\r\n      return null;\r\n\r\n    iValue = iValue.trim();\r\n\r\n    Object fieldValue = VALUE_NOT_PARSED;\r\n\r\n    if (iValue.startsWith(\"'\") && iValue.endsWith(\"'\") || iValue.startsWith(\"\\\"\") && iValue.endsWith(\"\\\"\"))\r\n      // STRING\r\n      fieldValue = OIOUtils.getStringContent(iValue);\r\n    else if (iValue.charAt(0) == OStringSerializerHelper.LIST_BEGIN\r\n        && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.LIST_END) {\r\n      // COLLECTION/ARRAY\r\n      final List<String> items = OStringSerializerHelper.smartSplit(iValue.substring(1, iValue.length() - 1),\r\n          OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n      final List<Object> coll = new ArrayList<Object>();\r\n      for (String item : items) {\r\n        coll.add(parseValue(item, iContext));\r\n      }\r\n      fieldValue = coll;\r\n\r\n    } else if (iValue.charAt(0) == OStringSerializerHelper.MAP_BEGIN\r\n        && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.MAP_END) {\r\n      // MAP\r\n      final List<String> items = OStringSerializerHelper.smartSplit(iValue.substring(1, iValue.length() - 1),\r\n          OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n      final Map<Object, Object> map = new HashMap<Object, Object>();\r\n      for (String item : items) {\r\n        final List<String> parts = OStringSerializerHelper.smartSplit(item, OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\r\n        if (parts == null || parts.size() != 2)\r\n          throw new OCommandSQLParsingException(\"Map found but entries are not defined as <key>:<value>\");\r\n\r\n        map.put(parseValue(parts.get(0), iContext), parseValue(parts.get(1), iContext));\r\n      }\r\n\r\n      if (map.containsKey(ODocumentHelper.ATTRIBUTE_TYPE))\r\n        // IT'S A DOCUMENT\r\n        // TODO: IMPROVE THIS CASE AVOIDING DOUBLE PARSING\r\n        fieldValue = new ODocument().fromJSON(iValue);\r\n      else\r\n        fieldValue = map;\r\n\r\n    } else if (iValue.charAt(0) == OStringSerializerHelper.EMBEDDED_BEGIN\r\n        && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.EMBEDDED_END) {\r\n      // SUB-COMMAND\r\n      fieldValue = new OCommandSQL(iValue.substring(1, iValue.length() - 1));\r\n      ((OCommandSQL) fieldValue).getContext().setParent(iContext);\r\n\r\n    } else if (ORecordId.isA(iValue))\r\n      // RID\r\n      fieldValue = new ORecordId(iValue.trim());\r\n    else {\r\n\r\n      if (iValue.equalsIgnoreCase(\"null\"))\r\n        // NULL\r\n        fieldValue = null;\r\n      else if (iValue.equalsIgnoreCase(\"not null\"))\r\n        // NULL\r\n        fieldValue = NOT_NULL;\r\n      else if (iValue.equalsIgnoreCase(\"defined\"))\r\n        // NULL\r\n        fieldValue = DEFINED;\r\n      else if (iValue.equalsIgnoreCase(\"true\"))\r\n        // BOOLEAN, TRUE\r\n        fieldValue = Boolean.TRUE;\r\n      else if (iValue.equalsIgnoreCase(\"false\"))\r\n        // BOOLEAN, FALSE\r\n        fieldValue = Boolean.FALSE;\r\n      else if (iValue.startsWith(\"date(\")) {\r\n        final OSQLFunctionRuntime func = OSQLHelper.getFunction(null, iValue);\r\n        if (func != null) {\r\n          fieldValue = func.execute(null, null, null, iContext);\r\n        }\r\n      } else {\r\n        final Object v = parseStringNumber(iValue);\r\n        if (v != null)\r\n          fieldValue = v;\r\n      }\r\n    }\r\n\r\n    return fieldValue;\r\n  }","id":67866,"modified_method":"/**\r\n   * Convert fields from text to real value. Supports: String, RID, Boolean, Float, Integer and NULL.\r\n   * \r\n   * @param iValue\r\n   *          Value to convert.\r\n   * @return The value converted if recognized, otherwise VALUE_NOT_PARSED\r\n   */\r\n  public static Object parseValue(String iValue, final OCommandContext iContext) {\r\n    if (iValue == null)\r\n      return null;\r\n\r\n    iValue = iValue.trim();\r\n\r\n    Object fieldValue = VALUE_NOT_PARSED;\r\n\r\n    if (iValue.startsWith(\"'\") && iValue.endsWith(\"'\") || iValue.startsWith(\"\\\"\") && iValue.endsWith(\"\\\"\"))\r\n      // STRING\r\n      fieldValue = OIOUtils.getStringContent(iValue);\r\n    else if (iValue.charAt(0) == OStringSerializerHelper.LIST_BEGIN\r\n        && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.LIST_END) {\r\n      // COLLECTION/ARRAY\r\n      final List<String> items = OStringSerializerHelper.smartSplit(iValue.substring(1, iValue.length() - 1),\r\n          OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n      final List<Object> coll = new ArrayList<Object>();\r\n      for (String item : items) {\r\n        coll.add(parseValue(item, iContext));\r\n      }\r\n      fieldValue = coll;\r\n\r\n    } else if (iValue.charAt(0) == OStringSerializerHelper.MAP_BEGIN\r\n        && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.MAP_END) {\r\n      // MAP\r\n      final List<String> items = OStringSerializerHelper.smartSplit(iValue.substring(1, iValue.length() - 1),\r\n          OStringSerializerHelper.RECORD_SEPARATOR);\r\n\r\n      final Map<Object, Object> map = new HashMap<Object, Object>();\r\n      for (String item : items) {\r\n        final List<String> parts = OStringSerializerHelper.smartSplit(item, OStringSerializerHelper.ENTRY_SEPARATOR);\r\n\r\n        if (parts == null || parts.size() != 2)\r\n          throw new OCommandSQLParsingException(\"Map found but entries are not defined as <key>:<value>\");\r\n\r\n        Object key = OStringSerializerHelper.decode(parseValue(parts.get(0), iContext).toString());\r\n        Object value = parseValue(parts.get(1), iContext);\r\n        if(value instanceof String){\r\n          value = OStringSerializerHelper.decode(value.toString());\r\n        }\r\n        map.put(key, value);\r\n      }\r\n\r\n      if (map.containsKey(ODocumentHelper.ATTRIBUTE_TYPE))\r\n        // IT'S A DOCUMENT\r\n        // TODO: IMPROVE THIS CASE AVOIDING DOUBLE PARSING\r\n        fieldValue = new ODocument().fromJSON(iValue);\r\n      else\r\n        fieldValue = map;\r\n\r\n    } else if (iValue.charAt(0) == OStringSerializerHelper.EMBEDDED_BEGIN\r\n        && iValue.charAt(iValue.length() - 1) == OStringSerializerHelper.EMBEDDED_END) {\r\n      // SUB-COMMAND\r\n      fieldValue = new OCommandSQL(iValue.substring(1, iValue.length() - 1));\r\n      ((OCommandSQL) fieldValue).getContext().setParent(iContext);\r\n\r\n    } else if (ORecordId.isA(iValue))\r\n      // RID\r\n      fieldValue = new ORecordId(iValue.trim());\r\n    else {\r\n\r\n      if (iValue.equalsIgnoreCase(\"null\"))\r\n        // NULL\r\n        fieldValue = null;\r\n      else if (iValue.equalsIgnoreCase(\"not null\"))\r\n        // NULL\r\n        fieldValue = NOT_NULL;\r\n      else if (iValue.equalsIgnoreCase(\"defined\"))\r\n        // NULL\r\n        fieldValue = DEFINED;\r\n      else if (iValue.equalsIgnoreCase(\"true\"))\r\n        // BOOLEAN, TRUE\r\n        fieldValue = Boolean.TRUE;\r\n      else if (iValue.equalsIgnoreCase(\"false\"))\r\n        // BOOLEAN, FALSE\r\n        fieldValue = Boolean.FALSE;\r\n      else if (iValue.startsWith(\"date(\")) {\r\n        final OSQLFunctionRuntime func = OSQLHelper.getFunction(null, iValue);\r\n        if (func != null) {\r\n          fieldValue = func.execute(null, null, null, iContext);\r\n        }\r\n      } else {\r\n        final Object v = parseStringNumber(iValue);\r\n        if (v != null)\r\n          fieldValue = v;\r\n      }\r\n    }\r\n\r\n    return fieldValue;\r\n  }","commit_id":"3295eb48bfd07ff939497a0b6cde8a001dfb4ad2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected SimpleNode checkRightSyntax(String query) {\n    return checkSyntax(query, true);\n  }","id":67867,"modified_method":"protected SimpleNode checkRightSyntax(String query) {\n    SimpleNode result = checkSyntax(query, true);\n    return checkSyntax(result.toString(), true);\n  }","commit_id":"3295eb48bfd07ff939497a0b6cde8a001dfb4ad2","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Test\n    public void testLotsOfSamples() {\n        File baseOutputFile = this.createTempFile(\"testManySamples\",\".tmp\");\n        this.setOutputFileLocation(baseOutputFile);\n        String[] intervals = {\"1:1105290-1105295\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/pilot3.CEU+TSI.5loci.bam\"};\n        String cmd = buildRootCmd(b36KGReference, new ArrayList<String>(Arrays.asList(bams)), new ArrayList<String>(Arrays.asList(intervals)));\n\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0,new ArrayList<String>());\n\n        spec.addAuxFile(\"c9561b52344536d2b06ab97b0bb1a234\",baseOutputFile);\n\n        execute(\"testLotsOfSamples\",spec);\n    }","id":67868,"modified_method":"@Test\n    public void testLotsOfSamples() {\n        String[] intervals = {\"1:1105290-1105295\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/pilot3.CEU+TSI.5loci.bam\"};\n        String cmd = buildRootCmd(b36KGReference, new ArrayList<String>(Arrays.asList(bams)), new ArrayList<String>(Arrays.asList(intervals)));\n\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0,new ArrayList<String>());\n\n        File baseOutputFile = this.createTempFile(\"testManySamples\",\".tmp\");\n        \n        spec.setOutputFileLocation(baseOutputFile);\n        spec.addAuxFile(\"c9561b52344536d2b06ab97b0bb1a234\",baseOutputFile);\n\n        execute(\"testLotsOfSamples\",spec);\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testMapQ0Only() {\n        // our base file\n        File baseOutputFile = this.createTempFile(\"depthofcoveragemapq0\",\".tmp\");\n        this.setOutputFileLocation(baseOutputFile);\n\n        String[] intervals = {\"1:10,000,000-10,002,000\",\"1:10,003,000-10,004,000\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\"};\n\n        String cmd = buildRootCmd(b36KGReference,new ArrayList<String>(Arrays.asList(bams)), new ArrayList<String>(Arrays.asList(intervals))) + \" --maxMappingQuality 0\";\n\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0,new ArrayList<String>());\n\n        spec.addAuxFile(\"f39af6ad99520fd4fb27b409ab0344a0\",baseOutputFile);\n        spec.addAuxFile(\"6b15f5330414b6d4e2f6caea42139fa1\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"cc6640d82077991dde8a2b523935cdff\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"0fb627234599c258a3fee1b2703e164a\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_statistics\"));\n        spec.addAuxFile(\"3ad34680c216279c52c7fa0c9e078249\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_summary\"));\n        spec.addAuxFile(\"347b47ef73fbd4e277704ddbd7834f69\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_statistics\"));\n        spec.addAuxFile(\"65bc90b4839cb9f20e60aba4956f06a9\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_summary\"));\n\n        execute(\"testMapQ0Only\",spec);\n    }","id":67869,"modified_method":"@Test\n    public void testMapQ0Only() {\n        String[] intervals = {\"1:10,000,000-10,002,000\",\"1:10,003,000-10,004,000\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/NA12878.1kg.p2.chr1_10mb_11_mb.allTechs.bam\"};\n\n        String cmd = buildRootCmd(b36KGReference,new ArrayList<String>(Arrays.asList(bams)), new ArrayList<String>(Arrays.asList(intervals))) + \" --maxMappingQuality 0\";\n\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0,new ArrayList<String>());\n\n        // our base file\n        File baseOutputFile = this.createTempFile(\"depthofcoveragemapq0\",\".tmp\");\n\n        spec.setOutputFileLocation(baseOutputFile);\n        spec.addAuxFile(\"f39af6ad99520fd4fb27b409ab0344a0\",baseOutputFile);\n        spec.addAuxFile(\"6b15f5330414b6d4e2f6caea42139fa1\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"cc6640d82077991dde8a2b523935cdff\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"0fb627234599c258a3fee1b2703e164a\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_statistics\"));\n        spec.addAuxFile(\"3ad34680c216279c52c7fa0c9e078249\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_summary\"));\n        spec.addAuxFile(\"347b47ef73fbd4e277704ddbd7834f69\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_statistics\"));\n        spec.addAuxFile(\"65bc90b4839cb9f20e60aba4956f06a9\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_summary\"));\n\n        execute(\"testMapQ0Only\",spec);\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testNoCoverageDueToFiltering() {\n        File baseOutputFile = this.createTempFile(\"depthofcoveragenofiltering\",\".tmp\");\n        this.setOutputFileLocation(baseOutputFile);\n\n        String[] intervals = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/fhs_jhs_30_targts.interval_list\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/FHS_indexed_subset.bam\"};\n\n        String cmd = buildRootCmd(hg18Reference,new ArrayList<String>(Arrays.asList(bams)),new ArrayList<String>(Arrays.asList(intervals))) + \" -mmq 0 -mbq 5 --maxBaseQuality 4 -dels -baseCounts -pt readgroup -pt sample -pt library --outputFormat csv\";\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0, new ArrayList<String>());\n\n        spec.addAuxFile(\"6ccd7d8970ba98cb95fe41636a070c1c\",baseOutputFile);\n        spec.addAuxFile(\"0ee40f3e5091536c14e077b77557083a\",createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_interval_summary\"));\n\n        execute(\"testNoCoverageDueToFiltering\",spec);\n    }","id":67870,"modified_method":"@Test\n    public void testNoCoverageDueToFiltering() {\n        String[] intervals = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/fhs_jhs_30_targts.interval_list\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/FHS_indexed_subset.bam\"};\n\n        String cmd = buildRootCmd(hg18Reference,new ArrayList<String>(Arrays.asList(bams)),new ArrayList<String>(Arrays.asList(intervals))) + \" -mmq 0 -mbq 5 --maxBaseQuality 4 -dels -baseCounts -pt readgroup -pt sample -pt library --outputFormat csv\";\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0, new ArrayList<String>());\n\n        File baseOutputFile = this.createTempFile(\"depthofcoveragenofiltering\",\".tmp\");\n        spec.setOutputFileLocation(baseOutputFile);\n\n        spec.addAuxFile(\"6ccd7d8970ba98cb95fe41636a070c1c\",baseOutputFile);\n        spec.addAuxFile(\"0ee40f3e5091536c14e077b77557083a\",createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_interval_summary\"));\n\n        execute(\"testNoCoverageDueToFiltering\",spec);\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testBaseOutputNoFiltering() {\n        // our base file\n        File baseOutputFile = this.createTempFile(\"depthofcoveragenofiltering\",\".tmp\");\n        this.setOutputFileLocation(baseOutputFile);\n\n        String[] intervals = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/fhs_jhs_30_targts.interval_list\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/FHS_indexed_subset.bam\"};\n\n        String cmd = buildRootCmd(hg18Reference,new ArrayList<String>(Arrays.asList(bams)),new ArrayList<String>(Arrays.asList(intervals))) + \" -mmq 0 -mbq 0 -dels -baseCounts -pt readgroup -pt sample -pt library --outputFormat csv -ct 10 -ct 15 -ct 20 -ct 25\";\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0, new ArrayList<String>());\n\n        // now add the expected files that get generated\n        spec.addAuxFile(\"423571e4c05e7934322172654ac6dbb7\", baseOutputFile);\n        spec.addAuxFile(\"9df5e7e07efeb34926c94a724714c219\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"b9a7748e5aec4dc06daed893c901c00d\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"9cd395f47b329b9dd00ad024fcac9929\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_interval_statistics\"));\n        spec.addAuxFile(\"ca95d2508366d32bf91bf0b0009a023a\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_interval_summary\"));\n        spec.addAuxFile(\"f6dbd74d32a48abe71ce08d300bce983\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_statistics\"));\n        spec.addAuxFile(\"7962a7c09c43ff8b339fa52bce51bfca\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_summary\"));\n        spec.addAuxFile(\"b82846df660f0aac8429aec57c2a62d6\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"d32a8c425fadcc4c048bd8b48d0f61e5\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"7b9d0e93bf5b5313995be7010ef1f528\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_interval_statistics\"));\n        spec.addAuxFile(\"755463d88222c81b84f99615e7b4cfd6\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_interval_summary\"));\n        spec.addAuxFile(\"e70952f241eebb9b5448f2e7cb288131\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_statistics\"));\n        spec.addAuxFile(\"51e4c04dfcb4a20c552ca6f013977fa8\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_summary\"));\n        spec.addAuxFile(\"d53431022f7387fe9ac47814ab1fcd88\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"650ee3714da7fbad7832c9d4ad49eb51\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"df0ba76e0e6082c0d29fcfd68efc6b77\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_statistics\"));\n        spec.addAuxFile(\"a52395c883ce8f1a62444d214fe37e88\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_summary\"));\n        spec.addAuxFile(\"a50011571334f17e950ad3ed1149e350\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_statistics\"));\n        spec.addAuxFile(\"f12a5f97b69718333c4987e3beb98f06\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_summary\"));\n        \n        execute(\"testBaseOutputNoFiltering\",spec);\n    }","id":67871,"modified_method":"@Test\n    public void testBaseOutputNoFiltering() {\n        String[] intervals = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/fhs_jhs_30_targts.interval_list\"};\n        String[] bams = {\"/humgen/gsa-hpprojects/GATK/data/Validation_Data/FHS_indexed_subset.bam\"};\n\n        String cmd = buildRootCmd(hg18Reference,new ArrayList<String>(Arrays.asList(bams)),new ArrayList<String>(Arrays.asList(intervals))) + \" -mmq 0 -mbq 0 -dels -baseCounts -pt readgroup -pt sample -pt library --outputFormat csv -ct 10 -ct 15 -ct 20 -ct 25\";\n        WalkerTestSpec spec = new WalkerTestSpec(cmd,0, new ArrayList<String>());\n\n        // our base file\n        File baseOutputFile = this.createTempFile(\"depthofcoveragenofiltering\",\".tmp\");\n        spec.setOutputFileLocation(baseOutputFile);\n\n        // now add the expected files that get generated\n        spec.addAuxFile(\"423571e4c05e7934322172654ac6dbb7\", baseOutputFile);\n        spec.addAuxFile(\"9df5e7e07efeb34926c94a724714c219\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"b9a7748e5aec4dc06daed893c901c00d\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"9cd395f47b329b9dd00ad024fcac9929\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_interval_statistics\"));\n        spec.addAuxFile(\"ca95d2508366d32bf91bf0b0009a023a\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_interval_summary\"));\n        spec.addAuxFile(\"f6dbd74d32a48abe71ce08d300bce983\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_statistics\"));\n        spec.addAuxFile(\"7962a7c09c43ff8b339fa52bce51bfca\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".library_summary\"));\n        spec.addAuxFile(\"b82846df660f0aac8429aec57c2a62d6\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"d32a8c425fadcc4c048bd8b48d0f61e5\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"7b9d0e93bf5b5313995be7010ef1f528\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_interval_statistics\"));\n        spec.addAuxFile(\"755463d88222c81b84f99615e7b4cfd6\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_interval_summary\"));\n        spec.addAuxFile(\"e70952f241eebb9b5448f2e7cb288131\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_statistics\"));\n        spec.addAuxFile(\"51e4c04dfcb4a20c552ca6f013977fa8\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".read_group_summary\"));\n        spec.addAuxFile(\"d53431022f7387fe9ac47814ab1fcd88\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_counts\"));\n        spec.addAuxFile(\"650ee3714da7fbad7832c9d4ad49eb51\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_cumulative_coverage_proportions\"));\n        spec.addAuxFile(\"df0ba76e0e6082c0d29fcfd68efc6b77\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_statistics\"));\n        spec.addAuxFile(\"a52395c883ce8f1a62444d214fe37e88\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_interval_summary\"));\n        spec.addAuxFile(\"a50011571334f17e950ad3ed1149e350\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_statistics\"));\n        spec.addAuxFile(\"f12a5f97b69718333c4987e3beb98f06\", createTempFileFromBase(baseOutputFile.getAbsolutePath()+\".sample_summary\"));\n        \n        execute(\"testBaseOutputNoFiltering\",spec);\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n    public void testUnmappedReadInclusion() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T PrintReads\" +\n                        \" -I \" + validationDataLocation + \"MV1994.bam\" +\n                        \" -R \" + validationDataLocation + \"Escherichia_coli_K12_MG1655.fasta\" +\n                        \" -L unmapped\" +\n                        \" -U --index_output_bam_on_the_fly\",\n                        0, // two output files\n                        Collections.<String>emptyList());\n\n        // our base file\n        File baseOutputFile = createTempFile(\"testUnmappedReadInclusion\",\".bam\");\n        this.setOutputFileLocation(baseOutputFile);\n        spec.addAuxFile(\"fcd11cfa8474472c617d400623a30fcd\",createTempFileFromBase(baseOutputFile.getAbsolutePath()));\n        spec.addAuxFile(\"3d1f077727e6b68e20a2095d034e56d7\", createTempFileFromBase(baseOutputFile.getAbsolutePath().substring(0,baseOutputFile.getAbsolutePath().indexOf(\".bam\"))+\".bai\"));\n\n        executeTest(\"testUnmappedReadInclusion\",spec);\n    }","id":67872,"modified_method":"@Test\n    public void testUnmappedReadInclusion() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T PrintReads\" +\n                        \" -I \" + validationDataLocation + \"MV1994.bam\" +\n                        \" -R \" + validationDataLocation + \"Escherichia_coli_K12_MG1655.fasta\" +\n                        \" -L unmapped\" +\n                        \" -U --index_output_bam_on_the_fly\",\n                        0, // two output files\n                        Collections.<String>emptyList());\n\n        // our base file\n        File baseOutputFile = createTempFile(\"testUnmappedReadInclusion\",\".bam\");\n        spec.setOutputFileLocation(baseOutputFile);\n        spec.addAuxFile(\"fcd11cfa8474472c617d400623a30fcd\",createTempFileFromBase(baseOutputFile.getAbsolutePath()));\n        spec.addAuxFile(\"3d1f077727e6b68e20a2095d034e56d7\", createTempFileFromBase(baseOutputFile.getAbsolutePath().substring(0,baseOutputFile.getAbsolutePath().indexOf(\".bam\"))+\".bai\"));\n\n        executeTest(\"testUnmappedReadInclusion\",spec);\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test(enabled = true)\n    public void testUnmappedReadExclusion() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T PrintReads\" +\n                        \" -I \" + validationDataLocation + \"MV1994.bam\" +\n                        \" -R \" + validationDataLocation + \"Escherichia_coli_K12_MG1655.fasta\" +\n                        \" -XL unmapped\" +\n                        \" -U --index_output_bam_on_the_fly\",\n                        0, // two output files\n                        Collections.<String>emptyList());\n\n        // our base file\n        File baseOutputFile = createTempFile(\"testUnmappedReadExclusion\",\".bam\");\n        this.setOutputFileLocation(baseOutputFile);\n        spec.addAuxFile(\"3153593c9f9ff80a8551fff5655e65ec\",createTempFileFromBase(baseOutputFile.getAbsolutePath()));\n        spec.addAuxFile(\"7fc574ac72211623e4df74d9f75a4e48\", createTempFileFromBase(baseOutputFile.getAbsolutePath().substring(0,baseOutputFile.getAbsolutePath().indexOf(\".bam\"))+\".bai\"));\n\n        executeTest(\"testUnmappedReadExclusion\",spec);\n    }","id":67873,"modified_method":"@Test(enabled = true)\n    public void testUnmappedReadExclusion() {\n        WalkerTest.WalkerTestSpec spec = new WalkerTest.WalkerTestSpec(\n                \"-T PrintReads\" +\n                        \" -I \" + validationDataLocation + \"MV1994.bam\" +\n                        \" -R \" + validationDataLocation + \"Escherichia_coli_K12_MG1655.fasta\" +\n                        \" -XL unmapped\" +\n                        \" -U --index_output_bam_on_the_fly\",\n                        0, // two output files\n                        Collections.<String>emptyList());\n\n        // our base file\n        File baseOutputFile = createTempFile(\"testUnmappedReadExclusion\",\".bam\");\n        spec.setOutputFileLocation(baseOutputFile);\n        spec.addAuxFile(\"3153593c9f9ff80a8551fff5655e65ec\",createTempFileFromBase(baseOutputFile.getAbsolutePath()));\n        spec.addAuxFile(\"7fc574ac72211623e4df74d9f75a4e48\", createTempFileFromBase(baseOutputFile.getAbsolutePath().substring(0,baseOutputFile.getAbsolutePath().indexOf(\".bam\"))+\".bai\"));\n\n        executeTest(\"testUnmappedReadExclusion\",spec);\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"protected Pair<List<File>, List<String>> executeTest(final String name, WalkerTestSpec spec) {\n        ensureMd5DbDirectory(); // ensure the md5 directory exists\n\n        List<File> tmpFiles = new ArrayList<File>();\n        for (int i = 0; i < spec.nOutputFiles; i++) {\n            String ext = spec.exts == null ? \".tmp\" : \".\" + spec.exts.get(i);\n            File fl = createTempFile(String.format(\"walktest.tmp_param.%d\", i), ext);\n            tmpFiles.add(fl);\n        }\n\n        final String args = String.format(spec.args, tmpFiles.toArray());\n        System.out.println(Utils.dupString('-', 80));\n\n        if ( spec.expectsException() ) {\n            // this branch handles the case were we are testing that a walker will fail as expected\n            return executeTest(name, null, tmpFiles, args, spec.getExpectedException());\n        } else {\n            List<String> md5s = new LinkedList<String>();\n            md5s.addAll(spec.md5s);\n\n            // check to see if they included any auxillary files, if so add them to the list\n            for (String md5 : spec.auxillaryFiles.keySet()) {\n                md5s.add(md5);\n                tmpFiles.add(spec.auxillaryFiles.get(md5));\n            }\n            return executeTest(name, md5s, tmpFiles, args, null);\n        }\n    }","id":67874,"modified_method":"protected Pair<List<File>, List<String>> executeTest(final String name, WalkerTestSpec spec) {\n        ensureMd5DbDirectory(); // ensure the md5 directory exists\n\n        List<File> tmpFiles = new ArrayList<File>();\n        for (int i = 0; i < spec.nOutputFiles; i++) {\n            String ext = spec.exts == null ? \".tmp\" : \".\" + spec.exts.get(i);\n            File fl = createTempFile(String.format(\"walktest.tmp_param.%d\", i), ext);\n            tmpFiles.add(fl);\n        }\n\n        final String args = String.format(spec.args, tmpFiles.toArray());\n        System.out.println(Utils.dupString('-', 80));\n\n        if ( spec.expectsException() ) {\n            // this branch handles the case were we are testing that a walker will fail as expected\n            return executeTest(name, spec.getOutputFileLocation(), null, tmpFiles, args, spec.getExpectedException());\n        } else {\n            List<String> md5s = new LinkedList<String>();\n            md5s.addAll(spec.md5s);\n\n            // check to see if they included any auxillary files, if so add them to the list\n            for (String md5 : spec.auxillaryFiles.keySet()) {\n                md5s.add(md5);\n                tmpFiles.add(spec.auxillaryFiles.get(md5));\n            }\n            return executeTest(name, spec.getOutputFileLocation(), md5s, tmpFiles, args, null);\n        }\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"/**\n     * execute the test, given the following:\n     * @param name     the name of the test\n     * @param md5s     the list of md5s\n     * @param tmpFiles the temp file corresponding to the md5 list\n     * @param args     the argument list\n     * @param expectedException the expected exception or null\n     * @return a pair of file and string lists\n     */\n    private Pair<List<File>, List<String>> executeTest(String name, List<String> md5s, List<File> tmpFiles, String args, Class expectedException) {\n        if (outputFileLocation != null)\n            args += \" -o \" + this.outputFileLocation.getAbsolutePath();\n        executeTest(name, args, expectedException);\n\n        if ( expectedException != null ) {\n            return null;\n        } else {\n            // we need to check MD5s\n            return new Pair<List<File>, List<String>>(tmpFiles, assertMatchingMD5s(name, tmpFiles, md5s));\n        }\n    }","id":67875,"modified_method":"/**\n     * execute the test, given the following:\n     * @param name     the name of the test\n     * @param md5s     the list of md5s\n     * @param tmpFiles the temp file corresponding to the md5 list\n     * @param args     the argument list\n     * @param expectedException the expected exception or null\n     * @return a pair of file and string lists\n     */\n    private Pair<List<File>, List<String>> executeTest(String name, File outputFileLocation, List<String> md5s, List<File> tmpFiles, String args, Class expectedException) {\n        if (outputFileLocation != null)\n            args += \" -o \" + outputFileLocation.getAbsolutePath();\n        executeTest(name, args, expectedException);\n\n        if ( expectedException != null ) {\n            return null;\n        } else {\n            // we need to check MD5s\n            return new Pair<List<File>, List<String>>(tmpFiles, assertMatchingMD5s(name, tmpFiles, md5s));\n        }\n    }","commit_id":"96241c6637779cf843ce99ad1f02fb1c22e6dea8","url":"https://github.com/broadgsa/gatk"},{"original_method":"@Test\n  public void doNotOverrideVersionFromPluginManagementSection() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overridePluginManagementSection.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n    assertThat(mavenPlugin, not(nullValue()));\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getVersion(), is(\"0.9\"));\n\n    Plugin pluginManagement = MavenUtils.getPlugin(pom.getPluginManagement().getPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(pluginManagement, nullValue());\n  }","id":67876,"modified_method":"@Test\n  public void doNotOverrideVersionFromPluginManagementSection() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overridePluginManagementSection.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n    assertThat(mavenPlugin).isNotNull();\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getVersion()).isEqualTo(\"0.9\");\n\n    Plugin pluginManagement = MavenUtils.getPlugin(pom.getPluginManagement().getPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(pluginManagement).isNull();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void overrideVersion() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overrideVersion.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getPlugin().getVersion(), is(\"1.0\"));\n    assertThat(plugin.getParameter(\"foo\"), is(\"bar\"));\n  }","id":67877,"modified_method":"@Test\n  public void overrideVersion() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overrideVersion.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getPlugin().getVersion()).isEqualTo(\"1.0\");\n    assertThat(plugin.getParameter(\"foo\")).isEqualTo(\"bar\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldOverriddeParameter() {\n    fakePlugin.setParameter(\"exclude\", \"abc\");\n    fakePlugin.setParameter(\"exclude\", \"overridden\");\n    assertThat(fakePlugin.toString(), fakePlugin.getParameter(\"exclude\"), is(\"overridden\"));\n    assertThat(fakePlugin.toString(), fakePlugin.getParameters(\"exclude\"), is(new String[]{\"overridden\"}));\n  }","id":67878,"modified_method":"@Test\n  public void shouldOverriddeParameter() {\n    fakePlugin.setParameter(\"exclude\", \"abc\");\n    fakePlugin.setParameter(\"exclude\", \"overridden\");\n    assertThat(fakePlugin.getParameter(\"exclude\")).isEqualTo(\"overridden\");\n    assertThat(fakePlugin.getParameters(\"exclude\")).containsOnly(\"overridden\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldOverrideNestedParameter() {\n    fakePlugin.setParameter(\"excludes/exclude\", \"abc\");\n    fakePlugin.setParameter(\"excludes/exclude\", \"overridden\");\n    assertThat(fakePlugin.toString(), fakePlugin.getParameter(\"excludes/exclude\"), is(\"overridden\"));\n    assertThat(fakePlugin.toString(), fakePlugin.getParameters(\"excludes/exclude\"), is(new String[]{\"overridden\"}));\n  }","id":67879,"modified_method":"@Test\n  public void shouldOverrideNestedParameter() {\n    fakePlugin.setParameter(\"excludes/exclude\", \"abc\");\n    fakePlugin.setParameter(\"excludes/exclude\", \"overridden\");\n    assertThat(fakePlugin.getParameter(\"excludes/exclude\")).isEqualTo(\"overridden\");\n    assertThat(fakePlugin.getParameters(\"excludes/exclude\")).containsOnly(\"overridden\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void addIndexedParameters() {\n    fakePlugin.addParameter(\"items/item[0]/entry\", \"value1\");\n    fakePlugin.addParameter(\"items/item[1]/entry\", \"value2\");\n\n    assertThat(fakePlugin.getParameter(\"items/item[0]/entry\"), is(\"value1\"));\n    assertThat(fakePlugin.getParameters(\"items/item[0]/entry\"), is(new String[]{\"value1\"}));\n\n    assertThat(fakePlugin.getParameter(\"items/item[1]/entry\"), is(\"value2\"));\n    assertThat(fakePlugin.getParameters(\"items/item[1]/entry\"), is(new String[]{\"value2\"}));\n\n    //ensure that indexes aren't serialized to real configuration\n    assertThat(fakePlugin.getPlugin().getConfiguration().toString(), not(containsString(\"item[0]\")));\n    assertThat(fakePlugin.getPlugin().getConfiguration().toString(), not(containsString(\"item[1]\")));\n  }","id":67880,"modified_method":"@Test\n  public void addIndexedParameters() {\n    fakePlugin.addParameter(\"items/item[0]/entry\", \"value1\");\n    fakePlugin.addParameter(\"items/item[1]/entry\", \"value2\");\n\n    assertThat(fakePlugin.getParameter(\"items/item[0]/entry\")).isEqualTo(\"value1\");\n    assertThat(fakePlugin.getParameters(\"items/item[0]/entry\")).containsOnly(\"value1\");\n\n    assertThat(fakePlugin.getParameter(\"items/item[1]/entry\")).isEqualTo(\"value2\");\n    assertThat(fakePlugin.getParameters(\"items/item[1]/entry\")).containsOnly(\"value2\");\n\n    //ensure that indexes aren't serialized to real configuration\n    assertThat(fakePlugin.getPlugin().getConfiguration().toString()).doesNotContain(\"item[0]\");\n    assertThat(fakePlugin.getPlugin().getConfiguration().toString()).doesNotContain(\"item[1]\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void removeIndexedParameter(){\n    fakePlugin.addParameter(\"items/item[0]/entry\", \"value1\");\n    fakePlugin.addParameter(\"items/item[1]/entry\", \"value2\");\n\n    fakePlugin.removeParameter(\"items/item[1]\");\n    fakePlugin.removeParameter(\"items/notExists\");\n\n    assertThat(fakePlugin.getParameter(\"items/item[0]/entry\"), notNullValue());\n    assertThat(fakePlugin.getParameter(\"items/item[1]/entry\"), nullValue());\n    assertThat(fakePlugin.getParameter(\"items/notExists\"), nullValue());\n  }","id":67881,"modified_method":"@Test\n  public void removeIndexedParameter() {\n    fakePlugin.addParameter(\"items/item[0]/entry\", \"value1\");\n    fakePlugin.addParameter(\"items/item[1]/entry\", \"value2\");\n\n    fakePlugin.removeParameter(\"items/item[1]\");\n    fakePlugin.removeParameter(\"items/notExists\");\n\n    assertThat(fakePlugin.getParameter(\"items/item[0]/entry\")).isNotNull();\n    assertThat(fakePlugin.getParameter(\"items/item[1]/entry\")).isNull();\n    assertThat(fakePlugin.getParameter(\"items/notExists\")).isNull();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void keepPluginDependencies() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"keepPluginDependencies.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n    assertThat(mavenPlugin, not(nullValue()));\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getVersion(), is(\"0.9\"));\n    assertThat(plugin.getDependencies().size(), is(1));\n  }","id":67882,"modified_method":"@Test\n  public void keepPluginDependencies() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"keepPluginDependencies.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n    assertThat(mavenPlugin).isNotNull();\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getVersion()).isEqualTo(\"0.9\");\n    assertThat(plugin.getDependencies().size()).isEqualTo(1);\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldRemoveNestedParameter() {\n    fakePlugin.setParameter(\"abc/def\", \"1\");\n    assertThat(fakePlugin.getParameter(\"abc/def\"), is(not(nullValue())));\n\n    fakePlugin.removeParameter(\"abc/def\");\n\n    assertThat(fakePlugin.getParameter(\"abc/def\"), is(nullValue()));\n  }","id":67883,"modified_method":"@Test\n  public void shouldRemoveNestedParameter() {\n    fakePlugin.setParameter(\"abc/def\", \"1\");\n    assertThat(fakePlugin.getParameter(\"abc/def\")).isNotNull();\n\n    fakePlugin.removeParameter(\"abc/def\");\n\n    assertThat(fakePlugin.getParameter(\"abc/def\")).isNull();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void overridePluginManagementSection() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overridePluginManagementSection.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n    assertThat(mavenPlugin, not(nullValue()));\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getVersion(), is(\"1.0\"));\n\n    Plugin pluginManagement = MavenUtils.getPlugin(pom.getPluginManagement().getPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(pluginManagement, nullValue());\n  }","id":67884,"modified_method":"@Test\n  public void overridePluginManagementSection() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overridePluginManagementSection.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n    assertThat(mavenPlugin).isNotNull();\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getVersion()).isEqualTo(\"1.0\");\n\n    Plugin pluginManagement = MavenUtils.getPlugin(pom.getPluginManagement().getPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(pluginManagement).isNull();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldAddNestedParameter() {\n    fakePlugin.addParameter(\"excludes/exclude\", \"abc\");\n    assertThat(fakePlugin.toString(), fakePlugin.getParameter(\"excludes/exclude\"), is(\"abc\"));\n    assertThat(fakePlugin.toString(), fakePlugin.getParameters(\"excludes/exclude\"), is(new String[]{\"abc\"}));\n  }","id":67885,"modified_method":"@Test\n  public void shouldAddNestedParameter() {\n    fakePlugin.addParameter(\"excludes/exclude\", \"abc\");\n    assertThat(fakePlugin.getParameter(\"excludes/exclude\")).isEqualTo(\"abc\");\n    assertThat(fakePlugin.getParameters(\"excludes/exclude\")).containsOnly(\"abc\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void overrideVersionFromPluginManagement() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overrideVersionFromPluginManagement.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getPlugin().getVersion(), is(\"1.0\"));\n    assertThat(plugin.getParameter(\"foo\"), is(\"bar\"));\n  }","id":67886,"modified_method":"@Test\n  public void overrideVersionFromPluginManagement() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"overrideVersionFromPluginManagement.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getPlugin().getVersion()).isEqualTo(\"1.0\");\n    assertThat(plugin.getParameter(\"foo\")).isEqualTo(\"bar\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldAddManyValuesToTheSameParameter() {\n    fakePlugin.addParameter(\"excludes/exclude\", \"abc\");\n    fakePlugin.addParameter(\"excludes/exclude\", \"def\");\n    assertThat(fakePlugin.toString(), fakePlugin.getParameters(\"excludes/exclude\"), is(new String[]{\"abc\", \"def\"}));\n  }","id":67887,"modified_method":"@Test\n  public void shouldAddManyValuesToTheSameParameter() {\n    fakePlugin.addParameter(\"excludes/exclude\", \"abc\");\n    fakePlugin.addParameter(\"excludes/exclude\", \"def\");\n    assertThat(fakePlugin.getParameters(\"excludes/exclude\")).containsOnly(\"abc\", \"def\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldWriteAndReadSimpleConfiguration() {\n    fakePlugin.setParameter(\"abc\", \"test\");\n    assertThat(fakePlugin.getParameter(\"abc\"), is(\"test\"));\n  }","id":67888,"modified_method":"@Test\n  public void shouldWriteAndReadSimpleConfiguration() {\n    fakePlugin.setParameter(\"abc\", \"test\");\n    assertThat(fakePlugin.getParameter(\"abc\")).isEqualTo(\"test\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void removeParameters() {\n    fakePlugin\n        .setParameter(\"foo\", \"bar\")\n        .setParameter(\"hello\", \"world\")\n        .removeParameters();\n\n    assertThat(fakePlugin.getParameter(\"foo\"), nullValue());\n    assertThat(fakePlugin.getParameter(\"hello\"), nullValue());\n    assertThat(fakePlugin.hasConfiguration(), is(false));\n  }","id":67889,"modified_method":"@Test\n  public void removeParameters() {\n    fakePlugin\n      .setParameter(\"foo\", \"bar\")\n      .setParameter(\"hello\", \"world\")\n      .removeParameters();\n\n    assertThat(fakePlugin.getParameter(\"foo\")).isNull();\n    assertThat(fakePlugin.getParameter(\"hello\")).isNull();\n    assertThat(fakePlugin.hasConfiguration()).isFalse();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void registerNewPlugin() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"registerNewPlugin.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    assertThat(mavenPlugin, not(nullValue()));\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getVersion(), is(\"1.0\"));\n  }","id":67890,"modified_method":"@Test\n  public void registerNewPlugin() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"registerNewPlugin.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    assertThat(mavenPlugin).isNotNull();\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getVersion()).isEqualTo(\"1.0\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void defaultParameterIndexIsZero() {\n    fakePlugin.addParameter(\"items/item/entry\", \"value1\");\n    fakePlugin.addParameter(\"items/item/entry\", \"value2\");\n\n    assertThat(fakePlugin.toString(), fakePlugin.getParameters(\"items/item/entry\"), is(new String[]{\"value1\", \"value2\"}));\n    assertThat(fakePlugin.toString(), fakePlugin.getParameters(\"items/item[0]/entry\"), is(new String[]{\"value1\", \"value2\"}));\n  }","id":67891,"modified_method":"@Test\n  public void defaultParameterIndexIsZero() {\n    fakePlugin.addParameter(\"items/item/entry\", \"value1\");\n    fakePlugin.addParameter(\"items/item/entry\", \"value2\");\n\n    assertThat(fakePlugin.getParameters(\"items/item/entry\")).containsOnly(\"value1\", \"value2\");\n    assertThat(fakePlugin.getParameters(\"items/item[0]/entry\")).containsOnly(\"value1\", \"value2\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void keepPluginManagementDependencies() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"keepPluginManagementDependencies.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n    assertThat(mavenPlugin, not(nullValue()));\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getVersion(), is(\"0.9\"));\n    assertThat(plugin.getDependencies().size(), is(1));\n  }","id":67892,"modified_method":"@Test\n  public void keepPluginManagementDependencies() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"keepPluginManagementDependencies.xml\");\n    MavenPlugin mavenPlugin = MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n    assertThat(mavenPlugin).isNotNull();\n\n    Plugin plugin = MavenUtils.getPlugin(pom.getBuildPlugins(), \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getVersion()).isEqualTo(\"0.9\");\n    assertThat(plugin.getDependencies().size()).isEqualTo(1);\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldReturnNullWhenChildNotFound() {\n    assertThat(fakePlugin.getParameter(\"abc/def/ghi\"), is(nullValue()));\n  }","id":67893,"modified_method":"@Test\n  public void shouldReturnNullWhenChildNotFound() {\n    assertThat(fakePlugin.getParameter(\"abc/def/ghi\")).isNull();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void mergeSettings() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"mergeSettings.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getPlugin().getVersion(), is(\"0.9\"));\n    assertThat(plugin.getParameter(\"foo\"), is(\"bar\"));\n  }","id":67894,"modified_method":"@Test\n  public void mergeSettings() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"mergeSettings.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", false);\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getPlugin().getVersion()).isEqualTo(\"0.9\");\n    assertThat(plugin.getParameter(\"foo\")).isEqualTo(\"bar\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void getConfigurationFromReport() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"getConfigurationFromReport.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    assertThat(pom.getBuildPlugins().size(), is(1));\n    assertThat(pom.getReportPlugins().size(), is(0));\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin, not(nullValue()));\n    assertThat(plugin.getPlugin().getVersion(), is(\"1.0\"));\n    assertThat(plugin.getParameter(\"foo\"), is(\"bar\"));\n  }","id":67895,"modified_method":"@Test\n  public void getConfigurationFromReport() {\n    MavenProject pom = MavenTestUtils.loadPom(getClass(), \"getConfigurationFromReport.xml\");\n    MavenPlugin.registerPlugin(pom, \"mygroup\", \"my.artifact\", \"1.0\", true);\n\n    assertThat(pom.getBuildPlugins().size()).isEqualTo(1);\n    assertThat(pom.getReportPlugins().size()).isEqualTo(0);\n\n    MavenPlugin plugin = MavenPlugin.getPlugin(pom, \"mygroup\", \"my.artifact\");\n    assertThat(plugin).isNotNull();\n    assertThat(plugin.getPlugin().getVersion()).isEqualTo(\"1.0\");\n    assertThat(plugin.getParameter(\"foo\")).isEqualTo(\"bar\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldRemoveNestedParameterButLeaveTheParent() {\n    fakePlugin.setParameter(\"abc/x\", \"1\");\n    fakePlugin.setParameter(\"abc/y\", \"2\");\n\n    fakePlugin.removeParameter(\"abc/x\");\n\n    assertThat(fakePlugin.getParameter(\"abc/y\"), is(not(nullValue())));\n  }","id":67896,"modified_method":"@Test\n  public void shouldRemoveNestedParameterButLeaveTheParent() {\n    fakePlugin.setParameter(\"abc/x\", \"1\");\n    fakePlugin.setParameter(\"abc/y\", \"2\");\n\n    fakePlugin.removeParameter(\"abc/x\");\n\n    assertThat(fakePlugin.getParameter(\"abc/y\")).isNotNull();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldRemoveParameter() {\n    fakePlugin.setParameter(\"abc\", \"1\");\n    assertThat(fakePlugin.getParameter(\"abc\"), is(not(nullValue())));\n\n    fakePlugin.removeParameter(\"abc\");\n    assertThat(fakePlugin.getParameter(\"abc\"), is(nullValue()));\n  }","id":67897,"modified_method":"@Test\n  public void shouldRemoveParameter() {\n    fakePlugin.setParameter(\"abc\", \"1\");\n    assertThat(fakePlugin.getParameter(\"abc\")).isNotNull();\n\n    fakePlugin.removeParameter(\"abc\");\n    assertThat(fakePlugin.getParameter(\"abc\")).isNull();\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldWriteAndReadComplexConfiguration() {\n    fakePlugin.setParameter(\"abc/def/ghi\", \"test\");\n    assertThat(fakePlugin.getParameter(\"abc/def/ghi\"), is(\"test\"));\n  }","id":67898,"modified_method":"@Test\n  public void shouldWriteAndReadComplexConfiguration() {\n    fakePlugin.setParameter(\"abc/def/ghi\", \"test\");\n    assertThat(fakePlugin.getParameter(\"abc/def/ghi\")).isEqualTo(\"test\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldSetParameter() {\n    fakePlugin.addParameter(\"exclude\", \"abc\");\n    assertThat(fakePlugin.toString(), fakePlugin.getParameter(\"exclude\"), is(\"abc\"));\n    assertThat(fakePlugin.toString(), fakePlugin.getParameters(\"exclude\"), is(new String[]{\"abc\"}));\n  }","id":67899,"modified_method":"@Test\n  public void shouldSetParameter() {\n    fakePlugin.addParameter(\"exclude\", \"abc\");\n    assertThat(fakePlugin.getParameter(\"exclude\")).isEqualTo(\"abc\");\n    assertThat(fakePlugin.getParameters(\"exclude\")).containsOnly(\"abc\");\n  }","commit_id":"e0d52b1c0820be0d136f7748581f0bae122414ca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param id the id to set\n   */\n  public void setId(Long id) {\n    this.id = id;\n  }","id":67900,"modified_method":"/**\n   * @param id the id to set\n   */\n  public ActiveDashboardDto setId(Long id) {\n    this.id = id;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public int hashCode() {\n    return id != null ? id.hashCode() : 0;\n  }","id":67901,"modified_method":"@Override\n  public int hashCode() {\n    return Objects.hashCode(id);\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param dashboardId the dashboardId to set\n   */\n  public void setDashboardId(Long dashboardId) {\n    this.dashboardId = dashboardId;\n  }","id":67902,"modified_method":"/**\n   * @param dashboardId the dashboardId to set\n   */\n  public ActiveDashboardDto setDashboardId(Long dashboardId) {\n    this.dashboardId = dashboardId;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param orderIndex the orderIndex to set\n   */\n  public void setOrderIndex(Integer orderIndex) {\n    this.orderIndex = orderIndex;\n  }","id":67903,"modified_method":"/**\n   * @param orderIndex the orderIndex to set\n   */\n  public ActiveDashboardDto setOrderIndex(Integer orderIndex) {\n    this.orderIndex = orderIndex;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param userId the userId to set\n   */\n  public void setUserId(Long userId) {\n    this.userId = userId;\n  }","id":67904,"modified_method":"/**\n   * @param userId the userId to set\n   */\n  public ActiveDashboardDto setUserId(Long userId) {\n    this.userId = userId;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public List<Class<? extends Extension>> getExtensions() {\n    List extensions = Lists.newLinkedList();\n\n    extensions.add(DefaultResourceTypes.class);\n    extensions.add(UserManagedMetrics.class);\n    extensions.add(ProjectFileSystemLogger.class);\n\n    // maven\n    extensions.add(MavenInitializer.class);\n\n    // languages\n    extensions.add(Java.class);\n\n    // pages\n    extensions.add(TestsViewerDefinition.class);\n    extensions.add(Lcom4Viewer.class);\n\n    // filters\n    extensions.add(ProjectFilter.class);\n    extensions.add(TreeMapFilter.class);\n    extensions.add(MyFavouritesFilter.class);\n\n    // widgets\n    extensions.add(AlertsWidget.class);\n    extensions.add(CoverageWidget.class);\n    extensions.add(ItCoverageWidget.class);\n    extensions.add(CommentsDuplicationsWidget.class);\n    extensions.add(DescriptionWidget.class);\n    extensions.add(ComplexityWidget.class);\n    extensions.add(RulesWidget.class);\n    extensions.add(SizeWidget.class);\n    extensions.add(EventsWidget.class);\n    extensions.add(CustomMeasuresWidget.class);\n    extensions.add(TimelineWidget.class);\n    extensions.add(TimeMachineWidget.class);\n    extensions.add(HotspotMetricWidget.class);\n    extensions.add(HotspotMostViolatedResourcesWidget.class);\n    extensions.add(HotspotMostViolatedRulesWidget.class);\n    extensions.add(MyReviewsWidget.class);\n    extensions.add(ProjectReviewsWidget.class);\n    extensions.add(FalsePositiveReviewsWidget.class);\n    extensions.add(ReviewsPerDeveloperWidget.class);\n    extensions.add(PlannedReviewsWidget.class);\n    extensions.add(UnplannedReviewsWidget.class);\n    extensions.add(ActionPlansWidget.class);\n    extensions.add(ReviewsMetricsWidget.class);\n    extensions.add(TreemapWidget.class);\n    extensions.add(FilterWidget.class);\n\n    // dashboards\n    extensions.add(DefaultDashboard.class);\n    extensions.add(HotspotsDashboard.class);\n    extensions.add(ReviewsDashboard.class);\n    extensions.add(TimeMachineDashboard.class);\n    extensions.add(ProjectsDashboard.class);\n    extensions.add(TreemapDashboard.class);\n\n    // chart\n    extensions.add(XradarChart.class);\n    extensions.add(DistributionBarChart.class);\n    extensions.add(DistributionAreaChart.class);\n\n    // colorizers\n    extensions.add(JavaColorizerFormat.class);\n\n    // batch\n    extensions.add(ProfileSensor.class);\n    extensions.add(ProfileEventsSensor.class);\n    extensions.add(ProjectLinksSensor.class);\n    extensions.add(UnitTestDecorator.class);\n    extensions.add(VersionEventsSensor.class);\n    extensions.add(CheckAlertThresholds.class);\n    extensions.add(GenerateAlertEvents.class);\n    extensions.add(ViolationsDecorator.class);\n    extensions.add(WeightedViolationsDecorator.class);\n    extensions.add(ViolationsDensityDecorator.class);\n    extensions.add(LineCoverageDecorator.class);\n    extensions.add(CoverageDecorator.class);\n    extensions.add(BranchCoverageDecorator.class);\n    extensions.add(ItLineCoverageDecorator.class);\n    extensions.add(ItCoverageDecorator.class);\n    extensions.add(ItBranchCoverageDecorator.class);\n    extensions.add(ApplyProjectRolesDecorator.class);\n    extensions.add(ExcludedResourceFilter.class);\n    extensions.add(CommentDensityDecorator.class);\n    extensions.add(NoSonarFilter.class);\n    extensions.add(DirectoriesDecorator.class);\n    extensions.add(FilesDecorator.class);\n    extensions.add(ReviewNotifications.class);\n    extensions.add(ReviewWorkflowDecorator.class);\n    extensions.add(ReferenceAnalysis.class);\n    extensions.add(ManualMeasureDecorator.class);\n    extensions.add(ManualViolationInjector.class);\n    extensions.add(ViolationSeverityUpdater.class);\n    extensions.add(IndexProjectPostJob.class);\n    extensions.add(ReviewsMeasuresDecorator.class);\n\n    // time machine\n    extensions.add(TendencyDecorator.class);\n    extensions.add(VariationDecorator.class);\n    extensions.add(ViolationTrackingDecorator.class);\n    extensions.add(ViolationPersisterDecorator.class);\n    extensions.add(NewViolationsDecorator.class);\n    extensions.add(TimeMachineConfigurationPersister.class);\n    extensions.add(NewCoverageFileAnalyzer.class);\n    extensions.add(NewItCoverageFileAnalyzer.class);\n    extensions.add(NewCoverageAggregator.class);\n\n    return extensions;\n  }","id":67905,"modified_method":"@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public List<Class<? extends Extension>> getExtensions() {\n    List extensions = Lists.newLinkedList();\n\n    extensions.add(DefaultResourceTypes.class);\n    extensions.add(UserManagedMetrics.class);\n    extensions.add(ProjectFileSystemLogger.class);\n\n    // maven\n    extensions.add(MavenInitializer.class);\n\n    // languages\n    extensions.add(Java.class);\n\n    // pages\n    extensions.add(TestsViewerDefinition.class);\n    extensions.add(Lcom4Viewer.class);\n\n    // filters\n    extensions.add(ProjectFilter.class);\n    extensions.add(TreeMapFilter.class);\n    extensions.add(MyFavouritesFilter.class);\n\n    // widgets\n    extensions.add(AlertsWidget.class);\n    extensions.add(CoverageWidget.class);\n    extensions.add(ItCoverageWidget.class);\n    extensions.add(CommentsDuplicationsWidget.class);\n    extensions.add(DescriptionWidget.class);\n    extensions.add(ComplexityWidget.class);\n    extensions.add(RulesWidget.class);\n    extensions.add(SizeWidget.class);\n    extensions.add(EventsWidget.class);\n    extensions.add(CustomMeasuresWidget.class);\n    extensions.add(TimelineWidget.class);\n    extensions.add(TimeMachineWidget.class);\n    extensions.add(HotspotMetricWidget.class);\n    extensions.add(HotspotMostViolatedResourcesWidget.class);\n    extensions.add(HotspotMostViolatedRulesWidget.class);\n    extensions.add(MyReviewsWidget.class);\n    extensions.add(ProjectReviewsWidget.class);\n    extensions.add(FalsePositiveReviewsWidget.class);\n    extensions.add(ReviewsPerDeveloperWidget.class);\n    extensions.add(PlannedReviewsWidget.class);\n    extensions.add(UnplannedReviewsWidget.class);\n    extensions.add(ActionPlansWidget.class);\n    extensions.add(ReviewsMetricsWidget.class);\n    extensions.add(TreemapWidget.class);\n    extensions.add(FilterWidget.class);\n\n    // dashboards\n    extensions.add(DefaultDashboard.class);\n    extensions.add(HotspotsDashboard.class);\n    extensions.add(ReviewsDashboard.class);\n    extensions.add(TimeMachineDashboard.class);\n    extensions.add(ProjectsDashboard.class);\n    extensions.add(TreemapDashboard.class);\n    extensions.add(MyFavouritesDashboard.class);\n\n    // chart\n    extensions.add(XradarChart.class);\n    extensions.add(DistributionBarChart.class);\n    extensions.add(DistributionAreaChart.class);\n\n    // colorizers\n    extensions.add(JavaColorizerFormat.class);\n\n    // batch\n    extensions.add(ProfileSensor.class);\n    extensions.add(ProfileEventsSensor.class);\n    extensions.add(ProjectLinksSensor.class);\n    extensions.add(UnitTestDecorator.class);\n    extensions.add(VersionEventsSensor.class);\n    extensions.add(CheckAlertThresholds.class);\n    extensions.add(GenerateAlertEvents.class);\n    extensions.add(ViolationsDecorator.class);\n    extensions.add(WeightedViolationsDecorator.class);\n    extensions.add(ViolationsDensityDecorator.class);\n    extensions.add(LineCoverageDecorator.class);\n    extensions.add(CoverageDecorator.class);\n    extensions.add(BranchCoverageDecorator.class);\n    extensions.add(ItLineCoverageDecorator.class);\n    extensions.add(ItCoverageDecorator.class);\n    extensions.add(ItBranchCoverageDecorator.class);\n    extensions.add(ApplyProjectRolesDecorator.class);\n    extensions.add(ExcludedResourceFilter.class);\n    extensions.add(CommentDensityDecorator.class);\n    extensions.add(NoSonarFilter.class);\n    extensions.add(DirectoriesDecorator.class);\n    extensions.add(FilesDecorator.class);\n    extensions.add(ReviewNotifications.class);\n    extensions.add(ReviewWorkflowDecorator.class);\n    extensions.add(ReferenceAnalysis.class);\n    extensions.add(ManualMeasureDecorator.class);\n    extensions.add(ManualViolationInjector.class);\n    extensions.add(ViolationSeverityUpdater.class);\n    extensions.add(IndexProjectPostJob.class);\n    extensions.add(ReviewsMeasuresDecorator.class);\n\n    // time machine\n    extensions.add(TendencyDecorator.class);\n    extensions.add(VariationDecorator.class);\n    extensions.add(ViolationTrackingDecorator.class);\n    extensions.add(ViolationPersisterDecorator.class);\n    extensions.add(NewViolationsDecorator.class);\n    extensions.add(TimeMachineConfigurationPersister.class);\n    extensions.add(NewCoverageFileAnalyzer.class);\n    extensions.add(NewItCoverageFileAnalyzer.class);\n    extensions.add(NewCoverageAggregator.class);\n\n    return extensions;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void activate(DashboardDto dashboardDto, int index) {\n    ActiveDashboardDto activeDashboardDto = new ActiveDashboardDto();\n    activeDashboardDto.setDashboardId(dashboardDto.getId());\n    activeDashboardDto.setOrderIndex(index);\n    activeDashboardDao.insert(activeDashboardDto);\n    LOG.info(\"New dashboard '\" + dashboardDto.getName() + \"' registered\");\n  }","id":67906,"modified_method":"private void activate(DashboardDto dashboardDto, int index) {\n    ActiveDashboardDto activeDashboardDto = new ActiveDashboardDto()\n        .setDashboardId(dashboardDto.getId())\n        .setOrderIndex(index);\n    activeDashboardDao.insert(activeDashboardDto);\n\n    LOG.info(\"New dashboard '\" + dashboardDto.getName() + \"' registered\");\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void start() {\n    TimeProfiler profiler = new TimeProfiler().start(\"Register dashboards\");\n\n    List<DashboardDto> registeredDashboards = Lists.newArrayList();\n    for (DashboardTemplate template : dashboardTemplates) {\n      if (shouldRegister(template.getName())) {\n        Dashboard dashboard = template.createDashboard();\n        DashboardDto dto = register(template.getName(), dashboard);\n        if (dto != null) {\n          registeredDashboards.add(dto);\n        }\n      }\n    }\n\n    activate(registeredDashboards);\n\n    profiler.stop();\n  }","id":67907,"modified_method":"public void start() {\n    TimeProfiler profiler = new TimeProfiler().start(\"Register dashboards\");\n\n    List<DashboardDto> registeredDashboards = Lists.newArrayList();\n    for (DashboardTemplate template : dashboardTemplates) {\n      if (shouldRegister(template.getName())) {\n        Dashboard dashboard = template.createDashboard();\n        DashboardDto dto = register(template.getName(), dashboard);\n        if ((dto != null) && (dashboard.isActivated())) {\n          registeredDashboards.add(dto);\n        }\n      }\n    }\n\n    activate(registeredDashboards);\n\n    profiler.stop();\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected DashboardDto createDtoFromExtension(String name, Dashboard dashboard) {\n    Date now = new Date();\n    DashboardDto dashboardDto = new DashboardDto();\n    dashboardDto.setName(name);\n    dashboardDto.setDescription(dashboard.getDescription());\n    dashboardDto.setColumnLayout(dashboard.getLayout().getCode());\n    dashboardDto.setShared(true);\n    dashboardDto.setGlobal(dashboard.isGlobal());\n    dashboardDto.setCreatedAt(now);\n    dashboardDto.setUpdatedAt(now);\n\n    for (int columnIndex = 1; columnIndex <= dashboard.getLayout().getColumns(); columnIndex++) {\n      List<Dashboard.Widget> widgets = dashboard.getWidgetsOfColumn(columnIndex);\n      for (int rowIndex = 1; rowIndex <= widgets.size(); rowIndex++) {\n        Dashboard.Widget widget = widgets.get(rowIndex - 1);\n        WidgetDto widgetDto = new WidgetDto();\n        widgetDto.setKey(widget.getId());\n        widgetDto.setColumnIndex(columnIndex);\n        widgetDto.setRowIndex(rowIndex);\n        widgetDto.setConfigured(true);\n        widgetDto.setCreatedAt(now);\n        widgetDto.setUpdatedAt(now);\n        dashboardDto.addWidget(widgetDto);\n\n        for (Entry<String, String> property : widget.getProperties().entrySet()) {\n          WidgetPropertyDto propDto = new WidgetPropertyDto();\n          propDto.setKey(property.getKey());\n          propDto.setValue(property.getValue());\n          widgetDto.addWidgetProperty(propDto);\n        }\n      }\n\n    }\n    return dashboardDto;\n  }","id":67908,"modified_method":"protected DashboardDto createDtoFromExtension(String name, Dashboard dashboard) {\n    Date now = new Date();\n\n    DashboardDto dashboardDto = new DashboardDto()\n        .setName(name)\n        .setDescription(dashboard.getDescription())\n        .setColumnLayout(dashboard.getLayout().getCode())\n        .setShared(true)\n        .setGlobal(dashboard.isGlobal())\n        .setCreatedAt(now)\n        .setUpdatedAt(now);\n\n    for (int columnIndex = 1; columnIndex <= dashboard.getLayout().getColumns(); columnIndex++) {\n      List<Dashboard.Widget> widgets = dashboard.getWidgetsOfColumn(columnIndex);\n      for (int rowIndex = 1; rowIndex <= widgets.size(); rowIndex++) {\n        Dashboard.Widget widget = widgets.get(rowIndex - 1);\n        WidgetDto widgetDto = new WidgetDto()\n            .setKey(widget.getId())\n            .setColumnIndex(columnIndex)\n            .setRowIndex(rowIndex)\n            .setConfigured(true)\n            .setCreatedAt(now)\n            .setUpdatedAt(now);\n        dashboardDto.addWidget(widgetDto);\n\n        for (Entry<String, String> property : widget.getProperties().entrySet()) {\n          WidgetPropertyDto propDto = new WidgetPropertyDto()\n              .setKey(property.getKey())\n              .setValue(property.getValue());\n          widgetDto.addWidgetProperty(propDto);\n        }\n      }\n    }\n    return dashboardDto;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void activate(List<DashboardDto> loadedDashboards) {\n    int nextOrderIndex = activeDashboardDao.selectMaxOrderIndexForNullUser() + 1;\n    Collections.sort(loadedDashboards, new DashboardComparator());\n    for (DashboardDto dashboardDto : loadedDashboards) {\n      activate(dashboardDto, nextOrderIndex++);\n    }\n  }","id":67909,"modified_method":"protected void activate(List<DashboardDto> loadedDashboards) {\n    int nextOrderIndex = activeDashboardDao.selectMaxOrderIndexForNullUser() + 1;\n\n    for (DashboardDto dashboardDto : new DashboardOrdering().sortedCopy(loadedDashboards)) {\n      activate(dashboardDto, nextOrderIndex++);\n    }\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void init() {\n    dashboardDao = mock(DashboardDao.class);\n    activeDashboardDao = mock(ActiveDashboardDao.class);\n    loadedTemplateDao = mock(LoadedTemplateDao.class);\n\n    fakeDashboardTemplate = new FakeDashboard();\n\n    task = new RegisterNewDashboards(new DashboardTemplate[]{fakeDashboardTemplate}, dashboardDao,\n        activeDashboardDao, loadedTemplateDao);\n  }","id":67910,"modified_method":"@Before\n  public void init() {\n    dashboardDao = mock(DashboardDao.class);\n    activeDashboardDao = mock(ActiveDashboardDao.class);\n    loadedTemplateDao = mock(LoadedTemplateDao.class);\n    fakeDashboardTemplate = mock(DashboardTemplate.class);\n\n    task = new RegisterNewDashboards(new DashboardTemplate[] {fakeDashboardTemplate}, dashboardDao,\n        activeDashboardDao, loadedTemplateDao);\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testStart() {\n    task.start();\n    verify(dashboardDao).insert(any(DashboardDto.class));\n    verify(loadedTemplateDao).insert(any(LoadedTemplateDto.class));\n    verify(activeDashboardDao).insert(any(ActiveDashboardDto.class));\n  }","id":67911,"modified_method":"@Test\n  public void testStart() {\n    when(fakeDashboardTemplate.createDashboard()).thenReturn(Dashboard.create());\n\n    task.start();\n\n    verify(dashboardDao).insert(any(DashboardDto.class));\n    verify(loadedTemplateDao).insert(any(LoadedTemplateDto.class));\n    verify(activeDashboardDao).insert(any(ActiveDashboardDto.class));\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldRegisterDashboard() {\n    when(loadedTemplateDao.countByTypeAndKey(LoadedTemplateDto.DASHBOARD_TYPE, \"Fake\")).thenReturn(0);\n    assertThat(task.shouldRegister(\"Fake\"), is(true));\n  }","id":67912,"modified_method":"@Test\n  public void shouldRegisterDashboard() {\n    when(loadedTemplateDao.countByTypeAndKey(LoadedTemplateDto.DASHBOARD_TYPE, \"Fake\")).thenReturn(0);\n\n    assertThat(task.shouldRegister(\"Fake\")).isTrue();\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotRegister() {\n    when(loadedTemplateDao.countByTypeAndKey(LoadedTemplateDto.DASHBOARD_TYPE, \"Fake\")).thenReturn(1);\n    assertThat(task.shouldRegister(\"Fake\"), is(false));\n  }","id":67913,"modified_method":"@Test\n  public void shouldNotRegister() {\n    when(loadedTemplateDao.countByTypeAndKey(LoadedTemplateDto.DASHBOARD_TYPE, \"Fake\")).thenReturn(1);\n\n    assertThat(task.shouldRegister(\"Fake\")).isFalse();\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldCreateDtoFromExtension() {\n    DashboardDto dto = task.createDtoFromExtension(\"Fake\", fakeDashboardTemplate.createDashboard());\n    assertThat(dto.getUserId(), is(nullValue()));\n    assertThat(dto.getName(), is(\"Fake\"));\n    assertThat(dto.getDescription(), nullValue());\n    assertThat(dto.getColumnLayout(), is(\"30%-70%\"));\n    assertThat(dto.getShared(), is(true));\n    assertThat(dto.getGlobal(), is(true));\n    assertNotNull(dto.getCreatedAt());\n    assertNotNull(dto.getUpdatedAt());\n\n    WidgetDto widgetDto = dto.getWidgets().iterator().next();\n    assertThat(widgetDto.getKey(), is(\"fake-widget\"));\n    assertThat(widgetDto.getDescription(), is(nullValue()));\n    assertThat(widgetDto.getColumnIndex(), is(1));\n    assertThat(widgetDto.getRowIndex(), is(1));\n    assertThat(widgetDto.getConfigured(), is(true));\n    assertNotNull(widgetDto.getCreatedAt());\n    assertNotNull(widgetDto.getUpdatedAt());\n\n    WidgetPropertyDto widgetPropertyDto = widgetDto.getWidgetProperties().iterator().next();\n    assertThat(widgetPropertyDto.getKey(), is(\"fake-property\"));\n    assertThat(widgetPropertyDto.getValue(), is(\"fake_metric\"));\n  }","id":67914,"modified_method":"@Test\n  public void shouldCreateDtoFromExtension() {\n    Dashboard dashboard = Dashboard.create()\n        .setGlobal(true)\n        .setLayout(DashboardLayout.TWO_COLUMNS_30_70);\n    Dashboard.Widget widget = dashboard.addWidget(\"fake-widget\", 1);\n    widget.setProperty(\"fake-property\", \"fake_metric\");\n    when(fakeDashboardTemplate.createDashboard()).thenReturn(dashboard);\n\n    DashboardDto dto = task.createDtoFromExtension(\"Fake\", fakeDashboardTemplate.createDashboard());\n    assertThat(dto.getUserId()).isNull();\n    assertThat(dto.getName()).isEqualTo(\"Fake\");\n    assertThat(dto.getDescription()).isNull();\n    assertThat(dto.getColumnLayout()).isEqualTo(\"30%-70%\");\n    assertThat(dto.getShared()).isTrue();\n    assertThat(dto.getGlobal()).isTrue();\n    assertThat(dto.getCreatedAt()).isNotNull();\n    assertThat(dto.getUpdatedAt()).isNotNull();\n\n    WidgetDto widgetDto = Iterables.getOnlyElement(dto.getWidgets());\n    assertThat(widgetDto.getKey()).isEqualTo(\"fake-widget\");\n    assertThat(widgetDto.getDescription()).isNull();\n    assertThat(widgetDto.getColumnIndex()).isEqualTo(1);\n    assertThat(widgetDto.getRowIndex()).isEqualTo(1);\n    assertThat(widgetDto.getConfigured()).isTrue();\n    assertThat(widgetDto.getCreatedAt()).isNotNull();\n    assertThat(widgetDto.getUpdatedAt()).isNotNull();\n\n    assertThat(widgetDto.getWidgetProperties()).satisfies(contains(new WidgetPropertyDto().setKey(\"fake-property\").setValue(\"fake_metric\")));\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private BaseMatcher<ActiveDashboardDto> matchActiveDashboard(final long dashboardId, final int orderId) {\n    return new BaseMatcher<ActiveDashboardDto>() {\n      public boolean matches(Object o) {\n        ActiveDashboardDto dto = (ActiveDashboardDto) o;\n        return dto.getDashboardId() == dashboardId && dto.getOrderIndex() == orderId;\n      }\n\n      public void describeTo(Description description) {\n      }\n    };\n  }","id":67915,"modified_method":"private BaseMatcher<ActiveDashboardDto> matchActiveDashboardDto(final long dashboardId, final int orderId) {\n    return new ArgumentMatcher<ActiveDashboardDto>() {\n      @Override\n      public boolean matches(Object o) {\n        ActiveDashboardDto dto = (ActiveDashboardDto) o;\n        return dto.getDashboardId() == dashboardId && dto.getOrderIndex() == orderId;\n      }\n    };\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldActivateDashboards() throws Exception {\n    DashboardDto d1 = new DashboardDto().setName(\"Foo\").setId(14L);\n    DashboardDto d2 = new DashboardDto().setName(\"Bar\").setId(16L);\n    List<DashboardDto> loadedDashboards = Lists.newArrayList(d1, d2);\n\n    when(activeDashboardDao.selectMaxOrderIndexForNullUser()).thenReturn(4);\n\n    task.activate(loadedDashboards);\n\n    verify(activeDashboardDao).insert(argThat(matchActiveDashboard(16L, 5)));\n    verify(activeDashboardDao).insert(argThat(matchActiveDashboard(14L, 6)));\n  }","id":67916,"modified_method":"@Test\n  public void should_activate_dashboard() {\n    Dashboard dashboard = Dashboard.create();\n    when(fakeDashboardTemplate.createDashboard()).thenReturn(dashboard);\n\n    task.start();\n\n    verify(activeDashboardDao).insert(any(ActiveDashboardDto.class));\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void defaultDashboardShouldBeTheFirstActivatedDashboard() throws Exception {\n    DashboardDto defaultDashboard = new DashboardDto()\n      .setName(RegisterNewDashboards.DEFAULT_DASHBOARD_NAME)\n      .setId(10L);\n    DashboardDto other = new DashboardDto()\n      .setName(\"Bar\")\n      .setId(11L);\n    List<DashboardDto> dashboards = Lists.newArrayList(other, defaultDashboard);\n\n    task.activate(dashboards);\n\n    verify(activeDashboardDao).insert(argThat(matchActiveDashboard(10L, 1)));\n    verify(activeDashboardDao).insert(argThat(matchActiveDashboard(11L, 2)));\n  }","id":67917,"modified_method":"@Test\n  public void defaultDashboardShouldBeTheFirstActivatedDashboard() {\n    DashboardDto defaultDashboard = new DashboardDto().setId(10L).setName(RegisterNewDashboards.DEFAULT_DASHBOARD_NAME);\n    DashboardDto second = new DashboardDto().setId(11L).setName(\"Bar\");\n    DashboardDto third = new DashboardDto().setId(12L).setName(\"Foo\");\n    List<DashboardDto> dashboards = Arrays.asList(third, defaultDashboard, second);\n\n    task.activate(dashboards);\n\n    verify(activeDashboardDao).insert(argThat(matchActiveDashboardDto(10L, 1)));\n    verify(activeDashboardDao).insert(argThat(matchActiveDashboardDto(11L, 2)));\n    verify(activeDashboardDao).insert(argThat(matchActiveDashboardDto(12L, 3)));\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param columnIndex the columnIndex to set\n   */\n  public void setColumnIndex(Integer columnIndex) {\n    this.columnIndex = columnIndex;\n  }","id":67918,"modified_method":"/**\n   * @param columnIndex the columnIndex to set\n   */\n  public WidgetDto setColumnIndex(Integer columnIndex) {\n    this.columnIndex = columnIndex;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param widgetPropertyDto the widgetProperty to set\n   */\n  public void addWidgetProperty(WidgetPropertyDto widgetPropertyDto) {\n    widgetPropertyDtos.add(widgetPropertyDto);\n  }","id":67919,"modified_method":"/**\n   * @param widgetPropertyDto the widgetProperty to set\n   */\n  public WidgetDto addWidgetProperty(WidgetPropertyDto widgetPropertyDto) {\n    widgetPropertyDtos.add(widgetPropertyDto);\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param name the name to set\n   */\n  public void setName(String name) {\n    this.name = name;\n  }","id":67920,"modified_method":"/**\n   * @param name the name to set\n   */\n  public WidgetDto setName(String name) {\n    this.name = name;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param key the key to set\n   */\n  public void setKey(String key) {\n    this.key = key;\n  }","id":67921,"modified_method":"/**\n   * @param key the key to set\n   */\n  public WidgetDto setKey(String key) {\n    this.key = key;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param resourceId the resourceId to set\n   * @since 3.1\n   */\n  public void setResourceId(Integer resourceId) {\n    this.resourceId = resourceId;\n  }","id":67922,"modified_method":"/**\n   * @param resourceId the resourceId to set\n   * @since 3.1\n   */\n  public WidgetDto setResourceId(Integer resourceId) {\n    this.resourceId = resourceId;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param rowIndex the rowIndex to set\n   */\n  public void setRowIndex(Integer rowIndex) {\n    this.rowIndex = rowIndex;\n  }","id":67923,"modified_method":"/**\n   * @param rowIndex the rowIndex to set\n   */\n  public WidgetDto setRowIndex(Integer rowIndex) {\n    this.rowIndex = rowIndex;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param updatedAt the updatedAt to set\n   */\n  public void setUpdatedAt(Date updatedAt) {\n    this.updatedAt = updatedAt;\n  }","id":67924,"modified_method":"/**\n   * @param updatedAt the updatedAt to set\n   */\n  public WidgetDto setUpdatedAt(Date updatedAt) {\n    this.updatedAt = updatedAt;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param id the id to set\n   */\n  public void setId(Long id) {\n    this.id = id;\n  }","id":67925,"modified_method":"/**\n   * @param id the id to set\n   */\n  public WidgetDto setId(Long id) {\n    this.id = id;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param description the description to set\n   */\n  public void setDescription(String description) {\n    this.description = description;\n  }","id":67926,"modified_method":"/**\n   * @param description the description to set\n   */\n  public WidgetDto setDescription(String description) {\n    this.description = description;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param dashboardId the dashboardId to set\n   */\n  public void setDashboardId(Long dashboardId) {\n    this.dashboardId = dashboardId;\n  }","id":67927,"modified_method":"/**\n   * @param dashboardId the dashboardId to set\n   */\n  public WidgetDto setDashboardId(Long dashboardId) {\n    this.dashboardId = dashboardId;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param configured the configured to set\n   */\n  public void setConfigured(boolean configured) {\n    this.configured = configured;\n  }","id":67928,"modified_method":"/**\n   * @param configured the configured to set\n   */\n  public WidgetDto setConfigured(boolean configured) {\n    this.configured = configured;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param createdAt the createdAt to set\n   */\n  public void setCreatedAt(Date createdAt) {\n    this.createdAt = createdAt;\n  }","id":67929,"modified_method":"/**\n   * @param createdAt the createdAt to set\n   */\n  public WidgetDto setCreatedAt(Date createdAt) {\n    this.createdAt = createdAt;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param key the key to set\n   */\n  public void setKey(String key) {\n    this.key = key;\n  }","id":67930,"modified_method":"/**\n   * @param key the key to set\n   */\n  public WidgetPropertyDto setKey(String key) {\n    this.key = key;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param value the value to set\n   */\n  public void setValue(String value) {\n    this.value = value;\n  }","id":67931,"modified_method":"/**\n   * @param value the value to set\n   */\n  public WidgetPropertyDto setValue(String value) {\n    this.value = value;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param widgetId the widgetId to set\n   */\n  public void setWidgetId(Long widgetId) {\n    this.widgetId = widgetId;\n  }","id":67932,"modified_method":"/**\n   * @param widgetId the widgetId to set\n   */\n  public WidgetPropertyDto setWidgetId(Long widgetId) {\n    this.widgetId = widgetId;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @param id the id to set\n   */\n  public void setId(Long id) {\n    this.id = id;\n  }","id":67933,"modified_method":"/**\n   * @param id the id to set\n   */\n  public WidgetPropertyDto setId(Long id) {\n    this.id = id;\n    return this;\n  }","commit_id":"7c03664400952bb5497e07a76e4d26bd9a22b7d3","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void testContactAdmin() {\n        DashboardBasePage dashboard =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\");\n        ContactAdminFormPage contactAdminFormPage =\n                dashboard.goToHelp().clickContactAdmin();\n\n        HelpPage helpPage =\n                contactAdminFormPage.inputSubject(\"hello admin\")\n                        .inputMessage(\"I love Zanata\").send();\n\n        assertThat(\n                helpPage.getNotificationMessage(),\n                Matchers.equalTo(\"Your message has been sent to the administrator\"));\n        List<WiserMessage> messages = emailRule.getMessages();\n        assertThat(messages, Matchers.hasSize(1));\n        WiserMessage wiserMessage = messages.get(0);\n        assertThat(wiserMessage.getEnvelopeReceiver(),\n                Matchers.equalTo(\"admin@example.com\"));\n\n        String content = HasEmailRule.getEmailContent(wiserMessage);\n        assertThat(\n                content,\n                Matchers.containsString(\"Zanata user 'translator' with id 'translator' has sent the following message:\"));\n        assertThat(content, Matchers.containsString(\"I love Zanata\"));\n        assertThat(\n                content,\n                Matchers.containsString(\"You can reply to translator at translator@example.com\"));\n        // contains instance url (without last slash)\n        String instanceUrl = PropertiesHolder\n                .getProperty(Constants.zanataInstance.value()).replaceAll(\"/$\", \"\");\n        assertThat(content, Matchers.containsString(instanceUrl));\n    }","id":67934,"modified_method":"@Feature(summary = \"The user can contact the site administrator\",\n            tcmsTestPlanIds = 5316, tcmsTestCaseIds = 181717)\n    @Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void testContactAdmin() {\n        DashboardBasePage dashboard =\n                new LoginWorkFlow().signIn(\"translator\", \"translator\");\n        ContactAdminFormPage contactAdminFormPage =\n                dashboard.goToHelp().clickContactAdmin();\n\n        HelpPage helpPage = contactAdminFormPage\n                .inputSubject(\"hello admin\")\n                .inputMessage(\"I love Zanata\")\n                .send();\n\n        assertThat(helpPage.expectNotification(\"Your message has been sent \" +\n                \"to the administrator\"))\n                .isTrue()\n                .as(\"An email sent notification shows\");\n\n        List<WiserMessage> messages = emailRule.getMessages();\n\n        assertThat(messages.size())\n                .isEqualTo(1)\n                .as(\"One email was sent\");\n\n        WiserMessage wiserMessage = messages.get(0);\n\n        assertThat(wiserMessage.getEnvelopeReceiver())\n                .isEqualTo(\"admin@example.com\")\n                .as(\"The email recipient is the administrator\");\n\n        String content = HasEmailRule.getEmailContent(wiserMessage);\n\n        assertThat(content)\n                .contains(\"Zanata user 'translator' with id 'translator' \" +\n                        \"has sent the following message:\")\n                .as(\"The email header is correct\");\n        assertThat(content)\n                .contains(\"I love Zanata\")\n                .as(\"The message content is correct\");\n        assertThat(content)\n                .contains(\"You can reply to translator at \" +\n                        \"translator@example.com\")\n                .as(\"The email instructions are correct\");\n\n        // contains instance url (without last slash)\n        String instanceUrl = PropertiesHolder.getProperty(\n                Constants.zanataInstance.value()).replaceAll(\"/$\", \"\");\n\n        assertThat(content)\n                .contains(instanceUrl)\n                .as(\"The email origin (server) is correct\");\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canLimitConcurrentRestRequestsPerAPIKey() throws Exception {\n        // translator creates the project/version\n        final String projectSlug = \"project\";\n        final String iterationSlug = \"version\";\n        new ZanataRestCaller(TRANSLATOR, TRANSLATOR_API)\n                .createProjectAndVersion(projectSlug, iterationSlug, \"gettext\");\n\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n        clientRequest.body(MediaType.TEXT_PLAIN_TYPE, \"2\");\n\n        checkStatusAndReleaseConnection(clientRequest.put());\n\n        // prepare to fire multiple REST requests\n        final AtomicInteger atomicInteger = new AtomicInteger(1);\n\n        // requests from translator user\n        final int translatorThreads = 3;\n        Callable<Integer> translatorTask = new Callable<Integer>() {\n\n            @Override\n            public Integer call() {\n                return invokeRestService(new ZanataRestCaller(TRANSLATOR,\n                        TRANSLATOR_API), projectSlug, iterationSlug,\n                        atomicInteger);\n            }\n        };\n        List<Callable<Integer>> translatorTasks =\n                Collections.nCopies(translatorThreads, translatorTask);\n\n        // requests from admin user\n        int adminThreads = 2;\n        Callable<Integer> adminTask = new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                return invokeRestService(new ZanataRestCaller(), projectSlug,\n                        iterationSlug, atomicInteger);\n            }\n        };\n\n        List<Callable<Integer>> adminTasks =\n                Collections.nCopies(adminThreads, adminTask);\n\n        ExecutorService executorService =\n                Executors.newFixedThreadPool(translatorThreads + adminThreads);\n\n        List<Callable<Integer>> tasks =\n                ImmutableList.<Callable<Integer>> builder()\n                        .addAll(translatorTasks).addAll(adminTasks).build();\n\n        List<Future<Integer>> futures = executorService.invokeAll(tasks);\n\n        List<Integer> result = getResultStatusCodes(futures);\n\n        // 1 request from translator should get 403 and fail\n        log.info(\"result: {}\", result);\n        assertThat(result, Matchers.containsInAnyOrder(201, 201, 201, 201, 429));\n    }","id":67935,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canLimitConcurrentRestRequestsPerAPIKey() throws Exception {\n        // translator creates the project/version\n        final String projectSlug = \"project\";\n        final String iterationSlug = \"version\";\n        new ZanataRestCaller(TRANSLATOR, TRANSLATOR_API)\n                .createProjectAndVersion(projectSlug, iterationSlug, \"gettext\");\n\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n        clientRequest.body(MediaType.TEXT_PLAIN_TYPE, \"2\");\n\n        checkStatusAndReleaseConnection(clientRequest.put());\n\n        // prepare to fire multiple REST requests\n        final AtomicInteger atomicInteger = new AtomicInteger(1);\n\n        // requests from translator user\n        final int translatorThreads = 3;\n        Callable<Integer> translatorTask = new Callable<Integer>() {\n\n            @Override\n            public Integer call() {\n                return invokeRestService(new ZanataRestCaller(TRANSLATOR,\n                        TRANSLATOR_API), projectSlug, iterationSlug,\n                        atomicInteger);\n            }\n        };\n        List<Callable<Integer>> translatorTasks =\n                Collections.nCopies(translatorThreads, translatorTask);\n\n        // requests from admin user\n        int adminThreads = 2;\n        Callable<Integer> adminTask = new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                return invokeRestService(new ZanataRestCaller(), projectSlug,\n                        iterationSlug, atomicInteger);\n            }\n        };\n\n        List<Callable<Integer>> adminTasks =\n                Collections.nCopies(adminThreads, adminTask);\n\n        ExecutorService executorService =\n                Executors.newFixedThreadPool(translatorThreads + adminThreads);\n\n        List<Callable<Integer>> tasks =\n                ImmutableList.<Callable<Integer>> builder()\n                        .addAll(translatorTasks).addAll(adminTasks).build();\n\n        List<Future<Integer>> futures = executorService.invokeAll(tasks);\n\n        List<Integer> result = getResultStatusCodes(futures);\n\n        // 1 request from translator should get 403 and fail\n        log.info(\"result: {}\", result);\n        assertThat(result).contains(201, 201, 201, 201, 429);\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canCallServerConfigurationRestService() throws Exception {\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n        clientRequest.body(\"text/plain\", \"1\");\n        // can put\n        Response putResponse = clientRequest.put();\n\n        assertThat(getStatusAndReleaseConnection(putResponse), Matchers.is(201));\n\n        // can get single configuration\n        Response getResponse =\n                clientRequestAsAdmin(\n                        \"rest/configurations/\" + maxConcurrentPathParam).get();\n\n        assertThat(getResponse.getStatus(), Matchers.is(200));\n        String rateLimitConfig =\n                ((BaseClientResponse<String>) getResponse)\n                        .getEntity(String.class);\n        assertThat(rateLimitConfig,\n                Matchers.containsString(KEY_MAX_CONCURRENT_REQ_PER_API_KEY));\n        assertThat(rateLimitConfig, Matchers.containsString(\"<value>1<\/value>\"));\n\n        // can get all configurations\n        Response getAllResponse =\n                clientRequestAsAdmin(\"rest/configurations/\").get();\n        BaseClientResponse<String> baseClientResponse =\n                (BaseClientResponse) getAllResponse;\n\n        String configurations = baseClientResponse.getEntity(String.class);\n        log.info(\"result {}\", configurations);\n\n        assertThat(getStatusAndReleaseConnection(getAllResponse),\n                Matchers.is(200));\n        assertThat(configurations, Matchers.notNullValue());\n    }","id":67936,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canCallServerConfigurationRestService() throws Exception {\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxConcurrentPathParam);\n        clientRequest.body(\"text/plain\", \"1\");\n        // can put\n        Response putResponse = clientRequest.put();\n\n        assertThat(getStatusAndReleaseConnection(putResponse)).isEqualTo(201);\n\n        // can get single configuration\n        Response getResponse =\n                clientRequestAsAdmin(\n                        \"rest/configurations/\" + maxConcurrentPathParam).get();\n\n        assertThat(getResponse.getStatus()).isEqualTo(200);\n        String rateLimitConfig =\n                ((BaseClientResponse<String>) getResponse)\n                        .getEntity(String.class);\n        assertThat(rateLimitConfig)\n                .contains(KEY_MAX_CONCURRENT_REQ_PER_API_KEY);\n        assertThat(rateLimitConfig).contains(\"<value>1<\/value>\");\n\n        // can get all configurations\n        Response getAllResponse =\n                clientRequestAsAdmin(\"rest/configurations/\").get();\n        BaseClientResponse<String> baseClientResponse =\n                (BaseClientResponse) getAllResponse;\n\n        String configurations = baseClientResponse.getEntity(String.class);\n        log.info(\"result {}\", configurations);\n\n        assertThat(getStatusAndReleaseConnection(getAllResponse))\n                .isEqualTo(200);\n        assertThat(configurations).isNotNull();\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void serverConfigurationRestServiceOnlyAvailableToAdmin()\n            throws Exception {\n        // all request should be rejected\n        Response response =\n                clientRequestAsTranslator(\"rest/configurations/\").get();\n        assertThat(getStatusAndReleaseConnection(response), Matchers.is(401));\n\n        Response response1 =\n                clientRequestAsTranslator(\n                        \"rest/configurations/c/\" + KEY_ADMIN_EMAIL).get();\n        assertThat(getStatusAndReleaseConnection(response1), Matchers.is(401));\n\n        ClientRequest request =\n                clientRequestAsTranslator(\"rest/configurations/c/\"\n                        + KEY_ADMIN_EMAIL);\n        request.body(\"text/plain\", \"admin@email.com\");\n        Response response2 = request.put();\n        assertThat(getStatusAndReleaseConnection(response2), Matchers.is(401));\n    }","id":67937,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void serverConfigurationRestServiceOnlyAvailableToAdmin()\n            throws Exception {\n        // all request should be rejected\n        Response response =\n                clientRequestAsTranslator(\"rest/configurations/\").get();\n        assertThat(getStatusAndReleaseConnection(response)).isEqualTo(401);\n\n        Response response1 =\n                clientRequestAsTranslator(\n                        \"rest/configurations/c/\" + KEY_ADMIN_EMAIL).get();\n        assertThat(getStatusAndReleaseConnection(response1)).isEqualTo(401);\n\n        ClientRequest request =\n                clientRequestAsTranslator(\"rest/configurations/c/\"\n                        + KEY_ADMIN_EMAIL);\n        request.body(\"text/plain\", \"admin@email.com\");\n        Response response2 = request.put();\n        assertThat(getStatusAndReleaseConnection(response2)).isEqualTo(401);\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canOnlyDealWithKnownConfiguration() throws Exception {\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\");\n\n        Response putResponse = clientRequest.put();\n        assertThat(getStatusAndReleaseConnection(putResponse), Matchers.is(400));\n\n        Response getResponse =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\").get();\n        assertThat(getStatusAndReleaseConnection(getResponse), Matchers.is(404));\n    }","id":67938,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canOnlyDealWithKnownConfiguration() throws Exception {\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\");\n\n        Response putResponse = clientRequest.put();\n        assertThat(getStatusAndReleaseConnection(putResponse)).isEqualTo(400);\n\n        Response getResponse =\n                clientRequestAsAdmin(\"rest/configurations/c/abc\").get();\n        assertThat(getStatusAndReleaseConnection(getResponse)).isEqualTo(404);\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = 5000)\n    public void exceptionWillReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        ClientRequest configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.body(MediaType.TEXT_PLAIN_TYPE, \"1\");\n        checkStatusAndReleaseConnection(configRequest.put());\n\n        // When: multiple requests that will result in a mapped exception\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/test/data/sample/dummy?exception=org.zanata.rest.NoSuchEntityException\");\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1, Matchers.is(1));\n    }","id":67939,"modified_method":"@Test(timeout = 5000)\n    public void exceptionWillReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        ClientRequest configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.body(MediaType.TEXT_PLAIN_TYPE, \"1\");\n        checkStatusAndReleaseConnection(configRequest.put());\n\n        // When: multiple requests that will result in a mapped exception\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/test/data/sample/dummy?exception=org.zanata.rest.NoSuchEntityException\");\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1).isEqualTo(1);\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = 5000)\n    public void unmappedExceptionWillAlsoReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        ClientRequest configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.body(MediaType.TEXT_PLAIN_TYPE, \"1\");\n        checkStatusAndReleaseConnection(configRequest.put());\n\n        // When: multiple requests that will result in an unmapped exception\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/test/data/sample/dummy?exception=java.lang.RuntimeException\");\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1, Matchers.is(1));\n    }","id":67940,"modified_method":"@Test(timeout = 5000)\n    public void unmappedExceptionWillAlsoReleaseSemaphore() throws Exception {\n        // Given: max active is set to 1\n        ClientRequest configRequest =\n                clientRequestAsAdmin(\"rest/configurations/\"\n                        + maxActivePathParam);\n        configRequest.body(MediaType.TEXT_PLAIN_TYPE, \"1\");\n        checkStatusAndReleaseConnection(configRequest.put());\n\n        // When: multiple requests that will result in an unmapped exception\n        ClientRequest clientRequest =\n                clientRequestAsAdmin(\"rest/test/data/sample/dummy?exception=java.lang.RuntimeException\");\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n        getStatusAndReleaseConnection(clientRequest.get());\n\n        // Then: request that result in exception should still release\n        // semaphore. i.e. no permit leak\n        assertThat(1).isEqualTo(1);\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canConfigureRateLimitByWebUI() {\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n        BasicWorkFlow basicWorkFlow = new BasicWorkFlow();\n        ServerConfigurationPage serverConfigPage =\n                basicWorkFlow.goToPage(\"admin/server_configuration\",\n                        ServerConfigurationPage.class);\n\n        assertThat(serverConfigPage.getMaxConcurrentRequestsPerApiKey(),\n                Matchers.equalTo(\"default is 6\"));\n        assertThat(serverConfigPage.getMaxActiveRequestsPerApiKey(),\n                Matchers.equalTo(\"default is 2\"));\n\n        AdministrationPage administrationPage =\n                serverConfigPage.inputMaxConcurrent(5).inputMaxActive(3).save();\n\n        assertThat(administrationPage.getNotificationMessage(),\n                Matchers.equalTo(\"Configuration was successfully updated.\"));\n\n        serverConfigPage =\n                basicWorkFlow.goToPage(\"admin/server_configuration\",\n                        ServerConfigurationPage.class);\n        assertThat(serverConfigPage.getMaxActiveRequestsPerApiKey(),\n                Matchers.equalTo(\"3\"));\n        assertThat(serverConfigPage.getMaxConcurrentRequestsPerApiKey(),\n                Matchers.equalTo(\"5\"));\n    }","id":67941,"modified_method":"@Test(timeout = ZanataTestCase.MAX_SHORT_TEST_DURATION)\n    public void canConfigureRateLimitByWebUI() {\n        new LoginWorkFlow().signIn(\"admin\", \"admin\");\n        BasicWorkFlow basicWorkFlow = new BasicWorkFlow();\n        ServerConfigurationPage serverConfigPage =\n                basicWorkFlow.goToPage(\"admin/server_configuration\",\n                        ServerConfigurationPage.class);\n\n        assertThat(serverConfigPage.getMaxConcurrentRequestsPerApiKey())\n                .isEqualTo(\"default is 6\");\n        assertThat(serverConfigPage.getMaxActiveRequestsPerApiKey())\n                .isEqualTo(\"default is 2\");\n\n        AdministrationPage administrationPage =\n                serverConfigPage.inputMaxConcurrent(5).inputMaxActive(3).save();\n\n        assertThat(administrationPage.getNotificationMessage())\n                .isEqualTo(\"Configuration was successfully updated.\");\n\n        serverConfigPage =\n                basicWorkFlow.goToPage(\"admin/server_configuration\",\n                        ServerConfigurationPage.class);\n        assertThat(serverConfigPage.getMaxActiveRequestsPerApiKey())\n                .isEqualTo(\"3\");\n        assertThat(serverConfigPage.getMaxConcurrentRequestsPerApiKey())\n                .isEqualTo(\"5\");\n    }","commit_id":"555ee06b64d830f95b64c56e2a8ef677181fc99d","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      DefaultInputFile that = (DefaultInputFile) o;\n      return basedir.equals(that.basedir) && relativePath.equals(that.relativePath);\n\n    }","id":67942,"modified_method":"@Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o instanceof DefaultInputFile) {\n        DefaultInputFile that = (DefaultInputFile) o;\n        return Objects.equal(basedir, that.basedir) && Objects.equal(relativePath, that.relativePath);\n      }\n      return false;\n    }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testCreateList() {\n    java.io.File basedir = new java.io.File(\"target/tmp/InputFileUtilsTest\");\n    File file1 = new File(basedir, \"org/sonar/Foo.java\");\n    File file2 = new File(basedir, \"org/sonar/Bar.java\");\n    File wrongFile = new File(\"somewhere/else/org/sonar/Foo.java\");\n\n    List<InputFile> inputFiles = InputFileUtils.create(basedir, Lists.newArrayList(file1, file2, wrongFile));\n\n    assertThat(inputFiles.size(), is(2));\n    assertThat(inputFiles.get(0).getFile(), is(file1));\n    assertThat(inputFiles.get(1).getFile(), is(file2));\n  }","id":67943,"modified_method":"@Test\n  public void testCreateList() {\n    File file1 = new File(BASE_DIR, \"org/sonar/Foo.java\");\n    File file2 = new File(BASE_DIR, \"org/sonar/Bar.java\");\n    File wrongFile = new File(\"somewhere/else/org/sonar/Foo.java\");\n\n    List<InputFile> inputFiles = InputFileUtils.create(BASE_DIR, Arrays.asList(file1, file2, wrongFile));\n\n    assertThat(inputFiles).hasSize(2);\n    assertThat(inputFiles.get(0).getFile()).isEqualTo(file1);\n    assertThat(inputFiles.get(1).getFile()).isEqualTo(file2);\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotEqualIfBasedirAreDifferents() {\n    InputFile inputFile1 = InputFileUtils.create(new File(\"target/tmp/InputFileUtilsTest\"), \"org/sonar/Foo.java\");\n    InputFile inputFile2 = InputFileUtils.create(new File(\"target/tmp/InputFileUtilsTest/org\"), \"sonar/Foo.java\");\n    assertThat(inputFile1.equals(inputFile2), is(false));\n  }","id":67944,"modified_method":"@Test\n  public void shouldNotEqualIfbaseDirAreDifferents() {\n    InputFile inputFile1 = InputFileUtils.create(BASE_DIR, \"org/sonar/Foo.java\");\n    InputFile inputFile2 = InputFileUtils.create(new File(BASE_DIR, \"org\"), \"sonar/Foo.java\");\n\n    assertThat(inputFile1).isNotEqualTo(inputFile2);\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testEqualsAndHashCode() {\n    java.io.File basedir = new java.io.File(\"target/tmp/InputFileUtilsTest\");\n\n    InputFile inputFile1 = InputFileUtils.create(basedir, \"org/sonar/Foo.java\");\n    InputFile inputFile2 = InputFileUtils.create(basedir, \"org/sonar/Foo.java\");\n\n    assertEquals(inputFile1, inputFile1);\n    assertEquals(inputFile1, inputFile2);\n\n    assertEquals(inputFile1.hashCode(), inputFile1.hashCode());\n  }","id":67945,"modified_method":"@Test\n  public void testEqualsAndHashCode() {\n    InputFile inputFile1 = InputFileUtils.create(BASE_DIR, \"org/sonar/Foo.java\");\n    InputFile inputFile2 = InputFileUtils.create(BASE_DIR, \"org/sonar/Foo.java\");\n    InputFile inputFile3 = InputFileUtils.create(BASE_DIR, \"org/sonar/Bar.java\");\n\n    assertThat(inputFile1).isEqualTo(inputFile1).isEqualTo(inputFile2);\n    assertThat(inputFile1.hashCode()).isEqualTo(inputFile2.hashCode());\n    assertThat(inputFile1).isNotEqualTo(inputFile3);\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldGuessRelativePath() {\n    java.io.File basedir = new java.io.File(\"target/tmp/InputFileUtilsTest\");\n\n    java.io.File file = new java.io.File(basedir, \"org/sonar/Foo.java\");\n    InputFile inputFile = InputFileUtils.create(basedir, file);\n\n    assertThat(inputFile.getFileBaseDir(), is(basedir));\n    assertThat(inputFile.getFile(), is(file));\n    assertThat(inputFile.getRelativePath(), is(\"org/sonar/Foo.java\"));\n  }","id":67946,"modified_method":"@Test\n  public void shouldGuessRelativePath() {\n    File file = new File(BASE_DIR, \"org/sonar/Foo.java\");\n\n    InputFile inputFile = InputFileUtils.create(BASE_DIR, file);\n\n    assertThat(inputFile.getFileBaseDir()).isEqualTo(BASE_DIR);\n    assertThat(inputFile.getFile()).isEqualTo(file);\n    assertThat(inputFile.getRelativePath()).isEqualTo(\"org/sonar/Foo.java\");\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testToFiles() {\n    File basedir = new File(\"target/tmp/InputFileUtilsTest\");\n    List<InputFile> inputFiles = Arrays.asList(\n        InputFileUtils.create(basedir, \"Foo.java\"), InputFileUtils.create(basedir, \"Bar.java\"));\n\n    List<File> files = InputFileUtils.toFiles(inputFiles);\n\n    assertThat(files.size(), is(2));\n    assertThat(files.get(0), is(new File(basedir, \"Foo.java\")));\n    assertThat(files.get(1), is(new File(basedir, \"Bar.java\")));\n  }","id":67947,"modified_method":"@Test\n  public void testToFiles() {\n    List<InputFile> inputFiles = Arrays.asList(InputFileUtils.create(BASE_DIR, \"Foo.java\"), InputFileUtils.create(BASE_DIR, \"Bar.java\"));\n    List<File> files = InputFileUtils.toFiles(inputFiles);\n\n    assertThat(files).containsExactly(new File(BASE_DIR, \"Foo.java\"), new File(BASE_DIR, \"Bar.java\"));\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldExtractRelativeDirectory() {\n    java.io.File basedir = new java.io.File(\"target/tmp/InputFileUtilsTest\");\n\n    InputFile inputFile = InputFileUtils.create(basedir, \"org/sonar/Foo.java\");\n    assertThat(InputFileUtils.getRelativeDirectory(inputFile), is(\"org/sonar\"));\n\n    inputFile = InputFileUtils.create(basedir, \"Foo.java\");\n    assertThat(InputFileUtils.getRelativeDirectory(inputFile), is(\"\"));\n  }","id":67948,"modified_method":"@Test\n  public void shouldExtractRelativeDirectory() {\n    InputFile inputFile = InputFileUtils.create(BASE_DIR, \"org/sonar/Foo.java\");\n    assertThat(InputFileUtils.getRelativeDirectory(inputFile)).isEqualTo(\"org/sonar\");\n\n    inputFile = InputFileUtils.create(BASE_DIR, \"Foo.java\");\n    assertThat(InputFileUtils.getRelativeDirectory(inputFile)).isEmpty();\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotEqualFile() {\n    java.io.File basedir = new java.io.File(\"target/tmp/InputFileUtilsTest\");\n    File file = new File(basedir, \"org/sonar/Foo.java\");\n    InputFile inputFile = InputFileUtils.create(basedir, file);\n\n    assertThat(inputFile.getFile(), is(file));\n    assertThat(inputFile.equals(file), is(false));\n  }","id":67949,"modified_method":"@Test\n  public void shouldNotEqualFile() {\n    File file = new File(BASE_DIR, \"org/sonar/Foo.java\");\n\n    InputFile inputFile = InputFileUtils.create(BASE_DIR, file);\n\n    assertThat(inputFile.getFile()).isEqualTo(file);\n    assertThat(inputFile).isNotEqualTo(file);\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldNotAcceptFileWithWrongBasedir() {\n    java.io.File basedir1 = new java.io.File(\"target/tmp/InputFileUtilsTest/basedir1\");\n    java.io.File basedir2 = new java.io.File(\"target/tmp/InputFileUtilsTest/basedir2\");\n\n    InputFile inputFile = InputFileUtils.create(basedir1, new File(basedir2, \"org/sonar/Foo.java\"));\n\n    assertThat(inputFile, nullValue());\n  }","id":67950,"modified_method":"@Test\n  public void shouldNotAcceptFileWithWrongbaseDir() {\n    File baseDir1 = new File(BASE_DIR, \"baseDir1\");\n    File baseDir2 = new File(BASE_DIR, \"baseDir2\");\n\n    InputFile inputFile = InputFileUtils.create(baseDir1, new File(baseDir2, \"org/sonar/Foo.java\"));\n\n    assertThat(inputFile).isNull();\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testToString() {\n    File basedir = new File(\"target/tmp/InputFileUtilsTest\");\n    InputFile inputFile = InputFileUtils.create(basedir, \"org/sonar/Foo.java\");\n    assertThat(inputFile.toString(), endsWith(\"InputFileUtilsTest -> org/sonar/Foo.java\"));\n  }","id":67951,"modified_method":"@Test\n  public void testToString() {\n    InputFile inputFile = InputFileUtils.create(BASE_DIR, \"org/sonar/Foo.java\");\n\n    assertThat(inputFile.toString()).endsWith(\"InputFileUtilsTest -> org/sonar/Foo.java\");\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldCreateInputFileWithRelativePath() {\n    java.io.File basedir = new java.io.File(\"target/tmp/InputFileUtilsTest\");\n\n    InputFile inputFile = InputFileUtils.create(basedir, \"org/sonar/Foo.java\");\n\n    assertThat(inputFile.getFileBaseDir(), is(basedir));\n    assertThat(inputFile.getFile(), is(new java.io.File(\"target/tmp/InputFileUtilsTest/org/sonar/Foo.java\")));\n    assertThat(inputFile.getRelativePath(), is(\"org/sonar/Foo.java\"));\n  }","id":67952,"modified_method":"@Test\n  public void shouldCreateInputFileWithRelativePath() {\n    String relativePath = \"org/sonar/Foo.java\";\n\n    InputFile inputFile = InputFileUtils.create(BASE_DIR, relativePath);\n\n    assertThat(inputFile.getFileBaseDir()).isEqualTo(BASE_DIR);\n    assertThat(inputFile.getRelativePath()).isEqualTo(relativePath);\n    assertThat(inputFile.getFile()).isEqualTo(new File(\"target/tmp/InputFileUtilsTest/org/sonar/Foo.java\"));\n  }","commit_id":"23ce7323fc6044a4d889a3914112b1f93a7470b6","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ClassLoader add(PluginMetadata plugin) {\n    if (done) {\n      throw new IllegalStateException(\"Plugin classloaders are already initialized\");\n    }\n    try {\n      List<URL> resources = Lists.newArrayList();\n      List<URL> others = Lists.newArrayList();\n      for (File file : plugin.getDeployedFiles()) {\n        if (isResource(file)) {\n          resources.add(file.toURI().toURL());\n        } else {\n          others.add(file.toURI().toURL());\n        }\n      }\n      ClassLoader parent;\n      if (resources.isEmpty()) {\n        parent = baseClassloader;\n      } else {\n        parent = new ResourcesClassloader(resources, baseClassloader);\n      }\n      final ClassRealm realm;\n      if (plugin.isUseChildFirstClassLoader()) {\n        ClassRealm parentRealm = world.newRealm(plugin.getKey() + \"-parent\", parent);\n        realm = parentRealm.createChildRealm(plugin.getKey());\n      } else {\n        realm = world.newRealm(plugin.getKey(), parent);\n      }\n      for (URL url : others) {\n        realm.addURL(url);\n      }\n      return realm;\n    } catch (Throwable e) {\n      throw new SonarException(\"Fail to build the classloader of \" + plugin.getKey(), e);\n    }\n  }","id":67953,"modified_method":"public ClassLoader add(PluginMetadata plugin) {\n    if (done) {\n      throw new IllegalStateException(\"Plugin classloaders are already initialized\");\n    }\n    try {\n      List<URL> resources = Lists.newArrayList();\n      List<URL> others = Lists.newArrayList();\n      for (File file : plugin.getDeployedFiles()) {\n        if (isResource(file)) {\n          resources.add(file.toURI().toURL());\n        } else {\n          others.add(file.toURI().toURL());\n        }\n      }\n      ClassLoader parent;\n      if (resources.isEmpty()) {\n        parent = baseClassloader;\n      } else {\n        parent = new ResourcesClassloader(resources, baseClassloader);\n      }\n      final ClassRealm realm;\n      if (plugin.isUseChildFirstClassLoader()) {\n        ClassRealm parentRealm = world.newRealm(plugin.getKey() + \"-parent\", parent);\n        realm = parentRealm.createChildRealm(plugin.getKey());\n      } else {\n        realm = world.newRealm(plugin.getKey(), parent);\n      }\n      for (URL url : others) {\n        realm.addURL(url);\n      }\n      return realm;\n    } catch (UnsupportedClassVersionError e) {\n      throw new SonarException(\"The plugin \" + plugin.getKey() + \" is not supported with Java \" + SystemUtils.JAVA_VERSION_TRIMMED, e);\n\n    } catch (Throwable e) {\n      throw new SonarException(\"Fail to build the classloader of \" + plugin.getKey(), e);\n    }\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public boolean extend(PluginMetadata plugin) {\n    if (done) {\n      throw new IllegalStateException(\"Plugin classloaders are already initialized\");\n    }\n    try {\n      ClassRealm base = world.getRealm(plugin.getBasePlugin());\n      if (base == null) {\n        // Ignored, because base plugin is not installed\n        LOG.warn(\"Plugin \" + plugin.getKey() + \" is ignored because base plugin is not installed: \" + plugin.getBasePlugin());\n        return false;\n      }\n      base.createChildRealm(plugin.getKey()); // we create new realm to be able to return it by key without conversion to baseKey\n      for (File file : plugin.getDeployedFiles()) {\n        base.addURL(file.toURI().toURL());\n      }\n      return true;\n    } catch (Throwable e) {\n      throw new SonarException(\"Fail to extend the plugin \" + plugin.getBasePlugin() + \" for \" + plugin.getKey(), e);\n    }\n  }","id":67954,"modified_method":"public boolean extend(PluginMetadata plugin) {\n    if (done) {\n      throw new IllegalStateException(\"Plugin classloaders are already initialized\");\n    }\n    try {\n      ClassRealm base = world.getRealm(plugin.getBasePlugin());\n      if (base == null) {\n        // Ignored, because base plugin is not installed\n        LOG.warn(\"Plugin \" + plugin.getKey() + \" is ignored because base plugin is not installed: \" + plugin.getBasePlugin());\n        return false;\n      }\n      base.createChildRealm(plugin.getKey()); // we create new realm to be able to return it by key without conversion to baseKey\n      for (File file : plugin.getDeployedFiles()) {\n        base.addURL(file.toURI().toURL());\n      }\n      return true;\n    } catch (UnsupportedClassVersionError e) {\n      throw new SonarException(\"The plugin \" + plugin.getKey() + \" is not supported with Java \" + SystemUtils.JAVA_VERSION_TRIMMED, e);\n\n    } catch (Throwable e) {\n      throw new SonarException(\"Fail to extend the plugin \" + plugin.getBasePlugin() + \" with \" + plugin.getKey(), e);\n    }\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public Plugin instantiatePlugin(PluginMetadata metadata) {\n    try {\n      Class claz = get(metadata.getKey()).loadClass(metadata.getMainClass());\n      return (Plugin) claz.newInstance();\n\n    } catch (Throwable e) {\n      // Do not catch only Exception in order to detect the plugins compiled for Java > 5\n      // (it raises a java.lang.UnsupportedClassVersionError)\n      throw new SonarException(\"Fail to load plugin \" + metadata.getKey(), e);\n    }\n  }","id":67955,"modified_method":"public Plugin instantiatePlugin(PluginMetadata plugin) {\n    try {\n      Class clazz = get(plugin.getKey()).loadClass(plugin.getMainClass());\n      return (Plugin) clazz.newInstance();\n\n    } catch (UnsupportedClassVersionError e) {\n      throw new SonarException(\"The plugin \" + plugin.getKey() + \" is not supported with Java \" + SystemUtils.JAVA_VERSION_TRIMMED, e);\n\n    } catch (Throwable e) {\n      throw new SonarException(\"Fail to load the plugin \" + plugin.getKey(), e);\n    }\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public PluginClassloaders(ClassLoader baseClassloader) {\n    this.baseClassloader = baseClassloader;\n  }","id":67956,"modified_method":"public PluginClassloaders(ClassLoader baseClassloader) {\n    this(baseClassloader, new ClassWorld());\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@After\n  public void clean() {\n    classloaders.clean();\n  }","id":67957,"modified_method":"@After\n  public void clean() {\n    if (classloaders != null) {\n      classloaders.clean();\n    }\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldImport() throws Exception {\n    classloaders.add(DefaultPluginMetadata.create(null).setKey(\"foo\").addDeployedFile(getFile(\"PluginClassloadersTest/foo.jar\")));\n    classloaders.add(DefaultPluginMetadata.create(null).setKey(\"bar\").addDeployedFile(getFile(\"PluginClassloadersTest/bar.jar\")));\n    classloaders.done();\n\n    String resourceName = \"org/sonar/plugins/bar/api/resource.txt\";\n    assertThat(classloaders.get(\"bar\").getResourceAsStream(resourceName), notNullValue());\n    assertThat(classloaders.get(\"foo\").getResourceAsStream(resourceName), notNullValue());\n  }","id":67958,"modified_method":"@Test\n  public void shouldImport() throws Exception {\n    classloaders.add(DefaultPluginMetadata.create(null).setKey(\"foo\").addDeployedFile(getFile(\"PluginClassloadersTest/foo.jar\")));\n    classloaders.add(DefaultPluginMetadata.create(null).setKey(\"bar\").addDeployedFile(getFile(\"PluginClassloadersTest/bar.jar\")));\n    classloaders.done();\n\n    String resourceName = \"org/sonar/plugins/bar/api/resource.txt\";\n    assertThat(classloaders.get(\"bar\").getResourceAsStream(resourceName)).isNotNull();\n    assertThat(classloaders.get(\"foo\").getResourceAsStream(resourceName)).isNotNull();\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldCreateBaseClassloader() {\n    classloaders = new PluginClassloaders(getClass().getClassLoader());\n    DefaultPluginMetadata checkstyle = DefaultPluginMetadata.create(null)\n        .setKey(\"checkstyle\")\n        .setMainClass(\"org.sonar.plugins.checkstyle.CheckstylePlugin\")\n        .addDeployedFile(getFile(\"sonar-checkstyle-plugin-2.8.jar\"));\n\n    Map<String, Plugin> map = classloaders.init(Arrays.<PluginMetadata>asList(checkstyle));\n\n    Plugin checkstyleEntryPoint = map.get(\"checkstyle\");\n    ClassRealm checkstyleRealm = (ClassRealm) checkstyleEntryPoint.getClass().getClassLoader();\n    assertThat(checkstyleRealm.getId(), is(\"checkstyle\"));\n  }","id":67959,"modified_method":"@Test\n  public void shouldCreateBaseClassloader() {\n    classloaders = new PluginClassloaders(getClass().getClassLoader());\n    DefaultPluginMetadata checkstyle = DefaultPluginMetadata.create(null)\n      .setKey(\"checkstyle\")\n      .setMainClass(\"org.sonar.plugins.checkstyle.CheckstylePlugin\")\n      .addDeployedFile(getFile(\"sonar-checkstyle-plugin-2.8.jar\"));\n\n    Map<String, Plugin> map = classloaders.init(Arrays.<PluginMetadata>asList(checkstyle));\n\n    Plugin checkstyleEntryPoint = map.get(\"checkstyle\");\n    ClassRealm checkstyleRealm = (ClassRealm) checkstyleEntryPoint.getClass().getClassLoader();\n    assertThat(checkstyleRealm.getId()).isEqualTo(\"checkstyle\");\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldExtendPlugin() {\n    classloaders = new PluginClassloaders(getClass().getClassLoader());\n\n    DefaultPluginMetadata checkstyle = DefaultPluginMetadata.create(null)\n        .setKey(\"checkstyle\")\n        .setMainClass(\"org.sonar.plugins.checkstyle.CheckstylePlugin\")\n        .addDeployedFile(getFile(\"sonar-checkstyle-plugin-2.8.jar\"));\n\n    DefaultPluginMetadata checkstyleExt = DefaultPluginMetadata.create(null)\n        .setKey(\"checkstyle-ext\")\n        .setBasePlugin(\"checkstyle\")\n        .setMainClass(\"com.mycompany.sonar.checkstyle.CheckstyleExtensionsPlugin\")\n        .addDeployedFile(getFile(\"sonar-checkstyle-extensions-plugin-0.1-SNAPSHOT.jar\"));\n\n    Map<String, Plugin> map = classloaders.init(Arrays.<PluginMetadata>asList(checkstyle, checkstyleExt));\n\n    Plugin checkstyleEntryPoint = map.get(\"checkstyle\");\n    Plugin checkstyleExtEntryPoint = map.get(\"checkstyle-ext\");\n\n    assertEquals(checkstyleEntryPoint.getClass().getClassLoader(), checkstyleExtEntryPoint.getClass().getClassLoader());\n  }","id":67960,"modified_method":"@Test\n  public void shouldExtendPlugin() {\n    classloaders = new PluginClassloaders(getClass().getClassLoader());\n\n    DefaultPluginMetadata checkstyle = DefaultPluginMetadata.create(null)\n      .setKey(\"checkstyle\")\n      .setMainClass(\"org.sonar.plugins.checkstyle.CheckstylePlugin\")\n      .addDeployedFile(getFile(\"sonar-checkstyle-plugin-2.8.jar\"));\n\n    DefaultPluginMetadata checkstyleExt = DefaultPluginMetadata.create(null)\n      .setKey(\"checkstyle-ext\")\n      .setBasePlugin(\"checkstyle\")\n      .setMainClass(\"com.mycompany.sonar.checkstyle.CheckstyleExtensionsPlugin\")\n      .addDeployedFile(getFile(\"sonar-checkstyle-extensions-plugin-0.1-SNAPSHOT.jar\"));\n\n    Map<String, Plugin> map = classloaders.init(Arrays.<PluginMetadata>asList(checkstyle, checkstyleExt));\n\n    Plugin checkstyleEntryPoint = map.get(\"checkstyle\");\n    Plugin checkstyleExtEntryPoint = map.get(\"checkstyle-ext\");\n\n    assertThat(checkstyleEntryPoint.getClass().getClassLoader().equals(checkstyleExtEntryPoint.getClass().getClassLoader())).isTrue();\n  }","commit_id":"c5e1f897110e1defa323508c9476a272721c16a0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void keyIsLanguage() {\n    CodeColorizerFormat format = new FakeFormat(\"foo\");\n    assertThat(format.getLanguageKey(), is(\"foo\"));\n\n    assertThat(format.equals(new FakeFormat(\"foo\")), is(true));\n    assertThat(format.equals(new FakeFormat(\"bar\")), is(false));\n  }","id":67961,"modified_method":"@Test\n  public void keyIsLanguage() {\n    CodeColorizerFormat format = new FakeFormat(\"foo\");\n    assertThat(format.getLanguageKey()).isEqualTo(\"foo\");\n\n    assertThat(format.equals(new FakeFormat(\"foo\"))).isTrue();\n    assertThat(format.equals(new FakeFormat(\"bar\"))).isFalse();\n    assertThat(format.hashCode()).isEqualTo(format.hashCode());\n    assertThat(format.hashCode()).isEqualTo(new FakeFormat(\"foo\").hashCode());\n  }","commit_id":"515c2fe4b92cb845e9047ee15c0e4d484d6576ce","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testValueOfString() {\n    Assert.assertEquals(RulePriority.INFO, RulePriority.valueOfString(\"info\"));\n    Assert.assertEquals(RulePriority.MAJOR, RulePriority.valueOfString(\"MAJOR\"));\n    Assert.assertEquals(RulePriority.MAJOR, RulePriority.valueOfString(\"ERROR\"));\n    Assert.assertEquals(RulePriority.INFO, RulePriority.valueOfString(\"WARNING\"));\n    Assert.assertEquals(RulePriority.MAJOR, RulePriority.valueOfString(\"ErRor\"));\n    Assert.assertEquals(RulePriority.INFO, RulePriority.valueOfString(\"WaRnInG\"));\n  }","id":67962,"modified_method":"@Test\n  public void testValueOfString() {\n    assertThat(RulePriority.INFO).isEqualTo(RulePriority.valueOfString(\"info\"));\n    assertThat(RulePriority.MAJOR).isEqualTo(RulePriority.valueOfString(\"MAJOR\"));\n    assertThat(RulePriority.MAJOR).isEqualTo(RulePriority.valueOfString(\"ERROR\"));\n    assertThat(RulePriority.INFO).isEqualTo(RulePriority.valueOfString(\"WARNING\"));\n    assertThat(RulePriority.MAJOR).isEqualTo(RulePriority.valueOfString(\"ErRor\"));\n    assertThat(RulePriority.INFO).isEqualTo(RulePriority.valueOfString(\"WaRnInG\"));\n  }","commit_id":"515c2fe4b92cb845e9047ee15c0e4d484d6576ce","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Unzip a file into a new temporary directory. The directory is not deleted on JVM exit, so it\n   * must be explicitely deleted. \n   * @return the temporary directory\n   * @since 2.2\n   * @deprecated since 3.4 use by {@link org.sonar.api.resources.ProjectFileSystem#getSonarWorkingDirectory} or {@link org.sonar.api.platform.ServerFileSystem#getTempDir}\n   */\n  @Deprecated\n  public static File unzipToTempDir(File zip) throws IOException {\n    File toDir = TempFileUtils.createTempDirectory();\n    unzip (zip, toDir);\n    return toDir;\n  }","id":67963,"modified_method":"/**\n   * Unzip a file into a new temporary directory. The directory is not deleted on JVM exit, so it\n   * must be explicitely deleted.\n   *\n   * @return the temporary directory\n   * @since 2.2\n   * @deprecated since 3.4 use by {@link org.sonar.api.scan.filesystem.ModuleFileSystem#workingDir()} or {@link org.sonar.api.platform.ServerFileSystem#getTempDir}\n   */\n  @Deprecated\n  public static File unzipToTempDir(File zip) throws IOException {\n    File toDir = TempFileUtils.createTempDirectory();\n    unzip(zip, toDir);\n    return toDir;\n  }","commit_id":"515c2fe4b92cb845e9047ee15c0e4d484d6576ce","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private static void zip(File file, ZipOutputStream out, String prefix) throws IOException {\n    if (prefix != null) {\n      int len = prefix.length();\n      if (len == 0) {\n        prefix = null;\n      } else if (prefix.charAt(len - 1) != '/') {\n        prefix += '/';\n      }\n    }\n    for (File child : file.listFiles()) {\n      String name = prefix != null ? prefix + child.getName() : child.getName();\n      _zip(name, child, out);\n    }\n  }","id":67964,"modified_method":"private static void zip(File file, ZipOutputStream out) throws IOException {\n    for (File child : file.listFiles()) {\n      String name = child.getName();\n      _zip(name, child, out);\n    }\n  }","commit_id":"515c2fe4b92cb845e9047ee15c0e4d484d6576ce","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static void zipDir(File dir, File zip) throws IOException {\n    OutputStream out = null;\n    ZipOutputStream zout = null;\n    try {\n      out = FileUtils.openOutputStream(zip);\n      zout = new ZipOutputStream(out);\n      zip(dir, zout, null);\n\n    } finally {\n      IOUtils.closeQuietly(zout);\n      IOUtils.closeQuietly(out);\n    }\n  }","id":67965,"modified_method":"public static void zipDir(File dir, File zip) throws IOException {\n    OutputStream out = null;\n    ZipOutputStream zout = null;\n    try {\n      out = FileUtils.openOutputStream(zip);\n      zout = new ZipOutputStream(out);\n      zip(dir, zout);\n\n    } finally {\n      IOUtils.closeQuietly(zout);\n      IOUtils.closeQuietly(out);\n    }\n  }","commit_id":"515c2fe4b92cb845e9047ee15c0e4d484d6576ce","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * @return part of request URL after servlet path\n   */\n  String getResource(HttpServletRequest request) {\n    return StringUtils.substringAfter(request.getRequestURI(), request.getContextPath() + request.getServletPath() + \"/\");\n  }","id":67966,"modified_method":"/**\n   * @return part of request URL after servlet path\n   */\n  String filename(HttpServletRequest request) {\n    String filename = null;\n    if (StringUtils.endsWithIgnoreCase(request.getRequestURI(), \"jar\")) {\n      filename = StringUtils.substringAfterLast(request.getRequestURI(), \"/\");\n    }\n    return filename;\n  }","commit_id":"fa8fbea698122e9900ee71b523184b71b2cf7473","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String resource = getResource(request);\n    if (StringUtils.isEmpty(resource)) {\n      PrintWriter writer = null;\n      try {\n        response.setContentType(\"text/plain\");\n        writer = response.getWriter();\n        writer.print(StringUtils.join(getLibs(), ','));\n      } catch (IOException e) {\n        LOG.error(\"Unable to provide list of batch resources\", e);\n        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      } finally {\n        IOUtils.closeQuietly(writer);\n      }\n    } else {\n      response.setContentType(\"application/java-archive\");\n      InputStream in = null;\n      OutputStream out = null;\n      try {\n        in = getServletContext().getResourceAsStream(\"/WEB-INF/lib/\" + resource);\n        if (in == null) {\n          // TODO\n        } else {\n          out = response.getOutputStream();\n          IOUtils.copy(in, out);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Unable to load batch resource '\" + resource + \"'\", e);\n        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      } finally {\n        IOUtils.closeQuietly(in);\n        IOUtils.closeQuietly(out);\n      }\n    }\n  }","id":67967,"modified_method":"@Override\n  public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n    String filename = filename(request);\n    if (StringUtils.isBlank(filename)) {\n      PrintWriter writer = null;\n      try {\n        response.setContentType(\"text/plain\");\n        writer = response.getWriter();\n        writer.print(StringUtils.join(getLibs(), ','));\n      } catch (IOException e) {\n        LOG.error(\"Unable to provide list of batch resources\", e);\n        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      } finally {\n        IOUtils.closeQuietly(writer);\n      }\n    } else {\n      InputStream in = null;\n      OutputStream out = null;\n      try {\n        in = getServletContext().getResourceAsStream(\"/WEB-INF/lib/\" + filename);\n        if (in == null) {\n          // TODO\n        } else {\n          response.setContentType(\"application/java-archive\");\n          out = response.getOutputStream();\n          IOUtils.copy(in, out);\n        }\n      } catch (Exception e) {\n        LOG.error(\"Unable to load batch resource '\" + filename + \"'\", e);\n        response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n      } finally {\n        IOUtils.closeQuietly(in);\n        IOUtils.closeQuietly(out);\n      }\n    }\n  }","commit_id":"fa8fbea698122e9900ee71b523184b71b2cf7473","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldDetermineListOfResources() {\n    ServletContext servletContext = mock(ServletContext.class);\n    servlet = spy(servlet);\n    doReturn(servletContext).when(servlet).getServletContext();\n    Set<String> libs = Sets.newHashSet();\n    libs.add(\"/WEB-INF/lib/sonar-core-2.6.jar\");\n    libs.add(\"/WEB-INF/lib/treemap.rb\");\n    libs.add(\"/WEB-INF/lib/directory/\");\n    when(servletContext.getResourcePaths(anyString())).thenReturn(libs);\n\n    assertThat(servlet.getLibs().size(), is(1));\n    assertThat(servlet.getLibs().get(0), is(\"sonar-core-2.6.jar\"));\n  }","id":67968,"modified_method":"@Test\n  public void shouldDetermineListOfResources() {\n    ServletContext servletContext = mock(ServletContext.class);\n    servlet = spy(servlet);\n    doReturn(servletContext).when(servlet).getServletContext();\n    Set<String> libs = Sets.newHashSet();\n    libs.add(\"/WEB-INF/lib/sonar-core-2.6.jar\");\n    libs.add(\"/WEB-INF/lib/treemap.rb\");\n    libs.add(\"/WEB-INF/lib/directory/\");\n    when(servletContext.getResourcePaths(anyString())).thenReturn(libs);\n\n    assertThat(servlet.getLibs()).hasSize(1);\n    assertThat(servlet.getLibs().get(0)).isEqualTo(\"sonar-core-2.6.jar\");\n  }","commit_id":"fa8fbea698122e9900ee71b523184b71b2cf7473","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldIgnore() {\n    assertThat(BatchResourcesServlet.isIgnored(\"sonar-batch-2.6-SNAPSHOT.jar\"), is(false));\n    assertThat(BatchResourcesServlet.isIgnored(\"h2-1.3.166.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"mysql-connector-java-5.1.13.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"postgresql-9.0-801.jdbc3.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"jtds-1.2.4.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"jfreechart-1.0.9.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"eastwood-1.1.0.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"jetty-util-6.1.24.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"jruby-complete-1.5.6.jar\"), is(true));\n    assertThat(BatchResourcesServlet.isIgnored(\"jruby-rack-1.0.5.jar\"), is(true));\n  }","id":67969,"modified_method":"@Test\n  public void shouldIgnore() {\n    assertThat(BatchResourcesServlet.isIgnored(\"sonar-batch-2.6-SNAPSHOT.jar\")).isFalse();\n    assertThat(BatchResourcesServlet.isIgnored(\"h2-1.3.166.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"mysql-connector-java-5.1.13.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"postgresql-9.0-801.jdbc3.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"jtds-1.2.4.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"jfreechart-1.0.9.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"eastwood-1.1.0.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"jetty-util-6.1.24.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"jruby-complete-1.5.6.jar\")).isTrue();\n    assertThat(BatchResourcesServlet.isIgnored(\"jruby-rack-1.0.5.jar\")).isTrue();\n  }","commit_id":"fa8fbea698122e9900ee71b523184b71b2cf7473","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testEqualsAndHashcode() {\n    assertEquals(new AsmClass(\"java/lang/String\"), new AsmClass(\"java/lang/String\"));\n    assertEquals(new AsmClass(\"java/lang/String\").hashCode(), new AsmClass(\"java/lang/String\").hashCode());\n    assertFalse(new AsmClass(\"java/lang/String\").equals(new AsmClass(\"java/lang/Number\")));\n    assertFalse(new AsmClass(\"java/lang/String\").hashCode() == new AsmClass(\"java/lang/Number\").hashCode());\n  }","id":67970,"modified_method":"@Test\n  public void testEqualsAndHashcode() {\n    assertThat(new AsmClass(\"java/lang/String\")).isEqualTo(new AsmClass(\"java/lang/String\"));\n    assertThat(new AsmClass(\"java/lang/String\").hashCode()).isEqualTo(new AsmClass(\"java/lang/String\").hashCode());\n    assertThat(new AsmClass(\"java/lang/String\")).isNotEqualTo(new AsmClass(\"java/lang/Number\"));\n    assertThat(new AsmClass(\"java/lang/String\").hashCode()).isNotEqualTo(new AsmClass(\"java/lang/Number\").hashCode());\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testGetFieldOrCreateIt() {\n    AsmClass asmClass = new AsmClass(\"java/lang/String\");\n    assertNull(asmClass.getField(\"internalString\"));\n    assertNotNull(asmClass.getFieldOrCreateIt(\"internalString\"));\n    assertNotNull(asmClass.getField(\"internalString\"));\n  }","id":67971,"modified_method":"@Test\n  public void testGetFieldOrCreateIt() {\n    AsmClass asmClass = new AsmClass(\"java/lang/String\");\n\n    assertThat(asmClass.getField(\"internalString\")).isNull();\n    assertThat(asmClass.getFieldOrCreateIt(\"internalString\")).isNotNull();\n    assertThat(asmClass.getField(\"internalString\")).isNotNull();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testGetMethoddOrCreateIt() {\n    AsmClass asmClass = new AsmClass(\"java/lang/String\");\n    assertNull(asmClass.getMethod(\"toString()Ljava/lang/String;\"));\n    assertNotNull(asmClass.getMethodOrCreateIt(\"toString()Ljava/lang/String;\"));\n    assertNotNull(asmClass.getMethod(\"toString()Ljava/lang/String;\"));\n  }","id":67972,"modified_method":"@Test\n  public void testGetMethoddOrCreateIt() {\n    AsmClass asmClass = new AsmClass(\"java/lang/String\");\n\n    assertThat(asmClass.getMethod(\"toString()Ljava/lang/String;\")).isNull();\n    assertThat(asmClass.getMethodOrCreateIt(\"toString()Ljava/lang/String;\")).isNotNull();\n    assertThat(asmClass.getMethod(\"toString()Ljava/lang/String;\")).isNotNull();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testDoubleProperties() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.setProperty(\"foo\", 3.1);\n\n    assertThat(characteristic.getProperty(\"foo\"), notNullValue());\n    assertThat(characteristic.getPropertyValue(\"foo\", null), is(3.1));\n    assertThat(characteristic.getPropertyTextValue(\"foo\", null), nullValue());\n  }","id":67973,"modified_method":"@Test\n  public void testDoubleProperties() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.setProperty(\"foo\", 3.1);\n\n    assertThat(characteristic.getProperty(\"foo\")).isNotNull();\n    assertThat(characteristic.getPropertyValue(\"foo\", null)).isEqualTo(3.1);\n    assertThat(characteristic.getPropertyTextValue(\"foo\", null)).isNull();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldCreateByName() {\n    Characteristic characteristic = Characteristic.createByName(\"Foo\");\n    assertThat(characteristic.getKey(), is(\"FOO\"));\n    assertThat(characteristic.getName(), is(\"Foo\"));\n  }","id":67974,"modified_method":"@Test\n  public void shouldCreateByName() {\n    Characteristic characteristic = Characteristic.createByName(\"Foo\");\n\n    assertThat(characteristic.getKey()).isEqualTo(\"FOO\");\n    assertThat(characteristic.getName()).isEqualTo(\"Foo\");\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testStringProperties() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.setProperty(\"foo\", \"bar\");\n\n    assertThat(characteristic.getProperty(\"foo\"), notNullValue());\n    assertThat(characteristic.getPropertyTextValue(\"foo\", null), is(\"bar\"));\n    assertThat(characteristic.getPropertyValue(\"foo\", null), nullValue());\n\n    assertThat(characteristic.getProperty(\"unknown\"), nullValue());\n    assertThat(characteristic.getPropertyTextValue(\"unknown\", null), nullValue());\n  }","id":67975,"modified_method":"@Test\n  public void testStringProperties() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.setProperty(\"foo\", \"bar\");\n\n    assertThat(characteristic.getProperty(\"foo\")).isNotNull();\n    assertThat(characteristic.getPropertyTextValue(\"foo\", null)).isEqualTo(\"bar\");\n    assertThat(characteristic.getPropertyValue(\"foo\", null)).isNull();\n\n    assertThat(characteristic.getProperty(\"unknown\")).isNull();\n    assertThat(characteristic.getPropertyTextValue(\"unknown\", null)).isNull();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldReturnDefaultValues() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.setProperty(\"foo\", (String)null);\n    characteristic.setProperty(\"bar\", (Double)null);\n\n    assertThat(characteristic.getPropertyTextValue(\"foo\", \"foodef\"), is(\"foodef\"));\n    assertThat(characteristic.getPropertyTextValue(\"other\", \"otherdef\"), is(\"otherdef\"));\n    assertThat(characteristic.getPropertyValue(\"bar\", 3.14), is(3.14));\n    assertThat(characteristic.getPropertyValue(\"other\", 3.14), is(3.14));\n  }","id":67976,"modified_method":"@Test\n  public void shouldReturnDefaultValues() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.setProperty(\"foo\", (String) null);\n    characteristic.setProperty(\"bar\", (Double) null);\n\n    assertThat(characteristic.getPropertyTextValue(\"foo\", \"foodef\")).isEqualTo(\"foodef\");\n    assertThat(characteristic.getPropertyTextValue(\"other\", \"otherdef\")).isEqualTo(\"otherdef\");\n    assertThat(characteristic.getPropertyValue(\"bar\", 3.14)).isEqualTo(3.14);\n    assertThat(characteristic.getPropertyValue(\"other\", 3.14)).isEqualTo(3.14);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void addProperty() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.addProperty(CharacteristicProperty.create(\"foo\"));\n\n    CharacteristicProperty property = characteristic.getProperty(\"foo\");\n    assertThat(property, notNullValue());\n    assertTrue(property.getCharacteristic()==characteristic);\n  }","id":67977,"modified_method":"@Test\n  public void addProperty() {\n    Characteristic characteristic = Characteristic.create();\n    characteristic.addProperty(CharacteristicProperty.create(\"foo\"));\n\n    CharacteristicProperty property = characteristic.getProperty(\"foo\");\n    assertThat(property).isNotNull();\n    assertThat(property.getCharacteristic()).isSameAs(characteristic);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testHashCode() {\n    assertTrue(new Cycle(Arrays.asList(AB_Cycle)).hashCode() == new Cycle(Arrays.asList(BA_Cycle)).hashCode());\n    assertTrue(new Cycle(Arrays.asList(BCDA_Cycle)).hashCode() == new Cycle(Arrays.asList(ABCD_Cycle)).hashCode());\n    assertFalse(new Cycle(Arrays.asList(AB_Cycle)).hashCode() == new Cycle(Arrays.asList(ABC_Cycle)).hashCode());\n  }","id":67978,"modified_method":"@Test\n  public void testHashCode() {\n    assertThat(new Cycle(AB_BA).hashCode()).isEqualTo(new Cycle(BA_AB).hashCode());\n    assertThat(new Cycle(BC_CD_DA_AB).hashCode()).isEqualTo(new Cycle(AB_BC_CD_DA).hashCode());\n    assertThat(new Cycle(AB_BA).hashCode()).isNotEqualTo(new Cycle(AB_BC_CA).hashCode());\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testContains() {\n    assertTrue(new Cycle(Arrays.asList(ABCD_Cycle)).contains(new StringEdge(\"B\", \"C\")));\n  }","id":67979,"modified_method":"@Test\n  public void testContains() {\n    assertThat(new Cycle(AB_BC_CD_DA).contains(new StringEdge(\"B\", \"C\"))).isTrue();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testEqualsObject() {\n    assertEquals(new Cycle(Arrays.asList(AB_Cycle)), new Cycle(Arrays.asList(BA_Cycle)));\n    assertEquals(new Cycle(Arrays.asList(BCDA_Cycle)), new Cycle(Arrays.asList(ABCD_Cycle)));\n    assertFalse(new Cycle(Arrays.asList(BCDA_Cycle)).equals(new Cycle(Arrays.asList(AB_Cycle))));\n    assertFalse(new Cycle(Arrays.asList(ABC_Cycle)).equals(new Cycle(Arrays.asList(HIJ_Cycle))));\n  }","id":67980,"modified_method":"@Test\n  public void testEqualsObject() {\n    assertThat(new Cycle(AB_BA)).isEqualTo(new Cycle(BA_AB));\n    assertThat(new Cycle(BC_CD_DA_AB)).isEqualTo(new Cycle(AB_BC_CD_DA));\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sameObject() {\n    String s1 = \"a\";\n    String s2 = s1;\n    assertTrue(\"same objects\", s1 == s2);\n    assertThat(\"s1 = s2\", FastStringComparator.INSTANCE.compare(s1, s2), is(0));\n    assertThat(\"s2 = s1\", FastStringComparator.INSTANCE.compare(s2, s1), is(0));\n  }","id":67981,"modified_method":"@Test\n  public void sameObject() {\n    String s1 = \"a\";\n    String s2 = s1;\n\n    assertThat(s1).isSameAs(s2);\n    assertThat(compare(s1, s2)).isZero();\n    assertThat(compare(s1, s2)).isZero();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void differentHashCode() {\n    String s1 = \"a\";\n    String s2 = \"c\";\n    assertTrue(\"different hash code\", s1.hashCode() != s2.hashCode());\n    assertThat(\"s1 < s2\", FastStringComparator.INSTANCE.compare(s1, s2), is(-1));\n    assertThat(\"s2 > s1\", FastStringComparator.INSTANCE.compare(s2, s1), is(1));\n  }","id":67982,"modified_method":"@Test\n  public void differentHashCode() {\n    String s1 = \"a\";\n    String s2 = \"c\";\n\n    assertThat(s1.hashCode()).isNotEqualTo(s2.hashCode());\n    assertThat(compare(s1, s2)).isEqualTo(-1);\n    assertThat(compare(s2, s1)).isEqualTo(1);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sameHashCode() {\n    // Next two Strings have same hash code in Java - see http://www.drmaciver.com/2008/07/javalangstringhashcode/\n    String s1 = \"Od\";\n    String s2 = \"PE\";\n    assertTrue(\"same hash code\", s1.hashCode() == s2.hashCode());\n    assertThat(\"s1 < s2\", FastStringComparator.INSTANCE.compare(s1, s2), lessThan(0));\n    assertThat(\"s2 > s1\", FastStringComparator.INSTANCE.compare(s2, s1), greaterThan(0));\n  }","id":67983,"modified_method":"@Test\n  public void sameHashCode() {\n    // Next two Strings have same hash code in Java - see http://www.drmaciver.com/2008/07/javalangstringhashcode/\n    String s1 = \"Od\";\n    String s2 = \"PE\";\n\n    assertThat(s1.hashCode()).isEqualTo(s2.hashCode());\n    assertThat(compare(s1, s2)).isLessThan(0);\n    assertThat(compare(s2, s1)).isGreaterThan(0);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void sameString() {\n    String s1 = new String(\"a\");\n    String s2 = new String(\"a\");\n    assertTrue(\"different objects\", s1 != s2);\n    assertThat(\"s1 = s2\", FastStringComparator.INSTANCE.compare(s1, s2), is(0));\n    assertThat(\"s2 = s1\", FastStringComparator.INSTANCE.compare(s2, s1), is(0));\n  }","id":67984,"modified_method":"@Test\n  public void sameString() {\n    String s1 = new String(\"a\");\n    String s2 = new String(\"a\");\n\n    assertThat(s1).isNotSameAs(s2);\n    assertThat(compare(s1, s2)).isZero();\n    assertThat(compare(s1, s2)).isZero();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldExportClonedProfiles() {\n\n    RulesProfile profileProvided = new RulesProfile();\n    profileProvided.setProvided(false);\n    profileProvided.setLanguage(\"test\");\n    profileProvided.setName(\"provided\");\n\n    ProfilesBackup profilesBackup = new ProfilesBackup(Arrays.asList(profileProvided));\n    profilesBackup.exportXml(sonarConfig);\n\n    assertFalse(sonarConfig.getProfiles().iterator().next() == profileProvided);\n    assertEquals(sonarConfig.getProfiles().iterator().next().getName(), \"provided\");\n  }","id":67985,"modified_method":"@Test\n  public void shouldExportClonedProfiles() {\n\n    RulesProfile profileProvided = new RulesProfile();\n    profileProvided.setProvided(false);\n    profileProvided.setLanguage(\"test\");\n    profileProvided.setName(\"provided\");\n\n    ProfilesBackup profilesBackup = new ProfilesBackup(Arrays.asList(profileProvided));\n    profilesBackup.exportXml(sonarConfig);\n\n    assertThat(sonarConfig.getProfiles().iterator().next()).isNotSameAs(profileProvided);\n    assertThat(sonarConfig.getProfiles().iterator().next().getName()).isEqualTo(\"provided\");\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldExportRules() {\n    Rule userRule = createUserRule();\n    RulesBackup rulesBackup = new RulesBackup(Arrays.asList(userRule));\n    rulesBackup.exportXml(sonarConfig);\n\n    assertThat(sonarConfig.getRules().size(), is(1));\n    assertTrue(sonarConfig.getRules().iterator().next() == userRule);\n  }","id":67986,"modified_method":"@Test\n  public void shouldExportRules() {\n    Rule userRule = createUserRule();\n    RulesBackup rulesBackup = new RulesBackup(Arrays.asList(userRule));\n    rulesBackup.exportXml(sonarConfig);\n\n    assertThat(sonarConfig.getRules()).containsOnly(userRule);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testEqualsAndHashCode() {\n    assertFalse((prj.equals(pac)));\n    assertFalse(prj.hashCode() == pac.hashCode());\n    assertFalse(prj.equals(new Object()));\n    SourceCode samePac = new SourcePackage(\"org.sonar\");\n    assertEquals(pac, samePac);\n    assertEquals(pac.hashCode(), samePac.hashCode());\n  }","id":67987,"modified_method":"@Test\n  public void testEqualsAndHashCode() {\n    assertThat(prj).isNotEqualTo(pac);\n    assertThat(prj.hashCode()).isNotEqualTo(pac.hashCode());\n    assertThat(prj).isNotEqualTo(new Object());\n\n    SourceCode samePac = new SourcePackage(\"org.sonar\");\n    assertThat(pac).isEqualTo(samePac);\n    assertThat(pac.hashCode()).isEqualTo(samePac.hashCode());\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testFlatTendencyWithPeak() {\n    Double[] doubles = new Double[]{10.0, 15.0, 10.0};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), -0.5, 0.5);\n    assertEquals(TendencyAnalyser.TENDENCY_NEUTRAL, slopeData.getLevel());\n  }","id":67988,"modified_method":"@Test\n  public void testFlatTendencyWithPeak() {\n    TendencyAnalyser.SlopeData slopeData = analyse(10.0, 15.0, 10.0);\n\n    assertThat(slopeData.getSlope()).isGreaterThan(-0.5).isLessThan(0.5);\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_NEUTRAL);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testBigUpTendencyOnThreeValues() {\n    Double[] doubles = new Double[]{10.0, 12.0, 15.5};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), 2.5, 3.0);\n    assertEquals(TendencyAnalyser.TENDENCY_BIG_UP, slopeData.getLevel());\n  }","id":67989,"modified_method":"@Test\n  public void testBigUpTendencyOnThreeValues() {\n    TendencyAnalyser.SlopeData slopeData = analyse(10.0, 12.0, 15.5);\n\n    assertThat(slopeData.getSlope()).isGreaterThan(2.5).isLessThan(3.0);\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_BIG_UP);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testTendencyOnThreeZeroDays() {\n    Double[] doubles = new Double[]{0.0, 0.0, 0.0};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), -0.0, 0.0);\n    assertEquals(TendencyAnalyser.TENDENCY_NEUTRAL, slopeData.getLevel());\n  }","id":67990,"modified_method":"@Test\n  public void testTendencyOnThreeZeroDays() {\n    TendencyAnalyser.SlopeData slopeData = analyse(0.0, 0.0, 0.0);\n\n    assertThat(slopeData.getSlope()).isZero();\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_NEUTRAL);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testTendencyOnThreeDays() {\n    Double[] doubles = new Double[]{10.0, null, 9.9};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), -0.5, 0.5);\n    assertEquals(TendencyAnalyser.TENDENCY_NEUTRAL, slopeData.getLevel());\n  }","id":67991,"modified_method":"@Test\n  public void testTendencyOnThreeDays() {\n    TendencyAnalyser.SlopeData slopeData = analyse(10.0, null, 9.9);\n\n    assertThat(slopeData.getSlope()).isGreaterThan(-0.5).isLessThan(0.5);\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_NEUTRAL);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testBigDownOnThreeDays() {\n    Double[] doubles = new Double[]{90.0, 91.0, 50.0};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertTrue(\"slope\", slopeData.getSlope() < -2.0);\n    assertEquals(TendencyAnalyser.TENDENCY_BIG_DOWN, slopeData.getLevel());\n  }","id":67992,"modified_method":"@Test\n  public void testBigDownOnThreeDays() {\n    TendencyAnalyser.SlopeData slopeData = analyse(90.0, 91.0, 50.0);\n\n    assertThat(slopeData.getSlope()).isLessThan(-2.0);\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_BIG_DOWN);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testAsymetricAlgorithm() {\n    TendencyAnalyser.SlopeData slopeData1 = analyser.analyse(getValues(new Double[]{45.0, 47.0, 95.0}));\n    TendencyAnalyser.SlopeData slopeData2 = analyser.analyse(getValues(new Double[]{95.0, 45.0, 47.0}));\n    assertTrue(slopeData1.getSlope() != slopeData2.getSlope());\n  }","id":67993,"modified_method":"@Test\n  public void testAsymetricAlgorithm() {\n    TendencyAnalyser.SlopeData slopeData1 = analyse(45.0, 47.0, 95.0);\n    TendencyAnalyser.SlopeData slopeData2 = analyse(95.0, 45.0, 47.0);\n\n    assertThat(slopeData1.getSlope()).isNotEqualTo(slopeData2.getSlope());\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testFlatTendency() {\n    Double[] doubles = new Double[]{10.0, 10.2, 9.9};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), -0.5, 0.5);\n    assertEquals(TendencyAnalyser.TENDENCY_NEUTRAL, slopeData.getLevel());\n  }","id":67994,"modified_method":"@Test\n  public void testFlatTendency() {\n    TendencyAnalyser.SlopeData slopeData = analyse(10.0, 10.2, 9.9);\n\n    assertThat(slopeData.getSlope()).isGreaterThan(-0.5).isLessThan(0.5);\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_NEUTRAL);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testBigUpTendencyOnTenValues() {\n    Double[] doubles = new Double[]{45.0, 60.0, 57.0, 65.0, 58.0, 68.0, 59.0, 66.0, 76.0, 80.0};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), 2.5, 3.0);\n    assertEquals(TendencyAnalyser.TENDENCY_BIG_UP, slopeData.getLevel());\n  }","id":67995,"modified_method":"@Test\n  public void testBigUpTendencyOnTenValues() {\n    TendencyAnalyser.SlopeData slopeData = analyse(45.0, 60.0, 57.0, 65.0, 58.0, 68.0, 59.0, 66.0, 76.0, 80.0);\n\n    assertThat(slopeData.getSlope()).isGreaterThan(2.5).isLessThan(3.0);\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_BIG_UP);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testMediumUpTendency() {\n    Double[] doubles = new Double[]{5.0, 4.5, 5.1, 5.5, 5.3, 6.4, 6.3, 6.6, 6.8, 6.5};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), 0.0, 1.0);\n    assertEquals(TendencyAnalyser.TENDENCY_UP, slopeData.getLevel());\n  }","id":67996,"modified_method":"@Test\n  public void testMediumUpTendency() {\n    TendencyAnalyser.SlopeData slopeData = analyse(5.0, 4.5, 5.1, 5.5, 5.3, 6.4, 6.3, 6.6, 6.8, 6.5);\n\n    assertThat(slopeData.getSlope()).isGreaterThan(0.0).isLessThan(1.0);\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_UP);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testNoData() {\n    assertThat(analyser.analyse(Collections.<Double>emptyList()), nullValue());\n  }","id":67997,"modified_method":"@Test\n  public void testNoData() {\n    TendencyAnalyser.SlopeData slopeData = analyse();\n\n    assertThat(slopeData).isNull();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testNotEnoughData() {\n    assertThat(analyser.analyseLevel(Arrays.asList(10.0)), nullValue());\n  }","id":67998,"modified_method":"@Test\n  public void testNotEnoughData() {\n    assertThat(analyseLevel(10.0)).isNull();\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testTendencyOnTwoZeroDays() {\n    Double[] doubles = new Double[]{0.0, 0.0};\n    TendencyAnalyser.SlopeData slopeData = analyser.analyse(getValues(doubles));\n    assertBetween(\"slope\", slopeData.getSlope(), -0.0, 0.0);\n    assertEquals(TendencyAnalyser.TENDENCY_NEUTRAL, slopeData.getLevel());\n  }","id":67999,"modified_method":"@Test\n  public void testTendencyOnTwoZeroDays() {\n    TendencyAnalyser.SlopeData slopeData = analyse(0.0, 0.0);\n\n    assertThat(slopeData.getSlope()).isZero();\n    assertThat(slopeData.getLevel()).isEqualTo(TendencyAnalyser.TENDENCY_NEUTRAL);\n  }","commit_id":"72afb8a3154d4525d9a956b755d2871a4a5c3d9f","url":"https://github.com/SonarSource/sonarqube"}]