[{"original_method":"@Override\n        public void run() {\n            try {\n                // make a threadsafe copy of all connections\n                ArrayList<NodeConnection> connections = new ArrayList<NodeConnection>();\n                synchronized (Distributer.this) {\n                    connections.addAll(m_connections);\n                }\n\n                long now = System.currentTimeMillis();\n\n                // for each connection\n                for (NodeConnection c : connections) {\n                    synchronized(c) {\n                        // check for connection age\n                        long sinceLastResponse = now - c.m_lastResponseTime;\n\n                        // if outstanding ping and timeout, close the connection\n                        if (c.m_outstandingPing && (sinceLastResponse > m_connectionResponseTimeoutMS)) {\n                            // memoize why it's closing\n                            c.m_closeCause = DisconnectCause.TIMEOUT;\n                            // this should trigger NodeConnection.stopping(..)\n                            c.m_connection.unregister();\n                        }\n\n                        // if 1/3 of the timeout since last response, send a ping\n                        if ((!c.m_outstandingPing) && (sinceLastResponse > (m_connectionResponseTimeoutMS / 3))) {\n                            c.sendPing();\n                        }\n\n                        // for each outstanding procedure\n                        Iterator<Entry<Long, CallbackBookeeping>> iter = c.m_callbacks.entrySet().iterator();\n                        while (iter.hasNext()) {\n                            Entry<Long, CallbackBookeeping> e = iter.next();\n                            long handle = e.getKey();\n                            CallbackBookeeping cb = e.getValue();\n\n                            // if the timeout is expired, call the callback and remove the\n                            // bookeeping data\n                            if ((now - cb.timestamp) > m_procedureCallTimeoutMS) {\n                                ClientResponseImpl r = new ClientResponseImpl(\n                                        ClientResponse.CONNECTION_TIMEOUT,\n                                        ClientResponse.UNINITIALIZED_APP_STATUS_CODE,\n                                        \"\",\n                                        new VoltTable[0],\n                                        String.format(\"No response received in the allotted time (set to %d ms).\",\n                                                m_procedureCallTimeoutMS));\n                                r.setClientHandle(handle);\n                                r.setClientRoundtrip((int) (now - cb.timestamp));\n                                r.setClusterRoundtrip((int) (now - cb.timestamp));\n\n                                try {\n                                    cb.callback.clientCallback(r);\n                                } catch (Exception e1) {\n                                    e1.printStackTrace();\n                                }\n                                iter.remove();\n                                c.m_callbacksToInvoke.decrementAndGet();\n                            }\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                t.printStackTrace();\n            }\n        }","id":74000,"modified_method":"@Override\n        public void run() {\n            try {\n                // make a threadsafe copy of all connections\n                ArrayList<NodeConnection> connections = new ArrayList<NodeConnection>();\n                synchronized (Distributer.this) {\n                    connections.addAll(m_connections);\n                }\n\n                long now = System.currentTimeMillis();\n\n                // for each connection\n                for (NodeConnection c : connections) {\n                    synchronized(c) {\n                        // check for connection age\n                        long sinceLastResponse = now - c.m_lastResponseTime;\n\n                        // if outstanding ping and timeout, close the connection\n                        if (c.m_outstandingPing && (sinceLastResponse > m_connectionResponseTimeoutMS)) {\n                            // memoize why it's closing\n                            c.m_closeCause = DisconnectCause.TIMEOUT;\n                            // this should trigger NodeConnection.stopping(..)\n                            c.m_connection.unregister();\n                        }\n\n                        // if 1/3 of the timeout since last response, send a ping\n                        if ((!c.m_outstandingPing) && (sinceLastResponse > (m_connectionResponseTimeoutMS / 3))) {\n                            c.sendPing();\n                        }\n\n                        // for each outstanding procedure\n                        Iterator<Entry<Long, CallbackBookeeping>> iter = c.m_callbacks.entrySet().iterator();\n                        while (iter.hasNext()) {\n                            Entry<Long, CallbackBookeeping> e = iter.next();\n                            long handle = e.getKey();\n                            CallbackBookeeping cb = e.getValue();\n\n                            // if the timeout is expired, call the callback and remove the\n                            // bookeeping data\n                            if ((now - cb.timestamp) > m_procedureCallTimeoutMS) {\n                                ClientResponseImpl r = new ClientResponseImpl(\n                                        ClientResponse.CONNECTION_TIMEOUT,\n                                        ClientResponse.UNINITIALIZED_APP_STATUS_CODE,\n                                        \"\",\n                                        new VoltTable[0],\n                                        String.format(\"No response received in the allotted time (set to %d ms).\",\n                                                m_procedureCallTimeoutMS));\n                                r.setClientHandle(handle);\n                                r.setClientRoundtrip((int) (now - cb.timestamp));\n                                r.setClusterRoundtrip((int) (now - cb.timestamp));\n\n                                try {\n                                    cb.callback.clientCallback(r);\n                                } catch (Exception e1) {\n                                    e1.printStackTrace();\n                                }\n                                iter.remove();\n                                m_rateLimiter.transactionResponseReceived(now, -1);\n                                int callbacksToInvoke = c.m_callbacksToInvoke.decrementAndGet();\n                                assert(callbacksToInvoke >= 0);\n                            }\n                        }\n                    }\n                }\n            } catch (Throwable t) {\n                t.printStackTrace();\n            }\n        }","commit_id":"0d1a321a0f743dbd20bfa25b795f7fb67189488d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"void createConnectionWithHashedCredentials(String host, String program, byte[] hashedPassword, int port)\n    throws UnknownHostException, IOException\n    {\n        final Object socketChannelAndInstanceIdAndBuildString[] =\n            ConnectionUtil.getAuthenticatedConnection(host, program, hashedPassword, port);\n        InetSocketAddress address = new InetSocketAddress(host, port);\n        final SocketChannel aChannel = (SocketChannel)socketChannelAndInstanceIdAndBuildString[0];\n        final long instanceIdWhichIsTimestampAndLeaderIp[] = (long[])socketChannelAndInstanceIdAndBuildString[1];\n        final int hostId = (int)instanceIdWhichIsTimestampAndLeaderIp[0];\n        synchronized (this) {\n            if (m_clusterInstanceId == null) {\n                long timestamp = instanceIdWhichIsTimestampAndLeaderIp[2];\n                int addr = (int)instanceIdWhichIsTimestampAndLeaderIp[3];\n                m_clusterInstanceId = new Object[] { timestamp, addr };\n            } else {\n                if (!(((Long)m_clusterInstanceId[0]).longValue() == instanceIdWhichIsTimestampAndLeaderIp[2]) ||\n                        !(((Integer)m_clusterInstanceId[1]).longValue() == instanceIdWhichIsTimestampAndLeaderIp[3])) {\n                    aChannel.close();\n                    throw new IOException(\n                            \"Cluster instance id mismatch. Current is \" + m_clusterInstanceId[0] + \",\" + m_clusterInstanceId[1]\n                                                                                                                             + \" and server's was \" + instanceIdWhichIsTimestampAndLeaderIp[2] + \",\" + instanceIdWhichIsTimestampAndLeaderIp[3]);\n                }\n            }\n            m_buildString = (String)socketChannelAndInstanceIdAndBuildString[2];\n        }\n        NodeConnection cxn = new NodeConnection(instanceIdWhichIsTimestampAndLeaderIp, address);\n\n        Connection c = m_network.registerChannel( aChannel, cxn);\n        cxn.m_hostname = c.getHostnameOrIP();\n        cxn.m_port = port;\n        cxn.m_connection = c;\n        m_connections.add(cxn);\n\n        synchronized (this) {\n            if (m_useClientAffinity) {\n                ProcedureInvocation spi = new ProcedureInvocation( TOPOLOGY_HANDLE, \"@Statistics\", \"TOPO\", 0);\n                //The handle is specific to topology updates and has special cased handling\n                queue(spi, null, true);\n\n                spi = new ProcedureInvocation( PROCEDURE_HANDLE, \"@SystemCatalog\", \"PROCEDURES\");\n                //The handle is specific to procedure updates and has special cased handling\n                queue(spi, null, true);\n                m_hostIdToConnection.put(hostId, cxn);\n            }\n        }\n    }","id":74001,"modified_method":"void createConnectionWithHashedCredentials(String host, String program, byte[] hashedPassword, int port)\n    throws UnknownHostException, IOException\n    {\n        final Object socketChannelAndInstanceIdAndBuildString[] =\n            ConnectionUtil.getAuthenticatedConnection(host, program, hashedPassword, port);\n        InetSocketAddress address = new InetSocketAddress(host, port);\n        final SocketChannel aChannel = (SocketChannel)socketChannelAndInstanceIdAndBuildString[0];\n        final long instanceIdWhichIsTimestampAndLeaderIp[] = (long[])socketChannelAndInstanceIdAndBuildString[1];\n        final int hostId = (int)instanceIdWhichIsTimestampAndLeaderIp[0];\n        synchronized (this) {\n            if (m_clusterInstanceId == null) {\n                long timestamp = instanceIdWhichIsTimestampAndLeaderIp[2];\n                int addr = (int)instanceIdWhichIsTimestampAndLeaderIp[3];\n                m_clusterInstanceId = new Object[] { timestamp, addr };\n            } else {\n                if (!(((Long)m_clusterInstanceId[0]).longValue() == instanceIdWhichIsTimestampAndLeaderIp[2]) ||\n                        !(((Integer)m_clusterInstanceId[1]).longValue() == instanceIdWhichIsTimestampAndLeaderIp[3])) {\n                    aChannel.close();\n                    throw new IOException(\n                            \"Cluster instance id mismatch. Current is \" + m_clusterInstanceId[0] + \",\" + m_clusterInstanceId[1]\n                                                                                                                             + \" and server's was \" + instanceIdWhichIsTimestampAndLeaderIp[2] + \",\" + instanceIdWhichIsTimestampAndLeaderIp[3]);\n                }\n            }\n            m_buildString = (String)socketChannelAndInstanceIdAndBuildString[2];\n        }\n        NodeConnection cxn = new NodeConnection(instanceIdWhichIsTimestampAndLeaderIp, address);\n\n        Connection c = m_network.registerChannel( aChannel, cxn);\n        cxn.m_hostname = c.getHostnameOrIP();\n        cxn.m_port = port;\n        cxn.m_connection = c;\n        m_connections.add(cxn);\n\n        synchronized (this) {\n            if (m_useClientAffinity) {\n                ProcedureInvocation spi = new ProcedureInvocation( TOPOLOGY_HANDLE, \"@Statistics\", \"TOPO\", 0);\n                //The handle is specific to topology updates and has special cased handling\n                queue(spi, new NullCallback(), true);\n\n                spi = new ProcedureInvocation( PROCEDURE_HANDLE, \"@SystemCatalog\", \"PROCEDURES\");\n                //The handle is specific to procedure updates and has special cased handling\n                queue(spi, new NullCallback(), true);\n                m_hostIdToConnection.put(hostId, cxn);\n            }\n        }\n    }","commit_id":"0d1a321a0f743dbd20bfa25b795f7fb67189488d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Queue invocation on first node connection without backpressure. If there is none with without backpressure\n     * then return false and don't queue the invocation\n     * @param invocation\n     * @param cb\n     * @param ignoreBackPressure If true the invocation will be queued even if there is backpressure\n     * @return True if the message was queued and false if the message was not queued due to backpressure\n     * @throws NoConnectionsException\n     */\n    boolean queue(\n            ProcedureInvocation invocation,\n            ProcedureCallback cb,\n            final boolean ignoreBackpressure)\n    throws NoConnectionsException {\n        NodeConnection cxn = null;\n        boolean backpressure = true;\n\n        /*\n         * Synchronization is necessary to ensure that m_connections is not modified\n         * as well as to ensure that backpressure is reported correctly\n         */\n        synchronized (this) {\n            final int totalConnections = m_connections.size();\n\n            if (totalConnections == 0) {\n                throw new NoConnectionsException(\"No connections.\");\n            }\n\n            /*\n             * Check if the master for the partition is known. No back pressure check to ensure correct\n             * routing, but backpressure will be managed anyways.\n             */\n            if (m_useClientAffinity && m_hashinatorInitialized) {\n                final Procedure procedureInfo = m_procedureInfo.get(invocation.getProcName());\n                if (procedureInfo != null) {\n                    Integer hashedPartition = invocation.getHashinatedParam(procedureInfo.partitionParameter);\n\n                    /*\n                     * If the procedure is read only, load balance across replicas\n                     */\n                    if (procedureInfo.readOnly) {\n                        NodeConnection partitionReplicas[] = m_partitionReplicas.get(hashedPartition);\n                        if (partitionReplicas != null && partitionReplicas.length > 0) {\n                            cxn = partitionReplicas[ThreadLocalRandom.current().nextInt(partitionReplicas.length)];\n                            if (cxn.hadBackPressure()) {\n                                //See if there is one without backpressure\n                                for (NodeConnection nc : partitionReplicas) {\n                                    if (!nc.hadBackPressure()) {\n                                        cxn = nc;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (!cxn.hadBackPressure() || ignoreBackpressure) {\n                                backpressure = false;\n                            }\n                        }\n                    } else {\n                        /*\n                         * Writes have to go to the master\n                         */\n                        cxn = m_partitionMasters.get(hashedPartition);\n                        if (cxn != null && !cxn.hadBackPressure() || ignoreBackpressure) {\n                            backpressure = false;\n                        }\n                    }\n                }\n            }\n            if (cxn == null) {\n                for (int i=0; i < totalConnections; ++i) {\n                    cxn = m_connections.get(Math.abs(++m_nextConnection % totalConnections));\n                    if (!cxn.hadBackPressure() || ignoreBackpressure) {\n                        // serialize and queue the invocation\n                        backpressure = false;\n                        break;\n                    }\n                }\n            }\n\n            if (backpressure) {\n                cxn = null;\n                for (ClientStatusListenerExt s : m_listeners) {\n                    s.backpressure(true);\n                }\n            }\n        }\n\n        /*\n         * Do the heavy weight serialization outside the synchronized block.\n         * createWork synchronizes on an individual connection which allows for more concurrency\n         */\n        if (cxn != null) {\n            ByteBuffer buf = ByteBuffer.allocate(4 + invocation.getSerializedSize());\n            buf.putInt(buf.capacity() - 4);\n            try {\n                invocation.flattenToBuffer(buf);\n                buf.flip();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n            cxn.createWork(invocation.getHandle(), invocation.getProcName(), buf, cb, ignoreBackpressure);\n        }\n\n        return !backpressure;\n    }","id":74002,"modified_method":"/**\n     * Queue invocation on first node connection without backpressure. If there is none with without backpressure\n     * then return false and don't queue the invocation\n     * @param invocation\n     * @param cb\n     * @param ignoreBackPressure If true the invocation will be queued even if there is backpressure\n     * @return True if the message was queued and false if the message was not queued due to backpressure\n     * @throws NoConnectionsException\n     */\n    boolean queue(\n            ProcedureInvocation invocation,\n            ProcedureCallback cb,\n            final boolean ignoreBackpressure)\n    throws NoConnectionsException {\n        assert(invocation != null);\n        assert(cb != null);\n\n        NodeConnection cxn = null;\n        boolean backpressure = true;\n\n        /*\n         * Synchronization is necessary to ensure that m_connections is not modified\n         * as well as to ensure that backpressure is reported correctly\n         */\n        synchronized (this) {\n            final int totalConnections = m_connections.size();\n\n            if (totalConnections == 0) {\n                throw new NoConnectionsException(\"No connections.\");\n            }\n\n            /*\n             * Check if the master for the partition is known. No back pressure check to ensure correct\n             * routing, but backpressure will be managed anyways.\n             */\n            if (m_useClientAffinity && m_hashinatorInitialized) {\n                final Procedure procedureInfo = m_procedureInfo.get(invocation.getProcName());\n                if (procedureInfo != null) {\n                    Integer hashedPartition = invocation.getHashinatedParam(procedureInfo.partitionParameter);\n\n                    /*\n                     * If the procedure is read only, load balance across replicas\n                     */\n                    if (procedureInfo.readOnly) {\n                        NodeConnection partitionReplicas[] = m_partitionReplicas.get(hashedPartition);\n                        if (partitionReplicas != null && partitionReplicas.length > 0) {\n                            cxn = partitionReplicas[ThreadLocalRandom.current().nextInt(partitionReplicas.length)];\n                            if (cxn.hadBackPressure()) {\n                                //See if there is one without backpressure\n                                for (NodeConnection nc : partitionReplicas) {\n                                    if (!nc.hadBackPressure()) {\n                                        cxn = nc;\n                                        break;\n                                    }\n                                }\n                            }\n                            if (!cxn.hadBackPressure() || ignoreBackpressure) {\n                                backpressure = false;\n                            }\n                        }\n                    } else {\n                        /*\n                         * Writes have to go to the master\n                         */\n                        cxn = m_partitionMasters.get(hashedPartition);\n                        if (cxn != null && !cxn.hadBackPressure() || ignoreBackpressure) {\n                            backpressure = false;\n                        }\n                    }\n                }\n            }\n            if (cxn == null) {\n                for (int i=0; i < totalConnections; ++i) {\n                    cxn = m_connections.get(Math.abs(++m_nextConnection % totalConnections));\n                    if (!cxn.hadBackPressure() || ignoreBackpressure) {\n                        // serialize and queue the invocation\n                        backpressure = false;\n                        break;\n                    }\n                }\n            }\n\n            if (backpressure) {\n                cxn = null;\n                for (ClientStatusListenerExt s : m_listeners) {\n                    s.backpressure(true);\n                }\n            }\n        }\n\n        /*\n         * Do the heavy weight serialization outside the synchronized block.\n         * createWork synchronizes on an individual connection which allows for more concurrency\n         */\n        if (cxn != null) {\n            ByteBuffer buf = ByteBuffer.allocate(4 + invocation.getSerializedSize());\n            buf.putInt(buf.capacity() - 4);\n            try {\n                invocation.flattenToBuffer(buf);\n                buf.flip();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n            cxn.createWork(invocation.getHandle(), invocation.getProcName(), buf, cb, ignoreBackpressure);\n        }\n\n        return !backpressure;\n    }","commit_id":"0d1a321a0f743dbd20bfa25b795f7fb67189488d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"synchronized void transactionResponseReceived(long timestamp, int internalLatency) {\n        ensureCurrentBlockIsKosher(timestamp);\n        --m_outstandingTxns;\n        if (internalLatency != -1) {\n            ++m_currentBlockRecvSuccessCount;\n            m_currentBlockTotalInternalLatency += internalLatency;\n        }\n    }","id":74003,"modified_method":"synchronized void transactionResponseReceived(long timestamp, int internalLatency) {\n        ensureCurrentBlockIsKosher(timestamp);\n        --m_outstandingTxns;\n        assert(m_outstandingTxns >= 0);\n        if (internalLatency != -1) {\n            ++m_currentBlockRecvSuccessCount;\n            m_currentBlockTotalInternalLatency += internalLatency;\n        }\n    }","commit_id":"0d1a321a0f743dbd20bfa25b795f7fb67189488d","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void onFinish(SuiteMessage suiteMessage) {\n        console.getResultsView().finish();\n    }","id":74004,"modified_method":"public void onFinish(SuiteMessage suiteMessage) {\n      final TestNGResults view = console.getResultsView();\n      if (view != null) {\n        view.finish();\n      }\n    }","commit_id":"87f0485a6b60a244aac2824333ca43c4f0bbd877","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void onStart(SuiteMessage suiteMessage) {\n        console.getResultsView().start();\n    }","id":74005,"modified_method":"public void onStart(SuiteMessage suiteMessage) {\n      final TestNGResults view = console.getResultsView();\n      if (view != null) {\n        view.start();\n      }\n    }","commit_id":"87f0485a6b60a244aac2824333ca43c4f0bbd877","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void onStart(TestMessage tm) {\n        console.getResultsView().setTotal(tm.getTestMethodCount());\n    }","id":74006,"modified_method":"public void onStart(TestMessage tm) {\n      final TestNGResults view = console.getResultsView();\n      if (view != null) {\n        view.setTotal(tm.getTestMethodCount());\n      }\n    }","commit_id":"87f0485a6b60a244aac2824333ca43c4f0bbd877","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void writeNewNodesAdded(final DataOutput output, final String clusterName, final List<ClusterNode> newNodes) throws IOException {\n        if (output == null) {\n            throw new IllegalArgumentException(\"Cannot write to null dataoutput\");\n        }\n        if (newNodes == null || newNodes.isEmpty()) {\n            return;\n        }\n        // write the header\n        output.write(HEADER_NEW_NODES_ADDED);\n        // write the cluster count\n        PackedInteger.writePackedInteger(output, 1);\n        // write the cluster name\n        output.writeUTF(clusterName);\n        // write the new nodes added count\n        final int newNodesCount = newNodes.size();\n        PackedInteger.writePackedInteger(output, newNodesCount);\n        // write out the member info for each new member\n        for (final ClusterNode clusterMember : newNodes) {\n            // write the node name\n            output.writeUTF(clusterMember.getName());\n            // TODO: This should be configurable. Right now we just write out the textual form\n            // of the IP address, but the configuration should allow sending back a hostname or an\n            // IP address\n            output.writeUTF(clusterMember.getIpAddress().getHostAddress());\n            // TODO: We need a way to figure out EJB remoting port of a cluster member\n            PackedInteger.writePackedInteger(output, 4447);\n        }\n    }","id":74007,"modified_method":"void writeNewNodesAdded(final DataOutput output, final String clusterName, final List<ClusterNode> newNodes,\n                            final Registry<String, List<ClientMapping>> clientMappings) throws IOException {\n        if (output == null) {\n            throw new IllegalArgumentException(\"Cannot write to null dataoutput\");\n        }\n        if (newNodes == null || newNodes.isEmpty()) {\n            return;\n        }\n        // write the header\n        output.write(HEADER_NEW_NODES_ADDED);\n        // write the cluster count\n        PackedInteger.writePackedInteger(output, 1);\n        // write the cluster name\n        output.writeUTF(clusterName);\n        // write out the cluster node(s) information\n        this.writeClusterNodes(output, clusterName, newNodes, clientMappings.getEntries());\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Writes out a EJB remoting protocol message containing the cluster topology information for the passed <code>clusters<\/code>\n     *\n     * @param output   The {@link DataOutput} into which the message will be written\n     * @param clusters The clusters whose topology will be written to the <code>output<\/code>\n     * @throws IOException\n     */\n    void writeCompleteClusterTopology(final DataOutput output, final GroupMembershipNotifier... clusters) throws IOException {\n        if (output == null) {\n            throw new IllegalArgumentException(\"Cannot write to null dataoutput\");\n        }\n        if (clusters == null || clusters.length == 0) {\n            return;\n        }\n        // write the header\n        output.write(HEADER_COMPLETE_CLUSTER_TOPOLOGY);\n        // write the cluster count\n        PackedInteger.writePackedInteger(output, clusters.length);\n        // write out each of the cluster's topology\n        for (final GroupMembershipNotifier cluster : clusters) {\n            // write the cluster name\n            output.writeUTF(cluster.getGroupName());\n            // write the member node count\n            final int memberCount = cluster.getClusterNodes().size();\n            PackedInteger.writePackedInteger(output, memberCount);\n            // write out the member info for each member\n            for (final ClusterNode clusterMember : cluster.getClusterNodes()) {\n                // write the node name\n                output.writeUTF(clusterMember.getName());\n                // TODO: This should be configurable. Right now we just write out the textual form\n                // of the IP address, but the configuration should allow sending back a hostname or an\n                // IP address\n                output.writeUTF(clusterMember.getIpAddress().getHostAddress());\n                // TODO: We need a way to figure out EJB remoting port of a cluster member\n                PackedInteger.writePackedInteger(output, 4447);\n            }\n        }\n\n    }","id":74008,"modified_method":"/**\n     * Writes out a EJB remoting protocol message containing the cluster topology information for the passed <code>clusters<\/code>\n     *\n     * @param output   The {@link DataOutput} into which the message will be written\n     * @param clusters The clusters whose topology will be written to the <code>output<\/code>\n     * @throws IOException\n     */\n    void writeCompleteClusterTopology(final DataOutput output, final GroupMembershipNotifier[] clusters,\n                                      final Registry<String, List<ClientMapping>> clientMappingsRegistry) throws IOException {\n        if (output == null) {\n            throw new IllegalArgumentException(\"Cannot write to null dataoutput\");\n        }\n        if (clusters == null || clusters.length == 0) {\n            return;\n        }\n        final Map<String, List<ClientMapping>> clientMappings = clientMappingsRegistry.getEntries();\n        // write the header\n        output.write(HEADER_COMPLETE_CLUSTER_TOPOLOGY);\n        // write the cluster count\n        PackedInteger.writePackedInteger(output, clusters.length);\n        // write out each of the cluster's topology\n        for (final GroupMembershipNotifier cluster : clusters) {\n            // write the cluster name\n            output.writeUTF(cluster.getGroupName());\n            // write out the information of each cluster node\n            this.writeClusterNodes(output, cluster.getGroupName(), cluster.getClusterNodes(), clientMappings);\n        }\n\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"Collection<ServiceController<?>> installRuntimeServices(final OperationContext context, final ModelNode model, final ServiceVerificationHandler verificationHandler) {\n        final String connectorName = model.require(CONNECTOR_REF).asString();\n        final String threadPoolName = model.require(THREAD_POOL_NAME).asString();\n        String clientMappingCacheContainerRef = DEFAULT_CLIENT_MAPPINGS_CACHE_CONTAINER_REF;\n        if (model.hasDefined(CLIENT_MAPPINGS_CACHE_CONTAINER_REF)) {\n            clientMappingCacheContainerRef = model.get(CLIENT_MAPPINGS_CACHE_CONTAINER_REF).asString();\n        }\n        String clientMappingCacheRef = DEFAULT_CLIENT_MAPPINGS_CACHE_REF;\n        if (model.hasDefined(CLIENT_MAPPINGS_CACHE_REF)) {\n            clientMappingCacheRef = model.get(CLIENT_MAPPINGS_CACHE_REF).asString();\n        }\n        final ServiceName remotingServerServiceName = RemotingServices.serverServiceName(connectorName);\n\n        final List<ServiceController<?>> services = new ArrayList<ServiceController<?>>();\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        // Install the client-mapping service for the remoting connector\n        final EJBRemotingConnectorClientMappingService clientMappingEntryProviderService = new EJBRemotingConnectorClientMappingService();\n        final ServiceBuilder clusterMappingServiceServiceBuilder = serviceTarget.addService(EJBRemotingConnectorClientMappingService.SERVICE_NAME, clientMappingEntryProviderService)\n                .addDependency(remotingServerServiceName, AbstractStreamServerService.class, clientMappingEntryProviderService.getRemotingServerInjector());\n        if (verificationHandler != null) {\n            clusterMappingServiceServiceBuilder.addListener(verificationHandler);\n        }\n\n        // Install the clustered registry service backed by the client-mapping registry entry provider\n        final RegistryService<String, List<ClientMapping>> clientMappingRegistryService = new RegistryService<String, List<ClientMapping>>(clientMappingEntryProviderService.getRegistryEntryProvider());\n        final ServiceName clientMappingRegistryServiceName = ServiceName.JBOSS.append(\"ejb\").append(\"remoting\").append(\"cluster-registry-service\");\n        // Form the client-mapping cache's ServiceName\n        final ServiceName clientMappingCacheContainerServiceName = EmbeddedCacheManagerService.getServiceName(clientMappingCacheContainerRef);\n        final ServiceName clientMappingCacheServiceName = clientMappingCacheContainerServiceName.append(clientMappingCacheRef);\n        final ServiceBuilder registryServiceBuilder = clientMappingRegistryService.build(serviceTarget, clientMappingRegistryServiceName, clientMappingCacheServiceName);\n        if (verificationHandler != null) {\n            registryServiceBuilder.addListener(verificationHandler);\n        }\n\n        // Install the EJB remoting connector service which will listen for client connections on the remoting channel\n        // TODO: Externalize (expose via management API if needed) the version and the marshalling strategy\n        final EJBRemoteConnectorService service = new EJBRemoteConnectorService((byte) 0x01, new String[]{\"river\"});\n        final ServiceBuilder<EJBRemoteConnectorService> ejbRemoteConnectorServiceBuilder = serviceTarget.addService(EJBRemoteConnectorService.SERVICE_NAME, service);\n        // add dependency on the Remoting subsytem endpoint\n        ejbRemoteConnectorServiceBuilder.addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, service.getEndpointInjector());\n        // add dependency on the remoting server (which allows remoting connector to connect to it)\n        ejbRemoteConnectorServiceBuilder.addDependency(RemotingServices.serverServiceName(connectorName));\n        // add rest of the dependencies\n        ejbRemoteConnectorServiceBuilder.addDependency(EJB3ThreadPoolAdd.BASE_SERVICE_NAME.append(threadPoolName), ExecutorService.class, service.getExecutorService())\n                .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, service.getDeploymentRepositoryInjector())\n                .addDependency(EJBRemoteTransactionsRepository.SERVICE_NAME, EJBRemoteTransactionsRepository.class, service.getEJBRemoteTransactionsRepositoryInjector())\n                .addDependency(GroupMembershipNotifierRegistryService.SERVICE_NAME, GroupMembershipNotifierRegistry.class, service.getClusterRegistryInjector())\n                .addDependency(clientMappingRegistryServiceName, Registry.class, service.getClientMappingRegistryServiceInjector())\n                .setInitialMode(ServiceController.Mode.ACTIVE);\n        if (verificationHandler != null) {\n            ejbRemoteConnectorServiceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController ejbRemotingConnectorServiceController = ejbRemoteConnectorServiceBuilder.install();\n        services.add(ejbRemotingConnectorServiceController);\n\n        return services;\n    }","id":74009,"modified_method":"Collection<ServiceController<?>> installRuntimeServices(final OperationContext context, final ModelNode model, final ServiceVerificationHandler verificationHandler) {\n        final String connectorName = model.require(CONNECTOR_REF).asString();\n        final String threadPoolName = model.require(THREAD_POOL_NAME).asString();\n        String clientMappingCacheContainerRef = DEFAULT_CLIENT_MAPPINGS_CACHE_CONTAINER_REF;\n        if (model.hasDefined(CLIENT_MAPPINGS_CACHE_CONTAINER_REF)) {\n            clientMappingCacheContainerRef = model.get(CLIENT_MAPPINGS_CACHE_CONTAINER_REF).asString();\n        }\n        String clientMappingCacheRef = DEFAULT_CLIENT_MAPPINGS_CACHE_REF;\n        if (model.hasDefined(CLIENT_MAPPINGS_CACHE_REF)) {\n            clientMappingCacheRef = model.get(CLIENT_MAPPINGS_CACHE_REF).asString();\n        }\n        final ServiceName remotingServerServiceName = RemotingServices.serverServiceName(connectorName);\n\n        final List<ServiceController<?>> services = new ArrayList<ServiceController<?>>();\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n\n        // Install the client-mapping service for the remoting connector\n        final EJBRemotingConnectorClientMappingService clientMappingEntryProviderService = new EJBRemotingConnectorClientMappingService();\n        final ServiceBuilder clientMappingEntryProviderServiceBuilder = serviceTarget.addService(EJBRemotingConnectorClientMappingService.SERVICE_NAME, clientMappingEntryProviderService)\n                .addDependency(remotingServerServiceName, AbstractStreamServerService.class, clientMappingEntryProviderService.getRemotingServerInjector())\n                .addDependency(ServerEnvironmentService.SERVICE_NAME, ServerEnvironment.class, clientMappingEntryProviderService.getServerEnvironmentInjector());\n        if (verificationHandler != null) {\n            clientMappingEntryProviderServiceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController clientMappingEntryProviderServiceController = clientMappingEntryProviderServiceBuilder.install();\n        // add it to the services to be returned\n        services.add(clientMappingEntryProviderServiceController);\n\n\n        // Install the clustered registry service backed by the client-mapping registry entry provider\n        final RegistryService<String, List<ClientMapping>> clientMappingRegistryService = new RegistryService<String, List<ClientMapping>>(clientMappingEntryProviderService.getRegistryEntryProvider());\n        // Form the client-mapping cache's ServiceName\n        final ServiceName clientMappingCacheContainerServiceName = EmbeddedCacheManagerService.getServiceName(clientMappingCacheContainerRef);\n        final ServiceName clientMappingCacheServiceName = clientMappingCacheContainerServiceName.append(clientMappingCacheRef);\n        // install the clustered registry service as a PASSIVE service so that it will be started only if the backing cache\n        // service is installed (which happens only in the presence of clustering subsystem)\n        final ServiceBuilder registryServiceBuilder = clientMappingRegistryService.build(serviceTarget, EJBRemoteConnectorService.EJB_REMOTE_CONNECTOR_CLIENT_MAPPINGS_REGISTRY_SERVICE, clientMappingCacheServiceName)\n                .setInitialMode(ServiceController.Mode.PASSIVE);\n        if (verificationHandler != null) {\n            registryServiceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController clientMappingRegistryServiceController = registryServiceBuilder.install();\n        // add it to the services to be returned\n        services.add(clientMappingRegistryServiceController);\n\n\n        // Install the EJB remoting connector service which will listen for client connections on the remoting channel\n        // TODO: Externalize (expose via management API if needed) the version and the marshalling strategy\n        final EJBRemoteConnectorService ejbRemoteConnectorService = new EJBRemoteConnectorService((byte) 0x01, new String[]{\"river\"});\n        final ServiceBuilder<EJBRemoteConnectorService> ejbRemoteConnectorServiceBuilder = serviceTarget.addService(EJBRemoteConnectorService.SERVICE_NAME, ejbRemoteConnectorService);\n        // add dependency on the Remoting subsytem endpoint\n        ejbRemoteConnectorServiceBuilder.addDependency(RemotingServices.SUBSYSTEM_ENDPOINT, Endpoint.class, ejbRemoteConnectorService.getEndpointInjector());\n        // add dependency on the remoting server (which allows remoting connector to connect to it)\n        ejbRemoteConnectorServiceBuilder.addDependency(remotingServerServiceName, AbstractStreamServerService.class, ejbRemoteConnectorService.getRemotingServerInjector());\n        // add rest of the dependencies\n        ejbRemoteConnectorServiceBuilder.addDependency(EJB3ThreadPoolAdd.BASE_SERVICE_NAME.append(threadPoolName), ExecutorService.class, ejbRemoteConnectorService.getExecutorService())\n                .addDependency(DeploymentRepository.SERVICE_NAME, DeploymentRepository.class, ejbRemoteConnectorService.getDeploymentRepositoryInjector())\n                .addDependency(EJBRemoteTransactionsRepository.SERVICE_NAME, EJBRemoteTransactionsRepository.class, ejbRemoteConnectorService.getEJBRemoteTransactionsRepositoryInjector())\n                .addDependency(GroupMembershipNotifierRegistryService.SERVICE_NAME, GroupMembershipNotifierRegistry.class, ejbRemoteConnectorService.getClusterRegistryInjector())\n                .addDependency(ServerEnvironmentService.SERVICE_NAME, ServerEnvironment.class, ejbRemoteConnectorService.getServerEnvironmentInjector())\n                        // optional dependency on the client-mapping registry service (which is backed by a cache). The dependency will be\n                        // available only in the presence of clustering subsystem\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, EJBRemoteConnectorService.EJB_REMOTE_CONNECTOR_CLIENT_MAPPINGS_REGISTRY_SERVICE, Registry.class, ejbRemoteConnectorService.getClientMappingsRegistryServiceInjector())\n                        // optional dependency on the backing cache of the client-mapping registry (available only in the presence of clustering\n                        // subsystem)\n                .addDependency(ServiceBuilder.DependencyType.OPTIONAL, clientMappingCacheServiceName, Cache.class, ejbRemoteConnectorService.getClientMappingsBackingCacheInjector())\n                .setInitialMode(ServiceController.Mode.ACTIVE);\n        if (verificationHandler != null) {\n            ejbRemoteConnectorServiceBuilder.addListener(verificationHandler);\n        }\n        final ServiceController ejbRemotingConnectorServiceController = ejbRemoteConnectorServiceBuilder.install();\n        // add it to the services to be returned\n        services.add(ejbRemotingConnectorServiceController);\n\n        return services;\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        model.get(CONNECTOR_REF).set(operation.require(CONNECTOR_REF).asString());\n        model.get(THREAD_POOL_NAME).set(operation.require(THREAD_POOL_NAME).asString());\n    }","id":74010,"modified_method":"@Override\n    protected void populateModel(ModelNode operation, ModelNode model) throws OperationFailedException {\n        model.get(CONNECTOR_REF).set(operation.require(CONNECTOR_REF).asString());\n        model.get(THREAD_POOL_NAME).set(operation.require(THREAD_POOL_NAME).asString());\n        if (operation.hasDefined(CLIENT_MAPPINGS_CACHE_CONTAINER_REF)) {\n            model.get(CLIENT_MAPPINGS_CACHE_CONTAINER_REF).set(operation.get(CLIENT_MAPPINGS_CACHE_CONTAINER_REF));\n        }\n        if (operation.hasDefined(CLIENT_MAPPINGS_CACHE_REF)) {\n            model.get(CLIENT_MAPPINGS_CACHE_REF).set(operation.get(CLIENT_MAPPINGS_CACHE_REF));\n        }\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"ClientVersionMessageReceiver(final ServiceContainer serviceContainer) {\n            this.serviceContainer = serviceContainer;\n        }","id":74011,"modified_method":"ClientVersionMessageReceiver() {\n        }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"ChannelOpenListener(final ServiceContainer serviceContainer) {\n            this.serviceContainer = serviceContainer;\n        }","id":74012,"modified_method":"ChannelOpenListener() {\n        }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void handleMessage(Channel channel, MessageInputStream messageInputStream) {\n            final DataInputStream dataInputStream = new DataInputStream(messageInputStream);\n            try {\n                final byte version = dataInputStream.readByte();\n                final String clientMarshallingStrategy = dataInputStream.readUTF();\n                log.debug(\"Client with protocol version \" + version + \" and marshalling strategy \" + clientMarshallingStrategy +\n                        \" trying to communicate on \" + channel);\n                if (!EJBRemoteConnectorService.this.isSupportedMarshallingStrategy(clientMarshallingStrategy)) {\n                    EjbLogger.EJB3_LOGGER.unsupportedClientMarshallingStrategy(clientMarshallingStrategy, channel);\n                    channel.close();\n                    return;\n                }\n                switch (version) {\n                    case 0x01:\n                        final MarshallerFactory marshallerFactory = EJBRemoteConnectorService.this.getMarshallerFactory(clientMarshallingStrategy);\n                        // enroll VersionOneProtocolChannelReceiver for handling subsequent messages on this channel\n                        final DeploymentRepository deploymentRepository = EJBRemoteConnectorService.this.deploymentRepositoryInjectedValue.getValue();\n                        final GroupMembershipNotifierRegistry groupMembershipNotifierRegistry = EJBRemoteConnectorService.this.clusterRegistry.getValue();\n                        final VersionOneProtocolChannelReceiver receiver = new VersionOneProtocolChannelReceiver(channel, deploymentRepository,\n                                EJBRemoteConnectorService.this.ejbRemoteTransactionsRepositoryInjectedValue.getValue(), groupMembershipNotifierRegistry,\n                                EJBRemoteConnectorService.this.getClientMappings(), marshallerFactory, executorService.getValue());\n                        // trigger the receiving\n                        receiver.startReceiving();\n                        break;\n\n                    default:\n                        throw new RuntimeException(\"Cannot handle client version \" + version);\n                }\n\n            } catch (IOException e) {\n                // log it\n                log.errorf(e, \"Exception on channel %s from message %s\", channel, messageInputStream);\n                IoUtils.safeClose(channel);\n            } finally {\n                IoUtils.safeClose(messageInputStream);\n            }\n\n\n        }","id":74013,"modified_method":"@Override\n        public void handleMessage(Channel channel, MessageInputStream messageInputStream) {\n            final DataInputStream dataInputStream = new DataInputStream(messageInputStream);\n            try {\n                final byte version = dataInputStream.readByte();\n                final String clientMarshallingStrategy = dataInputStream.readUTF();\n                log.debug(\"Client with protocol version \" + version + \" and marshalling strategy \" + clientMarshallingStrategy +\n                        \" trying to communicate on \" + channel);\n                if (!EJBRemoteConnectorService.this.isSupportedMarshallingStrategy(clientMarshallingStrategy)) {\n                    EjbLogger.EJB3_LOGGER.unsupportedClientMarshallingStrategy(clientMarshallingStrategy, channel);\n                    channel.close();\n                    return;\n                }\n                switch (version) {\n                    case 0x01:\n                        final MarshallerFactory marshallerFactory = EJBRemoteConnectorService.this.getMarshallerFactory(clientMarshallingStrategy);\n                        // enroll VersionOneProtocolChannelReceiver for handling subsequent messages on this channel\n                        final DeploymentRepository deploymentRepository = EJBRemoteConnectorService.this.deploymentRepositoryInjectedValue.getValue();\n                        final GroupMembershipNotifierRegistry groupMembershipNotifierRegistry = EJBRemoteConnectorService.this.clusterRegistry.getValue();\n                        // the registry will be available when the clustering subsytem is present, so get the value optionally\n                        final Registry<String, List<ClientMapping>> clientMappingRegistry = EJBRemoteConnectorService.this.clientMappingsRegistryService.getOptionalValue();\n                        final VersionOneProtocolChannelReceiver receiver = new VersionOneProtocolChannelReceiver(channel, deploymentRepository,\n                                EJBRemoteConnectorService.this.ejbRemoteTransactionsRepositoryInjectedValue.getValue(), groupMembershipNotifierRegistry,\n                                clientMappingRegistry, marshallerFactory, executorService.getValue());\n                        // trigger the receiving\n                        receiver.startReceiving();\n                        break;\n\n                    default:\n                        throw new RuntimeException(\"Cannot handle client version \" + version);\n                }\n\n            } catch (IOException e) {\n                // log it\n                log.errorf(e, \"Exception on channel %s from message %s\", channel, messageInputStream);\n                IoUtils.safeClose(channel);\n            } finally {\n                IoUtils.safeClose(messageInputStream);\n            }\n\n\n        }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        public void channelOpened(Channel channel) {\n            log.tracef(\"Welcome %s to the \" + EJB_CHANNEL_NAME + \" channel\", channel);\n            channel.addCloseHandler(new CloseHandler<Channel>() {\n                @Override\n                public void handleClose(Channel closed, IOException exception) {\n                    // do nothing\n                    log.tracef(\"channel %s closed\", closed);\n                }\n            });\n\n            // send the server version and supported marshalling types to the client\n            try {\n                EJBRemoteConnectorService.this.sendVersionMessage(channel);\n            } catch (IOException e) {\n                EjbLogger.EJB3_LOGGER.closingChannel(channel, e);\n                IoUtils.safeClose(channel);\n            }\n\n            // receive messages from the client\n            channel.receiveMessage(new ClientVersionMessageReceiver(this.serviceContainer));\n        }","id":74014,"modified_method":"@Override\n        public void channelOpened(Channel channel) {\n            log.tracef(\"Welcome %s to the \" + EJB_CHANNEL_NAME + \" channel\", channel);\n            channel.addCloseHandler(new CloseHandler<Channel>() {\n                @Override\n                public void handleClose(Channel closed, IOException exception) {\n                    // do nothing\n                    log.tracef(\"channel %s closed\", closed);\n                }\n            });\n\n            // send the server version and supported marshalling types to the client\n            try {\n                EJBRemoteConnectorService.this.sendVersionMessage(channel);\n            } catch (IOException e) {\n                EjbLogger.EJB3_LOGGER.closingChannel(channel, e);\n                IoUtils.safeClose(channel);\n            }\n\n            // receive messages from the client\n            channel.receiveMessage(new ClientVersionMessageReceiver());\n        }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void start(StartContext context) throws StartException {\n        final ServiceContainer serviceContainer = context.getController().getServiceContainer();\n        final OpenListener channelOpenListener = new ChannelOpenListener(serviceContainer);\n        try {\n            registration = endpointValue.getValue().registerService(EJB_CHANNEL_NAME, channelOpenListener, OptionMap.EMPTY);\n        } catch (ServiceRegistrationException e) {\n            throw new StartException(e);\n        }\n    }","id":74015,"modified_method":"@Override\n    public void start(StartContext context) throws StartException {\n        // populate the client-mapping cache which will be used for getting the client-mapping(s)\n        // of each node's EJB remoting connector's socketbining\n        this.populateClientMappingsCache();\n\n        // Register a EJB channel open listener\n        final OpenListener channelOpenListener = new ChannelOpenListener();\n        try {\n            registration = endpointValue.getValue().registerService(EJB_CHANNEL_NAME, channelOpenListener, OptionMap.EMPTY);\n        } catch (ServiceRegistrationException e) {\n            throw new StartException(e);\n        }\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"public EJBRemoteConnectorService(final byte serverProtocolVersion, final String[] supportedMarshallingStrategies) {\n        this.serverProtocolVersion = serverProtocolVersion;\n        this.supportedMarshallingStrategies = supportedMarshallingStrategies;\n        this.nodeName = SecurityActions.getSystemProperty(ServerEnvironment.NODE_NAME);\n    }","id":74016,"modified_method":"public EJBRemoteConnectorService(final byte serverProtocolVersion, final String[] supportedMarshallingStrategies) {\n        this.serverProtocolVersion = serverProtocolVersion;\n        this.supportedMarshallingStrategies = supportedMarshallingStrategies;\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"private List<ClientMapping> getClientMappings() {\n        final Registry<String, List<ClientMapping>> clientMappingsPerNode = this.clientMappingRegistryService.getValue();\n        // get the client mappings for this node\n        final List<ClientMapping> clientMappings = clientMappingsPerNode.getEntries().get(nodeName);\n        return clientMappings;\n    }","id":74017,"modified_method":"public Injector<Cache> getClientMappingsBackingCacheInjector() {\n        return this.clientMappingsBackingCache;\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"public Injector<Registry> getClientMappingRegistryServiceInjector() {\n        return this.clientMappingRegistryService;\n    }","id":74018,"modified_method":"public Injector<Registry> getClientMappingsRegistryServiceInjector() {\n        return this.clientMappingsRegistryService;\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void addDependencies(ServiceTarget target, ServiceBuilder<?> builder) {\n        ServiceName baseServiceName = EmbeddedCacheManagerService.getServiceName(null);\n        ServiceName serviceName = ServiceName.parse((this.cacheName != null) ? this.cacheName : DEFAULT_BACKING_CACHE);\n        if (!baseServiceName.isParentOf(serviceName)) {\n            serviceName = baseServiceName.append(serviceName);\n        }\n        if (serviceName.length() < 4) {\n            serviceName = serviceName.append(CacheContainer.DEFAULT_CACHE_NAME);\n        }\n        String container = serviceName.getParent().getSimpleName();\n        // install the GroupCommunicationService\n        new CoreGroupCommunicationServiceService(SCOPE_ID).build(target, container).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        new SharedLocalYieldingClusterLockManagerService(container).build(target).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        builder.addDependency(SharedLocalYieldingClusterLockManagerService.getServiceName(container), SharedLocalYieldingClusterLockManager.class, this.lockManager);\n        builder.addDependency(ServiceName.JBOSS.append(\"ejb\").append(\"remoting\").append(\"cluster-registry-service\"), Registry.class, this.registry);\n    }","id":74019,"modified_method":"@Override\n    public void addDependencies(ServiceTarget target, ServiceBuilder<?> builder) {\n        ServiceName baseServiceName = EmbeddedCacheManagerService.getServiceName(null);\n        ServiceName serviceName = ServiceName.parse((this.cacheName != null) ? this.cacheName : DEFAULT_BACKING_CACHE);\n        if (!baseServiceName.isParentOf(serviceName)) {\n            serviceName = baseServiceName.append(serviceName);\n        }\n        if (serviceName.length() < 4) {\n            serviceName = serviceName.append(CacheContainer.DEFAULT_CACHE_NAME);\n        }\n        String container = serviceName.getParent().getSimpleName();\n        // install the GroupCommunicationService\n        new CoreGroupCommunicationServiceService(SCOPE_ID).build(target, container).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        new SharedLocalYieldingClusterLockManagerService(container).build(target).setInitialMode(ServiceController.Mode.ON_DEMAND).install();\n        builder.addDependency(SharedLocalYieldingClusterLockManagerService.getServiceName(container), SharedLocalYieldingClusterLockManager.class, this.lockManager);\n        builder.addDependency(EJBRemoteConnectorService.EJB_REMOTE_CONNECTOR_CLIENT_MAPPINGS_REGISTRY_SERVICE, Registry.class, this.registry);\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Sends a cluster formation message for the passed clusters, over the remoting channel\n     *\n     * @param clusters The new clusters\n     * @throws IOException If any exception occurs while sending the message over the channel\n     */\n    private void sendNewClusterFormedMessage(final GroupMembershipNotifier... clusters) throws IOException {\n        final DataOutputStream outputStream = new DataOutputStream(this.channel.writeMessage());\n        final ClusterTopologyWriter clusterTopologyWriter = new ClusterTopologyWriter();\n        try {\n            logger.debug(\"Writing out cluster formation message for \" + clusters.length + \" clusters, to channel \" + this.channel);\n            clusterTopologyWriter.writeCompleteClusterTopology(outputStream, clusters);\n        } finally {\n            outputStream.close();\n        }\n    }","id":74020,"modified_method":"/**\n     * Sends a cluster formation message for the passed clusters, over the remoting channel\n     *\n     * @param clusters The new clusters\n     * @throws IOException If any exception occurs while sending the message over the channel\n     */\n    private void sendNewClusterFormedMessage(final GroupMembershipNotifier... clusters) throws IOException {\n        final DataOutputStream outputStream = new DataOutputStream(this.channel.writeMessage());\n        final ClusterTopologyWriter clusterTopologyWriter = new ClusterTopologyWriter();\n        try {\n            logger.debug(\"Writing out cluster formation message for \" + clusters.length + \" clusters, to channel \" + this.channel);\n            clusterTopologyWriter.writeCompleteClusterTopology(outputStream, clusters, this.clientMappingRegistry);\n        } finally {\n            outputStream.close();\n        }\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void sendClusterNodesAdded(final List<ClusterNode> addedNodes) throws IOException {\n            final DataOutputStream outputStream = new DataOutputStream(this.channelReceiver.channel.writeMessage());\n            final ClusterTopologyWriter clusterTopologyWriter = new ClusterTopologyWriter();\n            try {\n                logger.debug(addedNodes.size() + \" nodes added to cluster \" + clusterName + \", writing a protocol message to channel \" + this.channelReceiver.channel);\n                clusterTopologyWriter.writeNewNodesAdded(outputStream, clusterName, addedNodes);\n            } finally {\n                outputStream.close();\n            }\n\n        }","id":74021,"modified_method":"private void sendClusterNodesAdded(final List<ClusterNode> addedNodes) throws IOException {\n            final DataOutputStream outputStream = new DataOutputStream(this.channelReceiver.channel.writeMessage());\n            final ClusterTopologyWriter clusterTopologyWriter = new ClusterTopologyWriter();\n            try {\n                logger.debug(addedNodes.size() + \" nodes added to cluster \" + clusterName + \", writing a protocol message to channel \" + this.channelReceiver.channel);\n                clusterTopologyWriter.writeNewNodesAdded(outputStream, clusterName, addedNodes, VersionOneProtocolChannelReceiver.this.clientMappingRegistry);\n            } finally {\n                outputStream.close();\n            }\n\n        }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"public VersionOneProtocolChannelReceiver(final Channel channel, final DeploymentRepository deploymentRepository,\n                                             final EJBRemoteTransactionsRepository transactionsRepository, final GroupMembershipNotifierRegistry groupMembershipNotifierRegistry,\n                                             final List<ClientMapping> clientMappings, final MarshallerFactory marshallerFactory, final ExecutorService executorService) {\n        this.marshallerFactory = marshallerFactory;\n        this.channel = channel;\n        this.executorService = executorService;\n        this.deploymentRepository = deploymentRepository;\n        this.transactionsRepository = transactionsRepository;\n        this.groupMembershipNotifierRegistry = groupMembershipNotifierRegistry;\n        this.clientMappings = clientMappings;\n    }","id":74022,"modified_method":"public VersionOneProtocolChannelReceiver(final Channel channel, final DeploymentRepository deploymentRepository,\n                                             final EJBRemoteTransactionsRepository transactionsRepository, final GroupMembershipNotifierRegistry groupMembershipNotifierRegistry,\n                                             final Registry<String, List<ClientMapping>> clientMappingRegistry, final MarshallerFactory marshallerFactory, final ExecutorService executorService) {\n        this.marshallerFactory = marshallerFactory;\n        this.channel = channel;\n        this.executorService = executorService;\n        this.deploymentRepository = deploymentRepository;\n        this.transactionsRepository = transactionsRepository;\n        this.groupMembershipNotifierRegistry = groupMembershipNotifierRegistry;\n        this.clientMappingRegistry = clientMappingRegistry;\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Sends out a cluster removal message for the passed cluster, over the remoting channel\n     *\n     * @param cluster The cluster which was removed\n     * @throws IOException If any exception occurs while sending the message over the channel\n     */\n    private void sendClusterRemovedMessage(final GroupMembershipNotifier cluster) throws IOException {\n        final DataOutputStream outputStream = new DataOutputStream(this.channel.writeMessage());\n        final ClusterTopologyWriter clusterTopologyWriter = new ClusterTopologyWriter();\n        try {\n            logger.debug(\"Cluster \" + cluster.getGroupName() + \" removed, writing cluster removal message to channel \" + this.channel);\n            clusterTopologyWriter.writeClusterRemoved(outputStream, cluster);\n        } finally {\n            outputStream.close();\n        }\n    }","id":74023,"modified_method":"/**\n     * Sends out a cluster removal message for the passed cluster, over the remoting channel\n     *\n     * @param cluster The cluster which was removed\n     * @throws IOException If any exception occurs while sending the message over the channel\n     */\n    private void sendClusterRemovedMessage(final GroupMembershipNotifier cluster) throws IOException {\n        final DataOutputStream outputStream = new DataOutputStream(this.channel.writeMessage());\n        final ClusterTopologyWriter clusterTopologyWriter = new ClusterTopologyWriter();\n        try {\n            logger.debug(\"Cluster \" + cluster.getGroupName() + \" removed, writing cluster removal message to channel \" + this.channel);\n            clusterTopologyWriter.writeClusterRemoved(outputStream, new GroupMembershipNotifier[]{cluster});\n        } finally {\n            outputStream.close();\n        }\n    }","commit_id":"5c600beea37578c3fb837b60d0bfc8253f133561","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    void configureAdditionalDependencies(OperationContext context, ServiceBuilder<? extends ListenerService> serviceBuilder, ModelNode model, ListenerService service) throws OperationFailedException {\n        serviceBuilder.addDependency(HttpListenerAdd.REGISTRY_SERVICE_NAME, ListenerRegistry.class, ((HttpListenerService) service).getHttpListenerRegistry());\n        final String securityRealm = HttpsListenerResourceDefinition.SECURITY_REALM.resolveModelAttribute(context, model).asString();\n        SecurityRealm.ServiceUtil.addDependency(serviceBuilder, ((HttpsListenerService) service).getSecurityRealm(), securityRealm, false);\n    }","id":74024,"modified_method":"@Override\n    void configureAdditionalDependencies(OperationContext context, ServiceBuilder<? extends ListenerService> serviceBuilder, ModelNode model, ListenerService service) throws OperationFailedException {\n        serviceBuilder.addDependency(HttpListenerAdd.REGISTRY_SERVICE_NAME, ListenerRegistry.class, ((HttpListenerService) service).getHttpListenerRegistry());\n\n        ModelNode sslContextModel = HttpsListenerResourceDefinition.SSL_CONTEXT.resolveModelAttribute(context, model);\n        ModelNode securityRealmModel = HttpsListenerResourceDefinition.SECURITY_REALM.resolveModelAttribute(context, model);\n\n        final String sslContextRef = sslContextModel.isDefined() ? sslContextModel.asString() : null;\n        final String securityRealmRef = securityRealmModel.isDefined() ? securityRealmModel.asString() : null;\n\n        final InjectedValue<SSLContext> sslContextInjector = new InjectedValue<>();\n        final InjectedValue<SecurityRealm> securityRealmInjector = new InjectedValue<>();\n\n        if (securityRealmRef != null) {\n            SecurityRealm.ServiceUtil.addDependency(serviceBuilder, securityRealmInjector, securityRealmRef, false);\n        }\n\n        if (sslContextRef != null) {\n            String runtimeCapability = RuntimeCapability.buildDynamicCapabilityName(SSL_CONTEXT_CAPABILITY, sslContextRef);\n            ServiceName sslContextServiceName = context.getCapabilityServiceName(runtimeCapability, SSLContext.class);\n\n            serviceBuilder.addDependency(sslContextServiceName, SSLContext.class, sslContextInjector);\n        }\n\n        ((HttpsListenerService)service).setSSLContextSupplier(()-> {\n            if (sslContextRef != null) {\n                return sslContextInjector.getValue();\n            }\n\n            if (securityRealmRef != null) {\n                 SSLContext sslContext = securityRealmInjector.getValue().getSSLContext();\n\n                 if (sslContext == null) {\n                     throw UndertowLogger.ROOT_LOGGER.noSslContextInSecurityRealm(securityRealmRef);\n                 }\n                 return sslContext;\n            }\n\n            try {\n                return SSLContext.getDefault();\n            } catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n        });\n\n    }","commit_id":"44ffcce84815e114f8b41271cf586829724d4249","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        Collection<AttributeDefinition> res = new LinkedList<>(super.getAttributes());\n        res.add(SECURITY_REALM);\n        res.add(VERIFY_CLIENT);\n        res.add(ENABLED_CIPHER_SUITES);\n        res.add(ENABLED_PROTOCOLS);\n        res.add(ENABLE_HTTP2);\n        res.add(ENABLE_SPDY);\n        res.add(SSL_SESSION_CACHE_SIZE);\n        res.add(SSL_SESSION_TIMEOUT);\n        return res;\n    }","id":74025,"modified_method":"@Override\n    public Collection<AttributeDefinition> getAttributes() {\n        Collection<AttributeDefinition> res = new LinkedList<>(super.getAttributes());\n        res.add(SSL_CONTEXT);\n        res.add(SECURITY_REALM);\n        res.add(VERIFY_CLIENT);\n        res.add(ENABLED_CIPHER_SUITES);\n        res.add(ENABLED_PROTOCOLS);\n        res.add(ENABLE_HTTP2);\n        res.add(ENABLE_SPDY);\n        res.add(SSL_SESSION_CACHE_SIZE);\n        res.add(SSL_SESSION_TIMEOUT);\n        return res;\n    }","commit_id":"44ffcce84815e114f8b41271cf586829724d4249","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener) throws IOException {\n\n        SSLContext sslContext = securityRealm.getValue().getSSLContext();\n\n        if(sslContext == null) {\n            throw UndertowLogger.ROOT_LOGGER.noSslContextInSecurityRealm();\n        }\n\n        Builder builder = OptionMap.builder().addAll(commonOptions);\n        builder.addAll(socketOptions);\n        builder.set(Options.USE_DIRECT_BUFFERS, true);\n\n        if (cipherSuites != null) {\n            String[] cipherList = CipherSuiteSelector.fromString(cipherSuites).evaluate(sslContext.getSupportedSSLParameters().getCipherSuites());\n            builder.setSequence((Option<Sequence<String>>) HttpsListenerResourceDefinition.ENABLED_CIPHER_SUITES.getOption(), cipherList);\n        }\n\n        OptionMap combined = builder.getMap();\n\n        XnioSsl xnioSsl = new UndertowXnioSsl(worker.getXnio(), combined, sslContext);\n        sslServer = xnioSsl.createSslConnectionServer(worker, socketAddress, (ChannelListener) acceptListener, combined);\n        sslServer.resumeAccepts();\n\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"HTTPS\", getName(), NetworkUtils.formatIPAddressForURI(socketAddress.getAddress()), socketAddress.getPort());\n    }","id":74026,"modified_method":"@Override\n    protected void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener) throws IOException {\n        SSLContext sslContext = sslContextSupplier.get();\n        Builder builder = OptionMap.builder().addAll(commonOptions);\n        builder.addAll(socketOptions);\n        builder.set(Options.USE_DIRECT_BUFFERS, true);\n\n        if (cipherSuites != null) {\n            String[] cipherList = CipherSuiteSelector.fromString(cipherSuites).evaluate(sslContext.getSupportedSSLParameters().getCipherSuites());\n            builder.setSequence((Option<Sequence<String>>) HttpsListenerResourceDefinition.ENABLED_CIPHER_SUITES.getOption(), cipherList);\n        }\n\n        OptionMap combined = builder.getMap();\n\n        XnioSsl xnioSsl = new UndertowXnioSsl(worker.getXnio(), combined, sslContext);\n        sslServer = xnioSsl.createSslConnectionServer(worker, socketAddress, (ChannelListener) acceptListener, combined);\n        sslServer.resumeAccepts();\n\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"HTTPS\", getName(), NetworkUtils.formatIPAddressForURI(socketAddress.getAddress()), socketAddress.getPort());\n    }","commit_id":"44ffcce84815e114f8b41271cf586829724d4249","url":"https://github.com/wildfly/wildfly"},{"original_method":"private static void registerTransformers_3_0_0(SubsystemRegistration subsystemRegistration) {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n        builder.discardChildResource(PathElement.pathElement(Constants.APPLICATION_SECURITY_DOMAIN));\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, MODEL_VERSION_3_0_0);\n    }","id":74027,"modified_method":"private static void registerTransformers_3_0_0(SubsystemRegistration subsystemRegistration) {\n        final ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();\n\n        // Version 3.0.0 adds the new SSL_CONTEXT attribute, however it is mutually exclusive to the SECURITY_REALM attribute, both of which can\n        // now be set to 'undefined' so instead of rejecting a defined SSL_CONTEXT, reject an undefined SECURITY_REALM as that covers the\n        // two new combinations.\n        builder.addChildResource(UndertowExtension.HTTPS_LISTENER_PATH)\n            .getAttributeBuilder()\n                .addRejectCheck(RejectAttributeChecker.UNDEFINED, Constants.SECURITY_REALM)\n                .end();\n\n        builder.discardChildResource(PathElement.pathElement(Constants.APPLICATION_SECURITY_DOMAIN));\n        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, MODEL_VERSION_3_0_0);\n    }","commit_id":"44ffcce84815e114f8b41271cf586829724d4249","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n        protected void initializeExtraSubystemsAndModel(ExtensionRegistry extensionRegistry, Resource rootResource, ManagementResourceRegistration rootRegistration, RuntimeCapabilityRegistry capabilityRegistry) {\n            super.initializeExtraSubystemsAndModel(extensionRegistry, rootResource, rootRegistration, capabilityRegistry);\n            Map<String, Class> capabilities = new HashMap<>();\n            capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.IO_WORKER_CAPABILITY, ListenerResourceDefinition.WORKER.getDefaultValue().asString()), XnioWorker.class);\n            capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.IO_WORKER_CAPABILITY, \"non-default\"), XnioWorker.class);\n            capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.IO_BUFFER_POOL_CAPABILITY, ListenerResourceDefinition.BUFFER_POOL.getDefaultValue().asString()), Pool.class);\n            for (String entry : sockets.keySet()) {\n                capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.SOCKET_CAPABILITY, entry), SocketBinding.class);\n            }\n            capabilities.put(buildDynamicCapabilityName(\"org.wildfly.security.http-server-authentication\", \"elytron-factory\"), HttpAuthenticationFactory.class);\n            registerServiceCapabilities(capabilityRegistry, capabilities);\n\n        }","id":74028,"modified_method":"@Override\n        protected void initializeExtraSubystemsAndModel(ExtensionRegistry extensionRegistry, Resource rootResource, ManagementResourceRegistration rootRegistration, RuntimeCapabilityRegistry capabilityRegistry) {\n            super.initializeExtraSubystemsAndModel(extensionRegistry, rootResource, rootRegistration, capabilityRegistry);\n            Map<String, Class> capabilities = new HashMap<>();\n            capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.IO_WORKER_CAPABILITY, ListenerResourceDefinition.WORKER.getDefaultValue().asString()), XnioWorker.class);\n            capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.IO_WORKER_CAPABILITY, \"non-default\"), XnioWorker.class);\n            capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.IO_BUFFER_POOL_CAPABILITY, ListenerResourceDefinition.BUFFER_POOL.getDefaultValue().asString()), Pool.class);\n            for (String entry : sockets.keySet()) {\n                capabilities.put(buildDynamicCapabilityName(ListenerResourceDefinition.SOCKET_CAPABILITY, entry), SocketBinding.class);\n            }\n            capabilities.put(buildDynamicCapabilityName(\"org.wildfly.security.http-server-authentication\", \"elytron-factory\"), HttpAuthenticationFactory.class);\n            capabilities.put(buildDynamicCapabilityName(\"org.wildfly.security.ssl-context\", \"TestContext\"), SSLContext.class);\n            registerServiceCapabilities(capabilityRegistry, capabilities);\n\n        }","commit_id":"44ffcce84815e114f8b41271cf586829724d4249","url":"https://github.com/wildfly/wildfly"},{"original_method":"public DependencyResult createResolvedDependency(ModuleVersionSelector requested, ResolvedModuleVersionResult from, ResolvedModuleVersionResult selected) {\n        List<Object> key = asList(requested, from, selected);\n        if (!resolvedDependencies.containsKey(key)) {\n            resolvedDependencies.put(key, new DefaultResolvedDependencyResult(requested, selected, from));\n        }\n        return resolvedDependencies.get(key);\n    }","id":74029,"modified_method":"public ResolvedDependencyResult createResolvedDependency(ModuleVersionSelector requested, ResolvedModuleVersionResult from, ResolvedModuleVersionResult selected) {\n        List<Object> key = asList(requested, from, selected);\n        if (!resolvedDependencies.containsKey(key)) {\n            resolvedDependencies.put(key, new DefaultResolvedDependencyResult(requested, selected, from));\n        }\n        return resolvedDependencies.get(key);\n    }","commit_id":"80b196d07f92d439c082ec8570ccf2694c576eef","url":"https://github.com/gradle/gradle"},{"original_method":"public DependencyResult createUnresolvedDependency(ModuleVersionSelector requested, ResolvedModuleVersionResult from, Exception failure) {\n        List<Object> key = asList(requested, from);\n        if (!unresolvedDependencies.containsKey(key)) {\n            unresolvedDependencies.put(key, new DefaultUnresolvedDependencyResult(requested, failure, from));\n        }\n        return unresolvedDependencies.get(key);\n    }","id":74030,"modified_method":"public UnresolvedDependencyResult createUnresolvedDependency(ModuleVersionSelector requested, ResolvedModuleVersionResult from,\n                                                       @Nullable ResolvedModuleVersionResult selected, Exception failure) {\n        List<Object> key = asList(requested, from);\n        if (!unresolvedDependencies.containsKey(key)) {\n            unresolvedDependencies.put(key, new DefaultUnresolvedDependencyResult(requested, selected, from, failure));\n        }\n        return unresolvedDependencies.get(key);\n    }","commit_id":"80b196d07f92d439c082ec8570ccf2694c576eef","url":"https://github.com/gradle/gradle"},{"original_method":"public DefaultResolvedModuleVersionResult addDependent(ResolvedDependencyResult dependent) {\n        this.dependents.add(dependent);\n        return this;\n    }","id":74031,"modified_method":"public DefaultResolvedModuleVersionResult addDependent(DependencyResult dependent) {\n        this.dependents.add(dependent);\n        return this;\n    }","commit_id":"80b196d07f92d439c082ec8570ccf2694c576eef","url":"https://github.com/gradle/gradle"},{"original_method":"public Set<ResolvedDependencyResult> getDependents() {\n        return Collections.unmodifiableSet(dependents);\n    }","id":74032,"modified_method":"public Set<DependencyResult> getDependents() {\n        return Collections.unmodifiableSet(dependents);\n    }","commit_id":"80b196d07f92d439c082ec8570ccf2694c576eef","url":"https://github.com/gradle/gradle"},{"original_method":"public void resolvedConfiguration(ModuleVersionIdentifier id, Collection<? extends InternalDependencyResult> dependencies) {\n        for (InternalDependencyResult d : dependencies) {\n            DefaultResolvedModuleVersionResult from = modules.get(id);\n            if (from == null) {\n                throw new IllegalStateException(\"Something went wrong with building the dependency graph. Module [\" + id + \"] should have been visited.\");\n            }\n            if (d.getFailure() != null) {\n                from.addDependency(dependencyResultFactory.createUnresolvedDependency(d.getRequested(), from, d.getFailure()));\n            } else {\n                DefaultResolvedModuleVersionResult selected = createOrGet(d.getSelected().getSelectedId(), d.getSelected().getSelectionReason());\n                DependencyResult dependency = dependencyResultFactory.createResolvedDependency(d.getRequested(), from, selected);\n                from.addDependency(dependency);\n                selected.addDependent((ResolvedDependencyResult) dependency);\n            }\n        }\n    }","id":74033,"modified_method":"public void resolvedConfiguration(ModuleVersionIdentifier id, Collection<? extends InternalDependencyResult> dependencies) {\n        for (InternalDependencyResult d : dependencies) {\n            DefaultResolvedModuleVersionResult from = modules.get(id);\n            if (from == null) {\n                throw new IllegalStateException(\"Something went wrong with building the dependency graph. Module [\" + id + \"] should have been visited.\");\n            }\n            DefaultResolvedModuleVersionResult selected = createOrGet(d);\n            DependencyResult dependency;\n            if (d.getFailure() != null) {\n                dependency = dependencyResultFactory.createUnresolvedDependency(d.getRequested(), from, selected, d.getFailure());\n            } else {\n                dependency = dependencyResultFactory.createResolvedDependency(d.getRequested(), from, selected);\n            }\n            from.addDependency(dependency);\n            if (selected != null) {\n                selected.addDependent(dependency);\n            }\n        }\n    }","commit_id":"80b196d07f92d439c082ec8570ccf2694c576eef","url":"https://github.com/gradle/gradle"},{"original_method":"public HttpServletRequestData(final HttpServletRequest request) {\n    this.request = request;\n    Enumeration<String> _parameterNames = request.getParameterNames();\n    ArrayList<String> _list = Collections.<String>list(_parameterNames);\n    List<String> _unmodifiableList = Collections.<String>unmodifiableList(_list);\n    this.parameterKeys = _unmodifiableList;\n  }","id":74034,"modified_method":"public HttpServletRequestData(final HttpServletRequest request) {\n    this.request = request;\n    final Enumeration<String> paramNames = request.getParameterNames();\n    final HashSet<String> set = CollectionLiterals.<String>newHashSet();\n    while (paramNames.hasMoreElements()) {\n      String _nextElement = paramNames.nextElement();\n      set.add(_nextElement);\n    }\n    Set<String> _unmodifiableSet = Collections.<String>unmodifiableSet(set);\n    this.parameterKeys = _unmodifiableSet;\n    this.metadataKeys = Collections.<String>unmodifiableSet(CollectionLiterals.<String>newHashSet(IRequestData.REQUEST_TYPE, \"authType\", \"characterEncoding\", \"contentType\", \"contextPath\", \"localAddr\", \"localName\", \"localPort\", \"method\", \"pathInfo\", \"pathTranslated\", \"protocol\", \"queryString\", \"remoteAddr\", \"remoteHost\", \"remotePort\", \"remoteUser\", \"requestedSessionId\", \"requestURI\", \"scheme\", \"serverName\", \"serverPort\", \"servletPath\"));\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public Collection<String> getMetadataKeys() {\n    return Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(IRequestData.METADATA_REQUEST_TYPE, \"authType\", \"characterEncoding\", \"contentType\", \"contextPath\", \"localAddr\", \"localName\", \"localPort\", \"method\", \"pathInfo\", \"pathTranslated\", \"protocol\", \"queryString\", \"remoteAddr\", \"remoteHost\", \"remotePort\", \"remoteUser\", \"requestedSessionId\", \"requestURI\", \"scheme\", \"serverName\", \"serverPort\", \"servletPath\"));\n  }","id":74035,"modified_method":"@Pure\n  public Collection<String> getMetadataKeys() {\n    return this.metadataKeys;\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public String getMetadata(final String key) {\n    String _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (Objects.equal(key, IRequestData.METADATA_REQUEST_TYPE)) {\n        _matched=true;\n        String _pathInfo = this.request.getPathInfo();\n        String _substring = null;\n        if (_pathInfo!=null) {\n          _substring=_pathInfo.substring(1);\n        }\n        _switchResult = _substring;\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"authType\")) {\n        _matched=true;\n        _switchResult = this.request.getAuthType();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"characterEncoding\")) {\n        _matched=true;\n        _switchResult = this.request.getCharacterEncoding();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"contentType\")) {\n        _matched=true;\n        _switchResult = this.request.getContentType();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"contextPath\")) {\n        _matched=true;\n        _switchResult = this.request.getContextPath();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"localAddr\")) {\n        _matched=true;\n        _switchResult = this.request.getLocalAddr();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"localName\")) {\n        _matched=true;\n        _switchResult = this.request.getLocalName();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"localPort\")) {\n        _matched=true;\n        int _localPort = this.request.getLocalPort();\n        _switchResult = Integer.valueOf(_localPort).toString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"method\")) {\n        _matched=true;\n        _switchResult = this.request.getMethod();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"pathInfo\")) {\n        _matched=true;\n        _switchResult = this.request.getPathInfo();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"pathTranslated\")) {\n        _matched=true;\n        _switchResult = this.request.getPathTranslated();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"protocol\")) {\n        _matched=true;\n        _switchResult = this.request.getProtocol();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"queryString\")) {\n        _matched=true;\n        _switchResult = this.request.getQueryString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remoteAddr\")) {\n        _matched=true;\n        _switchResult = this.request.getRemoteAddr();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remoteHost\")) {\n        _matched=true;\n        _switchResult = this.request.getRemoteHost();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remotePort\")) {\n        _matched=true;\n        int _remotePort = this.request.getRemotePort();\n        _switchResult = Integer.valueOf(_remotePort).toString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remoteUser\")) {\n        _matched=true;\n        _switchResult = this.request.getRemoteUser();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"requestedSessionId\")) {\n        _matched=true;\n        _switchResult = this.request.getRequestedSessionId();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"requestURI\")) {\n        _matched=true;\n        _switchResult = this.request.getRequestURI();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"scheme\")) {\n        _matched=true;\n        _switchResult = this.request.getScheme();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"serverName\")) {\n        _matched=true;\n        _switchResult = this.request.getServerName();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"serverPort\")) {\n        _matched=true;\n        int _serverPort = this.request.getServerPort();\n        _switchResult = Integer.valueOf(_serverPort).toString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"servletPath\")) {\n        _matched=true;\n        _switchResult = this.request.getServletPath();\n      }\n    }\n    return _switchResult;\n  }","id":74036,"modified_method":"@Override\n  public String getMetadata(final String key) {\n    String _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (Objects.equal(key, IRequestData.REQUEST_TYPE)) {\n        _matched=true;\n        String _pathInfo = this.request.getPathInfo();\n        String _substring = null;\n        if (_pathInfo!=null) {\n          _substring=_pathInfo.substring(1);\n        }\n        _switchResult = _substring;\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"authType\")) {\n        _matched=true;\n        _switchResult = this.request.getAuthType();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"characterEncoding\")) {\n        _matched=true;\n        _switchResult = this.request.getCharacterEncoding();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"contentType\")) {\n        _matched=true;\n        _switchResult = this.request.getContentType();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"contextPath\")) {\n        _matched=true;\n        _switchResult = this.request.getContextPath();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"localAddr\")) {\n        _matched=true;\n        _switchResult = this.request.getLocalAddr();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"localName\")) {\n        _matched=true;\n        _switchResult = this.request.getLocalName();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"localPort\")) {\n        _matched=true;\n        int _localPort = this.request.getLocalPort();\n        _switchResult = Integer.valueOf(_localPort).toString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"method\")) {\n        _matched=true;\n        _switchResult = this.request.getMethod();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"pathInfo\")) {\n        _matched=true;\n        _switchResult = this.request.getPathInfo();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"pathTranslated\")) {\n        _matched=true;\n        _switchResult = this.request.getPathTranslated();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"protocol\")) {\n        _matched=true;\n        _switchResult = this.request.getProtocol();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"queryString\")) {\n        _matched=true;\n        _switchResult = this.request.getQueryString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remoteAddr\")) {\n        _matched=true;\n        _switchResult = this.request.getRemoteAddr();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remoteHost\")) {\n        _matched=true;\n        _switchResult = this.request.getRemoteHost();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remotePort\")) {\n        _matched=true;\n        int _remotePort = this.request.getRemotePort();\n        _switchResult = Integer.valueOf(_remotePort).toString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"remoteUser\")) {\n        _matched=true;\n        _switchResult = this.request.getRemoteUser();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"requestedSessionId\")) {\n        _matched=true;\n        _switchResult = this.request.getRequestedSessionId();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"requestURI\")) {\n        _matched=true;\n        _switchResult = this.request.getRequestURI();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"scheme\")) {\n        _matched=true;\n        _switchResult = this.request.getScheme();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"serverName\")) {\n        _matched=true;\n        _switchResult = this.request.getServerName();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"serverPort\")) {\n        _matched=true;\n        int _serverPort = this.request.getServerPort();\n        _switchResult = Integer.valueOf(_serverPort).toString();\n      }\n    }\n    if (!_matched) {\n      if (Objects.equal(key, \"servletPath\")) {\n        _matched=true;\n        _switchResult = this.request.getServletPath();\n      }\n    }\n    return _switchResult;\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public Collection<String> getMetadataKeys() {\n    return Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(IRequestData.METADATA_REQUEST_TYPE));\n  }","id":74037,"modified_method":"@Override\n  public Collection<String> getMetadataKeys() {\n    return Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(IRequestData.REQUEST_TYPE));\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public String getMetadata(final String key) {\n    String _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (Objects.equal(key, IRequestData.METADATA_REQUEST_TYPE)) {\n        _matched=true;\n        _switchResult = this.requestType;\n      }\n    }\n    return _switchResult;\n  }","id":74038,"modified_method":"@Override\n  public String getMetadata(final String key) {\n    String _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (Objects.equal(key, IRequestData.REQUEST_TYPE)) {\n        _matched=true;\n        _switchResult = this.requestType;\n      }\n    }\n    return _switchResult;\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public Collection<String> getMetadataKeys() {\n    return Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(IRequestData.METADATA_REQUEST_TYPE));\n  }","id":74039,"modified_method":"@Override\n  public Collection<String> getMetadataKeys() {\n    return Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(IRequestData.REQUEST_TYPE));\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n  public String getMetadata(final String key) {\n    String _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (Objects.equal(key, IRequestData.METADATA_REQUEST_TYPE)) {\n        _matched=true;\n        _switchResult = this.requestType;\n      }\n    }\n    return _switchResult;\n  }","id":74040,"modified_method":"@Override\n  public String getMetadata(final String key) {\n    String _switchResult = null;\n    boolean _matched = false;\n    if (!_matched) {\n      if (Objects.equal(key, IRequestData.REQUEST_TYPE)) {\n        _matched=true;\n        _switchResult = this.requestType;\n      }\n    }\n    return _switchResult;\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"public XtextServiceDispatcher.ServiceDescriptor getService(final IRequestData request, final ISessionStore sessionStore) throws InvalidRequestException {\n    XtextServiceDispatcher.ServiceDescriptor _xblockexpression = null;\n    {\n      String _elvis = null;\n      String _metadata = request.getMetadata(IRequestData.METADATA_REQUEST_TYPE);\n      if (_metadata != null) {\n        _elvis = _metadata;\n      } else {\n        _elvis = \"\";\n      }\n      final String requestType = _elvis;\n      boolean _isTraceEnabled = XtextServiceDispatcher.LOG.isTraceEnabled();\n      if (_isTraceEnabled) {\n        Collection<String> _parameterKeys = request.getParameterKeys();\n        List<String> _sort = IterableExtensions.<String>sort(_parameterKeys);\n        final Function1<String, CharSequence> _function = new Function1<String, CharSequence>() {\n          @Override\n          public CharSequence apply(final String key) {\n            String _xblockexpression = null;\n            {\n              final String value = request.getParameter(key);\n              String _xifexpression = null;\n              int _length = value.length();\n              boolean _greaterThan = (_length > 18);\n              if (_greaterThan) {\n                String _substring = value.substring(0, 16);\n                String _plus = ((key + \"=\\'\") + _substring);\n                _xifexpression = (_plus + \"...\\'\");\n              } else {\n                String _xifexpression_1 = null;\n                boolean _matches = value.matches(\".*\\\\s+.*\");\n                if (_matches) {\n                  _xifexpression_1 = (((key + \"=\\'\") + value) + \"\\'\");\n                } else {\n                  _xifexpression_1 = ((key + \"=\") + value);\n                }\n                _xifexpression = _xifexpression_1;\n              }\n              _xblockexpression = _xifexpression;\n            }\n            return _xblockexpression;\n          }\n        };\n        String _join = IterableExtensions.<String>join(_sort, \": \", \", \", \"\", _function);\n        final String stringParams = _join.replaceAll(\"(\\\\n|\\\\f|\\\\r)+\", \" \");\n        XtextServiceDispatcher.LOG.trace(((\"xtext-service/\" + requestType) + stringParams));\n      }\n      XtextServiceDispatcher.ServiceDescriptor _xtrycatchfinallyexpression = null;\n      try {\n        XtextServiceDispatcher.ServiceDescriptor _createServiceDescriptor = this.createServiceDescriptor(requestType, request, sessionStore);\n        final Procedure1<XtextServiceDispatcher.ServiceDescriptor> _function_1 = new Procedure1<XtextServiceDispatcher.ServiceDescriptor>() {\n          @Override\n          public void apply(final XtextServiceDispatcher.ServiceDescriptor it) {\n            it.type = requestType;\n          }\n        };\n        _xtrycatchfinallyexpression = ObjectExtensions.<XtextServiceDispatcher.ServiceDescriptor>operator_doubleArrow(_createServiceDescriptor, _function_1);\n      } catch (final Throwable _t) {\n        if (_t instanceof InvalidRequestException) {\n          final InvalidRequestException ire = (InvalidRequestException)_t;\n          InvalidRequestException.Type _type = ire.getType();\n          boolean _equals = Objects.equal(_type, InvalidRequestException.Type.INVALID_DOCUMENT_STATE);\n          if (_equals) {\n            XtextServiceDispatcher.LOG.trace(((\"Invalid document state (\" + requestType) + \")\"));\n            XtextServiceDispatcher.ServiceDescriptor _serviceDescriptor = new XtextServiceDispatcher.ServiceDescriptor();\n            final Procedure1<XtextServiceDispatcher.ServiceDescriptor> _function_2 = new Procedure1<XtextServiceDispatcher.ServiceDescriptor>() {\n              @Override\n              public void apply(final XtextServiceDispatcher.ServiceDescriptor it) {\n                it.type = requestType;\n                final Function0<IServiceResult> _function = new Function0<IServiceResult>() {\n                  @Override\n                  public IServiceResult apply() {\n                    return new ServiceConflictResult(\"invalidStateId\");\n                  }\n                };\n                it.service = _function;\n                it.hasConflict = true;\n              }\n            };\n            return ObjectExtensions.<XtextServiceDispatcher.ServiceDescriptor>operator_doubleArrow(_serviceDescriptor, _function_2);\n          }\n          throw ire;\n        } else {\n          throw Exceptions.sneakyThrow(_t);\n        }\n      }\n      _xblockexpression = _xtrycatchfinallyexpression;\n    }\n    return _xblockexpression;\n  }","id":74041,"modified_method":"public XtextServiceDispatcher.ServiceDescriptor getService(final IRequestData request, final ISessionStore sessionStore) throws InvalidRequestException {\n    XtextServiceDispatcher.ServiceDescriptor _xblockexpression = null;\n    {\n      String _xifexpression = null;\n      Collection<String> _parameterKeys = request.getParameterKeys();\n      boolean _contains = _parameterKeys.contains(IRequestData.REQUEST_TYPE);\n      if (_contains) {\n        _xifexpression = request.getParameter(IRequestData.REQUEST_TYPE);\n      } else {\n        _xifexpression = request.getMetadata(IRequestData.REQUEST_TYPE);\n      }\n      final String requestType = _xifexpression;\n      if ((requestType == null)) {\n        throw new InvalidRequestException(InvalidRequestException.Type.INVALID_PARAMETERS, \"The parameter \\'requestType\\' is required.\");\n      }\n      boolean _isTraceEnabled = XtextServiceDispatcher.LOG.isTraceEnabled();\n      if (_isTraceEnabled) {\n        Collection<String> _parameterKeys_1 = request.getParameterKeys();\n        List<String> _sort = IterableExtensions.<String>sort(_parameterKeys_1);\n        final Function1<String, CharSequence> _function = new Function1<String, CharSequence>() {\n          @Override\n          public CharSequence apply(final String key) {\n            String _xblockexpression = null;\n            {\n              final String value = request.getParameter(key);\n              String _xifexpression = null;\n              int _length = value.length();\n              boolean _greaterThan = (_length > 18);\n              if (_greaterThan) {\n                String _substring = value.substring(0, 16);\n                String _plus = ((key + \"=\\'\") + _substring);\n                _xifexpression = (_plus + \"...\\'\");\n              } else {\n                String _xifexpression_1 = null;\n                boolean _matches = value.matches(\".*\\\\s+.*\");\n                if (_matches) {\n                  _xifexpression_1 = (((key + \"=\\'\") + value) + \"\\'\");\n                } else {\n                  _xifexpression_1 = ((key + \"=\") + value);\n                }\n                _xifexpression = _xifexpression_1;\n              }\n              _xblockexpression = _xifexpression;\n            }\n            return _xblockexpression;\n          }\n        };\n        String _join = IterableExtensions.<String>join(_sort, \": \", \", \", \"\", _function);\n        final String stringParams = _join.replaceAll(\"(\\\\n|\\\\f|\\\\r)+\", \" \");\n        XtextServiceDispatcher.LOG.trace(((\"xtext-service/\" + requestType) + stringParams));\n      }\n      XtextServiceDispatcher.ServiceDescriptor _xtrycatchfinallyexpression = null;\n      try {\n        XtextServiceDispatcher.ServiceDescriptor _createServiceDescriptor = this.createServiceDescriptor(requestType, request, sessionStore);\n        final Procedure1<XtextServiceDispatcher.ServiceDescriptor> _function_1 = new Procedure1<XtextServiceDispatcher.ServiceDescriptor>() {\n          @Override\n          public void apply(final XtextServiceDispatcher.ServiceDescriptor it) {\n            it.type = requestType;\n          }\n        };\n        _xtrycatchfinallyexpression = ObjectExtensions.<XtextServiceDispatcher.ServiceDescriptor>operator_doubleArrow(_createServiceDescriptor, _function_1);\n      } catch (final Throwable _t) {\n        if (_t instanceof InvalidRequestException) {\n          final InvalidRequestException ire = (InvalidRequestException)_t;\n          InvalidRequestException.Type _type = ire.getType();\n          boolean _equals = Objects.equal(_type, InvalidRequestException.Type.INVALID_DOCUMENT_STATE);\n          if (_equals) {\n            XtextServiceDispatcher.LOG.trace(((\"Invalid document state (\" + requestType) + \")\"));\n            XtextServiceDispatcher.ServiceDescriptor _serviceDescriptor = new XtextServiceDispatcher.ServiceDescriptor();\n            final Procedure1<XtextServiceDispatcher.ServiceDescriptor> _function_2 = new Procedure1<XtextServiceDispatcher.ServiceDescriptor>() {\n              @Override\n              public void apply(final XtextServiceDispatcher.ServiceDescriptor it) {\n                it.type = requestType;\n                final Function0<IServiceResult> _function = new Function0<IServiceResult>() {\n                  @Override\n                  public IServiceResult apply() {\n                    return new ServiceConflictResult(\"invalidStateId\");\n                  }\n                };\n                it.service = _function;\n                it.hasConflict = true;\n              }\n            };\n            return ObjectExtensions.<XtextServiceDispatcher.ServiceDescriptor>operator_doubleArrow(_serviceDescriptor, _function_2);\n          }\n          throw ire;\n        } else {\n          throw Exceptions.sneakyThrow(_t);\n        }\n      }\n      _xblockexpression = _xtrycatchfinallyexpression;\n    }\n    return _xblockexpression;\n  }","commit_id":"8ce30c72b2d3b13f36dfb7acd12e6a01f43b5ae4","url":"https://github.com/eclipse/xtext"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLCreateEdge parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    parserRequiredKeyword(\"CREATE\");\r\n    parserRequiredKeyword(\"EDGE\");\r\n\r\n    String className = null;\r\n\r\n    String temp = parseOptionalWord(true);\r\n\r\n    while (temp != null) {\r\n      if (temp.equals(\"CLUSTER\")) {\r\n        clusterName = parserRequiredWord(false);\r\n\r\n      } else if (temp.equals(KEYWORD_FROM)) {\r\n        from = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\r\n\r\n      } else if (temp.equals(\"TO\")) {\r\n        to = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\r\n\r\n      } else if (temp.equals(KEYWORD_SET)) {\r\n        fields = new LinkedHashMap<String, Object>();\r\n        parseSetFields(fields);\r\n\r\n      } else if (temp.equals(KEYWORD_CONTENT)) {\r\n        parseContent();\r\n\r\n      } else if (temp.equals(KEYWORD_RETRY)) {\r\n        parseRetry();\r\n\r\n      } else if (className == null && temp.length() > 0)\r\n        className = temp;\r\n\r\n      temp = parseOptionalWord(true);\r\n      if (parserIsEnded())\r\n        break;\r\n    }\r\n\r\n    if (className == null)\r\n      // ASSIGN DEFAULT CLASS\r\n      className = \"E\";\r\n\r\n    // GET/CHECK CLASS NAME\r\n    clazz = ((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().getClass(className);\r\n    if (clazz == null)\r\n      throw new OCommandSQLParsingException(\"Class \" + className + \" was not found\");\r\n\r\n    return this;\r\n  }","id":74042,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLCreateEdge parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    parserRequiredKeyword(\"CREATE\");\r\n    parserRequiredKeyword(\"EDGE\");\r\n\r\n    String className = null;\r\n\r\n    String temp = parseOptionalWord(true);\r\n\r\n    while (temp != null) {\r\n      if (temp.equals(\"CLUSTER\")) {\r\n        clusterName = parserRequiredWord(false);\r\n\r\n      } else if (temp.equals(KEYWORD_FROM)) {\r\n        from = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\r\n\r\n      } else if (temp.equals(\"TO\")) {\r\n        to = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\r\n\r\n      } else if (temp.equals(KEYWORD_SET)) {\r\n        fields = new LinkedHashMap<String, Object>();\r\n        parseSetFields(clazz, fields);\r\n\r\n      } else if (temp.equals(KEYWORD_CONTENT)) {\r\n        parseContent();\r\n\r\n      } else if (temp.equals(KEYWORD_RETRY)) {\r\n        parseRetry();\r\n\r\n      } else if (className == null && temp.length() > 0) {\r\n        className = temp;\r\n        clazz = ((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().getClass(className);\r\n      }\r\n\r\n      temp = parseOptionalWord(true);\r\n      if (parserIsEnded())\r\n        break;\r\n    }\r\n\r\n    if (className == null) {\r\n      // ASSIGN DEFAULT CLASS\r\n      className = \"E\";\r\n      clazz = ((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().getClass(className);\r\n    }\r\n\r\n    // GET/CHECK CLASS NAME\r\n    if (clazz == null)\r\n      throw new OCommandSQLParsingException(\"Class '\" + className + \"' was not found\");\r\n\r\n    return this;\r\n  }","commit_id":"142e586a3927d7ab13a63cd5e353dc257d0d995b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLCreateVertex parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    String className = null;\r\n\r\n    parserRequiredKeyword(\"CREATE\");\r\n    parserRequiredKeyword(\"VERTEX\");\r\n\r\n    String temp = parseOptionalWord(true);\r\n\r\n    while (temp != null) {\r\n      if (temp.equals(\"CLUSTER\")) {\r\n        clusterName = parserRequiredWord(false);\r\n\r\n      } else if (temp.equals(KEYWORD_SET)) {\r\n        fields = new LinkedHashMap<String, Object>();\r\n        parseSetFields(fields);\r\n\r\n      } else if (temp.equals(KEYWORD_CONTENT)) {\r\n        parseContent();\r\n\r\n      } else if (className == null && temp.length() > 0)\r\n        className = temp;\r\n\r\n      temp = parserOptionalWord(true);\r\n      if (parserIsEnded())\r\n        break;\r\n    }\r\n\r\n    if (className == null)\r\n      // ASSIGN DEFAULT CLASS\r\n      className = \"V\";\r\n\r\n    // GET/CHECK CLASS NAME\r\n    clazz = ((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().getClass(className);\r\n    if (clazz == null)\r\n      throw new OCommandSQLParsingException(\"Class \" + className + \" was not found\");\r\n\r\n    return this;\r\n  }","id":74043,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLCreateVertex parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    String className = null;\r\n\r\n    parserRequiredKeyword(\"CREATE\");\r\n    parserRequiredKeyword(\"VERTEX\");\r\n\r\n    String temp = parseOptionalWord(true);\r\n\r\n    while (temp != null) {\r\n      if (temp.equals(\"CLUSTER\")) {\r\n        clusterName = parserRequiredWord(false);\r\n\r\n      } else if (temp.equals(KEYWORD_SET)) {\r\n        fields = new LinkedHashMap<String, Object>();\r\n        parseSetFields(clazz, fields);\r\n\r\n      } else if (temp.equals(KEYWORD_CONTENT)) {\r\n        parseContent();\r\n\r\n      } else if (className == null && temp.length() > 0)\r\n        className = temp;\r\n\r\n      temp = parserOptionalWord(true);\r\n      if (parserIsEnded())\r\n        break;\r\n    }\r\n\r\n    if (className == null)\r\n      // ASSIGN DEFAULT CLASS\r\n      className = \"V\";\r\n\r\n    // GET/CHECK CLASS NAME\r\n    clazz = ((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().getClass(className);\r\n    if (clazz == null)\r\n      throw new OCommandSQLParsingException(\"Class '\" + className + \"' was not found\");\r\n\r\n    return this;\r\n  }","commit_id":"142e586a3927d7ab13a63cd5e353dc257d0d995b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLInsert parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    className = null;\r\n    newRecords = null;\r\n    content = null;\r\n\r\n    if (parserTextUpperCase.endsWith(KEYWORD_UNSAFE)) {\r\n      unsafe = true;\r\n      parserText = parserText.substring(0, parserText.length() - KEYWORD_UNSAFE.length() - 1);\r\n      parserTextUpperCase = parserTextUpperCase.substring(0, parserTextUpperCase.length() - KEYWORD_UNSAFE.length() - 1);\r\n    }\r\n\r\n    parserRequiredKeyword(\"INSERT\");\r\n    parserRequiredKeyword(\"INTO\");\r\n\r\n    String subjectName = parserRequiredWord(true, \"Invalid subject name. Expected cluster, class or index\");\r\n    if (subjectName.startsWith(OCommandExecutorSQLAbstract.CLUSTER_PREFIX))\r\n      // CLUSTER\r\n      clusterName = subjectName.substring(OCommandExecutorSQLAbstract.CLUSTER_PREFIX.length());\r\n\r\n    else if (subjectName.startsWith(OCommandExecutorSQLAbstract.INDEX_PREFIX))\r\n      // INDEX\r\n      indexName = subjectName.substring(OCommandExecutorSQLAbstract.INDEX_PREFIX.length());\r\n\r\n    else {\r\n      // CLASS\r\n      if (subjectName.startsWith(OCommandExecutorSQLAbstract.CLASS_PREFIX))\r\n        subjectName = subjectName.substring(OCommandExecutorSQLAbstract.CLASS_PREFIX.length());\r\n\r\n      final OClass cls = ((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().getClass(subjectName);\r\n      if (cls == null)\r\n        throwParsingException(\"Class \" + subjectName + \" not found in database\");\r\n\r\n      if (!unsafe && cls.isSubClassOf(\"E\"))\r\n        // FOUND EDGE\r\n        throw new OCommandExecutionException(\r\n            \"'INSERT' command cannot create Edges. Use 'CREATE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\");\r\n\r\n      className = cls.getName();\r\n    }\r\n\r\n    parserSkipWhiteSpaces();\r\n    if (parserIsEnded())\r\n      throwSyntaxErrorException(\"Set of fields is missed. Example: (name, surname) or SET name = 'Bill'\");\r\n\r\n    final String temp = parseOptionalWord(true);\r\n    if (temp.equals(\"CLUSTER\")) {\r\n      clusterName = parserRequiredWord(false);\r\n\r\n      parserSkipWhiteSpaces();\r\n      if (parserIsEnded())\r\n        throwSyntaxErrorException(\"Set of fields is missed. Example: (name, surname) or SET name = 'Bill'\");\r\n    } else\r\n      parserGoBack();\r\n\r\n    newRecords = new ArrayList<Map<String, Object>>();\r\n    Boolean sourceClauseProcessed = false;\r\n    if (parserGetCurrentChar() == '(') {\r\n      parseValues();\r\n      parserNextWord(true, \" \\r\\n\");\r\n      sourceClauseProcessed = true;\r\n    } else {\r\n      parserNextWord(true, \" ,\\r\\n\");\r\n\r\n      if (parserGetLastWord().equals(KEYWORD_CONTENT)) {\r\n        newRecords = null;\r\n        parseContent();\r\n        sourceClauseProcessed = true;\r\n      } else if (parserGetLastWord().equals(KEYWORD_SET)) {\r\n        final LinkedHashMap<String, Object> fields = new LinkedHashMap<String, Object>();\r\n        newRecords.add(fields);\r\n        parseSetFields(fields);\r\n        sourceClauseProcessed = true;\r\n      }\r\n    }\r\n    if (sourceClauseProcessed)\r\n      parserNextWord(true, \" \\r\\n\");\r\n    // it has to be processed before KEYWORD_FROM in order to not be taken as part of SELECT\r\n    if (parserGetLastWord().equals(KEYWORD_RETURN)) {\r\n      parseReturn(!sourceClauseProcessed);\r\n      parserNextWord(true, \" \\r\\n\");\r\n    }\r\n\r\n    if (!sourceClauseProcessed) {\r\n      if (parserGetLastWord().equals(KEYWORD_FROM)) {\r\n        newRecords = null;\r\n        subQuery = new OSQLAsynchQuery<OIdentifiable>(parserText.substring(parserGetCurrentPosition()), this);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }","id":74044,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLInsert parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    className = null;\r\n    newRecords = null;\r\n    content = null;\r\n\r\n    if (parserTextUpperCase.endsWith(KEYWORD_UNSAFE)) {\r\n      unsafe = true;\r\n      parserText = parserText.substring(0, parserText.length() - KEYWORD_UNSAFE.length() - 1);\r\n      parserTextUpperCase = parserTextUpperCase.substring(0, parserTextUpperCase.length() - KEYWORD_UNSAFE.length() - 1);\r\n    }\r\n\r\n    parserRequiredKeyword(\"INSERT\");\r\n    parserRequiredKeyword(\"INTO\");\r\n\r\n    String subjectName = parserRequiredWord(true, \"Invalid subject name. Expected cluster, class or index\");\r\n    if (subjectName.startsWith(OCommandExecutorSQLAbstract.CLUSTER_PREFIX))\r\n      // CLUSTER\r\n      clusterName = subjectName.substring(OCommandExecutorSQLAbstract.CLUSTER_PREFIX.length());\r\n\r\n    else if (subjectName.startsWith(OCommandExecutorSQLAbstract.INDEX_PREFIX))\r\n      // INDEX\r\n      indexName = subjectName.substring(OCommandExecutorSQLAbstract.INDEX_PREFIX.length());\r\n\r\n    else {\r\n      // CLASS\r\n      if (subjectName.startsWith(OCommandExecutorSQLAbstract.CLASS_PREFIX))\r\n        subjectName = subjectName.substring(OCommandExecutorSQLAbstract.CLASS_PREFIX.length());\r\n\r\n      final OClass cls = ((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().getClass(subjectName);\r\n      if (cls == null)\r\n        throwParsingException(\"Class \" + subjectName + \" not found in database\");\r\n\r\n      if (!unsafe && cls.isSubClassOf(\"E\"))\r\n        // FOUND EDGE\r\n        throw new OCommandExecutionException(\r\n            \"'INSERT' command cannot create Edges. Use 'CREATE EDGE' command instead, or apply the 'UNSAFE' keyword to force it\");\r\n\r\n      className = cls.getName();\r\n      clazz = database.getMetadata().getSchema().getClass(className);\r\n      if (clazz == null)\r\n        throw new OQueryParsingException(\"Class '\" + className + \"' was not found\");\r\n    }\r\n\r\n    parserSkipWhiteSpaces();\r\n    if (parserIsEnded())\r\n      throwSyntaxErrorException(\"Set of fields is missed. Example: (name, surname) or SET name = 'Bill'\");\r\n\r\n    final String temp = parseOptionalWord(true);\r\n    if (temp.equals(\"CLUSTER\")) {\r\n      clusterName = parserRequiredWord(false);\r\n\r\n      parserSkipWhiteSpaces();\r\n      if (parserIsEnded())\r\n        throwSyntaxErrorException(\"Set of fields is missed. Example: (name, surname) or SET name = 'Bill'\");\r\n    } else\r\n      parserGoBack();\r\n\r\n    newRecords = new ArrayList<Map<String, Object>>();\r\n    Boolean sourceClauseProcessed = false;\r\n    if (parserGetCurrentChar() == '(') {\r\n      parseValues();\r\n      parserNextWord(true, \" \\r\\n\");\r\n      sourceClauseProcessed = true;\r\n    } else {\r\n      parserNextWord(true, \" ,\\r\\n\");\r\n\r\n      if (parserGetLastWord().equals(KEYWORD_CONTENT)) {\r\n        newRecords = null;\r\n        parseContent();\r\n        sourceClauseProcessed = true;\r\n      } else if (parserGetLastWord().equals(KEYWORD_SET)) {\r\n        final LinkedHashMap<String, Object> fields = new LinkedHashMap<String, Object>();\r\n        newRecords.add(fields);\r\n        parseSetFields(clazz, fields);\r\n        sourceClauseProcessed = true;\r\n      }\r\n    }\r\n    if (sourceClauseProcessed)\r\n      parserNextWord(true, \" \\r\\n\");\r\n    // it has to be processed before KEYWORD_FROM in order to not be taken as part of SELECT\r\n    if (parserGetLastWord().equals(KEYWORD_RETURN)) {\r\n      parseReturn(!sourceClauseProcessed);\r\n      parserNextWord(true, \" \\r\\n\");\r\n    }\r\n\r\n    if (!sourceClauseProcessed) {\r\n      if (parserGetLastWord().equals(KEYWORD_FROM)) {\r\n        newRecords = null;\r\n        subQuery = new OSQLAsynchQuery<OIdentifiable>(parserText.substring(parserGetCurrentPosition()), this);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }","commit_id":"142e586a3927d7ab13a63cd5e353dc257d0d995b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\n  public OCommandExecutorSQLMoveVertex parse(final OCommandRequest iRequest) {\n    final ODatabaseDocument database = getDatabase();\n\n    init((OCommandRequestText) iRequest);\n\n    parserRequiredKeyword(\"MOVE\");\n    parserRequiredKeyword(\"VERTEX\");\n\n    source = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\n    if (source == null)\n      throw new OCommandSQLParsingException(\"Cannot find source\");\n\n    parserRequiredKeyword(\"TO\");\n\n    String temp = parseOptionalWord(true);\n\n    while (temp != null) {\n      if (temp.startsWith(\"CLUSTER:\")) {\n        if (className != null)\n          throw new OCommandSQLParsingException(\"Cannot define multiple sources. Found both cluster and class.\");\n\n        clusterName = temp.substring(\"CLUSTER:\".length());\n        if (database.getClusterIdByName(clusterName) == -1)\n          throw new OCommandSQLParsingException(\"Cluster '\" + clusterName + \"' was not found\");\n\n      } else if (temp.startsWith(\"CLASS:\")) {\n        if (clusterName != null)\n          throw new OCommandSQLParsingException(\"Cannot define multiple sources. Found both cluster and class.\");\n\n        className = temp.substring(\"CLASS:\".length());\n\n        if (!((OMetadataInternal) database.getMetadata()).getImmutableSchemaSnapshot().existsClass(className))\n          throw new OCommandSQLParsingException(\"Class \" + className + \" was not found\");\n\n      } else if (temp.equals(KEYWORD_SET)) {\n        fields = new LinkedHashMap<String, Object>();\n        parseSetFields(fields);\n\n      } else if (temp.equals(KEYWORD_MERGE)) {\n        merge = parseJSON();\n\n      }\n\n      temp = parserOptionalWord(true);\n      if (parserIsEnded())\n        break;\n    }\n\n    return this;\n  }","id":74045,"modified_method":"@SuppressWarnings(\"unchecked\")\n  public OCommandExecutorSQLMoveVertex parse(final OCommandRequest iRequest) {\n    final ODatabaseDocument database = getDatabase();\n\n    init((OCommandRequestText) iRequest);\n\n    parserRequiredKeyword(\"MOVE\");\n    parserRequiredKeyword(\"VERTEX\");\n\n    source = parserRequiredWord(false, \"Syntax error\", \" =><,\\r\\n\");\n    if (source == null)\n      throw new OCommandSQLParsingException(\"Cannot find source\");\n\n    parserRequiredKeyword(\"TO\");\n\n    String temp = parseOptionalWord(true);\n\n    while (temp != null) {\n      if (temp.startsWith(\"CLUSTER:\")) {\n        if (className != null)\n          throw new OCommandSQLParsingException(\"Cannot define multiple sources. Found both cluster and class.\");\n\n        clusterName = temp.substring(\"CLUSTER:\".length());\n        if (database.getClusterIdByName(clusterName) == -1)\n          throw new OCommandSQLParsingException(\"Cluster '\" + clusterName + \"' was not found\");\n\n      } else if (temp.startsWith(\"CLASS:\")) {\n        if (clusterName != null)\n          throw new OCommandSQLParsingException(\"Cannot define multiple sources. Found both cluster and class.\");\n\n        className = temp.substring(\"CLASS:\".length());\n\n        clazz = database.getMetadata().getSchema().getClass(className);\n\n        if (clazz == null)\n          throw new OCommandSQLParsingException(\"Class '\" + className + \"' was not found\");\n\n      } else if (temp.equals(KEYWORD_SET)) {\n        fields = new LinkedHashMap<String, Object>();\n        parseSetFields(clazz, fields);\n\n      } else if (temp.equals(KEYWORD_MERGE)) {\n        merge = parseJSON();\n\n      }\n\n      temp = parserOptionalWord(true);\n      if (parserIsEnded())\n        break;\n    }\n\n    return this;\n  }","commit_id":"142e586a3927d7ab13a63cd5e353dc257d0d995b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected void parseSetFields(final Map<String, Object> fields) {\n    String fieldName;\n    String fieldValue;\n\n    while (!parserIsEnded() && (fields.size() == 0 || parserGetLastSeparator() == ',' || parserGetCurrentChar() == ',')) {\n      fieldName = parserRequiredWord(false, \"Field name expected\");\n      if (fieldName.equalsIgnoreCase(KEYWORD_WHERE)) {\n        parserGoBack();\n        break;\n      }\n\n      parserNextChars(false, true, \"=\");\n      fieldValue = parserRequiredWord(false, \"Value expected\", \" =><,\\r\\n\");\n\n      // INSERT TRANSFORMED FIELD VALUE\n      fields.put(fieldName, getFieldValueCountingParameters(fieldValue));\n      parserSkipWhiteSpaces();\n    }\n\n    if (fields.size() == 0)\n      throwParsingException(\"Entries to set <field> = <value> are missed. Example: name = 'Bill', salary = 300.2\");\n  }","id":74046,"modified_method":"protected void parseSetFields(final OClass iClass, final Map<String, Object> fields) {\n    String fieldName;\n    String fieldValue;\n\n    while (!parserIsEnded() && (fields.size() == 0 || parserGetLastSeparator() == ',' || parserGetCurrentChar() == ',')) {\n      fieldName = parserRequiredWord(false, \"Field name expected\");\n      if (fieldName.equalsIgnoreCase(KEYWORD_WHERE)) {\n        parserGoBack();\n        break;\n      }\n\n      parserNextChars(false, true, \"=\");\n      fieldValue = parserRequiredWord(false, \"Value expected\", \" =><,\\r\\n\");\n\n      // INSERT TRANSFORMED FIELD VALUE\n      Object v = getFieldValueCountingParameters(fieldValue);\n\n      if (iClass != null) {\n        // CHECK TYPE AND CONVERT IF NEEDED\n        final OProperty p = iClass.getProperty(fieldName);\n        if (p != null) {\n          switch (p.getType()) {\n          case EMBEDDEDSET:\n            // CONVERT MAPS IN DOCUMENTS ASSIGNING THE CLASS TAKEN FROM SCHEMA\n            if (!(v instanceof Map) && OMultiValue.isMultiValue(v)) {\n              final Set set = new HashSet();\n              final OClass embeddedType = p.getLinkedClass();\n\n              for (Object o : OMultiValue.getMultiValueIterable(v)) {\n                if (o instanceof Map) {\n                  final ODocument doc = new ODocument();\n                  if (embeddedType != null)\n                    doc.setClassName(embeddedType.getName());\n\n                  doc.fromMap((Map<String, Object>) o);\n\n                  set.add(doc);\n                } else if (o instanceof OIdentifiable)\n                  set.add(((OIdentifiable) o).getRecord());\n                else\n                  set.add(o);\n              }\n\n              v = set;\n            }\n            break;\n\n          case EMBEDDEDLIST:\n            // CONVERT MAPS IN DOCUMENTS ASSIGNING THE CLASS TAKEN FROM SCHEMA\n            if (!(v instanceof Map) && OMultiValue.isMultiValue(v)) {\n              final List set = new ArrayList();\n              final OClass embeddedType = p.getLinkedClass();\n\n              for (Object o : OMultiValue.getMultiValueIterable(v)) {\n                if (o instanceof Map) {\n                  final ODocument doc = new ODocument();\n                  if (embeddedType != null)\n                    doc.setClassName(embeddedType.getName());\n\n                  doc.fromMap((Map<String, Object>) o);\n\n                  set.add(doc);\n                } else if (o instanceof OIdentifiable)\n                  set.add(((OIdentifiable) o).getRecord());\n                else\n                  set.add(o);\n              }\n\n              v = set;\n            }\n            break;\n          }\n        }\n      }\n\n      fields.put(fieldName, v);\n      parserSkipWhiteSpaces();\n    }\n\n    if (fields.size() == 0)\n      throwParsingException(\"Entries to set <field> = <value> are missed. Example: name = 'Bill', salary = 300.2\");\n  }","commit_id":"142e586a3927d7ab13a63cd5e353dc257d0d995b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLUpdate parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    setEntries.clear();\r\n    addEntries.clear();\r\n    putEntries.clear();\r\n    removeEntries.clear();\r\n    incrementEntries.clear();\r\n    content = null;\r\n    merge = null;\r\n\r\n    query = null;\r\n\r\n    parserRequiredKeyword(KEYWORD_UPDATE);\r\n\r\n    subjectName = parserRequiredWord(false, \"Invalid target\", \" =><,\\r\\n\");\r\n    if (subjectName == null)\r\n      throwSyntaxErrorException(\"Invalid subject name. Expected cluster, class, index or sub-query\");\r\n\r\n    parserNextWord(true);\r\n    String word = parserGetLastWord();\r\n\r\n    if (parserIsEnded()\r\n        || (!word.equals(KEYWORD_SET) && !word.equals(KEYWORD_ADD) && !word.equals(KEYWORD_PUT) && !word.equals(KEYWORD_REMOVE)\r\n            && !word.equals(KEYWORD_INCREMENT) && !word.equals(KEYWORD_CONTENT) && !word.equals(KEYWORD_MERGE)\r\n            && !word.equals(KEYWORD_LOCK) && !word.equals(KEYWORD_RETURN) && !word.equals(KEYWORD_UPSERT)))\r\n      throwSyntaxErrorException(\"Expected keyword \" + KEYWORD_SET + \",\" + KEYWORD_ADD + \",\" + KEYWORD_CONTENT + \",\" + KEYWORD_MERGE\r\n          + \",\" + KEYWORD_PUT + \",\" + KEYWORD_REMOVE + \",\" + KEYWORD_INCREMENT + \",\" + KEYWORD_LOCK + \" or \" + KEYWORD_RETURN\r\n          + \" or \" + KEYWORD_UPSERT);\r\n\r\n    while ((!parserIsEnded() && !parserGetLastWord().equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE))\r\n        || parserGetLastWord().equals(KEYWORD_UPSERT)) {\r\n      word = parserGetLastWord();\r\n\r\n      if (word.equals(KEYWORD_CONTENT))\r\n        parseContent();\r\n      else if (word.equals(KEYWORD_MERGE))\r\n        parseMerge();\r\n      else if (word.equals(KEYWORD_SET))\r\n        parseSetFields(setEntries);\r\n      else if (word.equals(KEYWORD_ADD))\r\n        parseAddFields();\r\n      else if (word.equals(KEYWORD_PUT))\r\n        parsePutFields();\r\n      else if (word.equals(KEYWORD_REMOVE))\r\n        parseRemoveFields();\r\n      else if (word.equals(KEYWORD_INCREMENT))\r\n        parseIncrementFields();\r\n      else if (word.equals(KEYWORD_LOCK))\r\n        lockStrategy = parseLock();\r\n      else if (word.equals(KEYWORD_UPSERT))\r\n        upsertMode = true;\r\n      else if (word.equals(KEYWORD_RETURN))\r\n        parseReturn();\r\n      else if (word.equals(KEYWORD_RETRY))\r\n        parseRetry();\r\n      else\r\n        break;\r\n\r\n      parserNextWord(true);\r\n    }\r\n\r\n    final String additionalStatement = parserGetLastWord();\r\n\r\n    if (subjectName.startsWith(\"(\")) {\r\n      subjectName = subjectName.trim();\r\n      query = database.command(new OSQLAsynchQuery<ODocument>(subjectName.substring(1, subjectName.length() - 1), this)\r\n          .setContext(context));\r\n\r\n      if (additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE)\r\n          || additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_LIMIT))\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(parserText.substring(parserGetCurrentPosition()), getContext(),\r\n            KEYWORD_WHERE);\r\n\r\n    } else if (additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE)\r\n        || additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_LIMIT)\r\n        || additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_LET) || additionalStatement.equals(KEYWORD_LOCK)) {\r\n      query = new OSQLAsynchQuery<ODocument>(\"select from \" + subjectName + \" \" + additionalStatement + \" \"\r\n          + parserText.substring(parserGetCurrentPosition()), this);\r\n      isUpsertAllowed = (((OMetadataInternal) getDatabase().getMetadata()).getImmutableSchemaSnapshot().getClass(subjectName) != null);\r\n    } else if (!additionalStatement.isEmpty())\r\n      throwSyntaxErrorException(\"Invalid keyword \" + additionalStatement);\r\n    else\r\n      query = new OSQLAsynchQuery<ODocument>(\"select from \" + subjectName, this);\r\n\r\n    if (upsertMode && !isUpsertAllowed)\r\n      throwSyntaxErrorException(\"Upsert only works with class names \");\r\n\r\n    if (upsertMode && !additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE))\r\n      throwSyntaxErrorException(\"Upsert only works with WHERE keyword\");\r\n\r\n    return this;\r\n  }","id":74047,"modified_method":"@SuppressWarnings(\"unchecked\")\r\n  public OCommandExecutorSQLUpdate parse(final OCommandRequest iRequest) {\r\n    final ODatabaseDocument database = getDatabase();\r\n\r\n    init((OCommandRequestText) iRequest);\r\n\r\n    setEntries.clear();\r\n    addEntries.clear();\r\n    putEntries.clear();\r\n    removeEntries.clear();\r\n    incrementEntries.clear();\r\n    content = null;\r\n    merge = null;\r\n\r\n    query = null;\r\n\r\n    parserRequiredKeyword(KEYWORD_UPDATE);\r\n\r\n    subjectName = parserRequiredWord(false, \"Invalid target\", \" =><,\\r\\n\");\r\n    if (subjectName == null)\r\n      throwSyntaxErrorException(\"Invalid subject name. Expected cluster, class, index or sub-query\");\r\n\r\n    parserNextWord(true);\r\n    String word = parserGetLastWord();\r\n\r\n    if (parserIsEnded()\r\n        || (!word.equals(KEYWORD_SET) && !word.equals(KEYWORD_ADD) && !word.equals(KEYWORD_PUT) && !word.equals(KEYWORD_REMOVE)\r\n            && !word.equals(KEYWORD_INCREMENT) && !word.equals(KEYWORD_CONTENT) && !word.equals(KEYWORD_MERGE)\r\n            && !word.equals(KEYWORD_LOCK) && !word.equals(KEYWORD_RETURN) && !word.equals(KEYWORD_UPSERT)))\r\n      throwSyntaxErrorException(\"Expected keyword \" + KEYWORD_SET + \",\" + KEYWORD_ADD + \",\" + KEYWORD_CONTENT + \",\" + KEYWORD_MERGE\r\n          + \",\" + KEYWORD_PUT + \",\" + KEYWORD_REMOVE + \",\" + KEYWORD_INCREMENT + \",\" + KEYWORD_LOCK + \" or \" + KEYWORD_RETURN\r\n          + \" or \" + KEYWORD_UPSERT);\r\n\r\n    while ((!parserIsEnded() && !parserGetLastWord().equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE))\r\n        || parserGetLastWord().equals(KEYWORD_UPSERT)) {\r\n      word = parserGetLastWord();\r\n\r\n      if (word.equals(KEYWORD_CONTENT))\r\n        parseContent();\r\n      else if (word.equals(KEYWORD_MERGE))\r\n        parseMerge();\r\n      else if (word.equals(KEYWORD_SET))\r\n        parseSetFields(null, setEntries);\r\n      else if (word.equals(KEYWORD_ADD))\r\n        parseAddFields();\r\n      else if (word.equals(KEYWORD_PUT))\r\n        parsePutFields();\r\n      else if (word.equals(KEYWORD_REMOVE))\r\n        parseRemoveFields();\r\n      else if (word.equals(KEYWORD_INCREMENT))\r\n        parseIncrementFields();\r\n      else if (word.equals(KEYWORD_LOCK))\r\n        lockStrategy = parseLock();\r\n      else if (word.equals(KEYWORD_UPSERT))\r\n        upsertMode = true;\r\n      else if (word.equals(KEYWORD_RETURN))\r\n        parseReturn();\r\n      else if (word.equals(KEYWORD_RETRY))\r\n        parseRetry();\r\n      else\r\n        break;\r\n\r\n      parserNextWord(true);\r\n    }\r\n\r\n    final String additionalStatement = parserGetLastWord();\r\n\r\n    if (subjectName.startsWith(\"(\")) {\r\n      subjectName = subjectName.trim();\r\n      query = database.command(new OSQLAsynchQuery<ODocument>(subjectName.substring(1, subjectName.length() - 1), this)\r\n          .setContext(context));\r\n\r\n      if (additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE)\r\n          || additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_LIMIT))\r\n        compiledFilter = OSQLEngine.getInstance().parseCondition(parserText.substring(parserGetCurrentPosition()), getContext(),\r\n            KEYWORD_WHERE);\r\n\r\n    } else if (additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE)\r\n        || additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_LIMIT)\r\n        || additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_LET) || additionalStatement.equals(KEYWORD_LOCK)) {\r\n      query = new OSQLAsynchQuery<ODocument>(\"select from \" + subjectName + \" \" + additionalStatement + \" \"\r\n          + parserText.substring(parserGetCurrentPosition()), this);\r\n      isUpsertAllowed = (((OMetadataInternal) getDatabase().getMetadata()).getImmutableSchemaSnapshot().getClass(subjectName) != null);\r\n    } else if (!additionalStatement.isEmpty())\r\n      throwSyntaxErrorException(\"Invalid keyword \" + additionalStatement);\r\n    else\r\n      query = new OSQLAsynchQuery<ODocument>(\"select from \" + subjectName, this);\r\n\r\n    if (upsertMode && !isUpsertAllowed)\r\n      throwSyntaxErrorException(\"Upsert only works with class names \");\r\n\r\n    if (upsertMode && !additionalStatement.equals(OCommandExecutorSQLAbstract.KEYWORD_WHERE))\r\n      throwSyntaxErrorException(\"Upsert only works with WHERE keyword\");\r\n\r\n    return this;\r\n  }","commit_id":"142e586a3927d7ab13a63cd5e353dc257d0d995b","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n     * Retrieves the current execution environment\n     *\n     * @return The environment Grails is executing under\n     */\n    public static String getEnvironment() {\n        GrailsApplication app = ApplicationHolder.getApplication();\n\n\n        String envName = null;\n        if(app!=null) {\n            envName = (String)app.getMetadata().get(GrailsApplication.ENVIRONMENT);\n        }\n        if(StringUtils.isBlank(envName))\n            envName = System.getProperty(GrailsApplication.ENVIRONMENT);\n        \n        if(StringUtils.isBlank(envName)) {\n            // for now if no environment specified default to production\n            return GrailsApplication.ENV_PRODUCTION;                \n        }\n        else {\n            if(envNameMappings.containsKey(envName)) {\n                return (String)envNameMappings.get(envName);\n            }\n            else {\n                return envName;\n            }\n        }\n    }","id":74048,"modified_method":"/**\n     * Retrieves the current execution environment\n     *\n     * @return The environment Grails is executing under\n     */\n    public static String getEnvironment() {\n        GrailsApplication app = ApplicationHolder.getApplication();\n\n\n        String envName = null;\n        if(app!=null) {\n            Map metadata = app.getMetadata();\n            if(metadata!=null)\n                envName = (String)metadata.get(GrailsApplication.ENVIRONMENT);\n        }\n        if(StringUtils.isBlank(envName))\n            envName = System.getProperty(GrailsApplication.ENVIRONMENT);\n        \n        if(StringUtils.isBlank(envName)) {\n            // for now if no environment specified default to production\n            return GrailsApplication.ENV_PRODUCTION;                \n        }\n        else {\n            if(envNameMappings.containsKey(envName)) {\n                return (String)envNameMappings.get(envName);\n            }\n            else {\n                return envName;\n            }\n        }\n    }","commit_id":"1748960d32b22b335faa58f000d447e46ba3a1ba","url":"https://github.com/grails/grails-core"},{"original_method":"public void checkForClusterPermissions(final String iClusterName) {\r\n    // CHECK FOR ORESTRICTED\r\n    final Set<OClass> classes = ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata().getSchema()\r\n        .getClassesRelyOnCluster(iClusterName);\r\n    for (OClass c : classes) {\r\n      if (c.isSubClassOf(OSecurityShared.RESTRICTED_CLASSNAME))\r\n        throw new OSecurityException(\"Class \" + c.getName()\r\n            + \" cannot be truncated because has record level security enabled (extends \" + OSecurityShared.RESTRICTED_CLASSNAME\r\n            + \")\");\r\n    }\r\n  }","id":74049,"modified_method":"public void checkForClusterPermissions(final String iClusterName) {\r\n    // CHECK FOR ORESTRICTED\r\n    OMetadata metaData = ODatabaseRecordThreadLocal.INSTANCE.get().getMetadata();\r\n    if (metaData != null) {\r\n      final Set<OClass> classes = metaData.getSchema().getClassesRelyOnCluster(iClusterName);\r\n      for (OClass c : classes) {\r\n        if (c.isSubClassOf(OSecurityShared.RESTRICTED_CLASSNAME))\r\n          throw new OSecurityException(\"Class \" + c.getName()\r\n              + \" cannot be truncated because has record level security enabled (extends \" + OSecurityShared.RESTRICTED_CLASSNAME\r\n              + \")\");\r\n      }\r\n    }\r\n  }","commit_id":"9a42ee7d63d790afd230cc707402160010627e99","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void beginResponse(final int iRequesterId, final long iTimeout) throws IOException {\r\n    try {\r\n      int unreadResponse = 0;\r\n      final long startClock = iTimeout > 0 ? System.currentTimeMillis() : 0;\r\n\r\n      // WAIT FOR THE RESPONSE\r\n      do {\r\n        if (iTimeout <= 0)\r\n          lockRead.lock();\r\n        else if (!lockRead.tryLock(iTimeout, TimeUnit.MILLISECONDS))\r\n          throw new OTimeoutException(\"Cannot acquire read lock against channel: \" + this);\r\n\r\n        if (!channelRead) {\r\n          channelRead = true;\r\n\r\n          try {\r\n            currentStatus = readByte();\r\n            currentSessionId = readInt();\r\n\r\n            if (debug)\r\n              OLogManager.instance().debug(this, \"%s - Read response: %d-%d\", socket.getLocalAddress(), (int) currentStatus,\r\n                  currentSessionId);\r\n\r\n          } catch (IOException e) {\r\n            // UNLOCK THE RESOURCE AND PROPAGATES THE EXCEPTION\r\n            lockRead.unlock();\r\n            channelRead = false;\r\n            throw e;\r\n          }\r\n        }\r\n\r\n        if (currentSessionId == iRequesterId)\r\n          // IT'S FOR ME\r\n          break;\r\n\r\n        if (debug)\r\n          OLogManager.instance().debug(this, \"%s - Session %d skip response, it is for %d\", socket.getLocalAddress(), iRequesterId,\r\n              currentSessionId);\r\n\r\n        if (iTimeout > 0 && (System.currentTimeMillis() - startClock) > iTimeout)\r\n          throw new OTimeoutException(\"Timeout on reading response from the server for the request \" + iRequesterId);\r\n\r\n        if (unreadResponse > maxUnreadResponses) {\r\n          if (debug)\r\n            OLogManager.instance().info(this, \"Unread responses %d > %d, consider the buffer as dirty: close it...\",\r\n                unreadResponse, maxUnreadResponses);\r\n\r\n          // CALL THE SUPER-METHOD TO AVOID LOCKING AGAIN\r\n          // super.clearInput();\r\n          close();\r\n        }\r\n\r\n        lockRead.unlock();\r\n\r\n        final long start = System.currentTimeMillis();\r\n\r\n        // WAIT 1 SECOND AND RETRY\r\n        synchronized (this) {\r\n          try {\r\n            if (debug)\r\n              OLogManager.instance().debug(this, \"Session %d is going to sleep...\", iRequesterId);\r\n\r\n            wait(1000);\r\n            final long now = System.currentTimeMillis();\r\n\r\n            if (debug)\r\n              OLogManager.instance().debug(this, \"Waked up: slept %dms, checking again from %s for session %d\", (now - start),\r\n                  socket.getLocalAddress(), iRequesterId);\r\n\r\n            if (now - start >= 1000)\r\n              unreadResponse++;\r\n\r\n          } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n          }\r\n        }\r\n      } while (true);\r\n\r\n      if (debug)\r\n        OLogManager.instance().debug(this, \"%s - Session %d handle response\", socket.getLocalAddress(), iRequesterId);\r\n\r\n      handleStatus(currentStatus, currentSessionId);\r\n    } catch (InterruptedException e) {\r\n      Thread.currentThread().interrupt();\r\n      // NEVER HAPPENS?\r\n      e.printStackTrace();\r\n    }\r\n  }","id":74050,"modified_method":"public void beginResponse(final int iRequesterId, final long iTimeout) throws IOException {\r\n    try {\r\n      int unreadResponse = 0;\r\n      final long startClock = iTimeout > 0 ? System.currentTimeMillis() : 0;\r\n\r\n      // WAIT FOR THE RESPONSE\r\n      do {\r\n        if (iTimeout <= 0)\r\n          lockRead.lock();\r\n        else if (!lockRead.tryLock(iTimeout, TimeUnit.MILLISECONDS))\r\n          throw new OTimeoutException(\"Cannot acquire read lock against channel: \" + this);\r\n\r\n        if (!channelRead) {\r\n          channelRead = true;\r\n\r\n          try {\r\n            currentStatus = readByte();\r\n            currentSessionId = readInt();\r\n\r\n            if (debug)\r\n              OLogManager.instance().debug(this, \"%s - Read response: %d-%d\", socket.getLocalAddress(), (int) currentStatus,\r\n                  currentSessionId);\r\n\r\n          } catch (IOException e) {\r\n            // UNLOCK THE RESOURCE AND PROPAGATES THE EXCEPTION\r\n            lockRead.unlock();\r\n            channelRead = false;\r\n            throw e;\r\n          }\r\n        }\r\n\r\n        if (currentSessionId == iRequesterId)\r\n          // IT'S FOR ME\r\n          break;\r\n\r\n        if (debug)\r\n          OLogManager.instance().debug(this, \"%s - Session %d skip response, it is for %d\", socket.getLocalAddress(), iRequesterId,\r\n              currentSessionId);\r\n\r\n        if (iTimeout > 0 && (System.currentTimeMillis() - startClock) > iTimeout)\r\n          throw new OTimeoutException(\"Timeout on reading response from the server for the request \" + iRequesterId);\r\n\r\n        if (unreadResponse > maxUnreadResponses) {\r\n          if (debug)\r\n            OLogManager.instance().info(this, \"Unread responses %d > %d, consider the buffer as dirty: clean it\", unreadResponse,\r\n                maxUnreadResponses);\r\n\r\n          // CALL THE SUPER-METHOD TO AVOID LOCKING AGAIN\r\n          // super.clearInput();\r\n          close();\r\n          throw new IOException(\"Timeout on reading response\");\r\n        }\r\n\r\n        lockRead.unlock();\r\n\r\n        final long start = System.currentTimeMillis();\r\n\r\n        // WAIT 1 SECOND AND RETRY\r\n        synchronized (this) {\r\n          try {\r\n            if (debug)\r\n              OLogManager.instance().debug(this, \"Session %d is going to sleep...\", iRequesterId);\r\n\r\n            wait(1000);\r\n            final long now = System.currentTimeMillis();\r\n\r\n            if (debug)\r\n              OLogManager.instance().debug(this, \"Waked up: slept %dms, checking again from %s for session %d\", (now - start),\r\n                  socket.getLocalAddress(), iRequesterId);\r\n\r\n            if (now - start >= 1000)\r\n              unreadResponse++;\r\n\r\n          } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n          }\r\n        }\r\n      } while (true);\r\n\r\n      if (debug)\r\n        OLogManager.instance().debug(this, \"%s - Session %d handle response\", socket.getLocalAddress(), iRequesterId);\r\n\r\n      handleStatus(currentStatus, currentSessionId);\r\n    } catch (InterruptedException e) {\r\n      Thread.currentThread().interrupt();\r\n      // NEVER HAPPENS?\r\n      e.printStackTrace();\r\n    }\r\n  }","commit_id":"4c41f39f7c3952046166057e3df430114e6aabf5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void endResponse() {\r\n    channelRead = false;\r\n    lockRead.unlock();\r\n\r\n    // WAKE UP ALL THE WAITING THREADS\r\n    synchronized (this) {\r\n      notifyAll();\r\n    }\r\n  }","id":74051,"modified_method":"public void endResponse() {\r\n    channelRead = false;\r\n    try {\r\n      lockRead.unlock();\r\n    } catch (IllegalMonitorStateException e) {\r\n      // IGNORE IT\r\n    }\r\n\r\n    // WAKE UP ALL THE WAITING THREADS\r\n    synchronized (this) {\r\n      notifyAll();\r\n    }\r\n  }","commit_id":"4c41f39f7c3952046166057e3df430114e6aabf5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    checkOpeness();\r\n    rollback();\r\n\r\n    getMetadata().close();\r\n    ((ODatabaseRaw) ((ODatabaseRecord) underlying).getUnderlying()).callOnCloseListeners();\r\n    getLevel1Cache().clear();\r\n\r\n    ownerPool.release(this);\r\n    ownerPool = null;\r\n  }","id":74052,"modified_method":"/**\r\n   * Avoid to close it but rather release itself to the owner pool.\r\n   */\r\n  @Override\r\n  public void close() {\r\n    if (isClosed())\r\n      return;\r\n\r\n    checkOpeness();\r\n    rollback();\r\n\r\n    final OMetadata md = getMetadata();\r\n    if (md != null)\r\n      md.close();\r\n\r\n    ((ODatabaseRaw) ((ODatabaseRecord) underlying).getUnderlying()).callOnCloseListeners();\r\n    getLevel1Cache().clear();\r\n\r\n    ownerPool.release(this);\r\n    ownerPool = null;\r\n  }","commit_id":"4c41f39f7c3952046166057e3df430114e6aabf5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n  protected void onBeforeRequest() throws IOException {\n    connection = OClientConnectionManager.instance().getConnection(channel.socket, clientTxId);\n\n    if (clientTxId < 0) {\n      short protocolId = 0;\n\n      if (connection != null)\n        protocolId = connection.data.protocolVersion;\n\n      connection = OClientConnectionManager.instance().connect(channel.socket, this);\n\n      if (connection != null)\n        connection.data.protocolVersion = protocolId;\n    }\n\n    if (connection != null) {\n      ODatabaseRecordThreadLocal.INSTANCE.set(connection.database);\n      ++connection.data.totalRequests;\n      setDataCommandInfo(\"Listening\");\n      connection.data.commandDetail = \"-\";\n      connection.data.lastCommandReceived = System.currentTimeMillis();\n    }\n\n    OServerHandlerHelper.invokeHandlerCallbackOnBeforeClientRequest(connection, (byte) requestType);\n  }","id":74053,"modified_method":"@Override\n  protected void onBeforeRequest() throws IOException {\n    connection = OClientConnectionManager.instance().getConnection(channel.socket, clientTxId);\n\n    if (clientTxId < 0) {\n      short protocolId = 0;\n\n      if (connection != null)\n        protocolId = connection.data.protocolVersion;\n\n      connection = OClientConnectionManager.instance().connect(channel.socket, this);\n\n      if (connection != null)\n        connection.data.protocolVersion = protocolId;\n    }\n\n    if (connection != null) {\n      ODatabaseRecordThreadLocal.INSTANCE.set(connection.database);\n      ++connection.data.totalRequests;\n      setDataCommandInfo(\"Listening\");\n      connection.data.commandDetail = \"-\";\n      connection.data.lastCommandReceived = System.currentTimeMillis();\n    } else {\n      if (requestType != OChannelBinaryProtocol.REQUEST_DB_CLOSE)\n        throw new OIOException(\"Found unknown session \" + clientTxId);\n    }\n\n    OServerHandlerHelper.invokeHandlerCallbackOnBeforeClientRequest(connection, (byte) requestType);\n  }","commit_id":"4c41f39f7c3952046166057e3df430114e6aabf5","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiJavaCodeReferenceElement referenceElement =\n                    (PsiJavaCodeReferenceElement)descriptor.getPsiElement();\n            final PsiClass iface = (PsiClass)referenceElement.resolve();\n            assert iface != null;\n            final PsiField[] allFields = iface.getAllFields();\n\n            final PsiClass implementingClass =\n                    PsiTreeUtil.getParentOfType(referenceElement,\n                                                PsiClass.class);\n            final PsiManager manager = referenceElement.getManager();\n            final PsiSearchHelper searchHelper = manager.getSearchHelper();\n            assert implementingClass != null;\n            final SearchScope searchScope = implementingClass.getUseScope();\n            Map<PsiReferenceExpression, PsiField> refsToRebind = new HashMap<PsiReferenceExpression, PsiField>();\n            for (final PsiField field : allFields) {\n                final PsiReference[] references =\n                        searchHelper.findReferences(field, searchScope, false);\n\n                for (PsiReference reference1 : references) {\n                    if (!(reference1 instanceof PsiReferenceExpression)) {\n                        continue;\n                    }\n                    final PsiReferenceExpression reference =\n                            (PsiReferenceExpression)reference1;\n                    if(isQuickFixOnReadOnlyFile(reference)){\n                        continue;\n                    }\n                  refsToRebind.put(reference, field);\n                }\n            }\n            deleteElement(referenceElement);\n          for (PsiReferenceExpression reference : refsToRebind.keySet()) {\n            PsiField field = refsToRebind.get(reference);\n            PsiReferenceExpression qualified =\n              (PsiReferenceExpression)field.getManager().getElementFactory().createExpressionFromText(\"xxx.\" + reference.getText(), reference);\n            PsiReferenceExpression newReference = (PsiReferenceExpression)reference.replace(qualified);\n            ((PsiReferenceExpression)newReference.getQualifierExpression()).bindToElement(field.getContainingClass());\n          }\n        }","id":74054,"modified_method":"public void doFix(Project project, ProblemDescriptor descriptor)\n                throws IncorrectOperationException {\n            final PsiJavaCodeReferenceElement referenceElement =\n                    (PsiJavaCodeReferenceElement)descriptor.getPsiElement();\n            final PsiClass iface = (PsiClass)referenceElement.resolve();\n            assert iface != null;\n            final PsiField[] allFields = iface.getAllFields();\n\n            final PsiClass implementingClass =\n                    PsiTreeUtil.getParentOfType(referenceElement,\n                            PsiClass.class);\n            final PsiManager manager = referenceElement.getManager();\n            assert implementingClass != null;\n            final SearchScope searchScope = implementingClass.getUseScope();\n            final Map<PsiReferenceExpression, PsiField> refsToRebind =\n                    new HashMap<PsiReferenceExpression, PsiField>();\n            for (final PsiField field : allFields) {\n                final Query<PsiReference> search =\n                        ReferencesSearch.search(field, searchScope, false);\n                for (PsiReference reference1 : search) {\n                    if (!(reference1 instanceof PsiReferenceExpression)) {\n                        continue;\n                    }\n                    final PsiReferenceExpression reference =\n                            (PsiReferenceExpression)reference1;\n                    if(isQuickFixOnReadOnlyFile(reference)){\n                        continue;\n                    }\n                    refsToRebind.put(reference, field);\n                }\n            }\n            deleteElement(referenceElement);\n            for (PsiReferenceExpression reference : refsToRebind.keySet()) {\n                final PsiField field = refsToRebind.get(reference);\n                final PsiElementFactory elementFactory =\n                        manager.getElementFactory();\n                final PsiReferenceExpression qualified = (PsiReferenceExpression)\n                        elementFactory.createExpressionFromText(\"xxx.\" +\n                                reference.getText(), reference);\n                final PsiReferenceExpression newReference =\n                        (PsiReferenceExpression)reference.replace(qualified);\n                final PsiReferenceExpression referenceExpression =\n                        (PsiReferenceExpression)\n                                newReference.getQualifierExpression();\n                if (referenceExpression != null) {\n                    referenceExpression.bindToElement(field.getContainingClass());\n                }\n            }\n        }","commit_id":"b9db114b079f303628535357b93da9edc04a6e8e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void retargetUsages(UsageInfo[] usages, Map<PsiElement, PsiElement> oldToNewMap) {\n    final List<NonCodeUsageInfo> nonCodeUsages = new ArrayList<NonCodeUsageInfo>();\n    for (UsageInfo usageInfo : usages) {\n      if (usageInfo instanceof MyUsageInfo) {\n        final MyUsageInfo info = (MyUsageInfo)usageInfo;\n        final PsiElement element = myElementsToMove[info.myIndex];\n\n        if (info.getReference() instanceof FileReference || info.getReference() instanceof PsiDynaReference) {\n          final PsiElement usageElement = info.getElement();\n          if (usageElement != null) {\n            final PsiFile usageFile = usageElement.getContainingFile();\n            final PsiFile psiFile = usageFile.getViewProvider().getPsi(usageFile.getViewProvider().getBaseLanguage());\n            if (psiFile != null && psiFile.equals(element)) {\n              continue;  // already processed in MoveFilesOrDirectoriesUtil.doMoveFile\n            }\n          }\n        }\n\n        info.myReference.bindToElement(element);\n      } else if (usageInfo instanceof NonCodeUsageInfo) {\n        nonCodeUsages.add((NonCodeUsageInfo)usageInfo);\n      }\n    }\n\n    for (PsiFile movedFile : myFoundUsages.keySet()) {\n      MoveFileHandler.forElement(movedFile).retargetUsages(myFoundUsages.get(movedFile), oldToNewMap);\n    }\n\n    myNonCodeUsages = nonCodeUsages.toArray(new NonCodeUsageInfo[nonCodeUsages.size()]);\n  }","id":74055,"modified_method":"protected void retargetUsages(UsageInfo[] usages, Map<PsiElement, PsiElement> oldToNewMap) {\n    final List<NonCodeUsageInfo> nonCodeUsages = new ArrayList<NonCodeUsageInfo>();\n    for (UsageInfo usageInfo : usages) {\n      if (usageInfo instanceof MyUsageInfo) {\n        final MyUsageInfo info = (MyUsageInfo)usageInfo;\n        final PsiElement element = myElementsToMove[info.myIndex];\n\n        if (info.getReference() instanceof FileReference || info.getReference() instanceof PsiDynaReference) {\n          final PsiElement usageElement = info.getElement();\n          if (usageElement != null) {\n            final PsiFile usageFile = usageElement.getContainingFile();\n            final PsiFile psiFile = usageFile.getViewProvider().getPsi(usageFile.getViewProvider().getBaseLanguage());\n            if (psiFile != null && psiFile.equals(element)) {\n              continue;  // already processed in MoveFilesOrDirectoriesUtil.doMoveFile\n            }\n          }\n        }\n        final PsiElement refElement = info.myReference.getElement();\n        if (refElement != null && refElement.isValid()) {\n          info.myReference.bindToElement(element);\n        }\n      } else if (usageInfo instanceof NonCodeUsageInfo) {\n        nonCodeUsages.add((NonCodeUsageInfo)usageInfo);\n      }\n    }\n\n    for (PsiFile movedFile : myFoundUsages.keySet()) {\n      MoveFileHandler.forElement(movedFile).retargetUsages(myFoundUsages.get(movedFile), oldToNewMap);\n    }\n\n    myNonCodeUsages = nonCodeUsages.toArray(new NonCodeUsageInfo[nonCodeUsages.size()]);\n  }","commit_id":"3d8cb1b90b83a5faa126474b0f73490c1a1a9de9","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkQualifiedNewOfStaticClass(PsiNewExpression expression) {\n    PsiExpression qualifier = expression.getQualifier();\n    if (qualifier == null) return null;\n    PsiType type = expression.getType();\n    PsiClass aClass = PsiUtil.resolveClassInType(type);\n    if (aClass != null && aClass.hasModifierProperty(PsiModifier.STATIC)) {\n      HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                                      expression,\n                                                                      JavaErrorMessages.message(\"qualified.new.of.static.class\"));\n      if (!aClass.isEnum()) {\n        IntentionAction fix = QUICK_FIX_FACTORY.createModifierListFix(aClass.getModifierList(), PsiModifier.STATIC, false, false);\n        QuickFixAction.registerQuickFixAction(highlightInfo, fix);\n        QuickFixAction.registerQuickFixAction(highlightInfo, new RemoveNewQualifierFix(expression, aClass));\n      }\n      return highlightInfo;\n    }\n    return null;\n  }","id":74056,"modified_method":"public static HighlightInfo checkQualifiedNewOfStaticClass(PsiNewExpression expression) {\n    PsiExpression qualifier = expression.getQualifier();\n    if (qualifier == null) return null;\n    PsiType type = expression.getType();\n    if (type instanceof PsiArrayType) {\n      HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                                      expression,\n                                                                      JavaErrorMessages.message(\"invalid.qualified.new\"));\n      QuickFixAction.registerQuickFixAction(info, new RemoveNewQualifierFix(expression, null));\n      return info;\n    }\n    PsiClass aClass = PsiUtil.resolveClassInType(type);\n    if (aClass != null && aClass.hasModifierProperty(PsiModifier.STATIC)) {\n      HighlightInfo info = HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                                      expression,\n                                                                      JavaErrorMessages.message(\"qualified.new.of.static.class\"));\n      if (!aClass.isEnum()) {\n        IntentionAction fix = QUICK_FIX_FACTORY.createModifierListFix(aClass.getModifierList(), PsiModifier.STATIC, false, false);\n        QuickFixAction.registerQuickFixAction(info, fix);\n      }\n      QuickFixAction.registerQuickFixAction(info, new RemoveNewQualifierFix(expression, aClass));\n      return info;\n    }\n    return null;\n  }","commit_id":"00e667aa88e98057ad0c1b8fcb5fbe496d53bd08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    if (!CodeInsightUtil.prepareFileForWrite(expression.getContainingFile())) return;\n    PsiJavaCodeReferenceElement classReference = expression.getClassReference();\n    expression.getQualifier().delete();\n    classReference.bindToElement(aClass);\n  }","id":74057,"modified_method":"public void invoke(Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    if (!CodeInsightUtil.prepareFileForWrite(expression.getContainingFile())) return;\n    PsiJavaCodeReferenceElement classReference = expression.getClassReference();\n    expression.getQualifier().delete();\n    if (aClass != null && classReference != null) {\n      classReference.bindToElement(aClass);\n    }\n  }","commit_id":"00e667aa88e98057ad0c1b8fcb5fbe496d53bd08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n    return\n        expression != null\n        && expression.isValid()\n        && expression.getClassReference() != null\n        && aClass != null\n        && aClass.isValid()\n        && expression.getManager().isInProject(expression);\n  }","id":74058,"modified_method":"public boolean isAvailable(Project project, Editor editor, PsiFile file) {\n    return\n        expression != null\n        && expression.isValid()\n        && (aClass == null || aClass.isValid())\n        && expression.getManager().isInProject(expression);\n  }","commit_id":"00e667aa88e98057ad0c1b8fcb5fbe496d53bd08","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"PastSnapshot findByPreviousVersion(Snapshot projectSnapshot) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() +\n      \" where version<>:version AND version IS NOT NULL AND resourceId=:resourceId AND status=:status AND qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"version\", projectSnapshot.getVersion())\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    PastSnapshot result;\n    if (snapshots.isEmpty()) {\n      result = new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_VERSION);\n    } else {\n      Snapshot snapshot = snapshots.get(0);\n      Date targetDate = snapshot.getCreatedAt();\n      result = new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_VERSION, targetDate, snapshot).setModeParameter(snapshot.getVersion());\n    }\n    return result;\n  }","id":74059,"modified_method":"PastSnapshot findByPreviousVersion(Snapshot projectSnapshot) {\n    String currentVersion = projectSnapshot.getVersion();\n    Integer resourceId = projectSnapshot.getResourceId();\n\n    String hql = \"from \" + Event.class.getSimpleName() +\n      \" where name<>:version AND category='Version' AND resourceId=:resourceId ORDER BY date DESC\";\n\n    List<Event> events = session.createQuery(hql)\n        .setParameter(\"version\", currentVersion)\n        .setParameter(\"resourceId\", resourceId)\n        .setMaxResults(1)\n        .getResultList();\n\n    if (events.isEmpty()) {\n      return new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_VERSION);\n    }\n\n    Event previousVersionEvent = events.get(0);\n    Snapshot snapshot = session.getSingleResult(Snapshot.class, \"id\", previousVersionEvent.getSnapshot().getId());\n\n    return new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_VERSION, snapshot.getCreatedAt(), snapshot).setModeParameter(snapshot.getVersion());\n  }","commit_id":"9e32b6710276aa0b187b4ee388fcd9b99ded7262","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldFindByPreviousVersion() {\n    setupData(\"with-previous-version\");\n    PastSnapshotFinderByPreviousVersion finder = new PastSnapshotFinderByPreviousVersion(getSession());\n\n    Snapshot currentProjectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1010);\n    PastSnapshot foundSnapshot = finder.findByPreviousVersion(currentProjectSnapshot);\n    assertThat(foundSnapshot.getProjectSnapshotId()).isEqualTo(1009);\n    assertThat(foundSnapshot.getMode()).isEqualTo(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_VERSION);\n    assertThat(foundSnapshot.getModeParameter()).isEqualTo(\"1.1\");\n\n    // and test also another version to verify that unprocessed snapshots are ignored\n    currentProjectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1009);\n    assertThat(finder.findByPreviousVersion(currentProjectSnapshot).getProjectSnapshotId()).isEqualTo(1003);\n  }","id":74060,"modified_method":"@Test\n  public void shouldFindByPreviousVersion() {\n    setupData(\"with-previous-version\");\n    PastSnapshotFinderByPreviousVersion finder = new PastSnapshotFinderByPreviousVersion(getSession());\n\n    Snapshot currentProjectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1003);\n    PastSnapshot foundSnapshot = finder.findByPreviousVersion(currentProjectSnapshot);\n    assertThat(foundSnapshot.getProjectSnapshotId()).isEqualTo(1001);\n    assertThat(foundSnapshot.getMode()).isEqualTo(CoreProperties.TIMEMACHINE_MODE_PREVIOUS_VERSION);\n    assertThat(foundSnapshot.getModeParameter()).isEqualTo(\"1.1\");\n  }","commit_id":"9e32b6710276aa0b187b4ee388fcd9b99ded7262","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public PastSnapshot find(Snapshot projectSnapshot, Configuration conf, int index) {\n    String propertyValue = getPropertyValue(conf, index);\n    PastSnapshot pastSnapshot = find(projectSnapshot, index, propertyValue);\n    if (pastSnapshot == null && StringUtils.isNotBlank(propertyValue)) {\n      Logs.INFO.debug(\"The property \" + CoreProperties.TIMEMACHINE_PERIOD_PREFIX + index + \" has an unvalid value: \" + propertyValue);\n    }\n    return pastSnapshot;\n  }","id":74061,"modified_method":"public PastSnapshot find(Snapshot projectSnapshot, Configuration conf, int index) {\n    String propertyValue = getPropertyValue(conf, index);\n    PastSnapshot pastSnapshot = find(projectSnapshot, index, propertyValue);\n    if (pastSnapshot == null && StringUtils.isNotBlank(propertyValue)) {\n      LoggerFactory.getLogger(PastSnapshotFinder.class).debug(\"Property \" + CoreProperties.TIMEMACHINE_PERIOD_PREFIX + index + \" is not valid: \" + propertyValue);\n    }\n    return pastSnapshot;\n  }","commit_id":"b6c0e733080d9f53516bc865b1179da360499dca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"PastSnapshot findByVersion(Snapshot projectSnapshot, String version) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() + \" where version=:version AND resourceId=:resourceId AND status=:status AND qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"version\", version)\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    if (snapshots.isEmpty()) {\n      throw new IllegalStateException(\"Unknown project version: \" + version +\". Please check differential views in project settings.\");\n    }\n    Snapshot snapshot = snapshots.get(0);\n    Date targetDate = snapshot.getCreatedAt();\n    return new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_VERSION, targetDate, snapshot).setModeParameter(version);\n  }","id":74062,"modified_method":"PastSnapshot findByVersion(Snapshot projectSnapshot, String version) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() + \" where version=:version AND resourceId=:resourceId AND status=:status AND qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"version\", version)\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    PastSnapshot result;\n    if (snapshots.isEmpty()) {\n      result = new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_VERSION);\n    } else {\n      Snapshot snapshot = snapshots.get(0);\n      Date targetDate = snapshot.getCreatedAt();\n      result = new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_VERSION, targetDate, snapshot).setModeParameter(version);\n    }\n    return result;\n  }","commit_id":"b6c0e733080d9f53516bc865b1179da360499dca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void failIfUnknownVersion() {\n    thrown.expect(IllegalStateException.class);\n    thrown.expectMessage(\"Unknown project version: 0.1.2\");\n\n    setupData(\"shared\");\n\n    Snapshot currentProjectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1010);\n    PastSnapshotFinderByVersion finder = new PastSnapshotFinderByVersion(getSession());\n\n    finder.findByVersion(currentProjectSnapshot, \"0.1.2\");\n  }","id":74063,"modified_method":"/**\n   * Revert SONAR-3407\n   */\n  @Test\n  public void doNotFailIfUnknownVersion() {\n    setupData(\"shared\");\n\n    Snapshot currentProjectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1010);\n    PastSnapshotFinderByVersion finder = new PastSnapshotFinderByVersion(getSession());\n\n    PastSnapshot pastSnapshot = finder.findByVersion(currentProjectSnapshot, \"0.1.2\");\n    assertThat(pastSnapshot).isNotNull();\n    assertThat(pastSnapshot.getDate()).isNull();\n  }","commit_id":"b6c0e733080d9f53516bc865b1179da360499dca","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public PastSnapshot find(Snapshot projectSnapshot, Configuration conf, int index) {\n    String propertyValue = getPropertyValue(conf, index);\n    PastSnapshot pastSnapshot = find(projectSnapshot, index, propertyValue);\n    if (pastSnapshot == null && StringUtils.isNotBlank(propertyValue)) {\n      Logs.INFO.debug(\"The property \" + CoreProperties.TIMEMACHINE_PERIOD_PREFIX + index + \" has an unvalid value: \" + propertyValue);\n    }\n    return pastSnapshot;\n  }","id":74064,"modified_method":"public PastSnapshot find(Snapshot projectSnapshot, Configuration conf, int index) {\n    String propertyValue = getPropertyValue(conf, index);\n    PastSnapshot pastSnapshot = find(projectSnapshot, index, propertyValue);\n    if (pastSnapshot == null && StringUtils.isNotBlank(propertyValue)) {\n      LoggerFactory.getLogger(PastSnapshotFinder.class).debug(\"Property \" + CoreProperties.TIMEMACHINE_PERIOD_PREFIX + index + \" is not valid: \" + propertyValue);\n    }\n    return pastSnapshot;\n  }","commit_id":"8ab47b43ee0aceea2f5292f944fe63fdb8b6bf0e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"PastSnapshot findByVersion(Snapshot projectSnapshot, String version) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() + \" where version=:version AND resourceId=:resourceId AND status=:status AND qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"version\", version)\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    if (snapshots.isEmpty()) {\n      throw new IllegalStateException(\"Unknown project version: \" + version +\". Please check differential views in project settings.\");\n    }\n    Snapshot snapshot = snapshots.get(0);\n    Date targetDate = snapshot.getCreatedAt();\n    return new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_VERSION, targetDate, snapshot).setModeParameter(version);\n  }","id":74065,"modified_method":"PastSnapshot findByVersion(Snapshot projectSnapshot, String version) {\n    String hql = \"from \" + Snapshot.class.getSimpleName() + \" where version=:version AND resourceId=:resourceId AND status=:status AND qualifier<>:lib order by createdAt desc\";\n    List<Snapshot> snapshots = session.createQuery(hql)\n        .setParameter(\"version\", version)\n        .setParameter(\"resourceId\", projectSnapshot.getResourceId())\n        .setParameter(\"status\", Snapshot.STATUS_PROCESSED)\n        .setParameter(\"lib\", Qualifiers.LIBRARY)\n        .setMaxResults(1)\n        .getResultList();\n\n    PastSnapshot result;\n    if (snapshots.isEmpty()) {\n      result = new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_VERSION);\n    } else {\n      Snapshot snapshot = snapshots.get(0);\n      Date targetDate = snapshot.getCreatedAt();\n      result = new PastSnapshot(CoreProperties.TIMEMACHINE_MODE_VERSION, targetDate, snapshot).setModeParameter(version);\n    }\n    return result;\n  }","commit_id":"8ab47b43ee0aceea2f5292f944fe63fdb8b6bf0e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void failIfUnknownVersion() {\n    thrown.expect(IllegalStateException.class);\n    thrown.expectMessage(\"Unknown project version: 0.1.2\");\n\n    setupData(\"shared\");\n\n    Snapshot currentProjectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1010);\n    PastSnapshotFinderByVersion finder = new PastSnapshotFinderByVersion(getSession());\n\n    finder.findByVersion(currentProjectSnapshot, \"0.1.2\");\n  }","id":74066,"modified_method":"/**\n   * Revert SONAR-3407\n   */\n  @Test\n  public void doNotFailIfUnknownVersion() {\n    setupData(\"shared\");\n\n    Snapshot currentProjectSnapshot = getSession().getSingleResult(Snapshot.class, \"id\", 1010);\n    PastSnapshotFinderByVersion finder = new PastSnapshotFinderByVersion(getSession());\n\n    PastSnapshot pastSnapshot = finder.findByVersion(currentProjectSnapshot, \"0.1.2\");\n    assertThat(pastSnapshot).isNotNull();\n    assertThat(pastSnapshot.getDate()).isNull();\n  }","commit_id":"8ab47b43ee0aceea2f5292f944fe63fdb8b6bf0e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldLoadPluginDeprecatedExtensions() throws IOException {\n    RemotePlugin checkstyle = new RemotePlugin(\"checkstyle\", true)\n      .addFilename(\"checkstyle-ext.xml\");\n\n    PluginDownloader downloader = mock(PluginDownloader.class);\n    when(downloader.downloadPlugin(checkstyle)).thenReturn(copyFiles(\"sonar-checkstyle-plugin-2.8.jar\", \"checkstyle-ext.xml\"));\n\n    repository = new BatchPluginRepository(downloader, new Settings());\n\n    repository.doStart(Arrays.asList(checkstyle));\n\n    assertThat(repository.getPlugin(\"checkstyle\")).isNotNull();\n    assertThat(repository.getMetadata()).hasSize(1);\n    assertThat(repository.getMetadata(\"checkstyle\").getName()).isEqualTo(\"Checkstyle\");\n    assertThat(repository.getMetadata(\"checkstyle\").getDeployedFiles()).hasSize(5); // plugin + 3 dependencies + 1 deprecated\n    // extension\n  }","id":74067,"modified_method":"@Test\n  public void shouldLoadPluginDeprecatedExtensions() throws IOException {\n    RemotePlugin checkstyle = new RemotePlugin(\"checkstyle\", true);\n    checkstyle.getFiles().add(new RemotePluginFile(\"checkstyle-ext.xml\", \"fakemd5\"));\n\n    PluginDownloader downloader = mock(PluginDownloader.class);\n    when(downloader.downloadPlugin(checkstyle)).thenReturn(copyFiles(\"sonar-checkstyle-plugin-2.8.jar\", \"checkstyle-ext.xml\"));\n\n    repository = new BatchPluginRepository(downloader, new Settings());\n\n    repository.doStart(Arrays.asList(checkstyle));\n\n    assertThat(repository.getPlugin(\"checkstyle\")).isNotNull();\n    assertThat(repository.getMetadata()).hasSize(1);\n    assertThat(repository.getMetadata(\"checkstyle\").getName()).isEqualTo(\"Checkstyle\");\n    assertThat(repository.getMetadata(\"checkstyle\").getDeployedFiles()).hasSize(5); // plugin + 3 dependencies + 1 deprecated\n    // extension\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected void configure() {\n    container.addSingleton(globalProperties);\n    if (reactor != null) {\n      container.addSingleton(reactor);\n    }\n    container.addSingleton(new PropertiesConfiguration());\n    container.addSingleton(BootstrapSettings.class);\n    container.addSingleton(ServerClient.class);\n    container.addSingleton(BatchSettings.class);\n    container.addSingleton(BatchPluginRepository.class);\n    container.addSingleton(ExtensionInstaller.class);\n    container.addSingleton(Logback.class);\n    container.addSingleton(ServerMetadata.class);\n    container.addSingleton(org.sonar.batch.ServerMetadata.class);\n    container.addSingleton(TempDirectories.class);\n    container.addSingleton(HttpDownloader.class);\n    container.addSingleton(UriReader.class);\n    container.addSingleton(PluginDownloader.class);\n    for (Object component : boostrapperComponents) {\n      if (component != null) {\n        container.addSingleton(component);\n      }\n    }\n    if (!isMavenPluginExecutorRegistered()) {\n      container.addSingleton(FakeMavenPluginExecutor.class);\n    }\n  }","id":74068,"modified_method":"@Override\n  protected void configure() {\n    container.addSingleton(globalProperties);\n    if (reactor != null) {\n      container.addSingleton(reactor);\n    }\n    container.addSingleton(new PropertiesConfiguration());\n    container.addSingleton(BootstrapSettings.class);\n    container.addSingleton(ServerClient.class);\n    container.addSingleton(BatchSettings.class);\n    container.addSingleton(BatchPluginRepository.class);\n    container.addSingleton(ExtensionInstaller.class);\n    container.addSingleton(Logback.class);\n    container.addSingleton(ServerMetadata.class);\n    container.addSingleton(org.sonar.batch.ServerMetadata.class);\n    container.addSingleton(TempDirectories.class);\n    container.addSingleton(HttpDownloader.class);\n    container.addSingleton(UriReader.class);\n    container.addSingleton(PluginDownloader.class);\n    container.addSingleton(BatchSonarCache.class);\n    for (Object component : boostrapperComponents) {\n      if (component != null) {\n        container.addSingleton(component);\n      }\n    }\n    if (!isMavenPluginExecutorRegistered()) {\n      container.addSingleton(FakeMavenPluginExecutor.class);\n    }\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<File> downloadPlugin(RemotePlugin remote) {\n    try {\n      File targetDir = workingDirectories.getDir(\"plugins/\" + remote.getKey());\n      FileUtils.forceMkdir(targetDir);\n      LOG.debug(\"Downloading plugin \" + remote.getKey() + \" into \" + targetDir);\n\n      List<File> files = Lists.newArrayList();\n      for (String filename : remote.getFilenames()) {\n        String url = \"/deploy/plugins/\" + remote.getKey() + \"/\" + filename;\n        File toFile = new File(targetDir, filename);\n        server.download(url, toFile);\n        files.add(toFile);\n      }\n      return files;\n\n    } catch (Exception e) {\n      throw new SonarException(\"Fail to download plugin: \" + remote.getKey(), e);\n    }\n  }","id":74069,"modified_method":"public List<File> downloadPlugin(RemotePlugin remote) {\n    try {\n      List<File> files = Lists.newArrayList();\n      for (RemotePluginFile file : remote.getFiles()) {\n        LOG.debug(\"Looking if plugin file {} with md5 {} is already in cache\", file.getFilename(), file.getMd5());\n        File fileInCache = getSonarCache().getFileFromCache(file.getFilename(), file.getMd5());\n        if (fileInCache != null) {\n          LOG.debug(\"File is already cached at location {}\", fileInCache.getAbsolutePath());\n        }\n        else {\n          LOG.debug(\"File is not cached\");\n          File tmpDownloadFile = getSonarCache().getTemporaryFile();\n          String url = \"/deploy/plugins/\" + remote.getKey() + \"/\" + file.getFilename();\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Downloading {} to {}\", url, tmpDownloadFile.getAbsolutePath());\n          }\n          else {\n            LOG.info(\"Downloading {}\", file.getFilename());\n          }\n          server.download(url, tmpDownloadFile);\n          LOG.debug(\"Trying to cache file\");\n          String md5 = getSonarCache().cacheFile(tmpDownloadFile, file.getFilename());\n          fileInCache = getSonarCache().getFileFromCache(file.getFilename(), md5);\n          if (!md5.equals(file.getMd5())) {\n            LOG.warn(\"INVALID CHECKSUM: File {} was expected to have checksum {} but was cached with checksum {}\",\n                new String[] {fileInCache.getAbsolutePath(), file.getMd5(), md5});\n          }\n          LOG.debug(\"File cached at location {}\", fileInCache.getAbsolutePath());\n        }\n        files.add(fileInCache);\n      }\n      return files;\n\n    } catch (Exception e) {\n      throw new SonarException(\"Fail to download plugin: \" + remote.getKey(), e);\n    }\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public PluginDownloader(TempDirectories workingDirectories, ServerClient server) {\n    this.workingDirectories = workingDirectories;\n    this.server = server;\n  }","id":74070,"modified_method":"public PluginDownloader(BatchSonarCache batchCache, ServerClient server) {\n    this.server = server;\n    this.batchCache = batchCache;\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_fail_to_get_plugin_index() throws Exception {\n    thrown.expect(SonarException.class);\n\n    ServerClient server = mock(ServerClient.class);\n    doThrow(new SonarException()).when(server).request(\"/deploy/plugins/index.txt\");\n\n    new PluginDownloader(mock(TempDirectories.class), server).downloadPluginIndex();\n  }","id":74071,"modified_method":"@Test\n  public void should_fail_to_get_plugin_index() throws Exception {\n    thrown.expect(SonarException.class);\n\n    ServerClient server = mock(ServerClient.class);\n    doThrow(new SonarException()).when(server).request(\"/deploy/plugins/index.txt\");\n\n    new PluginDownloader(new BatchSonarCache(new Settings()), server).downloadPluginIndex();\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_request_list_of_plugins() {\n    TempDirectories tempDirs = mock(TempDirectories.class);\n    ServerClient server = mock(ServerClient.class);\n    when(server.request(\"/deploy/plugins/index.txt\")).thenReturn(\"checkstyle,true\\nsqale,false\");\n    PluginDownloader downloader = new PluginDownloader(tempDirs, server);\n\n    List<RemotePlugin> plugins = downloader.downloadPluginIndex();\n    assertThat(plugins).hasSize(2);\n    assertThat(plugins.get(0).getKey()).isEqualTo(\"checkstyle\");\n    assertThat(plugins.get(0).isCore()).isTrue();\n    assertThat(plugins.get(1).getKey()).isEqualTo(\"sqale\");\n    assertThat(plugins.get(1).isCore()).isFalse();\n  }","id":74072,"modified_method":"@Test\n  public void should_request_list_of_plugins() {\n    ServerClient server = mock(ServerClient.class);\n    when(server.request(\"/deploy/plugins/index.txt\")).thenReturn(\"checkstyle,true\\nsqale,false\");\n    PluginDownloader downloader = new PluginDownloader(new BatchSonarCache(new Settings()), server);\n\n    List<RemotePlugin> plugins = downloader.downloadPluginIndex();\n    assertThat(plugins).hasSize(2);\n    assertThat(plugins.get(0).getKey()).isEqualTo(\"checkstyle\");\n    assertThat(plugins.get(0).isCore()).isTrue();\n    assertThat(plugins.get(1).getKey()).isEqualTo(\"sqale\");\n    assertThat(plugins.get(1).isCore()).isFalse();\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void should_download_plugin() throws Exception {\n    TempDirectories tempDirs = mock(TempDirectories.class);\n    File toDir = temp.newFolder();\n    when(tempDirs.getDir(\"plugins/checkstyle\")).thenReturn(toDir);\n    ServerClient server = mock(ServerClient.class);\n    PluginDownloader downloader = new PluginDownloader(tempDirs, server);\n\n    RemotePlugin plugin = new RemotePlugin(\"checkstyle\", true)\n      .addFilename(\"checkstyle-plugin.jar\")\n      .addFilename(\"checkstyle-extensions.jar\");\n    List<File> files = downloader.downloadPlugin(plugin);\n\n    File pluginFile = new File(toDir, \"checkstyle-plugin.jar\");\n    File extFile = new File(toDir, \"checkstyle-extensions.jar\");\n    assertThat(files).hasSize(2);\n    assertThat(files).containsOnly(pluginFile, extFile);\n    verify(server).download(\"/deploy/plugins/checkstyle/checkstyle-plugin.jar\", pluginFile);\n    verify(server).download(\"/deploy/plugins/checkstyle/checkstyle-extensions.jar\", extFile);\n  }","id":74073,"modified_method":"@Test\n  public void should_download_plugin_if_not_cached() throws Exception {\n    SonarCache cache = mock(SonarCache.class);\n    BatchSonarCache batchCache = mock(BatchSonarCache.class);\n    when(batchCache.getCache()).thenReturn(cache);\n\n    File fileInCache = temp.newFile();\n    when(cache.cacheFile(Mockito.any(File.class), Mockito.anyString())).thenReturn(\"fakemd51\").thenReturn(\"fakemd52\");\n    when(cache.getFileFromCache(Mockito.anyString(), Mockito.anyString()))\n        .thenReturn(null)\n        .thenReturn(fileInCache)\n        .thenReturn(null)\n        .thenReturn(fileInCache);\n    ServerClient server = mock(ServerClient.class);\n    PluginDownloader downloader = new PluginDownloader(batchCache, server);\n\n    RemotePlugin plugin = new RemotePlugin(\"checkstyle\", true)\n        .addFile(\"checkstyle-plugin.jar\", \"fakemd51\")\n        .addFile(\"checkstyle-extensions.jar\", \"fakemd52\");\n    List<File> files = downloader.downloadPlugin(plugin);\n\n    assertThat(files).hasSize(2);\n    verify(server).download(Mockito.eq(\"/deploy/plugins/checkstyle/checkstyle-plugin.jar\"), Mockito.any(File.class));\n    verify(server).download(Mockito.eq(\"/deploy/plugins/checkstyle/checkstyle-extensions.jar\"), Mockito.any(File.class));\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public String getPluginFilename() {\n    return (!filenames.isEmpty() ? filenames.get(0) : null);\n  }","id":74074,"modified_method":"public String getPluginFilename() {\n    return (!files.isEmpty() ? files.get(0).getFilename() : null);\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static RemotePlugin unmarshal(String row) {\n    String[] fields = StringUtils.split(row, \",\");\n    RemotePlugin result = new RemotePlugin(fields[0], Boolean.parseBoolean(fields[1]));\n    if (fields.length > 2) {\n      for (int index = 2; index < fields.length; index++) {\n        result.addFilename(fields[index]);\n      }\n    }\n    return result;\n  }","id":74075,"modified_method":"public static RemotePlugin unmarshal(String row) {\n    String[] fields = StringUtils.split(row, \",\");\n    RemotePlugin result = new RemotePlugin(fields[0], Boolean.parseBoolean(fields[1]));\n    if (fields.length > 2) {\n      for (int index = 2; index < fields.length; index++) {\n        String[] nameAndMd5 = StringUtils.split(fields[index], \"|\");\n        result.addFile(nameAndMd5[0], nameAndMd5.length > 1 ? nameAndMd5[1] : null);\n      }\n    }\n    return result;\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public List<String> getFilenames() {\n    return filenames;\n  }","id":74076,"modified_method":"public List<RemotePluginFile> getFiles() {\n    return files;\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public RemotePlugin addFilename(String s) {\n    filenames.add(s);\n    return this;\n  }","id":74077,"modified_method":"public RemotePlugin addFile(String filename, String md5) {\n    files.add(new RemotePluginFile(filename, md5));\n    return this;\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static RemotePlugin create(DefaultPluginMetadata metadata) {\n    RemotePlugin result = new RemotePlugin(metadata.getKey(), metadata.isCore());\n    result.addFilename(metadata.getFile().getName());\n    for (File file : metadata.getDeprecatedExtensions()) {\n      result.addFilename(file.getName());\n    }\n    return result;\n  }","id":74078,"modified_method":"public static RemotePlugin create(DefaultPluginMetadata metadata) {\n    RemotePlugin result = new RemotePlugin(metadata.getKey(), metadata.isCore());\n    result.addFile(metadata.getFile());\n    for (File file : metadata.getDeprecatedExtensions()) {\n      result.addFile(file);\n    }\n    return result;\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public String marshal() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(pluginKey).append(\",\");\n    sb.append(String.valueOf(core));\n    for (String filename : filenames) {\n      sb.append(\",\").append(filename);\n    }\n    return sb.toString();\n  }","id":74079,"modified_method":"public String marshal() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(pluginKey).append(\",\");\n    sb.append(String.valueOf(core));\n    for (RemotePluginFile file : files) {\n      sb.append(\",\").append(file.getFilename());\n      if (StringUtils.isNotBlank(file.getMd5())) {\n        sb.append(\"|\").append(file.getMd5());\n      }\n    }\n    return sb.toString();\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldMarshal() {\n    RemotePlugin clirr = new RemotePlugin(\"clirr\", false).addFilename(\"clirr-1.1.jar\");\n    String text = clirr.marshal();\n    assertThat(text, is(\"clirr,false,clirr-1.1.jar\"));\n  }","id":74080,"modified_method":"@Test\n  public void shouldMarshal() {\n    RemotePlugin clirr = new RemotePlugin(\"clirr\", false).addFile(\"clirr-1.1.jar\", \"fakemd5\");\n    String text = clirr.marshal();\n    assertThat(text, is(\"clirr,false,clirr-1.1.jar|fakemd5\"));\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldUnmarshal() {\n    RemotePlugin clirr = RemotePlugin.unmarshal(\"clirr,false,clirr-1.1.jar\");\n    assertThat(clirr.getKey(), is(\"clirr\"));\n    assertThat(clirr.isCore(), is(false));\n    assertThat(clirr.getFilenames().size(), is(1));\n    assertThat(clirr.getFilenames().get(0), is(\"clirr-1.1.jar\"));\n\n  }","id":74081,"modified_method":"@Test\n  public void shouldUnmarshal() {\n    RemotePlugin clirr = RemotePlugin.unmarshal(\"clirr,false,clirr-1.1.jar|fakemd5\");\n    assertThat(clirr.getKey(), is(\"clirr\"));\n    assertThat(clirr.isCore(), is(false));\n    assertThat(clirr.getFiles().size(), is(1));\n    assertThat(clirr.getFiles().get(0).getFilename(), is(\"clirr-1.1.jar\"));\n    assertThat(clirr.getFiles().get(0).getMd5(), is(\"fakemd5\"));\n\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldMarshalDeprecatedExtensions() {\n    RemotePlugin checkstyle = new RemotePlugin(\"checkstyle\", true);\n    checkstyle.addFilename(\"checkstyle-2.8.jar\");\n    checkstyle.addFilename(\"ext.xml\");\n    checkstyle.addFilename(\"ext.jar\");\n\n    String text = checkstyle.marshal();\n    assertThat(text, is(\"checkstyle,true,checkstyle-2.8.jar,ext.xml,ext.jar\"));\n  }","id":74082,"modified_method":"@Test\n  public void shouldMarshalDeprecatedExtensions() {\n    RemotePlugin checkstyle = new RemotePlugin(\"checkstyle\", true)\n        .addFile(\"checkstyle-2.8.jar\", \"fakemd51\")\n        .addFile(\"ext.xml\", \"fakemd52\")\n        .addFile(\"ext.jar\", \"fakemd53\");\n\n    String text = checkstyle.marshal();\n    assertThat(text, is(\"checkstyle,true,checkstyle-2.8.jar|fakemd51,ext.xml|fakemd52,ext.jar|fakemd53\"));\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void shouldUnmarshalDeprecatedExtensions() {\n    RemotePlugin checkstyle = RemotePlugin.unmarshal(\"checkstyle,true,checkstyle-2.8.jar,ext.xml,ext.jar\");\n    assertThat(checkstyle.getKey(), is(\"checkstyle\"));\n    assertThat(checkstyle.isCore(), is(true));\n    assertThat(checkstyle.getFilenames().size(), is(3));\n    assertThat(checkstyle.getFilenames(), hasItems(\"checkstyle-2.8.jar\", \"ext.xml\", \"ext.jar\"));\n  }","id":74083,"modified_method":"@Test\n  public void shouldUnmarshalDeprecatedExtensions() {\n    RemotePlugin checkstyle = RemotePlugin.unmarshal(\"checkstyle,true,checkstyle-2.8.jar,ext.xml,ext.jar\");\n    assertThat(checkstyle.getKey(), is(\"checkstyle\"));\n    assertThat(checkstyle.isCore(), is(true));\n    assertThat(checkstyle.getFiles().size(), is(3));\n    assertThat(checkstyle.getFiles().get(0).getFilename(), is(\"checkstyle-2.8.jar\"));\n    assertThat(checkstyle.getFiles().get(1).getFilename(), is(\"ext.xml\"));\n    assertThat(checkstyle.getFiles().get(2).getFilename(), is(\"ext.jar\"));\n  }","commit_id":"ee10ce224ea3f6eaf389ad0c4572270de80b1cd9","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ArtifactResolveResult download(final Artifact artifact) throws ArtifactResolveException {\n        return cacheLockingManager.longRunningOperation(String.format(\"Download %s using repository %s\", artifact, getId()), new Factory<ArtifactResolveResult>() {\n            public ArtifactResolveResult create() {\n                return repository.download(artifact);\n            }\n        });\n    }","id":74084,"modified_method":"public void download(final Artifact artifact, final BuildableArtifactResolveResult result) {\n        cacheLockingManager.longRunningOperation(String.format(\"Download %s using repository %s\", artifact, getId()), new Runnable() {\n            public void run() {\n                repository.download(artifact, result);\n            }\n        });\n    }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactResolveResult download(Artifact artifact) {\n        if (isLocal()) {\n            return delegate.download(artifact);\n        }\n\n        ArtifactAtRepositoryKey resolutionCacheIndexKey = new ArtifactAtRepositoryKey(delegate, artifact.getId());\n\n        // Look in the cache for this resolver\n        CachedExternalResource cached = artifactAtRepositoryCachedResolutionIndex.lookup(resolutionCacheIndexKey);\n\n        if (cached != null) {\n            ArtifactIdentifier artifactIdentifier = createArtifactIdentifier(artifact);\n            long age = timeProvider.getCurrentTime() - cached.getCachedAt();\n            if (cached.isMissing()) {\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, null, age)) {\n                    LOGGER.debug(\"Detected non-existence of artifact '{}' in resolver cache\", artifact.getId());\n                    return new BrokenArtifactResolveResult(new ArtifactNotFoundException(artifact));\n                }\n            } else {\n                File cachedArtifactFile = cached.getCachedFile();\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, cachedArtifactFile, age)) {\n                    LOGGER.debug(\"Found artifact '{}' in resolver cache: {}\", artifact.getId(), cachedArtifactFile);\n                    return new FileBackedArtifactResolveResult(cachedArtifactFile, cached.getExternalResourceMetaData());\n                }\n            }\n        }\n\n        ArtifactResolveResult downloadedArtifact = delegate.download(artifact);\n        LOGGER.debug(\"Downloaded artifact '{}' from resolver: {}\", artifact.getId(), delegate);\n\n        if (downloadedArtifact.getFailure() instanceof ArtifactNotFoundException) {\n            artifactAtRepositoryCachedResolutionIndex.storeMissing(resolutionCacheIndexKey);\n        } else {\n            artifactAtRepositoryCachedResolutionIndex.store(resolutionCacheIndexKey, downloadedArtifact.getFile(), downloadedArtifact.getExternalResourceMetaData());\n        }\n\n        return downloadedArtifact;\n    }","id":74085,"modified_method":"public void download(Artifact artifact, BuildableArtifactResolveResult result) {\n        if (isLocal()) {\n            delegate.download(artifact, result);\n            return;\n        }\n\n        ArtifactAtRepositoryKey resolutionCacheIndexKey = new ArtifactAtRepositoryKey(delegate, artifact.getId());\n\n        // Look in the cache for this resolver\n        CachedExternalResource cached = artifactAtRepositoryCachedResolutionIndex.lookup(resolutionCacheIndexKey);\n\n        if (cached != null) {\n            ArtifactIdentifier artifactIdentifier = createArtifactIdentifier(artifact);\n            long age = timeProvider.getCurrentTime() - cached.getCachedAt();\n            if (cached.isMissing()) {\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, null, age)) {\n                    LOGGER.debug(\"Detected non-existence of artifact '{}' in resolver cache\", artifact.getId());\n                    result.notFound(artifact);\n                    return;\n                }\n            } else {\n                File cachedArtifactFile = cached.getCachedFile();\n                if (!cachePolicy.mustRefreshArtifact(artifactIdentifier, cachedArtifactFile, age)) {\n                    LOGGER.debug(\"Found artifact '{}' in resolver cache: {}\", artifact.getId(), cachedArtifactFile);\n                    result.resolved(cachedArtifactFile, cached.getExternalResourceMetaData());\n                    return;\n                }\n            }\n        }\n\n        delegate.download(artifact, result);\n        LOGGER.debug(\"Downloaded artifact '{}' from resolver: {}\", artifact.getId(), delegate);\n\n        if (result.getFailure() instanceof ArtifactNotFoundException) {\n            artifactAtRepositoryCachedResolutionIndex.storeMissing(resolutionCacheIndexKey);\n        } else {\n            artifactAtRepositoryCachedResolutionIndex.store(resolutionCacheIndexKey, result.getFile(), result.getExternalResourceMetaData());\n        }\n    }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactResolveResult download(Artifact artifact) {\n        EnhancedArtifactDownloadReport artifactDownloadReport = resolver.download(artifact);\n        if (downloadFailed(artifactDownloadReport)) {\n            return new BrokenArtifactResolveResult(new ArtifactResolveException(artifactDownloadReport.getArtifact(), artifactDownloadReport.getFailure()));\n        }\n\n        ArtifactOriginWithMetaData artifactOrigin = artifactDownloadReport.getArtifactOrigin();\n\n        File localFile = artifactDownloadReport.getLocalFile();\n        if (localFile != null) {\n            ExternalResourceMetaData metaData = artifactOrigin.getMetaData();\n            return new FileBackedArtifactResolveResult(localFile, metaData);\n        } else {\n            return new BrokenArtifactResolveResult(new ArtifactNotFoundException(artifact));\n        }\n    }","id":74086,"modified_method":"public void download(Artifact artifact, BuildableArtifactResolveResult result) {\n        EnhancedArtifactDownloadReport artifactDownloadReport = resolver.download(artifact);\n        if (downloadFailed(artifactDownloadReport)) {\n            result.failed(new ArtifactResolveException(artifactDownloadReport.getArtifact(), artifactDownloadReport.getFailure()));\n            return;\n        }\n\n        ArtifactOriginWithMetaData artifactOrigin = artifactDownloadReport.getArtifactOrigin();\n\n        File localFile = artifactDownloadReport.getLocalFile();\n        if (localFile != null) {\n            ExternalResourceMetaData metaData = artifactOrigin.getMetaData();\n            result.resolved(localFile, metaData);\n        } else {\n            result.notFound(artifact);\n        }\n    }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactResolveResult download(Artifact artifact) {\n        ArtifactDownloadReport artifactDownloadReport = resolver.download(new Artifact[]{artifact}, downloadOptions).getArtifactReport(artifact);\n        if (downloadFailed(artifactDownloadReport)) {\n            if (artifactDownloadReport instanceof EnhancedArtifactDownloadReport) {\n                EnhancedArtifactDownloadReport enhancedReport = (EnhancedArtifactDownloadReport) artifactDownloadReport;\n                return new BrokenArtifactResolveResult(new ArtifactResolveException(artifactDownloadReport.getArtifact(), enhancedReport.getFailure()));\n            }\n            return new BrokenArtifactResolveResult(new ArtifactResolveException(artifactDownloadReport.getArtifact(), artifactDownloadReport.getDownloadDetails()));\n        }\n\n        ArtifactOrigin artifactOrigin = artifactDownloadReport.getArtifactOrigin();\n\n        File localFile = artifactDownloadReport.getLocalFile();\n        if (localFile != null) {\n            ExternalResourceMetaData metaData = null;\n            if (artifactOrigin instanceof ArtifactOriginWithMetaData) {\n                metaData = ((ArtifactOriginWithMetaData) artifactOrigin).getMetaData();\n            }\n            return new FileBackedArtifactResolveResult(localFile, metaData);\n        } else {\n            return new BrokenArtifactResolveResult(new ArtifactNotFoundException(artifact));\n        }\n    }","id":74087,"modified_method":"public void download(Artifact artifact, BuildableArtifactResolveResult result) {\n        ArtifactDownloadReport artifactDownloadReport = resolver.download(new Artifact[]{artifact}, downloadOptions).getArtifactReport(artifact);\n        if (downloadFailed(artifactDownloadReport)) {\n            if (artifactDownloadReport instanceof EnhancedArtifactDownloadReport) {\n                EnhancedArtifactDownloadReport enhancedReport = (EnhancedArtifactDownloadReport) artifactDownloadReport;\n                result.failed(new ArtifactResolveException(artifactDownloadReport.getArtifact(), enhancedReport.getFailure()));\n            } else {\n                result.failed(new ArtifactResolveException(artifactDownloadReport.getArtifact(), artifactDownloadReport.getDownloadDetails()));\n            }\n            return;\n        }\n\n        ArtifactOrigin artifactOrigin = artifactDownloadReport.getArtifactOrigin();\n\n        File localFile = artifactDownloadReport.getLocalFile();\n        if (localFile != null) {\n            ExternalResourceMetaData metaData = null;\n            if (artifactOrigin instanceof ArtifactOriginWithMetaData) {\n                metaData = ((ArtifactOriginWithMetaData) artifactOrigin).getMetaData();\n            }\n            result.resolved(localFile, metaData);\n        } else {\n            result.notFound(artifact);\n        }\n    }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactResolveResult resolve(Artifact artifact) throws ArtifactResolveException {\n            ArtifactResolveResult result;\n            try {\n                result = resolver.resolve(artifact);\n            } catch (Throwable t) {\n                return new BrokenArtifactResolveResult(new ArtifactResolveException(artifact, t));\n            }\n            return result;\n        }","id":74088,"modified_method":"public void resolve(Artifact artifact, BuildableArtifactResolveResult result) {\n            try {\n                resolver.resolve(artifact, result);\n            } catch (Throwable t) {\n                result.failed(new ArtifactResolveException(artifact, t));\n            }\n        }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    public ArtifactOrigin locate(final Artifact artifact) {\n        return cacheLockingManager.useCache(String.format(\"Locate %s\", artifact), new Factory<ArtifactOrigin>() {\n            public ArtifactOrigin create() {\n                try {\n                    DependencyDescriptor dependencyDescriptor = new DefaultDependencyDescriptor(artifact.getModuleRevisionId(), false);\n                    DefaultBuildableModuleVersionResolveResult dependency = new DefaultBuildableModuleVersionResolveResult();\n                    userResolverChain.resolve(dependencyDescriptor, dependency);\n                    File artifactFile = dependency.getArtifactResolver().resolve(artifact).getFile();\n                    return new ArtifactOrigin(artifact, false, artifactFile.getAbsolutePath());\n                } catch (ModuleVersionNotFoundException e) {\n                    return null;\n                } catch (ArtifactNotFoundException e) {\n                    return null;\n                }\n            }\n        });\n    }","id":74089,"modified_method":"@Override\n    public ArtifactOrigin locate(final Artifact artifact) {\n        return cacheLockingManager.useCache(String.format(\"Locate %s\", artifact), new Factory<ArtifactOrigin>() {\n            public ArtifactOrigin create() {\n                try {\n                    DependencyDescriptor dependencyDescriptor = new DefaultDependencyDescriptor(artifact.getModuleRevisionId(), false);\n                    DefaultBuildableModuleVersionResolveResult dependency = new DefaultBuildableModuleVersionResolveResult();\n                    userResolverChain.resolve(dependencyDescriptor, dependency);\n                    DefaultBuildableArtifactResolveResult result = new DefaultBuildableArtifactResolveResult();\n                    dependency.getArtifactResolver().resolve(artifact, result);\n                    File artifactFile = result.getFile();\n                    return new ArtifactOrigin(artifact, false, artifactFile.getAbsolutePath());\n                } catch (ModuleVersionNotFoundException e) {\n                    return null;\n                } catch (ArtifactNotFoundException e) {\n                    return null;\n                }\n            }\n        });\n    }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactResolveResult resolve(Artifact artifact) throws ArtifactResolveException {\n            String path = artifact.getExtraAttribute(DefaultIvyDependencyPublisher.FILE_ABSOLUTE_PATH_EXTRA_ATTRIBUTE);\n            return new FileBackedArtifactResolveResult(new File(path), null);\n        }","id":74090,"modified_method":"public void resolve(Artifact artifact, BuildableArtifactResolveResult result) {\n            String path = artifact.getExtraAttribute(DefaultIvyDependencyPublisher.FILE_ABSOLUTE_PATH_EXTRA_ATTRIBUTE);\n            result.resolved(new File(path), null);\n        }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ResolvedArtifact create(ResolvedDependency owner, final Artifact artifact, final ArtifactResolver resolver) {\n        return new DefaultResolvedArtifact(owner, artifact, new Factory<File>() {\n            public File create() {\n                return lockingManager.useCache(String.format(\"download %s\", artifact), new Factory<File>() {\n                    public File create() {\n                        return resolver.resolve(artifact).getFile();\n                    }\n                });\n            }\n        });\n    }","id":74091,"modified_method":"public ResolvedArtifact create(ResolvedDependency owner, final Artifact artifact, final ArtifactResolver resolver) {\n        return new DefaultResolvedArtifact(owner, artifact, new Factory<File>() {\n            public File create() {\n                return lockingManager.useCache(String.format(\"download %s\", artifact), new Factory<File>() {\n                    public File create() {\n                        DefaultBuildableArtifactResolveResult result = new DefaultBuildableArtifactResolveResult();\n                        resolver.resolve(artifact, result);\n                        return result.getFile();\n                    }\n                });\n            }\n        });\n    }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactResolveResult download(Artifact artifact) {\n            return new BrokenArtifactResolveResult(new ArtifactResolveException(artifact, \"No cached version available for offline mode\"));\n        }","id":74092,"modified_method":"public void download(Artifact artifact, BuildableArtifactResolveResult result) {\n            result.failed(new ArtifactResolveException(artifact, \"No cached version available for offline mode\"));\n        }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"public ArtifactResolveResult resolve(Artifact artifact) {\n            LOGGER.debug(\"Attempting to download {} using repository '{}'\", artifact, repository.getName());\n            ArtifactResolveResult result;\n            try {\n                result = repository.download(artifact);\n            } catch (ArtifactResolveException e) {\n                return new BrokenArtifactResolveResult(e);\n            }\n            if (result == null) {\n                return new BrokenArtifactResolveResult(new ArtifactNotFoundException(artifact));\n            }\n            return result;\n        }","id":74093,"modified_method":"public void resolve(Artifact artifact, BuildableArtifactResolveResult result) {\n            LOGGER.debug(\"Attempting to download {} using repository '{}'\", artifact, repository.getName());\n            repository.download(artifact, result);\n        }","commit_id":"6534b1fcda1a37f65024a4be95f0941203ba6b75","url":"https://github.com/gradle/gradle"},{"original_method":"@Override\n    protected ClassPathXmlApplicationContext createApplicationContext() {\n        return new ClassPathXmlApplicationContext(\"org/apache/camel/component/cxf/GreeterEndpointBeans.xml\");\n    }","id":74094,"modified_method":"@Override\n    protected CamelContext createCamelContext() throws Exception {\n        return SpringTestHelper.createSpringCamelContext(this, \"org/apache/camel/component/cxf/GreeterEndpointBeans.xml\");\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"private void handleResponse(org.apache.camel.Exchange exchange) {\n            org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(exchange, true); \n            getLogger().log(Level.FINE, \"incoming observer is \" + incomingObserver);\n            incomingObserver.onMessage(inMessage);\n        }","id":74095,"modified_method":"private void handleResponse(org.apache.camel.Exchange exchange) {            \n            org.apache.cxf.message.Message inMessage = CxfSoapBinding.getCxfInMessage(exchange, true);           \n            incomingObserver.onMessage(inMessage);\n        }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void setCamelTemplate(CamelTemplate template) {\n        \n    }","id":74096,"modified_method":"public void setCamelTemplate(CamelTemplate<Exchange> template) {\n        camelTemplate = template;\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"private void commitOutputMessage() {\n            // we could wait for the rely asynconized\n            org.apache.camel.Exchange exchange = getCamelTemplate().send(targetCamelEndpointUri, new Processor() {\n                public void process(org.apache.camel.Exchange ex) throws IOException {\n                    CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n                    // send out the request message here\n                    ex.getIn().setHeaders(outMessage);\n                    ex.getIn().setBody(outputStream.getInputStream());\n                    // setup the out message\n                    getLogger().log(Level.FINE, \"template sending request: \", ex.getIn());\n                }\n            });\n            if (!isOneWay) {\n                handleResponse(exchange);\n            }\n            \n        }","id":74097,"modified_method":"private void commitOutputMessage() {\n            ExchangePattern pattern; \n            if (isOneWay) {\n                pattern = ExchangePattern.InOnly;\n            } else {\n                pattern = ExchangePattern.InOut;\n            }\n            getLogger().log(Level.FINE, \"send the message to endpoint\" + targetCamelEndpointUri);\n            // we could wait for the rely asynconized\n            org.apache.camel.Exchange exchange = getCamelTemplate().send(targetCamelEndpointUri, pattern, new Processor() {\n                public void process(org.apache.camel.Exchange ex) throws IOException {\n                    CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n                    // send out the request message here\n                    ex.getIn().setHeaders(outMessage);\n                    ex.getIn().setBody(outputStream.getInputStream());                    \n                    // setup the out message\n                    getLogger().log(Level.FINE, \"template sending request: \", ex.getIn());\n                }\n            });\n            \n            if (!isOneWay) {\n                handleResponse(exchange);\n            }\n            \n        }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"private void initConfig() {\n        // we could configure the camel context here     \n        Configurer configurer = bus.getExtension(Configurer.class);\n        if (null != configurer) {\n            configurer.configureBean(this);\n        }\n    }","id":74098,"modified_method":"private void initConfig() {\n        // we could configure the camel context here \n        if(bus != null) {\n            Configurer configurer = bus.getExtension(Configurer.class);\n            if (null != configurer) {\n                configurer.configureBean(this);\n            }\n        }    \n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public CamelConduit(CamelContext context, Bus b, EndpointInfo epInfo, EndpointReferenceType targetReference) {\n        super(targetReference);\n        AttributedURIType address = targetReference.getAddress();\n        if (address != null) {\n            this.targetCamelEndpointUri = address.getValue();\n        }\n        endpointInfo = epInfo;\n        camelContext = context;\n        bus = b;\n        initConfig();\n    }","id":74099,"modified_method":"public CamelConduit(CamelContext context, Bus b, EndpointInfo epInfo, EndpointReferenceType targetReference) {\n        super(targetReference);\n        String address = epInfo.getAddress();\n        if (address != null) {\n            targetCamelEndpointUri = address.substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());\n            if (targetCamelEndpointUri.startsWith(\"//\")) {\n                targetCamelEndpointUri = targetCamelEndpointUri.substring(2);     \n            }           \n        }\n        camelContext = context;\n        endpointInfo = epInfo;        \n        bus = b;\n        initConfig();\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void verifyReceivedMessage(Message message) {\n        ByteArrayInputStream bis = (ByteArrayInputStream)inMessage.getContent(InputStream.class);\n        byte bytes[] = new byte[bis.available()];\n        try {\n            bis.read(bytes);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        String reponse = new String(bytes);\n        assertEquals(\"The reponse date should be equals\", reponse, \"HelloWorld\");\n\n        /*\n         * CamelMessageHeadersType inHeader =\n         * (CamelMessageHeadersType)inMessage.get(CamelConstants.Camel_CLIENT_RESPONSE_HEADERS);\n         * assertTrue(\"The inMessage Camel Header should not be null\", inHeader !=\n         * null);\n         */\n\n    }","id":74100,"modified_method":"public void verifyReceivedMessage() {\n        ByteArrayInputStream bis = (ByteArrayInputStream)inMessage.getContent(InputStream.class);\n        byte bytes[] = new byte[bis.available()];\n        try {\n            bis.read(bytes);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n        String reponse = new String(bytes);\n        assertEquals(\"The reponse date should be equals\", reponse, \"HelloWorld\");\n\n        \n\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void testSendOut() throws Exception {\n        setupServiceInfo(\"http://cxf.apache.org/hello_world_camel\", \"/wsdl/camel_test.wsdl\", \"HelloWorldServiceLoop\", \"HelloWorldPortLoop\");\n\n        CamelConduit conduit = setupCamelConduit(true, false);\n        Message message = new MessageImpl();\n        // set the isOneWay to false\n        sendoutMessage(conduit, message, false);\n        verifyReceivedMessage(message);\n    }","id":74101,"modified_method":"public void testSendOut() throws Exception {       \n        endpointInfo.setAddress(\"camel://direct:Producer\");\n        CamelConduit conduit = setupCamelConduit(endpointInfo, true, false);\n        MockEndpoint endpoint = getMockEndpoint(\"mock:EndpointA\");\n        endpoint.expectedMessageCount(1);\n        Message message = new MessageImpl();\n        // set the isOneWay to be true\n        sendoutMessage(conduit, message, true, \"HelloWorld\");\n        assertMockEndpointsSatisifed();\n        // verify the endpoint get the response \n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void testPrepareSend() throws Exception {\n        setupServiceInfo(\"http://cxf.apache.org/hello_world_camel\", \"/wsdl/camel_test.wsdl\", \"HelloWorldService\", \"HelloWorldPort\");\n\n        CamelConduit conduit = setupCamelConduit(false, false);\n        Message message = new MessageImpl();\n        try {\n            conduit.prepare(message);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        verifySentMessage(false, message);\n    }","id":74102,"modified_method":"public void testPrepareSend() throws Exception {\n        endpointInfo.setAddress(\"camel://direct:Producer\");\n        CamelConduit conduit = setupCamelConduit(endpointInfo, false, false);\n        Message message = new MessageImpl();\n        try {\n            conduit.prepare(message);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        verifyMessageContent(message);\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"private void commitOutputMessage() throws IOException {\n            String targetCamelEndpointUri = (String) outMessage.get(CamelConstants.CAMEL_TARGET_ENDPOINT_URI);  \n            getCamelTemplate().send(targetCamelEndpointUri, new Processor() {\n                public void process(org.apache.camel.Exchange ex) throws IOException {\n                    // put the output stream into the message\n                    CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n                    // send out the request message here\n                    ex.getIn().setHeaders(outMessage);\n                    ex.getIn().setBody(outputStream.getInputStream());\n                    // setup the out message\n                    getLogger().log(Level.FINE, \"template sending request: \", ex.getIn());\n                }\n            });    \n        }","id":74103,"modified_method":"private void commitOutputMessage() throws IOException {\n            Exchange camelExchange =(Exchange)outMessage.get(CxfConstants.CAMEL_EXCHANGE);            \n            camelExchange.getOut().setHeaders(outMessage);\n            CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n            camelExchange.getOut().setBody(outputStream.getInputStream());\n            getLogger().log(Level.FINE, \"send the response message: \" + outputStream);\n             \n        }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * @param inMessage the incoming message\n     * @return the inbuilt backchannel\n     */\n    protected Conduit getInbuiltBackChannel(Message inMessage) {\n        return new BackChannelConduit(EndpointReferenceUtils.getAnonymousEndpointReference(), inMessage);\n    }","id":74104,"modified_method":"/**\n     * @param inMessage the incoming message\n     * @return the inbuilt backchannel\n     */\n    protected Conduit getInbuiltBackChannel(Message inMessage) {\n        //we can pass the message back by looking up the camelExchange from inMessage\n        return new BackChannelConduit(inMessage);\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"protected void incoming(org.apache.camel.Exchange exchange) {\n        getLogger().log(Level.FINE, \"server received request: \", exchange);\n        org.apache.cxf.message.Message inMessage = \n            CxfSoapBinding.getCxfInMessage(exchange, false);\n        \n        inMessage.put(CamelConstants.CAMEL_REQUEST_MESSAGE, exchange);\n\n        ((MessageImpl)inMessage).setDestination(this);\n\n        // handle the incoming message\n        incomingObserver.onMessage(inMessage);\n    }","id":74105,"modified_method":"protected void incoming(org.apache.camel.Exchange camelExchange) {\n        getLogger().log(Level.FINE, \"server received request: \", camelExchange);\n        org.apache.cxf.message.Message inMessage = \n            CxfSoapBinding.getCxfInMessage(camelExchange, false);\n        \n        inMessage.put(CxfConstants.CAMEL_EXCHANGE, camelExchange);\n        ((MessageImpl)inMessage).setDestination(this);\n                \n        // Handling the incoming message\n        // The response message will be send back by the outgoingchain\n        incomingObserver.onMessage(inMessage);\n        \n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void activate() {\n        getLogger().log(Level.INFO, \"CamelDestination activate().... \");\n\n        try {\n            getLogger().log(Level.FINE, \"establishing Camel connection\");\n            distinationEndpoint = camelContext.getEndpoint(camelUri);\n            consumer = distinationEndpoint.createConsumer(new ConsumerProcessor());\n            consumer.start();\n            \n        } catch (Exception ex) {\n            getLogger().log(Level.SEVERE, \"Camel connect failed with EException : \", ex);\n        }\n    }","id":74106,"modified_method":"public void activate() {\n        getLogger().log(Level.FINE, \"CamelDestination activate().... \");\n\n        try {\n            getLogger().log(Level.FINE, \"establishing Camel connection\");\n            distinationEndpoint = camelContext.getEndpoint(camelDestinationUri);\n            consumer = distinationEndpoint.createConsumer(new ConsumerProcessor());\n            consumer.start();\n            \n        } catch (Exception ex) {\n            getLogger().log(Level.SEVERE, \"Camel connect failed with EException : \", ex);\n        }\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"/**\n         * Send an outbound message, assumed to contain all the name-value\n         * mappings of the corresponding input message (if any).\n         * \n         * @param message the message to be sent.\n         */\n        public void prepare(Message message) throws IOException {\n            // setup the message to be send back\n            message.put(CamelConstants.CAMEL_REQUEST_MESSAGE, inMessage.get(CamelConstants.CAMEL_REQUEST_MESSAGE));\n            message.put(CamelConstants.CAMEL_TARGET_ENDPOINT_URI, targetCamelEndpointUri);\n            message.setContent(OutputStream.class, new CamelOutputStream(inMessage));\n        }","id":74107,"modified_method":"/**\n         * Send an outbound message, assumed to contain all the name-value\n         * mappings of the corresponding input message (if any).\n         * \n         * @param message the message to be sent.\n         */\n        public void prepare(Message message) throws IOException {            \n            message.put(CxfConstants.CAMEL_EXCHANGE, inMessage.get(CxfConstants.CAMEL_EXCHANGE));\n            message.setContent(OutputStream.class, new CamelOutputStream(message));\n            \n        }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"private void initConfig() {\n        // setup the endpoint infor here\n    }","id":74108,"modified_method":"private void initConfig() {\n        //we could configure the camel context here \n        if(bus != null) {\n            Configurer configurer = bus.getExtension(Configurer.class);\n            if (null != configurer) {\n                configurer.configureBean(this);\n            }\n        }        \n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public CamelDestination(CamelContext camelContext, Bus bus, ConduitInitiator ci, EndpointInfo info) throws IOException {\n        super(getTargetReference(info, bus), info);\n        this.camelContext = camelContext;\n        conduitInitiator = ci;\n        initConfig();\n    }","id":74109,"modified_method":"public CamelDestination(CamelContext camelContext, Bus bus, ConduitInitiator ci, EndpointInfo info) throws IOException {\n        super(getTargetReference(info, bus), info);\n        this.camelContext = camelContext;\n        conduitInitiator = ci;\n        camelDestinationUri = endpointInfo.getAddress().substring(CxfConstants.CAMEL_TRANSPORT_PREFIX.length());\n        if (camelDestinationUri.startsWith(\"//\")) {\n            camelDestinationUri = camelDestinationUri.substring(2);     \n        }                \n        initConfig();\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"BackChannelConduit(EndpointReferenceType ref, Message message) {\n            super(ref);\n            AttributedURIType address = ref.getAddress();\n            if (address != null) {\n                targetCamelEndpointUri = address.getValue();\n            }\n            inMessage = message;\n        }","id":74110,"modified_method":"BackChannelConduit(Message message) {\n            super(EndpointReferenceUtils.getAnonymousEndpointReference());\n            inMessage = message;\n            cxfExchange = inMessage.getExchange();\n            camelExchange = cxfExchange.get(Exchange.class);            \n        }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void testOneWayDestination() throws Exception {\n        destMessage = null;\n        inMessage = null;\n        setupServiceInfo(\"http://cxf.apache.org/hello_world_camel\", \"/wsdl/camel_test.wsdl\", \"HWStaticReplyQBinMsgService\", \"HWStaticReplyQBinMsgPort\");\n        CamelConduit conduit = setupCamelConduit(true, false);\n        Message outMessage = new MessageImpl();\n        setupMessageHeader(outMessage);\n        CamelDestination destination = null;\n        try {\n            destination = setupCamelDestination(true);\n            // destination.activate();\n        } catch (IOException e) {\n            assertFalse(\"The CamelDestination activate should not through exception \", false);\n            e.printStackTrace();\n        }\n        sendoutMessage(conduit, outMessage, true);\n        // wait for the message to be get from the destination\n        waitForReceiveDestMessage();\n        // just verify the Destination inMessage\n        assertTrue(\"The destiantion should have got the message \", destMessage != null);\n        verifyReceivedMessage(destMessage);\n        verifyHeaders(destMessage, outMessage);\n        destination.shutdown();\n    }","id":74111,"modified_method":"public void testOneWayDestination() throws Exception {\n        destMessage = null;\n        inMessage = null;\n        EndpointInfo conduitEpInfo = new EndpointInfo();\n        conduitEpInfo.setAddress(\"camel://direct:Producer\");\n        CamelConduit conduit = setupCamelConduit(conduitEpInfo, true, false);\n        Message outMessage = new MessageImpl();        \n        CamelDestination destination = null;\n        try {\n            endpointInfo.setAddress(\"camel://direct:EndpointA\");\n            destination = setupCamelDestination(endpointInfo, true);\n            // destination.activate();\n        } catch (IOException e) {\n            assertFalse(\"The CamelDestination activate should not through exception \", false);\n            e.printStackTrace();\n        }\n        sendoutMessage(conduit, outMessage, true, \"HelloWorld\");\n        \n        // just verify the Destination inMessage\n        assertTrue(\"The destiantion should have got the message \", destMessage != null);\n        verifyReceivedMessage(destMessage, \"HelloWorld\");        \n        destination.shutdown();\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public CamelDestination setupCamelDestination(boolean send) throws IOException {\n        ConduitInitiator conduitInitiator = EasyMock.createMock(ConduitInitiator.class);\n        CamelDestination camelDestination = new CamelDestination(camelContext, bus, conduitInitiator, endpointInfo);\n        if (send) {\n            // setMessageObserver\n            observer = new MessageObserver() {\n                public void onMessage(Message m) {\n                    Exchange exchange = new ExchangeImpl();\n                    exchange.setInMessage(m);\n                    m.setExchange(exchange);\n                    destMessage = m;\n                }\n            };\n            camelDestination.setMessageObserver(observer);\n        }\n        return camelDestination;\n    }","id":74112,"modified_method":"public CamelDestination setupCamelDestination(EndpointInfo endpointInfo, boolean send) throws IOException {\n        ConduitInitiator conduitInitiator = EasyMock.createMock(ConduitInitiator.class);        \n        CamelDestination camelDestination = new CamelDestination(context, bus, conduitInitiator, endpointInfo);\n        if (send) {\n            // setMessageObserver\n            observer = new MessageObserver() {\n                public void onMessage(Message m) {\n                    Exchange exchange = new ExchangeImpl();\n                    exchange.setInMessage(m);\n                    m.setExchange(exchange);\n                    destMessage = m;\n                }\n            };\n            camelDestination.setMessageObserver(observer);\n        }\n        return camelDestination;\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void testRoundTripDestination() throws Exception {\n\n        inMessage = null;\n        setupServiceInfo(\"http://cxf.apache.org/hello_world_camel\", \"/wsdl/camel_test.wsdl\", \"HelloWorldService\", \"HelloWorldPort\");\n        // set up the conduit send to be true\n        CamelConduit conduit = setupCamelConduit(true, false);\n        final Message outMessage = new MessageImpl();\n        setupMessageHeader(outMessage);\n        final CamelDestination destination = setupCamelDestination(true);\n\n        // set up MessageObserver for handlering the conduit message\n        MessageObserver observer = new MessageObserver() {\n            public void onMessage(Message m) {\n                Exchange exchange = new ExchangeImpl();\n                exchange.setInMessage(m);\n                m.setExchange(exchange);\n                verifyReceivedMessage(m);\n                verifyHeaders(m, outMessage);\n                // setup the message for\n                Conduit backConduit;\n                try {\n                    backConduit = destination.getBackChannel(m, null, null);\n                    // wait for the message to be got from the conduit\n                    Message replyMessage = new MessageImpl();\n                    sendoutMessage(backConduit, replyMessage, true);\n                } catch (Exception e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        };\n        destination.setMessageObserver(observer);\n        // set is oneway false for get response from destination\n        sendoutMessage(conduit, outMessage, false);\n        // wait for the message to be got from the destination,\n        // create the thread to handler the Destination incomming message\n\n        waitForReceiveInMessage();\n        verifyReceivedMessage(inMessage);\n        // wait for a while for the camel session recycling\n        Thread.sleep(1000);\n        destination.shutdown();\n    }","id":74113,"modified_method":"public void testRoundTripDestination() throws Exception {\n\n        inMessage = null;\n        EndpointInfo conduitEpInfo = new EndpointInfo();\n        conduitEpInfo.setAddress(\"camel://direct:Producer\");\n        // set up the conduit send to be true\n        CamelConduit conduit = setupCamelConduit(conduitEpInfo, true, false);\n        final Message outMessage = new MessageImpl();\n        \n        endpointInfo.setAddress(\"camel://direct:EndpointA\"); \n        final CamelDestination destination = setupCamelDestination(endpointInfo, true);\n\n        // set up MessageObserver for handlering the conduit message\n        MessageObserver observer = new MessageObserver() {\n            public void onMessage(Message m) {\n                Exchange exchange = new ExchangeImpl();\n                exchange.setInMessage(m);\n                m.setExchange(exchange);\n                verifyReceivedMessage(m, \"HelloWorld\");\n                //verifyHeaders(m, outMessage);\n                // setup the message for\n                Conduit backConduit;\n                try {\n                    backConduit = destination.getBackChannel(m, null, null);\n                    // wait for the message to be got from the conduit\n                    Message replyMessage = new MessageImpl();                    \n                    sendoutMessage(backConduit, replyMessage, true, \"HelloWorld Response\");\n                } catch (Exception e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        };\n        //this call will active the camelDestination\n        destination.setMessageObserver(observer);\n        // set is oneway false for get response from destination\n        // need to use another thread to send the request message\n        sendoutMessage(conduit, outMessage, false, \"HelloWorld\");\n        // wait for the message to be got from the destination,\n        // create the thread to handler the Destination incomming message\n        \n        verifyReceivedMessage(inMessage, \"HelloWorld Response\");\n       \n        destination.shutdown();\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"private void verifyReceivedMessage(Message inMessage) {\n        ByteArrayInputStream bis = (ByteArrayInputStream)inMessage.getContent(InputStream.class);\n        byte bytes[] = new byte[bis.available()];\n        try {\n            bis.read(bytes);\n        } catch (IOException ex) {\n            assertFalse(\"Read the Destination recieved Message error \", false);\n            ex.printStackTrace();\n        }\n        String reponse = new String(bytes);\n        assertEquals(\"The reponse date should be equals\", reponse, \"HelloWorld\");\n    }","id":74114,"modified_method":"private void verifyReceivedMessage(Message inMessage, String content) {\n        ByteArrayInputStream bis = (ByteArrayInputStream)inMessage.getContent(InputStream.class);\n        byte bytes[] = new byte[bis.available()];\n        try {\n            bis.read(bytes);\n        } catch (IOException ex) {\n            assertFalse(\"Read the Destination recieved Message error \", false);\n            ex.printStackTrace();\n        }\n        String reponse = new String(bytes);\n        assertEquals(\"The reponse date should be equals\", content, reponse);\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"/**\n    * This method is called when the incoming message is to\n    * be passed into the camel processor. The return value is the response\n    * from the processor\n    * @param inMessage\n    * @return outMessage\n    */\n    public Message invoke(Message inMessage) {\n        System.out.println(\"invoke the message \" + inMessage);\n        Exchange exchange = inMessage.getExchange();\n        //InvokingContext invokingContext = exchange.get(InvokingContext.class);\n                               \n        //Set Request Context into CXF Message\n        Map<String, Object> ctxContainer = new HashMap<String, Object>();\n        Map<String, Object> requestCtx = new HashMap<String, Object>();\n        ctxContainer.put(Client.REQUEST_CONTEXT, requestCtx);\n        updateContext(inMessage, requestCtx);\n        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();\n        CxfExchange cxfExchange = endpoint.createExchange(inMessage);\n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception e) {\n            // catch the exception and send back to cxf client\n            e.printStackTrace();\n        }\n       \n        // make sure the client has retrun back the message\n        Message outMessage = getCxfMessage(cxfExchange, exchange);\n               \n        //Set Response Context into CXF Message\n        /*ctxContainer = (Map<String, Object>)outMessage.getProperty(CxfMessageAdapter.REQ_RESP_CONTEXT);\n        Map<String, Object> respCtx = (Map<String, Object>)ctxContainer.get(Client.RESPONSE_CONTEXT);\n        updateContext(respCtx, outMessage);*/\n       \n        return outMessage;\n    }","id":74115,"modified_method":"/**\n    * This method is called when the incoming message is to\n    * be passed into the camel processor. The return value is the response\n    * from the processor\n    * @param inMessage\n    * @return outMessage\n    */\n    public Message invoke(Message inMessage) {        \n        Exchange exchange = inMessage.getExchange();\n        //InvokingContext invokingContext = exchange.get(InvokingContext.class);\n                               \n        //Set Request Context into CXF Message\n        Map<String, Object> ctxContainer = new HashMap<String, Object>();\n        Map<String, Object> requestCtx = new HashMap<String, Object>();\n        ctxContainer.put(Client.REQUEST_CONTEXT, requestCtx);\n        updateContext(inMessage, requestCtx);\n        CxfEndpoint endpoint = (CxfEndpoint) cxfConsumer.getEndpoint();\n        CxfExchange cxfExchange = endpoint.createExchange(inMessage);\n        try {\n            cxfConsumer.getProcessor().process(cxfExchange);\n        } catch (Exception e) {\n            // catch the exception and send back to cxf client\n            e.printStackTrace();\n        }\n       \n        // make sure the client has retrun back the message\n        Message outMessage = getCxfMessage(cxfExchange, exchange);\n               \n        //Set Response Context into CXF Message\n        /*ctxContainer = (Map<String, Object>)outMessage.getProperty(CxfMessageAdapter.REQ_RESP_CONTEXT);\n        Map<String, Object> respCtx = (Map<String, Object>)ctxContainer.get(Client.RESPONSE_CONTEXT);\n        updateContext(respCtx, outMessage);*/\n       \n        return outMessage;\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void setUp() throws Exception {\n        camelContext.start();\n        BusFactory bf = BusFactory.newInstance();\n        bus = bf.createBus();\n        BusFactory.setDefaultBus(bus);\n    }","id":74116,"modified_method":"public void setUp() throws Exception {\n        super.setUp();\n        BusFactory bf = BusFactory.newInstance();\n        //setup the camel transport for the bus\n        bus = bf.createBus();\n        DestinationFactoryManager dfm = bus.getExtension(DestinationFactoryManager.class);\n        CamelTransportFactory camelTransportFactory = new CamelTransportFactory();\n        //set the context here to the transport factory;\n        camelTransportFactory.setCamelContext(context);\n        dfm.registerDestinationFactory(\"http://cxf.apache.org/transports/camel\", camelTransportFactory);\n        \n        ConduitInitiatorManager cim = bus.getExtension(ConduitInitiatorManager.class);\n        cim.registerConduitInitiator(\"http://cxf.apache.org/transports/camel\", camelTransportFactory);\n        BusFactory.setDefaultBus(bus);\n        endpointInfo = new EndpointInfo();\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"protected CamelConduit setupCamelConduit(boolean send, boolean decoupled) {\n        if (decoupled) {\n            // setup the reference type\n        } else {\n            target = EasyMock.createMock(EndpointReferenceType.class);\n        }\n\n        CamelConduit camelConduit = new CamelConduit(camelContext, bus, endpointInfo, target);\n\n        if (send) {\n            // setMessageObserver\n            observer = new MessageObserver() {\n                public void onMessage(Message m) {\n                    inMessage = m;\n                }\n            };\n            camelConduit.setMessageObserver(observer);\n        }\n\n        return camelConduit;\n    }","id":74117,"modified_method":"protected CamelConduit setupCamelConduit(EndpointInfo endpointInfo, boolean send, boolean decoupled) {\n        if (decoupled) {\n            // setup the reference type\n        } else {\n            target = EasyMock.createMock(EndpointReferenceType.class);\n        }    \n        \n        CamelConduit camelConduit = new CamelConduit(context, bus, endpointInfo, target);\n        \n        if (send) {\n            // setMessageObserver\n            observer = new MessageObserver() {\n                public void onMessage(Message m) {                    \n                    inMessage = m;\n                }\n            };\n            camelConduit.setMessageObserver(observer);\n        }\n        \n        return camelConduit;        \n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void tearDown() throws Exception {\n        bus.shutdown(true);\n        if (System.getProperty(\"cxf.config.file\") != null) {\n            System.clearProperty(\"cxf.config.file\");\n        }\n        camelContext.stop();\n    }","id":74118,"modified_method":"public void tearDown() throws Exception {\n        bus.shutdown(true);        \n        super.tearDown();\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"protected void sendoutMessage(Conduit conduit, Message message, Boolean isOneWay) throws IOException {\n\n        Exchange exchange = new ExchangeImpl();\n        exchange.setOneWay(isOneWay);\n        message.setExchange(exchange);\n        exchange.setInMessage(message);\n        try {\n            conduit.prepare(message);\n        } catch (IOException ex) {\n            assertFalse(\"CamelConduit can't perpare to send out message\", false);\n            ex.printStackTrace();\n        }\n        OutputStream os = message.getContent(OutputStream.class);\n        assertTrue(\"The OutputStream should not be null \", os != null);\n        os.write(\"HelloWorld\".getBytes());\n        os.close();\n    }","id":74119,"modified_method":"protected void sendoutMessage(Conduit conduit, Message message, Boolean isOneWay, String content) throws IOException {\n        Exchange cxfExchange = message.getExchange();\n        if (cxfExchange == null) {\n            cxfExchange = new ExchangeImpl();\n            cxfExchange.setOneWay(isOneWay);\n            message.setExchange(cxfExchange);\n            cxfExchange.setInMessage(message);\n        }    \n        try {\n            conduit.prepare(message);\n        } catch (IOException ex) {\n            assertFalse(\"CamelConduit can't perpare to send out message\", false);\n            ex.printStackTrace();            \n        }            \n        OutputStream os = message.getContent(OutputStream.class);\n        assertTrue(\"The OutputStream should not be null \", os != null);\n        os.write(content.getBytes());\n        os.close();            \n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public static org.apache.cxf.message.Message getCxfInMessage(org.apache.camel.Exchange exchange, boolean isClient) {\n        MessageImpl answer = new MessageImpl();\n        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(\"CxfExchange\", \n                                                                        org.apache.cxf.message.Exchange.class);\n        org.apache.camel.Message message = null;\n        if (isClient) {\n            message = exchange.getOut();            \n        } else {\n            message = exchange.getIn();\n        }\n        if (cxfExchange == null) {\n            cxfExchange = new ExchangeImpl();\n            exchange.setProperty(\"CxfExchange\", cxfExchange);\n        }    \n        Object body = message.getBody(InputStream.class);\n        if (body == null) {\n            body = message.getBody();\n        }\n        if (body instanceof InputStream) {\n            answer.setContent(InputStream.class, body);             \n        }\n        answer.setExchange(cxfExchange);\n        cxfExchange.setInMessage(answer);\n        return answer;\n    }","id":74120,"modified_method":"public static org.apache.cxf.message.Message getCxfInMessage(org.apache.camel.Exchange exchange, boolean isClient) {\n        MessageImpl answer = new MessageImpl();\n        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(CxfConstants.CXF_EXCHANGE, \n                                                                        org.apache.cxf.message.Exchange.class);\n        org.apache.camel.Message message = null;\n        if (isClient) {\n            message = exchange.getOut();            \n        } else {\n            message = exchange.getIn();\n        }\n        assert message != null;\n        if (cxfExchange == null) {\n            cxfExchange = new ExchangeImpl();\n            exchange.setProperty(CxfConstants.CXF_EXCHANGE, cxfExchange);\n        }    \n        Object body = message.getBody(InputStream.class);\n        if (body == null) {\n            body = message.getBody();\n        }\n        if (body instanceof InputStream) {\n            answer.setContent(InputStream.class, body);             \n        }\n        answer.putAll(message.getHeaders());\n        answer.setExchange(cxfExchange);\n        cxfExchange.setInMessage(answer);\n        return answer;\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public static org.apache.cxf.message.Message getCxfOutMessage(org.apache.camel.Exchange exchange, boolean isClient) {\n        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(\"CxfExchange\", org.apache.cxf.message.Exchange.class);\n        assert cxfExchange != null;\n        org.apache.cxf.endpoint.Endpoint cxfEndpoint = cxfExchange.get(org.apache.cxf.endpoint.Endpoint.class);\n        org.apache.cxf.message.Message outMessage = cxfEndpoint.getBinding().createMessage();\n        outMessage.setExchange(cxfExchange);\n        cxfExchange.setOutMessage(outMessage);\n        org.apache.camel.Message message = null;\n        if (isClient) {\n            message = exchange.getIn();\n        }\n        else {\n            message = exchange.getOut();\n        }    \n        // send the body back\n        Object body = message.getBody(Source.class);\n        if (body == null) {\n            body = message.getBody();\n        }\n        if (body instanceof Source) {\n            outMessage.setContent(Source.class, body);             \n        }\n        outMessage.putAll(message.getHeaders());\n        return outMessage;\n    }","id":74121,"modified_method":"public static org.apache.cxf.message.Message getCxfOutMessage(org.apache.camel.Exchange exchange, boolean isClient) {\n        org.apache.cxf.message.Exchange cxfExchange = exchange.getProperty(CxfConstants.CXF_EXCHANGE, org.apache.cxf.message.Exchange.class);\n        assert cxfExchange != null;\n        org.apache.cxf.endpoint.Endpoint cxfEndpoint = cxfExchange.get(org.apache.cxf.endpoint.Endpoint.class);\n        org.apache.cxf.message.Message outMessage = cxfEndpoint.getBinding().createMessage();\n        outMessage.setExchange(cxfExchange);\n        cxfExchange.setOutMessage(outMessage);\n        org.apache.camel.Message message = null;\n        if (isClient) {\n            message = exchange.getIn();\n        }\n        else {\n            message = exchange.getOut();\n        }    \n        // send the body back\n        Object body = message.getBody(Source.class);\n        if (body == null) {\n            body = message.getBody();\n        }\n        if (body instanceof Source) {\n            outMessage.setContent(Source.class, body);             \n        }\n        outMessage.putAll(message.getHeaders());\n        return outMessage;\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"protected void processSoapProviderIn(Exchange exchange) throws Exception {\n        LOG.info(\"processSoapProviderIn: \" + exchange);\n        org.apache.cxf.endpoint.Endpoint cxfEndpoint = client.getEndpoint();        \n        org.apache.cxf.message.Exchange cxfExchange = new ExchangeImpl();        \n        cxfExchange.put(org.apache.cxf.endpoint.Endpoint.class, cxfEndpoint);\n        cxfExchange.put(Bus.class, getBus());\n        cxfExchange.setConduit(new NullConduit());\n        exchange.setProperty(\"CxfExchange\", cxfExchange);        \n        org.apache.cxf.message.Message outMessage = CxfSoapBinding.getCxfOutMessage(exchange, true);\n        outMessage.put(Message.REQUESTOR_ROLE, Boolean.TRUE);\n        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);\n        InterceptorChain chain = OutgoingChainInterceptor.getOutInterceptorChain(cxfExchange);\n        outMessage.setInterceptorChain(chain);\n               \n        chain.doIntercept(outMessage);\n        CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n                \n        exchange.getOut().setBody(outputStream.getInputStream());\n    }","id":74122,"modified_method":"protected void processSoapProviderIn(Exchange exchange) throws Exception {\n        LOG.info(\"processSoapProviderIn: \" + exchange);\n        org.apache.cxf.endpoint.Endpoint cxfEndpoint = client.getEndpoint();        \n        org.apache.cxf.message.Exchange cxfExchange = new ExchangeImpl();        \n        cxfExchange.put(org.apache.cxf.endpoint.Endpoint.class, cxfEndpoint);\n        cxfExchange.put(Bus.class, getBus());\n        cxfExchange.setConduit(new NullConduit());\n        exchange.setProperty(CxfConstants.CXF_EXCHANGE, cxfExchange);        \n        org.apache.cxf.message.Message outMessage = CxfSoapBinding.getCxfOutMessage(exchange, true);\n        outMessage.put(Message.REQUESTOR_ROLE, Boolean.TRUE);\n        outMessage.put(Message.INBOUND_MESSAGE, Boolean.FALSE);\n        InterceptorChain chain = OutgoingChainInterceptor.getOutInterceptorChain(cxfExchange);\n        outMessage.setInterceptorChain(chain);\n               \n        chain.doIntercept(outMessage);\n        CachedOutputStream outputStream = (CachedOutputStream)outMessage.getContent(OutputStream.class);\n                \n        exchange.getOut().setBody(outputStream.getInputStream());\n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"public void testSoapProducer() throws Exception {\n        // set out the source message\n        URL request = this.getClass().getResource(\"RequestBody.xml\");\n        File requestFile = new File(request.toURI());\n        FileInputStream inputStream = new FileInputStream(requestFile);\n        XMLStreamReader xmlReader = StaxUtils.createXMLStreamReader(inputStream);\n        DOMSource source = new DOMSource(StaxUtils.read(xmlReader));        \n        Object result = template.sendBody(\"direct:producer\", source);\n        assertFalse(\"The result should not be changed\", source.equals(result));\n        assertTrue(\"The result should be the instance of DOMSource\", result instanceof DOMSource);\n        assertEquals(\"The DOMSource should be equal\", XMLUtils.toString(source), XMLUtils.toString((Source)result));\n    }","id":74123,"modified_method":"public void testSoapProducer() throws Exception {\n        // set out the source message\n        URL request = this.getClass().getResource(\"RequestBody.xml\");\n        File requestFile = new File(request.toURI());\n        FileInputStream inputStream = new FileInputStream(requestFile);        \n        XMLStreamReader xmlReader = StaxUtils.createXMLStreamReader(inputStream);\n        DOMSource source = new DOMSource(StaxUtils.read(xmlReader));        \n        MockEndpoint endpoint = getMockEndpoint(\"mock:producer\");\n        endpoint.expectedMessageCount(1);\n        Object result = template.sendBody(\"direct:producer\", source);        \n       \n        assertMockEndpointsSatisifed();\n        assertFalse(\"The result should not be changed\", source.equals(result));\n        assertTrue(\"The result should be the instance of DOMSource\", result instanceof DOMSource);\n        assertEquals(\"The DOMSource should be equal\", XMLUtils.toString(source), XMLUtils.toString((Source)result));\n        \n    }","commit_id":"98ef5e9959410360c01f145e100a71fb52f23b2d","url":"https://github.com/apache/camel"},{"original_method":"/**\n     * When invoked inbound, check if the action indicates that this is one of the \n     * RM protocol messages (CreateSequence, CreateSequenceResponse, TerminateSequence)\n     * and if so, replace references to the application service model with references to\n     * the RM service model.\n     * The addressing protocol handler must have extracted the action beforehand. \n     * @see org.apache.cxf.transport.ChainInitiationObserver\n     * \n     * @param message the message\n     */\n    private void updateServiceModelInfo(SoapMessage message) throws Fault {\n\n        AddressingProperties maps = ContextUtils.retrieveMAPs(message, false, false, false);\n        AttributedURIType actionURI = null == maps ? null : maps.getAction();\n        String action = null == actionURI ? null : actionURI.getValue().trim();\n        \n        LOG.fine(\"action: \" + action);\n        RMConstants consts;\n        if (RM10Constants.ACTIONS.contains(action)) {\n            consts = RM10Constants.INSTANCE;\n        } else if (RM11Constants.ACTIONS.contains(action)) {\n            consts = RM11Constants.INSTANCE;\n        } else {\n            return;\n        }\n        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);\n        rmps.exposeAs(consts.getWSRMNamespace());\n        ProtocolVariation protocol = \n            ProtocolVariation.findVariant(consts.getWSRMNamespace(), maps.getNamespaceURI());\n        \n        LOG.info(\"Updating service model info in exchange\");\n        \n        RMManager manager = getManager(message);\n        assert manager != null;\n        \n        RMEndpoint rme = null;\n        try {\n            rme = manager.getReliableEndpoint(message);\n        } catch (RMException e) {\n            throw new SoapFault(new org.apache.cxf.common.i18n.Message(\"CANNOT_PROCESS\", LOG), e,\n                message.getVersion().getSender());\n        }\n  \n        Exchange exchange = message.getExchange();\n        Endpoint ep = rme.getEndpoint(protocol);\n        exchange.put(Endpoint.class, ep);\n        exchange.put(Service.class, ep.getService());\n        exchange.put(Binding.class, ep.getBinding());\n        \n        // Also set BindingOperationInfo as some operations (SequenceAcknowledgment) have\n        // neither in nor out messages, and thus the WrappedInInterceptor cannot\n        // determine the operation name.\n        \n        BindingInfo bi = ep.getEndpointInfo().getBinding();\n        BindingOperationInfo boi = null;\n        boolean isOneway = true;\n        if (consts.getCreateSequenceAction().equals(action)) {\n            if (RMContextUtils.isServerSide(message)) {\n                boi = bi.getOperation(consts.getCreateSequenceOperationName());\n                isOneway = false;\n            } else {\n                boi = bi.getOperation(consts.getCreateSequenceOnewayOperationName());\n            }\n        } else if (consts.getCreateSequenceResponseAction().equals(action)) {\n            if (RMContextUtils.isServerSide(message)) {\n                boi = bi.getOperation(consts.getCreateSequenceResponseOnewayOperationName());\n            } else {\n                boi = bi.getOperation(consts.getCreateSequenceOperationName());\n                isOneway = false;\n            }\n        } else if (consts.getSequenceAckAction().equals(action)) {\n            boi = bi.getOperation(consts.getSequenceAckOperationName()); \n        } else if (consts.getTerminateSequenceAction().equals(action)) {\n            boi = bi.getOperation(consts.getTerminateSequenceOperationName()); \n        } else if (RM11Constants.INSTANCE.getTerminateSequenceResponseAction().equals(action)) {\n            //TODO add server-side TSR handling\n            boi = bi.getOperation(RM11Constants.INSTANCE.getTerminateSequenceOperationName());\n            isOneway = false;\n        } else if (consts.getCloseSequenceAction().equals(action)) {\n            boi = bi.getOperation(consts.getCloseSequenceOperationName()); \n        } else if (RM11Constants.INSTANCE.getCloseSequenceResponseAction().equals(action)) {\n            boi = bi.getOperation(RM11Constants.INSTANCE.getCloseSequenceOperationName());\n            isOneway = false;\n        }\n        assert boi != null;\n        exchange.put(BindingOperationInfo.class, boi);\n        exchange.put(OperationInfo.class, boi.getOperationInfo());\n        exchange.setOneWay(isOneway); \n        \n        // Fix requestor role (as the client side message observer always sets it to TRUE) \n        // to allow unmarshalling the body of a server originated TerminateSequence request.\n        // In the logical RM interceptor set it back to what it was so that the logical\n        // addressing interceptor does not try to send a partial response to \n        // server originated oneway RM protocol messages.        \n        // \n        \n        if (!consts.getCreateSequenceResponseAction().equals(action)\n            && !consts.getSequenceAckAction().equals(action)\n            && !RM11Constants.INSTANCE.getTerminateSequenceResponseAction().equals(action)\n            && !RM11Constants.INSTANCE.getCloseSequenceResponseAction().equals(action)) {\n            LOG.fine(\"Changing requestor role from \" + message.get(Message.REQUESTOR_ROLE)\n                     + \" to false\");\n            Object originalRequestorRole = message.get(Message.REQUESTOR_ROLE);\n            if (null != originalRequestorRole) {\n                message.put(RMMessageConstants.ORIGINAL_REQUESTOR_ROLE, originalRequestorRole);\n            }\n            message.put(Message.REQUESTOR_ROLE, Boolean.FALSE);\n        }       \n        \n        // replace WrappedInInterceptor with BareInInterceptor if necessary\n        // as RM protocol messages use parameter style BARE\n\n        InterceptorChain chain = message.getInterceptorChain();\n        ListIterator<Interceptor<? extends Message>> it = chain.getIterator();            \n        boolean bareIn = false;\n        boolean wrappedIn = false;\n        while (it.hasNext() && !wrappedIn && !bareIn) {\n            PhaseInterceptor<? extends Message> pi = (PhaseInterceptor<? extends Message>)it.next();\n            if (BareInInterceptor.class.getName().equals(pi.getId())) {\n                bareIn = true;\n            }\n      \n        }\n        if (!bareIn) {\n            chain.add(new BareInInterceptor());\n            LOG.fine(\"Added BareInInterceptor to chain.\");\n        }\n    }","id":74124,"modified_method":"/**\n     * When invoked inbound, check if the action indicates that this is one of the \n     * RM protocol messages (CreateSequence, CreateSequenceResponse, TerminateSequence)\n     * and if so, replace references to the application service model with references to\n     * the RM service model.\n     * The addressing protocol handler must have extracted the action beforehand. \n     * @see org.apache.cxf.transport.ChainInitiationObserver\n     * \n     * @param message the message\n     */\n    private void updateServiceModelInfo(SoapMessage message) throws Fault {\n\n        AddressingProperties maps = ContextUtils.retrieveMAPs(message, false, false, false);\n        AttributedURIType actionURI = null == maps ? null : maps.getAction();\n        String action = null == actionURI ? null : actionURI.getValue().trim();\n        \n        LOG.fine(\"action: \" + action);\n        RMConstants consts;\n        if (RM10Constants.ACTIONS.contains(action)) {\n            consts = RM10Constants.INSTANCE;\n        } else if (RM11Constants.ACTIONS.contains(action)) {\n            consts = RM11Constants.INSTANCE;\n        } else {\n            return;\n        }\n        RMProperties rmps = RMContextUtils.retrieveRMProperties(message, false);\n        rmps.exposeAs(consts.getWSRMNamespace());\n        ProtocolVariation protocol = \n            ProtocolVariation.findVariant(consts.getWSRMNamespace(), maps.getNamespaceURI());\n        \n        LOG.info(\"Updating service model info in exchange\");\n        \n        RMManager manager = getManager(message);\n        assert manager != null;\n        \n        RMEndpoint rme = null;\n        try {\n            rme = manager.getReliableEndpoint(message);\n        } catch (RMException e) {\n            throw new SoapFault(new org.apache.cxf.common.i18n.Message(\"CANNOT_PROCESS\", LOG), e,\n                message.getVersion().getSender());\n        }\n  \n        Exchange exchange = message.getExchange();\n        Endpoint ep = rme.getEndpoint(protocol);\n        exchange.put(Endpoint.class, ep);\n        exchange.put(Service.class, ep.getService());\n        exchange.put(Binding.class, ep.getBinding());\n        \n        // Also set BindingOperationInfo as some operations (SequenceAcknowledgment) have\n        // neither in nor out messages, and thus the WrappedInInterceptor cannot\n        // determine the operation name.\n        \n        BindingInfo bi = ep.getEndpointInfo().getBinding();\n        BindingOperationInfo boi = null;\n        boolean isOneway = true;\n        if (consts.getCreateSequenceAction().equals(action)) {\n            if (RMContextUtils.isServerSide(message)) {\n                boi = bi.getOperation(consts.getCreateSequenceOperationName());\n                isOneway = false;\n            } else {\n                boi = bi.getOperation(consts.getCreateSequenceOnewayOperationName());\n            }\n        } else if (consts.getCreateSequenceResponseAction().equals(action)) {\n            if (RMContextUtils.isServerSide(message)) {\n                boi = bi.getOperation(consts.getCreateSequenceResponseOnewayOperationName());\n            } else {\n                boi = bi.getOperation(consts.getCreateSequenceOperationName());\n                isOneway = false;\n            }\n        } else if (consts.getSequenceAckAction().equals(action)) {\n            boi = bi.getOperation(consts.getSequenceAckOperationName()); \n        } else if (consts.getAckRequestedAction().equals(action)) {\n            boi = bi.getOperation(consts.getAckRequestedOperationName()); \n        } else if (consts.getTerminateSequenceAction().equals(action)) {\n            boi = bi.getOperation(consts.getTerminateSequenceOperationName()); \n        } else if (RM11Constants.INSTANCE.getTerminateSequenceResponseAction().equals(action)) {\n            //TODO add server-side TSR handling\n            boi = bi.getOperation(RM11Constants.INSTANCE.getTerminateSequenceOperationName());\n            isOneway = false;\n        } else if (consts.getCloseSequenceAction().equals(action)) {\n            boi = bi.getOperation(consts.getCloseSequenceOperationName()); \n        } else if (RM11Constants.INSTANCE.getCloseSequenceResponseAction().equals(action)) {\n            boi = bi.getOperation(RM11Constants.INSTANCE.getCloseSequenceOperationName());\n            isOneway = false;\n        }\n        \n        // make sure the binding information has been set\n        if (boi == null) {\n            LOG.fine(\"No BindingInfo for action \" + action);\n        } else {\n            exchange.put(BindingOperationInfo.class, boi);\n            exchange.put(OperationInfo.class, boi.getOperationInfo());\n            exchange.setOneWay(isOneway); \n        }\n        \n        // Fix requestor role (as the client side message observer always sets it to TRUE) \n        // to allow unmarshalling the body of a server originated TerminateSequence request.\n        // In the logical RM interceptor set it back to what it was so that the logical\n        // addressing interceptor does not try to send a partial response to \n        // server originated oneway RM protocol messages.        \n        // \n        \n        if (!consts.getCreateSequenceResponseAction().equals(action)\n            && !consts.getSequenceAckAction().equals(action)\n            && !RM11Constants.INSTANCE.getTerminateSequenceResponseAction().equals(action)\n            && !RM11Constants.INSTANCE.getCloseSequenceResponseAction().equals(action)) {\n            LOG.fine(\"Changing requestor role from \" + message.get(Message.REQUESTOR_ROLE)\n                     + \" to false\");\n            Object originalRequestorRole = message.get(Message.REQUESTOR_ROLE);\n            if (null != originalRequestorRole) {\n                message.put(RMMessageConstants.ORIGINAL_REQUESTOR_ROLE, originalRequestorRole);\n            }\n            message.put(Message.REQUESTOR_ROLE, Boolean.FALSE);\n        }       \n        \n        // replace WrappedInInterceptor with BareInInterceptor if necessary\n        // as RM protocol messages use parameter style BARE\n\n        InterceptorChain chain = message.getInterceptorChain();\n        ListIterator<Interceptor<? extends Message>> it = chain.getIterator();            \n        boolean bareIn = false;\n        boolean wrappedIn = false;\n        while (it.hasNext() && !wrappedIn && !bareIn) {\n            PhaseInterceptor<? extends Message> pi = (PhaseInterceptor<? extends Message>)it.next();\n            if (BareInInterceptor.class.getName().equals(pi.getId())) {\n                bareIn = true;\n            }\n      \n        }\n        if (!bareIn) {\n            chain.add(new BareInInterceptor());\n            LOG.fine(\"Added BareInInterceptor to chain.\");\n        }\n    }","commit_id":"21bfb9ab922392df0ffb93f0aacbc57ecff94fd3","url":"https://github.com/apache/cxf"},{"original_method":"protected void setOutMessageProperties(Message message, BindingOperationInfo boi) {\n        message.put(Message.REQUESTOR_ROLE, Boolean.TRUE);\n        message.put(Message.INBOUND_MESSAGE, Boolean.FALSE);\n        message.put(BindingMessageInfo.class, boi.getInput());\n        message.put(MessageInfo.class, boi.getOperationInfo().getInput());\n    }","id":74125,"modified_method":"protected void setOutMessageProperties(Message message, BindingOperationInfo boi) {\n        message.put(Message.REQUESTOR_ROLE, Boolean.TRUE);\n        message.put(Message.INBOUND_MESSAGE, Boolean.FALSE);\n        if (null != boi) {\n            message.put(BindingMessageInfo.class, boi.getInput());\n            message.put(MessageInfo.class, boi.getOperationInfo().getInput());\n        }\n    }","commit_id":"ea6c178de7ca3a31b5b2e4e8e5fd384d787dff69","url":"https://github.com/apache/cxf"},{"original_method":"private Object[] processResult(Message message, \n                                   Exchange exchange,\n                                   BindingOperationInfo oi,\n                                   Map<String, Object> resContext) throws Exception {\n     // Check to see if there is a Fault from the outgoing chain\n        Exception ex = message.getContent(Exception.class);\n        boolean mepCompleteCalled = false;\n        if (ex != null) {\n            getConduitSelector().complete(exchange);\n            mepCompleteCalled = true;\n            if (message.getContent(Exception.class) != null) {\n                throw ex;\n            }\n        }\n        ex = message.getExchange().get(Exception.class);\n        if (ex != null) {\n            if (!mepCompleteCalled) {\n                getConduitSelector().complete(exchange);\n            }\n            throw ex;\n        }\n        \n        // Wait for a response if we need to\n        if (oi != null && !oi.getOperationInfo().isOneWay()) {\n            synchronized (exchange) {\n                waitResponse(exchange);\n            }\n        }\n        getConduitSelector().complete(exchange);\n\n        // Grab the response objects if there are any\n        List resList = null;\n        Message inMsg = exchange.getInMessage();\n        if (inMsg != null) {\n            if (null != resContext) {                   \n                resContext.putAll(inMsg);\n                if (LOG.isLoggable(Level.FINE)) {\n                    LOG.fine(\"set responseContext to be\" + responseContext);\n                }\n            }\n            resList = inMsg.getContent(List.class);\n        }\n        \n        // check for an incoming fault\n        ex = getException(exchange);\n        \n        if (ex != null) {\n            throw ex;\n        }\n        \n        if (resList != null) {\n            return resList.toArray();\n        }\n        \n        return null;\n    }","id":74126,"modified_method":"protected Object[] processResult(Message message, \n                                   Exchange exchange,\n                                   BindingOperationInfo oi,\n                                   Map<String, Object> resContext) throws Exception {\n     // Check to see if there is a Fault from the outgoing chain\n        Exception ex = message.getContent(Exception.class);\n        boolean mepCompleteCalled = false;\n        if (ex != null) {\n            getConduitSelector().complete(exchange);\n            mepCompleteCalled = true;\n            if (message.getContent(Exception.class) != null) {\n                throw ex;\n            }\n        }\n        ex = message.getExchange().get(Exception.class);\n        if (ex != null) {\n            if (!mepCompleteCalled) {\n                getConduitSelector().complete(exchange);\n            }\n            throw ex;\n        }\n        \n        // Wait for a response if we need to\n        if (oi != null && !oi.getOperationInfo().isOneWay()) {\n            synchronized (exchange) {\n                waitResponse(exchange);\n            }\n        }\n        getConduitSelector().complete(exchange);\n\n        // Grab the response objects if there are any\n        List resList = null;\n        Message inMsg = exchange.getInMessage();\n        if (inMsg != null) {\n            if (null != resContext) {                   \n                resContext.putAll(inMsg);\n                if (LOG.isLoggable(Level.FINE)) {\n                    LOG.fine(\"set responseContext to be\" + responseContext);\n                }\n            }\n            resList = inMsg.getContent(List.class);\n        }\n        \n        // check for an incoming fault\n        ex = getException(exchange);\n        \n        if (ex != null) {\n            throw ex;\n        }\n        \n        if (resList != null) {\n            return resList.toArray();\n        }\n        \n        return null;\n    }","commit_id":"ea6c178de7ca3a31b5b2e4e8e5fd384d787dff69","url":"https://github.com/apache/cxf"},{"original_method":"private void waitResponse(Exchange exchange) {\n        int remaining = synchronousTimeout;\n        while (!Boolean.TRUE.equals(exchange.get(FINISHED)) && remaining > 0) {\n            long start = System.currentTimeMillis();\n            try {\n                exchange.wait(remaining);\n            } catch (InterruptedException ex) {\n                // ignore\n            }\n            long end = System.currentTimeMillis();\n            remaining -= (int)(end - start);\n        }\n        if (!Boolean.TRUE.equals(exchange.get(FINISHED))) {\n            LogUtils.log(LOG, Level.WARNING, \"RESPONSE_TIMEOUT\",\n                exchange.get(OperationInfo.class).getName().toString());\n        }\n    }","id":74127,"modified_method":"protected void waitResponse(Exchange exchange) {\n        int remaining = synchronousTimeout;\n        while (!Boolean.TRUE.equals(exchange.get(FINISHED)) && remaining > 0) {\n            long start = System.currentTimeMillis();\n            try {\n                exchange.wait(remaining);\n            } catch (InterruptedException ex) {\n                // ignore\n            }\n            long end = System.currentTimeMillis();\n            remaining -= (int)(end - start);\n        }\n        if (!Boolean.TRUE.equals(exchange.get(FINISHED))) {\n            LogUtils.log(LOG, Level.WARNING, \"RESPONSE_TIMEOUT\",\n                exchange.get(OperationInfo.class).getName().toString());\n        }\n    }","commit_id":"ea6c178de7ca3a31b5b2e4e8e5fd384d787dff69","url":"https://github.com/apache/cxf"},{"original_method":"public Object[] invoke(BindingOperationInfo oi,\n                           Object[] params, \n                           Map<String, Object> context,\n                           Exchange exchange) throws Exception {\n        Bus origBus = BusFactory.getThreadDefaultBus(false);\n        BusFactory.setThreadDefaultBus(bus);\n        try {\n            if (exchange == null) {\n                exchange = new ExchangeImpl();\n            }\n            exchange.setSynchronous(true);\n            Endpoint endpoint = getEndpoint();\n            \n            Map<String, Object> reqContext = null;\n            Map<String, Object> resContext = null;\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.fine(\"Invoke, operation info: \" + oi + \", params: \" + params);\n            }\n            Message message = endpoint.getBinding().createMessage();\n            if (null != context) {\n                reqContext = CastUtils.cast((Map)context.get(REQUEST_CONTEXT));\n                resContext = CastUtils.cast((Map)context.get(RESPONSE_CONTEXT));\n                message.put(Message.INVOCATION_CONTEXT, context);\n            }    \n            //setup the message context\n            setContext(reqContext, message);\n            setParameters(params, message);\n    \n            if (null != reqContext) {\n                exchange.putAll(reqContext);\n            }\n            exchange.setOneWay(oi.getOutput() == null);\n    \n            exchange.setOutMessage(message);\n            \n            setOutMessageProperties(message, oi);\n            setExchangeProperties(exchange, endpoint, oi);\n            \n            // setup chain\n    \n            PhaseInterceptorChain chain = setupInterceptorChain(endpoint);\n            message.setInterceptorChain(chain);\n            \n            modifyChain(chain, reqContext);\n            chain.setFaultObserver(outFaultObserver);\n            \n            // setup conduit selector\n            prepareConduitSelector(message);\n            \n            // execute chain        \n            chain.doIntercept(message);\n    \n            return processResult(message, exchange, oi, resContext);\n            \n        } finally {\n            BusFactory.setThreadDefaultBus(origBus);\n        }\n    }","id":74128,"modified_method":"public Object[] invoke(BindingOperationInfo oi,\n                           Object[] params, \n                           Map<String, Object> context,\n                           Exchange exchange) throws Exception {\n        Bus origBus = BusFactory.getThreadDefaultBus(false);\n        BusFactory.setThreadDefaultBus(bus);\n        try {\n            if (exchange == null) {\n                exchange = new ExchangeImpl();\n            }\n            exchange.setSynchronous(true);\n            Endpoint endpoint = getEndpoint();\n            \n            Map<String, Object> reqContext = null;\n            Map<String, Object> resContext = null;\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.fine(\"Invoke, operation info: \" + oi + \", params: \" + params);\n            }\n            Message message = endpoint.getBinding().createMessage();\n            if (null != context) {\n                reqContext = CastUtils.cast((Map)context.get(REQUEST_CONTEXT));\n                resContext = CastUtils.cast((Map)context.get(RESPONSE_CONTEXT));\n                message.put(Message.INVOCATION_CONTEXT, context);\n            }    \n            //setup the message context\n            setContext(reqContext, message);\n            setParameters(params, message);\n    \n            if (null != reqContext) {\n                exchange.putAll(reqContext);\n            }\n            \n            if (null != oi) {\n                exchange.setOneWay(oi.getOutput() == null);\n            }\n    \n            exchange.setOutMessage(message);\n            \n            setOutMessageProperties(message, oi);\n            setExchangeProperties(exchange, endpoint, oi);\n            \n            // setup chain\n    \n            PhaseInterceptorChain chain = setupInterceptorChain(endpoint);\n            message.setInterceptorChain(chain);\n            \n            modifyChain(chain, reqContext);\n            chain.setFaultObserver(outFaultObserver);\n            \n            // setup conduit selector\n            prepareConduitSelector(message);\n            \n            // execute chain        \n            chain.doIntercept(message);\n    \n            return processResult(message, exchange, oi, resContext);\n            \n        } finally {\n            BusFactory.setThreadDefaultBus(origBus);\n        }\n    }","commit_id":"ea6c178de7ca3a31b5b2e4e8e5fd384d787dff69","url":"https://github.com/apache/cxf"},{"original_method":"private void setParameters(Object[] params, Message message) {\n        MessageContentsList contents = new MessageContentsList(params);\n        message.setContent(List.class, contents);\n    }","id":74129,"modified_method":"protected void setParameters(Object[] params, Message message) {\n        MessageContentsList contents = new MessageContentsList(params);\n        message.setContent(List.class, contents);\n    }","commit_id":"ea6c178de7ca3a31b5b2e4e8e5fd384d787dff69","url":"https://github.com/apache/cxf"},{"original_method":"private void setContext(Map<String, Object> ctx, Message message) {\n        if (ctx != null) {            \n            message.putAll(ctx);\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.fine(\"set requestContext to message be\" + ctx);\n            }\n        }        \n    }","id":74130,"modified_method":"protected void setContext(Map<String, Object> ctx, Message message) {\n        if (ctx != null) {            \n            message.putAll(ctx);\n            if (LOG.isLoggable(Level.FINE)) {\n                LOG.fine(\"set requestContext to message be\" + ctx);\n            }\n        }        \n    }","commit_id":"ea6c178de7ca3a31b5b2e4e8e5fd384d787dff69","url":"https://github.com/apache/cxf"},{"original_method":"@Nullable\n  public static VirtualFile getGitRootOrNull(final File file) {\n    File root = file;\n    while (root != null && (!root.exists() || !root.isDirectory() || !new File(root, \".git\").exists())) {\n      root = root.getParentFile();\n    }\n    return LocalFileSystem.getInstance().findFileByIoFile(root);\n  }","id":74131,"modified_method":"@Nullable\n  public static VirtualFile getGitRootOrNull(final File file) {\n    File root = file;\n    while (root != null && (!root.exists() || !root.isDirectory() || !new File(root, \".git\").exists())) {\n      root = root.getParentFile();\n    }\n    return root == null ? null : LocalFileSystem.getInstance().findFileByIoFile(root);\n  }","commit_id":"48e69717c64da1464ad2e55511b88ae5da0c1266","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object o) {\n    if (!(o instanceof FilePath)) {\n      return false;\n    }\n    else {\n      if (! isSpecialName(myName) && ! isSpecialName(((FilePath)o).getName()) &&\n          ! Comparing.equal(myName, ((FilePath)o).getName())) return false;\n      return myFile.equals(((FilePath)o).getIOFile());\n    }\n  }","id":74132,"modified_method":"public boolean equals(Object o) {\n    if (!(o instanceof FilePath)) {\n      return false;\n    }\n    if (!isSpecialName(myName) && !isSpecialName(((FilePath)o).getName()) &&\n        !Comparing.equal(myName, ((FilePath)o).getName())) {\n      return false;\n    }\n    return myFile.equals(((FilePath)o).getIOFile());\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getPresentableUrl() {\n    if (myVirtualFile == null || !myVirtualFile.isValid()) {\n      return myFile.getAbsolutePath();\n    }\n    else {\n      return myVirtualFile.getPresentableUrl();\n    }\n  }","id":74133,"modified_method":"@Override\n  public String getPresentableUrl() {\n    VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile == null || !virtualFile.isValid()) {\n      return myFile.getAbsolutePath();\n    }\n    return virtualFile.getPresentableUrl();\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static FilePathImpl createForDeletedFile(final File selectedFile, final boolean isDirectory) {\n    LocalFileSystem lfs = LocalFileSystem.getInstance();\n\n    File parentFile = selectedFile.getParentFile();\n    if (parentFile == null) {\n      return new FilePathImpl(selectedFile, isDirectory);\n    }\n\n    VirtualFile virtualFileParent = lfs.findFileByIoFile(parentFile);\n    if (virtualFileParent != null) {\n      return new FilePathImpl(virtualFileParent, selectedFile.getName(), isDirectory, true);\n    }\n    else {\n      return new FilePathImpl(selectedFile, isDirectory);\n    }\n  }","id":74134,"modified_method":"public static FilePathImpl createForDeletedFile(final File selectedFile, final boolean isDirectory) {\n    LocalFileSystem lfs = LocalFileSystem.getInstance();\n\n    File parentFile = selectedFile.getParentFile();\n    if (parentFile == null) {\n      return new FilePathImpl(selectedFile, isDirectory);\n    }\n\n    VirtualFile virtualFileParent = lfs.findFileByIoFile(parentFile);\n    if (virtualFileParent != null) {\n      return new FilePathImpl(virtualFileParent, selectedFile.getName(), isDirectory, true);\n    }\n    return new FilePathImpl(selectedFile, isDirectory);\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getPath() {\n    final VirtualFile virtualFile = myVirtualFile;\n    if (virtualFile != null && virtualFile.isValid()) {\n      return virtualFile.getPath();\n    }\n    else {\n      return myFile.getPath();\n    }\n  }","id":74135,"modified_method":"@NotNull\n  @Override\n  public String getPath() {\n    final VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile != null && virtualFile.isValid()) {\n      return virtualFile.getPath();\n    }\n    return myFile.getPath();\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public FilePath createChild(final String subPath, final boolean isDirectory) {\n    if (StringUtil.isEmptyOrSpaces(subPath)) return this;\n\n    if (getVirtualFile() != null && subPath.indexOf('/') == -1 && subPath.indexOf('\\\\') == -1) {\n      return new FilePathImpl(getVirtualFile(), subPath, isDirectory, true);\n    }\n    else {\n      return new FilePathImpl(new File(getIOFile(), subPath), isDirectory);\n    }\n  }","id":74136,"modified_method":"@NotNull\n  public FilePath createChild(final String subPath, final boolean isDirectory) {\n    if (StringUtil.isEmptyOrSpaces(subPath)) return this;\n\n    VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile != null && subPath.indexOf('/') == -1 && subPath.indexOf('\\\\') == -1) {\n      return new FilePathImpl(virtualFile, subPath, isDirectory, true);\n    }\n    return new FilePathImpl(new File(getIOFile(), subPath), isDirectory);\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFileParent() {\n    if (myVirtualParent != null && !myVirtualParent.isValid()) {\n      myVirtualParent = null;\n    }\n    return myVirtualParent;\n  }","id":74137,"modified_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFileParent() {\n    VirtualFile virtualParent = myVirtualParent;\n    if (virtualParent != null && !virtualParent.isValid()) {\n      myVirtualParent = virtualParent = null;\n    }\n    return virtualParent;\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFile() {\n    if (myVirtualFile != null && !myVirtualFile.isValid()) {\n      myVirtualFile = null;\n    }\n    if (myVirtualFile == null) {\n      refresh();\n    }\n    detectFileType();\n    return myVirtualFile;\n  }","id":74138,"modified_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFile() {\n    VirtualFile virtualFile = myVirtualFile;\n    if (virtualFile != null && !virtualFile.isValid()) {\n      myVirtualFile = virtualFile = null;\n    }\n    if (virtualFile == null) {\n      virtualFile = refresh();\n    }\n    detectFileType(virtualFile);\n    return virtualFile;\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void hardRefresh() {\n    if (myLocal && (myVirtualFile == null || ! myVirtualFile.isValid())) {\n      myVirtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(myFile);\n    }\n  }","id":74139,"modified_method":"@Override\n  public void hardRefresh() {\n    if (myLocal) {\n      VirtualFile virtualFile = getVirtualFile();\n      if (virtualFile == null || !virtualFile.isValid()) {\n        myVirtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(myFile);\n      }\n    }\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public FilePath getParentPath() {\n    if (myVirtualParent != null && myVirtualParent.isValid() && myVirtualParent.getParent() != null) {\n      return new FilePathImpl(myVirtualParent);\n    }\n\n    // can't use File.getParentPath() because the path may not correspond to an actual file on disk,\n    // and adding a drive letter would not be appropriate (IDEADEV-7405)\n    // path containing exactly one separator is assumed to be root path\n    final String path = myFile.getPath();\n    int pos = path.lastIndexOf(File.separatorChar);\n    if (pos < 0 || pos == path.indexOf(File.separatorChar)) {\n      return null;\n    }\n    return new FilePathImpl(new File(path.substring(0, pos)), true);\n  }","id":74140,"modified_method":"@Override\n  public FilePath getParentPath() {\n    VirtualFile virtualParent = getVirtualFileParent();\n    if (virtualParent != null && virtualParent.getParent() != null) {\n      return new FilePathImpl(virtualParent);\n    }\n\n    // can't use File.getParentPath() because the path may not correspond to an actual file on disk,\n    // and adding a drive letter would not be appropriate (IDEADEV-7405)\n    // path containing exactly one separator is assumed to be root path\n    final String path = myFile.getPath();\n    int pos = path.lastIndexOf(File.separatorChar);\n    if (pos < 0 || pos == path.indexOf(File.separatorChar)) {\n      return null;\n    }\n    return new FilePathImpl(new File(path.substring(0, pos)), true);\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void detectFileType() {\n    VirtualFile file = myVirtualFile;\n    if (file == null || !file.isValid() || file.isDirectory()) return;\n    FileType fileType = file.getFileType();\n    if (fileType == UnknownFileType.INSTANCE) {\n      FileTypeRegistry.getInstance().detectFileTypeFromContent(file);\n    }\n  }","id":74141,"modified_method":"private static void detectFileType(VirtualFile virtualFile) {\n    if (virtualFile == null || !virtualFile.isValid() || virtualFile.isDirectory()) return;\n    FileType fileType = virtualFile.getFileType();\n    if (fileType == UnknownFileType.INSTANCE) {\n      FileTypeRegistry.getInstance().detectFileTypeFromContent(virtualFile);\n    }\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isUnder(FilePath parent, boolean strict) {\n    if (myVirtualFile != null) {\n      final VirtualFile parentFile = parent.getVirtualFile();\n      if (parentFile != null) {\n        return VfsUtilCore.isAncestor(parentFile, myVirtualFile, strict);\n      }\n    }\n    return FileUtil.isAncestor(parent.getIOFile(), getIOFile(), strict);\n  }","id":74142,"modified_method":"@Override\n  public boolean isUnder(@NotNull FilePath parent, boolean strict) {\n    VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile != null) {\n      final VirtualFile parentFile = parent.getVirtualFile();\n      if (parentFile != null) {\n        return VfsUtilCore.isAncestor(parentFile, virtualFile, strict);\n      }\n    }\n    return FileUtil.isAncestor(parent.getIOFile(), getIOFile(), strict);\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Charset getCharset(Project project) {\n    // try to find existing virtual file\n    VirtualFile existing = myVirtualFile != null && myVirtualFile.isValid() ? myVirtualFile : null;\n    if (existing == null) {\n      LocalFileSystem lfs = LocalFileSystem.getInstance();\n      for (File f = myFile; f != null; f = f.getParentFile()) {\n        existing = lfs.findFileByIoFile(f);\n        if (existing != null && existing.isValid()) {\n          break;\n        }\n      }\n    }\n    if (existing != null) {\n      Charset rc = existing.getCharset();\n      if (rc != null) {\n        return rc;\n      }\n    }\n    EncodingManager e = project != null ? EncodingProjectManager.getInstance(project) : null;\n    if (e == null) {\n      e = EncodingManager.getInstance();\n    }\n    return e.getDefaultCharset();\n  }","id":74143,"modified_method":"@Override\n  public Charset getCharset(Project project) {\n    // try to find existing virtual file\n    VirtualFile virtualFile = getVirtualFile();\n    VirtualFile existing = virtualFile != null && virtualFile.isValid() ? virtualFile : null;\n    if (existing == null) {\n      LocalFileSystem lfs = LocalFileSystem.getInstance();\n      for (File f = myFile; f != null; f = f.getParentFile()) {\n        existing = lfs.findFileByIoFile(f);\n        if (existing != null && existing.isValid()) {\n          break;\n        }\n      }\n    }\n    if (existing != null) {\n      Charset rc = existing.getCharset();\n      if (rc != null) {\n        return rc;\n      }\n    }\n    EncodingManager e = project != null ? EncodingProjectManager.getInstance(project) : null;\n    if (e == null) {\n      e = EncodingManager.getInstance();\n    }\n    return e.getDefaultCharset();\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isDirectory() {\n    if (myVirtualFile == null) {\n      return myIsDirectory;\n    }\n    else {\n      return myVirtualFile.isDirectory();\n    }\n  }","id":74144,"modified_method":"@Override\n  public boolean isDirectory() {\n    VirtualFile virtualFile = getVirtualFile();\n    return virtualFile == null ? myIsDirectory : virtualFile.isDirectory();\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static FilePath createNonLocal(String path, final boolean directory) {\n    path = path.replace('/', File.separatorChar);\n    // avoid filename normalization (IDEADEV-10548)\n    if (!ourFileStringConstructorInitialized) {\n      ourFileStringConstructorInitialized = true;\n      try {\n        ourFileStringConstructor = File.class.getDeclaredConstructor(String.class, int.class);\n        ourFileStringConstructor.setAccessible(true);\n      }\n      catch (Exception ex) {\n        ourFileStringConstructor = null;\n      }\n    }\n    File file = null;\n    try {\n      if (ourFileStringConstructor != null) {\n        file = ourFileStringConstructor.newInstance(path, 1);\n      }\n    }\n    catch (Exception ex) {\n      // reflection call failed, try regular call\n    }\n    if (file == null) {\n      file = new File(path);\n    }\n    return new FilePathImpl(file, directory, false);\n  }","id":74145,"modified_method":"@NotNull\n  public static FilePath createNonLocal(@NotNull String path, final boolean directory) {\n    path = path.replace('/', File.separatorChar);\n    File file = createIoFile(path);\n    return new FilePathImpl(file, directory, false);\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static FilePath createOn(String s) {\n    File ioFile = new File(s);\n    final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n    VirtualFile virtualFile = localFileSystem.findFileByIoFile(ioFile);\n    if (virtualFile != null) {\n      return new FilePathImpl(virtualFile);\n    }\n    else {\n      VirtualFile virtualFileParent = localFileSystem.findFileByIoFile(ioFile.getParentFile());\n      if (virtualFileParent != null) {\n        return new FilePathImpl(virtualFileParent, ioFile.getName(), false);\n      }\n      else {\n        return null;\n      }\n    }\n  }","id":74146,"modified_method":"public static FilePath createOn(@NotNull String s) {\n    File ioFile = new File(s);\n    final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n    VirtualFile virtualFile = localFileSystem.findFileByIoFile(ioFile);\n    if (virtualFile != null) {\n      return new FilePathImpl(virtualFile);\n    }\n    VirtualFile virtualFileParent = localFileSystem.findFileByIoFile(ioFile.getParentFile());\n    if (virtualFileParent == null) return null;\n    return new FilePathImpl(virtualFileParent, ioFile.getName(), false);\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void refresh() {\n    if (myLocal) {\n      if (myVirtualParent == null) {\n        myVirtualFile = LocalFileSystem.getInstance().findFileByIoFile(myFile);\n      }\n      else {\n        myVirtualFile = myVirtualParent.findChild(myName);\n      }\n    }\n  }","id":74147,"modified_method":"@Override\n  public VirtualFile refresh() {\n    VirtualFile virtualFile = myVirtualFile;\n    if (myLocal) {\n      VirtualFile virtualParent = getVirtualFileParent();\n      myVirtualFile = virtualFile = virtualParent == null ? LocalFileSystem.getInstance().findFileByIoFile(myFile) : virtualParent.findChild(myName);\n    }\n    return virtualFile;\n  }","commit_id":"ee19cc4993d940c3151889f9e436763fca7fba5b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * Tries to return gradle home defined as a dependency of the given module; falls back to the project-wide settings otherwise.\n   * \n   * @param module   target module that can have gradle home as a dependency\n   * @param project  target project which gradle home setting should be used if module-specific gradle location is not defined\n   * @return         gradle home derived from the settings of the given entities (if any); <code>null<\/code> otherwise\n   */\n  @Nullable\n  public VirtualFile getGradleHome(@Nullable Module module, @Nullable Project project) {\n    final VirtualFile result = getGradleHome(module);\n    if (result != null) {\n      return result;\n    }\n\n    final File home = getGradleHome(project);\n    return LocalFileSystem.getInstance().findFileByIoFile(home);\n  }","id":74148,"modified_method":"/**\n   * Tries to return gradle home defined as a dependency of the given module; falls back to the project-wide settings otherwise.\n   * \n   * @param module   target module that can have gradle home as a dependency\n   * @param project  target project which gradle home setting should be used if module-specific gradle location is not defined\n   * @return         gradle home derived from the settings of the given entities (if any); <code>null<\/code> otherwise\n   */\n  @Nullable\n  public VirtualFile getGradleHome(@Nullable Module module, @Nullable Project project) {\n    final VirtualFile result = getGradleHome(module);\n    if (result != null) {\n      return result;\n    }\n\n    final File home = getGradleHome(project);\n    return home == null ? null : LocalFileSystem.getInstance().findFileByIoFile(home);\n  }","commit_id":"ab1cd20c186e8312a51f26aeb97d24a48ee38667","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public Charset getCharset(Project project) {\n    // try to find existing virtual file\n    VirtualFile virtualFile = getVirtualFile();\n    VirtualFile existing = virtualFile != null && virtualFile.isValid() ? virtualFile : null;\n    if (existing == null) {\n      LocalFileSystem lfs = LocalFileSystem.getInstance();\n      for (File f = myFile; f != null; f = f.getParentFile()) {\n        existing = lfs.findFileByIoFile(f);\n        if (existing != null && existing.isValid()) {\n          break;\n        }\n      }\n    }\n    if (existing != null) {\n      Charset rc = existing.getCharset();\n      if (rc != null) {\n        return rc;\n      }\n    }\n    EncodingManager e = project != null ? EncodingProjectManager.getInstance(project) : null;\n    if (e == null) {\n      e = EncodingManager.getInstance();\n    }\n    return e.getDefaultCharset();\n  }","id":74149,"modified_method":"@Override\n  public Charset getCharset(Project project) {\n    // try to find existing virtual file\n    VirtualFile existing = myVirtualFile != null && myVirtualFile.isValid() ? myVirtualFile : null;\n    if (existing == null) {\n      LocalFileSystem lfs = LocalFileSystem.getInstance();\n      for (File f = myFile; f != null; f = f.getParentFile()) {\n        existing = lfs.findFileByIoFile(f);\n        if (existing != null && existing.isValid()) {\n          break;\n        }\n      }\n    }\n    if (existing != null) {\n      Charset rc = existing.getCharset();\n      if (rc != null) {\n        return rc;\n      }\n    }\n    EncodingManager e = project != null ? EncodingProjectManager.getInstance(project) : null;\n    if (e == null) {\n      e = EncodingManager.getInstance();\n    }\n    return e.getDefaultCharset();\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public FileType getFileType() {\n    VirtualFile virtualFile = getVirtualFile();\n    return virtualFile != null ? virtualFile.getFileType() : FileTypeManager.getInstance().getFileTypeByFileName(myFile.getName());\n  }","id":74150,"modified_method":"@Override\n  public FileType getFileType() {\n    return myVirtualFile != null ? myVirtualFile.getFileType() : FileTypeManager.getInstance().getFileTypeByFileName(myFile.getName());\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean equals(Object o) {\n    if (!(o instanceof FilePath)) {\n      return false;\n    }\n    if (!isSpecialName(myName) && !isSpecialName(((FilePath)o).getName()) &&\n        !Comparing.equal(myName, ((FilePath)o).getName())) {\n      return false;\n    }\n    return myFile.equals(((FilePath)o).getIOFile());\n  }","id":74151,"modified_method":"public boolean equals(Object o) {\n    if (!(o instanceof FilePath)) {\n      return false;\n    }\n    else {\n      if (! isSpecialName(myName) && ! isSpecialName(((FilePath)o).getName()) &&\n          ! Comparing.equal(myName, ((FilePath)o).getName())) return false;\n      return myFile.equals(((FilePath)o).getIOFile());\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void hardRefresh() {\n    if (myLocal) {\n      VirtualFile virtualFile = getVirtualFile();\n      if (virtualFile == null || !virtualFile.isValid()) {\n        myVirtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(myFile);\n      }\n    }\n  }","id":74152,"modified_method":"@Override\n  public void hardRefresh() {\n    if (myLocal && (myVirtualFile == null || ! myVirtualFile.isValid())) {\n      myVirtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(myFile);\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public String getPresentableUrl() {\n    VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile == null || !virtualFile.isValid()) {\n      return myFile.getAbsolutePath();\n    }\n    return virtualFile.getPresentableUrl();\n  }","id":74153,"modified_method":"@Override\n  public String getPresentableUrl() {\n    if (myVirtualFile == null || !myVirtualFile.isValid()) {\n      return myFile.getAbsolutePath();\n    }\n    else {\n      return myVirtualFile.getPresentableUrl();\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public FilePath createChild(final String subPath, final boolean isDirectory) {\n    if (StringUtil.isEmptyOrSpaces(subPath)) return this;\n\n    VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile != null && subPath.indexOf('/') == -1 && subPath.indexOf('\\\\') == -1) {\n      return new FilePathImpl(virtualFile, subPath, isDirectory, true);\n    }\n    return new FilePathImpl(new File(getIOFile(), subPath), isDirectory);\n  }","id":74154,"modified_method":"public FilePath createChild(final String subPath, final boolean isDirectory) {\n    if (StringUtil.isEmptyOrSpaces(subPath)) return this;\n\n    if (getVirtualFile() != null && subPath.indexOf('/') == -1 && subPath.indexOf('\\\\') == -1) {\n      return new FilePathImpl(getVirtualFile(), subPath, isDirectory, true);\n    }\n    else {\n      return new FilePathImpl(new File(getIOFile(), subPath), isDirectory);\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isUnder(@NotNull FilePath parent, boolean strict) {\n    VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile != null) {\n      final VirtualFile parentFile = parent.getVirtualFile();\n      if (parentFile != null) {\n        return VfsUtilCore.isAncestor(parentFile, virtualFile, strict);\n      }\n    }\n    return FileUtil.isAncestor(parent.getIOFile(), getIOFile(), strict);\n  }","id":74155,"modified_method":"@Override\n  public boolean isUnder(FilePath parent, boolean strict) {\n    if (myVirtualFile != null) {\n      final VirtualFile parentFile = parent.getVirtualFile();\n      if (parentFile != null) {\n        return VfsUtilCore.isAncestor(parentFile, myVirtualFile, strict);\n      }\n    }\n    return FileUtil.isAncestor(parent.getIOFile(), getIOFile(), strict);\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static FilePath createNonLocal(@NotNull String path, final boolean directory) {\n    path = path.replace('/', File.separatorChar);\n    File file = createIoFile(path);\n    return new FilePathImpl(file, directory, false);\n  }","id":74156,"modified_method":"@NotNull\n  public static FilePath createNonLocal(String path, final boolean directory) {\n    path = path.replace('/', File.separatorChar);\n    // avoid filename normalization (IDEADEV-10548)\n    if (!ourFileStringConstructorInitialized) {\n      ourFileStringConstructorInitialized = true;\n      try {\n        ourFileStringConstructor = File.class.getDeclaredConstructor(String.class, int.class);\n        ourFileStringConstructor.setAccessible(true);\n      }\n      catch (Exception ex) {\n        ourFileStringConstructor = null;\n      }\n    }\n    File file = null;\n    try {\n      if (ourFileStringConstructor != null) {\n        file = ourFileStringConstructor.newInstance(path, 1);\n      }\n    }\n    catch (Exception ex) {\n      // reflection call failed, try regular call\n    }\n    if (file == null) {\n      file = new File(path);\n    }\n    return new FilePathImpl(file, directory, false);\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFileParent() {\n    VirtualFile virtualParent = myVirtualParent;\n    if (virtualParent != null && !virtualParent.isValid()) {\n      myVirtualParent = virtualParent = null;\n    }\n    return virtualParent;\n  }","id":74157,"modified_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFileParent() {\n    if (myVirtualParent != null && !myVirtualParent.isValid()) {\n      myVirtualParent = null;\n    }\n    return myVirtualParent;\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static FilePathImpl createForDeletedFile(final File selectedFile, final boolean isDirectory) {\n    LocalFileSystem lfs = LocalFileSystem.getInstance();\n\n    File parentFile = selectedFile.getParentFile();\n    if (parentFile == null) {\n      return new FilePathImpl(selectedFile, isDirectory);\n    }\n\n    VirtualFile virtualFileParent = lfs.findFileByIoFile(parentFile);\n    if (virtualFileParent != null) {\n      return new FilePathImpl(virtualFileParent, selectedFile.getName(), isDirectory, true);\n    }\n    return new FilePathImpl(selectedFile, isDirectory);\n  }","id":74158,"modified_method":"public static FilePathImpl createForDeletedFile(final File selectedFile, final boolean isDirectory) {\n    LocalFileSystem lfs = LocalFileSystem.getInstance();\n\n    File parentFile = selectedFile.getParentFile();\n    if (parentFile == null) {\n      return new FilePathImpl(selectedFile, isDirectory);\n    }\n\n    VirtualFile virtualFileParent = lfs.findFileByIoFile(parentFile);\n    if (virtualFileParent != null) {\n      return new FilePathImpl(virtualFileParent, selectedFile.getName(), isDirectory, true);\n    }\n    else {\n      return new FilePathImpl(selectedFile, isDirectory);\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void refresh() {\n    if (myLocal) {\n      VirtualFile virtualParent = getVirtualFileParent();\n      myVirtualFile = virtualParent == null ? LocalFileSystem.getInstance().findFileByIoFile(myFile) : virtualParent.findChild(myName);\n    }\n  }","id":74159,"modified_method":"@Override\n  public void refresh() {\n    if (myLocal) {\n      if (myVirtualParent == null) {\n        myVirtualFile = LocalFileSystem.getInstance().findFileByIoFile(myFile);\n      }\n      else {\n        myVirtualFile = myVirtualParent.findChild(myName);\n      }\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public String getPath() {\n    final VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile != null && virtualFile.isValid()) {\n      return virtualFile.getPath();\n    }\n    return myFile.getPath();\n  }","id":74160,"modified_method":"@Override\n  public String getPath() {\n    final VirtualFile virtualFile = myVirtualFile;\n    if (virtualFile != null && virtualFile.isValid()) {\n      return virtualFile.getPath();\n    }\n    else {\n      return myFile.getPath();\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFile() {\n    VirtualFile virtualFile = myVirtualFile;\n    if (virtualFile != null && !virtualFile.isValid()) {\n      myVirtualFile = virtualFile = null;\n    }\n    if (virtualFile == null) {\n      refresh();\n      virtualFile = myVirtualFile;\n    }\n    return virtualFile;\n  }","id":74161,"modified_method":"@Override\n  @Nullable\n  public VirtualFile getVirtualFile() {\n    if (myVirtualFile != null && !myVirtualFile.isValid()) {\n      myVirtualFile = null;\n    }\n    return myVirtualFile;\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public FilePath getParentPath() {\n    VirtualFile virtualParent = getVirtualFileParent();\n    if (virtualParent != null && virtualParent.getParent() != null) {\n      return new FilePathImpl(virtualParent);\n    }\n\n    // can't use File.getParentPath() because the path may not correspond to an actual file on disk,\n    // and adding a drive letter would not be appropriate (IDEADEV-7405)\n    // path containing exactly one separator is assumed to be root path\n    final String path = myFile.getPath();\n    int pos = path.lastIndexOf(File.separatorChar);\n    if (pos < 0 || pos == path.indexOf(File.separatorChar)) {\n      return null;\n    }\n    return new FilePathImpl(new File(path.substring(0, pos)), true);\n  }","id":74162,"modified_method":"@Override\n  public FilePath getParentPath() {\n    if (myVirtualParent != null && myVirtualParent.isValid() && myVirtualParent.getParent() != null) {\n      return new FilePathImpl(myVirtualParent);\n    }\n\n    // can't use File.getParentPath() because the path may not correspond to an actual file on disk,\n    // and adding a drive letter would not be appropriate (IDEADEV-7405)\n    // path containing exactly one separator is assumed to be root path\n    final String path = myFile.getPath();\n    int pos = path.lastIndexOf(File.separatorChar);\n    if (pos < 0 || pos == path.indexOf(File.separatorChar)) {\n      return null;\n    }\n    return new FilePathImpl(new File(path.substring(0, pos)), true);\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public Document getDocument() {\n    VirtualFile virtualFile = getVirtualFile();\n    if (virtualFile == null || virtualFile.getFileType().isBinary()) {\n      return null;\n    }\n    return FileDocumentManager.getInstance().getDocument(virtualFile);\n  }","id":74163,"modified_method":"@Override\n  @Nullable\n  public Document getDocument() {\n    if (myVirtualFile == null || myVirtualFile.getFileType().isBinary()) {\n      return null;\n    }\n    return FileDocumentManager.getInstance().getDocument(myVirtualFile);\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isDirectory() {\n    VirtualFile virtualFile = getVirtualFile();\n    return virtualFile == null ? myIsDirectory : virtualFile.isDirectory();\n  }","id":74164,"modified_method":"@Override\n  public boolean isDirectory() {\n    if (myVirtualFile == null) {\n      return myIsDirectory;\n    }\n    else {\n      return myVirtualFile.isDirectory();\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static FilePath createOn(@NotNull String s) {\n    File ioFile = new File(s);\n    final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n    VirtualFile virtualFile = localFileSystem.findFileByIoFile(ioFile);\n    if (virtualFile != null) {\n      return new FilePathImpl(virtualFile);\n    }\n    VirtualFile virtualFileParent = localFileSystem.findFileByIoFile(ioFile.getParentFile());\n    if (virtualFileParent == null) return null;\n    return new FilePathImpl(virtualFileParent, ioFile.getName(), false);\n  }","id":74165,"modified_method":"public static FilePath createOn(String s) {\n    File ioFile = new File(s);\n    final LocalFileSystem localFileSystem = LocalFileSystem.getInstance();\n    VirtualFile virtualFile = localFileSystem.findFileByIoFile(ioFile);\n    if (virtualFile != null) {\n      return new FilePathImpl(virtualFile);\n    }\n    else {\n      VirtualFile virtualFileParent = localFileSystem.findFileByIoFile(ioFile.getParentFile());\n      if (virtualFileParent != null) {\n        return new FilePathImpl(virtualFileParent, ioFile.getName(), false);\n      }\n      else {\n        return null;\n      }\n    }\n  }","commit_id":"5248eb09058228bd71bf79be0ae5ed445b6da476","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected boolean login(Collection<CvsRootProvider> processedCvsRoots, ModalityContext executor)\n    throws CannotFindCvsRootException {\n    setIsLoggedIn();\n    Collection<CvsRootProvider> allCvsRoots = getAllCvsRoots();\n\n    final ProjectLocator projectLocator = ProjectLocator.getInstance();\n    final LocalFileSystem lfs = LocalFileSystem.getInstance();\n    for (final CvsRootProvider cvsRootProvider : allCvsRoots) {\n      if (processedCvsRoots.contains(cvsRootProvider)) continue;\n      processedCvsRoots.add(cvsRootProvider);\n      final VirtualFile vf = lfs.findFileByIoFile(cvsRootProvider.getLocalRoot());\n      final Project project = (vf == null) ? null : projectLocator.guessProjectForFile(vf);\n      if (!cvsRootProvider.login(executor, project)) return false;\n    }\n    return true;\n\n  }","id":74166,"modified_method":"protected boolean login(Collection<CvsRootProvider> processedCvsRoots, ModalityContext executor)\n    throws CannotFindCvsRootException {\n    setIsLoggedIn();\n    Collection<CvsRootProvider> allCvsRoots = getAllCvsRoots();\n\n    final ProjectLocator projectLocator = ProjectLocator.getInstance();\n    final LocalFileSystem lfs = LocalFileSystem.getInstance();\n    for (final CvsRootProvider cvsRootProvider : allCvsRoots) {\n      if (processedCvsRoots.contains(cvsRootProvider)) continue;\n      processedCvsRoots.add(cvsRootProvider);\n      final VirtualFile vf = cvsRootProvider.getLocalRoot() == null ? null : lfs.findFileByIoFile(cvsRootProvider.getLocalRoot());\n      final Project project = (vf == null) ? null : projectLocator.guessProjectForFile(vf);\n      if (!cvsRootProvider.login(executor, project)) return false;\n    }\n    return true;\n\n  }","commit_id":"e78a4451ae88a3b262e1cede4a6ad253f3ca030b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    void parse(VoltXMLElement stmtNode) {\n        String type = stmtNode.attributes.get(\"uniontype\");\n        // Set operation type\n        m_unionType = UnionType.valueOf(type);\n\n        int idx = 0;\n        VoltXMLElement limitElement = null, offsetElement = null, orderbyElement = null;\n        for (VoltXMLElement child : stmtNode.children) {\n            if (SELECT_NODE_NAME.equals(child.name) ||\n                    UNION_NODE_NAME.equals(child.name)) {\n                assert(idx < m_children.size());\n                AbstractParsedStmt nextStmt = m_children.get(idx++);\n                nextStmt.parse(child);\n            } else if (child.name.equalsIgnoreCase(\"limit\")) {\n                limitElement = child;\n            } else if (child.name.equalsIgnoreCase(\"offset\")) {\n                offsetElement = child;\n            } else if (child.name.equalsIgnoreCase(\"ordercolumns\")) {\n                orderbyElement = child;\n            }\n\n        }\n        // Parse LIMIT/OFFSET\n        ParsedSelectStmt.parseLimitAndOffset(limitElement, offsetElement, m_limitOffset);\n        // Parse ORDER BY\n        if (orderbyElement != null) {\n            parseOrderColumns(orderbyElement);\n        }\n\n        // prepare the limit plan node if it needs one.\n        if (hasLimitOrOffset()) {\n            ParsedSelectStmt.prepareLimitPlanNode(this, m_limitOffset);\n        }\n    }","id":74167,"modified_method":"@Override\n    void parse(VoltXMLElement stmtNode) {\n        String type = stmtNode.attributes.get(\"uniontype\");\n        // Set operation type\n        m_unionType = UnionType.valueOf(type);\n\n        int idx = 0;\n        VoltXMLElement limitElement = null, offsetElement = null, orderbyElement = null;\n        for (VoltXMLElement child : stmtNode.children) {\n            if (SELECT_NODE_NAME.equals(child.name) ||\n                    UNION_NODE_NAME.equals(child.name)) {\n                assert(idx < m_children.size());\n                AbstractParsedStmt nextStmt = m_children.get(idx++);\n                nextStmt.parse(child);\n            } else if (child.name.equalsIgnoreCase(\"limit\")) {\n                limitElement = child;\n            } else if (child.name.equalsIgnoreCase(\"offset\")) {\n                offsetElement = child;\n            } else if (child.name.equalsIgnoreCase(\"ordercolumns\")) {\n                orderbyElement = child;\n            }\n\n        }\n        // Parse LIMIT/OFFSET\n        ParsedSelectStmt.parseLimitAndOffset(limitElement, offsetElement, m_limitOffset);\n        // Parse ORDER BY\n        if (orderbyElement != null) {\n            parseOrderColumns(orderbyElement);\n            placeTVEsForOrderby();\n        }\n\n        // prepare the limit plan node if it needs one.\n        if (hasLimitOrOffset()) {\n            ParsedSelectStmt.prepareLimitPlanNode(this, m_limitOffset);\n        }\n    }","commit_id":"a302d814a9bd533b2fca005e5dc7dc7b9c7c04bc","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testUnionOrderByLimit() {\n        AbstractPlanNode pn = compile(\n                \"select C from T3 UNION select B from T2 order by C limit 3 offset 2\");\n        String[] columnNames = {\"C\"};\n        pn = pn.getChild(0);\n        checkOrderByNode(pn, columnNames);\n        assertTrue(pn.getChild(0) instanceof UnionPlanNode);\n        pn = pn.getInlinePlanNode(PlanNodeType.LIMIT);\n        checkLimitNode(pn, 3, 2);\n    }","id":74168,"modified_method":"public void testUnionOrderByLimit() {\n        AbstractPlanNode pn = compile(\n                \"select C from T3 UNION select B from T2 order by C limit 3 offset 2\");\n        String[] columnNames = {\"C\"};\n        pn = pn.getChild(0);\n        int[] idxs = {0};\n        checkOrderByNode(pn, columnNames, idxs);\n        assertTrue(pn.getChild(0) instanceof UnionPlanNode);\n        pn = pn.getInlinePlanNode(PlanNodeType.LIMIT);\n        checkLimitNode(pn, 3, 2);\n    }","commit_id":"a302d814a9bd533b2fca005e5dc7dc7b9c7c04bc","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testUnionOrderby() {\n        {\n            AbstractPlanNode pn = compile(\"select B from T2 UNION select B from T2 order by B\");\n            pn = pn.getChild(0);\n            String[] columnNames = {\"B\"};\n            checkOrderByNode(pn, columnNames);\n        }\n        {\n            AbstractPlanNode pn = compile(\"(select B as B1, B as B2 from T2 UNION select B as B1, B as B2 from T2) order by B1 asc, B2 desc\");\n            pn = pn.getChild(0);\n            String[] columnNames = {\"B1\", \"B2\"};\n            checkOrderByNode(pn, columnNames);\n        }\n        {\n            // T1 is partitioned\n            AbstractPlanNode pn = compile(\"(select A from T1 UNION select B from T2) order by A\");\n            pn = pn.getChild(0);\n            String[] columnNames = {\"A\"};\n            checkOrderByNode(pn, columnNames);\n        }\n    }","id":74169,"modified_method":"public void testUnionOrderby() {\n        {\n            AbstractPlanNode pn = compile(\"select B from T2 UNION select B from T2 order by B\");\n            pn = pn.getChild(0);\n            String[] columnNames = {\"B\"};\n            int[] idxs = {0};\n            checkOrderByNode(pn, columnNames, idxs);\n        }\n        {\n            AbstractPlanNode pn = compile(\"(select B as B1, B as B2 from T2 UNION select B as B1, B as B2 from T2) order by B1 asc, B2 desc\");\n            pn = pn.getChild(0);\n            String[] columnNames = {\"B1\", \"B2\"};\n            int[] idxs = {1, 1};\n            checkOrderByNode(pn, columnNames, idxs);\n        }\n        {\n            // T1 is partitioned\n            AbstractPlanNode pn = compile(\"(select A from T1 UNION select B from T2) order by A\");\n            pn = pn.getChild(0);\n            String[] columnNames = {\"A\"};\n            int[] idxs = {0};\n            checkOrderByNode(pn, columnNames, idxs);\n        }\n    }","commit_id":"a302d814a9bd533b2fca005e5dc7dc7b9c7c04bc","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public void testUnionOrderByLimitParams() {\n        AbstractPlanNode pn = compile(\n                \"select C from T3 where C = ? UNION select B from T2 order by C limit ? offset ?\");\n        String[] columnNames = {\"C\"};\n        pn = pn.getChild(0);\n        checkOrderByNode(pn, columnNames);\n        assertTrue(pn.getChild(0) instanceof UnionPlanNode);\n        pn = pn.getInlinePlanNode(PlanNodeType.LIMIT);\n        assert (pn instanceof LimitPlanNode);\n        assertTrue(pn.toExplainPlanString().contains(\"LIMIT with parameter\"));\n    }","id":74170,"modified_method":"public void testUnionOrderByLimitParams() {\n        AbstractPlanNode pn = compile(\n                \"select C from T3 where C = ? UNION select B from T2 order by C limit ? offset ?\");\n        String[] columnNames = {\"C\"};\n        pn = pn.getChild(0);\n        int[] idxs = {0};\n        checkOrderByNode(pn, columnNames, idxs);\n        assertTrue(pn.getChild(0) instanceof UnionPlanNode);\n        pn = pn.getInlinePlanNode(PlanNodeType.LIMIT);\n        assert (pn instanceof LimitPlanNode);\n        assertTrue(pn.toExplainPlanString().contains(\"LIMIT with parameter\"));\n    }","commit_id":"a302d814a9bd533b2fca005e5dc7dc7b9c7c04bc","url":"https://github.com/VoltDB/voltdb"},{"original_method":"private void checkOrderByNode(AbstractPlanNode pn, String columns[]) {\n        assertTrue(pn != null);\n        assertTrue(pn instanceof OrderByPlanNode);\n        OrderByPlanNode opn = (OrderByPlanNode) pn;\n        assertEquals(columns.length, opn.getOutputSchema().size());\n        for(int i = 0; i < columns.length; ++i) {\n            assertEquals(columns[i], opn.getOutputSchema().getColumns().get(i).getColumnAlias());\n        }\n    }","id":74171,"modified_method":"private void checkOrderByNode(AbstractPlanNode pn, String columns[], int[] idxs) {\n        assertTrue(pn != null);\n        assertTrue(pn instanceof OrderByPlanNode);\n        OrderByPlanNode opn = (OrderByPlanNode) pn;\n        assertEquals(columns.length, opn.getOutputSchema().size());\n        for(int i = 0; i < columns.length; ++i) {\n            SchemaColumn col = opn.getOutputSchema().getColumns().get(i);\n            assertEquals(columns[i], col.getColumnAlias());\n            AbstractExpression colExpr = col.getExpression();\n            assertEquals(ExpressionType.VALUE_TUPLE, colExpr.getExpressionType());\n            assertEquals(idxs[i], ((TupleValueExpression) colExpr).getColumnIndex());\n        }\n    }","commit_id":"a302d814a9bd533b2fca005e5dc7dc7b9c7c04bc","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Three table Union ALL - A.PKEY, B.I and C.I\n     * @throws NoConnectionsException\n     * @throws IOException\n     * @throws ProcCallException\n     */\n    public void testUnionOrderLimitOffset() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = this.getClient();\n        client.callProcedure(\"InsertA\", 0, 1); //In the final result set\n        client.callProcedure(\"InsertB\", 1, 1); //In the final result set\n        client.callProcedure(\"InsertB\", 2, 1); //In the final result set\n        client.callProcedure(\"InsertC\", 1, 2); //In the final result set\n        client.callProcedure(\"InsertC\", 2, 3); //In the final result set\n\n        // No limit, offset\n        VoltTable result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0;\")\n                .getResults()[0];\n        assertEquals(5, result.getRowCount());\n\n        // Order by\n        result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0 ORDER BY PKEY DESC;\")\n                .getResults()[0];\n        assertEquals(5, result.getRowCount());\n        assertEquals(3, result.fetchRow(0).getLong(0));\n        assertEquals(0, result.fetchRow(4).getLong(0));\n\n        if (!isHSQL()) { // HSQL does not handle limit with union\n            // limit 3, no offset\n            result = client.callProcedure(\"@AdHoc\", \"(SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0) LIMIT 3;\")\n                .getResults()[0];\n            assertEquals(3, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL SELECT I FROM B UNION ALL SELECT I FROM C LIMIT ?;\", 3)\n                .getResults()[0];\n            assertEquals(3, result.getRowCount());\n\n            // no limit, offset 3\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL SELECT I FROM B UNION ALL SELECT I FROM C ORDER BY PKEY OFFSET 3;\")\n                .getResults()[0];\n            assertEquals(2, result.getRowCount());\n            assertEquals(2, result.fetchRow(0).getLong(0));\n            assertEquals(3, result.fetchRow(1).getLong(0));\n\n            // limit 2, offset 2\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0 ORDER BY PKEY LIMIT 2 OFFSET 2;\")\n                .getResults()[0];\n            assertEquals(2, result.getRowCount());\n            assertEquals(1, result.fetchRow(0).getLong(0));\n            assertEquals(2, result.fetchRow(1).getLong(0));\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL SELECT I FROM B UNION ALL SELECT I FROM C LIMIT ? OFFSET ?;\", 2, 2)\n                    .getResults()[0];\n            assertEquals(2, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"(SELECT PKEY FROM A UNION ALL SELECT I FROM B LIMIT 1) UNION ALL SELECT I FROM C;\")\n                    .getResults()[0];\n            assertEquals(3, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL (SELECT I FROM B UNION ALL SELECT I FROM C LIMIT 1);\")\n                    .getResults()[0];\n            assertEquals(2, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"(SELECT PKEY FROM A UNION ALL SELECT I FROM B ORDER BY PKEY) UNION ALL SELECT I FROM C;\")\n                    .getResults()[0];\n            assertEquals(5, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL (SELECT I FROM B UNION ALL SELECT I FROM C ORDER BY I);\")\n                    .getResults()[0];\n            assertEquals(5, result.getRowCount());\n}\n\n        // Make sure the query is parameterized\n        result = client.callProcedure(\"@Explain\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0 LIMIT 2 OFFSET 2;\")\n                .getResults()[0];\n        String explainPlan = result.toString();\n        assertTrue(explainPlan.contains(\"LIMIT with parameter\"));\n        assertTrue(explainPlan.contains(\"uniquely match (PKEY = ?0)\"));\n        assertTrue(explainPlan.contains(\"filter by (column#1 = ?1)\"));\n        assertTrue(explainPlan.contains(\"range-scan covering from (PKEY > ?2)\"));\n\n    }","id":74172,"modified_method":"/**\n     * Three table Union ALL - A.PKEY, B.I and C.I\n     * @throws NoConnectionsException\n     * @throws IOException\n     * @throws ProcCallException\n     */\n    public void testUnionOrderLimitOffset() throws NoConnectionsException, IOException, ProcCallException {\n        Client client = this.getClient();\n        client.callProcedure(\"InsertA\", 0, 1); //In the final result set\n        client.callProcedure(\"InsertB\", 1, 1); //In the final result set\n        client.callProcedure(\"InsertB\", 2, 1); //In the final result set\n        client.callProcedure(\"InsertC\", 1, 2); //In the final result set\n        client.callProcedure(\"InsertC\", 2, 3); //In the final result set\n\n        // No limit, offset\n        VoltTable result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0;\")\n                .getResults()[0];\n        assertEquals(5, result.getRowCount());\n\n        // Order by\n        result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0 ORDER BY PKEY DESC;\")\n                .getResults()[0];\n        assertEquals(5, result.getRowCount());\n        assertEquals(3, result.fetchRow(0).getLong(0));\n        assertEquals(0, result.fetchRow(4).getLong(0));\n\n        // Order by with Expr\n        result = client.callProcedure(\"@AdHoc\", \"SELECT ABS(PKEY) as AP FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0 ORDER BY AP DESC;\")\n                .getResults()[0];\n        System.out.println(result.toString());\n        assertEquals(5, result.getRowCount());\n        assertEquals(3, result.fetchRow(0).getLong(0));\n        assertEquals(0, result.fetchRow(4).getLong(0));\n\n        if (!isHSQL()) { // HSQL does not handle limit with union\n            // limit 3, no offset\n            result = client.callProcedure(\"@AdHoc\", \"(SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0) LIMIT 3;\")\n                .getResults()[0];\n            assertEquals(3, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL SELECT I FROM B UNION ALL SELECT I FROM C LIMIT ?;\", 3)\n                .getResults()[0];\n            assertEquals(3, result.getRowCount());\n\n            // no limit, offset 3\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL SELECT I FROM B UNION ALL SELECT I FROM C ORDER BY PKEY OFFSET 3;\")\n                .getResults()[0];\n            assertEquals(2, result.getRowCount());\n            assertEquals(2, result.fetchRow(0).getLong(0));\n            assertEquals(3, result.fetchRow(1).getLong(0));\n\n            // limit 2, offset 2\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0 ORDER BY PKEY LIMIT 2 OFFSET 2;\")\n                .getResults()[0];\n            assertEquals(2, result.getRowCount());\n            assertEquals(1, result.fetchRow(0).getLong(0));\n            assertEquals(2, result.fetchRow(1).getLong(0));\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL SELECT I FROM B UNION ALL SELECT I FROM C LIMIT ? OFFSET ?;\", 2, 2)\n                    .getResults()[0];\n            assertEquals(2, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"(SELECT PKEY FROM A UNION ALL SELECT I FROM B LIMIT 1) UNION ALL SELECT I FROM C;\")\n                    .getResults()[0];\n            assertEquals(3, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL (SELECT I FROM B UNION ALL SELECT I FROM C LIMIT 1);\")\n                    .getResults()[0];\n            assertEquals(2, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"(SELECT PKEY FROM A UNION ALL SELECT I FROM B ORDER BY PKEY) UNION ALL SELECT I FROM C;\")\n                    .getResults()[0];\n            assertEquals(5, result.getRowCount());\n\n            result = client.callProcedure(\"@AdHoc\", \"SELECT PKEY FROM A UNION ALL (SELECT I FROM B UNION ALL SELECT I FROM C ORDER BY I);\")\n                    .getResults()[0];\n            assertEquals(5, result.getRowCount());\n}\n\n        // Make sure the query is parameterized\n        result = client.callProcedure(\"@Explain\", \"SELECT PKEY FROM A WHERE PKEY = 0 UNION ALL SELECT I FROM B WHERE I = 1 UNION ALL SELECT I FROM C WHERE PKEY > 0 LIMIT 2 OFFSET 2;\")\n                .getResults()[0];\n        String explainPlan = result.toString();\n        assertTrue(explainPlan.contains(\"LIMIT with parameter\"));\n        assertTrue(explainPlan.contains(\"uniquely match (PKEY = ?0)\"));\n        assertTrue(explainPlan.contains(\"filter by (column#1 = ?1)\"));\n        assertTrue(explainPlan.contains(\"range-scan covering from (PKEY > ?2)\"));\n\n    }","commit_id":"a302d814a9bd533b2fca005e5dc7dc7b9c7c04bc","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n\t * Create a TransactionStatus for an existing transaction.\n\t */\n\tprivate TransactionStatus handleExistingTransaction(\n\t\t\tTransactionDefinition definition, Object transaction, boolean debugEnabled)\n\t\t\tthrows TransactionException {\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Existing transaction found for transaction marked with propagation 'never'\");\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Suspending current transaction\");\n\t\t\t}\n\t\t\tObject suspendedResources = suspend(transaction);\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n\t\t\treturn newTransactionStatus(\n\t\t\t\t\tdefinition, null, false, newSynchronization, debugEnabled, suspendedResources);\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Suspending current transaction, creating new transaction with name [\" +\n\t\t\t\t\t\tdefinition.getName() + \"]\");\n\t\t\t}\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(transaction);\n\t\t\ttry {\n\t\t\t\tdoBegin(transaction, definition);\n\t\t\t}\n\t\t\tcatch (RuntimeException beginEx) {\n\t\t\t\tresumeAfterBeginException(transaction, suspendedResources, beginEx);\n\t\t\t\tthrow beginEx;\n\t\t\t}\n\t\t\tcatch (Error beginErr) {\n\t\t\t\tresumeAfterBeginException(transaction, suspendedResources, beginErr);\n\t\t\t\tthrow beginErr;\n\t\t\t}\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\t\treturn newTransactionStatus(\n\t\t\t\t\tdefinition, transaction, true, newSynchronization, debugEnabled, suspendedResources);\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n\t\t\tif (!isNestedTransactionAllowed()) {\n\t\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\t\"Transaction manager does not allow nested transactions by default - \" +\n\t\t\t\t\t\t\"specify 'nestedTransactionAllowed' property with value 'true'\");\n\t\t\t}\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Creating nested transaction with name [\" + definition.getName() + \"]\");\n\t\t\t}\n\t\t\tif (useSavepointForNestedTransaction()) {\n\t\t\t\t// Create savepoint within existing Spring-managed transaction,\n\t\t\t\t// through the SavepointManager API implemented by TransactionStatus.\n\t\t\t\t// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.\n\t\t\t\tDefaultTransactionStatus status =\n\t\t\t\t\t\tnewTransactionStatus(definition, transaction, false, false, debugEnabled, null);\n\t\t\t\tstatus.createAndHoldSavepoint();\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Nested transaction through nested begin and commit/rollback calls.\n\t\t\t\t// Usually only for JTA: Spring synchronization might get activated here\n\t\t\t\t// in case of a pre-existing JTA transaction.\n\t\t\t\tdoBegin(transaction, definition);\n\t\t\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\t\t\treturn newTransactionStatus(definition, transaction, true, newSynchronization, debugEnabled, null);\n\t\t\t}\n\t\t}\n\n\t\t// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.\n\t\tif (debugEnabled) {\n\t\t\tlogger.debug(\"Participating in existing transaction\");\n\t\t}\n\t\tif (isValidateExistingTransaction()) {\n\t\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\t\tInteger currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();\n\t\t\t\tif (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {\n\t\t\t\t\tConstants isoConstants = DefaultTransactionDefinition.constants;\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\n\t\t\t\t\t\t\tdefinition + \"] specifies isolation level which is incompatible with existing transaction: \" +\n\t\t\t\t\t\t\t(currentIsolationLevel != null ?\n\t\t\t\t\t\t\t\t\tisoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :\n\t\t\t\t\t\t\t\t\t\"(unknown)\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!definition.isReadOnly()) {\n\t\t\t\tif (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\n\t\t\t\t\t\t\tdefinition + \"] is not marked as read-only but existing transaction is\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\treturn newTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);\n\t}","id":74173,"modified_method":"/**\n\t * Create a TransactionStatus for an existing transaction.\n\t */\n\tprivate TransactionStatus handleExistingTransaction(\n\t\t\tTransactionDefinition definition, Object transaction, boolean debugEnabled)\n\t\t\tthrows TransactionException {\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"Existing transaction found for transaction marked with propagation 'never'\");\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Suspending current transaction\");\n\t\t\t}\n\t\t\tObject suspendedResources = suspend(transaction);\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n\t\t\treturn newTransactionStatus(\n\t\t\t\t\tdefinition, null, false, newSynchronization, debugEnabled, suspendedResources);\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Suspending current transaction, creating new transaction with name [\" +\n\t\t\t\t\t\tdefinition.getName() + \"]\");\n\t\t\t}\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(transaction);\n\t\t\tDefaultTransactionStatus status = null;\n\t\t\ttry {\n\t\t\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\t\t\tstatus = newTransactionStatus(\n\t\t\t\t\t\tdefinition, transaction, true, newSynchronization, debugEnabled, suspendedResources);\n\t\t\t\tdoBegin(transaction, definition);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tcatch (RuntimeException beginEx) {\n\t\t\t\tif (status != null && status.isNewSynchronization()) {\n\t\t\t\t\tTransactionSynchronizationManager.clear();\n\t\t\t\t}\n\t\t\t\tresumeAfterBeginException(transaction, suspendedResources, beginEx);\n\t\t\t\tthrow beginEx;\n\t\t\t}\n\t\t\tcatch (Error beginErr) {\n\t\t\t\tif (status != null && status.isNewSynchronization()) {\n\t\t\t\t\tTransactionSynchronizationManager.clear();\n\t\t\t\t}\n\t\t\t\tresumeAfterBeginException(transaction, suspendedResources, beginErr);\n\t\t\t\tthrow beginErr;\n\t\t\t}\n\t\t}\n\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n\t\t\tif (!isNestedTransactionAllowed()) {\n\t\t\t\tthrow new NestedTransactionNotSupportedException(\n\t\t\t\t\t\t\"Transaction manager does not allow nested transactions by default - \" +\n\t\t\t\t\t\t\"specify 'nestedTransactionAllowed' property with value 'true'\");\n\t\t\t}\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Creating nested transaction with name [\" + definition.getName() + \"]\");\n\t\t\t}\n\t\t\tif (useSavepointForNestedTransaction()) {\n\t\t\t\t// Create savepoint within existing Spring-managed transaction,\n\t\t\t\t// through the SavepointManager API implemented by TransactionStatus.\n\t\t\t\t// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.\n\t\t\t\tDefaultTransactionStatus status =\n\t\t\t\t\t\tnewTransactionStatus(definition, transaction, false, false, debugEnabled, null);\n\t\t\t\tstatus.createAndHoldSavepoint();\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Nested transaction through nested begin and commit/rollback calls.\n\t\t\t\t// Usually only for JTA: Spring synchronization might get activated here\n\t\t\t\t// in case of a pre-existing JTA transaction.\n\t\t\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\t\t\tDefaultTransactionStatus status = newTransactionStatus(\n\t\t\t\t\t\tdefinition, transaction, true, newSynchronization, debugEnabled, null);\n\t\t\t\ttry {\n\t\t\t\t\tdoBegin(transaction, definition);\n\t\t\t\t}\n\t\t\t\tcatch (RuntimeException beginEx) {\n\t\t\t\t\tif (status != null && status.isNewSynchronization()) {\n\t\t\t\t\t\tTransactionSynchronizationManager.clear();\n\t\t\t\t\t}\n\t\t\t\t\tthrow beginEx;\n\t\t\t\t}\n\t\t\t\tcatch (Error beginErr) {\n\t\t\t\t\tif (status != null && status.isNewSynchronization()) {\n\t\t\t\t\t\tTransactionSynchronizationManager.clear();\n\t\t\t\t\t}\n\t\t\t\t\tthrow beginErr;\n\t\t\t\t}\n\t\t\t\treturn status;\n\t\t\t}\n\t\t}\n\n\t\t// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.\n\t\tif (debugEnabled) {\n\t\t\tlogger.debug(\"Participating in existing transaction\");\n\t\t}\n\t\tif (isValidateExistingTransaction()) {\n\t\t\tif (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\n\t\t\t\tInteger currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();\n\t\t\t\tif (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {\n\t\t\t\t\tConstants isoConstants = DefaultTransactionDefinition.constants;\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\n\t\t\t\t\t\t\tdefinition + \"] specifies isolation level which is incompatible with existing transaction: \" +\n\t\t\t\t\t\t\t(currentIsolationLevel != null ?\n\t\t\t\t\t\t\t\t\tisoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :\n\t\t\t\t\t\t\t\t\t\"(unknown)\"));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!definition.isReadOnly()) {\n\t\t\t\tif (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {\n\t\t\t\t\tthrow new IllegalTransactionStateException(\"Participating transaction with definition [\" +\n\t\t\t\t\t\t\tdefinition + \"] is not marked as read-only but existing transaction is\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\treturn newTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);\n\t}","commit_id":"557dd1f1c448627c420f73ad355a9a2adc2700f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Create a new TransactionStatus for the given arguments,\n\t * initializing transaction synchronization as appropriate.\n\t */\n\tprotected DefaultTransactionStatus newTransactionStatus(\n\t\t\tTransactionDefinition definition, Object transaction, boolean newTransaction,\n\t\t\tboolean newSynchronization, boolean debug, Object suspendedResources) {\n\n\t\tboolean actualNewSynchronization = newSynchronization &&\n\t\t\t\t!TransactionSynchronizationManager.isSynchronizationActive();\n\t\tif (actualNewSynchronization) {\n\t\t\tTransactionSynchronizationManager.setActualTransactionActive(transaction != null);\n\t\t\tTransactionSynchronizationManager.setCurrentTransactionIsolationLevel(\n\t\t\t\t\t(definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) ?\n\t\t\t\t\t\t\tdefinition.getIsolationLevel() : null);\n\t\t\tTransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());\n\t\t\tTransactionSynchronizationManager.setCurrentTransactionName(definition.getName());\n\t\t\tTransactionSynchronizationManager.initSynchronization();\n\t\t}\n\t\treturn new DefaultTransactionStatus(\n\t\t\t\ttransaction, newTransaction, actualNewSynchronization,\n\t\t\t\tdefinition.isReadOnly(), debug, suspendedResources);\n\t}","id":74174,"modified_method":"/**\n\t * Create a new TransactionStatus for the given arguments,\n\t * initializing transaction synchronization as appropriate.\n\t */\n\tprotected DefaultTransactionStatus newTransactionStatus(\n\t\t\tTransactionDefinition definition, Object transaction, boolean newTransaction,\n\t\t\tboolean newSynchronization, boolean debug, Object suspendedResources) {\n\n\t\tboolean actualNewSynchronization = newSynchronization &&\n\t\t\t\t!TransactionSynchronizationManager.isSynchronizationActive();\n\t\ttry {\n\t\t\tif (actualNewSynchronization) {\n\t\t\t\tTransactionSynchronizationManager.setActualTransactionActive(transaction != null);\n\t\t\t\tTransactionSynchronizationManager.setCurrentTransactionIsolationLevel(\n\t\t\t\t\t\t(definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) ?\n\t\t\t\t\t\t\t\tdefinition.getIsolationLevel() : null);\n\t\t\t\tTransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly());\n\t\t\t\tTransactionSynchronizationManager.setCurrentTransactionName(definition.getName());\n\t\t\t\tTransactionSynchronizationManager.initSynchronization();\n\t\t\t}\n\t\t\treturn new DefaultTransactionStatus(\n\t\t\t\t\ttransaction, newTransaction, actualNewSynchronization,\n\t\t\t\t\tdefinition.isReadOnly(), debug, suspendedResources);\n\t\t}\n\t\tcatch (Error err) {\n\t\t\t// Can only really be an OutOfMemoryError...\n\t\t\tif (actualNewSynchronization) {\n\t\t\t\tTransactionSynchronizationManager.clear();\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\t}","commit_id":"557dd1f1c448627c420f73ad355a9a2adc2700f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * Clean up after completion, clearing synchronization if necessary,\n\t * and invoking doCleanupAfterCompletion.\n\t * @param status object representing the transaction\n\t * @see #doCleanupAfterCompletion\n\t */\n\tprivate void cleanupAfterCompletion(DefaultTransactionStatus status) {\n\t\tstatus.setCompleted();\n\t\tif (status.isNewSynchronization()) {\n\t\t\tTransactionSynchronizationManager.clear();\n\t\t}\n\t\tif (status.isNewTransaction()) {\n\t\t\tdoCleanupAfterCompletion(status.getTransaction());\n\t\t}\n\t\tif (status.getSuspendedResources() != null) {\n\t\t\tif (status.isDebug()) {\n\t\t\t\tlogger.debug(\"Resuming suspended transaction\");\n\t\t\t}\n\t\t\tresume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources());\n\t\t}\n\t}","id":74175,"modified_method":"/**\n\t * Clean up after completion, clearing synchronization if necessary,\n\t * and invoking doCleanupAfterCompletion.\n\t * @param status object representing the transaction\n\t * @see #doCleanupAfterCompletion\n\t */\n\tprivate void cleanupAfterCompletion(DefaultTransactionStatus status) {\n\t\tstatus.setCompleted();\n\t\tif (status.isNewSynchronization()) {\n\t\t\tTransactionSynchronizationManager.clear();\n\t\t}\n\t\tif (status.isNewTransaction()) {\n\t\t\tdoCleanupAfterCompletion(status.getTransaction());\n\t\t}\n\t\tif (status.getSuspendedResources() != null) {\n\t\t\tif (status.isDebug()) {\n\t\t\t\tlogger.debug(\"Resuming suspended transaction after completion of inner transaction\");\n\t\t\t}\n\t\t\tresume(status.getTransaction(), (SuspendedResourcesHolder) status.getSuspendedResources());\n\t\t}\n\t}","commit_id":"557dd1f1c448627c420f73ad355a9a2adc2700f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * This implementation handles propagation behavior. Delegates to\n\t * <code>doGetTransaction<\/code>, <code>isExistingTransaction<\/code>\n\t * and <code>doBegin<\/code>.\n\t * @see #doGetTransaction\n\t * @see #isExistingTransaction\n\t * @see #doBegin\n\t */\n\tpublic final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {\n\t\tObject transaction = doGetTransaction();\n\n\t\t// Cache debug flag to avoid repeated checks.\n\t\tboolean debugEnabled = logger.isDebugEnabled();\n\n\t\tif (definition == null) {\n\t\t\t// Use defaults if no transaction definition given.\n\t\t\tdefinition = new DefaultTransactionDefinition();\n\t\t}\n\n\t\tif (isExistingTransaction(transaction)) {\n\t\t\t// Existing transaction found -> check propagation behavior to find out how to behave.\n\t\t\treturn handleExistingTransaction(definition, transaction, debugEnabled);\n\t\t}\n\n\t\t// Check definition settings for new transaction.\n\t\tif (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\tthrow new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout());\n\t\t}\n\n\t\t// No existing transaction found -> check propagation behavior to find out how to proceed.\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"No existing transaction found for transaction marked with propagation 'mandatory'\");\n\t\t}\n\t\telse if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||\n\t\t\t\tdefinition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||\n\t\t    definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(null);\n\t\t\tif (debugEnabled) {\n\t\t\t\tlogger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tdoBegin(transaction, definition);\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tresume(null, suspendedResources);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Error err) {\n\t\t\t\tresume(null, suspendedResources);\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\t\treturn newTransactionStatus(\n\t\t\t\t\tdefinition, transaction, true, newSynchronization, debugEnabled, suspendedResources);\n\t\t}\n\t\telse {\n\t\t\t// Create \"empty\" transaction: no actual transaction, but potentially synchronization.\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n\t\t\treturn newTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);\n\t\t}\n\t}","id":74176,"modified_method":"/**\n\t * This implementation handles propagation behavior. Delegates to\n\t * <code>doGetTransaction<\/code>, <code>isExistingTransaction<\/code>\n\t * and <code>doBegin<\/code>.\n\t * @see #doGetTransaction\n\t * @see #isExistingTransaction\n\t * @see #doBegin\n\t */\n\tpublic final TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException {\n\t\tObject transaction = doGetTransaction();\n\n\t\t// Cache debug flag to avoid repeated checks.\n\t\tboolean debugEnabled = logger.isDebugEnabled();\n\n\t\tif (definition == null) {\n\t\t\t// Use defaults if no transaction definition given.\n\t\t\tdefinition = new DefaultTransactionDefinition();\n\t\t}\n\n\t\tif (isExistingTransaction(transaction)) {\n\t\t\t// Existing transaction found -> check propagation behavior to find out how to behave.\n\t\t\treturn handleExistingTransaction(definition, transaction, debugEnabled);\n\t\t}\n\n\t\t// Check definition settings for new transaction.\n\t\tif (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {\n\t\t\tthrow new InvalidTimeoutException(\"Invalid transaction timeout\", definition.getTimeout());\n\t\t}\n\n\t\t// No existing transaction found -> check propagation behavior to find out how to proceed.\n\t\tif (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {\n\t\t\tthrow new IllegalTransactionStateException(\n\t\t\t\t\t\"No existing transaction found for transaction marked with propagation 'mandatory'\");\n\t\t}\n\t\telse if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||\n\t\t\t\tdefinition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||\n\t\t    definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {\n\t\t\tSuspendedResourcesHolder suspendedResources = suspend(null);\n\t\t\tDefaultTransactionStatus status = null;\n\t\t\ttry {\n\t\t\t\tif (debugEnabled) {\n\t\t\t\t\tlogger.debug(\"Creating new transaction with name [\" + definition.getName() + \"]: \" + definition);\n\t\t\t\t}\n\t\t\t\tboolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);\n\t\t\t\tstatus = newTransactionStatus(\n\t\t\t\t\t\tdefinition, transaction, true, newSynchronization, debugEnabled, suspendedResources);\n\t\t\t\tdoBegin(transaction, definition);\n\t\t\t\treturn status;\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tif (status != null && status.isNewSynchronization()) {\n\t\t\t\t\tTransactionSynchronizationManager.clear();\n\t\t\t\t}\n\t\t\t\tresume(null, suspendedResources);\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t\tcatch (Error err) {\n\t\t\t\tif (status != null && status.isNewSynchronization()) {\n\t\t\t\t\tTransactionSynchronizationManager.clear();\n\t\t\t\t}\n\t\t\t\tresume(null, suspendedResources);\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// Create \"empty\" transaction: no actual transaction, but potentially synchronization.\n\t\t\tboolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);\n\t\t\treturn newTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);\n\t\t}\n\t}","commit_id":"557dd1f1c448627c420f73ad355a9a2adc2700f2","url":"https://github.com/spring-projects/spring-framework"},{"original_method":"/**\n\t * @return The time at which we will have to send some\n\t * notifications. Or Long.MAX_VALUE if there are none to send.\n\t */\n\tpublic long getNextUrgentTime() {\n\t\tlong earliestTime = Long.MAX_VALUE;\n\t\tsynchronized(ackQueue) {\n\t\t\tif(!ackQueue.isEmpty()) {\n\t\t\t\tQueuedAck qa = ackQueue.get(0);\n\t\t\t\tearliestTime = qa.urgentTime;\n\t\t\t}\n\t\t}\n\t\tsynchronized(resendRequestQueue) {\n\t\t\tif(!resendRequestQueue.isEmpty()) {\n\t\t\t\tQueuedResendRequest qr = resendRequestQueue.getLowest();\n\t\t\t\tearliestTime = Math.min(earliestTime, qr.urgentTime);\n\t\t\t}\n\t\t}\n\t\tsynchronized(ackRequestQueue) {\n\t\t\tif(!ackRequestQueue.isEmpty()) {\n\t\t\t\tQueuedAckRequest qr = ackRequestQueue.getLowest();\n\t\t\t\tearliestTime = Math.min(earliestTime, qr.urgentTime);\n\t\t\t}\n\t\t}\n\t\treturn earliestTime;\n\t}","id":74177,"modified_method":"/**\n\t * @return The time at which we will have to send some\n\t * notifications. Or Long.MAX_VALUE if there are none to send.\n\t */\n\tpublic long getNextUrgentTime() {\n\t\tlong earliestTime = Long.MAX_VALUE;\n\t\tsynchronized(ackQueue) {\n\t\t\tif(!ackQueue.isEmpty()) {\n\t\t\t\tQueuedAck qa = ackQueue.get(0);\n\t\t\t\tearliestTime = qa.urgentTime;\n\t\t\t}\n\t\t}\n\t\tPacketActionItem qr = null;\n\t\tsynchronized(resendRequestQueue) {\n\t\t\tif(!resendRequestQueue.isEmpty())\n\t\t\t\tqr = resendRequestQueue.getLowest();\n\t\t}\n\t\tif (qr != null);\n\t\t\tearliestTime = Math.min(earliestTime, qr.urgentTime);\n\n\t\tsynchronized(ackRequestQueue) {\n\t\t\tif(!ackRequestQueue.isEmpty())\n\t\t\t\tqr = ackRequestQueue.getLowest();\n\t\t}\n\t\tif (qr != null);\n\t\t\tearliestTime = Math.min(earliestTime, qr.urgentTime);\n\t\treturn earliestTime;\n\t}","commit_id":"35e0e86778b1cfad9c31ef7f003b55abd9abbcf3","url":"https://github.com/freenet/fred"},{"original_method":"public Iterator<KeyValue> descendingIterator() {\n    return new MapEntryIterator(this.delegatee.descendingMap().entrySet().\n      iterator());\n  }","id":74178,"modified_method":"public Iterator<KeyValue> descendingIterator() {\n    return this.delegatee.descendingMap().values().iterator();\n  }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"public Iterator<KeyValue> iterator() {\n    return new MapEntryIterator(this.delegatee.entrySet().iterator());\n  }","id":74179,"modified_method":"public Iterator<KeyValue> iterator() {\n    return this.delegatee.values().iterator();\n  }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"protected KeyValue getNext(Iterator<KeyValue> it) {\n      KeyValue ret = null;\n      long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \": threadpoint = \" + readPoint);\n\n      while (ret == null && it.hasNext()) {\n        KeyValue v = it.next();\n        if (v.getMemstoreTS() <= readPoint) {\n          // keep it.\n          ret = v;\n        }\n        numIterReseek--;\n        if (numIterReseek == 0) {\n          break;\n        }\n      }\n      return ret;\n    }","id":74180,"modified_method":"protected KeyValue getNext(Iterator<KeyValue> it, long readPoint) {\n      KeyValue ret = null;\n      //long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \": threadpoint = \" + readPoint);\n\n      while (ret == null && it.hasNext()) {\n        KeyValue v = it.next();\n        if (v.getMemstoreTS() <= readPoint) {\n          // keep it.\n          ret = v;\n        }\n        numIterReseek--;\n        if (numIterReseek == 0) {\n          break;\n        }\n      }\n      return ret;\n    }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"public synchronized KeyValue peek() {\n      //DebugPrint.println(\" MS@\" + hashCode() + \" peek = \" + getLowest());\n      return getLowest();\n    }","id":74181,"modified_method":"@Override\n    public synchronized KeyValue peek() {\n      //DebugPrint.println(\" MS@\" + hashCode() + \" peek = \" + getLowest());\n      return theNext;\n    }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"public synchronized boolean seek(KeyValue key) {\n      if (key == null) {\n        close();\n        return false;\n      }\n      numIterReseek = 0;\n\n      // kvset and snapshot will never be empty.\n      // if tailSet cant find anything, SS is empty (not null).\n      SortedSet<KeyValue> kvTail = kvset.tailSet(key);\n      SortedSet<KeyValue> snapshotTail = snapshot.tailSet(key);\n\n      kvsetIt = kvTail.iterator();\n      snapshotIt = snapshotTail.iterator();\n\n      kvsetNextRow = getNext(kvsetIt);\n      snapshotNextRow = getNext(snapshotIt);\n\n\n      //long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \" kvset seek: \" + kvsetNextRow + \" with size = \" +\n      //    kvset.size() + \" threadread = \" + readPoint);\n      //DebugPrint.println( \" MS@\" + hashCode() + \" snapshot seek: \" + snapshotNextRow + \" with size = \" +\n      //    snapshot.size() + \" threadread = \" + readPoint);\n\n\n      KeyValue lowest = getLowest();\n\n      // has data := (lowest != null)\n      return lowest != null;\n    }","id":74182,"modified_method":"public synchronized boolean seek(KeyValue key) {\n      if (key == null) {\n        close();\n        return false;\n      }\n      numIterReseek = 0;\n\n      // kvset and snapshot will never be empty.\n      // if tailSet cant find anything, SS is empty (not null).\n      SortedSet<KeyValue> kvTail = kvset.tailSet(key);\n      SortedSet<KeyValue> snapshotTail = snapshot.tailSet(key);\n\n      kvsetIt = kvTail.iterator();\n      snapshotIt = snapshotTail.iterator();\n\n      long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      kvsetNextRow = getNext(kvsetIt, readPoint);\n      snapshotNextRow = getNext(snapshotIt, readPoint);\n\n      theNext = getLowest();\n\n      //long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \" kvset seek: \" + kvsetNextRow + \" with size = \" +\n      //    kvset.size() + \" threadread = \" + readPoint);\n      //DebugPrint.println( \" MS@\" + hashCode() + \" snapshot seek: \" + snapshotNextRow + \" with size = \" +\n      //    snapshot.size() + \" threadread = \" + readPoint);\n\n      // has data\n      return (theNext != null);\n    }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"protected KeyValue getLower(KeyValue first, KeyValue second) {\n      if (first == null && second == null) {\n        return null;\n      }\n      if (first != null && second != null) {\n        int compare = comparator.compare(first, second);\n        return (compare <= 0 ? first : second);\n      }\n      return (first != null ? first : second);\n    }","id":74183,"modified_method":"protected KeyValue getLower(KeyValue first, KeyValue second) {\n      if (first == null) {\n        return second;\n      }\n      if (second == null) {\n        return first;\n      }\n\n      int compare = comparator.compare(first, second);\n      return (compare <= 0 ? first : second);\n    }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"public synchronized KeyValue next() {\n      KeyValue theNext = getLowest();\n\n      if (theNext == null) {\n          return null;\n      }\n\n      // Advance one of the iterators\n      if (theNext == kvsetNextRow) {\n        kvsetNextRow = getNext(kvsetIt);\n      } else {\n        snapshotNextRow = getNext(snapshotIt);\n      }\n\n      //long readpoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println(\" MS@\" + hashCode() + \" next: \" + theNext + \" next_next: \" +\n      //    getLowest() + \" threadpoint=\" + readpoint);\n      return theNext;\n    }","id":74184,"modified_method":"@Override\n    public synchronized KeyValue next() {\n\n      if (theNext == null) {\n          return null;\n      }\n\n      KeyValue ret = theNext;\n\n      // Advance one of the iterators\n      long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      if (theNext == kvsetNextRow) {\n        kvsetNextRow = getNext(kvsetIt, readPoint);\n      } else {\n        snapshotNextRow = getNext(snapshotIt, readPoint);\n      }\n\n      // Calculate the next value\n      theNext = getLowest();\n\n      //readpoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println(\" MS@\" + hashCode() + \" next: \" + theNext +\n      //    \" next_next: \" + getLowest() + \" threadpoint=\" + readpoint);\n      return ret;\n    }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public boolean reseek(KeyValue key) {\n      numIterReseek = reseekNumKeys;\n      while (kvsetNextRow != null &&\n          comparator.compare(kvsetNextRow, key) < 0) {\n        kvsetNextRow = getNext(kvsetIt);\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (kvsetNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n\n      while (snapshotNextRow != null &&\n          comparator.compare(snapshotNextRow, key) < 0) {\n        snapshotNextRow = getNext(snapshotIt);\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (snapshotNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n      return (kvsetNextRow != null || snapshotNextRow != null);\n    }","id":74185,"modified_method":"@Override\n    public synchronized boolean reseek(KeyValue key) {\n\n      numIterReseek = reseekNumKeys;\n      while (kvsetNextRow != null &&\n          comparator.compare(kvsetNextRow, key) < 0) {\n        kvsetNextRow = getNext(kvsetIt,\n          ReadWriteConsistencyControl.getThreadReadPoint());\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (kvsetNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n\n      while (snapshotNextRow != null &&\n          comparator.compare(snapshotNextRow, key) < 0) {\n        snapshotNextRow = getNext(snapshotIt,\n          ReadWriteConsistencyControl.getThreadReadPoint());\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (snapshotNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n\n      // Calculate the next value\n      theNext = getLowest();\n\n      return (theNext != null);\n    }","commit_id":"a02c83a1d7348db118089aa1430194573d3cfbe3","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public synchronized boolean reseek(KeyValue key) {\n\n      numIterReseek = reseekNumKeys;\n      while (kvsetNextRow != null &&\n          comparator.compare(kvsetNextRow, key) < 0) {\n        kvsetNextRow = getNext(kvsetIt,\n          ReadWriteConsistencyControl.getThreadReadPoint());\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (kvsetNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n\n      while (snapshotNextRow != null &&\n          comparator.compare(snapshotNextRow, key) < 0) {\n        snapshotNextRow = getNext(snapshotIt,\n          ReadWriteConsistencyControl.getThreadReadPoint());\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (snapshotNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n\n      // Calculate the next value\n      theNext = getLowest();\n\n      return (theNext != null);\n    }","id":74186,"modified_method":"@Override\n    public boolean reseek(KeyValue key) {\n      numIterReseek = reseekNumKeys;\n      while (kvsetNextRow != null &&\n          comparator.compare(kvsetNextRow, key) < 0) {\n        kvsetNextRow = getNext(kvsetIt);\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (kvsetNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n\n      while (snapshotNextRow != null &&\n          comparator.compare(snapshotNextRow, key) < 0) {\n        snapshotNextRow = getNext(snapshotIt);\n        // if we scanned enough entries but still not able to find the\n        // kv we are looking for, better cut our costs and do a tree\n        // scan using seek.\n        if (snapshotNextRow == null && numIterReseek == 0) {\n          return seek(key);\n        }\n      }\n      return (kvsetNextRow != null || snapshotNextRow != null);\n    }","commit_id":"5148146dafe9a89c5d21af420a179603399e9c40","url":"https://github.com/apache/hbase"},{"original_method":"public synchronized boolean seek(KeyValue key) {\n      if (key == null) {\n        close();\n        return false;\n      }\n      numIterReseek = 0;\n\n      // kvset and snapshot will never be empty.\n      // if tailSet cant find anything, SS is empty (not null).\n      SortedSet<KeyValue> kvTail = kvset.tailSet(key);\n      SortedSet<KeyValue> snapshotTail = snapshot.tailSet(key);\n\n      kvsetIt = kvTail.iterator();\n      snapshotIt = snapshotTail.iterator();\n\n      long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      kvsetNextRow = getNext(kvsetIt, readPoint);\n      snapshotNextRow = getNext(snapshotIt, readPoint);\n\n      theNext = getLowest();\n\n      //long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \" kvset seek: \" + kvsetNextRow + \" with size = \" +\n      //    kvset.size() + \" threadread = \" + readPoint);\n      //DebugPrint.println( \" MS@\" + hashCode() + \" snapshot seek: \" + snapshotNextRow + \" with size = \" +\n      //    snapshot.size() + \" threadread = \" + readPoint);\n\n      // has data\n      return (theNext != null);\n    }","id":74187,"modified_method":"public synchronized boolean seek(KeyValue key) {\n      if (key == null) {\n        close();\n        return false;\n      }\n      numIterReseek = 0;\n\n      // kvset and snapshot will never be empty.\n      // if tailSet cant find anything, SS is empty (not null).\n      SortedSet<KeyValue> kvTail = kvset.tailSet(key);\n      SortedSet<KeyValue> snapshotTail = snapshot.tailSet(key);\n\n      kvsetIt = kvTail.iterator();\n      snapshotIt = snapshotTail.iterator();\n\n      kvsetNextRow = getNext(kvsetIt);\n      snapshotNextRow = getNext(snapshotIt);\n\n\n      //long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \" kvset seek: \" + kvsetNextRow + \" with size = \" +\n      //    kvset.size() + \" threadread = \" + readPoint);\n      //DebugPrint.println( \" MS@\" + hashCode() + \" snapshot seek: \" + snapshotNextRow + \" with size = \" +\n      //    snapshot.size() + \" threadread = \" + readPoint);\n\n\n      KeyValue lowest = getLowest();\n\n      // has data := (lowest != null)\n      return lowest != null;\n    }","commit_id":"5148146dafe9a89c5d21af420a179603399e9c40","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public synchronized KeyValue peek() {\n      //DebugPrint.println(\" MS@\" + hashCode() + \" peek = \" + getLowest());\n      return theNext;\n    }","id":74188,"modified_method":"public synchronized KeyValue peek() {\n      //DebugPrint.println(\" MS@\" + hashCode() + \" peek = \" + getLowest());\n      return getLowest();\n    }","commit_id":"5148146dafe9a89c5d21af420a179603399e9c40","url":"https://github.com/apache/hbase"},{"original_method":"protected KeyValue getNext(Iterator<KeyValue> it, long readPoint) {\n      KeyValue ret = null;\n      //long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \": threadpoint = \" + readPoint);\n\n      while (ret == null && it.hasNext()) {\n        KeyValue v = it.next();\n        if (v.getMemstoreTS() <= readPoint) {\n          // keep it.\n          ret = v;\n        }\n        numIterReseek--;\n        if (numIterReseek == 0) {\n          break;\n        }\n      }\n      return ret;\n    }","id":74189,"modified_method":"protected KeyValue getNext(Iterator<KeyValue> it) {\n      KeyValue ret = null;\n      long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println( \" MS@\" + hashCode() + \": threadpoint = \" + readPoint);\n\n      while (ret == null && it.hasNext()) {\n        KeyValue v = it.next();\n        if (v.getMemstoreTS() <= readPoint) {\n          // keep it.\n          ret = v;\n        }\n        numIterReseek--;\n        if (numIterReseek == 0) {\n          break;\n        }\n      }\n      return ret;\n    }","commit_id":"5148146dafe9a89c5d21af420a179603399e9c40","url":"https://github.com/apache/hbase"},{"original_method":"protected KeyValue getLower(KeyValue first, KeyValue second) {\n      if (first == null) {\n        return second;\n      }\n      if (second == null) {\n        return first;\n      }\n\n      int compare = comparator.compare(first, second);\n      return (compare <= 0 ? first : second);\n    }","id":74190,"modified_method":"protected KeyValue getLower(KeyValue first, KeyValue second) {\n      if (first == null && second == null) {\n        return null;\n      }\n      if (first != null && second != null) {\n        int compare = comparator.compare(first, second);\n        return (compare <= 0 ? first : second);\n      }\n      return (first != null ? first : second);\n    }","commit_id":"5148146dafe9a89c5d21af420a179603399e9c40","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public synchronized KeyValue next() {\n\n      if (theNext == null) {\n          return null;\n      }\n\n      KeyValue ret = theNext;\n\n      // Advance one of the iterators\n      long readPoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      if (theNext == kvsetNextRow) {\n        kvsetNextRow = getNext(kvsetIt, readPoint);\n      } else {\n        snapshotNextRow = getNext(snapshotIt, readPoint);\n      }\n\n      // Calculate the next value\n      theNext = getLowest();\n\n      //readpoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println(\" MS@\" + hashCode() + \" next: \" + theNext +\n      //    \" next_next: \" + getLowest() + \" threadpoint=\" + readpoint);\n      return ret;\n    }","id":74191,"modified_method":"public synchronized KeyValue next() {\n      KeyValue theNext = getLowest();\n\n      if (theNext == null) {\n          return null;\n      }\n\n      // Advance one of the iterators\n      if (theNext == kvsetNextRow) {\n        kvsetNextRow = getNext(kvsetIt);\n      } else {\n        snapshotNextRow = getNext(snapshotIt);\n      }\n\n      //long readpoint = ReadWriteConsistencyControl.getThreadReadPoint();\n      //DebugPrint.println(\" MS@\" + hashCode() + \" next: \" + theNext + \" next_next: \" +\n      //    getLowest() + \" threadpoint=\" + readpoint);\n      return theNext;\n    }","commit_id":"5148146dafe9a89c5d21af420a179603399e9c40","url":"https://github.com/apache/hbase"},{"original_method":"private boolean ProcessFileFolder(String sourcefilefoldername,String destinationfilefoldername,String wildcard,Job parentJob,Result result)\n\t{\n\t\tboolean entrystatus = false ;\n\t\tFileObject sourcefilefolder = null;\n\t\tFileObject destinationfilefolder = null;\n\t\t\n\t\t// Clear list files to remove after copy process\n\t\t// This list is also added to result files name\n\t\tlist_files_remove.clear();\n\t\tlist_add_result.clear();\n\t\t\n\t\t\n\t\t// Get real source, destination file and wildcard\n\t\tString realSourceFilefoldername = environmentSubstitute(sourcefilefoldername);\n\t\tString realDestinationFilefoldername = environmentSubstitute(destinationfilefoldername);\n\t\tString realWildcard=environmentSubstitute(wildcard);\n\n\t\ttry\n\t\t{\n\t\t\tsourcefilefolder = KettleVFS.getFileObject(realSourceFilefoldername, this);\n\t\t\tdestinationfilefolder = KettleVFS.getFileObject(realDestinationFilefoldername, this);\n\t\t\t\n\t\t\tif (sourcefilefolder.exists())\n\t\t\t{\n\t\t\t\n\t\t\t\t// Check if destination folder/parent folder exists !\n\t\t\t\t// If user wanted and if destination folder does not exist\n\t\t\t\t// PDI will create it\n\t\t\t\tif(CreateDestinationFolder(destinationfilefolder))\n\t\t\t\t{\n\n\t\t\t\t\t// Basic Tests\n\t\t\t\t\tif (sourcefilefolder.getType().equals(FileType.FOLDER) && destination_is_a_file)//destinationfilefolder.getType().equals(FileType.FILE))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Source is a folder, destination is a file\n\t\t\t\t\t\t// WARNING !!! CAN NOT COPY FOLDER TO FILE !!!\n\t\t\t\t\t\t\n\t\t\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"JobCopyFiles.Log.Forbidden\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.CanNotCopyFolderToFile\",realSourceFilefoldername,realDestinationFilefoldername));\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tNbrFail++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (destinationfilefolder.getType().equals(FileType.FOLDER) && sourcefilefolder.getType().equals(FileType.FILE) )\n\t\t\t\t\t\t{\t\t\t\t\n\t\t\t\t\t\t\t// Source is a file, destination is a folder\n\t\t\t\t\t\t\t// Copy the file to the destination folder\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdestinationfilefolder.copyFrom(sourcefilefolder.getParent(),new TextOneFileSelector(sourcefilefolder.getParent().toString(),sourcefilefolder.getName().getBaseName(),destinationfilefolder.toString() ) );\n\t\t\t\t\t\t\tif(log.isDetailed())\t\n\t\t\t\t\t\t\t\tlog.logDetailed(BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopiedInfos\"), \n\t\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopied\",sourcefilefolder.getName().toString(),destinationfilefolder.getName().toString()));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sourcefilefolder.getType().equals(FileType.FILE) && destination_is_a_file)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Source is a file, destination is a file\n\n\t\t\t\t\t\t\tdestinationfilefolder.copyFrom(sourcefilefolder, new TextOneToOneFileSelector(destinationfilefolder));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Both source and destination are folders\n\t\t\t\t\t\t\tif(log.isDetailed()) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logDetailed(\"\",\"  \");\r\n\t\t\t\t\t\t\t\tlogDetailed(BaseMessages.getString(PKG, \"JobCopyFiles.Log.FetchFolder\",sourcefilefolder.toString()));\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdestinationfilefolder.copyFrom(sourcefilefolder,new TextFileSelector(sourcefilefolder.toString(),destinationfilefolder.toString(),realWildcard,parentJob) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Remove Files if needed\n\t\t\t\t\t\tif (remove_source_files && !list_files_remove.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t for (Iterator<String> iter = list_files_remove.iterator(); iter.hasNext() && !parentJob.isStopped();)\n\t\t\t\t\t        {\n\t\t\t\t\t            String fileremoventry = (String) iter.next();\n\t\t\t\t\t            // Remove ONLY Files\n\t\t\t\t\t            if (KettleVFS.getFileObject(fileremoventry, this).getType() == FileType.FILE)\n\t\t\t\t\t            {\n\t\t\t\t\t\t            boolean deletefile=KettleVFS.getFileObject(fileremoventry, this).delete();\n\t\t\t\t\t\t            log.logBasic(\" ------ \");\n\t\t\t\t\t\t            if (!deletefile)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlog.logError(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.Error\"), \n\t\t\t\t\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CanRemoveFileFolder\",fileremoventry));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t            else\n\t\t\t\t\t\t            {\n\t\t\t\t\t\t            \tif(log.isDetailed())\n\t\t\t\t\t\t            \t\tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileFolderRemovedInfos\"), \n\t\t\t\t\t\t            \t\t\tBaseMessages.getString(PKG, \"JobCopyFiles.Log.FileFolderRemoved\", fileremoventry));\n\t\t\t\t\t\t            }\n\t\t\t\t\t            }\n\t\t\t\t\t        }\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add files to result files name\n\t\t\t\t\t\tif (add_result_filesname && !list_add_result.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t for (Iterator<String> iter = list_add_result.iterator(); iter.hasNext();)\n\t\t\t\t\t        {\n\t\t\t\t\t            String fileaddentry = (String) iter.next();\n\t\t\t\t\t            // Add ONLY Files\n\t\t\t\t\t            if (KettleVFS.getFileObject(fileaddentry, this).getType() == FileType.FILE)\n\t\t\t\t\t            { \n\t\t\t\t                \tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, KettleVFS.getFileObject(fileaddentry, this), parentJob.getJobname(), toString());\n\t\t\t\t                    result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n\t\t\t\t                    if(log.isDetailed())\r\n\t\t\t\t                    {\n\t\t\t\t                    \tlog.logDetailed(\"\",\" ------ \");\n\t\t\t\t                    \tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.ResultFilesName\"),\n\t\t\t\t\t\t            \t\tBaseMessages.getString(PKG, \"JobCopyFiles.Log.FileAddedToResultFilesName\",fileaddentry));\r\n\t\t\t\t                    }\r\n\t\t\t\t\t            }\n\t\t\t\t\t        }\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentrystatus = true ;\n\t\t\t\t}\t\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Destination Folder or Parent folder is missing\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobCopyFiles.Error.DestinationFolderNotFound\",realDestinationFilefoldername));\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobCopyFiles.Error.SourceFileNotExists\",realSourceFilefoldername));\t\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) \n\t\t{\n\t\t\tlog.logError(\"Error\", BaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CopyProcess\",realSourceFilefoldername.toString(),destinationfilefolder.toString(), e.getMessage()), e);\t\t\t\t\t\n\t\t}\n\t\tfinally \n\t\t{\n\t\t\tif ( sourcefilefolder != null )\n\t\t\t{\n\t\t\t\ttry  \n\t\t\t\t{\n\t\t\t\t\tsourcefilefolder.close();\n\t\t\t\t\tsourcefilefolder=null;\n\t\t\t\t}\n\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t}\n\t\t\tif ( destinationfilefolder != null )\n\t\t\t{\n\t\t\t\ttry  \n\t\t\t\t{\n\t\t\t\t\tdestinationfilefolder.close();\n\t\t\t\t\tdestinationfilefolder=null;\n\t\t\t\t}\n\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t}\n\t\t}\n\n\t\treturn entrystatus;\n\t}","id":74192,"modified_method":"private boolean ProcessFileFolder(String sourcefilefoldername,String destinationfilefoldername,String wildcard,Job parentJob,Result result)\n\t{\n\t\tboolean entrystatus = false ;\n\t\tFileObject sourcefilefolder = null;\n\t\tFileObject destinationfilefolder = null;\n\t\t\n\t\t// Clear list files to remove after copy process\n\t\t// This list is also added to result files name\n\t\tlist_files_remove.clear();\n\t\tlist_add_result.clear();\n\t\t\n\t\t\n\t\t// Get real source, destination file and wildcard\n\t\tString realSourceFilefoldername = environmentSubstitute(sourcefilefoldername);\n\t\tString realDestinationFilefoldername = environmentSubstitute(destinationfilefoldername);\n\t\tString realWildcard=environmentSubstitute(wildcard);\n\n\t\ttry\n\t\t{\n\t\t\tsourcefilefolder = KettleVFS.getFileObject(realSourceFilefoldername, this);\n\t\t\tdestinationfilefolder = KettleVFS.getFileObject(realDestinationFilefoldername, this);\n\t\t\t\n\t\t\tif (sourcefilefolder.exists())\n\t\t\t{\n\t\t\t\n\t\t\t\t// Check if destination folder/parent folder exists !\n\t\t\t\t// If user wanted and if destination folder does not exist\n\t\t\t\t// PDI will create it\n\t\t\t\tif(CreateDestinationFolder(destinationfilefolder))\n\t\t\t\t{\n\n\t\t\t\t\t// Basic Tests\n\t\t\t\t\tif (sourcefilefolder.getType().equals(FileType.FOLDER) && destination_is_a_file)//destinationfilefolder.getType().equals(FileType.FILE))\n\t\t\t\t\t{\n\t\t\t\t\t\t// Source is a folder, destination is a file\n\t\t\t\t\t\t// WARNING !!! CAN NOT COPY FOLDER TO FILE !!!\n\t\t\t\t\t\t\n\t\t\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"JobCopyFiles.Log.Forbidden\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.CanNotCopyFolderToFile\",realSourceFilefoldername,realDestinationFilefoldername));\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tNbrFail++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (destinationfilefolder.getType().equals(FileType.FOLDER) && sourcefilefolder.getType().equals(FileType.FILE) )\n\t\t\t\t\t\t{\t\t\t\t\n\t\t\t\t\t\t\t// Source is a file, destination is a folder\n\t\t\t\t\t\t\t// Copy the file to the destination folder\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdestinationfilefolder.copyFrom(sourcefilefolder.getParent(),new TextOneFileSelector(sourcefilefolder.getParent().toString(),sourcefilefolder.getName().getBaseName(),destinationfilefolder.toString() ) );\n\t\t\t\t\t\t\tif(log.isDetailed())\t\n\t\t\t\t\t\t\t\tlog.logDetailed(BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopiedInfos\"), \n\t\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopied\",sourcefilefolder.getName().toString(),destinationfilefolder.getName().toString()));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (sourcefilefolder.getType().equals(FileType.FILE) && destination_is_a_file)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Source is a file, destination is a file\n\n\t\t\t\t\t\t\tdestinationfilefolder.copyFrom(sourcefilefolder, new TextOneToOneFileSelector(destinationfilefolder));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Both source and destination are folders\n\t\t\t\t\t\t\tif(log.isDetailed()) \r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlog.logDetailed(\"\",\"  \");\r\n\t\t\t\t\t\t\t\tlogDetailed(BaseMessages.getString(PKG, \"JobCopyFiles.Log.FetchFolder\",sourcefilefolder.toString()));\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tTextFileSelector textFileSelector = new TextFileSelector(sourcefilefolder,destinationfilefolder,realWildcard,parentJob);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tdestinationfilefolder.copyFrom(sourcefilefolder, textFileSelector);\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\ttextFileSelector.shutdown();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Remove Files if needed\n\t\t\t\t\t\tif (remove_source_files && !list_files_remove.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  String sourceFilefoldername = sourcefilefolder.toString();\n\t\t\t\t\t\t  int trimPathLength = sourceFilefoldername.length() + 1; \n              FileObject removeFile;\n\t\t\t\t\t\t  \n\t\t\t\t\t\t\t for (Iterator<String> iter = list_files_remove.iterator(); iter.hasNext() && !parentJob.isStopped();)\n\t\t\t\t\t        {\n\t\t\t\t\t            String fileremoventry = (String) iter.next();\n                      removeFile = null; // re=null each iteration\r\n\t\t\t\t\t            // Try to get the file relative to the existing connection\n\t\t\t\t\t            if(fileremoventry.startsWith(sourceFilefoldername)) {\n\t\t\t\t\t              if(trimPathLength < fileremoventry.length()) {\n\t\t\t\t\t                removeFile = sourcefilefolder.getChild(fileremoventry.substring(trimPathLength));\n\t\t\t\t\t              }\n\t\t\t\t\t            }\n\n\t\t\t\t\t            // Unable to retrieve file through existing connection; Get the file through a new VFS connection\n\t\t\t\t\t            if(removeFile == null) {\n\t\t\t\t\t              removeFile = KettleVFS.getFileObject(fileremoventry, this);\n\t\t\t\t\t            }\n\t\t\t\t\t            \n\t\t\t\t\t            // Remove ONLY Files\n\t\t\t\t\t            if (removeFile.getType() == FileType.FILE)\n\t\t\t\t\t            {\n\t\t\t\t\t\t            boolean deletefile=removeFile.delete();\n\t\t\t\t\t\t            log.logBasic(\" ------ \");\n\t\t\t\t\t\t            if (!deletefile)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tlog.logError(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.Error\"), \n\t\t\t\t\t\t\t\t\t\t\t\tBaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CanRemoveFileFolder\",fileremoventry));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t            else\n\t\t\t\t\t\t            {\n\t\t\t\t\t\t            \tif(log.isDetailed())\n\t\t\t\t\t\t            \t\tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileFolderRemovedInfos\"), \n\t\t\t\t\t\t            \t\t\tBaseMessages.getString(PKG, \"JobCopyFiles.Log.FileFolderRemoved\", fileremoventry));\n\t\t\t\t\t\t            }\n\t\t\t\t\t            }\n\t\t\t\t\t        }\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Add files to result files name\n\t\t\t\t\t\tif (add_result_filesname && !list_add_result.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  String destinationFilefoldername = destinationfilefolder.toString();\n\t\t\t\t\t\t  int trimPathLength = destinationFilefoldername.length() + 1;\n              FileObject addFile;\n\t\t\t\t\t\t  \n\t\t\t\t\t\t\t for (Iterator<String> iter = list_add_result.iterator(); iter.hasNext();)\n\t\t\t\t\t        {\n\t\t\t\t\t            String fileaddentry = (String) iter.next();\n                      addFile = null; // re=null each iteration\r\n\t\t\t\t\t            \n                      // Try to get the file relative to the existing connection\n                      if(fileaddentry.startsWith(destinationFilefoldername)) {\n                        if(trimPathLength < fileaddentry.length()) {\n                          addFile = destinationfilefolder.getChild(fileaddentry.substring(trimPathLength));\n                        }\n                      }\n\n                      // Unable to retrieve file through existing connection; Get the file through a new VFS connection\n                      if(addFile == null) {\n                        addFile = KettleVFS.getFileObject(fileaddentry, this);\n                      }\n\t\t\t\t\t            \n\t\t\t\t\t            // Add ONLY Files\n\t\t\t\t\t            if (addFile.getType() == FileType.FILE)\n\t\t\t\t\t            { \n\t\t\t\t                \tResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, addFile, parentJob.getJobname(), toString());\n\t\t\t\t                    result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\n\t\t\t\t                    if(log.isDetailed())\r\n\t\t\t\t                    {\n\t\t\t\t                    \tlog.logDetailed(\"\",\" ------ \");\n\t\t\t\t                    \tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.ResultFilesName\"),\n\t\t\t\t\t\t            \t\tBaseMessages.getString(PKG, \"JobCopyFiles.Log.FileAddedToResultFilesName\",fileaddentry));\r\n\t\t\t\t                    }\r\n\t\t\t\t\t            }\n\t\t\t\t\t        }\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentrystatus = true ;\n\t\t\t\t}\t\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Destination Folder or Parent folder is missing\n\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobCopyFiles.Error.DestinationFolderNotFound\",realDestinationFilefoldername));\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobCopyFiles.Error.SourceFileNotExists\",realSourceFilefoldername));\t\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) \n\t\t{\n\t\t\tlog.logError(\"Error\", BaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CopyProcess\",realSourceFilefoldername.toString(),destinationfilefolder.toString(), e.getMessage()), e);\t\t\t\t\t\n\t\t}\n\t\tfinally \n\t\t{\n\t\t\tif ( sourcefilefolder != null )\n\t\t\t{\n\t\t\t\ttry  \n\t\t\t\t{\n\t\t\t\t\tsourcefilefolder.close();\n\t\t\t\t\tsourcefilefolder=null;\n\t\t\t\t}\n\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t}\n\t\t\tif ( destinationfilefolder != null )\n\t\t\t{\n\t\t\t\ttry  \n\t\t\t\t{\n\t\t\t\t\tdestinationfilefolder.close();\n\t\t\t\t\tdestinationfilefolder=null;\n\t\t\t\t}\n\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t}\n\t\t}\n\n\t\treturn entrystatus;\n\t}","commit_id":"9e1b7ea73fabeb2884159a6c0331dec8a2389f67","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean includeFile(FileSelectInfo info) \n\t\t{\n\t\t\tboolean returncode=false;\n\t\t\tFileObject file_name=null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (!info.getFile().toString().equals(source_folder) && !parentjob.isStopped())\n\t\t\t\t{\n\t\t\t\t\t// Pass over the Base folder itself\n\t\t\t\t\t\n\t\t\t\t\tString short_filename_from_basefolder=info.getFile().getName().toString().substring(source_folder.length(),info.getFile().getName().toString().length());\n\t\t\t\t\tString short_filename= info.getFile().getName().getBaseName();\n\t\t\t\t\t// Built destination filename\n\t\t\t\t\tfile_name=KettleVFS.getFileObject(destination_folder + Const.FILE_SEPARATOR + short_filename_from_basefolder, JobEntryCopyFiles.this);//source_folder + Const.FILE_SEPARATOR + info.getFile().getName().getBaseName()); \n\t\t\t\t\t\n\t\t\t\t\tif (!info.getFile().getParent().equals(info.getBaseFolder()))\n\t\t\t\t\t {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Not in the Base Folder..Only if include sub folders  \n\t\t\t\t\t\t if (include_subfolders)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t// Folders..only if include subfolders\n\t\t\t\t\t\t\t if (info.getFile().getType() == FileType.FOLDER)\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t if (include_subfolders && copy_empty_folders && Const.isEmpty(file_wildcard))\n\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t if (!file_name.exists())\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopiedInfos\"),  BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopied\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\treturncode= true;\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t \tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t\t\t if (overwrite_files)\n\t\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwriteInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwrite\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t } \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\tif (GetFileWildcard(short_filename,file_wildcard))\n\t\t\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\t\t\t// Check if the file exists\n\t\t\t\t\t\t\t\t\t if (!file_name.exists())\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopiedInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopied\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturncode= true;\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t } \r\n\t\t\t\t\t\t\t\t\t\tif (overwrite_files)\n\t\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\"       \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t// In the Base Folder...\n\t\t\t\t\t\t// Folders..only if include subfolders\n\t\t\t\t\t\t if (info.getFile().getType() == FileType.FOLDER)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t if (include_subfolders && copy_empty_folders  && Const.isEmpty(file_wildcard))\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t if (!file_name.exists())\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopiedInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopied\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t if (overwrite_files)\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwriteInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwrite\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t }\n\t\t\t\t\t\t else\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t // file...Check if exists\n\t\t\t\t\t\t\t if (GetFileWildcard(short_filename,file_wildcard))\n\t\t\t\t\t\t\t {\t\n\t\t\t\t\t\t\t\t if (!file_name.exists())\n\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopiedInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopied\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t }\t\n\t\t\t\t\t\t\t\t\t returncode= true;\n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t if (overwrite_files)\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t } \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t }\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t\n\t\t\t\t\t }\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcatch (Exception e) \n\t\t\t{\n\t\t\t\t\n\n\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CopyProcessError\") , BaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CopyProcess\", \n\t\t\t\t\tinfo.getFile().toString(), file_name.toString(), e.getMessage()));\n\t\t\t\t\n\t\t\t\t returncode= false;\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\tif ( file_name != null )\n\t\t\t\t{\n\t\t\t\t\ttry  \n\t\t\t\t\t{\n\t\t\t\t\t\tfile_name.close();\n\t\t\t\t\t\tfile_name=null;\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tif (returncode && remove_source_files)\n\t\t\t{\n\t\t\t\t// add this folder/file to remove files\n\t\t\t\t// This list will be fetched and all entries files\n\t\t\t\t// will be removed\n\t\t\t\tlist_files_remove.add(info.getFile().toString());\n\t\t\t}\n\t\t\t\n\t\t\tif (returncode && add_result_filesname)\n\t\t\t{\n\t\t\t\t// add this folder/file to result files name\n\t\t\t\tlist_add_result.add(file_name.toString());\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn returncode;\n\t\t}","id":74193,"modified_method":"public boolean includeFile(FileSelectInfo info) \n\t\t{\n\t\t\tboolean returncode=false;\n\t\t\tFileObject file_name=null;\n\t\t\tString addFileNameString = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif (!info.getFile().toString().equals(source_folder) && !parentjob.isStopped())\n\t\t\t\t{\n\t\t\t\t\t// Pass over the Base folder itself\n\t\t\t\t\t\n\t\t\t\t\tString short_filename= info.getFile().getName().getBaseName();\n\t\t\t\t\t// Built destination filename\n\t\t\t\t\tif(destinationFolderObject == null) {\n\t\t\t\t\t  // Resolve the destination folder\n\t\t\t\t\t  destinationFolderObject=KettleVFS.getFileObject(destination_folder, JobEntryCopyFiles.this);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfile_name = destinationFolderObject.getChild(short_filename);\n\n\t\t\t\t\t\n\t\t\t\t\tif (!info.getFile().getParent().equals(info.getBaseFolder()))\n\t\t\t\t\t {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Not in the Base Folder..Only if include sub folders  \n\t\t\t\t\t\t if (include_subfolders)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t// Folders..only if include subfolders\n\t\t\t\t\t\t\t if (info.getFile().getType() == FileType.FOLDER)\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t if (include_subfolders && copy_empty_folders && Const.isEmpty(file_wildcard))\n\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t if ((file_name == null) || (!file_name.exists()))\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopiedInfos\"),  BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopied\",info.getFile().toString(),file_name != null ? file_name.toString():\"\"));\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\treturncode= true;\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t \tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t }\r\n\t\t\t\t\t\t\t\t\t\t if (overwrite_files)\n\t\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwriteInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwrite\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t } \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\tif (GetFileWildcard(short_filename))\n\t\t\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\t\t\t// Check if the file exists\n\t\t\t\t\t\t\t\t\t if ((file_name == null) || (!file_name.exists()))\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\tif(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopiedInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopied\",info.getFile().toString(),file_name != null ? file_name.toString():\"\"));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturncode= true;\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\" ------ \");\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t } \r\n\t\t\t\t\t\t\t\t\t\tif (overwrite_files)\n\t\t\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t\t\tif(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t\tlog.logDetailed(\"       \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t {\n\t\t\t\t\t\t// In the Base Folder...\n\t\t\t\t\t\t// Folders..only if include subfolders\n\t\t\t\t\t\t if (info.getFile().getType() == FileType.FOLDER)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t if (include_subfolders && copy_empty_folders  && Const.isEmpty(file_wildcard))\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t if ((file_name == null) || (!file_name.exists()))\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopiedInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderCopied\",info.getFile().toString(),file_name != null ? file_name.toString():\"\"));\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t {\r\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t if (overwrite_files)\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwriteInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FolderOverwrite\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t }\n\t\t\t\t\t\t else\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\t // file...Check if exists\n\t\t\t\t\t\t\t if (GetFileWildcard(short_filename))\n\t\t\t\t\t\t\t {\t\n\t\t\t\t\t\t\t\t if ((file_name == null) || (!file_name.exists()))\n\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopiedInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileCopied\",info.getFile().toString(),file_name != null ? file_name.toString():\"\"));\n\t\t\t\t\t\t\t\t\t }\t\n\t\t\t\t\t\t\t\t\t returncode= true;\n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t if(log.isDetailed())\r\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"\",\" ------ \");\n\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"), BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",file_name.toString()));\n\t\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t\t if (overwrite_files)\n\t\t\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t\t if(log.isDetailed())\n\t\t\t\t\t\t\t\t\t\t\t log.logDetailed(\"      \" + BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExistsInfos\"),BaseMessages.getString(PKG, \"JobCopyFiles.Log.FileExists\",info.getFile().toString(),file_name.toString()));\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t returncode= true; \n\t\t\t\t\t\t\t\t\t } \n\t\t\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t }\n\t\t\t\t\t\t }\n\t\t\t\t\t\t \n\t\t\t\t\t\t \n\t\t\t\t\t\t\n\t\t\t\t\t }\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tcatch (Exception e) \n\t\t\t{\n\t\t\t\t\n\n\t\t\t\tlog.logError(BaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CopyProcessError\") , BaseMessages.getString(PKG, \"JobCopyFiles.Error.Exception.CopyProcess\", \n\t\t\t\t\tinfo.getFile().toString(), file_name.toString(), e.getMessage()));\n\t\t\t\t\n\t\t\t\t returncode= false;\n\t\t\t}\n\t\t\tfinally \n\t\t\t{\n\t\t\t\tif ( file_name != null )\n\t\t\t\t{\n\t\t\t\t\ttry  \n\t\t\t\t\t{\n\t\t\t\t\t  if (returncode && add_result_filesname) {\n\t\t\t\t\t    addFileNameString = file_name.toString();\n\t\t\t\t\t  }\n\t\t\t\t\t\tfile_name.close();\n\t\t\t\t\t\tfile_name=null;\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( IOException ex ) {};\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\tif (returncode && remove_source_files)\n\t\t\t{\n\t\t\t\t// add this folder/file to remove files\n\t\t\t\t// This list will be fetched and all entries files\n\t\t\t\t// will be removed\n\t\t\t\tlist_files_remove.add(info.getFile().toString());\n\t\t\t}\n\t\t\t\n\t\t\tif (returncode && add_result_filesname)\n\t\t\t{\n\t\t\t\t// add this folder/file to result files name\n\t\t\t\tlist_add_result.add(addFileNameString); // was a NPE before with the file_name=null above in the finally\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\treturn returncode;\n\t\t}","commit_id":"9e1b7ea73fabeb2884159a6c0331dec8a2389f67","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public TextFileSelector(String sourcefolderin,String destinationfolderin,String filewildcard, Job parentJob) \n\t\t {\n\t\t\t\n\t\t\t if ( !Const.isEmpty(sourcefolderin))\n\t\t\t {\n\t\t\t\t source_folder=sourcefolderin;\n\t\t\t }\n\t\t\t if ( !Const.isEmpty(destinationfolderin))\n\t\t\t {\n\t\t\t\t destination_folder=destinationfolderin;\n\t\t\t }\n\t\t\t if ( !Const.isEmpty(filewildcard))\n\t\t\t {\n\t\t\t\t file_wildcard=filewildcard;\n\t\t\t }\r\n\t\t\t parentjob=parentJob;\n\t\t }","id":74194,"modified_method":"public TextFileSelector(FileObject sourcefolderin,FileObject destinationfolderin,String filewildcard, Job parentJob) \n\t\t {\n\t\t\t\n\t\t\t if ( sourcefolderin != null)\n\t\t\t {\n\t\t\t\t source_folder=sourcefolderin.toString();\n\t\t\t }\n\t\t\t if ( destinationfolderin != null)\n\t\t\t {\n\t\t\t   destinationFolderObject = destinationfolderin;\n\t\t\t\t destination_folder=destinationFolderObject.toString();\n\t\t\t }\n\t\t\t if ( !Const.isEmpty(filewildcard))\n\t\t\t {\n\t\t\t\t file_wildcard=filewildcard;\n\t\t\t\t pattern = Pattern.compile(file_wildcard);\n\t\t\t }\r\n\t\t\t parentjob=parentJob;\n\t\t }","commit_id":"9e1b7ea73fabeb2884159a6c0331dec8a2389f67","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean traverseDescendents(FileSelectInfo info) \n\t\t{\n\t\t\treturn true;\n\t\t}","id":74195,"modified_method":"public boolean traverseDescendents(FileSelectInfo info) \n\t\t{\n\t\t\treturn (traverseCount++ == 0 || include_subfolders);\n\t\t}","commit_id":"9e1b7ea73fabeb2884159a6c0331dec8a2389f67","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean traverseDescendents(FileSelectInfo info) \n\t\t{\n\t\t\treturn true;\n\t\t}","id":74196,"modified_method":"public boolean traverseDescendents(FileSelectInfo info) \n\t\t{\n\t\t\treturn (traverseCount++ == 0 || include_subfolders);\n\t\t}","commit_id":"9e1b7ea73fabeb2884159a6c0331dec8a2389f67","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public Result execute(Result previousResult, int nr)\n\t{\n\t\tResult result = previousResult;\n\t\tresult.setNrErrors(1);\n\t\tresult.setResult(false);\n\t\tString realdestinationFolder=environmentSubstitute(getDestinationFolder());\n\t\t\n\t\tif(!CreateDestinationFolder(realdestinationFolder))\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\t\t\n\t\t\n\t\tif(previousResult!=null)\n\t\t{\n\t\t\tNrErrors=0;\n\t\t\tlimitFiles=Const.toInt(environmentSubstitute(getNrErrorsLessThan()),10);\n\t\t\tNrErrors=0;\n\t\t\tNrSuccess=0;\n\t\t\tsuccessConditionBroken=false;\n\t\t\tsuccessConditionBrokenExit=false;\n\t\t\t\n\t\t\tFileObject file = null;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint size=result.getResultFiles().size();\n\t\t\t\tif(log.isBasic()) logBasic(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.log.FilesFound\",\"\"+size));\n\n\t\t\t\tList <ResultFile> resultFiles = result.getResultFilesList();\n\t\t\t    if (resultFiles != null && resultFiles.size() > 0)\n\t\t\t    {\n\t\t\t      \tfor (Iterator <ResultFile>  it = resultFiles.iterator() ; it.hasNext() && !parentJob.isStopped();)\n\t\t\t        {\n\t\t\t      \t\tif(successConditionBroken)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.Error.SuccessConditionbroken\",\"\"+NrErrors));\n\t\t\t\t\t\t\tthrow new Exception(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.Error.SuccessConditionbroken\",\"\"+NrErrors));\t\n\t\t\t\t\t\t}\n\t\t\t      \t\t\n\t\t\t       \t  ResultFile resultFile = (ResultFile) it.next();\n\t\t\t          file = resultFile.getFile();\n\t\t\t          if (file != null && file.exists())\n\t\t\t          {\n\t\t\t           \tif(!specifywildcard || \n\t\t\t           \t\t\t(CheckFileWildcard(file.getName().getBaseName(), environmentSubstitute(wildcard),true) \n\t\t\t           \t\t\t&& !CheckFileWildcard(file.getName().getBaseName(),  environmentSubstitute(wildcardexclude),false)\n\t\t\t           \t\t\t&&specifywildcard))\n\t\t\t  \t\t\t{\n\t\t\t        \t\t// Copy or Move file\n\t\t\t\t\t\t\tif(!processFile(file,realdestinationFolder,result,parentJob))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Update Errors\n\t\t\t\t\t\t\t\tupdateErrors();\n\t\t\t\t\t\t\t}\n\t\t\t           \t}  \n\t\t\t           \t \n\t\t\t           }else\n\t\t\t           {\n\t\t\t        \t   logError(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.log.ErrorCanNotFindFile\",file.toString()));  \n\t\t\t\t\t\t   // Update Errors\n\t\t\t\t\t\t   updateErrors();\n\t\t\t           }\n\t\t\t         }// end for\n\t\t\t     }     \n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.Error\",e.toString()));\n\t\t\t}\t\n\t\t\tfinally \n\t\t\t{\n\t\t\t\tif ( file != null )\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfile.close();\n\t\t\t\t\t\tfile=null;\n\t\t\t\t\t}catch ( Exception ex ) {};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Success Condition\n\t\tresult.setNrErrors(NrErrors);\n\t\tresult.setNrLinesWritten(NrSuccess);\n\t\tif(getSuccessStatus())\tresult.setResult(true);\n\t\t\n\t\treturn result;\n\t}","id":74197,"modified_method":"public Result execute(Result previousResult, int nr)\n\t{\n\t\tResult result = previousResult;\n\t\tresult.setNrErrors(1);\n\t\tresult.setResult(false);\n\t\tString realdestinationFolder=environmentSubstitute(getDestinationFolder());\n    if (!Const.isEmpty(wildcard)){\n      wildcardPattern = Pattern.compile(environmentSubstitute(wildcard));\n    }\n    if (!Const.isEmpty(wildcardexclude)) {\n      wildcardExcludePattern = Pattern.compile(environmentSubstitute(wildcardexclude));\n    }\n\t\t\n\t\tif(!CreateDestinationFolder(realdestinationFolder))\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t\t\t\n\t\t\n\t\tif(previousResult!=null)\n\t\t{\n\t\t\tNrErrors=0;\n\t\t\tlimitFiles=Const.toInt(environmentSubstitute(getNrErrorsLessThan()),10);\n\t\t\tNrErrors=0;\n\t\t\tNrSuccess=0;\n\t\t\tsuccessConditionBroken=false;\n\t\t\tsuccessConditionBrokenExit=false;\n\t\t\t\n\t\t\tFileObject file = null;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint size=result.getResultFiles().size();\n\t\t\t\tif(log.isBasic()) logBasic(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.log.FilesFound\",\"\"+size));\n\n\t\t\t\tList <ResultFile> resultFiles = result.getResultFilesList();\n\t\t\t    if (resultFiles != null && resultFiles.size() > 0)\n\t\t\t    {\n\t\t\t      \tfor (Iterator <ResultFile>  it = resultFiles.iterator() ; it.hasNext() && !parentJob.isStopped();)\n\t\t\t        {\n\t\t\t      \t\tif(successConditionBroken)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.Error.SuccessConditionbroken\",\"\"+NrErrors));\n\t\t\t\t\t\t\tthrow new Exception(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.Error.SuccessConditionbroken\",\"\"+NrErrors));\t\n\t\t\t\t\t\t}\n\t\t\t      \t\t\n\t\t\t       \t  ResultFile resultFile = (ResultFile) it.next();\n\t\t\t          file = resultFile.getFile();\n\t\t\t          if (file != null && file.exists())\n\t\t\t          {\n\t\t\t           \tif(!specifywildcard || \n\t\t\t           \t\t\t(CheckFileWildcard(file.getName().getBaseName(), wildcardPattern,true) \n\t\t\t           \t\t\t&& !CheckFileWildcard(file.getName().getBaseName(),  wildcardExcludePattern,false)\n\t\t\t           \t\t\t&&specifywildcard))\n\t\t\t  \t\t\t{\n\t\t\t        \t\t// Copy or Move file\n\t\t\t\t\t\t\tif(!processFile(file,realdestinationFolder,result,parentJob))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Update Errors\n\t\t\t\t\t\t\t\tupdateErrors();\n\t\t\t\t\t\t\t}\n\t\t\t           \t}  \n\t\t\t           \t \n\t\t\t           }else\n\t\t\t           {\n\t\t\t        \t   logError(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.log.ErrorCanNotFindFile\",file.toString()));  \n\t\t\t\t\t\t   // Update Errors\n\t\t\t\t\t\t   updateErrors();\n\t\t\t           }\n\t\t\t         }// end for\n\t\t\t     }     \n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tlogError(BaseMessages.getString(PKG, \"JobEntryCopyMoveResultFilenames.Error\",e.toString()));\n\t\t\t}\t\n\t\t\tfinally \n\t\t\t{\n\t\t\t\tif ( file != null )\n\t\t\t\t{\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfile.close();\n\t\t\t\t\t\tfile=null;\n\t\t\t\t\t}catch ( Exception ex ) {};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Success Condition\n\t\tresult.setNrErrors(NrErrors);\n\t\tresult.setNrLinesWritten(NrSuccess);\n\t\tif(getSuccessStatus())\tresult.setResult(true);\n\t\t\n\t\treturn result;\n\t}","commit_id":"9e1b7ea73fabeb2884159a6c0331dec8a2389f67","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**********************************************************\n\t * \n\t * @param selectedfile\n\t * @param wildcard\n\t * @return True if the selectedfile matches the wildcard\n\t **********************************************************/\n\tprivate boolean CheckFileWildcard(String selectedfile, String wildcard,boolean include)\n\t{\n\t\tPattern pattern = null;\n\t\tboolean getIt=include;\n\t\n        if (!Const.isEmpty(wildcard))\n        {\n        \t pattern = Pattern.compile(wildcard);\n\t\t\t// First see if the file matches the regular expression!\n\t\t\tif (pattern!=null)\n\t\t\t{\n\t\t\t\tMatcher matcher = pattern.matcher(selectedfile);\n\t\t\t\tgetIt = matcher.matches();\n\t\t\t}\n        }\n\t\t\n\t\treturn getIt;\n\t}","id":74198,"modified_method":"/**********************************************************\n\t * \n\t * @param selectedfile\n\t * @param wildcard\n\t * @return True if the selectedfile matches the wildcard\n\t **********************************************************/\n\tprivate boolean CheckFileWildcard(String selectedfile, Pattern pattern, boolean include)\n\t{\n\t\tboolean getIt=include;\n\t\tif (pattern != null) {\n\t\t\t\tMatcher matcher = pattern.matcher(selectedfile);\n\t\t\t\tgetIt = matcher.matches();\n\t\t\t}\n\t\treturn getIt;\n\t}","commit_id":"9e1b7ea73fabeb2884159a6c0331dec8a2389f67","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean processRowFile(Job parentJob, Result result, String realZipfilename, String realWildcard, String realWildcardExclude,\r\n      String realSourceDirectoryOrFile, String realMovetodirectory, boolean createparentfolder) {\r\n    boolean Fileexists = false;\r\n    File tempFile = null;\r\n    File fileZip = null;\r\n    boolean resultat = false;\r\n    boolean renameOk = false;\r\n    boolean orginExist = false;\r\n\r\n    // Check if target file/folder exists!\r\n    FileObject originFile = null;\r\n    ZipInputStream zin = null;\r\n    byte[] buffer = null;\r\n    OutputStream dest = null;\r\n    BufferedOutputStream buff = null;\r\n    ZipOutputStream out = null;\r\n    ZipEntry entry = null;\r\n    String localSourceFilename = realSourceDirectoryOrFile;\r\n\r\n    try {\r\n      originFile = KettleVFS.getFileObject(realSourceDirectoryOrFile, this);\r\n      localSourceFilename = KettleVFS.getFilename(originFile);\r\n      orginExist = originFile.exists();\r\n    } catch (Exception e) {\r\n    } finally {\r\n      if (originFile != null) {\r\n        try {\r\n          originFile.close();\r\n        } catch (IOException ex) {\r\n        }\r\n        ;\r\n      }\r\n    }\r\n\r\n    String localrealZipfilename = realZipfilename;\r\n    if (realZipfilename != null && orginExist) {\r\n\r\n      FileObject fileObject = null;\r\n      try {\r\n        fileObject = KettleVFS.getFileObject(localrealZipfilename, this);\r\n        localrealZipfilename = KettleVFS.getFilename(fileObject);\r\n        // Check if Zip File exists\r\n        if (fileObject.exists()) {\r\n          Fileexists = true;\r\n          if (log.isDebug())\r\n            logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileExists1.Label\") + localrealZipfilename\r\n                + BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileExists2.Label\"));\r\n        }\r\n        // Let's see if we need to create parent folder of destination zip filename\r\n        if (createparentfolder) {\r\n          createParentFolder(localrealZipfilename);\r\n        }\r\n\r\n        // Let's start the process now\r\n        if (ifzipfileexists == 3 && Fileexists) {\r\n          // the zip file exists and user want to Fail\r\n          resultat = false;\r\n        } else if (ifzipfileexists == 2 && Fileexists) {\r\n          // the zip file exists and user want to do nothing\r\n          if (addfiletoresult) {\r\n            // Add file to result files name\r\n            ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, fileObject, parentJob.getJobname(), toString());\r\n            result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n          }\r\n          resultat = true;\r\n        } else if (afterzip == 2 && realMovetodirectory == null) {\r\n          // After Zip, Move files..User must give a destination Folder\r\n          resultat = false;\r\n          logError(BaseMessages.getString(PKG, \"JobZipFiles.AfterZip_No_DestinationFolder_Defined.Label\"));\r\n        } else\r\n        // After Zip, Move files..User must give a destination Folder\r\n        {\r\n          // Let's see if we deal with file or folder\r\n          FileObject[] fileList =null;\r\n          \r\n          FileObject sourceFileOrFolder = KettleVFS.getFileObject(localSourceFilename);\r\n          boolean isSourceDirectory = sourceFileOrFolder.getType().equals(FileType.FOLDER);\r\n          final Pattern pattern;\r\n          final Pattern patternexclude;\r\n\r\n          if (isSourceDirectory) {\r\n            // Let's prepare the pattern matcher for performance reasons.\r\n            // We only do this if the target is a folder !\r\n            //\r\n            if (!Const.isEmpty(realWildcard)) pattern = Pattern.compile(realWildcard); else pattern=null;\r\n            if (!Const.isEmpty(realWildcardExclude)) patternexclude = Pattern.compile(realWildcardExclude); else patternexclude=null;\r\n\r\n            // Target is a directory\r\n            // Get all the files in the directory...\r\n            //\r\n            if (includingSubFolders) {\r\n              fileList = sourceFileOrFolder.findFiles(new FileSelector() {\r\n                \r\n                public boolean traverseDescendents(FileSelectInfo fileInfo) throws Exception {\r\n                  return true;\r\n                }\r\n                \r\n                public boolean includeFile(FileSelectInfo fileInfo) throws Exception {\r\n                  boolean include;\r\n                  \r\n                  // Only include files in the sub-folders...\r\n                  // When we include sub-folders we match the whole filename, not just the base-name\r\n                  //\r\n                  if (fileInfo.getFile().getType().equals(FileType.FILE)) {\r\n                    include=true;\r\n                    if (pattern!=null) {\r\n                      String name = fileInfo.getFile().getName().getPath();\r\n                      include = pattern.matcher(name).matches();\r\n                    }\r\n                    if (include && patternexclude!=null) {\r\n                      String name = fileInfo.getFile().getName().getPath();\r\n                      include = !pattern.matcher(name).matches();\r\n                    }\r\n                  } else {\r\n                    include=false;\r\n                  }\r\n                  return include;\r\n                }\r\n              });\r\n            } else {\r\n              fileList = sourceFileOrFolder.getChildren();\r\n            }\r\n          } else {\r\n            pattern=null;\r\n            patternexclude=null;\r\n            \r\n            // Target is a file\r\n            fileList = new FileObject[] { sourceFileOrFolder };\r\n          }\r\n\r\n          if (fileList.length == 0) {\r\n            resultat = false;\r\n            logError(BaseMessages.getString(PKG, \"JobZipFiles.Log.FolderIsEmpty\", localSourceFilename));\r\n          } else if (!checkContainsFile(localSourceFilename, fileList, isSourceDirectory)) {\r\n            resultat = false;\r\n            logError(BaseMessages.getString(PKG, \"JobZipFiles.Log.NoFilesInFolder\", localSourceFilename));\r\n          } else {\r\n            if (ifzipfileexists == 0 && Fileexists) {\r\n              // the zip file exists and user want to create new one with unique name\r\n              // Format Date\r\n\r\n              // do we have already a .zip at the end?\r\n              if (localrealZipfilename.toLowerCase().endsWith(\".zip\")) {\r\n                // strip this off\r\n                localrealZipfilename = localrealZipfilename.substring(0, localrealZipfilename.length() - 4);\r\n              }\r\n\r\n              localrealZipfilename += \"_\" + StringUtil.getFormattedDateTimeNow(true) + \".zip\";\r\n              if (log.isDebug())\r\n                logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileNameChange1.Label\") + localrealZipfilename\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileNameChange1.Label\"));\r\n            } else if (ifzipfileexists == 1 && Fileexists) {\r\n              // the zip file exists and user want to append\r\n              // get a temp file\r\n              fileZip = getFile(localrealZipfilename);\r\n              tempFile = File.createTempFile(fileZip.getName(), null);\r\n\r\n              // delete it, otherwise we cannot rename existing zip to it.\r\n              tempFile.delete();\r\n\r\n              renameOk = fileZip.renameTo(tempFile);\r\n\r\n              if (!renameOk) {\r\n                logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_Rename_Temp1.Label\") + fileZip.getAbsolutePath()\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Rename_Temp2.Label\") + tempFile.getAbsolutePath()\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Rename_Temp3.Label\"));\r\n              }\r\n              if (log.isDebug())\r\n                logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileAppend1.Label\") + localrealZipfilename\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileAppend2.Label\"));\r\n            }\r\n\r\n            if (log.isDetailed())\r\n              logDetailed(BaseMessages.getString(PKG, \"JobZipFiles.Files_Found1.Label\") + fileList.length\r\n                  + BaseMessages.getString(PKG, \"JobZipFiles.Files_Found2.Label\") + localSourceFilename\r\n                  + BaseMessages.getString(PKG, \"JobZipFiles.Files_Found3.Label\"));\r\n\r\n            // Prepare Zip File\r\n            buffer = new byte[18024];\r\n            dest = KettleVFS.getOutputStream(localrealZipfilename, false);\r\n            buff = new BufferedOutputStream(dest);\r\n            out = new ZipOutputStream(buff);\r\n\r\n            HashSet<String> fileSet = new HashSet<String>();\r\n\r\n            if (renameOk) {\r\n              // User want to append files to existing Zip file\r\n              // The idea is to rename the existing zip file to a temporary file\r\n              // and then adds all entries in the existing zip along with the new files,\r\n              // excluding the zip entries that have the same name as one of the new files.\r\n\r\n              zin = new ZipInputStream(new FileInputStream(tempFile));\r\n              entry = zin.getNextEntry();\r\n\r\n              while (entry != null) {\r\n                String name = entry.getName();\r\n\r\n                if (!fileSet.contains(name)) {\r\n\r\n                  // Add ZIP entry to output stream.\r\n                  out.putNextEntry(new ZipEntry(name));\r\n                  // Transfer bytes from the ZIP file to the output file\r\n                  int len;\r\n                  while ((len = zin.read(buffer)) > 0) {\r\n                    out.write(buffer, 0, len);\r\n                  }\r\n\r\n                  fileSet.add(name);\r\n                }\r\n                entry = zin.getNextEntry();\r\n              }\r\n              // Close the streams\r\n              zin.close();\r\n            }\r\n\r\n            // Set the method\r\n            out.setMethod(ZipOutputStream.DEFLATED);\r\n            // Set the compression level\r\n            if (compressionrate == 0) {\r\n              out.setLevel(Deflater.NO_COMPRESSION);\r\n            } else if (compressionrate == 1) {\r\n              out.setLevel(Deflater.DEFAULT_COMPRESSION);\r\n            }\r\n            if (compressionrate == 2) {\r\n              out.setLevel(Deflater.BEST_COMPRESSION);\r\n            }\r\n            if (compressionrate == 3) {\r\n              out.setLevel(Deflater.BEST_SPEED);\r\n            }\r\n            // Specify Zipped files (After that we will move,delete them...)\r\n            FileObject[] zippedFiles = new FileObject[fileList.length];\r\n            int fileNum = 0;\r\n\r\n            // Get the files in the list...\r\n            for (int i = 0; i < fileList.length && !parentJob.isStopped(); i++) {\r\n              boolean getIt = true;\r\n              boolean getItexclude = false;\r\n\r\n              // First see if the file matches the regular expression!\r\n              // ..only if target is a folder !\r\n              if (isSourceDirectory) {\r\n                // If we include sub-folders, we match on the whole name, not just the basename\r\n                // \r\n                String filename;\r\n                if (includingSubFolders) {\r\n                  filename = fileList[i].getName().getPath();\r\n                } else {\r\n                  filename = fileList[i].getName().getBaseName();\r\n                }\r\n                if (pattern != null) {\r\n                  // Matches the base name of the file (backward compatible!)\r\n                  //\r\n                  Matcher matcher = pattern.matcher(filename);\r\n                  getIt = matcher.matches();\r\n                }\r\n\r\n                if (patternexclude != null) {\r\n                  Matcher matcherexclude = patternexclude.matcher(filename);\r\n                  getItexclude = matcherexclude.matches();\r\n                }\r\n              }\r\n\r\n              // Get processing File\r\n              String targetFilename = KettleVFS.getFilename(fileList[i]);\r\n              if(sourceFileOrFolder.getType().equals(FileType.FILE)) {\r\n                targetFilename=localSourceFilename;\r\n              }\r\n\r\n              FileObject file = KettleVFS.getFileObject(targetFilename);\r\n              boolean isTargetDirectory = file.exists() && file.getType().equals(FileType.FOLDER);\r\n\r\n              if (getIt && !getItexclude &&  !isTargetDirectory && !fileSet.contains(targetFilename)) {\r\n                // We can add the file to the Zip Archive\r\n                if (log.isDebug())\r\n                  logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Add_FilesToZip1.Label\") + fileList[i]\r\n                      + BaseMessages.getString(PKG, \"JobZipFiles.Add_FilesToZip2.Label\") + localSourceFilename\r\n                      + BaseMessages.getString(PKG, \"JobZipFiles.Add_FilesToZip3.Label\"));\r\n\r\n                // Associate a file input stream for the current file\r\n                InputStream in = KettleVFS.getInputStream(file);\r\n\r\n                // Add ZIP entry to output stream.\r\n                //\r\n                String relativeName;\r\n                String fullName = fileList[i].getName().getPath();\r\n                String basePath = sourceFileOrFolder.getName().getPath();\r\n                if (isSourceDirectory) {\r\n                  if (fullName.startsWith(basePath)) {\r\n                    relativeName = fullName.substring(basePath.length()+1);\r\n                  } else {\r\n                    relativeName = fullName; \r\n                  }\r\n                } else {\r\n                  relativeName = fileList[i].getName().getBaseName();\r\n                }\r\n                out.putNextEntry(new ZipEntry(relativeName));\r\n\r\n                int len;\r\n                while ((len = in.read(buffer)) > 0) {\r\n                  out.write(buffer, 0, len);\r\n                }\r\n                out.flush();\r\n                out.closeEntry();\r\n\r\n                // Close the current file input stream\r\n                in.close();\r\n\r\n                // Get Zipped File\r\n                zippedFiles[fileNum] = fileList[i];\r\n                fileNum = fileNum + 1;\r\n              }\r\n            }\r\n            // Close the ZipOutPutStream\r\n            out.close();\r\n            buff.close();\r\n            dest.close();\r\n\r\n            if (log.isBasic())\r\n              logBasic(BaseMessages.getString(PKG, \"JobZipFiles.Log.TotalZippedFiles\", \"\" + zippedFiles.length));\r\n            // Delete Temp File\r\n            if (tempFile != null) {\r\n              tempFile.delete();\r\n            }\r\n\r\n            // -----Get the list of Zipped Files and Move or Delete Them\r\n            if (afterzip == 1 || afterzip == 2) {\r\n              // iterate through the array of Zipped files\r\n              for (int i = 0; i < zippedFiles.length; i++) {\r\n                if (zippedFiles[i] != null) {\r\n                  // Delete File\r\n                  FileObject fileObjectd = KettleVFS.getFileObject(localSourceFilename + Const.FILE_SEPARATOR + zippedFiles[i], this);\r\n                  if (!isSourceDirectory) {\r\n                    fileObjectd = KettleVFS.getFileObject(localSourceFilename, this);\r\n                  }\r\n\r\n                  // Here we can move, delete files\r\n                  if (afterzip == 1) {\r\n                    // Delete File\r\n                    boolean deleted = fileObjectd.delete();\r\n                    if (!deleted) {\r\n                      resultat = false;\r\n                      logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_Delete_File1.Label\") + localSourceFilename + Const.FILE_SEPARATOR + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Delete_File2.Label\"));\r\n\r\n                    }\r\n                    // File deleted\r\n                    if (log.isDebug())\r\n                      logDebug(BaseMessages.getString(PKG, \"JobZipFiles.File_Deleted1.Label\") + localSourceFilename + Const.FILE_SEPARATOR + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.File_Deleted2.Label\"));\r\n                  } else if (afterzip == 2) {\r\n                    // Move File\r\n                    try {\r\n                      FileObject fileObjectm = KettleVFS.getFileObject(realMovetodirectory + Const.FILE_SEPARATOR + zippedFiles[i], this);\r\n                      fileObjectd.moveTo(fileObjectm);\r\n                    } catch (IOException e) {\r\n                      logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_Move_File1.Label\") + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Move_File2.Label\") + e.getMessage());\r\n                      resultat = false;\r\n                    }\r\n                    // File moved\r\n                    if (log.isDebug())\r\n                      logDebug(BaseMessages.getString(PKG, \"JobZipFiles.File_Moved1.Label\") + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.File_Moved2.Label\"));\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            if (addfiletoresult) {\r\n              // Add file to result files name\r\n              ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, fileObject, parentJob.getJobname(), toString());\r\n              result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n            }\r\n\r\n            resultat = true;\r\n          }\r\n        }\r\n      } catch (Exception e) {\r\n        logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_CreateZipFile1.Label\") + localrealZipfilename\r\n            + BaseMessages.getString(PKG, \"JobZipFiles.Cant_CreateZipFile2.Label\") + e.getMessage());\r\n        resultat = false;\r\n      } finally {\r\n        if (fileObject != null) {\r\n          try {\r\n            fileObject.close();\r\n            fileObject = null;\r\n          } catch (IOException ex) {\r\n          }\r\n          ;\r\n        }\r\n\r\n        try {\r\n          if (out != null)\r\n            out.close();\r\n          if (buff != null)\r\n            buff.close();\r\n          if (dest != null)\r\n            dest.close();\r\n          if (zin != null)\r\n            zin.close();\r\n          if (entry != null)\r\n            entry = null;\r\n\r\n        } catch (IOException ex) {\r\n        }\r\n        ;\r\n      }\r\n    } else {\r\n      resultat = true;\r\n      if (localrealZipfilename == null)\r\n        logError(BaseMessages.getString(PKG, \"JobZipFiles.No_ZipFile_Defined.Label\"));\r\n      if (!orginExist)\r\n        logError(BaseMessages.getString(PKG, \"JobZipFiles.No_FolderCible_Defined.Label\", localSourceFilename));\r\n    }\r\n    // return a verifier\r\n    return resultat;\r\n  }","id":74199,"modified_method":"public boolean processRowFile(Job parentJob, Result result, String realZipfilename, String realWildcard, String realWildcardExclude,\r\n      String realSourceDirectoryOrFile, String realMovetodirectory, boolean createparentfolder) {\r\n    boolean Fileexists = false;\r\n    File tempFile = null;\r\n    File fileZip = null;\r\n    boolean resultat = false;\r\n    boolean renameOk = false;\r\n    boolean orginExist = false;\r\n\r\n    // Check if target file/folder exists!\r\n    FileObject originFile = null;\r\n    ZipInputStream zin = null;\r\n    byte[] buffer = null;\r\n    OutputStream dest = null;\r\n    BufferedOutputStream buff = null;\r\n    ZipOutputStream out = null;\r\n    ZipEntry entry = null;\r\n    String localSourceFilename = realSourceDirectoryOrFile;\r\n\r\n    try {\r\n      originFile = KettleVFS.getFileObject(realSourceDirectoryOrFile, this);\r\n      localSourceFilename = KettleVFS.getFilename(originFile);\r\n      orginExist = originFile.exists();\r\n    } catch (Exception e) {\r\n    } finally {\r\n      if (originFile != null) {\r\n        try {\r\n          originFile.close();\r\n        } catch (IOException ex) {\r\n        }\r\n        ;\r\n      }\r\n    }\r\n\r\n    String localrealZipfilename = realZipfilename;\r\n    if (realZipfilename != null && orginExist) {\r\n\r\n      FileObject fileObject = null;\r\n      try {\r\n        fileObject = KettleVFS.getFileObject(localrealZipfilename, this);\r\n        localrealZipfilename = KettleVFS.getFilename(fileObject);\r\n        // Check if Zip File exists\r\n        if (fileObject.exists()) {\r\n          Fileexists = true;\r\n          if (log.isDebug())\r\n            logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileExists1.Label\") + localrealZipfilename\r\n                + BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileExists2.Label\"));\r\n        }\r\n        // Let's see if we need to create parent folder of destination zip filename\r\n        if (createparentfolder) {\r\n          createParentFolder(localrealZipfilename);\r\n        }\r\n\r\n        // Let's start the process now\r\n        if (ifzipfileexists == 3 && Fileexists) {\r\n          // the zip file exists and user want to Fail\r\n          resultat = false;\r\n        } else if (ifzipfileexists == 2 && Fileexists) {\r\n          // the zip file exists and user want to do nothing\r\n          if (addfiletoresult) {\r\n            // Add file to result files name\r\n            ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, fileObject, parentJob.getJobname(), toString());\r\n            result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n          }\r\n          resultat = true;\r\n        } else if (afterzip == 2 && realMovetodirectory == null) {\r\n          // After Zip, Move files..User must give a destination Folder\r\n          resultat = false;\r\n          logError(BaseMessages.getString(PKG, \"JobZipFiles.AfterZip_No_DestinationFolder_Defined.Label\"));\r\n        } else\r\n        // After Zip, Move files..User must give a destination Folder\r\n        {\r\n          // Let's see if we deal with file or folder\r\n          FileObject[] fileList =null;\r\n          \r\n          FileObject sourceFileOrFolder = KettleVFS.getFileObject(localSourceFilename);\r\n          boolean isSourceDirectory = sourceFileOrFolder.getType().equals(FileType.FOLDER);\r\n          final Pattern pattern;\r\n          final Pattern patternexclude;\r\n\r\n          if (isSourceDirectory) {\r\n            // Let's prepare the pattern matcher for performance reasons.\r\n            // We only do this if the target is a folder !\r\n            //\r\n            if (!Const.isEmpty(realWildcard)) pattern = Pattern.compile(realWildcard); else pattern=null;\r\n            if (!Const.isEmpty(realWildcardExclude)) patternexclude = Pattern.compile(realWildcardExclude); else patternexclude=null;\r\n\r\n            // Target is a directory\r\n            // Get all the files in the directory...\r\n            //\r\n            if (includingSubFolders) {\r\n              fileList = sourceFileOrFolder.findFiles(new FileSelector() {\r\n                \r\n                public boolean traverseDescendents(FileSelectInfo fileInfo) throws Exception {\r\n                  return true;\r\n                }\r\n                \r\n                public boolean includeFile(FileSelectInfo fileInfo) throws Exception {\r\n                  boolean include;\r\n                  \r\n                  // Only include files in the sub-folders...\r\n                  // When we include sub-folders we match the whole filename, not just the base-name\r\n                  //\r\n                  if (fileInfo.getFile().getType().equals(FileType.FILE)) {\r\n                    include=true;\r\n                    if (pattern!=null) {\r\n                      String name = fileInfo.getFile().getName().getPath();\r\n                      include = pattern.matcher(name).matches();\r\n                    }\r\n                    if (include && patternexclude!=null) {\r\n                      String name = fileInfo.getFile().getName().getPath();\r\n                      include = !pattern.matcher(name).matches();\r\n                    }\r\n                  } else {\r\n                    include=false;\r\n                  }\r\n                  return include;\r\n                }\r\n              });\r\n            } else {\r\n              fileList = sourceFileOrFolder.getChildren();\r\n            }\r\n          } else {\r\n            pattern=null;\r\n            patternexclude=null;\r\n            \r\n            // Target is a file\r\n            fileList = new FileObject[] { sourceFileOrFolder };\r\n          }\r\n\r\n          if (fileList.length == 0) {\r\n            resultat = false;\r\n            logError(BaseMessages.getString(PKG, \"JobZipFiles.Log.FolderIsEmpty\", localSourceFilename));\r\n          } else if (!checkContainsFile(localSourceFilename, fileList, isSourceDirectory)) {\r\n            resultat = false;\r\n            logError(BaseMessages.getString(PKG, \"JobZipFiles.Log.NoFilesInFolder\", localSourceFilename));\r\n          } else {\r\n            if (ifzipfileexists == 0 && Fileexists) {\r\n              // the zip file exists and user want to create new one with unique name\r\n              // Format Date\r\n\r\n              // do we have already a .zip at the end?\r\n              if (localrealZipfilename.toLowerCase().endsWith(\".zip\")) {\r\n                // strip this off\r\n                localrealZipfilename = localrealZipfilename.substring(0, localrealZipfilename.length() - 4);\r\n              }\r\n\r\n              localrealZipfilename += \"_\" + StringUtil.getFormattedDateTimeNow(true) + \".zip\";\r\n              if (log.isDebug())\r\n                logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileNameChange1.Label\") + localrealZipfilename\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileNameChange1.Label\"));\r\n            } else if (ifzipfileexists == 1 && Fileexists) {\r\n              // the zip file exists and user want to append\r\n              // get a temp file\r\n              fileZip = getFile(localrealZipfilename);\r\n              tempFile = File.createTempFile(fileZip.getName(), null);\r\n\r\n              // delete it, otherwise we cannot rename existing zip to it.\r\n              tempFile.delete();\r\n\r\n              renameOk = fileZip.renameTo(tempFile);\r\n\r\n              if (!renameOk) {\r\n                logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_Rename_Temp1.Label\") + fileZip.getAbsolutePath()\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Rename_Temp2.Label\") + tempFile.getAbsolutePath()\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Rename_Temp3.Label\"));\r\n              }\r\n              if (log.isDebug())\r\n                logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileAppend1.Label\") + localrealZipfilename\r\n                    + BaseMessages.getString(PKG, \"JobZipFiles.Zip_FileAppend2.Label\"));\r\n            }\r\n\r\n            if (log.isDetailed())\r\n              logDetailed(BaseMessages.getString(PKG, \"JobZipFiles.Files_Found1.Label\") + fileList.length\r\n                  + BaseMessages.getString(PKG, \"JobZipFiles.Files_Found2.Label\") + localSourceFilename\r\n                  + BaseMessages.getString(PKG, \"JobZipFiles.Files_Found3.Label\"));\r\n\r\n            // Prepare Zip File\r\n            buffer = new byte[18024];\r\n            dest = KettleVFS.getOutputStream(localrealZipfilename, false);\r\n            buff = new BufferedOutputStream(dest);\r\n            out = new ZipOutputStream(buff);\r\n\r\n            HashSet<String> fileSet = new HashSet<String>();\r\n\r\n            if (renameOk) {\r\n              // User want to append files to existing Zip file\r\n              // The idea is to rename the existing zip file to a temporary file\r\n              // and then adds all entries in the existing zip along with the new files,\r\n              // excluding the zip entries that have the same name as one of the new files.\r\n\r\n              zin = new ZipInputStream(new FileInputStream(tempFile));\r\n              entry = zin.getNextEntry();\r\n\r\n              while (entry != null) {\r\n                String name = entry.getName();\r\n\r\n                if (!fileSet.contains(name)) {\r\n\r\n                  // Add ZIP entry to output stream.\r\n                  out.putNextEntry(new ZipEntry(name));\r\n                  // Transfer bytes from the ZIP file to the output file\r\n                  int len;\r\n                  while ((len = zin.read(buffer)) > 0) {\r\n                    out.write(buffer, 0, len);\r\n                  }\r\n\r\n                  fileSet.add(name);\r\n                }\r\n                entry = zin.getNextEntry();\r\n              }\r\n              // Close the streams\r\n              zin.close();\r\n            }\r\n\r\n            // Set the method\r\n            out.setMethod(ZipOutputStream.DEFLATED);\r\n            // Set the compression level\r\n            if (compressionrate == 0) {\r\n              out.setLevel(Deflater.NO_COMPRESSION);\r\n            } else if (compressionrate == 1) {\r\n              out.setLevel(Deflater.DEFAULT_COMPRESSION);\r\n            }\r\n            if (compressionrate == 2) {\r\n              out.setLevel(Deflater.BEST_COMPRESSION);\r\n            }\r\n            if (compressionrate == 3) {\r\n              out.setLevel(Deflater.BEST_SPEED);\r\n            }\r\n            // Specify Zipped files (After that we will move,delete them...)\r\n            FileObject[] zippedFiles = new FileObject[fileList.length];\r\n            int fileNum = 0;\r\n\r\n            // Get the files in the list...\r\n            for (int i = 0; i < fileList.length && !parentJob.isStopped(); i++) {\r\n              boolean getIt = true;\r\n              boolean getItexclude = false;\r\n\r\n              // First see if the file matches the regular expression!\r\n              // ..only if target is a folder !\r\n              if (isSourceDirectory) {\r\n                // If we include sub-folders, we match on the whole name, not just the basename\r\n                // \r\n                String filename;\r\n                if (includingSubFolders) {\r\n                  filename = fileList[i].getName().getPath();\r\n                } else {\r\n                  filename = fileList[i].getName().getBaseName();\r\n                }\r\n                if (pattern != null) {\r\n                  // Matches the base name of the file (backward compatible!)\r\n                  //\r\n                  Matcher matcher = pattern.matcher(filename);\r\n                  getIt = matcher.matches();\r\n                }\r\n\r\n                if (patternexclude != null) {\r\n                  Matcher matcherexclude = patternexclude.matcher(filename);\r\n                  getItexclude = matcherexclude.matches();\r\n                }\r\n              }\r\n\r\n              // Get processing File\r\n              String targetFilename = KettleVFS.getFilename(fileList[i]);\r\n              if(sourceFileOrFolder.getType().equals(FileType.FILE)) {\r\n                targetFilename=localSourceFilename;\r\n              }\r\n\r\n              FileObject file = KettleVFS.getFileObject(targetFilename);\r\n              boolean isTargetDirectory = file.exists() && file.getType().equals(FileType.FOLDER);\r\n\r\n              if (getIt && !getItexclude &&  !isTargetDirectory && !fileSet.contains(targetFilename)) {\r\n                // We can add the file to the Zip Archive\r\n                if (log.isDebug())\r\n                  logDebug(BaseMessages.getString(PKG, \"JobZipFiles.Add_FilesToZip1.Label\") + fileList[i]\r\n                      + BaseMessages.getString(PKG, \"JobZipFiles.Add_FilesToZip2.Label\") + localSourceFilename\r\n                      + BaseMessages.getString(PKG, \"JobZipFiles.Add_FilesToZip3.Label\"));\r\n\r\n                // Associate a file input stream for the current file\r\n                InputStream in = KettleVFS.getInputStream(file);\r\n\r\n                // Add ZIP entry to output stream.\r\n                //\r\n                String relativeName;\r\n                String fullName = fileList[i].getName().getPath();\r\n                String basePath = sourceFileOrFolder.getName().getPath();\r\n                if (isSourceDirectory) {\r\n                  if (fullName.startsWith(basePath)) {\r\n                    relativeName = fullName.substring(basePath.length()+1);\r\n                  } else {\r\n                    relativeName = fullName; \r\n                  }\r\n                } else {\r\n                  relativeName = fileList[i].getName().getBaseName();\r\n                }\r\n                out.putNextEntry(new ZipEntry(relativeName));\r\n\r\n                int len;\r\n                while ((len = in.read(buffer)) > 0) {\r\n                  out.write(buffer, 0, len);\r\n                }\r\n                out.flush();\r\n                out.closeEntry();\r\n\r\n                // Close the current file input stream\r\n                in.close();\r\n\r\n                // Get Zipped File\r\n                zippedFiles[fileNum] = fileList[i];\r\n                fileNum = fileNum + 1;\r\n              }\r\n            }\r\n            // Close the ZipOutPutStream\r\n            out.close();\r\n            buff.close();\r\n            dest.close();\r\n\r\n            if (log.isBasic())\r\n              logBasic(BaseMessages.getString(PKG, \"JobZipFiles.Log.TotalZippedFiles\", \"\" + zippedFiles.length));\r\n            // Delete Temp File\r\n            if (tempFile != null) {\r\n              tempFile.delete();\r\n            }\r\n\r\n            // -----Get the list of Zipped Files and Move or Delete Them\r\n            if (afterzip == 1 || afterzip == 2) {\r\n              // iterate through the array of Zipped files\r\n              for (int i = 0; i < zippedFiles.length; i++) {\r\n                if (zippedFiles[i] != null) {\r\n                 // Delete, Move File\r\n                  FileObject fileObjectd =  zippedFiles[i];\r\n                  if (!isSourceDirectory) {\r\n                    fileObjectd = KettleVFS.getFileObject(localSourceFilename);\r\n                  }\r\n\r\n                  // Here we can move, delete files\r\n                  if (afterzip == 1) {\r\n                    // Delete File\r\n                    boolean deleted = fileObjectd.delete();\r\n                    if (!deleted) {\r\n                      resultat = false;\r\n                      logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_Delete_File1.Label\") + localSourceFilename + Const.FILE_SEPARATOR + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Delete_File2.Label\"));\r\n\r\n                    }\r\n                    // File deleted\r\n                    if (log.isDebug())\r\n                      logDebug(BaseMessages.getString(PKG, \"JobZipFiles.File_Deleted1.Label\") + localSourceFilename + Const.FILE_SEPARATOR + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.File_Deleted2.Label\"));\r\n                  } else if (afterzip == 2) {\r\n                    // Move File\r\n                \t\tFileObject fileObjectm=null;\r\n                    try {\r\n                          fileObjectm = KettleVFS.getFileObject(realMovetodirectory + Const.FILE_SEPARATOR + fileObjectd.getName().getBaseName());\r\n\t                      fileObjectd.moveTo(fileObjectm);\r\n                    } catch (IOException e) {\r\n                      logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_Move_File1.Label\") + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.Cant_Move_File2.Label\") + e.getMessage());\r\n                      resultat = false;\r\n                    }finally {\r\n                    \ttry {\r\n                    \t\tif(fileObjectm!=null) {\r\n                    \t\t\tfileObjectm.close();\r\n                    \t\t}\r\n                    \t}catch(Exception e){};\r\n                    }\r\n                    // File moved\r\n                    if (log.isDebug())\r\n                      logDebug(BaseMessages.getString(PKG, \"JobZipFiles.File_Moved1.Label\") + zippedFiles[i]\r\n                          + BaseMessages.getString(PKG, \"JobZipFiles.File_Moved2.Label\"));\r\n                  }\r\n                }\r\n              }\r\n            }\r\n\r\n            if (addfiletoresult) {\r\n              // Add file to result files name\r\n              ResultFile resultFile = new ResultFile(ResultFile.FILE_TYPE_GENERAL, fileObject, parentJob.getJobname(), toString());\r\n              result.getResultFiles().put(resultFile.getFile().toString(), resultFile);\r\n            }\r\n\r\n            resultat = true;\r\n          }\r\n        }\r\n      } catch (Exception e) {\r\n        logError(BaseMessages.getString(PKG, \"JobZipFiles.Cant_CreateZipFile1.Label\") + localrealZipfilename\r\n            + BaseMessages.getString(PKG, \"JobZipFiles.Cant_CreateZipFile2.Label\") + e.getMessage());\r\n        resultat = false;\r\n      } finally {\r\n        if (fileObject != null) {\r\n          try {\r\n            fileObject.close();\r\n            fileObject = null;\r\n          } catch (IOException ex) {\r\n          }\r\n          ;\r\n        }\r\n\r\n        try {\r\n          if (out != null)\r\n            out.close();\r\n          if (buff != null)\r\n            buff.close();\r\n          if (dest != null)\r\n            dest.close();\r\n          if (zin != null)\r\n            zin.close();\r\n          if (entry != null)\r\n            entry = null;\r\n\r\n        } catch (IOException ex) {\r\n        }\r\n        ;\r\n      }\r\n    } else {\r\n      resultat = true;\r\n      if (localrealZipfilename == null)\r\n        logError(BaseMessages.getString(PKG, \"JobZipFiles.No_ZipFile_Defined.Label\"));\r\n      if (!orginExist)\r\n        logError(BaseMessages.getString(PKG, \"JobZipFiles.No_FolderCible_Defined.Label\", localSourceFilename));\r\n    }\r\n    // return a verifier\r\n    return resultat;\r\n  }","commit_id":"8a393fb06770e717d15afebf283334af246402e2","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * @return model object class\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<T> getObjectClass()\n\t{\n\t\tfinal String expression = propertyExpression();\n\t\tif (Strings.isEmpty(expression))\n\t\t{\n\t\t\t// Return a meaningful value for an empty property expression\n\t\t\tObject target = getTarget();\n\t\t\treturn (Class<T>)(target != null ? target.getClass() : null);\n\t\t}\n\n\t\tfinal Object target = getTarget();\n\t\tif (target != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn (Class<T>)PropertyResolver.getPropertyClass(expression, target);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t// ignore.\n\t\t\t}\n\t\t}\n\t\telse if (this.target instanceof IObjectClassAwareModel)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn PropertyResolver.getPropertyClass(expression,\n\t\t\t\t\t((IObjectClassAwareModel<?>)this.target).getObjectClass());\n\t\t\t}\n\t\t\tcatch (WicketRuntimeException e)\n\t\t\t{\n\t\t\t\t// it was just a try.\n\t\t\t}\n\n\t\t}\n\t\treturn null;\n\t}","id":74200,"modified_method":"/**\n\t * @return model object class\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Class<T> getObjectClass()\n\t{\n\t\tfinal String expression = propertyExpression();\n\t\tif (Strings.isEmpty(expression))\n\t\t{\n\t\t\t// Return a meaningful value for an empty property expression\n\t\t\tObject target = getTarget();\n\t\t\treturn (Class<T>)(target != null ? target.getClass() : null);\n\t\t}\n\n\t\tfinal Object target = getTarget();\n\t\tif (target != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn (Class<T>)PropertyResolver.getPropertyClass(expression, target);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t// ignore.\n\t\t\t}\n\t\t}\n\t\telse if (this.target instanceof IObjectClassAwareModel)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tClass<?> targetClass = ((IObjectClassAwareModel<?>)this.target).getObjectClass();\n\t\t\t\tif (targetClass != null)\n\t\t\t\t{\n\t\t\t\t\treturn PropertyResolver.getPropertyClass(expression, targetClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (WicketRuntimeException e)\n\t\t\t{\n\t\t\t\t// it was just a try.\n\t\t\t}\n\n\t\t}\n\t\treturn null;\n\t}","commit_id":"71b6e9058419c91999f5798f353c01f7aea84998","url":"https://github.com/apache/wicket"},{"original_method":"public ClaimCollection retrieveClaimValues(\n            RequestClaimCollection claims, ClaimsParameters parameters) {\n      \n        Principal principal = parameters.getPrincipal();\n        \n        String user = null;\n        if (principal instanceof KerberosPrincipal) {\n            KerberosPrincipal kp = (KerberosPrincipal)principal;\n            StringTokenizer st = new StringTokenizer(kp.getName(), \"@\");\n            user = st.nextToken();\n        } else if (principal instanceof X500Principal) {\n            X500Principal x500p = (X500Principal)principal;\n            LOG.warning(\"Unsupported principal type X500: \" + x500p.getName());\n            return new ClaimCollection();\n        } else if (principal != null) {\n            user = principal.getName();\n        } else {\n            //[TODO] if onbehalfof -> principal == null\n            LOG.info(\"Principal is null\");\n            return new ClaimCollection();\n        }\n        \n        if (user == null) {\n            LOG.warning(\"User must not be null\");\n            return new ClaimCollection();\n        } else {\n            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Retrieve claims for user \" + user);\n            }\n        }\n        \n        AndFilter filter = new AndFilter();\n        filter.and(\n                new EqualsFilter(\"objectclass\", this.getObjectClass())).and(\n                        new EqualsFilter(this.getUserNameAttribute(), user));\n\n        List<String> searchAttributeList = new ArrayList<String>();\n        for (RequestClaim claim : claims) {\n            if (getClaimsLdapAttributeMapping().keySet().contains(claim.getClaimType().toString())) {\n                searchAttributeList.add(\n                    getClaimsLdapAttributeMapping().get(claim.getClaimType().toString())\n                );\n            } else {\n                if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(\"Unsupported claim: \" + claim.getClaimType());\n                }\n            }\n        }\n\n        String[] searchAttributes = null;\n        searchAttributes = searchAttributeList.toArray(new String[searchAttributeList.size()]);\n\n        AttributesMapper mapper = \n            new AttributesMapper() {\n                public Object mapFromAttributes(Attributes attrs) throws NamingException {\n                    Map<String, Attribute> map = new HashMap<String, Attribute>();\n                    NamingEnumeration<? extends Attribute> attrEnum = attrs.getAll();\n                    while (attrEnum.hasMore()) {\n                        Attribute att = attrEnum.next();\n                        map.put(att.getID(), att);\n                    }\n                    return map;\n                }\n            };\n        \n        \n        List<?> result = ldap.search((this.userBaseDn == null) ? \"\" : this.userBaseDn, filter.toString(),\n                SearchControls.SUBTREE_SCOPE, searchAttributes, mapper);\n      \n        Map<String, Attribute> ldapAttributes = null;\n        if (result != null && result.size() > 0) {\n            ldapAttributes = CastUtils.cast((Map<?, ?>)result.get(0));\n        }\n        \n        ClaimCollection claimsColl = new ClaimCollection();\n\n        for (RequestClaim claim : claims) {\n            URI claimType = claim.getClaimType();\n            String ldapAttribute = getClaimsLdapAttributeMapping().get(claimType.toString());\n            Attribute attr = ldapAttributes.get(ldapAttribute);\n            if (attr == null) {\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Claim '\" + claim.getClaimType() + \"' is null\");\n                }\n            } else {\n                Claim c = new Claim();\n                c.setClaimType(claimType);\n                c.setPrincipal(principal);\n\n                StringBuilder claimValue = new StringBuilder();\n                try {\n                    NamingEnumeration<?> list = (NamingEnumeration<?>)attr.getAll();\n                    while (list.hasMore()) {\n                        Object obj = list.next();\n                        if (!(obj instanceof String)) {\n                            LOG.warning(\"LDAP attribute '\" + ldapAttribute \n                                    + \"' has got an unsupported value type\");\n                            break;\n                        }\n                        String itemValue = (String)obj;\n                        if (this.isX500FilterEnabled()) {\n                            try {\n                                X500Principal x500p = new X500Principal(itemValue);\n                                itemValue = x500p.getName();\n                                int index = itemValue.indexOf('=');\n                                itemValue = itemValue.substring(index + 1, itemValue.indexOf(',', index));\n                            } catch (Exception ex) {\n                                //Ignore, not X500 compliant thus use the whole string as the value\n                            }\n                        }\n                        claimValue.append(itemValue);\n                        if (list.hasMore()) {\n                            claimValue.append(this.getDelimiter());\n                        }\n                    }\n                } catch (NamingException ex) {\n                    LOG.warning(\"Failed to read value of LDAP attribute '\" + ldapAttribute + \"'\");\n                }\n                \n                c.addValue(claimValue.toString());\n                // c.setIssuer(issuer);\n                // c.setOriginalIssuer(originalIssuer);\n                // c.setNamespace(namespace);\n                claimsColl.add(c);\n            }\n        }\n        \n        return claimsColl;\n    }","id":74201,"modified_method":"public ClaimCollection retrieveClaimValues(\n            RequestClaimCollection claims, ClaimsParameters parameters) {\n        String user = null;\n        boolean useLdapLookup = false;\n        \n        Principal principal = parameters.getPrincipal();\n        if (principal instanceof KerberosPrincipal) {\n            KerberosPrincipal kp = (KerberosPrincipal)principal;\n            StringTokenizer st = new StringTokenizer(kp.getName(), \"@\");\n            user = st.nextToken();\n        } else if (principal instanceof X500Principal) {\n            X500Principal x500p = (X500Principal)principal;\n            LOG.warning(\"Unsupported principal type X500: \" + x500p.getName());\n            return new ClaimCollection();\n        } else if (principal != null) {\n            user = principal.getName();\n            if (user == null) {\n                LOG.warning(\"User must not be null\");\n                return new ClaimCollection();\n            }\n            useLdapLookup = LdapUtils.isDN(user);\n            \n        } else {\n            LOG.warning(\"Principal is null\");\n            return new ClaimCollection();\n        }\n       \n        if (LOG.isLoggable(Level.FINEST)) {\n            LOG.finest(\"Retrieve claims for user \" + user);\n        }\n        \n        \n\n\n        \n        Map<String, Attribute> ldapAttributes = null;\n        if (useLdapLookup) {\n            AttributesMapper mapper = \n                new AttributesMapper() {\n                    public Object mapFromAttributes(Attributes attrs) throws NamingException {\n                        Map<String, Attribute> map = new HashMap<String, Attribute>();\n                        NamingEnumeration<? extends Attribute> attrEnum = attrs.getAll();\n                        while (attrEnum.hasMore()) {\n                            Attribute att = attrEnum.next();\n                            map.put(att.getID(), att);\n                        }\n                        return map;\n                    }\n                };\n                \n            Object result = ldap.lookup(user, mapper);\n            ldapAttributes = CastUtils.cast((Map<?, ?>)result);\n        } else {\n            List<String> searchAttributeList = new ArrayList<String>();\n            for (RequestClaim claim : claims) {\n                if (getClaimsLdapAttributeMapping().keySet().contains(claim.getClaimType().toString())) {\n                    searchAttributeList.add(\n                        getClaimsLdapAttributeMapping().get(claim.getClaimType().toString())\n                    );\n                } else {\n                    if (LOG.isLoggable(Level.FINER)) {\n                        LOG.finer(\"Unsupported claim: \" + claim.getClaimType());\n                    }\n                }\n            }\n\n            String[] searchAttributes = null;\n            searchAttributes = searchAttributeList.toArray(new String[searchAttributeList.size()]);\n            \n            ldapAttributes = LdapUtils.getAttributesOfEntry(ldap, this.userBaseDn, this.getObjectClass(),\n                                                            this.getUserNameAttribute(), user, searchAttributes);\n        }\n        \n        if (ldapAttributes == null || ldapAttributes.size() == 0) {\n            //No result\n            if (LOG.isLoggable(Level.INFO)) {\n                LOG.finest(\"User '\" + user + \"' not found\");\n            }\n            return new ClaimCollection();\n        }\n        \n        ClaimCollection claimsColl = new ClaimCollection();\n\n        for (RequestClaim claim : claims) {\n            URI claimType = claim.getClaimType();\n            String ldapAttribute = getClaimsLdapAttributeMapping().get(claimType.toString());\n            Attribute attr = ldapAttributes.get(ldapAttribute);\n            if (attr == null) {\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Claim '\" + claim.getClaimType() + \"' is null\");\n                }\n            } else {\n                Claim c = new Claim();\n                c.setClaimType(claimType);\n                c.setPrincipal(principal);\n\n                StringBuilder claimValue = new StringBuilder();\n                try {\n                    NamingEnumeration<?> list = (NamingEnumeration<?>)attr.getAll();\n                    while (list.hasMore()) {\n                        Object obj = list.next();\n                        if (!(obj instanceof String)) {\n                            LOG.warning(\"LDAP attribute '\" + ldapAttribute \n                                    + \"' has got an unsupported value type\");\n                            break;\n                        }\n                        String itemValue = (String)obj;\n                        if (this.isX500FilterEnabled()) {\n                            try {\n                                X500Principal x500p = new X500Principal(itemValue);\n                                itemValue = x500p.getName();\n                                int index = itemValue.indexOf('=');\n                                itemValue = itemValue.substring(index + 1, itemValue.indexOf(',', index));\n                            } catch (Exception ex) {\n                                //Ignore, not X500 compliant thus use the whole string as the value\n                            }\n                        }\n                        claimValue.append(itemValue);\n                        if (list.hasMore()) {\n                            claimValue.append(this.getDelimiter());\n                        }\n                    }\n                } catch (NamingException ex) {\n                    LOG.warning(\"Failed to read value of LDAP attribute '\" + ldapAttribute + \"'\");\n                }\n                \n                c.addValue(claimValue.toString());\n                // c.setIssuer(issuer);\n                // c.setOriginalIssuer(originalIssuer);\n                // c.setNamespace(namespace);\n                claimsColl.add(c);\n            }\n        }\n        \n        return claimsColl;\n    }","commit_id":"48f22102e6bc9ee0bbafcffdeee1228b2c536789","url":"https://github.com/apache/cxf"},{"original_method":"public ClaimCollection retrieveClaimValues(\n            RequestClaimCollection claims, ClaimsParameters parameters) {\n      \n        Principal principal = parameters.getPrincipal();\n        \n        String user = null;\n        if (principal instanceof KerberosPrincipal) {\n            KerberosPrincipal kp = (KerberosPrincipal)principal;\n            StringTokenizer st = new StringTokenizer(kp.getName(), \"@\");\n            user = st.nextToken();\n        } else if (principal instanceof X500Principal) {\n            X500Principal x500p = (X500Principal)principal;\n            LOG.warning(\"Unsupported principal type X500: \" + x500p.getName());\n            return new ClaimCollection();\n        } else if (principal != null) {\n            user = principal.getName();\n        } else {\n            //[TODO] if onbehalfof -> principal == null\n            LOG.info(\"Principal is null\");\n            return new ClaimCollection();\n        }\n        \n        if (user == null) {\n            LOG.warning(\"User must not be null\");\n            return new ClaimCollection();\n        } else {\n            if (LOG.isLoggable(Level.FINEST)) {\n                LOG.finest(\"Retrieve claims for user \" + user);\n            }\n        }\n        \n        AndFilter filter = new AndFilter();\n        filter.and(\n                new EqualsFilter(\"objectclass\", this.getObjectClass())).and(\n                        new EqualsFilter(this.getUserNameAttribute(), user));\n\n        List<String> searchAttributeList = new ArrayList<String>();\n        for (RequestClaim claim : claims) {\n            if (getClaimsLdapAttributeMapping().keySet().contains(claim.getClaimType().toString())) {\n                searchAttributeList.add(\n                    getClaimsLdapAttributeMapping().get(claim.getClaimType().toString())\n                );\n            } else {\n                if (LOG.isLoggable(Level.FINER)) {\n                    LOG.finer(\"Unsupported claim: \" + claim.getClaimType());\n                }\n            }\n        }\n\n        String[] searchAttributes = null;\n        searchAttributes = searchAttributeList.toArray(new String[searchAttributeList.size()]);\n\n        AttributesMapper mapper = \n            new AttributesMapper() {\n                public Object mapFromAttributes(Attributes attrs) throws NamingException {\n                    Map<String, Attribute> map = new HashMap<String, Attribute>();\n                    NamingEnumeration<? extends Attribute> attrEnum = attrs.getAll();\n                    while (attrEnum.hasMore()) {\n                        Attribute att = attrEnum.next();\n                        map.put(att.getID(), att);\n                    }\n                    return map;\n                }\n            };\n        \n        \n        List<?> result = ldap.search((this.userBaseDn == null) ? \"\" : this.userBaseDn, filter.toString(),\n                SearchControls.SUBTREE_SCOPE, searchAttributes, mapper);\n      \n        Map<String, Attribute> ldapAttributes = null;\n        if (result != null && result.size() > 0) {\n            ldapAttributes = CastUtils.cast((Map<?, ?>)result.get(0));\n        }\n        \n        ClaimCollection claimsColl = new ClaimCollection();\n\n        for (RequestClaim claim : claims) {\n            URI claimType = claim.getClaimType();\n            String ldapAttribute = getClaimsLdapAttributeMapping().get(claimType.toString());\n            Attribute attr = ldapAttributes.get(ldapAttribute);\n            if (attr == null) {\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Claim '\" + claim.getClaimType() + \"' is null\");\n                }\n            } else {\n                Claim c = new Claim();\n                c.setClaimType(claimType);\n                c.setPrincipal(principal);\n\n                StringBuilder claimValue = new StringBuilder();\n                try {\n                    NamingEnumeration<?> list = (NamingEnumeration<?>)attr.getAll();\n                    while (list.hasMore()) {\n                        Object obj = list.next();\n                        if (!(obj instanceof String)) {\n                            LOG.warning(\"LDAP attribute '\" + ldapAttribute \n                                    + \"' has got an unsupported value type\");\n                            break;\n                        }\n                        String itemValue = (String)obj;\n                        if (this.isX500FilterEnabled()) {\n                            try {\n                                X500Principal x500p = new X500Principal(itemValue);\n                                itemValue = x500p.getName();\n                                int index = itemValue.indexOf('=');\n                                itemValue = itemValue.substring(index + 1, itemValue.indexOf(',', index));\n                            } catch (Exception ex) {\n                                //Ignore, not X500 compliant thus use the whole string as the value\n                            }\n                        }\n                        claimValue.append(itemValue);\n                        if (list.hasMore()) {\n                            claimValue.append(this.getDelimiter());\n                        }\n                    }\n                } catch (NamingException ex) {\n                    LOG.warning(\"Failed to read value of LDAP attribute '\" + ldapAttribute + \"'\");\n                }\n                \n                c.addValue(claimValue.toString());\n                // c.setIssuer(issuer);\n                // c.setOriginalIssuer(originalIssuer);\n                // c.setNamespace(namespace);\n                claimsColl.add(c);\n            }\n        }\n        \n        return claimsColl;\n    }","id":74202,"modified_method":"public ClaimCollection retrieveClaimValues(\n            RequestClaimCollection claims, ClaimsParameters parameters) {\n        String user = null;\n        boolean useLdapLookup = false;\n        \n        Principal principal = parameters.getPrincipal();\n        if (principal instanceof KerberosPrincipal) {\n            KerberosPrincipal kp = (KerberosPrincipal)principal;\n            StringTokenizer st = new StringTokenizer(kp.getName(), \"@\");\n            user = st.nextToken();\n        } else if (principal instanceof X500Principal) {\n            X500Principal x500p = (X500Principal)principal;\n            LOG.warning(\"Unsupported principal type X500: \" + x500p.getName());\n            return new ClaimCollection();\n        } else if (principal != null) {\n            user = principal.getName();\n            if (user == null) {\n                LOG.warning(\"User must not be null\");\n                return new ClaimCollection();\n            }\n            useLdapLookup = LdapUtils.isDN(user);\n            \n        } else {\n            LOG.warning(\"Principal is null\");\n            return new ClaimCollection();\n        }\n       \n        if (LOG.isLoggable(Level.FINEST)) {\n            LOG.finest(\"Retrieve claims for user \" + user);\n        }\n        \n        \n\n\n        \n        Map<String, Attribute> ldapAttributes = null;\n        if (useLdapLookup) {\n            AttributesMapper mapper = \n                new AttributesMapper() {\n                    public Object mapFromAttributes(Attributes attrs) throws NamingException {\n                        Map<String, Attribute> map = new HashMap<String, Attribute>();\n                        NamingEnumeration<? extends Attribute> attrEnum = attrs.getAll();\n                        while (attrEnum.hasMore()) {\n                            Attribute att = attrEnum.next();\n                            map.put(att.getID(), att);\n                        }\n                        return map;\n                    }\n                };\n                \n            Object result = ldap.lookup(user, mapper);\n            ldapAttributes = CastUtils.cast((Map<?, ?>)result);\n        } else {\n            List<String> searchAttributeList = new ArrayList<String>();\n            for (RequestClaim claim : claims) {\n                if (getClaimsLdapAttributeMapping().keySet().contains(claim.getClaimType().toString())) {\n                    searchAttributeList.add(\n                        getClaimsLdapAttributeMapping().get(claim.getClaimType().toString())\n                    );\n                } else {\n                    if (LOG.isLoggable(Level.FINER)) {\n                        LOG.finer(\"Unsupported claim: \" + claim.getClaimType());\n                    }\n                }\n            }\n\n            String[] searchAttributes = null;\n            searchAttributes = searchAttributeList.toArray(new String[searchAttributeList.size()]);\n            \n            ldapAttributes = LdapUtils.getAttributesOfEntry(ldap, this.userBaseDn, this.getObjectClass(),\n                                                            this.getUserNameAttribute(), user, searchAttributes);\n        }\n        \n        if (ldapAttributes == null || ldapAttributes.size() == 0) {\n            //No result\n            if (LOG.isLoggable(Level.INFO)) {\n                LOG.finest(\"User '\" + user + \"' not found\");\n            }\n            return new ClaimCollection();\n        }\n        \n        ClaimCollection claimsColl = new ClaimCollection();\n\n        for (RequestClaim claim : claims) {\n            URI claimType = claim.getClaimType();\n            String ldapAttribute = getClaimsLdapAttributeMapping().get(claimType.toString());\n            Attribute attr = ldapAttributes.get(ldapAttribute);\n            if (attr == null) {\n                if (LOG.isLoggable(Level.FINEST)) {\n                    LOG.finest(\"Claim '\" + claim.getClaimType() + \"' is null\");\n                }\n            } else {\n                Claim c = new Claim();\n                c.setClaimType(claimType);\n                c.setPrincipal(principal);\n\n                StringBuilder claimValue = new StringBuilder();\n                try {\n                    NamingEnumeration<?> list = (NamingEnumeration<?>)attr.getAll();\n                    while (list.hasMore()) {\n                        Object obj = list.next();\n                        if (!(obj instanceof String)) {\n                            LOG.warning(\"LDAP attribute '\" + ldapAttribute \n                                    + \"' has got an unsupported value type\");\n                            break;\n                        }\n                        String itemValue = (String)obj;\n                        if (this.isX500FilterEnabled()) {\n                            try {\n                                X500Principal x500p = new X500Principal(itemValue);\n                                itemValue = x500p.getName();\n                                int index = itemValue.indexOf('=');\n                                itemValue = itemValue.substring(index + 1, itemValue.indexOf(',', index));\n                            } catch (Exception ex) {\n                                //Ignore, not X500 compliant thus use the whole string as the value\n                            }\n                        }\n                        claimValue.append(itemValue);\n                        if (list.hasMore()) {\n                            claimValue.append(this.getDelimiter());\n                        }\n                    }\n                } catch (NamingException ex) {\n                    LOG.warning(\"Failed to read value of LDAP attribute '\" + ldapAttribute + \"'\");\n                }\n                \n                c.addValue(claimValue.toString());\n                // c.setIssuer(issuer);\n                // c.setOriginalIssuer(originalIssuer);\n                // c.setNamespace(namespace);\n                claimsColl.add(c);\n            }\n        }\n        \n        return claimsColl;\n    }","commit_id":"fef3f12ad0e54f483c5b4c036070f9fed46b37df","url":"https://github.com/apache/cxf"},{"original_method":"/**\n\t * @return model object class\n\t */\n\tpublic Class getObjectClass()\n\t{\n\t\tfinal String expression = propertyExpression();\n\t\tif (Strings.isEmpty(expression))\n\t\t{\n\t\t\t// Return a meaningful value for an empty property expression\n\t\t\tObject target = getTarget();\n\t\t\treturn target != null ? target.getClass() : null;\n\t\t}\n\n\t\tfinal Object target = getTarget();\n\t\tif (target != null)\n\t\t{\n\t\t\treturn PropertyResolver.getPropertyClass(expression, target);\n\t\t}\n\t\treturn null;\n\t}","id":74203,"modified_method":"/**\n\t * @return model object class\n\t */\n\tpublic Class getObjectClass()\n\t{\n\t\tfinal String expression = propertyExpression();\n\t\tif (Strings.isEmpty(expression))\n\t\t{\n\t\t\t// Return a meaningful value for an empty property expression\n\t\t\tObject target = getTarget();\n\t\t\treturn target != null ? target.getClass() : null;\n\t\t}\n\n\t\tfinal Object target = getTarget();\n\t\tif (target != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn PropertyResolver.getPropertyClass(expression, target);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\t// ignore.\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}","commit_id":"17950a9ddec6706ec6d7d91760ee0fede11b9df7","url":"https://github.com/apache/wicket"},{"original_method":"private Class getModelType(IModel model)\n\t{\n\t\tif (model instanceof IObjectClassAwareModel)\n\t\t{\n\t\t\treturn ((IObjectClassAwareModel)model).getObjectClass();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}","id":74204,"modified_method":"private Class getModelType(IModel model)\n\t{\n\t\tif (model instanceof IObjectClassAwareModel)\n\t\t{\n\t\t\tClass objectClass = ((IObjectClassAwareModel)model).getObjectClass();\n\t\t\tif (objectClass == null)\n\t\t\t{\n\t\t\t\tlog.warn(\"Couldn't resolve model type of \" + model + \" for \" + this +\n\t\t\t\t\t\", please set the type yourself.\");\n\t\t\t}\n\t\t\treturn objectClass;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t}","commit_id":"17950a9ddec6706ec6d7d91760ee0fede11b9df7","url":"https://github.com/apache/wicket"},{"original_method":"public boolean isModified(CodeStyleSettings settings) {\n    if (!Comparing.equal(getSelectedLineSeparator(), settings.LINE_SEPARATOR)) {\n      return true;\n    }\n    if (myCbUseSameIndents.isSelected() != settings.USE_SAME_INDENTS) {\n      return true;\n    }\n    if (settings.USE_SAME_INDENTS) {\n      final IndentOptionsEditor editor = findEditorForSameIndents();\n      // since the values from the editor will be saved into all options,\n      if (editor.isModified(settings, settings.OTHER_INDENT_OPTIONS)) {\n        return true;\n      }\n    }\n    else {\n      if (myOtherIndentOptions.isModified(settings, settings.OTHER_INDENT_OPTIONS)) {\n        return true;\n      }\n\n      for(Map.Entry<FileType, IndentOptionsEditor> entry : myAdditionalIndentOptions.entrySet()) {\n        IndentOptionsEditor editor = entry.getValue();\n        FileType fileType = entry.getKey();\n        if (editor.isModified(settings, settings.getAdditionalIndentOptions(fileType))) {\n          return true;\n        }\n      }\n    }\n\n    if (settings.WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN ^ myCbWrapWhenTypingReachesRightMargin.isSelected()) {\n      return true;\n    }\n\n    return !myRightMarginField.getText().equals(String.valueOf(settings.RIGHT_MARGIN));\n  }","id":74205,"modified_method":"public boolean isModified(CodeStyleSettings settings) {\n    if (!Comparing.equal(getSelectedLineSeparator(), settings.LINE_SEPARATOR)) {\n      return true;\n    }\n    if (myCbUseSameIndents.isSelected() != settings.USE_SAME_INDENTS) {\n      return true;\n    }\n    if (settings.USE_SAME_INDENTS) {\n      final IndentOptionsEditor editor = findEditorForSameIndents();\n      // since the values from the editor will be saved into all options,\n      if (editor.isModified(settings, settings.OTHER_INDENT_OPTIONS)) {\n        return true;\n      }\n    }\n    else {\n      if (myOtherIndentOptions.isModified(settings, settings.OTHER_INDENT_OPTIONS)) {\n        return true;\n      }\n\n      for(Map.Entry<FileType, IndentOptionsEditor> entry : myAdditionalIndentOptions.entrySet()) {\n        FileType fileType = entry.getKey();\n        CodeStyleSettings.IndentOptions additionalIndentOptions = settings.getAdditionalIndentOptions(fileType);\n        if (additionalIndentOptions == null) {\n          continue;\n        }\n        IndentOptionsEditor editor = entry.getValue();\n        if (editor.isModified(settings, additionalIndentOptions)) {\n          return true;\n        }\n      }\n    }\n\n    if (settings.WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN ^ myCbWrapWhenTypingReachesRightMargin.isSelected()) {\n      return true;\n    }\n\n    return !myRightMarginField.getText().equals(String.valueOf(settings.RIGHT_MARGIN));\n  }","commit_id":"8bd63a79f5833c2c0b703dd8bf45b1632a1b05d8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void resetImpl(final CodeStyleSettings settings) {\n    myCbUseSameIndents.setSelected(settings.USE_SAME_INDENTS);\n\n    myOtherIndentOptions.reset(settings, settings.OTHER_INDENT_OPTIONS);\n\n    boolean first = true;\n    for(Map.Entry<FileType, IndentOptionsEditor> entry : myAdditionalIndentOptions.entrySet()) {\n      final IndentOptionsEditor editor = entry.getValue();\n      if (settings.USE_SAME_INDENTS && first) {\n        first = false;\n        editor.reset(settings, settings.OTHER_INDENT_OPTIONS);\n      }\n      else {\n        FileType type = entry.getKey();\n        editor.reset(settings, settings.getAdditionalIndentOptions(type));\n      }\n    }\n\n    String lineSeparator = settings.LINE_SEPARATOR;\n    if (\"\\n\".equals(lineSeparator)) {\n      myLineSeparatorCombo.setSelectedItem(UNIX_STRING);\n    }\n    else if (\"\\r\\n\".equals(lineSeparator)) {\n      myLineSeparatorCombo.setSelectedItem(WINDOWS_STRING);\n    }\n    else if (\"\\r\".equals(lineSeparator)) {\n      myLineSeparatorCombo.setSelectedItem(MACINTOSH_STRING);\n    }\n    else {\n      myLineSeparatorCombo.setSelectedItem(SYSTEM_DEPENDANT_STRING);\n    }\n\n    myRightMarginField.setText(String.valueOf(settings.RIGHT_MARGIN));\n    myCbWrapWhenTypingReachesRightMargin.setSelected(settings.WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN);\n    update();\n  }","id":74206,"modified_method":"protected void resetImpl(final CodeStyleSettings settings) {\n    myCbUseSameIndents.setSelected(settings.USE_SAME_INDENTS);\n\n    myOtherIndentOptions.reset(settings, settings.OTHER_INDENT_OPTIONS);\n\n    boolean first = true;\n    for(Map.Entry<FileType, IndentOptionsEditor> entry : myAdditionalIndentOptions.entrySet()) {\n      final IndentOptionsEditor editor = entry.getValue();\n      if (settings.USE_SAME_INDENTS && first) {\n        first = false;\n        editor.reset(settings, settings.OTHER_INDENT_OPTIONS);\n      }\n      else {\n        FileType type = entry.getKey();\n        CodeStyleSettings.IndentOptions additionalIndentOptions = settings.getAdditionalIndentOptions(type);\n        if (additionalIndentOptions != null) {\n          editor.reset(settings, additionalIndentOptions);\n        }\n      }\n    }\n\n    String lineSeparator = settings.LINE_SEPARATOR;\n    if (\"\\n\".equals(lineSeparator)) {\n      myLineSeparatorCombo.setSelectedItem(UNIX_STRING);\n    }\n    else if (\"\\r\\n\".equals(lineSeparator)) {\n      myLineSeparatorCombo.setSelectedItem(WINDOWS_STRING);\n    }\n    else if (\"\\r\".equals(lineSeparator)) {\n      myLineSeparatorCombo.setSelectedItem(MACINTOSH_STRING);\n    }\n    else {\n      myLineSeparatorCombo.setSelectedItem(SYSTEM_DEPENDANT_STRING);\n    }\n\n    myRightMarginField.setText(String.valueOf(settings.RIGHT_MARGIN));\n    myCbWrapWhenTypingReachesRightMargin.setSelected(settings.WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN);\n    update();\n  }","commit_id":"1e7df5625637ecb43fd55c87d5d63e6a8d106520","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void apply(CodeStyleSettings settings) {\n    settings.LINE_SEPARATOR = getSelectedLineSeparator();\n    settings.USE_SAME_INDENTS = myCbUseSameIndents.isSelected();\n    if (settings.USE_SAME_INDENTS) {\n      IndentOptionsEditor theEditor = findEditorForSameIndents();\n      theEditor.apply(settings, settings.OTHER_INDENT_OPTIONS);\n    }\n    else {\n      myOtherIndentOptions.apply(settings, settings.OTHER_INDENT_OPTIONS);\n\n      for(Map.Entry<FileType, IndentOptionsEditor> entry : myAdditionalIndentOptions.entrySet()) {\n        FileType fileType = entry.getKey();\n        IndentOptionsEditor editor = entry.getValue();\n        editor.apply(settings, settings.getAdditionalIndentOptions(fileType));\n      }\n    }\n\n    int rightMarginImpl = getRightMarginImpl();\n    if (rightMarginImpl > 0) {\n      settings.RIGHT_MARGIN = rightMarginImpl;\n    }\n    settings.WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN = myCbWrapWhenTypingReachesRightMargin.isSelected();\n  }","id":74207,"modified_method":"public void apply(CodeStyleSettings settings) {\n    settings.LINE_SEPARATOR = getSelectedLineSeparator();\n    settings.USE_SAME_INDENTS = myCbUseSameIndents.isSelected();\n    if (settings.USE_SAME_INDENTS) {\n      IndentOptionsEditor theEditor = findEditorForSameIndents();\n      theEditor.apply(settings, settings.OTHER_INDENT_OPTIONS);\n    }\n    else {\n      myOtherIndentOptions.apply(settings, settings.OTHER_INDENT_OPTIONS);\n\n      for(Map.Entry<FileType, IndentOptionsEditor> entry : myAdditionalIndentOptions.entrySet()) {\n        FileType fileType = entry.getKey();\n        CodeStyleSettings.IndentOptions additionalIndentOptions = settings.getAdditionalIndentOptions(fileType);\n        if (additionalIndentOptions == null) {\n          continue;\n        }\n        IndentOptionsEditor editor = entry.getValue();\n        editor.apply(settings, additionalIndentOptions);\n      }\n    }\n\n    int rightMarginImpl = getRightMarginImpl();\n    if (rightMarginImpl > 0) {\n      settings.RIGHT_MARGIN = rightMarginImpl;\n    }\n    settings.WRAP_WHEN_TYPING_REACHES_RIGHT_MARGIN = myCbWrapWhenTypingReachesRightMargin.isSelected();\n  }","commit_id":"a9d5de9e7ad04dc3514b5b5d70e5e07d32db82a2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"Object getField(Object o, int columnIndex);","id":74208,"modified_method":"T getField(T o, int columnIndex);","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setData(java.util.List data) {\n    myData = data;\n    myTableModel.fireTableDataChanged();\n  }","id":74209,"modified_method":"public void setData(java.util.List<T> data) {\n    myData = data;\n    myTableModel.fireTableDataChanged();\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract Object addItem();","id":74210,"modified_method":"protected abstract T addItem();","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public AddEditRemovePanel(String labelText, TableModel model, List data) {\n    myModel = model;\n    myData = data;\n\n    initPanel();\n    updateButtons();\n\n    setBorder(BorderFactory.createTitledBorder(new EtchedBorder(),labelText));\n  }","id":74211,"modified_method":"public AddEditRemovePanel(String labelText, TableModel<T> model, List<T> data) {\n    myModel = model;\n    myData = data;\n\n    initPanel();\n    updateButtons();\n\n    setBorder(BorderFactory.createTitledBorder(new EtchedBorder(),labelText));\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract boolean removeItem(Object o);","id":74212,"modified_method":"protected abstract boolean removeItem(T o);","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected abstract Object editItem(Object o);","id":74213,"modified_method":"protected abstract T editItem(T o);","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createMainComponent(){\n    myTableModel = new AbstractTableModel() {\n      public int getRowCount(){\n        return myData != null ? myData.size() : 0;\n      }\n\n      public int getColumnCount(){\n        return myModel.getColumnCount();\n      }\n\n      public String getColumnName(int column){\n        return myModel.getColumnName(column);\n      }\n\n      public Class getColumnClass(int columnIndex){\n        return String.class;\n      }\n\n      public Object getValueAt(int rowIndex, int columnIndex){\n        return myModel.getField(myData.get(rowIndex), columnIndex);\n      }\n    };\n\n    myTable = new Table(myTableModel);\n    myTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    myTable.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e){\n        if (e.getClickCount() == 2) doEdit();\n      }\n    });\n\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e){\n        updateButtons();\n      }\n    });\n\n    JScrollPane scrollpane = ScrollPaneFactory.createScrollPane(myTable);\n\n    return scrollpane;\n  }","id":74214,"modified_method":"protected JComponent createMainComponent(){\n    myTableModel = new AbstractTableModel() {\n      public int getRowCount(){\n        return myData != null ? myData.size() : 0;\n      }\n\n      public int getColumnCount(){\n        return myModel.getColumnCount();\n      }\n\n      public String getColumnName(int column){\n        return myModel.getColumnName(column);\n      }\n\n      public Class getColumnClass(int columnIndex){\n        return String.class;\n      }\n\n      public Object getValueAt(int rowIndex, int columnIndex){\n        return myModel.getField(myData.get(rowIndex), columnIndex);\n      }\n    };\n\n    myTable = new Table(myTableModel);\n    myTable.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);\n    myTable.addMouseListener(new MouseAdapter() {\n      public void mouseClicked(MouseEvent e){\n        if (e.getClickCount() == 2) doEdit();\n      }\n    });\n\n    myTable.getSelectionModel().addListSelectionListener(new ListSelectionListener() {\n      public void valueChanged(ListSelectionEvent e){\n        updateButtons();\n      }\n    });\n\n    return ScrollPaneFactory.createScrollPane(myTable);\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doAdd() {\n    Object o = addItem();\n    if (o == null) return;\n\n    myData.add(o);\n    int index = myData.size() - 1;\n    myTableModel.fireTableRowsInserted(index, index);\n    myTable.setRowSelectionInterval(index, index);\n  }","id":74215,"modified_method":"protected void doAdd() {\n    T o = addItem();\n    if (o == null) return;\n\n    myData.add(o);\n    int index = myData.size() - 1;\n    myTableModel.fireTableRowsInserted(index, index);\n    myTable.setRowSelectionInterval(index, index);\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void doEdit() {\n    int selected = myTable.getSelectedRow();\n    Object o = editItem(myData.get(selected));\n    if (o != null) myData.set(selected, o);\n\n    myTableModel.fireTableRowsUpdated(selected, selected);\n  }","id":74216,"modified_method":"protected void doEdit() {\n    int selected = myTable.getSelectedRow();\n    T o = editItem(myData.get(selected));\n    if (o != null) myData.set(selected, o);\n\n    myTableModel.fireTableRowsUpdated(selected, selected);\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void reset() {\n    myPairs = new ArrayList();\n    ExternalResourceManagerEx manager = ExternalResourceManagerEx.getInstanceEx();\n\n    String[] urls = manager.getAvailableUrls();\n    for (String url : urls) {\n      String loc = manager.getResourceLocation(url);\n      myPairs.add(new EditLocationDialog.Pair(url, loc));\n    }\n\n    Collections.sort(myPairs);\n\n    myIgnoredUrls = new ArrayList();\n    final String[] ignoredResources = manager.getIgnoredResources();\n    for (String ignoredResource : ignoredResources) {\n      myIgnoredUrls.add(ignoredResource);\n    }\n\n    Collections.sort(myIgnoredUrls);\n\n    myExtPanel.setData(myPairs);\n    myIgnorePanel.setData(myIgnoredUrls);\n\n    setModified(false);\n  }","id":74217,"modified_method":"public void reset() {\n    myPairs = new ArrayList<EditLocationDialog.Pair>();\n    ExternalResourceManagerEx manager = ExternalResourceManagerEx.getInstanceEx();\n\n    String[] urls = manager.getAvailableUrls();\n    for (String url : urls) {\n      String loc = manager.getResourceLocation(url);\n      myPairs.add(new EditLocationDialog.Pair(url, loc));\n    }\n\n    Collections.sort(myPairs);\n\n    myIgnoredUrls = new ArrayList<String>();\n    final String[] ignoredResources = manager.getIgnoredResources();\n    for (String ignoredResource : ignoredResources) {\n      myIgnoredUrls.add(ignoredResource);\n    }\n\n    Collections.sort(myIgnoredUrls);\n\n    myExtPanel.setData(myPairs);\n    myIgnorePanel.setData(myIgnoredUrls);\n\n    setModified(false);\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object editIgnoreLocation(Object o) {\n    EditLocationDialog dialog = new EditLocationDialog(null, false);\n    dialog.init(o.toString(), o.toString());\n    dialog.show();\n    if (!dialog.isOK()) return null;\n    setModified(true);\n    return dialog.getPair().myName;\n  }","id":74218,"modified_method":"private String editIgnoreLocation(Object o) {\n    EditLocationDialog dialog = new EditLocationDialog(null, false);\n    dialog.init(o.toString(), o.toString());\n    dialog.show();\n    if (!dialog.isOK()) return null;\n    setModified(true);\n    return dialog.getPair().myName;\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Object addIgnoreLocation() {\n    EditLocationDialog dialog = new EditLocationDialog(null, false);\n    dialog.show();\n    if (!dialog.isOK()) return null;\n    setModified(true);\n    return dialog.getPair().myName;\n  }","id":74219,"modified_method":"private String addIgnoreLocation() {\n    EditLocationDialog dialog = new EditLocationDialog(null, false);\n    dialog.show();\n    if (!dialog.isOK()) return null;\n    setModified(true);\n    return dialog.getPair().myName;\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public JComponent createComponent() {\n    myPanel = new JPanel(new GridBagLayout()){\n      public Dimension getPreferredSize() {\n        return new Dimension(700, 400);    \n      }\n    };\n\n    myExtPanel = new AddEditRemovePanel(J2EEBundle.message(\"label.edit.external.resource.configure.external.resources\"), new ExtUrlsTableModel(), myPairs) {\n      protected Object addItem() {\n        return addExtLocation();\n      }\n\n      protected boolean removeItem(Object o) {\n        setModified(true);\n        return true;\n      }\n\n      protected Object editItem(Object o) {\n        return editExtLocation(o);\n      }\n\n      protected char getAddMnemonic(){\n        return 'A';\n      }\n\n      protected char getEditMnemonic(){\n        return 'E';\n      }\n\n      protected char getRemoveMnemonic(){\n        return 'R';\n      }\n    };\n\n    myExtPanel.setRenderer(1, new PathRenderer());\n\n    myIgnorePanel = new AddEditRemovePanel(J2EEBundle.message(\"label.edit.external.resource.configure.ignored.resources\"), new IgnoredUrlsModel(), myIgnoredUrls) {\n      protected Object addItem() {\n        return addIgnoreLocation();\n      }\n\n      protected boolean removeItem(Object o) {\n        setModified(true);\n        return true;\n      }\n\n      protected Object editItem(Object o) {\n        return editIgnoreLocation(o);\n      }\n\n      protected char getAddMnemonic(){\n        return 'd';\n      }\n\n      protected char getEditMnemonic(){\n        return 't';\n      }\n\n      protected char getRemoveMnemonic(){\n        return 'm';\n      }\n    };\n\n    myPanel.add(myExtPanel, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(5, 2, 4, 2), 0, 0));\n    myPanel.add(myIgnorePanel, new GridBagConstraints(0, 1, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(5, 2, 4, 2), 0, 0));\n\n    return myPanel;\n  }","id":74220,"modified_method":"public JComponent createComponent() {\n    myPanel = new JPanel(new GridBagLayout()){\n      public Dimension getPreferredSize() {\n        return new Dimension(700, 400);\n      }\n    };\n\n    myExtPanel = new AddEditRemovePanel<EditLocationDialog.Pair>(J2EEBundle.message(\"label.edit.external.resource.configure.external.resources\"), new ExtUrlsTableModel(), myPairs) {\n      protected EditLocationDialog.Pair addItem() {\n        return addExtLocation();\n      }\n\n      protected boolean removeItem(EditLocationDialog.Pair o) {\n        setModified(true);\n        return true;\n      }\n\n      protected EditLocationDialog.Pair editItem(EditLocationDialog.Pair o) {\n        return editExtLocation(o);\n      }\n\n      protected char getAddMnemonic(){\n        return 'A';\n      }\n\n      protected char getEditMnemonic(){\n        return 'E';\n      }\n\n      protected char getRemoveMnemonic(){\n        return 'R';\n      }\n    };\n\n    myExtPanel.setRenderer(1, new PathRenderer());\n\n    myIgnorePanel = new AddEditRemovePanel<String>(J2EEBundle.message(\"label.edit.external.resource.configure.ignored.resources\"), new IgnoredUrlsModel(), myIgnoredUrls) {\n      protected String addItem() {\n        return addIgnoreLocation();\n      }\n\n      protected boolean removeItem(String o) {\n        setModified(true);\n        return true;\n      }\n\n      protected String editItem(String o) {\n        return editIgnoreLocation(o);\n      }\n\n      protected char getAddMnemonic(){\n        return 'd';\n      }\n\n      protected char getEditMnemonic(){\n        return 't';\n      }\n\n      protected char getRemoveMnemonic(){\n        return 'm';\n      }\n    };\n\n    myPanel.add(myExtPanel, new GridBagConstraints(0, 0, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(5, 2, 4, 2), 0, 0));\n    myPanel.add(myIgnorePanel, new GridBagConstraints(0, 1, 1, 1, 1, 1, GridBagConstraints.NORTH, GridBagConstraints.BOTH, new Insets(5, 2, 4, 2), 0, 0));\n\n    return myPanel;\n  }","commit_id":"5ef801f9409be5ffc7859a819fa67a3436a257be","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean isModified() {\n    if (myPanel != null) {\n      return myPanel.isModified(mySettings);\n    }\n    else {\n      return false;\n    }\n  }","id":74221,"modified_method":"public boolean isModified() {\n    return myPanel != null && myPanel.isModified(mySettings);\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private final Editor createEditor() {\n    EditorFactory editorFactory = EditorFactory.getInstance();\n    myTextToReformat = getPreviewText();\n    Document editorDocument = editorFactory.createDocument(myTextToReformat);\n    EditorEx editor = (EditorEx)editorFactory.createEditor(editorDocument);\n\n    myLastDocumentModificationStamp = editor.getDocument().getModificationStamp();\n\n    EditorSettings editorSettings = editor.getSettings();\n    fillEditorSettings(editorSettings);\n\n    EditorColorsScheme scheme = editor.getColorsScheme();\n    scheme.setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    editor.setHighlighter(createHighlighter(scheme));\n\n    return editor;\n  }","id":74222,"modified_method":"private Editor createEditor() {\n    EditorFactory editorFactory = EditorFactory.getInstance();\n    myTextToReformat = getPreviewText();\n    Document editorDocument = editorFactory.createDocument(myTextToReformat);\n    EditorEx editor = (EditorEx)editorFactory.createEditor(editorDocument);\n\n    myLastDocumentModificationStamp = editor.getDocument().getModificationStamp();\n\n    EditorSettings editorSettings = editor.getSettings();\n    fillEditorSettings(editorSettings);\n\n    EditorColorsScheme scheme = editor.getColorsScheme();\n    scheme.setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    editor.setHighlighter(createHighlighter(scheme));\n\n    return editor;\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void resetImpl(final CodeStyleSettings settings) {\n    myKeepBlankLinesInDeclarations.setText(\"\" + settings.KEEP_BLANK_LINES_IN_DECLARATIONS);\n    myKeepBlankLinesInCode.setText(\"\" + settings.KEEP_BLANK_LINES_IN_CODE);\n    myKeepBlankLinesBeforeRBrace.setText(\"\" + settings.KEEP_BLANK_LINES_BEFORE_RBRACE);\n    myBlankLinesBeforePackage.setText(\"\" + settings.BLANK_LINES_BEFORE_PACKAGE);\n    myBlankLinesAfterPackage.setText(\"\" + settings.BLANK_LINES_AFTER_PACKAGE);\n    myBlankLinesBeforeImports.setText(\"\" + settings.BLANK_LINES_BEFORE_IMPORTS);\n    myBlankLinesAfterImports.setText(\"\" + settings.BLANK_LINES_AFTER_IMPORTS);\n    myBlankLinesAroundClass.setText(\"\" + settings.BLANK_LINES_AROUND_CLASS);\n    myBlankLinesAroundField.setText(\"\" + settings.BLANK_LINES_AROUND_FIELD);\n    myBlankLinesAroundMethod.setText(\"\" + settings.BLANK_LINES_AROUND_METHOD);\n    myBlankLinesAfterClassHeader.setText(\"\" + settings.BLANK_LINES_AFTER_CLASS_HEADER);\n\n  }","id":74223,"modified_method":"protected void resetImpl(final CodeStyleSettings settings) {\n    myKeepBlankLinesInDeclarations.setText(String.valueOf(settings.KEEP_BLANK_LINES_IN_DECLARATIONS));\n    myKeepBlankLinesInCode.setText(String.valueOf(settings.KEEP_BLANK_LINES_IN_CODE));\n    myKeepBlankLinesBeforeRBrace.setText(String.valueOf(settings.KEEP_BLANK_LINES_BEFORE_RBRACE));\n    myBlankLinesBeforePackage.setText(String.valueOf(settings.BLANK_LINES_BEFORE_PACKAGE));\n    myBlankLinesAfterPackage.setText(String.valueOf(settings.BLANK_LINES_AFTER_PACKAGE));\n    myBlankLinesBeforeImports.setText(String.valueOf(settings.BLANK_LINES_BEFORE_IMPORTS));\n    myBlankLinesAfterImports.setText(String.valueOf(settings.BLANK_LINES_AFTER_IMPORTS));\n    myBlankLinesAroundClass.setText(String.valueOf(settings.BLANK_LINES_AROUND_CLASS));\n    myBlankLinesAroundField.setText(String.valueOf(settings.BLANK_LINES_AROUND_FIELD));\n    myBlankLinesAroundMethod.setText(String.valueOf(settings.BLANK_LINES_AROUND_METHOD));\n    myBlankLinesAfterClassHeader.setText(String.valueOf(settings.BLANK_LINES_AFTER_CLASS_HEADER));\n\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createPackagesTable() {\n    final String[] names = {\n      ApplicationBundle.message(\"listbox.import.package\"),\n      ApplicationBundle.message(\"listbox.import.with.subpackages\")\n    };\n    // Create a model of the data.\n    TableModel dataModel = new AbstractTableModel() {\n      public int getColumnCount() { return names.length; }\n      public int getRowCount() { return myPackageList.getEntryCount();}\n      public Object getValueAt(int row, int col) {\n        CodeStyleSettings.PackageTable.Entry entry = myPackageList.getEntryAt(row);\n        if(col == 0) {\n          if(entry != null) {\n            return entry.getPackageName();\n          }\n        }\n\n        if(col == 1) {\n          if(entry != null) {\n            return entry.isWithSubpackages() ? Boolean.TRUE : Boolean.FALSE;\n          }\n        }\n        return null;\n      }\n      public String getColumnName(int column) { return names[column]; }\n      public Class getColumnClass(int c) {\n        if(c == 0) {\n          return String.class;\n        }\n        if(c == 1) {\n          return Boolean.class;\n        }\n        return null;\n      }\n      public boolean isCellEditable(int row, int col) {\n        return true;\n      }\n\n      public void setValueAt(Object aValue, int row, int col) {\n        CodeStyleSettings.PackageTable.Entry packageEntry = myPackageList.getEntryAt(row);\n        if(col == 0) {\n          CodeStyleSettings.PackageTable.Entry newPackageEntry = new CodeStyleSettings.PackageTable.Entry(((String)aValue).trim(), packageEntry.isWithSubpackages());\n          myPackageList.setEntryAt(newPackageEntry, row);\n        }\n\n        if(col == 1) {\n          CodeStyleSettings.PackageTable.Entry newPackageEntry = new CodeStyleSettings.PackageTable.Entry(packageEntry.getPackageName(), ((Boolean)aValue).booleanValue());\n          myPackageList.setEntryAt(newPackageEntry, row);\n        }\n      }\n    };\n\n    // Create the table\n    myPackageTable = new Table(dataModel);\n    myPackageTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    TableCellEditor editor = myPackageTable.getDefaultEditor(String.class);\n    myPackageTable.fixColumnWidthToHeader(1);\n    if (editor instanceof DefaultCellEditor) {\n      ((DefaultCellEditor)editor).setClickCountToStart(1);\n    }\n    myPackageTable.getSelectionModel().addListSelectionListener(\n      new ListSelectionListener(){\n        public void valueChanged(ListSelectionEvent e){\n          updateButtons();\n        }\n      }\n    );\n\n    JScrollPane scrollpane = ScrollPaneFactory.createScrollPane(myPackageTable);\n    return scrollpane;\n  }","id":74224,"modified_method":"private JComponent createPackagesTable() {\n    final String[] names = {\n      ApplicationBundle.message(\"listbox.import.package\"),\n      ApplicationBundle.message(\"listbox.import.with.subpackages\")\n    };\n    // Create a model of the data.\n    TableModel dataModel = new AbstractTableModel() {\n      public int getColumnCount() { return names.length; }\n      public int getRowCount() { return myPackageList.getEntryCount();}\n      public Object getValueAt(int row, int col) {\n        CodeStyleSettings.PackageTable.Entry entry = myPackageList.getEntryAt(row);\n        if(col == 0) {\n          if(entry != null) {\n            return entry.getPackageName();\n          }\n        }\n\n        if(col == 1) {\n          if(entry != null) {\n            return entry.isWithSubpackages() ? Boolean.TRUE : Boolean.FALSE;\n          }\n        }\n        return null;\n      }\n      public String getColumnName(int column) { return names[column]; }\n      public Class getColumnClass(int c) {\n        if(c == 0) {\n          return String.class;\n        }\n        if(c == 1) {\n          return Boolean.class;\n        }\n        return null;\n      }\n      public boolean isCellEditable(int row, int col) {\n        return true;\n      }\n\n      public void setValueAt(Object aValue, int row, int col) {\n        CodeStyleSettings.PackageTable.Entry packageEntry = myPackageList.getEntryAt(row);\n        if(col == 0) {\n          CodeStyleSettings.PackageTable.Entry newPackageEntry = new CodeStyleSettings.PackageTable.Entry(((String)aValue).trim(), packageEntry.isWithSubpackages());\n          myPackageList.setEntryAt(newPackageEntry, row);\n        }\n\n        if(col == 1) {\n          CodeStyleSettings.PackageTable.Entry newPackageEntry = new CodeStyleSettings.PackageTable.Entry(packageEntry.getPackageName(), ((Boolean)aValue).booleanValue());\n          myPackageList.setEntryAt(newPackageEntry, row);\n        }\n      }\n    };\n\n    // Create the table\n    myPackageTable = new Table(dataModel);\n    myPackageTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    TableCellEditor editor = myPackageTable.getDefaultEditor(String.class);\n    myPackageTable.fixColumnWidthToHeader(1);\n    if (editor instanceof DefaultCellEditor) {\n      ((DefaultCellEditor)editor).setClickCountToStart(1);\n    }\n    myPackageTable.getSelectionModel().addListSelectionListener(\n      new ListSelectionListener(){\n        public void valueChanged(ListSelectionEvent e){\n          updateButtons();\n        }\n      }\n    );\n\n    return ScrollPaneFactory.createScrollPane(myPackageTable);\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JPanel createImportLayoutButtonsPanel() {\n    JPanel tableButtonsPanel = new JPanel(new VerticalFlowLayout());\n\n    myAddPackageToImportLayoutButton = new JButton(ApplicationBundle.message(\"button.add.package\"));\n    tableButtonsPanel.add(myAddPackageToImportLayoutButton);\n\n    myAddBlankLineButton = new JButton(ApplicationBundle.message(\"button.add.blank\"));\n    tableButtonsPanel.add(myAddBlankLineButton);\n\n    myMoveUpButton = new JButton(ApplicationBundle.message(\"button.move.up\"));\n    tableButtonsPanel.add(myMoveUpButton);\n\n    myMoveDownButton = new JButton(ApplicationBundle.message(\"button.move.down\"));\n    tableButtonsPanel.add(myMoveDownButton);\n\n    myRemovePackageFromImportLayoutButton = new JButton(ApplicationBundle.message(\"button.remove\"));\n    tableButtonsPanel.add(myRemovePackageFromImportLayoutButton);\n\n    myAddPackageToImportLayoutButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          addPackageToImportLayouts();\n        }\n      }\n    );\n\n    myAddBlankLineButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          addBlankLine();\n        }\n      }\n    );\n\n    myRemovePackageFromImportLayoutButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          removeEntryFromImportLayouts();\n        }\n      }\n    );\n\n    myMoveUpButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          moveRowUp();\n        }\n      }\n    );\n\n    myMoveDownButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          moveRowDown();\n        }\n      }\n    );\n\n    return tableButtonsPanel;\n  }","id":74225,"modified_method":"private JPanel createImportLayoutButtonsPanel() {\n    JPanel tableButtonsPanel = new JPanel(new VerticalFlowLayout());\n\n    JButton addPackageToImportLayoutButton = new JButton(ApplicationBundle.message(\"button.add.package\"));\n    tableButtonsPanel.add(addPackageToImportLayoutButton);\n\n    JButton addBlankLineButton = new JButton(ApplicationBundle.message(\"button.add.blank\"));\n    tableButtonsPanel.add(addBlankLineButton);\n\n    myMoveUpButton = new JButton(ApplicationBundle.message(\"button.move.up\"));\n    tableButtonsPanel.add(myMoveUpButton);\n\n    myMoveDownButton = new JButton(ApplicationBundle.message(\"button.move.down\"));\n    tableButtonsPanel.add(myMoveDownButton);\n\n    myRemovePackageFromImportLayoutButton = new JButton(ApplicationBundle.message(\"button.remove\"));\n    tableButtonsPanel.add(myRemovePackageFromImportLayoutButton);\n\n    addPackageToImportLayoutButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          addPackageToImportLayouts();\n        }\n      }\n    );\n\n    addBlankLineButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          addBlankLine();\n        }\n      }\n    );\n\n    myRemovePackageFromImportLayoutButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          removeEntryFromImportLayouts();\n        }\n      }\n    );\n\n    myMoveUpButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          moveRowUp();\n        }\n      }\n    );\n\n    myMoveDownButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          moveRowDown();\n        }\n      }\n    );\n\n    return tableButtonsPanel;\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JPanel createPackagesButtonsPanel() {\n    JPanel tableButtonsPanel = new JPanel(new VerticalFlowLayout());\n    tableButtonsPanel.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));\n\n    myAddPackageToPackagesButton = new JButton(ApplicationBundle.message(\"button.add.package.p\"));\n    tableButtonsPanel.add(myAddPackageToPackagesButton);\n\n    myRemovePackageFromPackagesButton = new JButton(ApplicationBundle.message(\"button.remove.r\"));\n    tableButtonsPanel.add(myRemovePackageFromPackagesButton);\n\n    myAddPackageToPackagesButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          addPackageToPackages();\n        }\n      }\n    );\n\n    myRemovePackageFromPackagesButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          removeEntryFromPackages();\n        }\n      }\n    );\n\n    return tableButtonsPanel;\n  }","id":74226,"modified_method":"private JPanel createPackagesButtonsPanel() {\n    JPanel tableButtonsPanel = new JPanel(new VerticalFlowLayout());\n    tableButtonsPanel.setBorder(BorderFactory.createEmptyBorder(4,4,4,4));\n\n    JButton addPackageToPackagesButton;addPackageToPackagesButton = new JButton(ApplicationBundle.message(\"button.add.package.p\"));\n    tableButtonsPanel.add(addPackageToPackagesButton);\n\n    myRemovePackageFromPackagesButton = new JButton(ApplicationBundle.message(\"button.remove.r\"));\n    tableButtonsPanel.add(myRemovePackageFromPackagesButton);\n\n    addPackageToPackagesButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          addPackageToPackages();\n        }\n      }\n    );\n\n    myRemovePackageFromPackagesButton.addActionListener(\n      new ActionListener(){\n        public void actionPerformed(ActionEvent e){\n          removeEntryFromPackages();\n        }\n      }\n    );\n\n    return tableButtonsPanel;\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createImportLayoutTable() {\n    final String[] names = {\n      ApplicationBundle.message(\"listbox.import.package\"),\n      ApplicationBundle.message(\"listbox.import.with.subpackages\")\n    };\n    // Create a model of the data.\n    TableModel dataModel = new AbstractTableModel() {\n      public int getColumnCount() { return names.length; }\n      public int getRowCount() { return myImportLayoutList.getEntryCount();}\n      public Object getValueAt(int row, int col) {\n        CodeStyleSettings.ImportLayoutTable.Entry entry = myImportLayoutList.getEntryAt(row);\n        if(col == 0) {\n          if(isOtherEntry(entry) && entry == myOtherPackageEntry) {\n            return ApplicationBundle.message(\"listbox.import.all.other.imports\");\n          }\n          else if(entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n            CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n            return packageEntry.getPackageName();\n          }\n          else {\n            return ApplicationBundle.message(\"listbox.import.blank.line\");\n          }\n        }\n\n        if(col == 1) {\n          if(isOtherEntry(entry) && entry == myOtherPackageEntry) {\n            return null;\n          }\n          else if(entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n            CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n            return packageEntry.isWithSubpackages() ? Boolean.TRUE : Boolean.FALSE;\n          }\n          else {\n            return null;\n          }\n        }\n        return null;\n      }\n      public String getColumnName(int column) { return names[column]; }\n      public Class getColumnClass(int c) {\n        if(c == 0) {\n          return String.class;\n        }\n        if(c == 1) {\n          return Boolean.class;\n        }\n        return null;\n//        return CodeStyleSettings.ImportLayoutTable.Entry.class;\n      }\n      public boolean isCellEditable(int row, int col) {\n        CodeStyleSettings.ImportLayoutTable.Entry entry = myImportLayoutList.getEntryAt(row);\n        if(isOtherEntry(entry) && entry == myOtherPackageEntry) {\n          return false;\n        }\n        else if(entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n          return true;\n        }\n        else {\n          return false;\n        }\n      }\n\n      public void setValueAt(Object aValue, int row, int col) {\n        CodeStyleSettings.ImportLayoutTable.Entry entry = myImportLayoutList.getEntryAt(row);\n        if(col == 0 && entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n          CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n          CodeStyleSettings.ImportLayoutTable.PackageEntry newPackageEntry = new CodeStyleSettings.ImportLayoutTable.PackageEntry(((String)aValue).trim(), packageEntry.isWithSubpackages());\n          myImportLayoutList.setEntryAt(newPackageEntry, row);\n        }\n        if(col == 1 && entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n          CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n          CodeStyleSettings.ImportLayoutTable.PackageEntry newPackageEntry = new CodeStyleSettings.ImportLayoutTable.PackageEntry(packageEntry.getPackageName(), aValue.equals(Boolean.TRUE));\n          myImportLayoutList.setEntryAt(newPackageEntry, row);\n        }\n      }\n    };\n\n    // Create the table\n    myImportLayoutTable = new Table(dataModel);\n    myImportLayoutTable.setDefaultRenderer(Boolean.class, new BooleanTableCellRenderer());\n    myImportLayoutTable.fixColumnWidthToHeader(1);\n    myImportLayoutTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    TableCellEditor editor = myImportLayoutTable.getDefaultEditor(String.class);\n    if (editor instanceof DefaultCellEditor) {\n      ((DefaultCellEditor)editor).setClickCountToStart(1);\n    }\n\n    myImportLayoutTable.getSelectionModel().addListSelectionListener(\n      new ListSelectionListener(){\n        public void valueChanged(ListSelectionEvent e){\n          updateButtons();\n        }\n      }\n    );\n\n    JScrollPane scrollpane = ScrollPaneFactory.createScrollPane(myImportLayoutTable);\n    return scrollpane;\n  }","id":74227,"modified_method":"private JComponent createImportLayoutTable() {\n    final String[] names = {\n      ApplicationBundle.message(\"listbox.import.package\"),\n      ApplicationBundle.message(\"listbox.import.with.subpackages\")\n    };\n    // Create a model of the data.\n    TableModel dataModel = new AbstractTableModel() {\n      public int getColumnCount() { return names.length; }\n      public int getRowCount() { return myImportLayoutList.getEntryCount();}\n      public Object getValueAt(int row, int col) {\n        CodeStyleSettings.ImportLayoutTable.Entry entry = myImportLayoutList.getEntryAt(row);\n        if(col == 0) {\n          if(isOtherEntry(entry) && entry == myOtherPackageEntry) {\n            return ApplicationBundle.message(\"listbox.import.all.other.imports\");\n          }\n          else if(entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n            CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n            return packageEntry.getPackageName();\n          }\n          else {\n            return ApplicationBundle.message(\"listbox.import.blank.line\");\n          }\n        }\n\n        if(col == 1) {\n          if(isOtherEntry(entry) && entry == myOtherPackageEntry) {\n            return null;\n          }\n          else if(entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n            CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n            return packageEntry.isWithSubpackages() ? Boolean.TRUE : Boolean.FALSE;\n          }\n          else {\n            return null;\n          }\n        }\n        return null;\n      }\n      public String getColumnName(int column) { return names[column]; }\n      public Class getColumnClass(int c) {\n        if(c == 0) {\n          return String.class;\n        }\n        if(c == 1) {\n          return Boolean.class;\n        }\n        return null;\n//        return CodeStyleSettings.ImportLayoutTable.Entry.class;\n      }\n      public boolean isCellEditable(int row, int col) {\n        CodeStyleSettings.ImportLayoutTable.Entry entry = myImportLayoutList.getEntryAt(row);\n        if(isOtherEntry(entry) && entry == myOtherPackageEntry) {\n          return false;\n        }\n        else if(entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n          return true;\n        }\n        else {\n          return false;\n        }\n      }\n\n      public void setValueAt(Object aValue, int row, int col) {\n        CodeStyleSettings.ImportLayoutTable.Entry entry = myImportLayoutList.getEntryAt(row);\n        if(col == 0 && entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n          CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n          CodeStyleSettings.ImportLayoutTable.PackageEntry newPackageEntry = new CodeStyleSettings.ImportLayoutTable.PackageEntry(((String)aValue).trim(), packageEntry.isWithSubpackages());\n          myImportLayoutList.setEntryAt(newPackageEntry, row);\n        }\n        if(col == 1 && entry instanceof CodeStyleSettings.ImportLayoutTable.PackageEntry) {\n          CodeStyleSettings.ImportLayoutTable.PackageEntry packageEntry = (CodeStyleSettings.ImportLayoutTable.PackageEntry)entry;\n          CodeStyleSettings.ImportLayoutTable.PackageEntry newPackageEntry = new CodeStyleSettings.ImportLayoutTable.PackageEntry(packageEntry.getPackageName(), aValue.equals(Boolean.TRUE));\n          myImportLayoutList.setEntryAt(newPackageEntry, row);\n        }\n      }\n    };\n\n    // Create the table\n    myImportLayoutTable = new Table(dataModel);\n    myImportLayoutTable.setDefaultRenderer(Boolean.class, new BooleanTableCellRenderer());\n    myImportLayoutTable.fixColumnWidthToHeader(1);\n    myImportLayoutTable.getSelectionModel().setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    TableCellEditor editor = myImportLayoutTable.getDefaultEditor(String.class);\n    if (editor instanceof DefaultCellEditor) {\n      ((DefaultCellEditor)editor).setClickCountToStart(1);\n    }\n\n    myImportLayoutTable.getSelectionModel().addListSelectionListener(\n      new ListSelectionListener(){\n        public void valueChanged(ListSelectionEvent e){\n          updateButtons();\n        }\n      }\n    );\n\n    return ScrollPaneFactory.createScrollPane(myImportLayoutTable);\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void updateData() {\n    final DefaultListModel model = ((DefaultListModel)myList.getModel());\n    model.clear();\n    for (Iterator<String> iterator = myData.iterator(); iterator.hasNext();) {\n      model.addElement(iterator.next());\n    }\n  }","id":74228,"modified_method":"private void updateData() {\n    final DefaultListModel model = ((DefaultListModel)myList.getModel());\n    model.clear();\n    for (String data : myData) {\n      model.addElement(data);\n    }\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private AnAction createDeleteAction() {\n    return new IconWithTextAction(ApplicationBundle.message(\"action.remove\"), null, Icons.DELETE_ICON) {\n      public void update(AnActionEvent e) {\n        final int selectedIndex = myList.getSelectedIndex();\n        if (selectedIndex >= 0) {\n          e.getPresentation().setEnabled(true);\n        } else {\n          e.getPresentation().setEnabled(false);\n        }\n      }\n\n      public void actionPerformed(AnActionEvent e) {\n        int selectedIndex = myList.getSelectedIndex();\n        if (selectedIndex >= 0) {\n          myData.remove(selectedIndex);\n          updateData();\n          if (selectedIndex >= myData.size()) {\n            selectedIndex = selectedIndex - 1;\n          }\n          if (selectedIndex >= 0) {\n            myList.setSelectedIndex(selectedIndex);\n          }\n        }\n      }\n    };\n  }","id":74229,"modified_method":"private AnAction createDeleteAction() {\n    return new IconWithTextAction(ApplicationBundle.message(\"action.remove\"), null, Icons.DELETE_ICON) {\n      public void update(AnActionEvent e) {\n        final int selectedIndex = myList.getSelectedIndex();\n        if (selectedIndex >= 0) {\n          e.getPresentation().setEnabled(true);\n        } else {\n          e.getPresentation().setEnabled(false);\n        }\n      }\n\n      public void actionPerformed(AnActionEvent e) {\n        int selectedIndex = myList.getSelectedIndex();\n        if (selectedIndex >= 0) {\n          myData.remove(selectedIndex);\n          updateData();\n          if (selectedIndex >= myData.size()) {\n            selectedIndex -= 1;\n          }\n          if (selectedIndex >= 0) {\n            myList.setSelectedIndex(selectedIndex);\n          }\n        }\n      }\n    };\n  }","commit_id":"4d63ded34ca71209d09eb1fb48efb89ccae47d8c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private JComponent createVariablesTable() {\n    final String[] names = {\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.name\"),\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.expression\"),\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.default.value\"),\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.skip.if.defined\")\n    };\n\n    // Create a model of the data.\n    TableModel dataModel = new AbstractTableModel() {\n      public int getColumnCount() {\n        return names.length;\n      }\n\n      public int getRowCount() {\n        return myVariables.size();\n      }\n\n      public Object getValueAt(int row, int col) {\n        Variable variable = myVariables.get(row);\n        if (col == 0) {\n          return variable.getName();\n        }\n        if (col == 1) {\n          return variable.getExpressionString();\n        }\n        if (col == 2) {\n          return variable.getDefaultValueString();\n        }\n        else {\n          return variable.isAlwaysStopAt() ? Boolean.FALSE : Boolean.TRUE;\n        }\n      }\n\n      public String getColumnName(int column) {\n        return names[column];\n      }\n\n      public Class getColumnClass(int c) {\n        if (c <= 2) {\n          return String.class;\n        }\n        else {\n          return Boolean.class;\n        }\n      }\n\n      public boolean isCellEditable(int row, int col) {\n        return true;\n      }\n\n      public void setValueAt(Object aValue, int row, int col) {\n        Variable variable = myVariables.get(row);\n        if (col == 0) {\n           String varName = (String) aValue;\n          Variable newVar = new Variable (varName, variable.getExpressionString(), variable.getDefaultValueString(),\n                          variable.isAlwaysStopAt());\n          myVariables.set(row, newVar);\n          updateTemplateTextByVarNameChange(variable, newVar);\n        }\n        else if (col == 1) {\n          variable.setExpressionString((String)aValue);\n        }\n        else if (col == 2) {\n          variable.setDefaultValueString((String)aValue);\n        }\n        else {\n          variable.setAlwaysStopAt(!((Boolean)aValue).booleanValue());\n        }\n      }\n    };\n\n    // Create the table\n    myTable = new Table(dataModel);\n    myTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTable.setPreferredScrollableViewportSize(new Dimension(500, myTable.getRowHeight() * 8));\n    myTable.getColumn(names[0]).setPreferredWidth(120);\n    myTable.getColumn(names[1]).setPreferredWidth(200);\n    myTable.getColumn(names[2]).setPreferredWidth(200);\n    myTable.getColumn(names[3]).setPreferredWidth(100);\n    if (myVariables.size() > 0) {\n      myTable.getSelectionModel().setSelectionInterval(0, 0);\n    }\n\n    JComboBox comboField = new JComboBox();\n    Macro[] macros = MacroFactory.getMacros();\n\n    if (additionalMacros!=null) {\n      ArrayList<Macro> list = new ArrayList<Macro>(macros.length + additionalMacros.size());\n      list.addAll( Arrays.asList(macros) );\n      list.addAll( additionalMacros );\n      macros = (Macro[])list.toArray(new Macro[0]);\n    }\n\n    Arrays.sort(macros, new Comparator<Macro> () {\n      public int compare(Macro m1, Macro m2) {\n        return m1.getDescription().compareTo(m2.getDescription());\n      }\n    });\n    for (Macro macro : macros) {\n      comboField.addItem(macro.getDescription());\n    }\n    comboField.setEditable(true);\n    DefaultCellEditor cellEditor = new DefaultCellEditor(comboField);\n    cellEditor.setClickCountToStart(1);\n    myTable.getColumn(names[1]).setCellEditor(cellEditor);\n    myTable.setRowHeight(comboField.getPreferredSize().height);\n\n    JTextField textField = new JTextField();\n\n    /*textField.addMouseListener(\n      new PopupHandler(){\n        public void invokePopup(Component comp,int x,int y){\n          showCellPopup((JTextField)comp,x,y);\n        }\n      }\n    );*/\n\n    cellEditor = new DefaultCellEditor(textField);\n    cellEditor.setClickCountToStart(1);\n    myTable.setDefaultEditor(String.class, cellEditor);\n\n    myTable.getSelectionModel().addListSelectionListener(\n      new ListSelectionListener() {\n        public void valueChanged(ListSelectionEvent e) {\n          updateButtons();\n        }\n      }\n    );\n    JScrollPane scrollpane = ScrollPaneFactory.createScrollPane(myTable);\n    return scrollpane;\n  }","id":74230,"modified_method":"private JComponent createVariablesTable() {\n    final String[] names = {\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.name\"),\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.expression\"),\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.default.value\"),\n      CodeInsightBundle.message(\"templates.dialog.edit.variables.table.column.skip.if.defined\")\n    };\n\n    // Create a model of the data.\n    TableModel dataModel = new AbstractTableModel() {\n      public int getColumnCount() {\n        return names.length;\n      }\n\n      public int getRowCount() {\n        return myVariables.size();\n      }\n\n      public Object getValueAt(int row, int col) {\n        Variable variable = myVariables.get(row);\n        if (col == 0) {\n          return variable.getName();\n        }\n        if (col == 1) {\n          return variable.getExpressionString();\n        }\n        if (col == 2) {\n          return variable.getDefaultValueString();\n        }\n        else {\n          return variable.isAlwaysStopAt() ? Boolean.FALSE : Boolean.TRUE;\n        }\n      }\n\n      public String getColumnName(int column) {\n        return names[column];\n      }\n\n      public Class getColumnClass(int c) {\n        if (c <= 2) {\n          return String.class;\n        }\n        else {\n          return Boolean.class;\n        }\n      }\n\n      public boolean isCellEditable(int row, int col) {\n        return true;\n      }\n\n      public void setValueAt(Object aValue, int row, int col) {\n        Variable variable = myVariables.get(row);\n        if (col == 0) {\n           String varName = (String) aValue;\n          Variable newVar = new Variable (varName, variable.getExpressionString(), variable.getDefaultValueString(),\n                          variable.isAlwaysStopAt());\n          myVariables.set(row, newVar);\n          updateTemplateTextByVarNameChange(variable, newVar);\n        }\n        else if (col == 1) {\n          variable.setExpressionString((String)aValue);\n        }\n        else if (col == 2) {\n          variable.setDefaultValueString((String)aValue);\n        }\n        else {\n          variable.setAlwaysStopAt(!((Boolean)aValue).booleanValue());\n        }\n      }\n    };\n\n    // Create the table\n    myTable = new Table(dataModel);\n    myTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n    myTable.setPreferredScrollableViewportSize(new Dimension(500, myTable.getRowHeight() * 8));\n    myTable.getColumn(names[0]).setPreferredWidth(120);\n    myTable.getColumn(names[1]).setPreferredWidth(200);\n    myTable.getColumn(names[2]).setPreferredWidth(200);\n    myTable.getColumn(names[3]).setPreferredWidth(100);\n    if (myVariables.size() > 0) {\n      myTable.getSelectionModel().setSelectionInterval(0, 0);\n    }\n\n    JComboBox comboField = new JComboBox();\n    Macro[] macros = MacroFactory.getMacros();\n\n    if (additionalMacros!=null) {\n      ArrayList<Macro> list = new ArrayList<Macro>(macros.length + additionalMacros.size());\n      list.addAll( Arrays.asList(macros) );\n      list.addAll( additionalMacros );\n      macros = list.toArray(new Macro[0]);\n    }\n\n    Arrays.sort(macros, new Comparator<Macro> () {\n      public int compare(Macro m1, Macro m2) {\n        return m1.getDescription().compareTo(m2.getDescription());\n      }\n    });\n    for (Macro macro : macros) {\n      comboField.addItem(macro.getDescription());\n    }\n    comboField.setEditable(true);\n    DefaultCellEditor cellEditor = new DefaultCellEditor(comboField);\n    cellEditor.setClickCountToStart(1);\n    myTable.getColumn(names[1]).setCellEditor(cellEditor);\n    myTable.setRowHeight(comboField.getPreferredSize().height);\n\n    JTextField textField = new JTextField();\n\n    /*textField.addMouseListener(\n      new PopupHandler(){\n        public void invokePopup(Component comp,int x,int y){\n          showCellPopup((JTextField)comp,x,y);\n        }\n      }\n    );*/\n\n    cellEditor = new DefaultCellEditor(textField);\n    cellEditor.setClickCountToStart(1);\n    myTable.setDefaultEditor(String.class, cellEditor);\n\n    myTable.getSelectionModel().addListSelectionListener(\n      new ListSelectionListener() {\n        public void valueChanged(ListSelectionEvent e) {\n          updateButtons();\n        }\n      }\n    );\n    return ScrollPaneFactory.createScrollPane(myTable);\n  }","commit_id":"b674a8861587f179e2fe289aa8305fd5cc9537e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected JComponent createCenterPanel() {\n    JPanel panel = new JPanel();\n    panel.setBorder(IdeBorderFactory.createTitledBorder(CodeInsightBundle.message(\"templates.dialog.edit.variables.border.title\")));\n    JPanel tablePanel = panel;\n    tablePanel.setLayout(new BorderLayout());\n    tablePanel.add(createVariablesTable(), BorderLayout.CENTER);\n    if (hasMoveVars) tablePanel.add(createTableButtonPanel(), BorderLayout.EAST);\n    return tablePanel;\n  }","id":74231,"modified_method":"protected JComponent createCenterPanel() {\n    JPanel panel = new JPanel();\n    panel.setBorder(IdeBorderFactory.createTitledBorder(CodeInsightBundle.message(\"templates.dialog.edit.variables.border.title\")));\n    panel.setLayout(new BorderLayout());\n    panel.add(createVariablesTable(), BorderLayout.CENTER);\n    if (hasMoveVars) panel.add(createTableButtonPanel(), BorderLayout.EAST);\n    return panel;\n  }","commit_id":"b674a8861587f179e2fe289aa8305fd5cc9537e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public EditVariableDialog(Editor editor, Component parent, ArrayList<Variable> variables, boolean _hasMoveVars, java.util.List<Macro> _additionalMacros) {\n    super(parent, true);\n\n    hasMoveVars = _hasMoveVars;\n    additionalMacros = _additionalMacros;\n    setButtonsMargin(null);\n    myVariables = variables;\n    myEditor = editor;\n    init();\n    setTitle(CodeInsightBundle.message(\"templates.dialog.edit.variables.title\"));\n    setOKButtonText(CommonBundle.getOkButtonText());\n    updateButtons();\n  }","id":74232,"modified_method":"public EditVariableDialog(Editor editor, Component parent, ArrayList<Variable> variables, boolean _hasMoveVars, List<Macro> _additionalMacros) {\n    super(parent, true);\n\n    hasMoveVars = _hasMoveVars;\n    additionalMacros = _additionalMacros;\n    setButtonsMargin(null);\n    myVariables = variables;\n    myEditor = editor;\n    init();\n    setTitle(CodeInsightBundle.message(\"templates.dialog.edit.variables.title\"));\n    setOKButtonText(CommonBundle.getOkButtonText());\n    updateButtons();\n  }","commit_id":"b674a8861587f179e2fe289aa8305fd5cc9537e4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private FieldSelector buildFieldSelectors(SearchContext context) {\n        if (context.hasScriptFields() && !context.hasFieldNames()) {\n            // we ask for script fields, and no field names, don't load the source\n            return UidFieldSelector.INSTANCE;\n        }\n\n        if (!context.hasFieldNames()) {\n            return new UidAndSourceFieldSelector();\n        }\n\n        if (context.fieldNames().isEmpty()) {\n            return UidFieldSelector.INSTANCE;\n        }\n\n        // asked for all stored fields, just return null so all of them will be loaded\n        if (context.fieldNames().get(0).equals(\"*\")) {\n            return null;\n        }\n\n        FieldMappersFieldSelector fieldSelector = new FieldMappersFieldSelector();\n        for (String fieldName : context.fieldNames()) {\n            FieldMappers x = context.mapperService().smartNameFieldMappers(fieldName);\n            if (x == null) {\n                throw new FetchPhaseExecutionException(context, \"No mapping for field [\" + fieldName + \"]\");\n            }\n            fieldSelector.add(x);\n        }\n        fieldSelector.add(UidFieldMapper.NAME);\n        return fieldSelector;\n    }","id":74233,"modified_method":"private FieldSelector buildFieldSelectors(SearchContext context) {\n        if (context.hasScriptFields() && !context.hasFieldNames()) {\n            // we ask for script fields, and no field names, don't load the source\n            return UidFieldSelector.INSTANCE;\n        }\n\n        if (!context.hasFieldNames()) {\n            return new UidAndSourceFieldSelector();\n        }\n\n        if (context.fieldNames().isEmpty()) {\n            return UidFieldSelector.INSTANCE;\n        }\n\n        // asked for all stored fields, just return null so all of them will be loaded\n        // don't load the source field in this case, makes little sense to get it with all stored fields\n        if (context.fieldNames().get(0).equals(\"*\")) {\n            return AllButSourceFieldSelector.INSTANCE;\n        }\n\n        FieldMappersFieldSelector fieldSelector = new FieldMappersFieldSelector();\n        for (String fieldName : context.fieldNames()) {\n            FieldMappers x = context.mapperService().smartNameFieldMappers(fieldName);\n            if (x == null) {\n                throw new FetchPhaseExecutionException(context, \"No mapping for field [\" + fieldName + \"]\");\n            }\n            fieldSelector.add(x);\n        }\n        fieldSelector.add(UidFieldMapper.NAME);\n        return fieldSelector;\n    }","commit_id":"a1df3c637c14af5572e9e0bed42a4c38e7770239","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void parse(XContentParser parser, SearchContext context) throws Exception {\n        XContentParser.Token token = parser.currentToken();\n        if (token == XContentParser.Token.START_ARRAY) {\n            boolean added = false;\n            while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                added = true;\n                String name = parser.text();\n                if (name.contains(\"_source.\") || name.contains(\"doc[\")) {\n                    // script field to load from source\n                    SearchScript searchScript = new SearchScript(context.lookup(), null, name, null, context.scriptService());\n                    context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript));\n                } else {\n                    FieldMapper fieldMapper = context.mapperService().smartNameFieldMapper(name);\n                    if (!\"*\".equals(name) && (fieldMapper == null || !fieldMapper.stored())) {\n                        // script field to load from source\n                        SearchScript searchScript = new SearchScript(context.lookup(), null, \"_source.\" + name, null, context.scriptService());\n                        context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript));\n                    } else {\n                        context.fieldNames().add(name);\n                    }\n                }\n            }\n            if (!added) {\n                context.emptyFieldNames();\n            }\n        } else if (token == XContentParser.Token.VALUE_STRING) {\n            String name = parser.text();\n            if (name.contains(\"_source.\") || name.contains(\"doc[\")) {\n                // script field to load from source\n                SearchScript searchScript = new SearchScript(context.lookup(), null, name, null, context.scriptService());\n                context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript));\n            } else {\n                FieldMapper fieldMapper = context.mapperService().smartNameFieldMapper(name);\n                if (!\"*\".equals(name) && (fieldMapper == null || !fieldMapper.stored())) {\n                    // script field to load from source\n                    SearchScript searchScript = new SearchScript(context.lookup(), null, \"_source.\" + name, null, context.scriptService());\n                    context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript));\n                } else {\n                    context.fieldNames().add(name);\n                }\n            }\n        }\n    }","id":74234,"modified_method":"@Override public void parse(XContentParser parser, SearchContext context) throws Exception {\n        XContentParser.Token token = parser.currentToken();\n        if (token == XContentParser.Token.START_ARRAY) {\n            boolean added = false;\n            while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {\n                String name = parser.text();\n                if (name.contains(\"_source.\") || name.contains(\"doc[\")) {\n                    // script field to load from source\n                    SearchScript searchScript = new SearchScript(context.lookup(), null, name, null, context.scriptService());\n                    context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript, true));\n                } else {\n                    if (\"*\".equals(name)) {\n                        added = true;\n                        context.fieldNames().add(\"*\");\n                    } else {\n                        FieldMapper fieldMapper = context.mapperService().smartNameFieldMapper(name);\n                        if (fieldMapper != null) {\n                            if (fieldMapper.stored()) {\n                                added = true;\n                                context.fieldNames().add(name);\n                            } else {\n                                SearchScript searchScript = new SearchScript(context.lookup(), \"mvel\", \"_source.\" + fieldMapper.names().fullName(), null, context.scriptService());\n                                context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript, true));\n                            }\n                        }\n                    }\n                }\n            }\n            if (!added) {\n                context.emptyFieldNames();\n            }\n        } else if (token == XContentParser.Token.VALUE_STRING) {\n            String name = parser.text();\n            if (name.contains(\"_source.\") || name.contains(\"doc[\")) {\n                // script field to load from source\n                SearchScript searchScript = new SearchScript(context.lookup(), null, name, null, context.scriptService());\n                context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript, true));\n            } else {\n                if (\"*\".equals(name)) {\n                    context.fieldNames().add(\"*\");\n                } else {\n                    FieldMapper fieldMapper = context.mapperService().smartNameFieldMapper(name);\n                    if (fieldMapper != null) {\n                        if (fieldMapper.stored()) {\n                            context.fieldNames().add(name);\n                        } else {\n                            SearchScript searchScript = new SearchScript(context.lookup(), \"mvel\", \"_source.\" + fieldMapper.names().fullName(), null, context.scriptService());\n                            context.scriptFields().add(new ScriptFieldsContext.ScriptField(name, searchScript, true));\n                        }\n                    } else {\n                        context.emptyFieldNames(); // don't load anything if we can't find mapping\n                    }\n                }\n            }\n        }\n    }","commit_id":"a1df3c637c14af5572e9e0bed42a4c38e7770239","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public ScriptField(String name, SearchScript script) {\n            this.name = name;\n            this.script = script;\n        }","id":74235,"modified_method":"public ScriptField(String name, SearchScript script, boolean ignoreException) {\n            this.name = name;\n            this.script = script;\n            this.ignoreException = ignoreException;\n        }","commit_id":"a1df3c637c14af5572e9e0bed42a4c38e7770239","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void parse(XContentParser parser, SearchContext context) throws Exception {\n        XContentParser.Token token;\n        String currentFieldName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                String fieldName = currentFieldName;\n                String script = null;\n                String scriptLang = null;\n                Map<String, Object> params = null;\n                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                    if (token == XContentParser.Token.FIELD_NAME) {\n                        currentFieldName = parser.currentName();\n                    } else if (token == XContentParser.Token.START_OBJECT) {\n                        params = parser.map();\n                    } else if (token.isValue()) {\n                        if (\"script\".equals(currentFieldName)) {\n                            script = parser.text();\n                        } else if (\"lang\".equals(currentFieldName)) {\n                            scriptLang = parser.text();\n                        }\n                    }\n                }\n                SearchScript searchScript = new SearchScript(context.lookup(), scriptLang, script, params, context.scriptService());\n                context.scriptFields().add(new ScriptFieldsContext.ScriptField(fieldName, searchScript));\n            }\n        }\n    }","id":74236,"modified_method":"@Override public void parse(XContentParser parser, SearchContext context) throws Exception {\n        XContentParser.Token token;\n        String currentFieldName = null;\n        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n            if (token == XContentParser.Token.FIELD_NAME) {\n                currentFieldName = parser.currentName();\n            } else if (token == XContentParser.Token.START_OBJECT) {\n                String fieldName = currentFieldName;\n                String script = null;\n                String scriptLang = null;\n                Map<String, Object> params = null;\n                boolean ignoreException = false;\n                while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n                    if (token == XContentParser.Token.FIELD_NAME) {\n                        currentFieldName = parser.currentName();\n                    } else if (token == XContentParser.Token.START_OBJECT) {\n                        params = parser.map();\n                    } else if (token.isValue()) {\n                        if (\"script\".equals(currentFieldName)) {\n                            script = parser.text();\n                        } else if (\"lang\".equals(currentFieldName)) {\n                            scriptLang = parser.text();\n                        } else if (\"ignore_failure\".equals(currentFieldName)) {\n                            ignoreException = parser.booleanValue();\n                        }\n                    }\n                }\n                SearchScript searchScript = new SearchScript(context.lookup(), scriptLang, script, params, context.scriptService());\n                context.scriptFields().add(new ScriptFieldsContext.ScriptField(fieldName, searchScript, ignoreException));\n            }\n        }\n    }","commit_id":"a1df3c637c14af5572e9e0bed42a4c38e7770239","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void execute(SearchContext context, InternalSearchHit hit, Uid uid, IndexReader reader, int docId) throws ElasticSearchException {\n        for (ScriptFieldsContext.ScriptField scriptField : context.scriptFields().fields()) {\n            scriptField.script().setNextReader(reader);\n\n            Object value = scriptField.script().execute(docId);\n\n            if (hit.fieldsOrNull() == null) {\n                hit.fields(new HashMap<String, SearchHitField>(2));\n            }\n\n            SearchHitField hitField = hit.fields().get(scriptField.name());\n            if (hitField == null) {\n                hitField = new InternalSearchHitField(scriptField.name(), new ArrayList<Object>(2));\n                hit.fields().put(scriptField.name(), hitField);\n            }\n            hitField.values().add(value);\n        }\n    }","id":74237,"modified_method":"@Override public void execute(SearchContext context, InternalSearchHit hit, Uid uid, IndexReader reader, int docId) throws ElasticSearchException {\n        for (ScriptFieldsContext.ScriptField scriptField : context.scriptFields().fields()) {\n            scriptField.script().setNextReader(reader);\n\n            Object value;\n            try {\n                value = scriptField.script().execute(docId);\n            } catch (RuntimeException e) {\n                if (scriptField.ignoreException()) {\n                    continue;\n                }\n                throw e;\n            }\n\n            if (hit.fieldsOrNull() == null) {\n                hit.fields(new HashMap<String, SearchHitField>(2));\n            }\n\n            SearchHitField hitField = hit.fields().get(scriptField.name());\n            if (hitField == null) {\n                hitField = new InternalSearchHitField(scriptField.name(), new ArrayList<Object>(2));\n                hit.fields().put(scriptField.name(), hitField);\n            }\n            hitField.values().add(value);\n        }\n    }","commit_id":"a1df3c637c14af5572e9e0bed42a4c38e7770239","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListResourceCollector#getResources(org.opencms.file.CmsObject, java.util.Map)\n     */\n    @Override\n    public List<CmsResource> getResources(CmsObject cms, Map<String, String> params) throws CmsException {\n\n        List<CmsSearchResult> result = getSearchResults(params);\n        int count = getSearchBean(params).getSearchResultCount();\n        CmsResource[] resources = new CmsResource[count];\n        int from = (getSearchBean(params).getSearchPage() - 1) * getSearchBean(params).getMatchesPerPage();\n        int siteLen = cms.getRequestContext().getSiteRoot().length();\n\n        Iterator<CmsSearchResult> it = result.iterator();\n        while (it.hasNext()) {\n            CmsSearchResult sr = it.next();\n            CmsResource resource = cms.readResource(sr.getPath().substring(siteLen), CmsResourceFilter.ALL);\n            m_resCache.put(resource.getStructureId().toString(), resource);\n            m_srCache.put(resource.getStructureId().toString(), sr);\n            resources[from] = resource;\n            from++;\n        }\n        return Arrays.asList(resources);\n    }","id":74238,"modified_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListResourceCollector#getResources(org.opencms.file.CmsObject, java.util.Map)\n     */\n    @Override\n    public List<CmsResource> getResources(CmsObject cms, Map<String, String> params) {\n\n        List<CmsSearchResult> result = getSearchResults(params);\n        List<CmsResource> resources = new ArrayList<CmsResource>();\n        String siteRoot = cms.getRequestContext().getSiteRoot();\n        int siteLen = siteRoot.length();\n        for (CmsSearchResult sr : result) {\n            try {\n                String resultPath = sr.getPath();\n                if (resultPath.startsWith(siteRoot)) {\n                    resultPath = sr.getPath().substring(siteLen);\n                }\n                CmsResource resource = cms.readResource(resultPath, CmsResourceFilter.ALL);\n                m_resCache.put(resource.getStructureId().toString(), resource);\n                m_srCache.put(resource.getStructureId().toString(), sr);\n                resources.add(resource);\n            } catch (CmsException e) {\n                LOG.warn(e.getLocalizedMessage(), e);\n            }\n        }\n        return resources;\n    }","commit_id":"503a09bc283e13985a7c43e28bf29a1ec3ef8fd7","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListResourceCollector#getResources(org.opencms.file.CmsObject, java.util.Map)\n     */\n    @Override\n    public List<CmsResource> getResources(CmsObject cms, Map<String, String> params) throws CmsException {\n\n        List<CmsSearchResult> result = getSearchResults(params);\n        int count = getSearchBean(params).getSearchResultCount();\n        CmsResource[] resources = new CmsResource[count];\n        int from = (getSearchBean(params).getSearchPage() - 1) * getSearchBean(params).getMatchesPerPage();\n        int siteLen = cms.getRequestContext().getSiteRoot().length();\n\n        Iterator<CmsSearchResult> it = result.iterator();\n        while (it.hasNext()) {\n            CmsSearchResult sr = it.next();\n            CmsResource resource = cms.readResource(sr.getPath().substring(siteLen), CmsResourceFilter.ALL);\n            m_resCache.put(resource.getStructureId().toString(), resource);\n            m_srCache.put(resource.getStructureId().toString(), sr);\n            resources[from] = resource;\n            from++;\n        }\n        return Arrays.asList(resources);\n    }","id":74239,"modified_method":"/**\n     * @see org.opencms.workplace.list.A_CmsListResourceCollector#getResources(org.opencms.file.CmsObject, java.util.Map)\n     */\n    @Override\n    public List<CmsResource> getResources(CmsObject cms, Map<String, String> params) {\n\n        List<CmsSearchResult> result = getSearchResults(params);\n        List<CmsResource> resources = new ArrayList<CmsResource>();\n        String siteRoot = cms.getRequestContext().getSiteRoot();\n        int siteLen = siteRoot.length();\n        for (CmsSearchResult sr : result) {\n            try {\n                String resultPath = sr.getPath();\n                if (resultPath.startsWith(siteRoot)) {\n                    resultPath = sr.getPath().substring(siteLen);\n                }\n                CmsResource resource = cms.readResource(resultPath, CmsResourceFilter.ALL);\n                m_resCache.put(resource.getStructureId().toString(), resource);\n                m_srCache.put(resource.getStructureId().toString(), sr);\n                resources.add(resource);\n            } catch (CmsException e) {\n                LOG.warn(e.getLocalizedMessage(), e);\n            }\n        }\n        return resources;\n    }","commit_id":"a6d450e5380c6c79184a58000f6c48bb9f782032","url":"https://github.com/alkacon/opencms-core"},{"original_method":"/**\r\n     * Tries to get the subsite root for a given resource root path.<p>\r\n     * \r\n     * @param cms the current CMS context \r\n     * @param rootPath the root path for which the subsite root should be found \r\n     * \r\n     * @return the subsite root \r\n     */\r\n    public String getSubSiteRoot(CmsObject cms, String rootPath) {\r\n\r\n        CmsADEConfigData configData = lookupConfiguration(cms, rootPath);\r\n        String basePath = configData.getBasePath();\r\n        if (basePath == null) {\r\n            return OpenCms.getSiteManager().getSiteRoot(rootPath);\r\n        } else {\r\n            return basePath;\r\n        }\r\n    }","id":74240,"modified_method":"/**\r\n     * Tries to get the subsite root for a given resource root path.<p>\r\n     * \r\n     * @param cms the current CMS context \r\n     * @param rootPath the root path for which the subsite root should be found \r\n     * \r\n     * @return the subsite root \r\n     */\r\n    public String getSubSiteRoot(CmsObject cms, String rootPath) {\r\n\r\n        CmsADEConfigData configData = lookupConfiguration(cms, rootPath);\r\n        String basePath = configData.getBasePath();\r\n        String siteRoot = OpenCms.getSiteManager().getSiteRoot(rootPath);\r\n        if ((basePath == null) || !basePath.startsWith(siteRoot)) {\r\n            // the subsite root should always be below the site root\r\n            return siteRoot;\r\n        } else {\r\n            return basePath;\r\n        }\r\n    }","commit_id":"e634cf9e3388bd5a949fe15988be8ef662f0eae4","url":"https://github.com/alkacon/opencms-core"},{"original_method":"public PutObjectResponseType putObject(PutObjectType request)\n\tthrows EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request\n\t\t.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request\n\t\t.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\t\t\tif (logData != null)\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\tString objectName;\n\t\t\t\t\t\tString versionId;\n\t\t\t\t\t\tObjectInfo objectInfo = null;\n\t\t\t\t\t\tif (bucket.isVersioningEnabled()) {\n\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\tversionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tversionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObjectInfo foundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\tif (!foundObject.canWrite(userId)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t// writes are unconditional\n\t\t\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger\n\t\t\t\t\t\t.getQueue(key, randomKey);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\t\t\tlong size = 0;\n\t\t\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\t\t\twhile ((dataMessage = putQueue.take()) != null) {\n\t\t\t\t\t\t\t\tif(putQueue.getInterrupted()) {                                         \n\t\t\t\t\t\t\t\t\tif(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\t\tif(monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\t\t\ttempObjectName = objectName + \".\"\n\t\t\t\t\t\t\t\t\t+ Hashes.getRandom(12);\n\t\t\t\t\t\t\t\t\tdigest = Digest.MD5.get();\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(\n\t\t\t\t\t\t\t\t\t\t\t\tbucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t// commit object\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\ttempObjectName, objectName);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\t\t\tfor(ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tObjectInfo foundObject;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfoundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos,\n\t\t\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = dbObject\n\t\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tLOG\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\t\tif(objectInfo != null) {\n\t\t\t\t\t\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to update object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfoundObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\t\tfoundObject.setContentType(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentType());\n\t\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentDisposition());\n\t\t\t\t\t\t\t\t\tfoundObject.setLast(true);\n\t\t\t\t\t\t\t\t\tfoundObject.setDeleted(false);\n\t\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\t\tEntityWrapper<BucketInfo> dbBucket = dbObject.recast(BucketInfo.class);\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tbucket = dbBucket.getUnique(new BucketInfo(bucketName));\n\t\t\t\t\t\t\t\t\t} catch(EucalyptusCloudException e) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(e);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize\n\t\t\t\t\t\t\t\t\t+ size;\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.shouldEnforceUsageLimits\n\t\t\t\t\t\t\t\t\t\t\t&& !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\t\tif (newSize > (WalrusInfo.getWalrusInfo().getStorageMaxBucketSizeInMB() * WalrusProperties.M)) {\n\t\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(objectInfo != null)\n\t\t\t\t\t\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long\n\t\t\t\t\t\t\t\t\t\t\t\t.parseLong(new String(dataMessage\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPayload())));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// restart all interrupted puts\n\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tassert (WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t\t\t// start writing object (but do not commit yet)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// calculate md5 on the fly\n\t\t\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \"\n\t\t\t\t\t\t\t\t\t+ key + \".\" + randomKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(),\n\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t+ \".000Z\");\n\t\treturn reply;\n\t}","id":74241,"modified_method":"public PutObjectResponseType putObject(PutObjectType request)\n\tthrows EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request\n\t\t.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request\n\t\t.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\t\t\tif (logData != null)\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\tString objectName;\n\t\t\t\t\t\tString versionId;\n\t\t\t\t\t\tObjectInfo objectInfo = null;\n\t\t\t\t\t\tif (bucket.isVersioningEnabled()) {\n\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\tversionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tversionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObjectInfo foundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\tif (!foundObject.canWrite(userId)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\t\t\t} catch(AccessDeniedException ex) { \n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t// writes are unconditional\n\t\t\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger\n\t\t\t\t\t\t.getQueue(key, randomKey);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\t\t\tlong size = 0;\n\t\t\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\t\t\twhile ((dataMessage = putQueue.take()) != null) {\n\t\t\t\t\t\t\t\tif(putQueue.getInterrupted()) {                                         \n\t\t\t\t\t\t\t\t\tif(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\t\tif(monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\t\t\ttempObjectName = objectName + \".\"\n\t\t\t\t\t\t\t\t\t+ Hashes.getRandom(12);\n\t\t\t\t\t\t\t\t\tdigest = Digest.MD5.get();\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(\n\t\t\t\t\t\t\t\t\t\t\t\tbucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t// commit object\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\ttempObjectName, objectName);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\t\t\tfor(ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tObjectInfo foundObject;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfoundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos,\n\t\t\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = dbObject\n\t\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tLOG\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\t\tif(objectInfo != null) {\n\t\t\t\t\t\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to update object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfoundObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\t\tfoundObject.setContentType(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentType());\n\t\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentDisposition());\n\t\t\t\t\t\t\t\t\tfoundObject.setLast(true);\n\t\t\t\t\t\t\t\t\tfoundObject.setDeleted(false);\n\t\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\t\tEntityWrapper<BucketInfo> dbBucket = dbObject.recast(BucketInfo.class);\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tbucket = dbBucket.getUnique(new BucketInfo(bucketName));\n\t\t\t\t\t\t\t\t\t} catch(EucalyptusCloudException e) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(e);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize\n\t\t\t\t\t\t\t\t\t+ size;\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.shouldEnforceUsageLimits\n\t\t\t\t\t\t\t\t\t\t\t&& !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\t\tif (newSize > (WalrusInfo.getWalrusInfo().getStorageMaxBucketSizeInMB() * WalrusProperties.M)) {\n\t\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(objectInfo != null)\n\t\t\t\t\t\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long\n\t\t\t\t\t\t\t\t\t\t\t\t.parseLong(new String(dataMessage\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPayload())));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// restart all interrupted puts\n\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tassert (WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t\t\t// start writing object (but do not commit yet)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// calculate md5 on the fly\n\t\t\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \"\n\t\t\t\t\t\t\t\t\t+ key + \".\" + randomKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(),\n\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t+ \".000Z\");\n\t\treturn reply;\n\t}","commit_id":"3eccdb5d256c90f6158c9a539374510f6f3815f9","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpResponse ) {\n\t\t\tMappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );\n\t\t\tEucalyptusMessage msg = (EucalyptusMessage) httpResponse.getMessage( );\n\t\t\tBinding binding;\n\n\t\t\tif(!(msg instanceof EucalyptusErrorMessageType)) {\n\t\t\t\tif(msg instanceof PutObjectResponseType) {\n\t\t\t\t\tif(putQueue != null) {\n\t\t\t\t\t\tputQueue = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( namespace ) );\n\t\t\t\tif(msg instanceof PutObjectResponseType) {\n\t\t\t\t\tif(putQueue != null) {\n\t\t\t\t\t\tputQueue = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( \"http://msgs.eucalyptus.com\" ) );\n\t\t\t\tif(putQueue != null) {\n\t\t\t\t\tputQueue = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(msg != null) {\n\t\t\t\tOMElement omMsg = binding.toOM( msg );\n\t\t\t\tByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n\t\t\t\tHoldMe.canHas.lock(); \n\t\t\t\ttry {\n\t\t\t\t\tomMsg.serialize( byteOut );\n\t\t\t\t} finally {\n\t\t\t\t\tHoldMe.canHas.unlock();\n\t\t\t\t}\n\t\t\t\tbyte[] req = byteOut.toByteArray();\n\t\t\t\tChannelBuffer buffer = ChannelBuffers.copiedBuffer( req );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buffer.readableBytes() ) );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, \"application/xml\" );\n\t\t\t\thttpResponse.setContent( buffer );\n\t\t\t}\n\t\t}\n\t}","id":74242,"modified_method":"@Override\n\tpublic void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpResponse ) {\n\t\t\tMappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );\n\t\t\tEucalyptusMessage msg = (EucalyptusMessage) httpResponse.getMessage( );\n\t\t\tBinding binding;\n\n\t\t\tif(!(msg instanceof EucalyptusErrorMessageType)) {\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( namespace ) );\n\t\t\t\tif(putQueue != null) {\n\t\t\t\t\tputQueue = null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( \"http://msgs.eucalyptus.com\" ) );\n\t\t\t\tif(putQueue != null) {\n\t\t\t\t\tputQueue = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(msg != null) {\n\t\t\t\tOMElement omMsg = binding.toOM( msg );\n\t\t\t\tByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n\t\t\t\tHoldMe.canHas.lock(); \n\t\t\t\ttry {\n\t\t\t\t\tomMsg.serialize( byteOut );\n\t\t\t\t} finally {\n\t\t\t\t\tHoldMe.canHas.unlock();\n\t\t\t\t}\n\t\t\t\tbyte[] req = byteOut.toByteArray();\n\t\t\t\tChannelBuffer buffer = ChannelBuffers.copiedBuffer( req );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buffer.readableBytes() ) );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, \"application/xml\" );\n\t\t\t\thttpResponse.setContent( buffer );\n\t\t\t}\n\t\t}\n\t}","commit_id":"3eccdb5d256c90f6158c9a539374510f6f3815f9","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void handleHttpChunk(HttpChunk httpChunk) throws Exception {\n\t\tChannelBuffer buffer = httpChunk.getContent();\n\t\ttry {\n\t\t\tbuffer.markReaderIndex( );\n\t\t\tbyte[] read = new byte[buffer.readableBytes( )];\n\t\t\tbuffer.readBytes( read );\n\t\t\tputQueue.put(WalrusDataMessage.DataMessage(read));\n\t\t\tif(httpChunk.isLast())\n\t\t\t\tputQueue.put(WalrusDataMessage.EOF());\n\n\t\t} catch (Exception ex) {\n\t\t\tLOG.error(ex, ex);\n\t\t}\n\n\t}","id":74243,"modified_method":"private void handleHttpChunk(HttpChunk httpChunk) throws Exception {\n\t\tChannelBuffer buffer = httpChunk.getContent();\n\t\ttry {\n\t\t\tbuffer.markReaderIndex( );\n\t\t\tbyte[] read = new byte[buffer.readableBytes( )];\n\t\t\tbuffer.readBytes( read );\n\t\t\twhile(!putQueue.offer(WalrusDataMessage.DataMessage(read), 500, TimeUnit.MILLISECONDS));\n\t\t\tif(httpChunk.isLast()) {\n\t\t\t\twhile(!putQueue.offer(WalrusDataMessage.EOF(), 1000, TimeUnit.MILLISECONDS));\n\t\t\t}\n\t\t} catch(NullPointerException ex) {\n\t\t\t//ignore NPEs (they are intentional if an exception has been thrown\n\t\t} catch (Exception ex) {\n\t\t\tLOG.error(ex, ex);\n\t\t}\n\n\t}","commit_id":"3eccdb5d256c90f6158c9a539374510f6f3815f9","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public PutObjectResponseType putObject(PutObjectType request)\n\tthrows EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request\n\t\t.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request\n\t\t.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\t\t\tif (logData != null)\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\tString objectName;\n\t\t\t\t\t\tString versionId;\n\t\t\t\t\t\tObjectInfo objectInfo = null;\n\t\t\t\t\t\tif (bucket.isVersioningEnabled()) {\n\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\tversionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tversionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObjectInfo foundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\tif (!foundObject.canWrite(userId)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t// writes are unconditional\n\t\t\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger\n\t\t\t\t\t\t.getQueue(key, randomKey);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\t\t\tlong size = 0;\n\t\t\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\t\t\twhile ((dataMessage = putQueue.take()) != null) {\n\t\t\t\t\t\t\t\tif(putQueue.getInterrupted()) {                                         \n\t\t\t\t\t\t\t\t\tif(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\t\tif(monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\t\t\ttempObjectName = objectName + \".\"\n\t\t\t\t\t\t\t\t\t+ Hashes.getRandom(12);\n\t\t\t\t\t\t\t\t\tdigest = Digest.MD5.get();\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(\n\t\t\t\t\t\t\t\t\t\t\t\tbucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t// commit object\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\ttempObjectName, objectName);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\t\t\tfor(ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tObjectInfo foundObject;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfoundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos,\n\t\t\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = dbObject\n\t\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tLOG\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\t\tif(objectInfo != null) {\n\t\t\t\t\t\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to update object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfoundObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\t\tfoundObject.setContentType(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentType());\n\t\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentDisposition());\n\t\t\t\t\t\t\t\t\tfoundObject.setLast(true);\n\t\t\t\t\t\t\t\t\tfoundObject.setDeleted(false);\n\t\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\t\tEntityWrapper<BucketInfo> dbBucket = dbObject.recast(BucketInfo.class);\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tbucket = dbBucket.getUnique(new BucketInfo(bucketName));\n\t\t\t\t\t\t\t\t\t} catch(EucalyptusCloudException e) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(e);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize\n\t\t\t\t\t\t\t\t\t+ size;\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.shouldEnforceUsageLimits\n\t\t\t\t\t\t\t\t\t\t\t&& !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\t\tif (newSize > (WalrusInfo.getWalrusInfo().getStorageMaxBucketSizeInMB() * WalrusProperties.M)) {\n\t\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(objectInfo != null)\n\t\t\t\t\t\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long\n\t\t\t\t\t\t\t\t\t\t\t\t.parseLong(new String(dataMessage\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPayload())));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// restart all interrupted puts\n\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tassert (WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t\t\t// start writing object (but do not commit yet)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// calculate md5 on the fly\n\t\t\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \"\n\t\t\t\t\t\t\t\t\t+ key + \".\" + randomKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(),\n\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t+ \".000Z\");\n\t\treturn reply;\n\t}","id":74244,"modified_method":"public PutObjectResponseType putObject(PutObjectType request)\n\tthrows EucalyptusCloudException {\n\t\tPutObjectResponseType reply = (PutObjectResponseType) request\n\t\t.getReply();\n\t\tString userId = request.getUserId();\n\n\t\tString bucketName = request.getBucket();\n\t\tString objectKey = request.getKey();\n\n\t\tLong oldBucketSize = 0L;\n\n\t\tString md5 = \"\";\n\t\tDate lastModified = null;\n\n\t\tAccessControlListType accessControlList = request\n\t\t.getAccessControlList();\n\t\tif (accessControlList == null) {\n\t\t\taccessControlList = new AccessControlListType();\n\t\t}\n\n\t\tString key = bucketName + \".\" + objectKey;\n\t\tString randomKey = request.getRandomKey();\n\t\tWalrusDataMessenger messenger = WalrusRESTBinding.getWriteMessenger();\n\n\t\tEntityWrapper<BucketInfo> db = WalrusControl.getEntityWrapper();\n\t\tBucketInfo bucketInfo = new BucketInfo(bucketName);\n\t\tList<BucketInfo> bucketList = db.query(bucketInfo);\n\n\t\tif (bucketList.size() > 0) {\n\t\t\tBucketInfo bucket = bucketList.get(0);\n\t\t\tBucketLogData logData = bucket.getLoggingEnabled() ? request\n\t\t\t\t\t.getLogData() : null;\n\t\t\t\t\tif (bucket.canWrite(userId)) {\n\t\t\t\t\t\tif (logData != null)\n\t\t\t\t\t\t\treply.setLogData(logData);\n\t\t\t\t\t\tString objectName;\n\t\t\t\t\t\tString versionId;\n\t\t\t\t\t\tObjectInfo objectInfo = null;\n\t\t\t\t\t\tif (bucket.isVersioningEnabled()) {\n\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\tversionId = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tversionId = WalrusProperties.NULL_VERSION_ID;\n\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = db.recast(ObjectInfo.class);\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tObjectInfo foundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\tif (!foundObject.canWrite(userId)) {\n\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tthrow new AccessDeniedException(\"Key\", objectKey,\n\t\t\t\t\t\t\t\t\t\t\tlogData);\n\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\tobjectName = foundObject.getObjectName();\n\t\t\t\t\t\t\t} catch(AccessDeniedException ex) { \n\t\t\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\tobjectInfo = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\tobjectInfo.setOwnerId(userId);\n\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\tobjectInfo.addGrants(userId, grantInfos, accessControlList);\n\t\t\t\t\t\t\t\tobjectInfo.setGrants(grantInfos);\n\t\t\t\t\t\t\t\tobjectName = objectKey.replaceAll(\"/\", \"-\")\n\t\t\t\t\t\t\t\t+ Hashes.getRandom(4);\n\t\t\t\t\t\t\t\tobjectInfo.setObjectName(objectName);\n\t\t\t\t\t\t\t\tobjectInfo.setSize(0L);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t// writes are unconditional\n\t\t\t\t\t\tWalrusDataQueue<WalrusDataMessage> putQueue = messenger\n\t\t\t\t\t\t.getQueue(key, randomKey);\n\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tWalrusDataMessage dataMessage;\n\t\t\t\t\t\t\tString tempObjectName = objectName;\n\t\t\t\t\t\t\tMessageDigest digest = null;\n\t\t\t\t\t\t\tlong size = 0;\n\t\t\t\t\t\t\tFileIO fileIO = null;\n\t\t\t\t\t\t\twhile ((dataMessage = putQueue.take()) != null) {\n\t\t\t\t\t\t\t\tif(putQueue.getInterrupted()) {                                         \n\t\t\t\t\t\t\t\t\tif(WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\t\tif(monitor.getLastModified() == null) {\n\t\t\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\t\t\tmonitor.wait();\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tlastModified = monitor.getLastModified();\n\t\t\t\t\t\t\t\t\t\tmd5 = monitor.getMd5();\n\t\t\t\t\t\t\t\t\t\t//ok we are done here\n\t\t\t\t\t\t\t\t\t\tif(fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tObjectDeleter objectDeleter = new ObjectDeleter(bucketName, tempObjectName, -1L);\n\t\t\t\t\t\t\t\t\t\tobjectDeleter.start();\n\t\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer interrupted: \"+ key);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tbreak;  \n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (WalrusDataMessage.isStart(dataMessage)) {\n\t\t\t\t\t\t\t\t\ttempObjectName = objectName + \".\"\n\t\t\t\t\t\t\t\t\t+ Hashes.getRandom(12);\n\t\t\t\t\t\t\t\t\tdigest = Digest.MD5.get();\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfileIO = storageManager.prepareForWrite(\n\t\t\t\t\t\t\t\t\t\t\t\tbucketName, tempObjectName);\n\t\t\t\t\t\t\t\t\t} catch (Exception ex) {\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (WalrusDataMessage.isEOF(dataMessage)) {\n\t\t\t\t\t\t\t\t\t// commit object\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.finish();\n\t\t\t\t\t\t\t\t\t\tstorageManager.renameObject(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\ttempObjectName, objectName);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(objectKey);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tmd5 = Hashes.bytesToHex(digest.digest());\n\t\t\t\t\t\t\t\t\tlastModified = new Date();\n\t\t\t\t\t\t\t\t\tObjectInfo searchObject = new ObjectInfo(bucketName, objectKey);\n\t\t\t\t\t\t\t\t\tsearchObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tEntityWrapper<ObjectInfo> dbObject = WalrusControl.getEntityWrapper();\n\t\t\t\t\t\t\t\t\tList<ObjectInfo> objectInfos = dbObject.query(new ObjectInfo(bucketName, objectKey));\n\t\t\t\t\t\t\t\t\tfor(ObjectInfo objInfo : objectInfos) {\n\t\t\t\t\t\t\t\t\t\tobjInfo.setLast(false);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tObjectInfo foundObject;\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tfoundObject = dbObject.getUnique(searchObject);\n\t\t\t\t\t\t\t\t\t\tif (foundObject.canWriteACP(userId)) {\n\t\t\t\t\t\t\t\t\t\t\tList<GrantInfo> grantInfos = new ArrayList<GrantInfo>();\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.addGrants(userId, grantInfos,\n\t\t\t\t\t\t\t\t\t\t\t\t\taccessControlList);\n\t\t\t\t\t\t\t\t\t\t\tfoundObject.setGrants(grantInfos);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (WalrusProperties.enableTorrents) {\n\t\t\t\t\t\t\t\t\t\t\tEntityWrapper<TorrentInfo> dbTorrent = dbObject\n\t\t\t\t\t\t\t\t\t\t\t.recast(TorrentInfo.class);\n\t\t\t\t\t\t\t\t\t\t\tTorrentInfo torrentInfo = new TorrentInfo(bucketName,\n\t\t\t\t\t\t\t\t\t\t\t\t\tobjectKey);\n\t\t\t\t\t\t\t\t\t\t\tList<TorrentInfo> torrentInfos = dbTorrent\n\t\t\t\t\t\t\t\t\t\t\t.query(torrentInfo);\n\t\t\t\t\t\t\t\t\t\t\tif (torrentInfos.size() > 0) {\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentInfo foundTorrentInfo = torrentInfos.get(0);\n\t\t\t\t\t\t\t\t\t\t\t\tTorrentClient torrentClient = Torrents\n\t\t\t\t\t\t\t\t\t\t\t\t.getClient(bucketName + objectKey);\n\t\t\t\t\t\t\t\t\t\t\t\tif (torrentClient != null) {\n\t\t\t\t\t\t\t\t\t\t\t\t\ttorrentClient.bye();\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tdbTorrent.delete(foundTorrentInfo);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tLOG\n\t\t\t\t\t\t\t\t\t\t\t.warn(\"Bittorrent support has been disabled. Please check pre-requisites\");\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (EucalyptusCloudException ex) {\n\t\t\t\t\t\t\t\t\t\tif(objectInfo != null) {\n\t\t\t\t\t\t\t\t\t\t\tfoundObject = objectInfo;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to update object: \" + bucketName + \"/\" + objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tfoundObject.setVersionId(versionId);\n\t\t\t\t\t\t\t\t\tfoundObject.replaceMetaData(request.getMetaData());\n\t\t\t\t\t\t\t\t\tfoundObject.setEtag(md5);\n\t\t\t\t\t\t\t\t\tfoundObject.setSize(size);\n\t\t\t\t\t\t\t\t\tfoundObject.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\tfoundObject.setStorageClass(\"STANDARD\");\n\t\t\t\t\t\t\t\t\tfoundObject.setContentType(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentType());\n\t\t\t\t\t\t\t\t\tfoundObject.setContentDisposition(request\n\t\t\t\t\t\t\t\t\t\t\t.getContentDisposition());\n\t\t\t\t\t\t\t\t\tfoundObject.setLast(true);\n\t\t\t\t\t\t\t\t\tfoundObject.setDeleted(false);\n\t\t\t\t\t\t\t\t\treply.setSize(size);\n\t\t\t\t\t\t\t\t\tEntityWrapper<BucketInfo> dbBucket = dbObject.recast(BucketInfo.class);\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tbucket = dbBucket.getUnique(new BucketInfo(bucketName));\n\t\t\t\t\t\t\t\t\t} catch(EucalyptusCloudException e) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(e);\n\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tLong bucketSize = bucket.getBucketSize();\n\t\t\t\t\t\t\t\t\tlong newSize = bucketSize + oldBucketSize\n\t\t\t\t\t\t\t\t\t+ size;\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.shouldEnforceUsageLimits\n\t\t\t\t\t\t\t\t\t\t\t&& !request.isAdministrator()) {\n\t\t\t\t\t\t\t\t\t\tif (newSize > (WalrusInfo.getWalrusInfo().getStorageMaxBucketSizeInMB() * WalrusProperties.M)) {\n\t\t\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\t\t\tdbObject.rollback();\n\t\t\t\t\t\t\t\t\t\t\tthrow new EntityTooLargeException(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\"Key\", objectKey);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tbucket.setBucketSize(newSize);\n\t\t\t\t\t\t\t\t\tif (WalrusProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateBytesIn(size);\n\t\t\t\t\t\t\t\t\t\twalrusStatistics.updateSpaceUsed(size);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setObjectSize(size);\n\t\t\t\t\t\t\t\t\t\tupdateLogData(bucket, logData);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif(objectInfo != null)\n\t\t\t\t\t\t\t\t\t\tdbObject.add(foundObject);\n\t\t\t\t\t\t\t\t\tdbObject.commit();\n\t\t\t\t\t\t\t\t\tif (logData != null) {\n\t\t\t\t\t\t\t\t\t\tlogData.setTurnAroundTime(Long\n\t\t\t\t\t\t\t\t\t\t\t\t.parseLong(new String(dataMessage\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.getPayload())));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// restart all interrupted puts\n\t\t\t\t\t\t\t\t\tWalrusMonitor monitor = messenger.getMonitor(key);\n\t\t\t\t\t\t\t\t\tsynchronized (monitor) {\n\t\t\t\t\t\t\t\t\t\tmonitor.setLastModified(lastModified);\n\t\t\t\t\t\t\t\t\t\tmonitor.setMd5(md5);\n\t\t\t\t\t\t\t\t\t\tmonitor.notifyAll();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tmessenger.removeMonitor(key);\n\t\t\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\t\t\tLOG.info(\"Transfer complete: \" + key);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tassert (WalrusDataMessage.isData(dataMessage));\n\t\t\t\t\t\t\t\t\tbyte[] data = dataMessage.getPayload();\n\t\t\t\t\t\t\t\t\t// start writing object (but do not commit yet)\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tif (fileIO != null)\n\t\t\t\t\t\t\t\t\t\t\tfileIO.write(data);\n\t\t\t\t\t\t\t\t\t} catch (IOException ex) {\n\t\t\t\t\t\t\t\t\t\tLOG.error(ex);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// calculate md5 on the fly\n\t\t\t\t\t\t\t\t\tsize += data.length;\n\t\t\t\t\t\t\t\t\tif (digest != null)\n\t\t\t\t\t\t\t\t\t\tdigest.update(data);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (InterruptedException ex) {\n\t\t\t\t\t\t\tLOG.error(ex, ex);\n\t\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\t\tthrow new EucalyptusCloudException(\"Transfer interrupted: \"\n\t\t\t\t\t\t\t\t\t+ key + \".\" + randomKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\t\t\t\tthrow new AccessDeniedException(\"Bucket\", bucketName, logData);\n\t\t\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tmessenger.removeQueue(key, randomKey);\n\t\t\tthrow new NoSuchBucketException(bucketName);\n\t\t}\n\t\treply.setEtag(md5);\n\t\treply.setLastModified(DateUtils.format(lastModified.getTime(),\n\t\t\t\tDateUtils.ISO8601_DATETIME_PATTERN)\n\t\t\t\t+ \".000Z\");\n\t\treturn reply;\n\t}","commit_id":"5b1f6e0fc01bcedfdac3cab39acd185984fbac6f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void handleHttpChunk(HttpChunk httpChunk) throws Exception {\n\t\tChannelBuffer buffer = httpChunk.getContent();\n\t\ttry {\n\t\t\tbuffer.markReaderIndex( );\n\t\t\tbyte[] read = new byte[buffer.readableBytes( )];\n\t\t\tbuffer.readBytes( read );\n\t\t\tputQueue.put(WalrusDataMessage.DataMessage(read));\n\t\t\tif(httpChunk.isLast())\n\t\t\t\tputQueue.put(WalrusDataMessage.EOF());\n\n\t\t} catch (Exception ex) {\n\t\t\tLOG.error(ex, ex);\n\t\t}\n\n\t}","id":74245,"modified_method":"private void handleHttpChunk(HttpChunk httpChunk) throws Exception {\n\t\tChannelBuffer buffer = httpChunk.getContent();\n\t\ttry {\n\t\t\tbuffer.markReaderIndex( );\n\t\t\tbyte[] read = new byte[buffer.readableBytes( )];\n\t\t\tbuffer.readBytes( read );\n\t\t\twhile(!putQueue.offer(WalrusDataMessage.DataMessage(read), 500, TimeUnit.MILLISECONDS));\n\t\t\tif(httpChunk.isLast()) {\n\t\t\t\twhile(!putQueue.offer(WalrusDataMessage.EOF(), 1000, TimeUnit.MILLISECONDS));\n\t\t\t}\n\t\t} catch(NullPointerException ex) {\n\t\t\t//ignore NPEs (they are intentional if an exception has been thrown\n\t\t} catch (Exception ex) {\n\t\t\tLOG.error(ex, ex);\n\t\t}\n\n\t}","commit_id":"5b1f6e0fc01bcedfdac3cab39acd185984fbac6f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\tpublic void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpResponse ) {\n\t\t\tMappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );\n\t\t\tEucalyptusMessage msg = (EucalyptusMessage) httpResponse.getMessage( );\n\t\t\tBinding binding;\n\n\t\t\tif(!(msg instanceof EucalyptusErrorMessageType)) {\n\t\t\t\tif(msg instanceof PutObjectResponseType) {\n\t\t\t\t\tif(putQueue != null) {\n\t\t\t\t\t\tputQueue = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( namespace ) );\n\t\t\t\tif(msg instanceof PutObjectResponseType) {\n\t\t\t\t\tif(putQueue != null) {\n\t\t\t\t\t\tputQueue = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( \"http://msgs.eucalyptus.com\" ) );\n\t\t\t\tif(putQueue != null) {\n\t\t\t\t\tputQueue = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(msg != null) {\n\t\t\t\tOMElement omMsg = binding.toOM( msg );\n\t\t\t\tByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n\t\t\t\tHoldMe.canHas.lock(); \n\t\t\t\ttry {\n\t\t\t\t\tomMsg.serialize( byteOut );\n\t\t\t\t} finally {\n\t\t\t\t\tHoldMe.canHas.unlock();\n\t\t\t\t}\n\t\t\t\tbyte[] req = byteOut.toByteArray();\n\t\t\t\tChannelBuffer buffer = ChannelBuffers.copiedBuffer( req );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buffer.readableBytes() ) );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, \"application/xml\" );\n\t\t\t\thttpResponse.setContent( buffer );\n\t\t\t}\n\t\t}\n\t}","id":74246,"modified_method":"@Override\n\tpublic void outgoingMessage( ChannelHandlerContext ctx, MessageEvent event ) throws Exception {\n\t\tif ( event.getMessage( ) instanceof MappingHttpResponse ) {\n\t\t\tMappingHttpResponse httpResponse = ( MappingHttpResponse ) event.getMessage( );\n\t\t\tEucalyptusMessage msg = (EucalyptusMessage) httpResponse.getMessage( );\n\t\t\tBinding binding;\n\n\t\t\tif(!(msg instanceof EucalyptusErrorMessageType)) {\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( namespace ) );\n\t\t\t\tif(putQueue != null) {\n\t\t\t\t\tputQueue = null;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbinding = BindingManager.getBinding( BindingManager.sanitizeNamespace( \"http://msgs.eucalyptus.com\" ) );\n\t\t\t\tif(putQueue != null) {\n\t\t\t\t\tputQueue = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(msg != null) {\n\t\t\t\tOMElement omMsg = binding.toOM( msg );\n\t\t\t\tByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n\t\t\t\tHoldMe.canHas.lock(); \n\t\t\t\ttry {\n\t\t\t\t\tomMsg.serialize( byteOut );\n\t\t\t\t} finally {\n\t\t\t\t\tHoldMe.canHas.unlock();\n\t\t\t\t}\n\t\t\t\tbyte[] req = byteOut.toByteArray();\n\t\t\t\tChannelBuffer buffer = ChannelBuffers.copiedBuffer( req );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(buffer.readableBytes() ) );\n\t\t\t\thttpResponse.addHeader( HttpHeaders.Names.CONTENT_TYPE, \"application/xml\" );\n\t\t\t\thttpResponse.setContent( buffer );\n\t\t\t}\n\t\t}\n\t}","commit_id":"5b1f6e0fc01bcedfdac3cab39acd185984fbac6f","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Test\n    public void testLocalPluginWithoutFolders() throws Exception {\n        //When we don't have folders at all in the top-level, but only files, we don't modify anything\n        String pluginName = \"plugin-test\";\n        URL url = PluginManagerTests.class.getResource(\"plugin_without_folders.zip\");\n        downloadAndExtract(pluginName, \"file://\" + url.getFile());\n\n        cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","id":74247,"modified_method":"@Test\n    public void testLocalPluginWithoutFolders() throws Exception {\n        //When we don't have folders at all in the top-level, but only files, we don't modify anything\n        String pluginName = \"plugin-test\";\n        URI uri = URI.create(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").toString());\n        downloadAndExtract(pluginName, \"file://\" + uri.getPath());\n\n        cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testInstallSitePlugin() throws IOException {\n        PluginManager pluginManager = pluginManager(\"file://\".concat(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").getFile()));\n\n        pluginManager.downloadAndExtract(\"plugin-site\");\n        File[] plugins = pluginManager.getListInstalledPlugins();\n        assertThat(plugins, notNullValue());\n        assertThat(plugins.length, is(1));\n\n        // We want to check that Plugin Manager moves content to _site\n        String pluginDir = PLUGIN_DIR.concat(\"/plugin-site/_site\");\n        assertThat(FileSystemUtils.exists(new File(pluginDir)), is(true));\n    }","id":74248,"modified_method":"@Test\n    public void testInstallSitePlugin() throws IOException {\n        PluginManager pluginManager = pluginManager(\"file://\".concat(\n                URI.create(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").toString()).getPath()));\n\n        pluginManager.downloadAndExtract(\"plugin-site\");\n        File[] plugins = pluginManager.getListInstalledPlugins();\n        assertThat(plugins, notNullValue());\n        assertThat(plugins.length, is(1));\n\n        // We want to check that Plugin Manager moves content to _site\n        String pluginDir = PLUGIN_DIR.concat(\"/plugin-site/_site\");\n        assertThat(FileSystemUtils.exists(new File(pluginDir)), is(true));\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testInstallPlugin() throws IOException {\n        PluginManager pluginManager = pluginManager(\"file://\".concat(PluginManagerTests.class.getResource(\"plugin_with_classfile.zip\").getFile()));\n\n        pluginManager.downloadAndExtract(\"plugin\");\n        File[] plugins = pluginManager.getListInstalledPlugins();\n        assertThat(plugins, notNullValue());\n        assertThat(plugins.length, is(1));\n    }","id":74249,"modified_method":"@Test\n    public void testInstallPlugin() throws IOException {\n        PluginManager pluginManager = pluginManager(\"file://\".concat(\n                URI.create(PluginManagerTests.class.getResource(\"plugin_with_classfile.zip\").toString()).getPath()));\n\n        pluginManager.downloadAndExtract(\"plugin\");\n        File[] plugins = pluginManager.getListInstalledPlugins();\n        assertThat(plugins, notNullValue());\n        assertThat(plugins.length, is(1));\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLocalPluginInstallSiteFolder() throws Exception {\n        //When we have only a folder in top-level (no files either) but it's called _site, we make it work\n        //we can either remove the folder while extracting and then re-add it manually or just leave it as it is\n        String pluginName = \"plugin-test\";\n        URL url = PluginManagerTests.class.getResource(\"plugin_folder_site.zip\");\n        downloadAndExtract(pluginName, \"file://\" + url.getFile());\n\n        String nodeName = cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","id":74250,"modified_method":"@Test\n    public void testLocalPluginInstallSiteFolder() throws Exception {\n        //When we have only a folder in top-level (no files either) but it's called _site, we make it work\n        //we can either remove the folder while extracting and then re-add it manually or just leave it as it is\n        String pluginName = \"plugin-test\";\n        URI uri = URI.create(PluginManagerTests.class.getResource(\"plugin_folder_site.zip\").toString());\n        downloadAndExtract(pluginName, \"file://\" + uri.getPath());\n\n        String nodeName = cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLocalPluginFolderAndFile() throws Exception {\n        //When we have a single top-level folder but also files in the top-level, we don't modify anything\n        String pluginName = \"plugin-test\";\n        URL url = PluginManagerTests.class.getResource(\"plugin_folder_file.zip\");\n        downloadAndExtract(pluginName, \"file://\" + url.getFile());\n\n        cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","id":74251,"modified_method":"@Test\n    public void testLocalPluginFolderAndFile() throws Exception {\n        //When we have a single top-level folder but also files in the top-level, we don't modify anything\n        String pluginName = \"plugin-test\";\n        URI uri = URI.create(PluginManagerTests.class.getResource(\"plugin_folder_file.zip\").toString());\n        downloadAndExtract(pluginName, \"file://\" + uri.getPath());\n\n        cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testRemovePlugin() throws Exception {\n        // We want to remove plugin with plugin short name\n        singlePluginInstallAndRemove(\"plugintest\", \"file://\".concat(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").getFile()));\n\n        // We want to remove plugin with groupid/artifactid/version form\n        singlePluginInstallAndRemove(\"groupid/plugintest/1.0.0\", \"file://\".concat(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").getFile()));\n\n        // We want to remove plugin with groupid/artifactid form\n        singlePluginInstallAndRemove(\"groupid/plugintest\", \"file://\".concat(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").getFile()));\n    }","id":74252,"modified_method":"@Test\n    public void testRemovePlugin() throws Exception {\n        // We want to remove plugin with plugin short name\n        singlePluginInstallAndRemove(\"plugintest\", \"file://\".concat(\n                URI.create(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").toString()).getPath()));\n\n        // We want to remove plugin with groupid/artifactid/version form\n        singlePluginInstallAndRemove(\"groupid/plugintest/1.0.0\", \"file://\".concat(\n                URI.create(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").toString()).getPath()));\n\n        // We want to remove plugin with groupid/artifactid form\n        singlePluginInstallAndRemove(\"groupid/plugintest\", \"file://\".concat(\n                URI.create(PluginManagerTests.class.getResource(\"plugin_without_folders.zip\").toString()).getPath()));\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test(expected = IllegalArgumentException.class)\n    public void testSitePluginWithSourceThrows() throws Exception {\n        String pluginName = \"plugin-with-source\";\n        URL url = PluginManagerTests.class.getResource(\"plugin_with_sourcefiles.zip\");\n        downloadAndExtract(pluginName, \"file://\" + url.getFile());\n    }","id":74253,"modified_method":"@Test(expected = IllegalArgumentException.class)\n    public void testSitePluginWithSourceThrows() throws Exception {\n        String pluginName = \"plugin-with-source\";\n        URI uri = URI.create(PluginManagerTests.class.getResource(\"plugin_with_sourcefiles.zip\").toString());\n        downloadAndExtract(pluginName, \"file://\" + uri.getPath());\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Test\n    public void testLocalPluginInstallSingleFolder() throws Exception {\n        //When we have only a folder in top-level (no files either) we remove that folder while extracting\n        String pluginName = \"plugin-test\";\n        URL url = PluginManagerTests.class.getResource(\"plugin_single_folder.zip\");\n        downloadAndExtract(pluginName, \"file://\" + url.getFile());\n\n        cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","id":74254,"modified_method":"@Test\n    public void testLocalPluginInstallSingleFolder() throws Exception {\n        //When we have only a folder in top-level (no files either) we remove that folder while extracting\n        String pluginName = \"plugin-test\";\n        URI uri = URI.create(PluginManagerTests.class.getResource(\"plugin_single_folder.zip\").toString());\n        downloadAndExtract(pluginName, \"file://\" + uri.getPath());\n\n        cluster().startNode(SETTINGS);\n\n        assertPluginLoaded(pluginName);\n        assertPluginAvailable(pluginName);\n    }","commit_id":"2663d04a96f3c54cf2c55a45022181966486f503","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    GrExpression right = expression.getRightOperand();\n    final PsiType ltype = left.getType();\n    final PsiElement token = expression.getOperationToken();\n    final IElementType op = expression.getOperationTokenType();\n    if (GenerationSettings.dontReplaceOperatorsWithMethodsForNumbers &&\n        (TypesUtil.isNumericType(ltype) && (right == null || TypesUtil.isNumericType(right.getType())) ||\n         op == mPLUS && ltype != null && TypesUtil.typeEqualsToText(ltype, CommonClassNames.JAVA_LANG_STRING))) {\n      writeSimpleBinaryExpression(token, left, right);\n      return;\n    }\n\n    final GroovyResolveResult resolveResult = PsiImplUtil.extractUniqueResult(expression.multiResolve(false));\n    final PsiElement resolved = resolveResult.getElement();\n    if (resolved instanceof PsiMethod) {\n      if (right == null) {\n        right = factory.createExpressionFromText(\"null\");\n      }\n      invokeMethodOn(\n        ((PsiMethod)resolved),\n        left,\n        new GrExpression[]{right},\n        GrNamedArgument.EMPTY_ARRAY,\n        GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        expression\n      );\n      if (op == mGE) builder.append(\" >= 0\");\n      else if (op == mGT) builder.append(\" > 0\");\n      else if (op == mLT) builder.append(\" < 0\");\n      else if (op == mLE) builder.append(\" <= 0\");\n    }\n    else {\n      writeSimpleBinaryExpression(token, left, right);\n    }\n  }","id":74255,"modified_method":"@Override\n  public void visitBinaryExpression(GrBinaryExpression expression) {\n    final GrExpression left = expression.getLeftOperand();\n    GrExpression right = expression.getRightOperand();\n    final PsiType ltype = left.getType();\n    final PsiElement token = expression.getOperationToken();\n    final IElementType op = expression.getOperationTokenType();\n\n    if (op == mREGEX_FIND) {\n      builder.append(GroovyCommonClassNames.JAVA_UTIL_REGEX_PATTERN).append(\".compile(\");\n      if (right != null) {\n        right.accept(this);\n      }\n      builder.append(\").matcher(\");\n      left.accept(this);\n      builder.append(\")\");\n      return;\n    }\n    if (op == mREGEX_MATCH) {\n      builder.append(GroovyCommonClassNames.JAVA_UTIL_REGEX_PATTERN).append(\".matches(\");\n      if (right != null) {\n        right.accept(this);\n      }\n      builder.append(\", \");\n      left.accept(this);\n      builder.append(')');\n      return;\n    }\n    if (GenerationSettings.dontReplaceOperatorsWithMethodsForNumbers &&\n        (TypesUtil.isNumericType(ltype) && (right == null || TypesUtil.isNumericType(right.getType())) ||\n         op == mPLUS && ltype != null && TypesUtil.typeEqualsToText(ltype, CommonClassNames.JAVA_LANG_STRING))) {\n      writeSimpleBinaryExpression(token, left, right);\n      return;\n    }\n\n    final GroovyResolveResult resolveResult = PsiImplUtil.extractUniqueResult(expression.multiResolve(false));\n    final PsiElement resolved = resolveResult.getElement();\n    if (resolved instanceof PsiMethod) {\n      if (right == null) {\n        right = factory.createExpressionFromText(\"null\");\n      }\n      invokeMethodOn(\n        ((PsiMethod)resolved),\n        left,\n        new GrExpression[]{right},\n        GrNamedArgument.EMPTY_ARRAY,\n        GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        expression\n      );\n      if (op == mGE) builder.append(\" >= 0\");\n      else if (op == mGT) builder.append(\" > 0\");\n      else if (op == mLT) builder.append(\" < 0\");\n      else if (op == mLE) builder.append(\" <= 0\");\n    }\n    else {\n      writeSimpleBinaryExpression(token, left, right);\n    }\n  }","commit_id":"418065c6d7ae98f9c34d26781eae9797b33809b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    final GrExpression qualifier = referenceExpression.getQualifier();\n    final GroovyResolveResult resolveResult = referenceExpression.advancedResolve();\n    final PsiElement resolved = resolveResult.getElement();\n\n    final IElementType type = referenceExpression.getDotTokenType();\n\n    GrExpression qualifierToUse = qualifier;\n\n    if (type == mMEMBER_POINTER) {\n      LOG.assertTrue(qualifier != null);\n      builder.append(\"new \").append(GroovyCommonClassNames.ORG_CODEHAUS_GROOVY_RUNTIME_METHOD_CLOSURE).append(\"(\");\n      qualifier.accept(this);\n      builder.append(\", \\\"\").append(referenceExpression.getReferenceName()).append(\"\\\")\");\n      return;\n    }\n\n    if (type == mOPTIONAL_DOT) {\n      LOG.assertTrue(qualifier != null);\n\n      String qualifierName = createVarByInitializer(qualifier);\n      builder.append(qualifierName).append(\" == null ? null : \");\n\n      qualifierToUse = factory.createReferenceExpressionFromText(qualifierName, referenceExpression);\n    }\n\n\n    if (resolveResult.isInvokedOnProperty()) {\n      LOG.assertTrue(resolved instanceof PsiMethod);\n      invokeMethodOn(\n        ((PsiMethod)resolved),\n        qualifierToUse,\n        GrExpression.EMPTY_ARRAY,\n        GrNamedArgument.EMPTY_ARRAY,\n        GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        referenceExpression\n      );\n    }\n    else {\n      if (qualifierToUse != null) {\n        qualifierToUse.accept(this);\n        builder.append('.');\n      }\n      final String refName =\n        resolved instanceof PsiNamedElement ? ((PsiNamedElement)resolved).getName() : referenceExpression.getReferenceName();\n      builder.append(refName);\n    }\n  }","id":74256,"modified_method":"@Override\n  public void visitReferenceExpression(GrReferenceExpression referenceExpression) {\n    final GrExpression qualifier = referenceExpression.getQualifier();\n    final GroovyResolveResult resolveResult = referenceExpression.advancedResolve();\n    final PsiElement resolved = resolveResult.getElement();\n\n    final IElementType type = referenceExpression.getDotTokenType();\n\n    GrExpression qualifierToUse = qualifier;\n\n    if (type == mMEMBER_POINTER) {\n      LOG.assertTrue(qualifier != null);\n      builder.append(\"new \").append(GroovyCommonClassNames.ORG_CODEHAUS_GROOVY_RUNTIME_METHOD_CLOSURE).append(\"(\");\n      qualifier.accept(this);\n      builder.append(\", \\\"\").append(referenceExpression.getReferenceName()).append(\"\\\")\");\n      return;\n    }\n\n    if (type == mOPTIONAL_DOT) {\n      LOG.assertTrue(qualifier != null);\n\n      String qualifierName = createVarByInitializer(qualifier);\n      builder.append(qualifierName).append(\" == null ? null : \");\n\n      qualifierToUse = factory.createReferenceExpressionFromText(qualifierName, referenceExpression);\n    }\n\n\n    if (resolveResult.isInvokedOnProperty()) {\n      LOG.assertTrue(resolved instanceof PsiMethod);\n      invokeMethodOn(\n        ((PsiMethod)resolved),\n        qualifierToUse,\n        GrExpression.EMPTY_ARRAY,\n        GrNamedArgument.EMPTY_ARRAY,\n        GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        referenceExpression\n      );\n    }\n    else {\n      if (qualifierToUse != null) {\n        qualifierToUse.accept(this);\n        builder.append('.');\n      }\n      if (resolved instanceof PsiNamedElement) {\n        final String refName = ((PsiNamedElement)resolved).getName();\n        builder.append(refName);\n      }\n      else {\n        final String refName = referenceExpression.getReferenceName();\n        if (refName != null) {\n          builder.append(refName);\n        }\n        else {\n          final PsiElement nameElement = referenceExpression.getReferenceNameElement();\n          if (nameElement instanceof GrExpression) {\n            ((GrExpression)nameElement).accept(this);\n          }\n          else if (nameElement != null) {\n            builder.append(nameElement.toString());\n          }\n        }\n      }\n    }\n  }","commit_id":"418065c6d7ae98f9c34d26781eae9797b33809b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean generatePrefixIncDec(PsiMethod method,\n                                       GrExpression operand,\n                                       GrUnaryExpression unary) {\n    if (!(operand instanceof GrReferenceExpression)) return false;\n\n    final GrExpression qualifier = ((GrReferenceExpression)operand).getQualifier();\n    final GroovyResolveResult resolveResult = ((GrReferenceExpression)operand).advancedResolve();\n    final PsiElement resolved = resolveResult.getElement();\n    if (resolved instanceof PsiMethod && GroovyPropertyUtils.isSimplePropertyGetter((PsiMethod)resolved)) {\n      final PsiMethod getter = (PsiMethod)resolved;\n      final String propertyName = GroovyPropertyUtils.getPropertyNameByGetter(getter);\n      final PsiType type;\n      if (qualifier == null) {\n        type = null;\n      }\n      else {\n        type = qualifier.getType();\n        if (type == null) return false;\n      }\n      final PsiMethod setter = GroovyPropertyUtils.findPropertySetter(type, propertyName, unary);\n      if (setter == null) return false;\n\n      StringBuilder builder = new StringBuilder();\n      final ExpressionGenerator generator = new ExpressionGenerator(builder, context);\n      generator.invokeMethodOn(\n        method,\n        operand,\n        GrExpression.EMPTY_ARRAY, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        unary\n      );\n\n      final GrExpression fromText = factory.createExpressionFromText(builder.toString(), unary);\n      invokeMethodOn(\n        setter,\n        qualifier,\n        new GrExpression[]{fromText}, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        unary\n      );\n    }\n    else if (resolved instanceof PsiVariable) {\n      builder.append('(');\n      operand.accept(this);\n      builder.append(\" = \");\n      invokeMethodOn(\n        method,\n        operand,\n        GrExpression.EMPTY_ARRAY, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        unary\n      );\n      builder.append(')');\n    }\n    return true;\n  }","id":74257,"modified_method":"private boolean generatePrefixIncDec(PsiMethod method,\n                                       GrExpression operand,\n                                       GrUnaryExpression unary) {\n    if (!(operand instanceof GrReferenceExpression)) return false;\n\n    final GrExpression qualifier = ((GrReferenceExpression)operand).getQualifier();\n    final GroovyResolveResult resolveResult = ((GrReferenceExpression)operand).advancedResolve();\n    final PsiElement resolved = resolveResult.getElement();\n    if (resolved instanceof PsiMethod && GroovyPropertyUtils.isSimplePropertyGetter((PsiMethod)resolved)) {\n      final PsiMethod getter = (PsiMethod)resolved;\n      final String propertyName = GroovyPropertyUtils.getPropertyNameByGetter(getter);\n      final PsiType type;\n      if (qualifier == null) {\n        type = null;\n      }\n      else {\n        type = qualifier.getType();\n        if (type == null) return false;\n      }\n      final PsiMethod setter = GroovyPropertyUtils.findPropertySetter(type, propertyName, unary);\n      if (setter == null) return false;\n\n      final ExpressionGenerator generator = new ExpressionGenerator(new StringBuilder(), context);\n      generator.invokeMethodOn(\n        method,\n        operand,\n        GrExpression.EMPTY_ARRAY, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        unary\n      );\n\n      final GrExpression fromText = factory.createExpressionFromText(generator.toString(), unary);\n      invokeMethodOn(\n        setter,\n        qualifier,\n        new GrExpression[]{fromText}, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        unary\n      );\n    }\n    else if (resolved instanceof PsiVariable) {\n      builder.append('(');\n      operand.accept(this);\n      builder.append(\" = \");\n      invokeMethodOn(\n        method,\n        operand,\n        GrExpression.EMPTY_ARRAY, GrNamedArgument.EMPTY_ARRAY, GrClosableBlock.EMPTY_ARRAY,\n        resolveResult.getSubstitutor(),\n        unary\n      );\n      builder.append(')');\n    }\n    return true;\n  }","commit_id":"418065c6d7ae98f9c34d26781eae9797b33809b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public GrExpression getReferenceNameElement() {\n    final PsiElement last = getLastChild();\n    assert last instanceof GrExpression;\n    return (GrExpression)last;\n  }","id":74258,"modified_method":"@NotNull\n  @Override\n  public GrExpression getReferenceNameElement() {\n    final PsiElement last = getLastChild();\n//    assert last instanceof GrExpression;\n    return (GrExpression)last;\n  }","commit_id":"418065c6d7ae98f9c34d26781eae9797b33809b1","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public PsiClassType rawType() {\n    PsiElement resolved = myReference.resolve();\n    if (resolved instanceof PsiClass) {\n      PsiClass aClass = (PsiClass)resolved;\n      if (!PsiUtil.typeParametersIterable(aClass).iterator().hasNext()) return this;\n      PsiManager manager = myReference.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n      final PsiSubstitutor rawSubstitutor = factory.createRawSubstitutor(aClass);\n      return factory.createType(aClass, rawSubstitutor, getLanguageLevel(), getAnnotations());\n    }\n    String qualifiedName = myReference.getQualifiedName();\n    LightClassReference reference = new LightClassReference(myReference.getManager(), myReference.getReferenceName(), qualifiedName, myReference.getResolveScope());\n    return new PsiClassReferenceType(reference, null,getAnnotations());\n  }","id":74259,"modified_method":"@NotNull\n  public PsiClassType rawType() {\n    PsiElement resolved = myReference.resolve();\n    if (resolved instanceof PsiClass) {\n      PsiClass aClass = (PsiClass)resolved;\n      if (!PsiUtil.typeParametersIterable(aClass).iterator().hasNext()) return this;\n      PsiManager manager = myReference.getManager();\n      final PsiElementFactory factory = JavaPsiFacade.getInstance(manager.getProject()).getElementFactory();\n      final PsiSubstitutor rawSubstitutor = factory.createRawSubstitutor(aClass);\n      return factory.createType(aClass, rawSubstitutor, getLanguageLevel(), getAnnotations());\n    }\n    String qualifiedName = myReference.getQualifiedName();\n    String name = myReference.getReferenceName();\n    if (name==null) name=\"\";\n    LightClassReference reference = new LightClassReference(myReference.getManager(), name, qualifiedName, myReference.getResolveScope());\n    return new PsiClassReferenceType(reference, null,getAnnotations());\n  }","commit_id":"0f093b0487cb0495d91065f2a4ecf4eddd690b2e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static JSFunction findDeclaredFunction(JSExpression expression) {\n    final Ref<JSFunction> result = Ref.create();\n    if (expression instanceof JSReferenceExpression) {\n      final String name = ((JSReferenceExpression)expression).getReferenceName();\n      expression.getContainingFile().accept(new JSRecursiveWalkingElementVisitor() {\n        @Override\n        public void visitJSFunctionExpression(JSFunctionExpression node) {\n          checkFunction(node);\n          super.visitJSFunctionExpression(node);\n        }\n\n        public void checkFunction(JSFunction node) {\n          if (StringUtil.equals(name, node.getName())) {\n            result.set(node);\n            stopWalking();\n          }\n        }\n\n        @Override\n        public void visitJSFunctionDeclaration(JSFunction node) {\n          checkFunction(node);\n          super.visitJSFunctionDeclaration(node);\n        }\n      });\n    }\n    return result.get();\n  }","id":74260,"modified_method":"private static JSFunction findDeclaredFunction(JSExpression expression) {\n    final String name = expression instanceof JSReferenceExpression ? ((JSReferenceExpression)expression).getReferenceName() : null;\n    if (name != null) {\n      ASTNode node = expression.getNode();\n      final JSTreeUtil.JSScopeDeclarationsAndAssignments declaration = JSTreeUtil.getDeclarationsAndAssignmentsInScopeAndUp(name, node);\n      CompositeElement definition = declaration != null ? declaration.findNearestDefinition(node) : null;\n      if (definition != null && JSElementTypes.FUNCTION_DECLARATIONS.contains(definition.getElementType())) {\n        return (JSFunction)definition.getPsi();\n      }\n    }\n    return null;\n  }","commit_id":"2a5dcd96b3d606b57feb2aa0eba51be2efc13dcc","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"public String getPackageName() {\n    GrReferenceElement ref = getPackageReference();\n    if (ref == null) return \"\";\n    StringBuilder builder = new StringBuilder();\n    while(ref != null) {\n      builder.append(ref.getReferenceName());\n      ref = ref.getQualifier();\n      if (ref != null) builder.append(\".\");\n    }\n\n    return builder.toString();\n  }","id":74261,"modified_method":"public String getPackageName() {\n    GrReferenceElement ref = getPackageReference();\n    if (ref == null) return \"\";\n    StringBuilder builder = new StringBuilder();\n    while(ref != null) {\n      String refName = ref.getReferenceName();\n      if (refName == null) break;\n      builder.append(refName);\n      ref = ref.getQualifier();\n      if (ref != null) builder.append(\".\");\n    }\n\n    return builder.toString();\n  }","commit_id":"f0143800f291e103f0f2b7dcc464144a4299976d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getReferenceName() {\n    if (findChildByType(GroovyTokenTypes.mIDENT) != null) {\n      return findChildByType(GroovyTokenTypes.mIDENT).getText();\n    }\n    return null;\n  }","id":74262,"modified_method":"public String getReferenceName() {\n    PsiElement ident = findChildByType(GroovyTokenTypes.mIDENT);\n    if (ident != null) {\n      return ident.getText();\n    }\n    return null;\n  }","commit_id":"f0143800f291e103f0f2b7dcc464144a4299976d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getInferredType(@NotNull final GrReferenceExpression refExpr) {\n    final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(refExpr);\n    if (scope == null) return null;\n\n    return getInferenceCache(scope).getInferredType(refExpr.getReferenceName(), ControlFlowUtils\n      .findRWInstruction(refExpr, scope.getControlFlow()));\n  }","id":74263,"modified_method":"@Nullable\n  public static PsiType getInferredType(@NotNull final GrReferenceExpression refExpr) {\n    final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(refExpr);\n    if (scope == null) return null;\n\n    final String referenceName = refExpr.getReferenceName();\n    if (referenceName == null) return null;\n\n    final ReadWriteVariableInstruction rwInstruction = ControlFlowUtils.findRWInstruction(refExpr, scope.getControlFlow());\n    if (rwInstruction == null) return null;\n\n    return getInferenceCache(scope).getInferredType(referenceName, rwInstruction);\n  }","commit_id":"838b4a2de5077db72e47692416855af13ea18ed0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public static PsiType getInferredType(@NotNull PsiElement place, String variableName) {\n    final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(place);\n    if (scope == null) return null;\n\n    return getInferenceCache(scope).getInferredType(variableName, ControlFlowUtils.findNearestInstruction(place, scope.getControlFlow()));\n  }","id":74264,"modified_method":"@Nullable\n  public static PsiType getInferredType(@NotNull PsiElement place, @NotNull String variableName) {\n    final GrControlFlowOwner scope = ControlFlowUtils.findControlFlowOwner(place);\n    if (scope == null) return null;\n\n    final Instruction nearest = ControlFlowUtils.findNearestInstruction(place, scope.getControlFlow());\n    if (nearest == null) return null;\n    return getInferenceCache(scope).getInferredType(variableName, nearest);\n  }","commit_id":"838b4a2de5077db72e47692416855af13ea18ed0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    private PsiType getInferredType(@Nullable String variableName, @Nullable Instruction instruction) {\n      if (instruction == null || variableName == null) return null;\n      if (tooComplex.contains(instruction)) return null;\n\n      TypeDfaState cache = varTypes.get().get(instruction.num());\n      if (!cache.containsVariable(variableName)) {\n        Pair<ReachingDefinitionsDfaInstance, List<DefinitionMap>> defUse = getDefUseMaps(scope);\n        if (defUse == null) {\n          tooComplex.add(instruction);\n          return null;\n        }\n\n        Set<Instruction> interesting = collectRequiredInstructions(instruction, variableName, defUse);\n        List<TypeDfaState> dfaResult = performTypeDfa(scope, flow, interesting);\n        if (dfaResult == null) {\n          tooComplex.addAll(interesting);\n        } else {\n          cacheDfaResult(dfaResult);\n        }\n      }\n      DFAType dfaType = getCachedInferredType(variableName, instruction);\n      return dfaType == null ? null : dfaType.getResultType();\n    }","id":74265,"modified_method":"@Nullable\n    private PsiType getInferredType(@NotNull String variableName, @NotNull Instruction instruction) {\n      if (tooComplex.contains(instruction)) return null;\n\n      TypeDfaState cache = varTypes.get().get(instruction.num());\n      if (!cache.containsVariable(variableName)) {\n        Pair<ReachingDefinitionsDfaInstance, List<DefinitionMap>> defUse = getDefUseMaps(scope);\n        if (defUse == null) {\n          tooComplex.add(instruction);\n          return null;\n        }\n\n        Set<Instruction> interesting = collectRequiredInstructions(instruction, variableName, defUse);\n        List<TypeDfaState> dfaResult = performTypeDfa(scope, flow, interesting);\n        if (dfaResult == null) {\n          tooComplex.addAll(interesting);\n        } else {\n          cacheDfaResult(dfaResult);\n        }\n      }\n      DFAType dfaType = getCachedInferredType(variableName, instruction);\n      return dfaType == null ? null : dfaType.getResultType();\n    }","commit_id":"838b4a2de5077db72e47692416855af13ea18ed0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testSpaceAroundTypeColon() throws Exception {\n        getJetSettings().SPACE_AFTER_TYPE_COLON = false;\n        getJetSettings().SPACE_BEFORE_TYPE_COLON = true;\n        doTest();\n    }","id":74266,"modified_method":"public void testSpaceAroundExtendColon() throws Exception {\n        doTestWithInvert();\n    }","commit_id":"ccb8c086848f35dc56884fac83b421cdbd537fa7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testParameters() throws Exception {\n        getJetSettings().SPACE_AFTER_TYPE_COLON = true;\n        getJetSettings().SPACE_BEFORE_TYPE_COLON = false;\n        doTest();\n    }","id":74267,"modified_method":"public void testParameters() throws Exception {\n        doTestWithInvert();\n    }","commit_id":"ccb8c086848f35dc56884fac83b421cdbd537fa7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_DIRECTIVE).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .around(TokenSet.create(PLUS, MINUS)).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                // TODO: Ask for better API\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                ;\n    }","id":74268,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n        CommonCodeStyleSettings jetCommonSettings = settings.getCommonSettings(JetLanguage.INSTANCE);\n\n        return new SpacingBuilder(settings)\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .between(IMPORT_DIRECTIVE, IMPORT_DIRECTIVE).lineBreakInCode()\n                .after(IMPORT_DIRECTIVE).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                // =============== Spacing ================\n                .before(COMMA).spaceIf(jetCommonSettings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(jetCommonSettings.SPACE_AFTER_COMMA)\n\n                .around(TokenSet.create(EQ, MULTEQ, DIVEQ, PLUSEQ, MINUSEQ, PERCEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .around(TokenSet.create(ANDAND, OROR)).spaceIf(jetCommonSettings.SPACE_AROUND_LOGICAL_OPERATORS)\n                .around(TokenSet.create(EQEQ, EXCLEQ, EQEQEQ, EXCLEQEQEQ)).spaceIf(jetCommonSettings.SPACE_AROUND_EQUALITY_OPERATORS)\n                .aroundInside(TokenSet.create(LT, GT, LTEQ, GTEQ), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_RELATIONAL_OPERATORS)\n                .around(TokenSet.create(PLUS, MINUS)).spaceIf(jetCommonSettings.SPACE_AROUND_ADDITIVE_OPERATORS)\n                .aroundInside(TokenSet.create(MUL, DIV, PERC), BINARY_EXPRESSION).spaceIf(jetCommonSettings.SPACE_AROUND_MULTIPLICATIVE_OPERATORS)\n                .around(TokenSet.create(PLUSPLUS, MINUSMINUS, EXCLEXCL, MINUS, PLUS, EXCL)).spaceIf(jetCommonSettings.SPACE_AROUND_UNARY_OPERATOR)\n                .around(RANGE).spaceIf(jetSettings.SPACE_AROUND_RANGE)\n\n                .beforeInside(BLOCK, FUN).spaceIf(jetCommonSettings.SPACE_BEFORE_METHOD_LBRACE)\n\n                // TODO: Ask for better API\n                // Type of the declaration colon\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n\n                // Extends or constraint colon\n                .beforeInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_CONSTRAINT).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_EXTEND_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_EXTEND_COLON)\n                ;\n    }","commit_id":"ccb8c086848f35dc56884fac83b421cdbd537fa7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public String getCodeSample(@NotNull SettingsType settingsType) {\n        switch (settingsType) {\n            case WRAPPING_AND_BRACES_SETTINGS:\n                return\n                        \"public class ThisIsASampleClass {\\n\" +\n                        \"    private fun foo1(i1: Int,\\n\" +\n                        \"                     i2: Int,\\n\" +\n                        \"                     i3: Int) : Int {\\n\" +\n                        \"        return 0\\n\" +\n                        \"    }\\n\" +\n                        \"    private fun foo2():Int {\\n\" +\n                        \"        return foo1(12,\\n\" +\n                        \"                13,\\n\" +\n                        \"                14\\n\" +\n                        \"        )\\n\" +\n                        \"    }\\n\" +\n                        \"}\";\n            default:\n                return\n                        \"class Some {\\n\" +\n                        \"  fun foo() : Int {\\n\" +\n                        \"    val test : Int = 12\\n\" +\n                        \"    return test\\n\" +\n                        \"  }\\n\" +\n                        \"}\";\n        }\n    }","id":74269,"modified_method":"@Override\n    public String getCodeSample(@NotNull SettingsType settingsType) {\n        switch (settingsType) {\n            case WRAPPING_AND_BRACES_SETTINGS:\n                return\n                        \"public class ThisIsASampleClass {\\n\" +\n                        \"    private fun foo1(i1: Int,\\n\" +\n                        \"                     i2: Int,\\n\" +\n                        \"                     i3: Int) : Int {\\n\" +\n                        \"        return 0\\n\" +\n                        \"    }\\n\" +\n                        \"    private fun foo2():Int {\\n\" +\n                        \"        return foo1(12,\\n\" +\n                        \"                13,\\n\" +\n                        \"                14\\n\" +\n                        \"        )\\n\" +\n                        \"    }\\n\" +\n                        \"}\";\n            default:\n                return\n                        \"class Some {\\n\" +\n                        \"  fun foo() : Int {\\n\" +\n                        \"    val test : Int = 12\\n\" +\n                        \"    return test\\n\" +\n                        \"  }\\n\" +\n                        \"  private fun <T>foo2():Int where T : List<T> {\\n\" +\n                        \"    return 0\\n\" +\n                        \"  }\\n\" +\n                        \"}\";\n        }\n    }","commit_id":"ccb8c086848f35dc56884fac83b421cdbd537fa7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void customizeSettings(@NotNull CodeStyleSettingsCustomizable consumer, @NotNull SettingsType settingsType) {\n        switch (settingsType) {\n            case SPACING_SETTINGS:\n                consumer.showStandardOptions(\n                        \"SPACE_AROUND_ASSIGNMENT_OPERATORS\",\n                        \"SPACE_AROUND_LOGICAL_OPERATORS\",\n                        \"SPACE_AROUND_EQUALITY_OPERATORS\",\n                        \"SPACE_AROUND_RELATIONAL_OPERATORS\",\n                        \"SPACE_AROUND_ADDITIVE_OPERATORS\",\n                        \"SPACE_AROUND_MULTIPLICATIVE_OPERATORS\",\n                        \"SPACE_AROUND_UNARY_OPERATOR\",\n                        \"SPACE_AFTER_COMMA\",\n                        \"SPACE_BEFORE_COMMA\"\n                );\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_AROUND_RANGE\", \"Around range (..)\",\n                                          CodeStyleSettingsCustomizable.SPACES_AROUND_OPERATORS);\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_AFTER_TYPE_COLON\", \"Space after colon, before declarations' type\",\n                                          CodeStyleSettingsCustomizable.SPACES_OTHER);\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_BEFORE_TYPE_COLON\", \"Space before colon, after declarations' name\",\n                                          CodeStyleSettingsCustomizable.SPACES_OTHER);\n                break;\n            case WRAPPING_AND_BRACES_SETTINGS:\n                consumer.showStandardOptions(\n                        // \"ALIGN_MULTILINE_CHAINED_METHODS\",\n                        \"ALIGN_MULTILINE_PARAMETERS\",\n                        \"ALIGN_MULTILINE_PARAMETERS_IN_CALLS\",\n                        \"ALIGN_MULTILINE_METHOD_BRACKETS\"\n                );\n                break;\n            default:\n                consumer.showStandardOptions();\n        }\n    }","id":74270,"modified_method":"@Override\n    public void customizeSettings(@NotNull CodeStyleSettingsCustomizable consumer, @NotNull SettingsType settingsType) {\n        switch (settingsType) {\n            case SPACING_SETTINGS:\n                consumer.showStandardOptions(\n                        \"SPACE_AROUND_ASSIGNMENT_OPERATORS\",\n                        \"SPACE_AROUND_LOGICAL_OPERATORS\",\n                        \"SPACE_AROUND_EQUALITY_OPERATORS\",\n                        \"SPACE_AROUND_RELATIONAL_OPERATORS\",\n                        \"SPACE_AROUND_ADDITIVE_OPERATORS\",\n                        \"SPACE_AROUND_MULTIPLICATIVE_OPERATORS\",\n                        \"SPACE_AROUND_UNARY_OPERATOR\",\n                        \"SPACE_AFTER_COMMA\",\n                        \"SPACE_BEFORE_COMMA\"\n                );\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_AROUND_RANGE\", \"Around range (..)\",\n                                          CodeStyleSettingsCustomizable.SPACES_AROUND_OPERATORS);\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_AFTER_TYPE_COLON\", \"Space after colon, before declarations' type\",\n                                          CodeStyleSettingsCustomizable.SPACES_OTHER);\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_BEFORE_TYPE_COLON\", \"Space before colon, after declarations' name\",\n                                          CodeStyleSettingsCustomizable.SPACES_OTHER);\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_AFTER_EXTEND_COLON\",\n                                          \"Space after colon in new type definition\",\n                                          CodeStyleSettingsCustomizable.SPACES_OTHER);\n\n                consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_BEFORE_EXTEND_COLON\",\n                                          \"Space before colon in new type definition\",\n                                          CodeStyleSettingsCustomizable.SPACES_OTHER);\n                break;\n            case WRAPPING_AND_BRACES_SETTINGS:\n                consumer.showStandardOptions(\n                        // \"ALIGN_MULTILINE_CHAINED_METHODS\",\n                        \"ALIGN_MULTILINE_PARAMETERS\",\n                        \"ALIGN_MULTILINE_PARAMETERS_IN_CALLS\",\n                        \"ALIGN_MULTILINE_METHOD_BRACKETS\"\n                );\n                break;\n            default:\n                consumer.showStandardOptions();\n        }\n    }","commit_id":"ccb8c086848f35dc56884fac83b421cdbd537fa7","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public Configurable createSettingsPage(CodeStyleSettings settings, CodeStyleSettings originalSettings) {\n        return new CodeStyleAbstractConfigurable(settings, originalSettings, \"Kotlin\") {\n            @Override\n            protected CodeStyleAbstractPanel createPanel(CodeStyleSettings settings) {\n                return new TabbedLanguageCodeStylePanel(JetLanguage.INSTANCE, getCurrentSettings(), settings) {\n                    @Override\n                    protected void initTabs(CodeStyleSettings settings) {\n                        // TODO: activate all parent tabs\n                        addIndentOptionsTab(settings);\n                    }\n                };\n            }\n\n            @Override\n            public String getHelpTopic() {\n                return null;\n            }\n        };\n    }","id":74271,"modified_method":"@NotNull\n    @Override\n    public Configurable createSettingsPage(CodeStyleSettings settings, CodeStyleSettings originalSettings) {\n        return new CodeStyleAbstractConfigurable(settings, originalSettings, \"Kotlin\") {\n            @Override\n            protected CodeStyleAbstractPanel createPanel(CodeStyleSettings settings) {\n                return new TabbedLanguageCodeStylePanel(JetLanguage.INSTANCE, getCurrentSettings(), settings) {\n                    @Override\n                    protected void initTabs(CodeStyleSettings settings) {\n                        // TODO: activate all parent tabs\n                        addIndentOptionsTab(settings);\n                        addSpacesTab(settings);\n                    }\n                };\n            }\n\n            @Override\n            public String getHelpTopic() {\n                return null;\n            }\n        };\n    }","commit_id":"c21cdaf413ee2b43eb927d4f26da772008f34e09","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public void testParameters() throws Exception {\n        doTest();\n    }","id":74272,"modified_method":"public void testParameters() throws Exception {\n        getJetSettings().SPACE_AFTER_TYPE_COLON = true;\n        getJetSettings().SPACE_BEFORE_TYPE_COLON = false;\n        doTest();\n    }","commit_id":"c21cdaf413ee2b43eb927d4f26da772008f34e09","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        return new SpacingBuilder(settings)\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n                .between(IMPORT_DIRECTIVE, OBJECT_DECLARATION).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode();\n    }","id":74273,"modified_method":"private static SpacingBuilder createSpacingBuilder(CodeStyleSettings settings) {\n        JetCodeStyleSettings jetSettings = settings.getCustomSettings(JetCodeStyleSettings.class);\n\n        return new SpacingBuilder(settings)\n\n                // ============ Line breaks ==============\n                .after(NAMESPACE_HEADER).blankLines(1)\n\n                .before(IMPORT_DIRECTIVE).lineBreakInCode()\n                .between(IMPORT_DIRECTIVE, CLASS).blankLines(1)\n                .between(IMPORT_DIRECTIVE, FUN).blankLines(1)\n                .between(IMPORT_DIRECTIVE, PROPERTY).blankLines(1)\n                .between(IMPORT_DIRECTIVE, OBJECT_DECLARATION).blankLines(1)\n\n                .before(FUN).lineBreakInCode()\n                .before(PROPERTY).lineBreakInCode()\n                .between(FUN, FUN).blankLines(1)\n                .between(FUN, PROPERTY).blankLines(1)\n\n                .afterInside(LBRACE, BLOCK).lineBreakInCode()\n                .beforeInside(RBRACE, CLASS_BODY).lineBreakInCode()\n                .beforeInside(RBRACE, BLOCK).lineBreakInCode()\n\n                        // =============== Spacing ================\n                .before(COMMA).spaceIf(settings.SPACE_BEFORE_COMMA)\n                .after(COMMA).spaceIf(settings.SPACE_AFTER_COMMA)\n                .around(EQ).spaceIf(settings.SPACE_AROUND_ASSIGNMENT_OPERATORS)\n                .beforeInside(BLOCK, FUN).spaceIf(settings.SPACE_BEFORE_METHOD_LBRACE)\n\n                // TODO: Ask for better API\n                .beforeInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, PROPERTY).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, CLASS).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, CLASS).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, FUN).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, FUN).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, TYPE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON)\n                .beforeInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_BEFORE_TYPE_COLON)\n                .afterInside(COLON, VALUE_PARAMETER).spaceIf(jetSettings.SPACE_AFTER_TYPE_COLON);\n    }","commit_id":"c21cdaf413ee2b43eb927d4f26da772008f34e09","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void customizeSettings(@NotNull CodeStyleSettingsCustomizable consumer, @NotNull SettingsType settingsType) {\n        consumer.showAllStandardOptions();\n    }","id":74274,"modified_method":"@Override\n    public void customizeSettings(@NotNull CodeStyleSettingsCustomizable consumer, @NotNull SettingsType settingsType) {\n        if (settingsType == SettingsType.SPACING_SETTINGS) {\n            consumer.showStandardOptions(\n                    \"SPACE_AROUND_ASSIGNMENT_OPERATORS\",\n                    \"SPACE_AROUND_LOGICAL_OPERATORS\",\n                    \"SPACE_AROUND_EQUALITY_OPERATORS\",\n                    \"SPACE_AROUND_RELATIONAL_OPERATORS\",\n                    \"SPACE_AROUND_BITWISE_OPERATORS\",\n                    \"SPACE_AROUND_ADDITIVE_OPERATORS\",\n                    \"SPACE_AROUND_MULTIPLICATIVE_OPERATORS\",\n                    \"SPACE_AROUND_SHIFT_OPERATORS\",\n                    \"SPACE_AROUND_UNARY_OPERATOR\",\n                    \"SPACE_AFTER_COMMA\",\n                    \"SPACE_AFTER_COMMA_IN_TYPE_ARGUMENTS\",\n                    \"SPACE_BEFORE_COMMA\",\n                    \"SPACE_AFTER_SEMICOLON\",\n                    \"SPACE_BEFORE_SEMICOLON\",\n                    \"SPACE_WITHIN_PARENTHESES\",\n                    \"SPACE_WITHIN_METHOD_CALL_PARENTHESES\",\n                    \"SPACE_WITHIN_EMPTY_METHOD_CALL_PARENTHESES\",\n                    \"SPACE_WITHIN_METHOD_PARENTHESES\",\n                    \"SPACE_WITHIN_EMPTY_METHOD_PARENTHESES\",\n                    \"SPACE_WITHIN_IF_PARENTHESES\",\n                    \"SPACE_WITHIN_WHILE_PARENTHESES\",\n                    \"SPACE_WITHIN_FOR_PARENTHESES\",\n                    \"SPACE_WITHIN_TRY_PARENTHESES\",\n                    \"SPACE_WITHIN_CATCH_PARENTHESES\",\n                    \"SPACE_WITHIN_SWITCH_PARENTHESES\",\n                    // \"SPACE_WITHIN_SYNCHRONIZED_PARENTHESES\",\n                    \"SPACE_WITHIN_CAST_PARENTHESES\",\n                    \"SPACE_WITHIN_BRACKETS\",\n                    \"SPACE_WITHIN_BRACES\",\n                    // \"SPACE_WITHIN_ARRAY_INITIALIZER_BRACES\",\n                    \"SPACE_AFTER_TYPE_CAST\",\n                    \"SPACE_BEFORE_METHOD_CALL_PARENTHESES\",\n                    \"SPACE_BEFORE_METHOD_PARENTHESES\",\n                    \"SPACE_BEFORE_IF_PARENTHESES\",\n                    \"SPACE_BEFORE_WHILE_PARENTHESES\",\n                    \"SPACE_BEFORE_FOR_PARENTHESES\",\n                    \"SPACE_BEFORE_TRY_PARENTHESES\",\n                    \"SPACE_BEFORE_CATCH_PARENTHESES\",\n                    \"SPACE_BEFORE_SWITCH_PARENTHESES\",\n                    \"SPACE_BEFORE_SYNCHRONIZED_PARENTHESES\",\n                    \"SPACE_BEFORE_CLASS_LBRACE\",\n                    \"SPACE_BEFORE_METHOD_LBRACE\",\n                    \"SPACE_BEFORE_IF_LBRACE\",\n                    \"SPACE_BEFORE_ELSE_LBRACE\",\n                    \"SPACE_BEFORE_WHILE_LBRACE\",\n                    \"SPACE_BEFORE_FOR_LBRACE\",\n                    \"SPACE_BEFORE_DO_LBRACE\",\n                    \"SPACE_BEFORE_SWITCH_LBRACE\",\n                    \"SPACE_BEFORE_TRY_LBRACE\",\n                    \"SPACE_BEFORE_CATCH_LBRACE\",\n                    \"SPACE_BEFORE_FINALLY_LBRACE\",\n                    \"SPACE_BEFORE_SYNCHRONIZED_LBRACE\",\n                    \"SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE\",\n                    \"SPACE_BEFORE_ANNOTATION_ARRAY_INITIALIZER_LBRACE\",\n                    \"SPACE_BEFORE_ELSE_KEYWORD\",\n                    \"SPACE_BEFORE_WHILE_KEYWORD\",\n                    \"SPACE_BEFORE_CATCH_KEYWORD\",\n                    \"SPACE_BEFORE_FINALLY_KEYWORD\",\n                    \"SPACE_BEFORE_QUEST\",\n                    \"SPACE_AFTER_QUEST\",\n                    \"SPACE_BEFORE_COLON\",\n                    \"SPACE_AFTER_COLON\",\n                    \"SPACE_BEFORE_TYPE_PARAMETER_LIST\"\n            );\n\n            consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_AFTER_TYPE_COLON\", \"Space after colon, before declarations' type\",\n                                      CodeStyleSettingsCustomizable.SPACES_OTHER);\n\n            consumer.showCustomOption(JetCodeStyleSettings.class, \"SPACE_BEFORE_TYPE_COLON\", \"Space before colon, after declarations' name\",\n                                      CodeStyleSettingsCustomizable.SPACES_OTHER);\n        } else {\n            consumer.showAllStandardOptions();\n        }\n\n\n    }","commit_id":"c21cdaf413ee2b43eb927d4f26da772008f34e09","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public String getCodeSample(@NotNull SettingsType settingsType) {\n        return\n            \"class Some {\\n\" +\n            \"fun foo() : Int {\\n\" +\n            \"return 0\\n\" +\n            \"}\\n\" +\n            \"}\";\n    }","id":74275,"modified_method":"@Override\n    public String getCodeSample(@NotNull SettingsType settingsType) {\n        return\n                \"class Some {\\n\" +\n                \"  fun foo() : Int {\\n\" +\n                \"    val test : Int = 12\\n\" +\n                \"    return test\\n\" +\n                \"  }\\n\" +\n                \"}\";\n    }","commit_id":"c21cdaf413ee2b43eb927d4f26da772008f34e09","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static JetElement overrideFunction(Project project, JetFile file, SimpleFunctionDescriptor descriptor) {\n        StringBuilder bodyBuilder = new StringBuilder(\"override fun \");\n        bodyBuilder.append(descriptor.getName());\n        bodyBuilder.append(\"(\");\n        boolean first = true;\n        for (ValueParameterDescriptor parameterDescriptor : descriptor.getValueParameters()) {\n            if (!first) {\n                bodyBuilder.append(\",\");\n            }\n            first = false;\n            bodyBuilder.append(parameterDescriptor.getName());\n            bodyBuilder.append(\" : \");\n            bodyBuilder.append(parameterDescriptor.getType().toString());\n\n            ImportClassHelper.addImportDirectiveIfNeeded(parameterDescriptor.getType(), file);\n        }\n        bodyBuilder.append(\")\");\n        final JetType returnType = descriptor.getReturnType();\n        final JetStandardLibrary stdlib = JetStandardLibrary.getInstance();\n        if (!returnType.equals(stdlib.getTuple0Type())) {\n            bodyBuilder.append(\" : \").append(returnType.toString());\n            ImportClassHelper.addImportDirectiveIfNeeded(returnType, file);\n        }\n\n        bodyBuilder.append(\"{\").append(\"throw UnsupportedOperationException()\").append(\"}\");\n\n        return JetPsiFactory.createFunction(project, bodyBuilder.toString());\n    }","id":74276,"modified_method":"private static JetElement overrideFunction(Project project, JetFile file, SimpleFunctionDescriptor descriptor) {\n        StringBuilder bodyBuilder = new StringBuilder(\"override fun \");\n        bodyBuilder.append(descriptor.getName());\n        bodyBuilder.append(\"(\");\n        boolean first = true;\n        for (ValueParameterDescriptor parameterDescriptor : descriptor.getValueParameters()) {\n            if (!first) {\n                bodyBuilder.append(\",\");\n            }\n            first = false;\n            bodyBuilder.append(parameterDescriptor.getName());\n            bodyBuilder.append(\":\");\n            bodyBuilder.append(parameterDescriptor.getType().toString());\n\n            ImportClassHelper.addImportDirectiveIfNeeded(parameterDescriptor.getType(), file);\n        }\n        bodyBuilder.append(\")\");\n        final JetType returnType = descriptor.getReturnType();\n        final JetStandardLibrary stdlib = JetStandardLibrary.getInstance();\n        if (!returnType.equals(stdlib.getTuple0Type())) {\n            bodyBuilder.append(\":\").append(returnType.toString());\n            ImportClassHelper.addImportDirectiveIfNeeded(returnType, file);\n        }\n\n        bodyBuilder.append(\"{\").append(\"throw UnsupportedOperationException()\").append(\"}\");\n\n        return JetPsiFactory.createFunction(project, bodyBuilder.toString());\n    }","commit_id":"c21cdaf413ee2b43eb927d4f26da772008f34e09","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private static JetElement overrideProperty(Project project, JetFile file, PropertyDescriptor descriptor) {\n        StringBuilder bodyBuilder = new StringBuilder(\"override \");\n        if (descriptor.isVar()) {\n            bodyBuilder.append(\"var \");\n        }\n        else {\n            bodyBuilder.append(\"val \");\n        }\n        bodyBuilder.append(descriptor.getName()).append(\" : \").append(descriptor.getType());\n        ImportClassHelper.addImportDirectiveIfNeeded(descriptor.getType(), file);\n        String initializer = defaultInitializer(descriptor.getType(), JetStandardLibrary.getInstance());\n        if (initializer != null) {\n            bodyBuilder.append(\"=\").append(initializer);\n        }\n        else {\n            bodyBuilder.append(\"= ?\");\n        }\n        return JetPsiFactory.createProperty(project, bodyBuilder.toString());\n    }","id":74277,"modified_method":"private static JetElement overrideProperty(Project project, JetFile file, PropertyDescriptor descriptor) {\n        StringBuilder bodyBuilder = new StringBuilder(\"override \");\n        if (descriptor.isVar()) {\n            bodyBuilder.append(\"var \");\n        }\n        else {\n            bodyBuilder.append(\"val \");\n        }\n        bodyBuilder.append(descriptor.getName()).append(\":\").append(descriptor.getType());\n        ImportClassHelper.addImportDirectiveIfNeeded(descriptor.getType(), file);\n        String initializer = defaultInitializer(descriptor.getType(), JetStandardLibrary.getInstance());\n        if (initializer != null) {\n            bodyBuilder.append(\"=\").append(initializer);\n        }\n        else {\n            bodyBuilder.append(\"= ?\");\n        }\n        return JetPsiFactory.createProperty(project, bodyBuilder.toString());\n    }","commit_id":"c21cdaf413ee2b43eb927d4f26da772008f34e09","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public int getPeriod() {\n    return period;\n  }","id":74278,"modified_method":"@CheckForNull\n  public Integer getPeriod() {\n    return period;\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QualityGateConditionDto setPeriod(int period) {\n    this.period = period;\n    return this;\n  }","id":74279,"modified_method":"public QualityGateConditionDto setPeriod(@Nullable Integer period) {\n    this.period = period;\n    return this;\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void delete(long idToDelete) {\n    checkPermission(UserSession.get());\n    QualityGateDto qGate = getNonNull(idToDelete);\n    if (isDefault(qGate)) {\n      throw new BadRequestException(\"Impossible to delete default quality gate.\");\n    }\n    dao.delete(qGate);\n  }","id":74280,"modified_method":"public void delete(long idToDelete) {\n    checkPermission(UserSession.get());\n    QualityGateDto qGate = getNonNullQgate(idToDelete);\n    if (isDefault(qGate)) {\n      throw new BadRequestException(\"Impossible to delete default quality gate.\");\n    }\n    dao.delete(qGate);\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private QualityGateDto getNonNull(long id) {\n    QualityGateDto qGate = dao.selectById(id);\n    if (qGate == null) {\n      throw new NotFoundException(\"There is no quality gate with id=\" + id);\n    }\n    return qGate;\n  }","id":74281,"modified_method":"private QualityGateDto getNonNullQgate(long id) {\n    QualityGateDto qGate = dao.selectById(id);\n    if (qGate == null) {\n      throw new NotFoundException(\"There is no quality gate with id=\" + id);\n    }\n    return qGate;\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QualityGates(QualityGateDao dao, QualityGateConditionDao conditionDao, PropertiesDao propertiesDao) {\n    this.dao = dao;\n    this.conditionDao = conditionDao;\n    this.propertiesDao = propertiesDao;\n  }","id":74282,"modified_method":"public QualityGates(QualityGateDao dao, QualityGateConditionDao conditionDao, MetricFinder metricFinder, PropertiesDao propertiesDao) {\n    this.dao = dao;\n    this.conditionDao = conditionDao;\n    this.metricFinder = metricFinder;\n    this.propertiesDao = propertiesDao;\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QualityGateDto rename(long idToRename, String name) {\n    checkPermission(UserSession.get());\n    QualityGateDto toRename = getNonNull(idToRename);\n    validateQualityGate(idToRename, name);\n    toRename.setName(name);\n    dao.update(toRename);\n    return toRename;\n  }","id":74283,"modified_method":"public QualityGateDto rename(long idToRename, String name) {\n    checkPermission(UserSession.get());\n    QualityGateDto toRename = getNonNullQgate(idToRename);\n    validateQualityGate(idToRename, name);\n    toRename.setName(name);\n    dao.update(toRename);\n    return toRename;\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void setDefault(@Nullable Long idToUseAsDefault) {\n    checkPermission(UserSession.get());\n    if (idToUseAsDefault == null) {\n      propertiesDao.deleteGlobalProperty(SONAR_QUALITYGATE_PROPERTY);\n    } else {\n      QualityGateDto newDefault = getNonNull(idToUseAsDefault);\n      propertiesDao.setProperty(new PropertyDto().setKey(SONAR_QUALITYGATE_PROPERTY).setValue(newDefault.getName()));\n    }\n  }","id":74284,"modified_method":"public void setDefault(@Nullable Long idToUseAsDefault) {\n    checkPermission(UserSession.get());\n    if (idToUseAsDefault == null) {\n      propertiesDao.deleteGlobalProperty(SONAR_QUALITYGATE_PROPERTY);\n    } else {\n      QualityGateDto newDefault = getNonNullQgate(idToUseAsDefault);\n      propertiesDao.setProperty(new PropertyDto().setKey(SONAR_QUALITYGATE_PROPERTY).setValue(newDefault.getName()));\n    }\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public QualityGateConditionDto createCondition(long qGateId, long metricId, String operator,\n    @Nullable String warningThreshold, @Nullable String errorThreshold, @Nullable Integer period) {\n    return null;\n  }","id":74285,"modified_method":"public QualityGateConditionDto createCondition(long qGateId, String metricKey, String operator,\n    @Nullable String warningThreshold, @Nullable String errorThreshold, @Nullable Integer period) {\n    checkPermission(UserSession.get());\n    getNonNullQgate(qGateId);\n    Metric metric = getNonNullMetric(metricKey);\n    validateCondition(metric, operator, warningThreshold, errorThreshold, period);\n    QualityGateConditionDto newCondition = new QualityGateConditionDto().setQualityGateId(qGateId)\n      .setMetricId(metric.getId()).setMetricKey(metric.getKey())\n      .setOperator(operator).setWarningThreshold(warningThreshold).setErrorThreshold(errorThreshold).setPeriod(period);\n    conditionDao.insert(newCondition);\n    return newCondition;\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Before\n  public void initialize() {\n    qGates = new QualityGates(dao, conditionDao, propertiesDao);\n    UserSessionTestUtils.setUserSession(authorizedUserSession);\n  }","id":74286,"modified_method":"@Before\n  public void initialize() {\n    qGates = new QualityGates(dao, conditionDao, metricFinder, propertiesDao);\n    UserSessionTestUtils.setUserSession(authorizedUserSession);\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void destroy(Request request, Response response) {\n    qualityGates.delete(parse(request.requiredParam(\"id\")));\n    response.noContent();\n  }","id":74287,"modified_method":"protected void destroy(Request request, Response response) {\n    qualityGates.delete(parseId(request, \"id\"));\n    response.noContent();\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.newController(\"api/qualitygates\")\n      .setSince(\"4.3\")\n      .setDescription(\"This service can be used to manage quality gates, including requirements and project association.\");\n\n    controller.newAction(\"create\")\n      .setDescription(\"Create a quality gate, given its name.\")\n      .setPost(true)\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          create(request, response);\n        }\n    }).newParam(\"name\").setDescription(\"The name of the quality gate to create.\");\n\n    controller.newAction(\"set_as_default\")\n    .setDescription(\"Select the default quality gate.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        setDefault(request, response);\n      }\n    }).newParam(\"id\").setDescription(\"The ID of the quality gate to use as default.\");\n\n    controller.newAction(\"unset_default\")\n    .setDescription(\"Unselect the default quality gate.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        unsetDefault(response);\n      }\n    });\n\n    NewAction rename = controller.newAction(\"rename\")\n    .setDescription(\"Rename a quality gate, given its id and new name.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        rename(request, response);\n      }\n    });\n    rename.newParam(\"id\").setDescription(\"The ID of the quality gate to rename.\");\n    rename.newParam(\"name\").setDescription(\"The new name for the quality gate.\");\n\n    controller.newAction(\"list\")\n    .setDescription(\"List all quality gates.\")\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        list(request, response);\n      }\n    });\n\n    controller.newAction(\"destroy\")\n    .setDescription(\"Destroy a quality gate, given its id.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        destroy(request, response);\n      }\n    }).newParam(\"id\").setDescription(\"The numerical ID of the quality gate to destroy.\");\n\n    controller.done();\n  }","id":74288,"modified_method":"@Override\n  public void define(Context context) {\n    NewController controller = context.newController(\"api/qualitygates\")\n      .setSince(\"4.3\")\n      .setDescription(\"This service can be used to manage quality gates, including requirements and project association.\");\n\n    controller.newAction(\"create\")\n      .setDescription(\"Create a quality gate, given its name.\")\n      .setPost(true)\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          create(request, response);\n        }\n    }).newParam(\"name\").setDescription(\"The name of the quality gate to create.\");\n\n    controller.newAction(\"set_as_default\")\n    .setDescription(\"Select the default quality gate.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        setDefault(request, response);\n      }\n    }).newParam(\"id\").setDescription(\"The ID of the quality gate to use as default.\");\n\n    controller.newAction(\"unset_default\")\n    .setDescription(\"Unselect the default quality gate.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        unsetDefault(response);\n      }\n    });\n\n    NewAction rename = controller.newAction(\"rename\")\n    .setDescription(\"Rename a quality gate, given its id and new name.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        rename(request, response);\n      }\n    });\n    rename.newParam(\"id\").setDescription(\"The ID of the quality gate to rename.\");\n    rename.newParam(\"name\").setDescription(\"The new name for the quality gate.\");\n\n    controller.newAction(\"list\")\n    .setDescription(\"List all quality gates.\")\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        list(request, response);\n      }\n    });\n\n    controller.newAction(\"destroy\")\n    .setDescription(\"Destroy a quality gate, given its id.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        destroy(request, response);\n      }\n    }).newParam(\"id\").setDescription(\"The numerical ID of the quality gate to destroy.\");\n\n    NewAction createCondition = controller.newAction(\"create_condition\")\n    .setDescription(\"Add a new condition to a quality gate.\")\n    .setPost(true)\n    .setHandler(new RequestHandler() {\n      @Override\n      public void handle(Request request, Response response) {\n        createCondition(request, response);\n      }\n    });\n    createCondition.newParam(PARAM_GATE_ID).setDescription(\"The numerical ID of the quality gate.\");\n    createCondition.newParam(PARAM_METRIC).setDescription(\"The key for the metric tested by this condition.\");\n    createCondition.newParam(PARAM_OPERATOR).setDescription(\"The operator used for the test, one of 'EQ', 'NE', 'LT', 'GT'.\");\n    createCondition.newParam(PARAM_PERIOD).setDescription(\"The optional period to use (for differential measures).\");\n    createCondition.newParam(PARAM_WARNING).setDescription(\"An optional value for the warning threshold.\");\n    createCondition.newParam(PARAM_ERROR).setDescription(\"An optional value for the error threshold.\");\n\n    controller.done();\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void setDefault(Request request, Response response) {\n    qualityGates.setDefault(parse(request.requiredParam(\"id\")));\n    response.noContent();\n  }","id":74289,"modified_method":"protected void setDefault(Request request, Response response) {\n    qualityGates.setDefault(parseId(request, \"id\"));\n    response.noContent();\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"protected void rename(Request request, Response response) {\n    long idToRename = parse(request.requiredParam(\"id\"));\n    QualityGateDto renamedQualityGate = qualityGates.rename(idToRename, request.requiredParam(\"name\"));\n    JsonWriter writer = response.newJsonWriter();\n    writeQualityGate(renamedQualityGate, writer).close();\n  }","id":74290,"modified_method":"protected void rename(Request request, Response response) {\n    long idToRename = parseId(request, \"id\");\n    QualityGateDto renamedQualityGate = qualityGates.rename(idToRename, request.requiredParam(\"name\"));\n    JsonWriter writer = response.newJsonWriter();\n    writeQualityGate(renamedQualityGate, writer).close();\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void define_ws() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/qualitygates\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.path()).isEqualTo(\"api/qualitygates\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(6);\n\n    WebService.Action list = controller.action(\"list\");\n    assertThat(list).isNotNull();\n    assertThat(list.handler()).isNotNull();\n    assertThat(list.since()).isEqualTo(\"4.3\");\n    assertThat(list.isPost()).isFalse();\n    assertThat(list.isPrivate()).isFalse();\n\n    WebService.Action create = controller.action(\"create\");\n    assertThat(create).isNotNull();\n    assertThat(create.handler()).isNotNull();\n    assertThat(create.since()).isEqualTo(\"4.3\");\n    assertThat(create.isPost()).isTrue();\n    assertThat(create.param(\"name\")).isNotNull();\n    assertThat(create.isPrivate()).isFalse();\n\n    WebService.Action destroy = controller.action(\"destroy\");\n    assertThat(destroy).isNotNull();\n    assertThat(destroy.handler()).isNotNull();\n    assertThat(destroy.since()).isEqualTo(\"4.3\");\n    assertThat(destroy.isPost()).isTrue();\n    assertThat(destroy.param(\"id\")).isNotNull();\n    assertThat(destroy.isPrivate()).isFalse();\n\n    WebService.Action rename = controller.action(\"rename\");\n    assertThat(rename).isNotNull();\n    assertThat(rename.handler()).isNotNull();\n    assertThat(rename.since()).isEqualTo(\"4.3\");\n    assertThat(rename.isPost()).isTrue();\n    assertThat(rename.param(\"id\")).isNotNull();\n    assertThat(rename.param(\"name\")).isNotNull();\n    assertThat(rename.isPrivate()).isFalse();\n\n    WebService.Action setDefault = controller.action(\"set_as_default\");\n    assertThat(setDefault).isNotNull();\n    assertThat(setDefault.handler()).isNotNull();\n    assertThat(setDefault.since()).isEqualTo(\"4.3\");\n    assertThat(setDefault.isPost()).isTrue();\n    assertThat(setDefault.param(\"id\")).isNotNull();\n    assertThat(setDefault.isPrivate()).isFalse();\n\n    WebService.Action unsetDefault = controller.action(\"unset_default\");\n    assertThat(setDefault).isNotNull();\n    assertThat(setDefault.handler()).isNotNull();\n    assertThat(setDefault.since()).isEqualTo(\"4.3\");\n    assertThat(setDefault.isPost()).isTrue();\n    assertThat(setDefault.isPrivate()).isFalse();\n  }","id":74291,"modified_method":"@Test\n  public void define_ws() throws Exception {\n    WebService.Controller controller = tester.controller(\"api/qualitygates\");\n    assertThat(controller).isNotNull();\n    assertThat(controller.path()).isEqualTo(\"api/qualitygates\");\n    assertThat(controller.description()).isNotEmpty();\n    assertThat(controller.actions()).hasSize(7);\n\n    WebService.Action list = controller.action(\"list\");\n    assertThat(list).isNotNull();\n    assertThat(list.handler()).isNotNull();\n    assertThat(list.since()).isEqualTo(\"4.3\");\n    assertThat(list.isPost()).isFalse();\n    assertThat(list.isPrivate()).isFalse();\n\n    WebService.Action create = controller.action(\"create\");\n    assertThat(create).isNotNull();\n    assertThat(create.handler()).isNotNull();\n    assertThat(create.since()).isEqualTo(\"4.3\");\n    assertThat(create.isPost()).isTrue();\n    assertThat(create.param(\"name\")).isNotNull();\n    assertThat(create.isPrivate()).isFalse();\n\n    WebService.Action destroy = controller.action(\"destroy\");\n    assertThat(destroy).isNotNull();\n    assertThat(destroy.handler()).isNotNull();\n    assertThat(destroy.since()).isEqualTo(\"4.3\");\n    assertThat(destroy.isPost()).isTrue();\n    assertThat(destroy.param(\"id\")).isNotNull();\n    assertThat(destroy.isPrivate()).isFalse();\n\n    WebService.Action rename = controller.action(\"rename\");\n    assertThat(rename).isNotNull();\n    assertThat(rename.handler()).isNotNull();\n    assertThat(rename.since()).isEqualTo(\"4.3\");\n    assertThat(rename.isPost()).isTrue();\n    assertThat(rename.param(\"id\")).isNotNull();\n    assertThat(rename.param(\"name\")).isNotNull();\n    assertThat(rename.isPrivate()).isFalse();\n\n    WebService.Action setDefault = controller.action(\"set_as_default\");\n    assertThat(setDefault).isNotNull();\n    assertThat(setDefault.handler()).isNotNull();\n    assertThat(setDefault.since()).isEqualTo(\"4.3\");\n    assertThat(setDefault.isPost()).isTrue();\n    assertThat(setDefault.param(\"id\")).isNotNull();\n    assertThat(setDefault.isPrivate()).isFalse();\n\n    WebService.Action unsetDefault = controller.action(\"unset_default\");\n    assertThat(unsetDefault).isNotNull();\n    assertThat(unsetDefault.handler()).isNotNull();\n    assertThat(unsetDefault.since()).isEqualTo(\"4.3\");\n    assertThat(unsetDefault.isPost()).isTrue();\n    assertThat(unsetDefault.isPrivate()).isFalse();\n\n    WebService.Action createCondition = controller.action(\"create_condition\");\n    assertThat(createCondition).isNotNull();\n    assertThat(createCondition.handler()).isNotNull();\n    assertThat(createCondition.since()).isEqualTo(\"4.3\");\n    assertThat(createCondition.isPost()).isTrue();\n    assertThat(createCondition.param(\"gateId\")).isNotNull();\n    assertThat(createCondition.param(\"metric\")).isNotNull();\n    assertThat(createCondition.param(\"op\")).isNotNull();\n    assertThat(createCondition.param(\"warning\")).isNotNull();\n    assertThat(createCondition.param(\"error\")).isNotNull();\n    assertThat(createCondition.param(\"period\")).isNotNull();\n    assertThat(createCondition.isPrivate()).isFalse();\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private JsonWriter initErrorStream(int status, ServletResponse response) {\n    ServletResponse.ServletStream stream = response.stream();\n    stream.reset();\n    stream.setStatus(status);\n    stream.setMediaType(MimeTypes.JSON);\n    JsonWriter json = JsonWriter.of(new OutputStreamWriter(stream.output()));\n    return json;\n  }","id":74292,"modified_method":"private JsonWriter initErrorStream(int status, ServletResponse response) {\n    ServletResponse.ServletStream stream = response.stream();\n    stream.reset();\n    stream.setStatus(status);\n    stream.setMediaType(MimeTypes.JSON);\n    return JsonWriter.of(new OutputStreamWriter(stream.output()));\n  }","commit_id":"8482a79f90902dc08edb0ceeb6a43371313ca930","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void other(SNode node) {\n    SNodeOperations.isAttribute(node);\n    List<SNode> nodes = SNodeOperations.getAllAttributes(node);\n    SNode firstNode = SequenceOperations.getFirst(SNodeOperations.getAllAttributes(node));\n  }","id":74293,"modified_method":"public void other(SNode node) {\n    SNodeOperations.isAttribute(node);\n    List<SNode> nodes = SNodeOperations.getAllAttributes(node);\n    SNode firstNode = ListSequence.fromList(SNodeOperations.getAllAttributes(node)).first();\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void accessToNodeAttribute_1(SNode node) {\n    List<SNode> macros = SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SNode firstMacro = SequenceOperations.getFirst(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true));\n  }","id":74294,"modified_method":"public void accessToNodeAttribute_1(SNode node) {\n    List<SNode> macros = SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SNode firstMacro = ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).first();\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void accessToChildren_3(SNode statement) {\n    List<SNode> children1 = SNodeOperations.getDescendants(SLinkOperations.getTarget(statement, \"expression\", true), null, false);\n    List<SNode> children2 = SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", false);\n    List<SNode> children3 = SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", true);\n    Iterable<SNode> children4 = SequenceOperations.where(SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", false), new zPredicate(Children.this, null));\n    SNode abcdef;\n    SNodeOperations.getDescendants(statement, NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(statement)), false);\n    SNodeOperations.getDescendants(statement, NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(statement)), false);\n    SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", false);\n  }","id":74295,"modified_method":"public void accessToChildren_3(SNode statement) {\n    List<SNode> children1 = SNodeOperations.getDescendants(SLinkOperations.getTarget(statement, \"expression\", true), null, false);\n    List<SNode> children2 = SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", false);\n    List<SNode> children3 = SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", true);\n    Iterable<SNode> children4 = ListSequence.fromList(SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", false)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        return SPropertyOperations.getBoolean(it, \"value\") == true;\n      }\n\n    });\n    SNode abcdef;\n    SNodeOperations.getDescendants(statement, NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(statement)), false);\n    SNodeOperations.getDescendants(statement, null, false);\n    SNodeOperations.getDescendants(statement, NameUtil.nodeFQName(SNodeOperations.getConceptDeclaration(statement)), false);\n    SNodeOperations.getDescendants(statement, \"jetbrains.mps.baseLanguage.structure.BooleanConstant\", false);\n    SNodeOperations.getDescendants(statement, NameUtil.nodeFQName(SConceptOperations.findConceptDeclaration(\"jetbrains.mps.baseLanguage.structure.BooleanConstant\")), false);\n    SNode aConcept = null;\n    SNodeOperations.getDescendants(statement, NameUtil.nodeFQName(aConcept), false);\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void accessToChildren_1(SNode statementList) {\n    BaseConcept_Behavior.call_getPresentation_1180102203531(statementList);\n    int count1 = SLinkOperations.getCount(statementList, \"statement\");\n    List<SNode> statements = SLinkOperations.getTargets(statementList, \"statement\", true);\n    int count2 = SequenceOperations.getSize(statements);\n    int count3 = ((List<SNode>)statements).size();\n  }","id":74296,"modified_method":"public void accessToChildren_1(SNode statementList) {\n    BaseConcept_Behavior.call_getPresentation_1180102203531(statementList);\n    int count1 = SLinkOperations.getCount(statementList, \"statement\");\n    List<SNode> statements = SLinkOperations.getTargets(statementList, \"statement\", true);\n    int count2 = ListSequence.fromList(statements).count();\n    int count3 = ((List<SNode>)statements).size();\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void accessToChildren_2(SNode statementList1, SNode statementList2) {\n    SLinkOperations.addNewChild(statementList1, \"statement\", \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n    SLinkOperations.addNewChild(statementList1, \"statement\", \"jetbrains.mps.baseLanguage.structure.IfStatement\");\n    SLinkOperations.addNewChild(statementList1, \"statement\", \"jetbrains.mps.baseLanguage.structure.ReturnStatement\");\n    for(SNode statement : SLinkOperations.getTargets(statementList1, \"statement\", true)) {\n      SLinkOperations.addChild(statementList2, \"statement\", SNodeOperations.copyNode(statement));\n    }\n    for(SNode statement : SLinkOperations.getTargets(statementList1, \"statement\", true)) {\n      SLinkOperations.addChild(statementList2, \"statement\", SNodeOperations.copyNode(statement));\n    }\n    for(SNode statement : SLinkOperations.getTargets(statementList1, \"statement\", true)) {\n      SLinkOperations.addChild(statementList2, \"statement\", SNodeOperations.copyNode(statement));\n    }\n    {\n      ICursor<SNode> _zCursor = CursorFactory.createCursor(SLinkOperations.getTargets(statementList2, \"statement\", true));\n      try {\n        while(_zCursor.moveToNext()) {\n          SNode statement = _zCursor.getCurrent();\n          SLinkOperations.addChild(statementList2, \"statement\", SequenceOperations.getFirst(SLinkOperations.getTargets(statementList2, \"statement\", true)));\n        }\n      } finally {\n        _zCursor.release();\n      }\n    }\n  }","id":74297,"modified_method":"public void accessToChildren_2(SNode statementList1, SNode statementList2) {\n    SLinkOperations.addNewChild(statementList1, \"statement\", \"jetbrains.mps.baseLanguage.structure.LocalVariableDeclarationStatement\");\n    SLinkOperations.addNewChild(statementList1, \"statement\", \"jetbrains.mps.baseLanguage.structure.IfStatement\");\n    SLinkOperations.addNewChild(statementList1, \"statement\", \"jetbrains.mps.baseLanguage.structure.ReturnStatement\");\n    for(SNode statement : SLinkOperations.getTargets(statementList1, \"statement\", true)) {\n      SLinkOperations.addChild(statementList2, \"statement\", SNodeOperations.copyNode(statement));\n    }\n    for(SNode statement : SLinkOperations.getTargets(statementList1, \"statement\", true)) {\n      SLinkOperations.addChild(statementList2, \"statement\", SNodeOperations.copyNode(statement));\n    }\n    for(SNode statement : SLinkOperations.getTargets(statementList1, \"statement\", true)) {\n      SLinkOperations.addChild(statementList2, \"statement\", SNodeOperations.copyNode(statement));\n    }\n    for(SNode statement : SLinkOperations.getTargets(statementList2, \"statement\", true)) {\n      SLinkOperations.addChild(statementList2, \"statement\", ListSequence.fromList(SLinkOperations.getTargets(statementList2, \"statement\", true)).first());\n    }\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void first(SNode sl) {\n    SequenceOperations.getFirst(SLinkOperations.getTargets(sl, \"statement\", true));\n    Iterable<SNode> nodes = SequenceOperations.where(SLinkOperations.getTargets(sl, \"statement\", true), new zPredicate3(ListOfNodes.this, null));\n  }","id":74298,"modified_method":"public void first(SNode sl) {\n    ListSequence.fromList(SLinkOperations.getTargets(sl, \"statement\", true)).first();\n    Iterable<SNode> nodes = ListSequence.fromList(SLinkOperations.getTargets(sl, \"statement\", true)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(it, \"jetbrains.mps.baseLanguage.structure.IfStatement\");\n      }\n\n    });\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void newList(SNode e1, SNode e2) {\n    List<SNode> list = ListOperations.<SNode>createList(e1, e2);\n  }","id":74299,"modified_method":"public void newList(SNode e1, SNode e2) {\n    List<SNode> list = ListSequence.<SNode>fromArray(e1, e2);\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void nodes_access_1(SModel model) {\n    List<SNode> nodes1 = SModelOperations.getNodes(model, null);\n    List<SNode> nodes2 = SModelOperations.getNodes(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    Iterable<SNode> nodes3 = SequenceOperations.where(SModelOperations.getNodes(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), new zPredicate2(Model.this, null));\n  }","id":74300,"modified_method":"public void nodes_access_1(SModel model) {\n    List<SNode> nodes1 = SModelOperations.getNodes(model, null);\n    List<SNode> nodes2 = SModelOperations.getNodes(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    Iterable<SNode> nodes3 = ListSequence.fromList(SModelOperations.getNodes(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode c) {\n        return SPropertyOperations.hasValue(c, \"name\", \"Utils\");\n      }\n\n    });\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void roots_access_1(SModel model) {\n    List<SNode> roots1 = SModelOperations.getRoots(model, null);\n    List<SNode> roots2 = SModelOperations.getRoots(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    Iterable<SNode> roots3 = SequenceOperations.where(SModelOperations.getRoots(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\"), new zPredicate1(Model.this, null));\n  }","id":74301,"modified_method":"public void roots_access_1(SModel model) {\n    List<SNode> roots1 = SModelOperations.getRoots(model, null);\n    List<SNode> roots2 = SModelOperations.getRoots(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\");\n    Iterable<SNode> roots3 = ListSequence.fromList(SModelOperations.getRoots(model, \"jetbrains.mps.baseLanguage.structure.ClassConcept\")).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode c) {\n        return SPropertyOperations.hasValue(c, \"name\", \"Utils\");\n      }\n\n    });\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void countChildren(SNode methodCall) {\n    int count_verbose_not_efficient = SequenceOperations.getSize(((List<SNode>)SLinkOperations.getTargets(methodCall, \"actualArgument\", true)));\n    int count_not_efficient = SequenceOperations.getSize(SLinkOperations.getTargets(methodCall, \"actualArgument\", true));\n    int count_not_efficient2 = SLinkOperations.getTargets(methodCall, \"actualArgument\", true).size();\n    int count_best = SLinkOperations.getCount(methodCall, \"actualArgument\");\n  }","id":74302,"modified_method":"public void countChildren(SNode methodCall) {\n    int count_verbose_not_efficient = ListSequence.fromList(((List<SNode>)SLinkOperations.getTargets(methodCall, \"actualArgument\", true))).count();\n    int count_not_efficient = ListSequence.fromList(SLinkOperations.getTargets(methodCall, \"actualArgument\", true)).count();\n    int count_not_efficient2 = SLinkOperations.getTargets(methodCall, \"actualArgument\", true).size();\n    int count_best = SLinkOperations.getCount(methodCall, \"actualArgument\");\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void cast_snodes_to_List(List<SNode> statements) {\n    List list1 = statements;\n    List<SNode> list2 = statements;\n  }","id":74303,"modified_method":"public void cast_nlist_to_List(List<SNode> statements) {\n    List list1 = statements;\n    List<SNode> list2 = statements;\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void cast_SNode_to_snode(SNode node) {\n    SNode snode1 = node;\n    SNode snode2 = (SNode)node;\n  }","id":74304,"modified_method":"public void cast_SNode_to_node(SNode node) {\n    SNode node1 = node;\n    SNode node2 = (SNode)node;\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void cast_children_to_snodes(SNode statementList) {\n    List<SNode> statements = SLinkOperations.getTargets(statementList, \"statement\", true);\n  }","id":74305,"modified_method":"public void cast_children_to_nlist(SNode statementList) {\n    List<SNode> statements = SLinkOperations.getTargets(statementList, \"statement\", true);\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void cast_snode_to_SNode(SNode ifStatement) {\n    SNode nodeObject1 = ifStatement;\n    SNode nodeObject2 = (SNode)SLinkOperations.getTarget(ifStatement, \"condition\", true);\n    SNode nodeObject3 = SLinkOperations.getTarget(ifStatement, \"condition\", true);\n    SNode expression = nodeObject3;\n  }","id":74306,"modified_method":"public void cast_node_to_SNode(SNode ifStatement) {\n    SNode nodeObject1 = ifStatement;\n    SNode nodeObject2 = (SNode)SLinkOperations.getTarget(ifStatement, \"condition\", true);\n    SNode nodeObject3 = SLinkOperations.getTarget(ifStatement, \"condition\", true);\n    SNode expression = nodeObject3;\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode op) {\n    RulesUtil.checkAppliedTo_LinkListAccess_aggregation(op);\n    final SNode Concept_typevar_1206099501305 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);\n    RulesUtil.equate_inputNodeConcept(op, TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099501305));\n    {\n      final SNode concreteConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099501305);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(concreteConcept, new Runnable() {\n\n        public void run() {\n          SNode resultConcept = null;\n          SNode parameterConcept = SLinkOperations.getTarget(op, \"concept\", false);\n          if (parameterConcept == null) {\n            resultConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept);\n          } else\n          {\n            resultConcept = parameterConcept;\n            if (!(SConceptOperations.isSubConceptOf(parameterConcept, NameUtil.nodeFQName(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept))))) {\n              TypeChecker.getInstance().reportTypeError(op, SPropertyOperations.getString(parameterConcept, \"name\") + \" is not sub-concept of \" + SPropertyOperations.getString(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept), \"name\"), \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771608879\");\n            }\n          }\n          TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(op, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771608897\", true), new QuotationClass_69().createNode(resultConcept), op, null, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771608895\");\n        }\n\n      }, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771551269\");\n    }\n  }","id":74307,"modified_method":"public void applyRule(final SNode op) {\n    RulesUtil.checkAppliedTo_LinkListAccess_aggregation(op);\n    final SNode Concept_typevar_1206099501305 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);\n    RulesUtil.equate_inputNodeConcept(op, TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099501305));\n    {\n      final SNode concreteConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099501305);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(concreteConcept, new Runnable() {\n\n        public void run() {\n          SNode resultConcept;\n          SNode parameterConcept = SLinkOperations.getTarget(op, \"concept\", false);\n          if (parameterConcept == null) {\n            resultConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept);\n          } else\n          {\n            resultConcept = parameterConcept;\n            if (!(SConceptOperations.isSubConceptOf(parameterConcept, NameUtil.nodeFQName(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept))))) {\n              TypeChecker.getInstance().reportTypeError(op, SPropertyOperations.getString(parameterConcept, \"name\") + \" is not sub-concept of \" + SPropertyOperations.getString(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept), \"name\"), \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771608879\");\n            }\n          }\n          TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(op, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771608897\", true), new QuotationClass_69().createNode(resultConcept), op, null, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771608895\");\n        }\n\n      }, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205771551269\");\n    }\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode op) {\n    RulesUtil.checkAppliedTo_LinkAccess_aggregation(op);\n    final SNode Concept_typevar_1206099875685 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);\n    RulesUtil.equate_inputNodeConcept(op, TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099875685));\n    {\n      final SNode concreteConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099875685);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(concreteConcept, new Runnable() {\n\n        public void run() {\n          SNode resultConcept = null;\n          SNode parameterConcept = SLinkOperations.getTarget(op, \"concept\", false);\n          if (parameterConcept == null) {\n            resultConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept);\n          } else\n          {\n            resultConcept = parameterConcept;\n            if (!(SConceptOperations.isSubConceptOf(parameterConcept, NameUtil.nodeFQName(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept))))) {\n              TypeChecker.getInstance().reportTypeError(op, SPropertyOperations.getString(parameterConcept, \"name\") + \" is not sub-concept of \" + SPropertyOperations.getString(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept), \"name\"), \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442304609\");\n            }\n          }\n          TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(op, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442304627\", true), new QuotationClass_67().createNode(resultConcept), op, null, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442304625\");\n        }\n\n      }, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442246000\");\n    }\n  }","id":74308,"modified_method":"public void applyRule(final SNode op) {\n    RulesUtil.checkAppliedTo_LinkAccess_aggregation(op);\n    final SNode Concept_typevar_1206099875685 = TypeChecker.getInstance().getRuntimeSupport().createNewRuntimeTypesVariable(false);\n    RulesUtil.equate_inputNodeConcept(op, TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099875685));\n    {\n      final SNode concreteConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(Concept_typevar_1206099875685);\n      TypeChecker.getInstance().getRuntimeSupport().whenConcrete(concreteConcept, new Runnable() {\n\n        public void run() {\n          SNode resultConcept;\n          SNode parameterConcept = SLinkOperations.getTarget(op, \"concept\", false);\n          if (parameterConcept == null) {\n            resultConcept = TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept);\n          } else\n          {\n            resultConcept = parameterConcept;\n            if (!(SConceptOperations.isSubConceptOf(parameterConcept, NameUtil.nodeFQName(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept))))) {\n              TypeChecker.getInstance().reportTypeError(op, SPropertyOperations.getString(parameterConcept, \"name\") + \" is not sub-concept of \" + SPropertyOperations.getString(TypeChecker.getInstance().getEquationManager().getRepresentator(concreteConcept), \"name\"), \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442304609\");\n            }\n          }\n          TypeChecker.getInstance().getRuntimeSupport().createEquation(TypeChecker.getInstance().getRuntimeSupport().typeOf(op, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442304627\", true), new QuotationClass_67().createNode(resultConcept), op, null, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442304625\");\n        }\n\n      }, \"jetbrains.mps.bootstrap.smodelLanguage.helgins\", \"1205442246000\");\n    }\n  }","commit_id":"6a4d35b694fe729f3293d576cecd3335fbbe672a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method6(SNode node) {\n    // attribute list access\n    List<SNode> nodes = SLinkOperations.getTargets(node, \"statement\", true);\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addChild(node, \"statement\", null);\n    SLinkOperations.addAll(node, \"statement\", null);\n    SLinkOperations.insertChildFirst(node, \"statement\", null);\n    int c1 = SLinkOperations.getCount(node, \"statement\");\n    List<SNode> macros = SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.transformation.TLBase.structure.NodeMacro\");\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.transformation.TLBase.structure.NodeMacro\");\n    SLinkOperations.addChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    SLinkOperations.addAll(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    SLinkOperations.insertChildFirst(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    int c2 = SLinkOperations.getCount(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"));\n    int c3 = SequenceOperations.count(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true));\n    // not a link\n    int all = SequenceOperations.count(SNodeOperations.getAllAttributes(node));\n    SNodeOperations.copyNode(SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), true));\n  }","id":74309,"modified_method":"public void method6(SNode node) {\n    // attribute list access\n    List<SNode> nodes = SLinkOperations.getTargets(node, \"statement\", true);\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addNewChild(node, \"statement\", \"jetbrains.mps.baseLanguage.structure.Statement\");\n    SLinkOperations.addChild(node, \"statement\", null);\n    SLinkOperations.addAll(node, \"statement\", null);\n    SLinkOperations.insertChildFirst(node, \"statement\", null);\n    int c1 = SLinkOperations.getCount(node, \"statement\");\n    List<SNode> macros = SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.transformation.TLBase.structure.NodeMacro\");\n    SLinkOperations.addNewChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), \"jetbrains.mps.transformation.TLBase.structure.NodeMacro\");\n    SLinkOperations.addChild(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    SLinkOperations.addAll(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    SLinkOperations.insertChildFirst(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), null);\n    int c2 = SLinkOperations.getCount(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"));\n    int c3 = ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).count();\n    // not a link\n    int all = ListSequence.fromList(SNodeOperations.getAllAttributes(node)).count();\n    SNodeOperations.copyNode(SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), true));\n  }","commit_id":"937e548bdf4b29fbc12a562ac225d7907dd26fd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method5(SNode node) {\n    // single attribute access\n    SNode expression = SLinkOperations.getTarget(node, \"expression\", true);\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.Expression\");\n    SNode ex = SLinkOperations.deleteChild(node, \"expression\");\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.transformation.TLBase.structure.PropertyMacro\");\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.transformation.TLBase.structure.PropertyMacro\");\n    SNode macro = SLinkOperations.deleteChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"));\n  }","id":74310,"modified_method":"public void method5(SNode node) {\n    // single attribute access\n    SNode expression = SLinkOperations.getTarget(node, \"expression\", true);\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.BinaryOperation\");\n    SLinkOperations.setNewChild(node, \"expression\", \"jetbrains.mps.baseLanguage.structure.Expression\");\n    SNode ex = SLinkOperations.removeChild(node, \"expression\");\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.transformation.TLBase.structure.PropertyMacro\");\n    SLinkOperations.setNewChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"), \"jetbrains.mps.transformation.TLBase.structure.PropertyMacro\");\n    SNode macro = SLinkOperations.removeChild(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"alias\"));\n  }","commit_id":"937e548bdf4b29fbc12a562ac225d7907dd26fd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method1(SNode node) {\n    SNodeOperations.isAttribute(node);\n    List<SNode> nodes = SNodeOperations.getAllAttributes(node);\n    SNode firstNode = SequenceOperations.getFirst(SNodeOperations.getAllAttributes(node));\n  }","id":74311,"modified_method":"public void method1(SNode node) {\n    SNodeOperations.isAttribute(node);\n    List<SNode> nodes = SNodeOperations.getAllAttributes(node);\n    SNode firstNode = ListSequence.fromList(SNodeOperations.getAllAttributes(node)).first();\n  }","commit_id":"937e548bdf4b29fbc12a562ac225d7907dd26fd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method7(SNode node) {\n    Iterable<SNode> seq = SequenceOperations.where(SLinkOperations.getTargets(node, \"statement\", true), new zPredicate(Class1.this, null));\n    {\n      ICursor<SNode> _zCursor = CursorFactory.createCursor(SLinkOperations.getTargets(node, \"statement\", true));\n      try {\n        while(_zCursor.moveToNext()) {\n          SNode statement = _zCursor.getCurrent();\n          {\n            String string = SPropertyOperations.getString(statement, \"alias\");\n          }\n        }\n      } finally {\n        _zCursor.release();\n      }\n    }\n  }","id":74312,"modified_method":"public void method7(SNode node) {\n    Iterable<SNode> seq = ListSequence.fromList(SLinkOperations.getTargets(node, \"statement\", true)).where(new IWhereFilter <SNode>() {\n\n      public boolean accept(SNode it) {\n        return SNodeOperations.isInstanceOf(SLinkOperations.getTarget(it, \"expression\", true), \"jetbrains.mps.baseLanguage.structure.NullLiteral\");\n      }\n\n    });\n    for(SNode statement : SLinkOperations.getTargets(node, \"statement\", true)) {\n      String string = SPropertyOperations.getString(statement, \"alias\");\n    }\n  }","commit_id":"937e548bdf4b29fbc12a562ac225d7907dd26fd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method4(SNode node) {\n    SNode conceptDeclaration = SLinkOperations.getTarget(node, \"conceptDeclaration\", false);\n    SLinkOperations.setTarget(node, \"conceptDeclaration\", null, false);\n    SLinkOperations.setTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"conceptDeclaration\"), null, true);\n    SLinkOperations.setTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"conceptDeclaration\"), SConceptOperations.createNewNode(\"jetbrains.mps.transformation.TLBase.structure.ReferenceMacro\", null), true);\n  }","id":74313,"modified_method":"public void method4(SNode node) {\n    SNode variableDeclaration = SLinkOperations.getTarget(node, \"variableDeclaration\", false);\n    SLinkOperations.setTarget(node, \"variableDeclaration\", null, false);\n    SLinkOperations.setTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"variableDeclaration\"), null, true);\n    SLinkOperations.setTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"localVariableDeclaration\"), SConceptOperations.createNewNode(\"jetbrains.mps.transformation.TLBase.structure.ReferenceMacro\", null), true);\n  }","commit_id":"937e548bdf4b29fbc12a562ac225d7907dd26fd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method2(SNode node) {\n    List<SNode> macros = SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SNode firstMacro = SequenceOperations.getFirst(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true));\n    SNode propertyMacro = SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"name\"), true);\n    SNode concept = SNodeOperations.getConceptDeclaration(SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"name\"), true));\n  }","id":74314,"modified_method":"public void method2(SNode node) {\n    List<SNode> macros = SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true);\n    SNode firstMacro = ListSequence.fromList(SLinkOperations.getTargets(node, AttributesRolesUtil.childRoleFromAttributeRole(\"nodeMacro\"), true)).first();\n    SNode propertyMacro = SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"name\"), true);\n    SNode concept = SNodeOperations.getConceptDeclaration(SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromPropertyAttributeRole(\"propertyMacro\", \"name\"), true));\n  }","commit_id":"937e548bdf4b29fbc12a562ac225d7907dd26fd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void method3(SNode node) {\n    SNode macro = SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"conceptDeclaration\"), true);\n    SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"xoxoxoxo\"), true);\n  }","id":74315,"modified_method":"public void method3(SNode node) {\n    SNode macro = SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"variableDeclaration\"), true);\n    SLinkOperations.getTarget(node, AttributesRolesUtil.childRoleFromLinkAttributeRole(\"referenceMacro\", \"xoxoxoxo\"), true);\n  }","commit_id":"937e548bdf4b29fbc12a562ac225d7907dd26fd9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public ISearchScope createNodeReferentSearchScope(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    List<SNode> result = new ArrayList<SNode>();\n    {\n      ICursor<SNode> _zCursor19 = CursorFactory.createCursor(SNodeOperations.getAncestors(_context.getEnclosingNode(), \"jetbrains.mps.buildlanguage.structure.IPropertyHolder\", true));\n      try {\n        while(_zCursor19.moveToNext()) {\n          SNode holder = _zCursor19.getCurrent();\n          ListOperations.addAllElements(result, IPropertyHolder_Behavior.call_getProperties_1200425502495(holder));\n        }\n      } finally {\n        _zCursor19.release();\n      }\n    }\n    return new SimpleSearchScope(result);\n  }","id":74316,"modified_method":"public ISearchScope createNodeReferentSearchScope(final IOperationContext operationContext, final ReferentConstraintContext _context) {\n    List<SNode> result = new ArrayList<SNode>();\n    for(SNode holder : SNodeOperations.getAncestors(_context.getEnclosingNode(), \"jetbrains.mps.buildlanguage.structure.IPropertyHolder\", true)) {\n      ListSequence.fromList(result).addSequence(ListSequence.fromList(IPropertyHolder_Behavior.call_getProperties_1200425502495(holder)));\n    }\n    return new SimpleSearchScope(result);\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void setupBasic_ConstantCell(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209564349820\");\n  }","id":74317,"modified_method":"private static void setupBasic_ConstantCell(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209893955435\");\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void setupBasic_ConstantCell1(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209564349821\");\n  }","id":74318,"modified_method":"private static void setupBasic_ConstantCell1(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209893955437\");\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void setupBasic_RowCell1(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209564349819\");\n  }","id":74319,"modified_method":"private static void setupBasic_RowCell1(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209893955433\");\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void setupBasic_RowCell(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209564349818\");\n    editorCell.setSelectable(false);\n  }","id":74320,"modified_method":"private static void setupBasic_RowCell(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209893955468\");\n    editorCell.setSelectable(false);\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static void setupBasic_DependsList(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209564349822\");\n  }","id":74321,"modified_method":"private static void setupBasic_DependsList(EditorCell editorCell, SNode node, EditorContext context) {\n    editorCell.putUserObject(EditorCell.CELL_ID, node.getId() + \"_1209893955439\");\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static boolean _QueryFunction_NodeCondition_1209564349823(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(node, \"depends\") != 0 || editorContext.isInspector();\n  }","id":74322,"modified_method":"public static boolean _QueryFunction_NodeCondition_1209893955441(SNode node, EditorContext editorContext, IScope scope) {\n    return SLinkOperations.getCount(node, \"depends\") != 0 || editorContext.isInspector();\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public EditorCell createRowCell(EditorContext context, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    TargetDeclaration_EditorComponent.setupBasic_RowCell(editorCell, node, context);\n    editorCell.setGridLayout(false);\n    editorCell.setUsesBraces(false);\n    editorCell.setCanBeFolded(false);\n    if (TargetDeclaration_EditorComponent._QueryFunction_NodeCondition_1209564349823(node, context, context.getOperationContext().getScope())) {\n      editorCell.addEditorCell(this.createRowCell1(context, node));\n    }\n    return editorCell;\n  }","id":74323,"modified_method":"public EditorCell createRowCell(EditorContext context, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createHorizontal(context, node);\n    TargetDeclaration_EditorComponent.setupBasic_RowCell(editorCell, node, context);\n    editorCell.setGridLayout(false);\n    editorCell.setUsesBraces(false);\n    editorCell.setCanBeFolded(false);\n    if (TargetDeclaration_EditorComponent._QueryFunction_NodeCondition_1209893955441(node, context, context.getOperationContext().getScope())) {\n      editorCell.addEditorCell(this.createRowCell1(context, node));\n    }\n    return editorCell;\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public void applyRule(final SNode nodeToCheck) {\n    {\n      ICursor<SNode> _zCursor = CursorFactory.createCursor(SLinkOperations.getTargets(nodeToCheck, \"constants\", true));\n      try {\n        while(_zCursor.moveToNext()) {\n          SNode element = _zCursor.getCurrent();\n          TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(element, \"jetbrains.mps.buildlanguage.helgins\", \"1197401239298\", true), SequenceOperations.getFirst(SLinkOperations.getConceptLinkTargets(nodeToCheck, \"type\")), element, null, \"jetbrains.mps.buildlanguage.helgins\", \"1197401256457\", false);\n        }\n      } finally {\n        _zCursor.release();\n      }\n    }\n  }","id":74324,"modified_method":"public void applyRule(final SNode nodeToCheck) {\n    for(SNode element : SLinkOperations.getTargets(nodeToCheck, \"constants\", true)) {\n      TypeChecker.getInstance().getRuntimeSupport().createLessThanInequation(TypeChecker.getInstance().getRuntimeSupport().typeOf(element, \"jetbrains.mps.buildlanguage.helgins\", \"1197401239298\", true), ListSequence.fromList(SLinkOperations.getConceptLinkTargets(nodeToCheck, \"type\")).first(), element, null, \"jetbrains.mps.buildlanguage.helgins\", \"1197401256457\", false);\n    }\n  }","commit_id":"b3b1bbbdd7a4a16fedad0184824711326713523a","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected void startWebApp() {\n    Configuration conf = getConfig();\n    // Play trick to make the customized filter will only be loaded by the\n    // timeline server when security is enabled and Kerberos authentication\n    // is used.\n    if (UserGroupInformation.isSecurityEnabled()\n        && conf\n            .get(TimelineAuthenticationFilterInitializer.PREFIX + \"type\", \"\")\n            .equals(\"kerberos\")) {\n      String initializers = conf.get(\"hadoop.http.filter.initializers\");\n      initializers =\n          initializers == null || initializers.length() == 0 ? \"\" : \",\"\n              + initializers;\n      if (!initializers.contains(\n          TimelineAuthenticationFilterInitializer.class.getName())) {\n        conf.set(\"hadoop.http.filter.initializers\",\n            TimelineAuthenticationFilterInitializer.class.getName()\n            + initializers);\n      }\n    }\n    String bindAddress = WebAppUtils.getAHSWebAppURLWithoutScheme(conf);\n    LOG.info(\"Instantiating AHSWebApp at \" + bindAddress);\n    try {\n      AHSWebApp ahsWebApp = AHSWebApp.getInstance();\n      ahsWebApp.setApplicationHistoryManager(historyManager);\n      ahsWebApp.setTimelineStore(timelineStore);\n      ahsWebApp.setTimelineDelegationTokenSecretManagerService(secretManagerService);\n      ahsWebApp.setTimelineACLsManager(timelineACLsManager);\n      webApp =\n          WebApps\n            .$for(\"applicationhistory\", ApplicationHistoryClientService.class,\n                ahsClientService, \"ws\")\n            .with(conf).at(bindAddress).start(ahsWebApp);\n    } catch (Exception e) {\n      String msg = \"AHSWebApp failed to start.\";\n      LOG.error(msg, e);\n      throw new YarnRuntimeException(msg, e);\n    }\n  }","id":74325,"modified_method":"protected void startWebApp() {\n    Configuration conf = getConfig();\n    // Always load pseudo authentication filter to parse \"user.name\" in an URL\n    // to identify a HTTP request's user in insecure mode.\n    // When Kerberos authentication type is set (i.e., secure mode is turned on),\n    // the customized filter will be loaded by the timeline server to do Kerberos\n    // + DT authentication.\n    String initializers = conf.get(\"hadoop.http.filter.initializers\");\n    initializers =\n        initializers == null || initializers.length() == 0 ? \"\" : \",\"\n            + initializers;\n    if (!initializers.contains(\n        TimelineAuthenticationFilterInitializer.class.getName())) {\n      conf.set(\"hadoop.http.filter.initializers\",\n          TimelineAuthenticationFilterInitializer.class.getName()\n              + initializers);\n    }\n    String bindAddress = WebAppUtils.getAHSWebAppURLWithoutScheme(conf);\n    LOG.info(\"Instantiating AHSWebApp at \" + bindAddress);\n    try {\n      AHSWebApp ahsWebApp = AHSWebApp.getInstance();\n      ahsWebApp.setApplicationHistoryManager(historyManager);\n      ahsWebApp.setTimelineStore(timelineStore);\n      ahsWebApp.setTimelineDelegationTokenSecretManagerService(secretManagerService);\n      ahsWebApp.setTimelineACLsManager(timelineACLsManager);\n      webApp =\n          WebApps\n            .$for(\"applicationhistory\", ApplicationHistoryClientService.class,\n                ahsClientService, \"ws\")\n            .with(conf).at(bindAddress).start(ahsWebApp);\n    } catch (Exception e) {\n      String msg = \"AHSWebApp failed to start.\";\n      LOG.error(msg, e);\n      throw new YarnRuntimeException(msg, e);\n    }\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  public Response toResponse(Exception e) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"GOT EXCEPITION\", e);\n    }\n    // Don't catch this as filter forward on 404\n    // (ServletContainer.FEATURE_FILTER_FORWARD_ON_404)\n    // won't work and the web UI won't work!\n    if (e instanceof com.sun.jersey.api.NotFoundException) {\n      return ((com.sun.jersey.api.NotFoundException) e).getResponse();\n    }\n    // clear content type\n    response.setContentType(null);\n\n    // Convert exception\n    if (e instanceof RemoteException) {\n      e = ((RemoteException) e).unwrapRemoteException();\n    }\n\n    // Map response status\n    final Response.Status s;\n    if (e instanceof SecurityException) {\n      s = Response.Status.UNAUTHORIZED;\n    } else if (e instanceof AuthorizationException) {\n      s = Response.Status.UNAUTHORIZED;\n    } else if (e instanceof FileNotFoundException) {\n      s = Response.Status.NOT_FOUND;\n    } else if (e instanceof NotFoundException) {\n      s = Response.Status.NOT_FOUND;\n    } else if (e instanceof IOException) {\n      s = Response.Status.NOT_FOUND;\n    } else if (e instanceof UnsupportedOperationException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof IllegalArgumentException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof NumberFormatException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof BadRequestException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof WebApplicationException\n        && e.getCause() instanceof UnmarshalException) {\n      s = Response.Status.BAD_REQUEST;\n    } else {\n      LOG.warn(\"INTERNAL_SERVER_ERROR\", e);\n      s = Response.Status.INTERNAL_SERVER_ERROR;\n    }\n\n    // let jaxb handle marshalling data out in the same format requested\n    RemoteExceptionData exception = new RemoteExceptionData(e.getClass().getSimpleName(),\n       e.getMessage(), e.getClass().getName());\n\n    return Response.status(s).entity(exception)\n        .build();\n  }","id":74326,"modified_method":"@Override\n  public Response toResponse(Exception e) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"GOT EXCEPITION\", e);\n    }\n    // Don't catch this as filter forward on 404\n    // (ServletContainer.FEATURE_FILTER_FORWARD_ON_404)\n    // won't work and the web UI won't work!\n    if (e instanceof com.sun.jersey.api.NotFoundException) {\n      return ((com.sun.jersey.api.NotFoundException) e).getResponse();\n    }\n    // clear content type\n    response.setContentType(null);\n\n    // Convert exception\n    if (e instanceof RemoteException) {\n      e = ((RemoteException) e).unwrapRemoteException();\n    }\n\n    // Map response status\n    final Response.Status s;\n    if (e instanceof SecurityException) {\n      s = Response.Status.UNAUTHORIZED;\n    } else if (e instanceof AuthorizationException) {\n      s = Response.Status.UNAUTHORIZED;\n    } else if (e instanceof FileNotFoundException) {\n      s = Response.Status.NOT_FOUND;\n    } else if (e instanceof NotFoundException) {\n      s = Response.Status.NOT_FOUND;\n    } else if (e instanceof IOException) {\n      s = Response.Status.NOT_FOUND;\n    } else if (e instanceof ForbiddenException) {\n      s = Response.Status.FORBIDDEN;\n    } else if (e instanceof UnsupportedOperationException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof IllegalArgumentException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof NumberFormatException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof BadRequestException) {\n      s = Response.Status.BAD_REQUEST;\n    } else if (e instanceof WebApplicationException\n        && e.getCause() instanceof UnmarshalException) {\n      s = Response.Status.BAD_REQUEST;\n    } else {\n      LOG.warn(\"INTERNAL_SERVER_ERROR\", e);\n      s = Response.Status.INTERNAL_SERVER_ERROR;\n    }\n\n    // let jaxb handle marshalling data out in the same format requested\n    RemoteExceptionData exception = new RemoteExceptionData(e.getClass().getSimpleName(),\n       e.getMessage(), e.getClass().getName());\n\n    return Response.status(s).entity(exception)\n        .build();\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testMassiveWriteContainerHistory() throws IOException {\n    long mb = 1024 * 1024;\n    Runtime runtime = Runtime.getRuntime();\n    long usedMemoryBefore = (runtime.totalMemory() - runtime.freeMemory()) / mb;\n    int numContainers = 100000;\n    ApplicationId appId = ApplicationId.newInstance(0, 1);\n    ApplicationAttemptId appAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    for (int i = 1; i <= numContainers; ++i) {\n      ContainerId containerId = ContainerId.newInstance(appAttemptId, i);\n      writeContainerStartData(containerId);\n      writeContainerFinishData(containerId);\n    }\n    long usedMemoryAfter = (runtime.totalMemory() - runtime.freeMemory()) / mb;\n    Assert.assertTrue((usedMemoryAfter - usedMemoryBefore) < 200);\n  }","id":74327,"modified_method":"@Test\n  public void testMassiveWriteContainerHistory() throws IOException {\n    long mb = 1024 * 1024;\n    Runtime runtime = Runtime.getRuntime();\n    long usedMemoryBefore = (runtime.totalMemory() - runtime.freeMemory()) / mb;\n    int numContainers = 100000;\n    ApplicationId appId = ApplicationId.newInstance(0, 1);\n    ApplicationAttemptId appAttemptId =\n        ApplicationAttemptId.newInstance(appId, 1);\n    for (int i = 1; i <= numContainers; ++i) {\n      ContainerId containerId = ContainerId.newInstance(appAttemptId, i);\n      writeContainerStartData(containerId);\n      writeContainerFinishData(containerId);\n    }\n    long usedMemoryAfter = (runtime.totalMemory() - runtime.freeMemory()) / mb;\n    Assert.assertTrue((usedMemoryAfter - usedMemoryBefore) < 400);\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testPostEntities() throws Exception {\n    TimelineEntities entities = new TimelineEntities();\n    TimelineEntity entity = new TimelineEntity();\n    entity.setEntityId(\"test id 1\");\n    entity.setEntityType(\"test type 1\");\n    entity.setStartTime(System.currentTimeMillis());\n    entities.addEntity(entity);\n    WebResource r = resource();\n    ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .accept(MediaType.APPLICATION_JSON)\n        .type(MediaType.APPLICATION_JSON)\n        .post(ClientResponse.class, entities);\n    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n    TimelinePutResponse putResposne = response.getEntity(TimelinePutResponse.class);\n    Assert.assertNotNull(putResposne);\n    Assert.assertEquals(0, putResposne.getErrors().size());\n    // verify the entity exists in the store\n    response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .path(\"test type 1\").path(\"test id 1\")\n        .accept(MediaType.APPLICATION_JSON)\n        .get(ClientResponse.class);\n    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n    entity = response.getEntity(TimelineEntity.class);\n    Assert.assertNotNull(entity);\n    Assert.assertEquals(\"test id 1\", entity.getEntityId());\n    Assert.assertEquals(\"test type 1\", entity.getEntityType());\n  }","id":74328,"modified_method":"@Test\n  public void testPostEntities() throws Exception {\n    TimelineEntities entities = new TimelineEntities();\n    TimelineEntity entity = new TimelineEntity();\n    entity.setEntityId(\"test id 1\");\n    entity.setEntityType(\"test type 1\");\n    entity.setStartTime(System.currentTimeMillis());\n    entities.addEntity(entity);\n    WebResource r = resource();\n    // No owner, will be rejected\n    ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .accept(MediaType.APPLICATION_JSON)\n        .type(MediaType.APPLICATION_JSON)\n        .post(ClientResponse.class, entities);\n    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n    assertEquals(ClientResponse.Status.FORBIDDEN,\n        response.getClientResponseStatus());\n\n    response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .queryParam(\"user.name\", \"tester\")\n        .accept(MediaType.APPLICATION_JSON)\n        .type(MediaType.APPLICATION_JSON)\n        .post(ClientResponse.class, entities);\n    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n    TimelinePutResponse putResposne = response.getEntity(TimelinePutResponse.class);\n    Assert.assertNotNull(putResposne);\n    Assert.assertEquals(0, putResposne.getErrors().size());\n    // verify the entity exists in the store\n    response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .path(\"test type 1\").path(\"test id 1\")\n        .accept(MediaType.APPLICATION_JSON)\n        .get(ClientResponse.class);\n    assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n    entity = response.getEntity(TimelineEntity.class);\n    Assert.assertNotNull(entity);\n    Assert.assertEquals(\"test id 1\", entity.getEntityId());\n    Assert.assertEquals(\"test type 1\", entity.getEntityType());\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testPostEntitiesWithYarnACLsEnabled() throws Exception {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    remoteUser = \"tester\";\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 2\");\n      entity.setEntityType(\"test type 2\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      TimelinePutResponse putResponse = response.getEntity(TimelinePutResponse.class);\n      Assert.assertNotNull(putResponse);\n      Assert.assertEquals(0, putResponse.getErrors().size());\n\n      // override/append timeline data in the same entity with different user\n      remoteUser = \"other\";\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      putResponse = response.getEntity(TimelinePutResponse.class);\n      Assert.assertNotNull(putResponse);\n      Assert.assertEquals(1, putResponse.getErrors().size());\n      Assert.assertEquals(TimelinePutResponse.TimelinePutError.ACCESS_DENIED,\n          putResponse.getErrors().get(0).getErrorCode());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n      remoteUser = null;\n    }\n  }","id":74329,"modified_method":"@Test\n  public void testPostEntitiesWithYarnACLsEnabled() throws Exception {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 2\");\n      entity.setEntityType(\"test type 2\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"tester\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      TimelinePutResponse putResponse = response.getEntity(TimelinePutResponse.class);\n      Assert.assertNotNull(putResponse);\n      Assert.assertEquals(0, putResponse.getErrors().size());\n\n      // override/append timeline data in the same entity with different user\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"other\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      putResponse = response.getEntity(TimelinePutResponse.class);\n      Assert.assertNotNull(putResponse);\n      Assert.assertEquals(1, putResponse.getErrors().size());\n      Assert.assertEquals(TimelinePutResponse.TimelinePutError.ACCESS_DENIED,\n          putResponse.getErrors().get(0).getErrorCode());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n    }\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testGetEventsWithYarnACLsEnabled() {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    remoteUser = \"tester\";\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 5\");\n      entity.setEntityType(\"test type 5\");\n      entity.setStartTime(System.currentTimeMillis());\n      TimelineEvent event = new TimelineEvent();\n      event.setEventType(\"event type 1\");\n      event.setTimestamp(System.currentTimeMillis());\n      entity.addEvent(event);\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      remoteUser = \"other\";\n      entities = new TimelineEntities();\n      entity = new TimelineEntity();\n      entity.setEntityId(\"test id 6\");\n      entity.setEntityType(\"test type 5\");\n      entity.setStartTime(System.currentTimeMillis());\n      event = new TimelineEvent();\n      event.setEventType(\"event type 2\");\n      event.setTimestamp(System.currentTimeMillis());\n      entity.addEvent(event);\n      entities.addEntity(entity);\n      r = resource();\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 5\").path(\"events\")\n          .queryParam(\"entityId\", \"test id 5,test id 6\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      TimelineEvents events = response.getEntity(TimelineEvents.class);\n      assertEquals(1, events.getAllEvents().size());\n      assertEquals(\"test id 6\", events.getAllEvents().get(0).getEntityId());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n      remoteUser = null;\n    }\n  }","id":74330,"modified_method":"@Test\n  public void testGetEventsWithYarnACLsEnabled() {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 5\");\n      entity.setEntityType(\"test type 5\");\n      entity.setStartTime(System.currentTimeMillis());\n      TimelineEvent event = new TimelineEvent();\n      event.setEventType(\"event type 1\");\n      event.setTimestamp(System.currentTimeMillis());\n      entity.addEvent(event);\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"tester\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      entities = new TimelineEntities();\n      entity = new TimelineEntity();\n      entity.setEntityId(\"test id 6\");\n      entity.setEntityType(\"test type 5\");\n      entity.setStartTime(System.currentTimeMillis());\n      event = new TimelineEvent();\n      event.setEventType(\"event type 2\");\n      event.setTimestamp(System.currentTimeMillis());\n      entity.addEvent(event);\n      entities.addEntity(entity);\n      r = resource();\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"other\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 5\").path(\"events\")\n          .queryParam(\"user.name\", \"other\")\n          .queryParam(\"entityId\", \"test id 5,test id 6\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      TimelineEvents events = response.getEntity(TimelineEvents.class);\n      assertEquals(1, events.getAllEvents().size());\n      assertEquals(\"test id 6\", events.getAllEvents().get(0).getEntityId());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n    }\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testPostEntitiesWithPrimaryFilter() throws Exception {\n    TimelineEntities entities = new TimelineEntities();\n    TimelineEntity entity = new TimelineEntity();\n    Map<String, Set<Object>> filters = new HashMap<String, Set<Object>>();\n    filters.put(TimelineStore.SystemFilter.ENTITY_OWNER.toString(), new HashSet<Object>());\n    entity.setPrimaryFilters(filters);\n    entity.setEntityId(\"test id 6\");\n    entity.setEntityType(\"test type 6\");\n    entity.setStartTime(System.currentTimeMillis());\n    entities.addEntity(entity);\n    WebResource r = resource();\n    ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .accept(MediaType.APPLICATION_JSON)\n        .type(MediaType.APPLICATION_JSON)\n        .post(ClientResponse.class, entities);\n    TimelinePutResponse putResposne = response.getEntity(TimelinePutResponse.class);\n    Assert.assertEquals(1, putResposne.getErrors().size());\n    List<TimelinePutError> errors = putResposne.getErrors();\n    Assert.assertEquals(TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT,\n      errors.get(0).getErrorCode());\n  }","id":74331,"modified_method":"@Test\n  public void testPostEntitiesWithPrimaryFilter() throws Exception {\n    TimelineEntities entities = new TimelineEntities();\n    TimelineEntity entity = new TimelineEntity();\n    Map<String, Set<Object>> filters = new HashMap<String, Set<Object>>();\n    filters.put(TimelineStore.SystemFilter.ENTITY_OWNER.toString(), new HashSet<Object>());\n    entity.setPrimaryFilters(filters);\n    entity.setEntityId(\"test id 6\");\n    entity.setEntityType(\"test type 6\");\n    entity.setStartTime(System.currentTimeMillis());\n    entities.addEntity(entity);\n    WebResource r = resource();\n    ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n        .queryParam(\"user.name\", \"tester\")\n        .accept(MediaType.APPLICATION_JSON)\n        .type(MediaType.APPLICATION_JSON)\n        .post(ClientResponse.class, entities);\n    TimelinePutResponse putResposne = response.getEntity(TimelinePutResponse.class);\n    Assert.assertEquals(1, putResposne.getErrors().size());\n    List<TimelinePutError> errors = putResposne.getErrors();\n    Assert.assertEquals(TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT,\n      errors.get(0).getErrorCode());\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testGetEntitiesWithYarnACLsEnabled() {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    remoteUser = \"tester\";\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 4\");\n      entity.setEntityType(\"test type 4\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      remoteUser = \"other\";\n      entities = new TimelineEntities();\n      entity = new TimelineEntity();\n      entity.setEntityId(\"test id 5\");\n      entity.setEntityType(\"test type 4\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      r = resource();\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 4\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entities = response.getEntity(TimelineEntities.class);\n      assertEquals(1, entities.getEntities().size());\n      assertEquals(\"test type 4\", entities.getEntities().get(0).getEntityType());\n      assertEquals(\"test id 5\", entities.getEntities().get(0).getEntityId());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n      remoteUser = null;\n    }\n  }","id":74332,"modified_method":"@Test\n  public void testGetEntitiesWithYarnACLsEnabled() {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 4\");\n      entity.setEntityType(\"test type 4\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"tester\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      entities = new TimelineEntities();\n      entity = new TimelineEntity();\n      entity.setEntityId(\"test id 5\");\n      entity.setEntityType(\"test type 4\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      r = resource();\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"other\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"other\")\n          .path(\"test type 4\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entities = response.getEntity(TimelineEntities.class);\n      assertEquals(1, entities.getEntities().size());\n      assertEquals(\"test type 4\", entities.getEntities().get(0).getEntityType());\n      assertEquals(\"test id 5\", entities.getEntities().get(0).getEntityId());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n    }\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Test\n  public void testGetEntityWithYarnACLsEnabled() throws Exception {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    remoteUser = \"tester\";\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 3\");\n      entity.setEntityType(\"test type 3\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n      // verify the system data will not be exposed\n      // 1. No field specification\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entity = response.getEntity(TimelineEntity.class);\n      Assert.assertNull(entity.getPrimaryFilters().get(\n          TimelineStore.SystemFilter.ENTITY_OWNER.toString()));\n      // 2. other field\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .queryParam(\"fields\", \"relatedentities\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entity = response.getEntity(TimelineEntity.class);\n      Assert.assertNull(entity.getPrimaryFilters().get(\n          TimelineStore.SystemFilter.ENTITY_OWNER.toString()));\n      // 3. primaryfilters field\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .queryParam(\"fields\", \"primaryfilters\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entity = response.getEntity(TimelineEntity.class);\n      Assert.assertNull(entity.getPrimaryFilters().get(\n          TimelineStore.SystemFilter.ENTITY_OWNER.toString()));\n\n      // get entity with other user\n      remoteUser = \"other\";\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      assertEquals(ClientResponse.Status.NOT_FOUND,\n          response.getClientResponseStatus());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n      remoteUser = null;\n    }\n  }","id":74333,"modified_method":"@Test\n  public void testGetEntityWithYarnACLsEnabled() throws Exception {\n    AdminACLsManager oldAdminACLsManager =\n        timelineACLsManager.setAdminACLsManager(adminACLsManager);\n    try {\n      TimelineEntities entities = new TimelineEntities();\n      TimelineEntity entity = new TimelineEntity();\n      entity.setEntityId(\"test id 3\");\n      entity.setEntityType(\"test type 3\");\n      entity.setStartTime(System.currentTimeMillis());\n      entities.addEntity(entity);\n      WebResource r = resource();\n      ClientResponse response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .queryParam(\"user.name\", \"tester\")\n          .accept(MediaType.APPLICATION_JSON)\n          .type(MediaType.APPLICATION_JSON)\n          .post(ClientResponse.class, entities);\n      // verify the system data will not be exposed\n      // 1. No field specification\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .queryParam(\"user.name\", \"tester\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entity = response.getEntity(TimelineEntity.class);\n      Assert.assertNull(entity.getPrimaryFilters().get(\n          TimelineStore.SystemFilter.ENTITY_OWNER.toString()));\n      // 2. other field\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .queryParam(\"fields\", \"relatedentities\")\n          .queryParam(\"user.name\", \"tester\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entity = response.getEntity(TimelineEntity.class);\n      Assert.assertNull(entity.getPrimaryFilters().get(\n          TimelineStore.SystemFilter.ENTITY_OWNER.toString()));\n      // 3. primaryfilters field\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .queryParam(\"fields\", \"primaryfilters\")\n          .queryParam(\"user.name\", \"tester\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      entity = response.getEntity(TimelineEntity.class);\n      Assert.assertNull(entity.getPrimaryFilters().get(\n          TimelineStore.SystemFilter.ENTITY_OWNER.toString()));\n\n      // get entity with other user\n      response = r.path(\"ws\").path(\"v1\").path(\"timeline\")\n          .path(\"test type 3\").path(\"test id 3\")\n          .queryParam(\"user.name\", \"other\")\n          .accept(MediaType.APPLICATION_JSON)\n          .get(ClientResponse.class);\n      assertEquals(MediaType.APPLICATION_JSON_TYPE, response.getType());\n      assertEquals(ClientResponse.Status.NOT_FOUND,\n          response.getClientResponseStatus());\n    } finally {\n      timelineACLsManager.setAdminACLsManager(oldAdminACLsManager);\n    }\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"public boolean checkAccess(UserGroupInformation callerUGI,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \" + callerUGI.getShortUserName()\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    Set<Object> values =\n        entity.getPrimaryFilters().get(\n            SystemFilter.ENTITY_OWNER.toString());\n    if (values == null || values.size() != 1) {\n      throw new YarnException(\"Owner information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" is corrupted.\");\n    }\n    String owner = values.iterator().next().toString();\n    // TODO: Currently we just check the user is the admin or the timeline\n    // entity owner. In the future, we need to check whether the user is in the\n    // allowed user/group list\n    if (callerUGI != null\n        && (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner))) {\n      return true;\n    }\n    return false;\n  }","id":74334,"modified_method":"public boolean checkAccess(UserGroupInformation callerUGI,\n      TimelineEntity entity) throws YarnException, IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Verifying the access of \"\n          + (callerUGI == null ? null : callerUGI.getShortUserName())\n          + \" on the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));\n    }\n\n    if (!adminAclsManager.areACLsEnabled()) {\n      return true;\n    }\n\n    Set<Object> values =\n        entity.getPrimaryFilters().get(\n            SystemFilter.ENTITY_OWNER.toString());\n    if (values == null || values.size() != 1) {\n      throw new YarnException(\"Owner information of the timeline entity \"\n          + new EntityIdentifier(entity.getEntityId(), entity.getEntityType())\n          + \" is corrupted.\");\n    }\n    String owner = values.iterator().next().toString();\n    // TODO: Currently we just check the user is the admin or the timeline\n    // entity owner. In the future, we need to check whether the user is in the\n    // allowed user/group list\n    if (callerUGI != null\n        && (adminAclsManager.isAdmin(callerUGI) ||\n            callerUGI.getShortUserName().equals(owner))) {\n      return true;\n    }\n    return false;\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"@Override\n  protected Properties getConfiguration(String configPrefix,\n      FilterConfig filterConfig) throws ServletException {\n    // In yarn-site.xml, we can simply set type to \"kerberos\". However, we need\n    // to replace the name here to use the customized Kerberos + DT service\n    // instead of the standard Kerberos handler.\n    Properties properties = super.getConfiguration(configPrefix, filterConfig);\n    if (properties.getProperty(AUTH_TYPE).equals(\"kerberos\")) {\n      properties.setProperty(\n          AUTH_TYPE, TimelineClientAuthenticationService.class.getName());\n    }\n    return properties;\n  }","id":74335,"modified_method":"@Override\n  protected Properties getConfiguration(String configPrefix,\n      FilterConfig filterConfig) throws ServletException {\n    // In yarn-site.xml, we can simply set type to \"kerberos\". However, we need\n    // to replace the name here to use the customized Kerberos + DT service\n    // instead of the standard Kerberos handler.\n    Properties properties = super.getConfiguration(configPrefix, filterConfig);\n    String authType = properties.getProperty(AUTH_TYPE);\n    if (authType != null && authType.equals(\"kerberos\")) {\n      properties.setProperty(\n          AUTH_TYPE, TimelineClientAuthenticationService.class.getName());\n    }\n    return properties;\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"public TimelineClientImpl() {\n    super(TimelineClientImpl.class.getName());\n    ClientConfig cc = new DefaultClientConfig();\n    cc.getClasses().add(YarnJacksonJaxbJsonProvider.class);\n    if (UserGroupInformation.isSecurityEnabled()) {\n      urlFactory = new TimelineAuthenticatedURLConnectionFactory();\n      client = new Client(new URLConnectionClientHandler(urlFactory), cc);\n    } else {\n      client = Client.create(cc);\n    }\n  }","id":74336,"modified_method":"public TimelineClientImpl() {\n    super(TimelineClientImpl.class.getName());\n    ClientConfig cc = new DefaultClientConfig();\n    cc.getClasses().add(YarnJacksonJaxbJsonProvider.class);\n    if (UserGroupInformation.isSecurityEnabled()) {\n      urlFactory = new KerberosAuthenticatedURLConnectionFactory();\n      client = new Client(new URLConnectionClientHandler(urlFactory), cc);\n    } else {\n      client = new Client(new URLConnectionClientHandler(\n          new PseudoAuthenticatedURLConnectionFactory()), cc);\n    }\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Store the given entities into the timeline store, and return the errors\n   * that happen during storing.\n   */\n  @POST\n  @Consumes({ MediaType.APPLICATION_JSON /* , MediaType.APPLICATION_XML */})\n  public TimelinePutResponse postEntities(\n      @Context HttpServletRequest req,\n      @Context HttpServletResponse res,\n      TimelineEntities entities) {\n    init(res);\n    if (entities == null) {\n      return new TimelinePutResponse();\n    }\n    UserGroupInformation callerUGI = getUser(req);\n    try {\n      List<EntityIdentifier> entityIDs = new ArrayList<EntityIdentifier>();\n      TimelineEntities entitiesToPut = new TimelineEntities();\n      List<TimelinePutResponse.TimelinePutError> errors =\n          new ArrayList<TimelinePutResponse.TimelinePutError>();\n      for (TimelineEntity entity : entities.getEntities()) {\n        EntityIdentifier entityID =\n            new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n\n        // check if there is existing entity\n        TimelineEntity existingEntity = null;\n        try {\n          existingEntity =\n              store.getEntity(entityID.getId(), entityID.getType(),\n                  EnumSet.of(Field.PRIMARY_FILTERS));\n          if (existingEntity != null\n              && !timelineACLsManager.checkAccess(callerUGI, existingEntity)) {\n            throw new YarnException(\"The timeline entity \" + entityID\n                + \" was not put by \" + callerUGI + \" before\");\n          }\n        } catch (Exception e) {\n          // Skip the entity which already exists and was put by others\n          LOG.warn(\"Skip the timeline entity: \" + entityID + \", because \"\n              + e.getMessage());\n          TimelinePutResponse.TimelinePutError error =\n              new TimelinePutResponse.TimelinePutError();\n          error.setEntityId(entityID.getId());\n          error.setEntityType(entityID.getType());\n          error.setErrorCode(\n              TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n          errors.add(error);\n          continue;\n        }\n\n        // inject owner information for the access check if this is the first\n        // time to post the entity, in case it's the admin who is updating\n        // the timeline data.\n        try {\n          if (existingEntity == null) {\n            injectOwnerInfo(entity,\n                callerUGI == null ? \"\" : callerUGI.getShortUserName());\n          }\n        } catch (YarnException e) {\n          // Skip the entity which messes up the primary filter and record the\n          // error\n          LOG.warn(\"Skip the timeline entity: \" + entityID + \", because \"\n              + e.getMessage());\n          TimelinePutResponse.TimelinePutError error =\n              new TimelinePutResponse.TimelinePutError();\n          error.setEntityId(entityID.getId());\n          error.setEntityType(entityID.getType());\n          error.setErrorCode(\n              TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT);\n          errors.add(error);\n          continue;\n        }\n\n        entityIDs.add(entityID);\n        entitiesToPut.addEntity(entity);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n              + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n      }\n      TimelinePutResponse response =  store.put(entitiesToPut);\n      // add the errors of timeline system filter key conflict\n      response.addErrors(errors);\n      return response;\n    } catch (IOException e) {\n      LOG.error(\"Error putting entities\", e);\n      throw new WebApplicationException(e,\n          Response.Status.INTERNAL_SERVER_ERROR);\n    }\n  }","id":74337,"modified_method":"/**\n   * Store the given entities into the timeline store, and return the errors\n   * that happen during storing.\n   */\n  @POST\n  @Consumes({ MediaType.APPLICATION_JSON /* , MediaType.APPLICATION_XML */})\n  public TimelinePutResponse postEntities(\n      @Context HttpServletRequest req,\n      @Context HttpServletResponse res,\n      TimelineEntities entities) {\n    init(res);\n    if (entities == null) {\n      return new TimelinePutResponse();\n    }\n    UserGroupInformation callerUGI = getUser(req);\n    if (callerUGI == null) {\n      String msg = \"The owner of the posted timeline entities is not set\";\n      LOG.error(msg);\n      throw new ForbiddenException(msg);\n    }\n    try {\n      List<EntityIdentifier> entityIDs = new ArrayList<EntityIdentifier>();\n      TimelineEntities entitiesToPut = new TimelineEntities();\n      List<TimelinePutResponse.TimelinePutError> errors =\n          new ArrayList<TimelinePutResponse.TimelinePutError>();\n      for (TimelineEntity entity : entities.getEntities()) {\n        EntityIdentifier entityID =\n            new EntityIdentifier(entity.getEntityId(), entity.getEntityType());\n\n        // check if there is existing entity\n        TimelineEntity existingEntity = null;\n        try {\n          existingEntity =\n              store.getEntity(entityID.getId(), entityID.getType(),\n                  EnumSet.of(Field.PRIMARY_FILTERS));\n          if (existingEntity != null\n              && !timelineACLsManager.checkAccess(callerUGI, existingEntity)) {\n            throw new YarnException(\"The timeline entity \" + entityID\n                + \" was not put by \" + callerUGI + \" before\");\n          }\n        } catch (Exception e) {\n          // Skip the entity which already exists and was put by others\n          LOG.warn(\"Skip the timeline entity: \" + entityID + \", because \"\n              + e.getMessage());\n          TimelinePutResponse.TimelinePutError error =\n              new TimelinePutResponse.TimelinePutError();\n          error.setEntityId(entityID.getId());\n          error.setEntityType(entityID.getType());\n          error.setErrorCode(\n              TimelinePutResponse.TimelinePutError.ACCESS_DENIED);\n          errors.add(error);\n          continue;\n        }\n\n        // inject owner information for the access check if this is the first\n        // time to post the entity, in case it's the admin who is updating\n        // the timeline data.\n        try {\n          if (existingEntity == null) {\n            injectOwnerInfo(entity, callerUGI.getShortUserName());\n          }\n        } catch (YarnException e) {\n          // Skip the entity which messes up the primary filter and record the\n          // error\n          LOG.warn(\"Skip the timeline entity: \" + entityID + \", because \"\n              + e.getMessage());\n          TimelinePutResponse.TimelinePutError error =\n              new TimelinePutResponse.TimelinePutError();\n          error.setEntityId(entityID.getId());\n          error.setEntityType(entityID.getType());\n          error.setErrorCode(\n              TimelinePutResponse.TimelinePutError.SYSTEM_FILTER_CONFLICT);\n          errors.add(error);\n          continue;\n        }\n\n        entityIDs.add(entityID);\n        entitiesToPut.addEntity(entity);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Storing the entity \" + entityID + \", JSON-style content: \"\n              + TimelineUtils.dumpTimelineRecordtoJSON(entity));\n        }\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Storing entities: \" + CSV_JOINER.join(entityIDs));\n      }\n      TimelinePutResponse response =  store.put(entitiesToPut);\n      // add the errors of timeline system filter key conflict\n      response.addErrors(errors);\n      return response;\n    } catch (IOException e) {\n      LOG.error(\"Error putting entities\", e);\n      throw new WebApplicationException(e,\n          Response.Status.INTERNAL_SERVER_ERROR);\n    }\n  }","commit_id":"a6cd712ca7a3cae3fa8f63ab4e48116d8c94a705","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n     * Create a {@code PropertyState} from a {@link javax.jcr.Value}.\n     * @param name  The name of the property state\n     * @param value  The value of the property state\n     * @return  The new property state of type {@link Type#BINARY}\n     */\n    public static PropertyState binaryProperty(\n            @Nonnull String name, @Nonnull Value value) {\n        return new BinaryPropertyState(\n                name, new ValueBasedBlob(checkNotNull(value)));\n    }","id":74338,"modified_method":"/**\n     * Create a {@code PropertyState} from a {@link javax.jcr.Value}.\n     * @param name  The name of the property state\n     * @param value  The value of the property state\n     * @return  The new property state of type {@link Type#BINARY}\n     */\n    public static PropertyState binaryProperty(\n            @Nonnull String name, @Nonnull Value value) {\n        return new BinaryPropertyState(name, ValueImpl.getBlob(value));\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"private Reader openReader() throws IOException {\n        return new InputStreamReader(\n                new BufferedInputStream(new FileInputStream(tmpFile)), \"UTF-8\");\n    }","id":74339,"modified_method":"private Reader openReader() throws IOException {\n        return new InputStreamReader(openStream(), \"UTF-8\");\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Constructs a new empty {@code BufferedStringValue}.\n     *\n     * @param valueFactory The value factory\n     * @param namePathMapper the name/path mapper\n     */\n    protected BufferedStringValue(ValueFactory valueFactory, NamePathMapper namePathMapper) {\n        buffer = new StringWriter();\n        length = 0;\n        tmpFile = null;\n        writer = null;\n        this.namePathMapper = namePathMapper;\n        this.valueFactory = valueFactory;\n    }","id":74340,"modified_method":"/**\n     * Constructs a new empty {@code BufferedStringValue}.\n     *\n     * @param valueFactory The value factory\n     * @param namePathMapper the name/path mapper\n     */\n    protected BufferedStringValue(\n            ValueFactory valueFactory, NamePathMapper namePathMapper,\n            boolean base64) {\n        buffer = new StringWriter();\n        length = 0;\n        tmpFile = null;\n        writer = null;\n        this.namePathMapper = namePathMapper;\n        this.valueFactory = valueFactory;\n        this.base64 = base64;\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Value getValue(int targetType) throws RepositoryException {\n        try {\n            if (targetType == PropertyType.NAME) {\n                return ValueHelper.deserialize(\n                        namePathMapper.getOakName(retrieveString()), targetType, false, valueFactory);\n            } else if (targetType == PropertyType.PATH) {\n                return ValueHelper.deserialize(\n                        namePathMapper.getOakPath(retrieveString()), targetType, false, valueFactory);\n            } else if (targetType == PropertyType.BINARY) {\n                if (length() < 0x10000) {\n                    // < 65kb: deserialize BINARY type using String\n                    return ValueHelper.deserialize(retrieve(), targetType, false, valueFactory);\n                } else {\n                    // >= 65kb: deserialize BINARY type using Reader\n                    Reader reader = reader();\n                    try {\n                        return ValueHelper.deserialize(reader, targetType, false, valueFactory);\n                    } finally {\n                        reader.close();\n                    }\n                }\n            } else {\n                // all other types\n                return ValueHelper.deserialize(retrieveString(), targetType, false, valueFactory);\n            }\n        } catch (IOException e) {\n            String msg = \"failed to retrieve serialized value\";\n            log.debug(msg, e);\n            throw new RepositoryException(msg, e);\n        }\n    }","id":74341,"modified_method":"@Override @SuppressWarnings(\"deprecation\")\n    public Value getValue(int targetType) throws RepositoryException {\n        try {\n            if (targetType == PropertyType.BINARY) {\n                return valueFactory.createValue(stream());\n            }\n\n            String jcrValue = retrieveString();\n            if (targetType == PropertyType.NAME) {\n                jcrValue = namePathMapper.getOakName(jcrValue);\n            } else if (targetType == PropertyType.PATH) {\n                jcrValue = namePathMapper.getOakPath(jcrValue);\n            }\n            return valueFactory.createValue(jcrValue, targetType);\n        } catch (IOException e) {\n            throw new RepositoryException(\n                    \"failed to retrieve serialized value\", e);\n        }\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Appends the given character data to the internal buffer.\n     *\n     * @param ch     the characters to be appended\n     * @param start  the index of the first character to append\n     * @param length the number of characters to append\n     * @throws SAXException if an error occurs\n     * @see #characters(char[], int, int)\n     * @see #ignorableWhitespace(char[], int, int)\n     * @see #processCharacters()\n     */\n    private void appendCharacters(char[] ch, int start, int length)\n            throws SAXException {\n        if (textHandler == null) {\n            textHandler = new BufferedStringValue(sessionContext.getValueFactory(), currentNamePathMapper());\n        }\n        try {\n            textHandler.append(ch, start, length);\n        } catch (IOException ioe) {\n            String msg = \"internal error while processing internal buffer data\";\n            log.error(msg, ioe);\n            throw new SAXException(msg, ioe);\n        }\n    }","id":74342,"modified_method":"/**\n     * Appends the given character data to the internal buffer.\n     *\n     * @param ch     the characters to be appended\n     * @param start  the index of the first character to append\n     * @param length the number of characters to append\n     * @throws SAXException if an error occurs\n     * @see #characters(char[], int, int)\n     * @see #ignorableWhitespace(char[], int, int)\n     * @see #processCharacters()\n     */\n    private void appendCharacters(char[] ch, int start, int length)\n            throws SAXException {\n        if (textHandler == null) {\n            textHandler = new BufferedStringValue(\n                    sessionContext.getValueFactory(), currentNamePathMapper(),\n                    false);\n        }\n        try {\n            textHandler.append(ch, start, length);\n        } catch (IOException ioe) {\n            String msg = \"internal error while processing internal buffer data\";\n            log.error(msg, ioe);\n            throw new SAXException(msg, ioe);\n        }\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public static PropertyState createProperty(\n            String name, Iterable<Value> values, int type)\n            throws RepositoryException {\n        switch (type) {\n            case PropertyType.STRING:\n                List<String> strings = Lists.newArrayList();\n                for (Value value : values) {\n                    strings.add(getString(value, type));\n                }\n                return MultiStringPropertyState.stringProperty(name, strings);\n            case PropertyType.BINARY:\n                List<Blob> blobs = Lists.newArrayList();\n                for (Value value : values) {\n                    blobs.add(new ValueBasedBlob(value));\n                }\n                return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);\n            case PropertyType.LONG:\n                List<Long> longs = Lists.newArrayList();\n                for (Value value : values) {\n                    longs.add(value.getLong());\n                }\n                return MultiLongPropertyState.createLongProperty(name, longs);\n            case PropertyType.DOUBLE:\n                List<Double> doubles = Lists.newArrayList();\n                for (Value value : values) {\n                    doubles.add(value.getDouble());\n                }\n                return MultiDoublePropertyState.doubleProperty(name, doubles);\n            case PropertyType.BOOLEAN:\n                List<Boolean> booleans = Lists.newArrayList();\n                for (Value value : values) {\n                    booleans.add(value.getBoolean());\n                }\n                return MultiBooleanPropertyState.booleanProperty(name, booleans);\n            case PropertyType.DECIMAL:\n                List<BigDecimal> decimals = Lists.newArrayList();\n                for (Value value : values) {\n                    decimals.add(value.getDecimal());\n                }\n                return MultiDecimalPropertyState.decimalProperty(name, decimals);\n            default:\n                List<String> vals = Lists.newArrayList();\n                for (Value value : values) {\n                    vals.add(getString(value, type));\n                }\n                return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\n        }\n    }","id":74343,"modified_method":"public static PropertyState createProperty(\n            String name, Iterable<Value> values, int type)\n            throws RepositoryException {\n        switch (type) {\n            case PropertyType.STRING:\n                List<String> strings = Lists.newArrayList();\n                for (Value value : values) {\n                    strings.add(getString(value, type));\n                }\n                return MultiStringPropertyState.stringProperty(name, strings);\n            case PropertyType.BINARY:\n                List<Blob> blobs = Lists.newArrayList();\n                for (Value value : values) {\n                    blobs.add(ValueImpl.getBlob(value));\n                }\n                return MultiBinaryPropertyState.binaryPropertyFromBlob(name, blobs);\n            case PropertyType.LONG:\n                List<Long> longs = Lists.newArrayList();\n                for (Value value : values) {\n                    longs.add(value.getLong());\n                }\n                return MultiLongPropertyState.createLongProperty(name, longs);\n            case PropertyType.DOUBLE:\n                List<Double> doubles = Lists.newArrayList();\n                for (Value value : values) {\n                    doubles.add(value.getDouble());\n                }\n                return MultiDoublePropertyState.doubleProperty(name, doubles);\n            case PropertyType.BOOLEAN:\n                List<Boolean> booleans = Lists.newArrayList();\n                for (Value value : values) {\n                    booleans.add(value.getBoolean());\n                }\n                return MultiBooleanPropertyState.booleanProperty(name, booleans);\n            case PropertyType.DECIMAL:\n                List<BigDecimal> decimals = Lists.newArrayList();\n                for (Value value : values) {\n                    decimals.add(value.getDecimal());\n                }\n                return MultiDecimalPropertyState.decimalProperty(name, decimals);\n            default:\n                List<String> vals = Lists.newArrayList();\n                for (Value value : values) {\n                    vals.add(getString(value, type));\n                }\n                return new MultiGenericPropertyState(name, vals, Type.fromTag(type, true));\n        }\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Value getValue(int type) throws RepositoryException {\n        String inputValue = type == PropertyType.NAME ?\n                namePathMapper.getOakName(value) :\n                type == PropertyType.PATH ?\n                        namePathMapper.getOakPath(value) :\n                        value;\n        return ValueHelper.deserialize(inputValue, type, false, valueFactory);\n    }","id":74344,"modified_method":"@Override @SuppressWarnings(\"deprecation\")\n    public Value getValue(int type) throws RepositoryException {\n        if (type == PropertyType.BINARY) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            try {\n                Base64.decode(value, baos);\n                return valueFactory.createValue(\n                        new ByteArrayInputStream(baos.toByteArray()));\n            } catch (IOException e) {\n                throw new RepositoryException(\n                        \"Failed to decode binary value: \" + value, e);\n            }\n        }\n\n        // The ValueFactory instance takes care of name and path mapping\n        // from JCR to Oak values, but here we need an additional level of\n        // mapping for XML to JCR values.\n        String jcrValue;\n        if (type == PropertyType.NAME) {\n            jcrValue = namePathMapper.getOakName(value);\n        } else if (type == PropertyType.PATH) {\n            jcrValue = namePathMapper.getOakPath(value);\n        } else {\n            jcrValue = value;\n        }\n        return valueFactory.createValue(jcrValue, type);\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public void startElement(String namespaceURI, String localName,\n                             String qName, Attributes atts)\n            throws SAXException {\n        // check element name\n        if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"node\".equals(localName)) {\n            // sv:node element\n\n            // node name (value of sv:name attribute)\n            String svName = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"name\");\n            if (svName == null) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"missing mandatory sv:name attribute of element sv:node\"));\n            }\n\n            if (!stack.isEmpty()) {\n                // process current node first\n                ImportState current = stack.peek();\n                // need to start current node\n                if (!current.started) {\n                    processNode(current, true, false);\n                    current.started = true;\n                }\n            }\n\n            // push new ImportState instance onto the stack\n            ImportState state = new ImportState();\n            try {\n                state.nodeName = new NameInfo(svName).getRepoQualifiedName();\n            } catch (RepositoryException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal node name: \" + svName, e));\n            }\n            stack.push(state);\n        } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"property\".equals(localName)) {\n            // sv:property element\n\n            // reset temp fields\n            currentPropValues.clear();\n\n            // property name (value of sv:name attribute)\n            String svName = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"name\");\n            if (svName == null) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"missing mandatory sv:name attribute of element sv:property\"));\n            }\n            try {\n                currentPropName = new NameInfo(svName);\n            } catch (RepositoryException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal property name: \" + svName, e));\n            }\n            // property type (sv:type attribute)\n            String type = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"type\");\n            if (type == null) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"missing mandatory sv:type attribute of element sv:property\"));\n            }\n            try {\n                currentPropType = PropertyType.valueFromName(type);\n            } catch (IllegalArgumentException e) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"Unknown property type: \" + type, e));\n            }\n            // 'multi-value' hint (sv:multiple attribute)\n            String multiple = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"multiple\");\n            if (multiple != null) {\n                currentPropMultipleStatus = PropInfo.MultipleStatus.MULTIPLE;\n            } else {\n                currentPropMultipleStatus = PropInfo.MultipleStatus.UNKNOWN;\n            }\n        } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"value\".equals(localName)) {\n            // sv:value element\n            currentPropValue = new BufferedStringValue(sessionContext.getValueFactory(), currentNamePathMapper());\n            String xsiType = atts.getValue(\"xsi:type\");\n            currentPropValue.setBase64(\"xs:base64Binary\".equals(xsiType));\n        } else {\n            throw new SAXException(new InvalidSerializedDataException(\n                    \"Unexpected element in system view xml document: {\" + namespaceURI + '}' + localName));\n        }\n    }","id":74345,"modified_method":"@Override\n    public void startElement(String namespaceURI, String localName,\n                             String qName, Attributes atts)\n            throws SAXException {\n        // check element name\n        if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"node\".equals(localName)) {\n            // sv:node element\n\n            // node name (value of sv:name attribute)\n            String svName = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"name\");\n            if (svName == null) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"missing mandatory sv:name attribute of element sv:node\"));\n            }\n\n            if (!stack.isEmpty()) {\n                // process current node first\n                ImportState current = stack.peek();\n                // need to start current node\n                if (!current.started) {\n                    processNode(current, true, false);\n                    current.started = true;\n                }\n            }\n\n            // push new ImportState instance onto the stack\n            ImportState state = new ImportState();\n            try {\n                state.nodeName = new NameInfo(svName).getRepoQualifiedName();\n            } catch (RepositoryException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal node name: \" + svName, e));\n            }\n            stack.push(state);\n        } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"property\".equals(localName)) {\n            // sv:property element\n\n            // reset temp fields\n            currentPropValues.clear();\n\n            // property name (value of sv:name attribute)\n            String svName = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"name\");\n            if (svName == null) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"missing mandatory sv:name attribute of element sv:property\"));\n            }\n            try {\n                currentPropName = new NameInfo(svName);\n            } catch (RepositoryException e) {\n                throw new SAXException(new InvalidSerializedDataException(\"illegal property name: \" + svName, e));\n            }\n            // property type (sv:type attribute)\n            String type = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"type\");\n            if (type == null) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"missing mandatory sv:type attribute of element sv:property\"));\n            }\n            try {\n                currentPropType = PropertyType.valueFromName(type);\n            } catch (IllegalArgumentException e) {\n                throw new SAXException(new InvalidSerializedDataException(\n                        \"Unknown property type: \" + type, e));\n            }\n            // 'multi-value' hint (sv:multiple attribute)\n            String multiple = getAttribute(atts, NamespaceConstants.NAMESPACE_SV, \"multiple\");\n            if (multiple != null) {\n                currentPropMultipleStatus = PropInfo.MultipleStatus.MULTIPLE;\n            } else {\n                currentPropMultipleStatus = PropInfo.MultipleStatus.UNKNOWN;\n            }\n        } else if (namespaceURI.equals(NamespaceConstants.NAMESPACE_SV) && \"value\".equals(localName)) {\n            // sv:value element\n            boolean base64 =\n                    currentPropType == PropertyType.BINARY\n                    || \"xs:base64Binary\".equals(atts.getValue(\"xsi:type\"));\n            currentPropValue = new BufferedStringValue(\n                    sessionContext.getValueFactory(), currentNamePathMapper(),\n                    base64);\n        } else {\n            throw new SAXException(new InvalidSerializedDataException(\n                    \"Unexpected element in system view xml document: {\" + namespaceURI + '}' + localName));\n        }\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * create nodes with following properties binary & single binary & multival\n     * notbinary & single notbinary & multival\n     */\n    private static void addExportValues(Node node, String name) throws RepositoryException, IOException {\n        String prefix = \"valid\";\n        if (name.indexOf('<') != -1) {\n            prefix = \"invalid\";\n        }\n        node = getOrAddNode(node, prefix + \"Names\");\n\n        String[] texts = new String[] { \"multival text 1\", \"multival text 2\", \"multival text 3\" };\n        getOrAddNode(node, prefix + \"MultiNoBin\").setProperty(name, texts);\n\n        Node resource = getOrAddNode(node, prefix + \"MultiBin\");\n        resource.setProperty(\"jcr:encoding\", ENCODING);\n        resource.setProperty(\"jcr:mimeType\", \"text/plain\");\n        String[] values = new String[] { \"SGVsbG8gd8O2cmxkLg==\", \"SGVsbG8gd8O2cmxkLg==\" };\n        resource.setProperty(name, values, PropertyType.BINARY);\n        resource.setProperty(\"jcr:lastModified\", Calendar.getInstance());\n\n        getOrAddNode(node, prefix + \"NoBin\").setProperty(name, \"text 1\");\n\n        resource = getOrAddNode(node, \"invalidBin\");\n        resource.setProperty(\"jcr:encoding\", ENCODING);\n        resource.setProperty(\"jcr:mimeType\", \"text/plain\");\n        byte[] bytes = \"Hello w\\u00F6rld.\".getBytes(ENCODING);\n        resource.setProperty(name, new BinaryValue(bytes));\n        resource.setProperty(\"jcr:lastModified\", Calendar.getInstance());\n    }","id":74346,"modified_method":"/**\n     * create nodes with following properties binary & single binary & multival\n     * notbinary & single notbinary & multival\n     */\n    private static void addExportValues(Node node, String name) throws RepositoryException, IOException {\n        String prefix = \"valid\";\n        if (name.indexOf('<') != -1) {\n            prefix = \"invalid\";\n        }\n        node = getOrAddNode(node, prefix + \"Names\");\n\n        String[] texts = new String[] { \"multival text 1\", \"multival text 2\", \"multival text 3\" };\n        getOrAddNode(node, prefix + \"MultiNoBin\").setProperty(name, texts);\n\n        Node resource = getOrAddNode(node, prefix + \"MultiBin\");\n        resource.setProperty(\"jcr:encoding\", ENCODING);\n        resource.setProperty(\"jcr:mimeType\", \"text/plain\");\n        String[] values = new String[] { \"SGVsbG8gd8O2cmxkLg==\", \"SGVsbG8gd8O2cmxkLg==\" };\n        resource.setProperty(name, values, PropertyType.BINARY);\n        resource.setProperty(\"jcr:lastModified\", Calendar.getInstance());\n\n        getOrAddNode(node, prefix + \"NoBin\").setProperty(name, \"text 1\");\n\n        resource = getOrAddNode(node, \"invalidBin\");\n        resource.setProperty(\"jcr:encoding\", ENCODING);\n        resource.setProperty(\"jcr:mimeType\", \"text/plain\");\n        resource.setProperty(name, \"Hello w\\u00F6rld.\", PropertyType.BINARY);\n        resource.setProperty(\"jcr:lastModified\", Calendar.getInstance());\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"/**\n     * Creates three nodes under the given node: one of type nt:resource and the\n     * other nodes referencing it.\n     */\n    private static void addNodeTestData(Node node) throws RepositoryException, IOException {\n        if (node.hasNode(\"multiReference\")) {\n            node.getNode(\"multiReference\").remove();\n        }\n        if (node.hasNode(\"resReference\")) {\n            node.getNode(\"resReference\").remove();\n        }\n        if (node.hasNode(\"myResource\")) {\n            node.getNode(\"myResource\").remove();\n        }\n\n        Node resource = node.addNode(\"myResource\", \"nt:resource\");\n        // nt:resource not longer referenceable since JCR 2.0\n        resource.addMixin(\"mix:referenceable\");\n        resource.setProperty(\"jcr:encoding\", ENCODING);\n        resource.setProperty(\"jcr:mimeType\", \"text/plain\");\n        resource.setProperty(\"jcr:data\", new BinaryValue(\"Hello w\\u00F6rld.\".getBytes(ENCODING)));\n        resource.setProperty(\"jcr:lastModified\", Calendar.getInstance());\n\n        Node resReference = getOrAddNode(node, \"reference\");\n        resReference.setProperty(\"ref\", resource);\n        // make this node itself referenceable\n        resReference.addMixin(\"mix:referenceable\");\n\n        Node multiReference = node.addNode(\"multiReference\");\n        ValueFactory factory = node.getSession().getValueFactory();\n        multiReference.setProperty(\"ref\", new Value[] {\n            factory.createValue(resource),\n            factory.createValue(resReference)\n        });\n\n        // NodeDefTest requires a test node with a mandatory child node\n        JcrUtils.putFile(node, \"testFile\", \"text/plain\", new ByteArrayInputStream(\"Hello, World!\".getBytes(\"UTF-8\")));\n    }","id":74347,"modified_method":"/**\n     * Creates three nodes under the given node: one of type nt:resource and the\n     * other nodes referencing it.\n     */\n    private static void addNodeTestData(Node node) throws RepositoryException, IOException {\n        if (node.hasNode(\"multiReference\")) {\n            node.getNode(\"multiReference\").remove();\n        }\n        if (node.hasNode(\"resReference\")) {\n            node.getNode(\"resReference\").remove();\n        }\n        if (node.hasNode(\"myResource\")) {\n            node.getNode(\"myResource\").remove();\n        }\n\n        Node resource = node.addNode(\"myResource\", \"nt:resource\");\n        // nt:resource not longer referenceable since JCR 2.0\n        resource.addMixin(\"mix:referenceable\");\n        resource.setProperty(\"jcr:encoding\", ENCODING);\n        resource.setProperty(\"jcr:mimeType\", \"text/plain\");\n        resource.setProperty(\"jcr:data\", \"Hello w\\u00F6rld.\", PropertyType.BINARY);\n        resource.setProperty(\"jcr:lastModified\", Calendar.getInstance());\n\n        Node resReference = getOrAddNode(node, \"reference\");\n        resReference.setProperty(\"ref\", resource);\n        // make this node itself referenceable\n        resReference.addMixin(\"mix:referenceable\");\n\n        Node multiReference = node.addNode(\"multiReference\");\n        ValueFactory factory = node.getSession().getValueFactory();\n        multiReference.setProperty(\"ref\", new Value[] {\n            factory.createValue(resource),\n            factory.createValue(resReference)\n        });\n\n        // NodeDefTest requires a test node with a mandatory child node\n        JcrUtils.putFile(node, \"testFile\", \"text/plain\", new ByteArrayInputStream(\"Hello, World!\".getBytes(\"UTF-8\")));\n    }","commit_id":"730bf26ce29352e122d4b79af523394b87c92d8f","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Group createGroup(String groupID, Principal principal, String intermediatePath) throws RepositoryException {\n        checkValidID(groupID);\n        checkValidPrincipal(principal, true);\n\n        String oakPath = namePathMapper.getOakPath(intermediatePath);\n        Tree groupTree = getUserProvider().createGroup(groupID, oakPath);\n        setPrincipal(groupTree, principal);\n\n        Group group = new GroupImpl(groupTree, this);\n        onCreate(group);\n\n        log.debug(\"Group created: \" + groupID);\n        return group;\n    }","id":74348,"modified_method":"@Override\n    public Group createGroup(String groupID, Principal principal, String intermediatePath) throws RepositoryException {\n        checkValidID(groupID);\n        checkValidPrincipal(principal, true);\n\n        if (intermediatePath != null) {\n            intermediatePath = namePathMapper.getOakPath(intermediatePath);\n        }\n        Tree groupTree = getUserProvider().createGroup(groupID, intermediatePath);\n        setPrincipal(groupTree, principal);\n\n        Group group = new GroupImpl(groupTree, this);\n        onCreate(group);\n\n        log.debug(\"Group created: \" + groupID);\n        return group;\n    }","commit_id":"a76a7dc8710662cef3e60dbfc97c1f18cb4a8aa5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public User createUser(String userID, String password, Principal principal, String intermediatePath) throws RepositoryException {\n        checkValidID(userID);\n        checkValidPrincipal(principal, false);\n\n        String oakPath = namePathMapper.getOakPath(intermediatePath);\n        Tree userTree = getUserProvider().createUser(userID, intermediatePath);\n        setPrincipal(userTree, principal);\n        setPassword(userTree, password, true);\n\n        User user = new UserImpl(userTree, this);\n        onCreate(user, password);\n\n        log.debug(\"User created: \" + userID);\n        return user;\n    }","id":74349,"modified_method":"@Override\n    public User createUser(String userID, String password, Principal principal, String intermediatePath) throws RepositoryException {\n        checkValidID(userID);\n        checkValidPrincipal(principal, false);\n\n        if (intermediatePath != null) {\n            intermediatePath = namePathMapper.getOakPath(intermediatePath);\n        }\n        Tree userTree = userProvider.createUser(userID, intermediatePath);\n        setPrincipal(userTree, principal);\n        setPassword(userTree, password, true);\n\n        User user = new UserImpl(userTree, this);\n        onCreate(user, password);\n\n        log.debug(\"User created: \" + userID);\n        return user;\n    }","commit_id":"a76a7dc8710662cef3e60dbfc97c1f18cb4a8aa5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"@Override\n    public Tree getAuthorizableByPrincipal(Principal principal) {\n        Tree authorizableTree = null;\n        if (principal instanceof TreeBasedPrincipal) {\n            authorizableTree = root.getTree(((TreeBasedPrincipal) principal).getOakPath());\n        } else {\n            // NOTE: in contrast to JR2 the extra shortcut for ID==principalName\n            // can be omitted as principals names are stored in user defined\n            // index as well.\n            try {\n                CoreValue bindValue = valueFactory.createValue(principal.getName());\n                Map<String, CoreValue> bindings = Collections.singletonMap(\"principalName\", bindValue);\n                String stmt = \"SELECT * FROM [rep:Authorizable] WHERE [rep:principalName] = $principalName\";\n                Result result = queryEngine.executeQuery(stmt,\n                        Query.JCR_SQL2, 1, 0,\n                        Collections.singletonMap(\"principalName\", bindValue),\n                        new NamePathMapper.Default());\n\n                Iterator rows = result.getRows().iterator();\n                if (rows.hasNext()) {\n                    String path = rows.next().toString();\n                    authorizableTree = root.getTree(path);\n                }\n            } catch (ParseException ex) {\n                log.error(\"query failed\", ex);\n            }\n        }\n        return authorizableTree;\n    }","id":74350,"modified_method":"@Override\n    public Tree getAuthorizableByPrincipal(Principal principal) {\n        if (principal instanceof TreeBasedPrincipal) {\n            return root.getTree(((TreeBasedPrincipal) principal).getOakPath());\n        }\n\n        // NOTE: in contrast to JR2 the extra shortcut for ID==principalName\n        // can be omitted as principals names are stored in user defined\n        // index as well.\n        try {\n            CoreValue bindValue = valueFactory.createValue(principal.getName());\n            String stmt = \"SELECT * FROM [rep:Authorizable] WHERE [rep:principalName] = $principalName\";\n            Result result = queryEngine.executeQuery(stmt,\n                    Query.JCR_SQL2, 1, 0,\n                    Collections.singletonMap(\"principalName\", bindValue),\n                    new NamePathMapper.Default());\n\n            Iterator<? extends ResultRow> rows = result.getRows().iterator();\n            if (rows.hasNext()) {\n                String path = rows.next().getPath();\n                return root.getTree(path);\n            }\n        } catch (ParseException ex) {\n            log.error(\"query failed\", ex);\n        }\n\n        return null;\n    }","commit_id":"a76a7dc8710662cef3e60dbfc97c1f18cb4a8aa5","url":"https://github.com/apache/jackrabbit-oak"},{"original_method":"public synchronized String toString() {\n\t\tStringBuilder s = new StringBuilder();\n\t\ts.append(\"HourlyStats: Report for hour beginning with UTC \");\n\t\ts.append(utcDateTime.format(beginTime, new StringBuffer(), new FieldPosition(0))).append(\"\\n\");\n\t\ts.append(\"HourlyStats: Node uptime (ms):\\t\").append(node.getUptime()).append(\"\\n\");\n\t\ts.append(\"HourlyStats: build:\\t\").append(Version.buildNumber()).append(\"\\n\");\n\t\ts.append(\"HourlyStats: CompleteHour: \").append(completeHour);\n\t\ts.append(\"\\tFinished: \").append(finishedReporting).append(\"\\n\");\n\n\t\tfor (int i = byHTL.length - 1; i >= 0; i--) {\n\t\t\ts.append(\"HourlyStats: HTL\\t\").append(i).append(\"\\t\");\n\t\t\tHTLStats line = byHTL[i];\n\n\t\t\ts.append(line.chkLocalSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.chkRemoteSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.chkFailureDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.sskLocalSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.sskRemoteSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.sskFailureDist.countReports()).append(\"\\t\");\n\n\t\t\ts.append(line.chkLocalSuccessDist.currentValue()).append(\"\\t\");\n\t\t\ts.append(line.chkRemoteSuccessDist.currentValue()).append(\"\\t\");\n\t\t\ts.append(line.chkFailureDist.currentValue()).append(\"\\t\");\n\t\t\ts.append(line.sskLocalSuccessDist.currentValue()).append(\"\\t\");\n\t\t\ts.append(line.sskRemoteSuccessDist.currentValue()).append(\"\\t\");\n\t\t\ts.append(line.sskFailureDist.currentValue()).append(\"\\n\");\n\t\t}\n\t\treturn s.toString();\n\t}","id":74351,"modified_method":"public synchronized String toString() {\n\t\tStringBuilder s = new StringBuilder();\n\t\ts.append(\"HourlyStats: Report for hour beginning with UTC \");\n\t\ts.append(utcDateTime.format(beginTime, new StringBuffer(), new FieldPosition(0))).append(\"\\n\");\n\t\ts.append(\"HourlyStats: Node uptime (ms):\\t\").append(node.getUptime()).append(\"\\n\");\n\t\ts.append(\"HourlyStats: build:\\t\").append(Version.buildNumber()).append(\"\\n\");\n\t\ts.append(\"HourlyStats: CompleteHour: \").append(completeHour);\n\t\ts.append(\"\\tFinished: \").append(finishedReporting).append(\"\\n\");\n\n\t\tfor (int i = byHTL.length - 1; i >= 0; i--) {\n\t\t\ts.append(\"HourlyStats: HTL\\t\").append(i).append(\"\\t\");\n\t\t\tHTLStats line = byHTL[i];\n\n\t\t\ts.append(line.chkLocalSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.chkRemoteSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.chkFailureDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.sskLocalSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.sskRemoteSuccessDist.countReports()).append(\"\\t\");\n\t\t\ts.append(line.sskFailureDist.countReports()).append(\"\\t\");\n\n\t\t\ts.append(fix4p.format(fixNaN(line.chkLocalSuccessDist.currentValue()))).append(\"\\t\");\n\t\t\ts.append(fix4p.format(fixNaN(line.chkRemoteSuccessDist.currentValue()))).append(\"\\t\");\n\t\t\ts.append(fix4p.format(fixNaN(line.chkFailureDist.currentValue()))).append(\"\\t\");\n\t\t\ts.append(fix4p.format(fixNaN(line.sskLocalSuccessDist.currentValue()))).append(\"\\t\");\n\t\t\ts.append(fix4p.format(fixNaN(line.sskRemoteSuccessDist.currentValue()))).append(\"\\t\");\n\t\t\ts.append(fix4p.format(fixNaN(line.sskFailureDist.currentValue()))).append(\"\\n\");\n\t\t}\n\t\treturn s.toString();\n\t}","commit_id":"0f4550b85e03747c5a3b1b0c9671d3226a769972","url":"https://github.com/freenet/fred"},{"original_method":"@Override\n  public void synchronizeAfter(DbSession session, long timestamp) {\n    throw new IllegalStateException(\"Log Index does not synchronize!\");\n  }","id":74352,"modified_method":"@Override\n  public void synchronizeAfter(DbSession session, long timestamp) {\n\n  }","commit_id":"b261040b47ddee53f91396909fe304543eab5bd0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void insert(DbSession session, E item, Date now) {\n    item.setCreatedAt(now);\n    item.setUpdatedAt(now);\n    doInsert(session, item);\n    if (hasIndex()) {\n      session.enqueue(new DtoIndexAction<E>(getIndexType(), IndexAction.Method.UPSERT, item));\n    }\n  }","id":74353,"modified_method":"private void insert(DbSession session, E item, Date now) {\n    if (item.getCreatedAt() == null) {\n      item.setCreatedAt(now);\n    }\n    item.setUpdatedAt(now);\n    doInsert(session, item);\n    if (hasIndex()) {\n      session.enqueue(new DtoIndexAction<E>(getIndexType(), IndexAction.Method.UPSERT, item));\n    }\n  }","commit_id":"b261040b47ddee53f91396909fe304543eab5bd0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public void execute() {\n    /* synchronize all activeRules until we have mng tables in INDEX */\n    DbSession session = db.openSession(true);\n    LOG.info(\"Starting DB to Index synchronization\");\n    long start = System.currentTimeMillis();\n    db.ruleDao().synchronizeAfter(session, 0);\n    db.activeRuleDao().synchronizeAfter(session, 0);\n    session.commit();\n    LOG.info(\"Synchronization done in {}ms...\", System.currentTimeMillis()-start);\n    session.close();\n  }","id":74354,"modified_method":"public void execute() {\n    /* synchronize all activeRules until we have mng tables in INDEX */\n    DbSession session = db.openSession(true);\n    LOG.info(\"Starting DB to Index synchronization\");\n    long start = System.currentTimeMillis();\n    db.ruleDao().synchronizeAfter(session, 0);\n    db.activeRuleDao().synchronizeAfter(session, 0);\n    db.activityDao().synchronizeAfter(session, 0);\n    session.commit();\n    LOG.info(\"Synchronization done in {}ms...\", System.currentTimeMillis()-start);\n    session.close();\n  }","commit_id":"b261040b47ddee53f91396909fe304543eab5bd0","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"activity\")\n      .setDescription(format(\"Search for past task executions. Requires the system administration permission, \" +\n        \"or project administration permission if %s is set.\", PARAM_COMPONENT_UUID))\n      .setResponseExample(getClass().getResource(\"activity-example.json\"))\n      .setHandler(this)\n      .setSince(\"5.2\");\n    action.createParam(PARAM_COMPONENT_UUID)\n      .setDescription(\"Optional id of the component (project) to filter on\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_03);\n    action.createParam(PARAM_COMPONENT_QUERY)\n      .setDescription(format(\"Optional search by component name or key. Must not be set together with %s.\", PARAM_COMPONENT_UUID))\n      .setExampleValue(\"Apache\");\n    action.createParam(PARAM_STATUS)\n      .setDescription(\"Optional filter on task status\")\n      .setPossibleValues(CeActivityDto.Status.values());\n    action.createParam(PARAM_ONLY_CURRENTS)\n      .setDescription(\"Optional filter on the current activities (only the most recent task by project)\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"false\");\n    action.createParam(PARAM_TYPE)\n      .setDescription(\"Optional filter on task type\")\n      .setExampleValue(CeTaskTypes.REPORT);\n    action.createParam(PARAM_MIN_SUBMITTED_AT)\n      .setDescription(\"Optional filter on minimum date of task submission\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.createParam(PARAM_MAX_EXECUTED_AT)\n      .setDescription(\"Optional filter on the maximum date of end of task processing\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.addPagingParams(10);\n  }","id":74355,"modified_method":"@Override\n  public void define(WebService.NewController controller) {\n    WebService.NewAction action = controller.createAction(\"activity\")\n      .setDescription(format(\"Search for tasks.<br> \" +\n        \"Requires the system administration permission, \" +\n        \"or project administration permission if %s is set.\", PARAM_COMPONENT_ID))\n      .setResponseExample(getClass().getResource(\"activity-example.json\"))\n      .setHandler(this)\n      .setSince(\"5.2\");\n\n    action.createParam(PARAM_COMPONENT_ID)\n      .setDescription(\"Id of the component (project) to filter on\")\n      .setExampleValue(Uuids.UUID_EXAMPLE_03);\n    action.createParam(PARAM_COMPONENT_QUERY)\n      .setDescription(format(\"Limit search to: <ul>\" +\n        \"<li>component names that contain the supplied string<\/li>\" +\n        \"<li>component keys that are exactly the same as the supplied string<\/li>\" +\n        \"<\/ul>\" +\n        \"Must not be set together with %s\", PARAM_COMPONENT_ID))\n      .setExampleValue(\"Apache\");\n    action.createParam(PARAM_STATUS)\n      .setDescription(\"Comma separated list of task statuses\")\n      .setPossibleValues(ImmutableList.builder()\n        .add(CeActivityDto.Status.values())\n        .add(CeQueueDto.Status.values()).build())\n      .setExampleValue(Joiner.on(\",\").join(CeQueueDto.Status.IN_PROGRESS, CeActivityDto.Status.SUCCESS))\n      // activity statuses by default to be backward compatible\n      // queued tasks have been added in 5.5\n      .setDefaultValue(Joiner.on(\",\").join(CeActivityDto.Status.values()));\n    action.createParam(PARAM_ONLY_CURRENTS)\n      .setDescription(\"Filter on the last tasks (only the most recent finished task by project)\")\n      .setBooleanPossibleValues()\n      .setDefaultValue(\"false\");\n    action.createParam(PARAM_TYPE)\n      .setDescription(\"Task type\")\n      .setExampleValue(CeTaskTypes.REPORT)\n      .setPossibleValues(taskTypes);\n    action.createParam(PARAM_MIN_SUBMITTED_AT)\n      .setDescription(\"Minimum date of task submission\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.createParam(PARAM_MAX_EXECUTED_AT)\n      .setDescription(\"Maximum date of end of task processing\")\n      .setExampleValue(DateUtils.formatDateTime(new Date()));\n    action.addPagingParams(100);\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private CeActivityQuery buildQuery(DbSession dbSession, Request wsRequest) {\n    String componentUuid = wsRequest.param(PARAM_COMPONENT_UUID);\n    String componentQuery = wsRequest.param(PARAM_COMPONENT_QUERY);\n    checkRequest(componentUuid == null || componentQuery == null,\n      format(\"Only one of following parameters is accepted: %s or %s\", PARAM_COMPONENT_UUID, PARAM_COMPONENT_QUERY));\n\n    CeActivityQuery query = new CeActivityQuery();\n    query.setType(wsRequest.param(PARAM_TYPE));\n    query.setOnlyCurrents(wsRequest.mandatoryParamAsBoolean(PARAM_ONLY_CURRENTS));\n    query.setMinSubmittedAt(toTime(wsRequest.paramAsDateTime(PARAM_MIN_SUBMITTED_AT)));\n    query.setMaxExecutedAt(toTime(wsRequest.paramAsDateTime(PARAM_MAX_EXECUTED_AT)));\n\n    String status = wsRequest.param(PARAM_STATUS);\n    if (status != null) {\n      query.setStatus(CeActivityDto.Status.valueOf(status));\n    }\n\n    loadComponentUuids(dbSession, wsRequest, query);\n    return query;\n  }","id":74356,"modified_method":"private CeActivityQuery buildQuery(DbSession dbSession, ActivityWsRequest request) {\n    CeActivityQuery query = new CeActivityQuery();\n    query.setType(request.getType());\n    query.setOnlyCurrents(request.getOnlyCurrents());\n    query.setMinSubmittedAt(dateToLong(parseDateTimeQuietly(request.getMinSubmittedAt())));\n    query.setMaxExecutedAt(dateToLong(parseDateTimeQuietly(request.getMaxExecutedAt())));\n\n    List<String> statuses = request.getStatus();\n    if (statuses != null && !statuses.isEmpty()) {\n      query.setStatuses(request.getStatus());\n    }\n\n    loadComponentUuids(dbSession, request, query);\n    return query;\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      CeActivityQuery query = buildQuery(dbSession, wsRequest);\n      checkPermissions(query);\n\n      RowBounds rowBounds = readMyBatisRowBounds(wsRequest);\n      List<CeActivityDto> dtos = dbClient.ceActivityDao().selectByQuery(dbSession, query, rowBounds);\n      int total = dbClient.ceActivityDao().countByQuery(dbSession, query);\n\n      WsCe.ActivityResponse.Builder wsResponseBuilder = WsCe.ActivityResponse.newBuilder();\n      wsResponseBuilder.addAllTasks(formatter.formatActivity(dbSession, dtos));\n      wsResponseBuilder.setPaging(Common.Paging.newBuilder()\n        .setPageIndex(wsRequest.mandatoryParamAsInt(WebService.Param.PAGE))\n        .setPageSize(wsRequest.mandatoryParamAsInt(WebService.Param.PAGE_SIZE))\n        .setTotal(total));\n      WsUtils.writeProtobuf(wsResponseBuilder.build(), wsRequest, wsResponse);\n\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":74357,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    ActivityResponse activityResponse = doHandle(toSearchWsRequest(wsRequest));\n    writeProtobuf(activityResponse, wsRequest, wsResponse);\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public ActivityAction(UserSession userSession, DbClient dbClient, TaskFormatter formatter) {\n    this.userSession = userSession;\n    this.dbClient = dbClient;\n    this.formatter = formatter;\n  }","id":74358,"modified_method":"public ActivityAction(UserSession userSession, DbClient dbClient, TaskFormatter formatter, CeTaskProcessor[] taskProcessors) {\n    this.userSession = userSession;\n    this.dbClient = dbClient;\n    this.formatter = formatter;\n\n    this.taskTypes = new LinkedHashSet<>();\n    for (CeTaskProcessor taskProcessor : taskProcessors) {\n      taskTypes.addAll(taskProcessor.getHandledCeTaskTypes());\n    }\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void loadComponentUuids(DbSession dbSession, Request wsRequest, CeActivityQuery query) {\n    String componentUuid = wsRequest.param(PARAM_COMPONENT_UUID);\n    String componentQuery = wsRequest.param(PARAM_COMPONENT_QUERY);\n    if (componentUuid != null && componentQuery != null) {\n      throw new BadRequestException(format(\"Only one of parameters must be set: %s or %s\", PARAM_COMPONENT_UUID, PARAM_COMPONENT_QUERY));\n    }\n\n    if (componentUuid != null) {\n      query.setComponentUuid(componentUuid);\n    }\n    if (componentQuery != null) {\n      ComponentQuery componentDtoQuery = ComponentQuery.builder().setNameOrKeyQuery(componentQuery).setQualifiers(Qualifiers.PROJECT, Qualifiers.VIEW).build();\n      List<ComponentDto> componentDtos = dbClient.componentDao().selectByQuery(dbSession, componentDtoQuery, 0, CeActivityQuery.MAX_COMPONENT_UUIDS);\n      query.setComponentUuids(Lists.transform(componentDtos, ComponentDtoFunctions.toUuid()));\n    }\n  }","id":74359,"modified_method":"private void loadComponentUuids(DbSession dbSession, ActivityWsRequest request, CeActivityQuery query) {\n    String componentUuid = request.getComponentId();\n    String componentQuery = request.getComponentQuery();\n\n    if (componentUuid != null) {\n      query.setComponentUuid(componentUuid);\n    }\n    if (componentQuery != null) {\n      ComponentQuery componentDtoQuery = ComponentQuery.builder().setNameOrKeyQuery(componentQuery).setQualifiers(Qualifiers.PROJECT, Qualifiers.VIEW).build();\n      List<ComponentDto> componentDtos = dbClient.componentDao().selectByQuery(dbSession, componentDtoQuery, 0, CeActivityQuery.MAX_COMPONENT_UUIDS);\n      query.setComponentUuids(Lists.transform(componentDtos, ComponentDtoFunctions.toUuid()));\n    }\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_by_status() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insert(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n\n    TestResponse wsResponse = tester.newRequest()\n      .setParam(\"status\", \"FAILED\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.PARSER);\n    assertThat(activityResponse.getTasksCount()).isEqualTo(1);\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T2\");\n  }","id":74360,"modified_method":"@Test\n  public void filter_by_status() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insertActivity(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insertActivity(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n    insertQueue(\"T3\", \"PROJECT_1\", CeQueueDto.Status.IN_PROGRESS);\n\n    TestResponse wsResponse = ws.newRequest()\n      .setParam(\"status\", \"FAILED,IN_PROGRESS\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.parser());\n    assertThat(activityResponse.getTasksCount()).isEqualTo(2);\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T3\");\n    assertThat(activityResponse.getTasks(1).getId()).isEqualTo(\"T2\");\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void search_activity_by_component_name() throws IOException {\n    componentDb.insertProjectAndSnapshot(newProjectDto().setName(\"apache struts\").setUuid(\"P1\"));\n    componentDb.insertProjectAndSnapshot(newProjectDto().setName(\"apache zookeeper\").setUuid(\"P2\"));\n    componentDb.insertProjectAndSnapshot(newProjectDto().setName(\"eclipse\").setUuid(\"P3\"));\n    dbTester.commit();\n    componentDb.indexProjects();\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insert(\"T1\", \"P1\", CeActivityDto.Status.SUCCESS);\n    insert(\"T2\", \"P2\", CeActivityDto.Status.SUCCESS);\n    insert(\"T3\", \"P3\", CeActivityDto.Status.SUCCESS);\n\n    TestResponse wsResponse = tester.newRequest()\n      .setParam(\"componentQuery\", \"apac\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = WsCe.ActivityResponse.parseFrom(wsResponse.getInputStream());\n    assertThat(activityResponse.getTasksList()).extracting(\"id\").containsOnly(\"T1\", \"T2\");\n  }","id":74361,"modified_method":"@Test\n  public void search_activity_by_component_name() throws IOException {\n    componentDb.insertProjectAndSnapshot(newProjectDto().setName(\"apache struts\").setUuid(\"P1\"));\n    componentDb.insertProjectAndSnapshot(newProjectDto().setName(\"apache zookeeper\").setUuid(\"P2\"));\n    componentDb.insertProjectAndSnapshot(newProjectDto().setName(\"eclipse\").setUuid(\"P3\"));\n    dbTester.commit();\n    componentDb.indexProjects();\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insertActivity(\"T1\", \"P1\", CeActivityDto.Status.SUCCESS);\n    insertActivity(\"T2\", \"P2\", CeActivityDto.Status.SUCCESS);\n    insertActivity(\"T3\", \"P3\", CeActivityDto.Status.SUCCESS);\n\n    TestResponse wsResponse = ws.newRequest()\n      .setParam(\"componentQuery\", \"apac\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = WsCe.ActivityResponse.parseFrom(wsResponse.getInputStream());\n    assertThat(activityResponse.getTasksList()).extracting(\"id\").containsOnly(\"T1\", \"T2\");\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void project_administrator_can_access_his_project_activity() {\n    // no need to be a system admin\n    userSession.addComponentUuidPermission(UserRole.ADMIN, \"PROJECT_1\", \"PROJECT_1\");\n    insert(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n\n    TestResponse wsResponse = tester.newRequest()\n      .setParam(\"componentId\", \"PROJECT_1\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.PARSER);\n    assertThat(activityResponse.getTasksCount()).isEqualTo(1);\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T1\");\n    assertThat(activityResponse.getTasks(0).getStatus()).isEqualTo(WsCe.TaskStatus.SUCCESS);\n    assertThat(activityResponse.getTasks(0).getComponentId()).isEqualTo(\"PROJECT_1\");\n  }","id":74362,"modified_method":"@Test\n  public void project_administrator_can_access_his_project_activity() {\n    // no need to be a system admin\n    userSession.addComponentUuidPermission(UserRole.ADMIN, \"PROJECT_1\", \"PROJECT_1\");\n    insertActivity(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insertActivity(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n\n    TestResponse wsResponse = ws.newRequest()\n      .setParam(\"componentId\", \"PROJECT_1\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.parser());\n    assertThat(activityResponse.getTasksCount()).isEqualTo(1);\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T1\");\n    assertThat(activityResponse.getTasks(0).getStatus()).isEqualTo(WsCe.TaskStatus.SUCCESS);\n    assertThat(activityResponse.getTasks(0).getComponentId()).isEqualTo(\"PROJECT_1\");\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void assertPage(int pageIndex, int pageSize, int expectedTotal, List<String> expectedOrderedTaskIds) {\n    TestResponse wsResponse = tester.newRequest()\n      .setMediaType(MediaTypes.PROTOBUF)\n      .setParam(WebService.Param.PAGE, Integer.toString(pageIndex))\n      .setParam(WebService.Param.PAGE_SIZE, Integer.toString(pageSize))\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.PARSER);\n    assertThat(activityResponse.getPaging().getPageIndex()).isEqualTo(pageIndex);\n    assertThat(activityResponse.getPaging().getPageSize()).isEqualTo(pageSize);\n    assertThat(activityResponse.getPaging().getTotal()).isEqualTo(expectedTotal);\n\n    assertThat(activityResponse.getTasksCount()).isEqualTo(expectedOrderedTaskIds.size());\n    for (int i = 0; i < expectedOrderedTaskIds.size(); i++) {\n      String expectedTaskId = expectedOrderedTaskIds.get(i);\n      assertThat(activityResponse.getTasks(i).getId()).isEqualTo(expectedTaskId);\n    }\n  }","id":74363,"modified_method":"private void assertPage(int pageIndex, int pageSize, int expectedTotal, List<String> expectedOrderedTaskIds) {\n    TestResponse wsResponse = ws.newRequest()\n      .setMediaType(MediaTypes.PROTOBUF)\n      .setParam(WebService.Param.PAGE, Integer.toString(pageIndex))\n      .setParam(WebService.Param.PAGE_SIZE, Integer.toString(pageSize))\n      .setParam(PARAM_STATUS, \"SUCCESS,FAILED,CANCELED,IN_PROGRESS,PENDING\")\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.parser());\n    assertThat(activityResponse.getPaging().getPageIndex()).isEqualTo(pageIndex);\n    assertThat(activityResponse.getPaging().getPageSize()).isEqualTo(pageSize);\n    assertThat(activityResponse.getPaging().getTotal()).isEqualTo(expectedTotal);\n\n    assertThat(activityResponse.getTasksCount()).isEqualTo(expectedOrderedTaskIds.size());\n    for (int i = 0; i < expectedOrderedTaskIds.size(); i++) {\n      String expectedTaskId = expectedOrderedTaskIds.get(i);\n      assertThat(activityResponse.getTasks(i).getId()).isEqualTo(expectedTaskId);\n    }\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void filter_on_current_activities() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    // T2 is the current activity (the most recent one)\n    insert(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"T2\", \"PROJECT_1\", CeActivityDto.Status.FAILED);\n\n    TestResponse wsResponse = tester.newRequest()\n      .setParam(\"onlyCurrents\", \"true\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.PARSER);\n    assertThat(activityResponse.getTasksCount()).isEqualTo(1);\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T2\");\n  }","id":74364,"modified_method":"@Test\n  public void filter_on_current_activities() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    // T2 is the current activity (the most recent one)\n    insertActivity(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insertActivity(\"T2\", \"PROJECT_1\", CeActivityDto.Status.FAILED);\n    insertQueue(\"T3\", \"PROJECT_1\", CeQueueDto.Status.PENDING);\n\n    TestResponse wsResponse = ws.newRequest()\n      .setParam(\"onlyCurrents\", \"true\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.parser());\n    assertThat(activityResponse.getTasksCount()).isEqualTo(1);\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T2\");\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void fail_if_both_filters_on_component_id_and_name() {\n    expectedException.expect(BadRequestException.class);\n    expectedException.expectMessage(\"Only one of following parameters is accepted: componentId or componentQuery\");\n\n    tester.newRequest()\n      .setParam(\"componentId\", \"ID1\")\n      .setParam(\"componentQuery\", \"apache\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n  }","id":74365,"modified_method":"@Test\n  public void fail_if_both_filters_on_component_id_and_name() {\n    expectedException.expect(BadRequestException.class);\n    expectedException.expectMessage(\"componentId and componentQuery must not be set at the same time\");\n\n    ws.newRequest()\n      .setParam(\"componentId\", \"ID1\")\n      .setParam(\"componentQuery\", \"apache\")\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private CeActivityDto insert(String taskUuid, String componentUuid, CeActivityDto.Status status) {\n    CeQueueDto queueDto = new CeQueueDto();\n    queueDto.setTaskType(CeTaskTypes.REPORT);\n    queueDto.setComponentUuid(componentUuid);\n    queueDto.setUuid(taskUuid);\n    CeActivityDto activityDto = new CeActivityDto(queueDto);\n    activityDto.setStatus(status);\n    activityDto.setExecutionTimeMs(500L);\n    activityDto.setSnapshotId(123_456L);\n    dbTester.getDbClient().ceActivityDao().insert(dbTester.getSession(), activityDto);\n    dbTester.commit();\n    return activityDto;\n  }","id":74366,"modified_method":"private CeActivityDto insertActivity(String taskUuid, String componentUuid, CeActivityDto.Status status) {\n    CeQueueDto queueDto = new CeQueueDto();\n    queueDto.setTaskType(CeTaskTypes.REPORT);\n    queueDto.setComponentUuid(componentUuid);\n    queueDto.setUuid(taskUuid);\n    CeActivityDto activityDto = new CeActivityDto(queueDto);\n    activityDto.setStatus(status);\n    activityDto.setExecutionTimeMs(500L);\n    activityDto.setSnapshotId(123_456L);\n    dbTester.getDbClient().ceActivityDao().insert(dbTester.getSession(), activityDto);\n    dbTester.commit();\n    return activityDto;\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void get_all_past_activity() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insert(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n\n    TestResponse wsResponse = tester.newRequest()\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    // verify the protobuf response\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.PARSER);\n    assertThat(activityResponse.getTasksCount()).isEqualTo(2);\n\n    // chronological order, from newest to oldest\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T2\");\n    assertThat(activityResponse.getTasks(0).getStatus()).isEqualTo(WsCe.TaskStatus.FAILED);\n    assertThat(activityResponse.getTasks(0).getComponentId()).isEqualTo(\"PROJECT_2\");\n    assertThat(activityResponse.getTasks(0).getAnalysisId()).isEqualTo(\"123456\");\n    assertThat(activityResponse.getTasks(0).getExecutionTimeMs()).isEqualTo(500L);\n    assertThat(activityResponse.getTasks(0).getLogs()).isFalse();\n    assertThat(activityResponse.getTasks(1).getId()).isEqualTo(\"T1\");\n    assertThat(activityResponse.getTasks(1).getStatus()).isEqualTo(WsCe.TaskStatus.SUCCESS);\n    assertThat(activityResponse.getTasks(1).getComponentId()).isEqualTo(\"PROJECT_1\");\n    assertThat(activityResponse.getTasks(1).getLogs()).isFalse();\n  }","id":74367,"modified_method":"@Test\n  public void get_all_past_activity() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insertActivity(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insertActivity(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n\n    TestResponse wsResponse = ws.newRequest()\n      .setMediaType(MediaTypes.PROTOBUF)\n      .execute();\n\n    // verify the protobuf response\n    WsCe.ActivityResponse activityResponse = Protobuf.read(wsResponse.getInputStream(), WsCe.ActivityResponse.parser());\n    assertThat(activityResponse.getTasksCount()).isEqualTo(2);\n\n    // chronological order, from newest to oldest\n    assertThat(activityResponse.getTasks(0).getId()).isEqualTo(\"T2\");\n    assertThat(activityResponse.getTasks(0).getStatus()).isEqualTo(WsCe.TaskStatus.FAILED);\n    assertThat(activityResponse.getTasks(0).getComponentId()).isEqualTo(\"PROJECT_2\");\n    assertThat(activityResponse.getTasks(0).getAnalysisId()).isEqualTo(\"123456\");\n    assertThat(activityResponse.getTasks(0).getExecutionTimeMs()).isEqualTo(500L);\n    assertThat(activityResponse.getTasks(0).getLogs()).isFalse();\n    assertThat(activityResponse.getTasks(1).getId()).isEqualTo(\"T1\");\n    assertThat(activityResponse.getTasks(1).getStatus()).isEqualTo(WsCe.TaskStatus.SUCCESS);\n    assertThat(activityResponse.getTasks(1).getComponentId()).isEqualTo(\"PROJECT_1\");\n    assertThat(activityResponse.getTasks(1).getLogs()).isFalse();\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void paginate_results() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insert(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n\n    assertPage(1, 1, 2, asList(\"T2\"));\n    assertPage(2, 1, 2, asList(\"T1\"));\n    assertPage(1, 10, 2, asList(\"T2\", \"T1\"));\n    assertPage(2, 10, 2, Collections.<String>emptyList());\n  }","id":74368,"modified_method":"@Test\n  public void paginate_results() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    insertActivity(\"T1\", \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insertActivity(\"T2\", \"PROJECT_2\", CeActivityDto.Status.FAILED);\n    insertQueue(\"T3\", \"PROJECT_1\", CeQueueDto.Status.IN_PROGRESS);\n\n    assertPage(1, 1, 3, asList(\"T3\"));\n    assertPage(2, 1, 3, asList(\"T2\"));\n    assertPage(1, 10, 3, asList(\"T3\", \"T2\", \"T1\"));\n    assertPage(2, 10, 3, Collections.<String>emptyList());\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void support_json_response() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    TestResponse wsResponse = tester.newRequest()\n      .setMediaType(MediaTypes.JSON)\n      .execute();\n\n    JsonAssert.assertJson(wsResponse.getInput()).isSimilarTo(\"{\\\"tasks\\\":[]}\");\n  }","id":74369,"modified_method":"@Test\n  public void support_json_response() {\n    userSession.setGlobalPermissions(UserRole.ADMIN);\n    TestResponse wsResponse = ws.newRequest()\n      .setMediaType(MediaTypes.JSON)\n      .execute();\n\n    JsonAssert.assertJson(wsResponse.getInput()).isSimilarTo(\"{\\\"tasks\\\":[]}\");\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/**\n   * Ordered by id desc -> newest to oldest\n   */\n  public List<CeActivityDto> selectByQuery(DbSession dbSession, CeActivityQuery query, RowBounds rowBounds) {\n    if (query.isShortCircuitedByComponentUuids()) {\n      return Collections.emptyList();\n    }\n    return mapper(dbSession).selectByQuery(query, rowBounds);\n  }","id":74370,"modified_method":"/**\n   * Ordered by id desc -> newest to oldest\n   */\n  public List<CeActivityDto> selectByQuery(DbSession dbSession, CeActivityQuery query, int offset, int pageSize) {\n    if (query.isShortCircuitedByComponentUuids()) {\n      return Collections.emptyList();\n    }\n\n    return mapper(dbSession).selectByQuery(query, new RowBounds(offset, pageSize));\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void select_and_count_by_date() {\n    insertWithDates(\"UUID1\", 1_450_000_000_000L, 1_470_000_000_000L);\n    insertWithDates(\"UUID2\", 1_460_000_000_000L, 1_480_000_000_000L);\n\n    // search by min submitted date\n    CeActivityQuery query = new CeActivityQuery().setMinSubmittedAt(1_455_000_000_000L);\n    assertThat(underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10))).extracting(\"uuid\").containsOnly(\"UUID2\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n    // search by max executed date\n    query = new CeActivityQuery().setMaxExecutedAt(1_475_000_000_000L);\n    assertThat(underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10))).extracting(\"uuid\").containsOnly(\"UUID1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n    // search by both dates\n    query = new CeActivityQuery()\n      .setMinSubmittedAt(1_400_000_000_000L)\n      .setMaxExecutedAt(1_475_000_000_000L);\n    assertThat(underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10))).extracting(\"uuid\").containsOnly(\"UUID1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n  }","id":74371,"modified_method":"@Test\n  public void select_and_count_by_date() {\n    insertWithDates(\"UUID1\", 1_450_000_000_000L, 1_470_000_000_000L);\n    insertWithDates(\"UUID2\", 1_460_000_000_000L, 1_480_000_000_000L);\n\n    // search by min submitted date\n    CeActivityQuery query = new CeActivityQuery().setMinSubmittedAt(1_455_000_000_000L);\n    assertThat(underTest.selectByQuery(db.getSession(), query, 0, 5)).extracting(\"uuid\").containsOnly(\"UUID2\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n    // search by max executed date\n    query = new CeActivityQuery().setMaxExecutedAt(1_475_000_000_000L);\n    assertThat(underTest.selectByQuery(db.getSession(), query, 0, 5)).extracting(\"uuid\").containsOnly(\"UUID1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n    // search by both dates\n    query = new CeActivityQuery()\n      .setMinSubmittedAt(1_400_000_000_000L)\n      .setMaxExecutedAt(1_475_000_000_000L);\n    assertThat(underTest.selectByQuery(db.getSession(), query, 0, 5)).extracting(\"uuid\").containsOnly(\"UUID1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_countByQuery() {\n    insert(\"TASK_1\", REPORT, \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_2\", REPORT, \"PROJECT_1\", CeActivityDto.Status.FAILED);\n    insert(\"TASK_3\", REPORT, \"PROJECT_2\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_4\", \"views\", null, CeActivityDto.Status.SUCCESS);\n\n    // no filters\n    CeActivityQuery query = new CeActivityQuery();\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(4);\n\n    // select by component uuid\n    query = new CeActivityQuery().setComponentUuid(\"PROJECT_1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(2);\n\n    // select by status\n    query = new CeActivityQuery().setStatus(CeActivityDto.Status.SUCCESS);\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(3);\n\n    // select by type\n    query = new CeActivityQuery().setType(REPORT);\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(3);\n    query = new CeActivityQuery().setType(\"views\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n    // select by multiple conditions\n    query = new CeActivityQuery().setType(REPORT).setOnlyCurrents(true).setComponentUuid(\"PROJECT_1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n  }","id":74372,"modified_method":"@Test\n  public void test_countByQuery() {\n    insert(\"TASK_1\", REPORT, \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_2\", REPORT, \"PROJECT_1\", CeActivityDto.Status.FAILED);\n    insert(\"TASK_3\", REPORT, \"PROJECT_2\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_4\", \"views\", null, CeActivityDto.Status.SUCCESS);\n\n    // no filters\n    CeActivityQuery query = new CeActivityQuery();\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(4);\n\n    // select by component uuid\n    query = new CeActivityQuery().setComponentUuid(\"PROJECT_1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(2);\n\n    // select by status\n    query = new CeActivityQuery().setStatuses(singletonList(CeActivityDto.Status.SUCCESS.name()));\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(3);\n\n    // select by type\n    query = new CeActivityQuery().setType(REPORT);\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(3);\n    query = new CeActivityQuery().setType(\"views\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n\n    // select by multiple conditions\n    query = new CeActivityQuery().setType(REPORT).setOnlyCurrents(true).setComponentUuid(\"PROJECT_1\");\n    assertThat(underTest.countByQuery(db.getSession(), query)).isEqualTo(1);\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void test_selectByQuery() {\n    insert(\"TASK_1\", REPORT, \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_2\", REPORT, \"PROJECT_1\", CeActivityDto.Status.FAILED);\n    insert(\"TASK_3\", REPORT, \"PROJECT_2\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_4\", \"views\", null, CeActivityDto.Status.SUCCESS);\n\n    // no filters\n    CeActivityQuery query = new CeActivityQuery();\n    List<CeActivityDto> dtos = underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10));\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_4\", \"TASK_3\", \"TASK_2\", \"TASK_1\");\n\n    // select by component uuid\n    query = new CeActivityQuery().setComponentUuid(\"PROJECT_1\");\n    dtos = underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10));\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_2\", \"TASK_1\");\n\n    // select by status\n    query = new CeActivityQuery().setStatus(CeActivityDto.Status.SUCCESS);\n    dtos = underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10));\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_4\", \"TASK_3\", \"TASK_1\");\n\n    // select by type\n    query = new CeActivityQuery().setType(REPORT);\n    dtos = underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10));\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_3\", \"TASK_2\", \"TASK_1\");\n    query = new CeActivityQuery().setType(\"views\");\n    dtos = underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10));\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_4\");\n\n    // select by multiple conditions\n    query = new CeActivityQuery().setType(REPORT).setOnlyCurrents(true).setComponentUuid(\"PROJECT_1\");\n    dtos = underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10));\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_2\");\n  }","id":74373,"modified_method":"@Test\n  public void test_selectByQuery() {\n    insert(\"TASK_1\", REPORT, \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_2\", REPORT, \"PROJECT_1\", CeActivityDto.Status.FAILED);\n    insert(\"TASK_3\", REPORT, \"PROJECT_2\", CeActivityDto.Status.SUCCESS);\n    insert(\"TASK_4\", \"views\", null, CeActivityDto.Status.SUCCESS);\n\n    // no filters\n    CeActivityQuery query = new CeActivityQuery().setStatuses(Collections.<String>emptyList());\n    List<CeActivityDto> dtos = underTest.selectByQuery(db.getSession(), query, 0, 10);\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_4\", \"TASK_3\", \"TASK_2\", \"TASK_1\");\n\n    // select by component uuid\n    query = new CeActivityQuery().setComponentUuid(\"PROJECT_1\");\n    dtos = underTest.selectByQuery(db.getSession(), query, 0, 100);\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_2\", \"TASK_1\");\n\n    // select by status\n    query = new CeActivityQuery().setStatuses(singletonList(CeActivityDto.Status.SUCCESS.name()));\n    dtos = underTest.selectByQuery(db.getSession(), query, 0, 100);\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_4\", \"TASK_3\", \"TASK_1\");\n\n    // select by type\n    query = new CeActivityQuery().setType(REPORT);\n    dtos = underTest.selectByQuery(db.getSession(), query, 0, 100);\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_3\", \"TASK_2\", \"TASK_1\");\n    query = new CeActivityQuery().setType(\"views\");\n    dtos = underTest.selectByQuery(db.getSession(), query, 0, 100);\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_4\");\n\n    // select by multiple conditions\n    query = new CeActivityQuery().setType(REPORT).setOnlyCurrents(true).setComponentUuid(\"PROJECT_1\");\n    dtos = underTest.selectByQuery(db.getSession(), query, 0, 100);\n    assertThat(dtos).extracting(\"uuid\").containsExactly(\"TASK_2\");\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void selectByQuery_no_results_if_shortcircuited_by_component_uuids() {\n    insert(\"TASK_1\", REPORT, \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n\n    CeActivityQuery query = new CeActivityQuery();\n    query.setComponentUuids(Collections.<String>emptyList());\n    assertThat(underTest.selectByQuery(db.getSession(), query, new RowBounds(0, 10))).isEmpty();\n  }","id":74374,"modified_method":"@Test\n  public void selectByQuery_no_results_if_shortcircuited_by_component_uuids() {\n    insert(\"TASK_1\", REPORT, \"PROJECT_1\", CeActivityDto.Status.SUCCESS);\n\n    CeActivityQuery query = new CeActivityQuery();\n    query.setComponentUuids(Collections.<String>emptyList());\n    assertThat(underTest.selectByQuery(db.getSession(), query, 0, 0)).isEmpty();\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@CheckForNull\n  public CeActivityDto.Status getStatus() {\n    return status;\n  }","id":74375,"modified_method":"@CheckForNull\n  public List<String> getStatuses() {\n    return statuses;\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public CeQueueDto insert(DbSession session, CeQueueDto dto) {\n    dto.setCreatedAt(system2.now());\n    dto.setUpdatedAt(system2.now());\n    mapper(session).insert(dto);\n    return dto;\n  }","id":74376,"modified_method":"public CeQueueDto insert(DbSession session, CeQueueDto dto) {\n    if (dto.getCreatedAt() == 0L || dto.getUpdatedAt() == 0L) {\n      dto.setCreatedAt(system2.now());\n      dto.setUpdatedAt(system2.now());\n    }\n\n    mapper(session).insert(dto);\n    return dto;\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void insert(String uuid, String componentUuid, CeQueueDto.Status status) {\n    CeQueueDto dto = new CeQueueDto();\n    dto.setUuid(uuid);\n    dto.setTaskType(CeTaskTypes.REPORT);\n    dto.setComponentUuid(componentUuid);\n    dto.setStatus(status);\n    dto.setSubmitterLogin(\"henri\");\n    underTest.insert(db.getSession(), dto);\n    db.getSession().commit();\n  }","id":74377,"modified_method":"private void insert(String uuid, String componentUuid, CeQueueDto.Status status) {\n    CeQueueDto dto = new CeQueueDto();\n    dto.setUuid(uuid);\n    dto.setTaskType(CeTaskTypes.REPORT);\n    dto.setComponentUuid(componentUuid);\n    dto.setStatus(status);\n    dto.setSubmitterLogin(\"henri\");\n    underTest.insert(db.getSession(), dto);\n    db.commit();\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  protected void configureModule() {\n    add(\n      CeWs.class,\n      ActivityAction.class,\n      CancelAction.class,\n      CancelAllAction.class,\n      QueueAction.class,\n      IsQueueEmptyWs.class,\n      LogsAction.class,\n      ComponentAction.class,\n      SubmitAction.class,\n      TaskFormatter.class,\n      TaskAction.class);\n  }","id":74378,"modified_method":"@Override\n  protected void configureModule() {\n    add(\n      CeWs.class,\n      CancelAction.class,\n      CancelAllAction.class,\n      QueueAction.class,\n      IsQueueEmptyWs.class,\n      LogsAction.class,\n      ComponentAction.class,\n      SubmitAction.class,\n      TaskFormatter.class,\n      TaskAction.class,\n      ActivityAction.class);\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    String componentUuid = wsRequest.mandatoryParam(PARAM_COMPONENT_UUID);\n    userSession.checkComponentUuidPermission(UserRole.USER, componentUuid);\n\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      List<CeQueueDto> queueDtos = dbClient.ceQueueDao().selectByComponentUuid(dbSession, componentUuid);\n      CeActivityQuery activityQuery = new CeActivityQuery()\n        .setComponentUuid(componentUuid)\n        .setOnlyCurrents(true);\n      List<CeActivityDto> activityDtos = dbClient.ceActivityDao().selectByQuery(dbSession, activityQuery, new RowBounds(0, 1));\n\n      ProjectResponse.Builder wsResponseBuilder = ProjectResponse.newBuilder();\n      wsResponseBuilder.addAllQueue(formatter.formatQueue(dbSession, queueDtos));\n      if (activityDtos.size() == 1) {\n        wsResponseBuilder.setCurrent(formatter.formatActivity(dbSession, activityDtos.get(0)));\n      }\n      WsUtils.writeProtobuf(wsResponseBuilder.build(), wsRequest, wsResponse);\n\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","id":74379,"modified_method":"@Override\n  public void handle(Request wsRequest, Response wsResponse) throws Exception {\n    String componentUuid = wsRequest.mandatoryParam(PARAM_COMPONENT_UUID);\n    userSession.checkComponentUuidPermission(UserRole.USER, componentUuid);\n\n    DbSession dbSession = dbClient.openSession(false);\n    try {\n      List<CeQueueDto> queueDtos = dbClient.ceQueueDao().selectByComponentUuid(dbSession, componentUuid);\n      CeActivityQuery activityQuery = new CeActivityQuery()\n        .setComponentUuid(componentUuid)\n        .setOnlyCurrents(true);\n      List<CeActivityDto> activityDtos = dbClient.ceActivityDao().selectByQuery(dbSession, activityQuery, 0, 1);\n\n      ProjectResponse.Builder wsResponseBuilder = ProjectResponse.newBuilder();\n      wsResponseBuilder.addAllQueue(formatter.formatQueue(dbSession, queueDtos));\n      if (activityDtos.size() == 1) {\n        wsResponseBuilder.setCurrent(formatter.formatActivity(dbSession, activityDtos.get(0)));\n      }\n      WsUtils.writeProtobuf(wsResponseBuilder.build(), wsRequest, wsResponse);\n\n    } finally {\n      dbClient.closeSession(dbSession);\n    }\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public HttpWsClient(WsConnector wsConnector) {\n    this.wsConnector = wsConnector;\n    this.permissionsService = new PermissionsService(wsConnector);\n    this.componentsService = new ComponentsService(wsConnector);\n    this.qualityProfilesService = new QualityProfilesService(wsConnector);\n    this.issuesService = new IssuesService(wsConnector);\n    this.userTokensService = new UserTokensService(wsConnector);\n    this.qualityGatesService = new QualityGatesService(wsConnector);\n    this.measuresService = new MeasuresService(wsConnector);\n    this.systemService = new SystemService(wsConnector);\n  }","id":74380,"modified_method":"public HttpWsClient(WsConnector wsConnector) {\n    this.wsConnector = wsConnector;\n    this.permissionsService = new PermissionsService(wsConnector);\n    this.componentsService = new ComponentsService(wsConnector);\n    this.qualityProfilesService = new QualityProfilesService(wsConnector);\n    this.issuesService = new IssuesService(wsConnector);\n    this.userTokensService = new UserTokensService(wsConnector);\n    this.qualityGatesService = new QualityGatesService(wsConnector);\n    this.measuresService = new MeasuresService(wsConnector);\n    this.systemService = new SystemService(wsConnector);\n    this.ceService = new CeService(wsConnector);\n  }","commit_id":"89a93e795af89c98f5e99de60620c21287f7889e","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@NotNull\n  public MethodSignature getSignature(@NotNull PsiSubstitutor substitutor) {\n    return MethodSignatureBackedByPsiMethod.create(this, PsiSubstitutor.EMPTY);\n  }","id":74381,"modified_method":"@NotNull\n  public MethodSignature getSignature(@NotNull PsiSubstitutor substitutor) {\n    return MethodSignatureBackedByPsiMethod.create(this, substitutor);\n  }","commit_id":"b5ea7fb4554b4817ff5dddea31b468411a25ba63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void writeTypeDefinition(StringBuffer text, String typeDefinitionName, GrTypeDefinition typeDefinition, GrPackageDefinition packageDefinition) {\n    final boolean isScript = typeDefinition == null;\n\n    writePackageStatement(text, packageDefinition);\n\n    GrMembersDeclaration[] membersDeclarations = typeDefinition == null ? GrMembersDeclaration.EMPTY_ARRAY : typeDefinition.getMemberDeclarations();\n\n    boolean isClassDef = typeDefinition instanceof GrClassDefinition;\n    boolean isInterface = typeDefinition instanceof GrInterfaceDefinition;\n\n\n    if (typeDefinition != null) {\n      PsiModifierList modifierList = typeDefinition.getModifierList();\n\n      boolean wasAddedModifiers = writeTypeDefinitionMethodModifiers(text, modifierList, JAVA_TYPE_DEFINITION_MODIFIERS, typeDefinition.isInterface());\n      if (!wasAddedModifiers) {\n        text.append(\"public \");\n      }\n    }\n\n    if (isScript) {\n      text.append(\"public \");\n    }\n\n//    text.append(\" \");\n\n    if (isInterface) text.append(\"interface\");\n    else text.append(\"class\");\n\n    text.append(\" \");\n\n    text.append(typeDefinitionName);\n    text.append(\" \");\n\n    if (isScript) {\n      text.append(\"extends \");\n      text.append(\"groovy.lang.Script \");\n    } else {\n      final PsiClassType[] extendsClassesTypes = typeDefinition.getExtendsListTypes();\n\n      if (extendsClassesTypes.length > 0) {\n        text.append(\"extends \");\n        text.append(computeTypeText(extendsClassesTypes[0]));\n        text.append(\" \");\n      } else {\n        if (isClassDef) {\n          text.append(\"extends \");\n          text.append(GrTypeDefinition.DEFAULT_BASE_CLASS_NAME);\n          text.append(\" \");\n        }\n      }\n\n      PsiClassType[] implementsTypes = typeDefinition.getImplementsListTypes();\n\n      if (implementsTypes.length > 0) {\n        text.append(isInterface ? \"extends \" : \"implements \");\n        int i = 0;\n        while (i < implementsTypes.length) {\n          if (i > 0) text.append(\", \");\n          text.append(computeTypeText(implementsTypes[i]));\n          text.append(\" \");\n          i++;\n        }\n      }\n    }\n\n    text.append(\"{\");\n\n    boolean wasRunMethodPresent = false;\n\n//    Map<String, String> gettersNames = new HashMap<String, String>();\n//    Map<String, String> settersNames = new HashMap<String, String>();\n    List<String> gettersNames = new ArrayList<String>();\n    List<String> settersNames = new ArrayList<String>();\n\n    List<Pair<String, MethodSignature>> methods = new ArrayList<Pair<String, MethodSignature>>();\n\n    for (GrMembersDeclaration declaration : membersDeclarations) {\n      if (declaration instanceof GrMethod) {\n        final GrMethod method = (GrMethod) declaration;\n        if (method instanceof GrConstructor) {\n          writeConstructor(text, (GrConstructor) method);\n          continue;\n        }\n\n        Pair<String, MethodSignature> methodNameSignature = new Pair<String, MethodSignature>(method.getName(), method.getSignature(PsiSubstitutor.EMPTY));\n        if (!methods.contains(methodNameSignature)) {\n          methods.add(methodNameSignature);\n          writeMethod(text, method);\n        }\n\n        getDefinedGetters(gettersNames, method);\n        getDefinedSetters(settersNames, method);\n\n        wasRunMethodPresent = wasRunMethod(method);\n      }\n      if (declaration instanceof GrVariableDeclaration) {\n        writeVariableDeclarations(text, (GrVariableDeclaration) declaration);\n      }\n    }\n\n    for (GrMembersDeclaration decl : membersDeclarations) {\n      if (decl instanceof GrVariableDeclaration) {\n        final GrVariable[] variables = ((GrVariableDeclaration) decl).getVariables();\n\n        for (GrVariable variable : variables) {\n          if (variable instanceof GrField && ((GrField) variable).isProperty()) {\n            if (!gettersNames.contains(variable.getName())) {\n              writeMethod(text, ((GrField) variable).getGetter());\n            }\n\n            if (!settersNames.contains(variable.getName())) {\n              writeMethod(text, ((GrField) variable).getSetter());\n            }\n          }\n        }\n      }\n    }\n\n    if (isScript && !wasRunMethodPresent) {\n      writeRunMethod(text);\n    }\n\n    text.append(\"}\");\n  }","id":74382,"modified_method":"private void writeTypeDefinition(StringBuffer text, String typeDefinitionName, PsiClass groovyClass, GrPackageDefinition packageDefinition) {\n    final boolean isScript = groovyClass == null;\n\n    writePackageStatement(text, packageDefinition);\n\n    GrMembersDeclaration[] membersDeclarations = groovyClass instanceof GrTypeDefinition ? ((GrTypeDefinition) groovyClass).getMemberDeclarations() : GrMembersDeclaration.EMPTY_ARRAY; //todo\n\n    boolean isClassDef = groovyClass instanceof GrClassDefinition;\n    boolean isInterface = groovyClass instanceof GrInterfaceDefinition;\n\n\n    if (groovyClass != null) {\n      PsiModifierList modifierList = groovyClass.getModifierList();\n\n      boolean wasAddedModifiers = modifierList != null && writeTypeDefinitionMethodModifiers(text, modifierList, JAVA_TYPE_DEFINITION_MODIFIERS, groovyClass.isInterface());\n      if (!wasAddedModifiers) {\n        text.append(\"public \");\n      }\n    }\n\n    if (isScript) {\n      text.append(\"public \");\n    }\n\n//    text.append(\" \");\n\n    if (isInterface) text.append(\"interface\");\n    else text.append(\"class\");\n\n    text.append(\" \");\n\n    text.append(typeDefinitionName);\n    text.append(\" \");\n\n    if (isScript) {\n      text.append(\"extends \");\n      text.append(\"groovy.lang.Script \");\n    } else {\n      final PsiClassType[] extendsClassesTypes = groovyClass.getExtendsListTypes();\n\n      if (extendsClassesTypes.length > 0) {\n        text.append(\"extends \");\n        text.append(computeTypeText(extendsClassesTypes[0]));\n        text.append(\" \");\n      } else {\n        if (isClassDef) {\n          text.append(\"extends \");\n          text.append(GrTypeDefinition.DEFAULT_BASE_CLASS_NAME);\n          text.append(\" \");\n        }\n      }\n\n      PsiClassType[] implementsTypes = groovyClass.getImplementsListTypes();\n\n      if (implementsTypes.length > 0) {\n        text.append(isInterface ? \"extends \" : \"implements \");\n        int i = 0;\n        while (i < implementsTypes.length) {\n          if (i > 0) text.append(\", \");\n          text.append(computeTypeText(implementsTypes[i]));\n          text.append(\" \");\n          i++;\n        }\n      }\n    }\n\n    text.append(\"{\");\n\n    boolean wasRunMethodPresent = false;\n\n    Set<MethodSignature> methodSignatures = new HashSet<MethodSignature>();\n\n    PsiMethod[] methods = groovyClass.getMethods();\n    for (PsiMethod method : methods) {\n      if (method instanceof GrConstructor) {\n        writeConstructor(text, (GrConstructor) method);\n        continue;\n      }\n\n      MethodSignature signature = method.getSignature(PsiSubstitutor.EMPTY);\n      if (methodSignatures.add(signature)) writeMethod(text, method);\n\n      wasRunMethodPresent = wasRunMethod(method);\n    }\n\n    for (GrMembersDeclaration declaration : membersDeclarations) {\n      if (declaration instanceof GrVariableDeclaration) {\n        writeVariableDeclarations(text, (GrVariableDeclaration) declaration);\n      }\n    }\n\n    for (GrMembersDeclaration decl : membersDeclarations) {\n      if (decl instanceof GrVariableDeclaration) {\n        final GrVariable[] variables = ((GrVariableDeclaration) decl).getVariables();\n\n        for (GrVariable variable : variables) {\n          if (variable instanceof GrField && ((GrField) variable).isProperty()) {\n            PsiMethod getter = ((GrField) variable).getGetter();\n            if (getter != null) writeMethod(text, getter);\n            \n            PsiMethod setter = ((GrField) variable).getSetter();\n            if (setter != null) writeMethod(text, setter);\n          }\n        }\n      }\n    }\n\n    if (isScript && !wasRunMethodPresent) {\n      writeRunMethod(text);\n    }\n\n    text.append(\"}\");\n  }","commit_id":"b5ea7fb4554b4817ff5dddea31b468411a25ba63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String createJavaSourceFile(VirtualFile outputRootDirectory, GroovyFileBase file, String typeDefinitionName, GrTypeDefinition typeDefinition, GrPackageDefinition packageDefinition) {\n    //prefix defines structure of directories tree\n    String prefix = \"\";\n    if (packageDefinition != null) {\n      prefix = getJavaClassPackage(packageDefinition);\n    }\n\n    StringBuffer text = new StringBuffer();\n\n    writeTypeDefinition(text, typeDefinitionName, typeDefinition, packageDefinition);\n\n    VirtualFile virtualFile = file.getVirtualFile();\n    assert virtualFile != null;\n//    String generatedFileRelativePath = prefix + typeDefinitionName + \".\" + \"java\";\n    String fileShortName = typeDefinitionName + \".\" + \"java\";\n    createGeneratedFile(text, outputRootDirectory.getPath(), prefix, fileShortName);\n    return prefix + typeDefinitionName + \".\" + \"java\";\n  }","id":74383,"modified_method":"private String createJavaSourceFile(VirtualFile outputRootDirectory, GroovyFileBase file, String typeDefinitionName, PsiClass groovyClass, GrPackageDefinition packageDefinition) {\n    //prefix defines structure of directories tree\n    String prefix = \"\";\n    if (packageDefinition != null) {\n      prefix = getJavaClassPackage(packageDefinition);\n    }\n\n    StringBuffer text = new StringBuffer();\n\n    writeTypeDefinition(text, typeDefinitionName, groovyClass, packageDefinition);\n\n    VirtualFile virtualFile = file.getVirtualFile();\n    assert virtualFile != null;\n//    String generatedFileRelativePath = prefix + typeDefinitionName + \".\" + \"java\";\n    String fileShortName = typeDefinitionName + \".\" + \"java\";\n    createGeneratedFile(text, outputRootDirectory.getPath(), prefix, fileShortName);\n    return prefix + typeDefinitionName + \".\" + \"java\";\n  }","commit_id":"b5ea7fb4554b4817ff5dddea31b468411a25ba63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean wasRunMethod(GrMethod method) {\n    boolean runMethodPresent = false;\n    if (\"run\".equals(method.getName())) {\n      PsiType returnType = method.getReturnType();\n\n      runMethodPresent = returnType != null && \"java.lang.Object\".equals(computeTypeText(returnType));\n    }\n    return runMethodPresent;\n  }","id":74384,"modified_method":"private boolean wasRunMethod(PsiMethod method) {\n    boolean runMethodPresent = false;\n    if (\"run\".equals(method.getName())) {\n      PsiType returnType = method.getReturnType();\n\n      runMethodPresent = returnType != null && \"java.lang.Object\".equals(computeTypeText(returnType));\n    }\n    return runMethodPresent;\n  }","commit_id":"b5ea7fb4554b4817ff5dddea31b468411a25ba63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List<String> generate(final GroovyFile file, VirtualFile outputRootDirectory) {\n    List<String> generatedItemsRelativePaths = new ArrayList<String>();\n\n    GrTopStatement[] statements = getTopStatementsInReadAction(file);\n\n    GrPackageDefinition packageDefinition = null;\n    if (statements.length > 0 && statements[0] instanceof GrPackageDefinition) {\n      packageDefinition = (GrPackageDefinition) statements[0];\n    }\n\n    if (file.isScript()) {\n      VirtualFile virtualFile = file.getVirtualFile();\n      assert virtualFile != null;\n      String fileDefinitionName = virtualFile.getNameWithoutExtension();\n\n      String topLevelGeneratedItemPath = createJavaSourceFile(outputRootDirectory, file, fileDefinitionName, null, packageDefinition);\n      generatedItemsRelativePaths.add(topLevelGeneratedItemPath);\n    }\n\n    for (final GrTypeDefinition typeDefinition : file.getTypeDefinitions()) {\n      String generatedItemPath = createJavaSourceFile(outputRootDirectory, file, typeDefinition.getName(), typeDefinition, packageDefinition);\n      generatedItemsRelativePaths.add(generatedItemPath);\n    }\n\n    return generatedItemsRelativePaths;\n  }","id":74385,"modified_method":"private List<String> generate(final GroovyFile file, VirtualFile outputRootDirectory) {\n    List<String> generatedItemsRelativePaths = new ArrayList<String>();\n\n    GrTopStatement[] statements = getTopStatementsInReadAction(file);\n\n    GrPackageDefinition packageDefinition = null;\n    if (statements.length > 0 && statements[0] instanceof GrPackageDefinition) {\n      packageDefinition = (GrPackageDefinition) statements[0];\n    }\n\n    if (file.isScript()) {\n      VirtualFile virtualFile = file.getVirtualFile();\n      assert virtualFile != null;\n      String fileDefinitionName = virtualFile.getNameWithoutExtension();\n\n      String topLevelGeneratedItemPath = createJavaSourceFile(outputRootDirectory, file, fileDefinitionName, file.getScriptClass(), packageDefinition);\n      generatedItemsRelativePaths.add(topLevelGeneratedItemPath);\n    }\n\n    for (final GrTypeDefinition typeDefinition : file.getTypeDefinitions()) {\n      String generatedItemPath = createJavaSourceFile(outputRootDirectory, file, typeDefinition.getName(), typeDefinition, packageDefinition);\n      generatedItemsRelativePaths.add(generatedItemPath);\n    }\n\n    return generatedItemsRelativePaths;\n  }","commit_id":"b5ea7fb4554b4817ff5dddea31b468411a25ba63","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        JetFunctionOrPropertyAccessor newElement = (JetFunctionOrPropertyAccessor) element.copy();\n        JetExpression bodyExpression = newElement.getBodyExpression();\n        if (!(newElement.getLastChild() instanceof PsiWhiteSpace)) {\n            newElement.add(JetPsiFactory.createWhiteSpace(project));\n        }\n        if (bodyExpression == null) {\n            newElement.add(JetPsiFactory.createEmptyBody(project));\n        }\n        element.replace(newElement);\n    }","id":74386,"modified_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        JetFunction newElement = (JetFunction) element.copy();\n        JetExpression bodyExpression = newElement.getBodyExpression();\n        if (!(newElement.getLastChild() instanceof PsiWhiteSpace)) {\n            newElement.add(JetPsiFactory.createWhiteSpace(project));\n        }\n        if (bodyExpression == null) {\n            newElement.add(JetPsiFactory.createEmptyBody(project));\n        }\n        element.replace(newElement);\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public AddFunctionBodyFix(@NotNull JetFunctionOrPropertyAccessor element) {\n        super(element);\n    }","id":74387,"modified_method":"public AddFunctionBodyFix(@NotNull JetFunction element) {\n        super(element);\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static JetIntentionActionFactory<JetFunctionOrPropertyAccessor> createFactory() {\n        return new JetIntentionActionFactory<JetFunctionOrPropertyAccessor>() {\n            @Override\n            public JetIntentionAction<JetFunctionOrPropertyAccessor> createAction(DiagnosticWithPsiElement diagnostic) {\n                assert diagnostic.getPsiElement() instanceof JetFunctionOrPropertyAccessor;\n                return new AddFunctionBodyFix((JetFunctionOrPropertyAccessor) diagnostic.getPsiElement());\n            }\n        };\n    }","id":74388,"modified_method":"public static JetIntentionActionFactory<JetFunction> createFactory() {\n        return new JetIntentionActionFactory<JetFunction>() {\n            @Override\n            public JetIntentionAction<JetFunction> createAction(DiagnosticWithPsiElement diagnostic) {\n                assert diagnostic.getPsiElement() instanceof JetFunction;\n                return new AddFunctionBodyFix((JetFunction) diagnostic.getPsiElement());\n            }\n        };\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public String getText() {\n        if (modifier == JetTokens.ABSTRACT_KEYWORD || modifier == JetTokens.OPEN_KEYWORD) {\n            return \"Make \" + getElementName() + \" \" + modifier.getValue();\n        }\n        return \"Add '\" + modifier.getValue() + \"' modifier\";\n    }","id":74389,"modified_method":"@NotNull\n    @Override\n    public String getText() {\n        if (modifier == JetTokens.ABSTRACT_KEYWORD || modifier == JetTokens.OPEN_KEYWORD) {\n            return \"Make \" + getElementName(element) + \" \" + modifier.getValue();\n        }\n        return \"Add '\" + modifier.getValue() + \"' modifier\";\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private AddModifierFix(@NotNull JetModifierListOwner element, JetKeywordToken modifier, JetToken[] modifiersThanCanBeReplaced) {\n        super(element, modifier);\n        this.modifiersThanCanBeReplaced = modifiersThanCanBeReplaced;\n    }","id":74390,"modified_method":"private AddModifierFix(@NotNull JetModifierListOwner element, JetKeywordToken modifier, JetToken[] modifiersThanCanBeReplaced) {\n        super(element);\n        this.modifier = modifier;\n        this.modifiersThanCanBeReplaced = modifiersThanCanBeReplaced;\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkIllegalInThisContextModifiers(@Nullable JetModifierList modifierList, JetKeywordToken... illegalModifiers) {\n        if (modifierList == null) return;\n        for (JetKeywordToken modifier : illegalModifiers) {\n            if (modifierList.hasModifier(modifier)) {\n                context.getTrace().report(Errors.ILLEGAL_MODIFIER.on(modifierList.getModifierNode(modifier), modifier));\n            }\n        }\n    }","id":74391,"modified_method":"private void checkIllegalInThisContextModifiers(@Nullable JetModifierList modifierList, Collection<JetKeywordToken> illegalModifiers) {\n        if (modifierList == null) return;\n        for (JetKeywordToken modifier : illegalModifiers) {\n            if (modifierList.hasModifier(modifier)) {\n                context.getTrace().report(Errors.ILLEGAL_MODIFIER.on(modifierList, modifierList.getModifierNode(modifier), modifier));\n            }\n        }\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkOpenMembers(JetClass aClass, MutableClassDescriptor classDescriptor) {\n            for (CallableMemberDescriptor memberDescriptor : classDescriptor.getCallableMembers()) {\n    \n                JetNamedDeclaration member = (JetNamedDeclaration) context.getTrace().get(BindingContext.DESCRIPTOR_TO_DECLARATION, memberDescriptor);\n                if (member != null && classDescriptor.getModality() == Modality.FINAL && member.hasModifier(JetTokens.OPEN_KEYWORD)) {\n                    ASTNode openModifierNode = member.getModifierList().getModifierNode(JetTokens.OPEN_KEYWORD);\n                    context.getTrace().report(NON_FINAL_MEMBER_IN_FINAL_CLASS.on(member, openModifierNode, aClass));\n                }\n            }\n        }","id":74392,"modified_method":"private void checkOpenMembers(JetClass aClass, MutableClassDescriptor classDescriptor) {\n            for (CallableMemberDescriptor memberDescriptor : classDescriptor.getCallableMembers()) {\n    \n                JetNamedDeclaration member = (JetNamedDeclaration) context.getTrace().get(BindingContext.DESCRIPTOR_TO_DECLARATION, memberDescriptor);\n                if (member != null && classDescriptor.getModality() == Modality.FINAL && member.hasModifier(JetTokens.OPEN_KEYWORD)) {\n                    JetModifierList modifierList = member.getModifierList();\n                    assert  modifierList != null;\n                    ASTNode openModifierNode = modifierList.getModifierNode(JetTokens.OPEN_KEYWORD);\n                    context.getTrace().report(NON_FINAL_MEMBER_IN_FINAL_CLASS.on(member, openModifierNode, aClass));\n                }\n            }\n        }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"protected void checkFunction(JetDeclarationWithBody function, FunctionDescriptor functionDescriptor) {\n        DeclarationDescriptor containingDescriptor = functionDescriptor.getContainingDeclaration();\n        PsiElement nameIdentifier;\n        boolean isPropertyAccessor = false;\n        if (function instanceof JetNamedFunction) {\n            nameIdentifier = ((JetNamedFunction) function).getNameIdentifier();\n        }\n        else if (function instanceof JetPropertyAccessor) {\n            isPropertyAccessor = true;\n            nameIdentifier = ((JetPropertyAccessor) function).getNamePlaceholder();\n        }\n        else {\n            throw new UnsupportedOperationException();\n        }\n        JetFunctionOrPropertyAccessor functionOrPropertyAccessor = (JetFunctionOrPropertyAccessor) function;\n        JetModifierList modifierList = functionOrPropertyAccessor.getModifierList();\n        ASTNode abstractNode = modifierList != null ? modifierList.getModifierNode(JetTokens.ABSTRACT_KEYWORD) : null;\n        boolean hasAbstractModifier = abstractNode != null;\n        if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) containingDescriptor;\n            boolean inTrait = classDescriptor.getKind() == ClassKind.TRAIT;\n            boolean inEnum = classDescriptor.getKind() == ClassKind.ENUM_CLASS;\n            boolean inAbstractClass = classDescriptor.getModality() == Modality.ABSTRACT;\n            if (hasAbstractModifier && !inAbstractClass && !inTrait && !inEnum) {\n                PsiElement classElement = context.getTrace().get(BindingContext.DESCRIPTOR_TO_DECLARATION, classDescriptor);\n                assert classElement instanceof JetClass;\n                context.getTrace().report(ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS.on(functionOrPropertyAccessor, abstractNode, functionDescriptor.getName(), classDescriptor, (JetClass) classElement));\n            }\n            if (hasAbstractModifier && inTrait && !isPropertyAccessor) {\n                context.getTrace().report(REDUNDANT_MODIFIER_IN_TRAIT.on(modifierList, abstractNode, JetTokens.ABSTRACT_KEYWORD));\n            }\n            if (function.getBodyExpression() != null && hasAbstractModifier) {\n                context.getTrace().report(ABSTRACT_FUNCTION_WITH_BODY.on(functionOrPropertyAccessor, abstractNode, functionDescriptor));\n            }\n            if (function.getBodyExpression() == null && !hasAbstractModifier && !inTrait && nameIdentifier != null && !isPropertyAccessor) {\n                context.getTrace().report(NON_ABSTRACT_FUNCTION_WITH_NO_BODY.on(functionOrPropertyAccessor, nameIdentifier, functionDescriptor));\n            }\n            return;\n        }\n        if (hasAbstractModifier) {\n            if (!isPropertyAccessor) {\n                context.getTrace().report(NON_MEMBER_ABSTRACT_FUNCTION.on(functionOrPropertyAccessor, abstractNode, functionDescriptor));\n            }\n            else {\n                context.getTrace().report(NON_MEMBER_ABSTRACT_ACCESSOR.on(functionOrPropertyAccessor, abstractNode));\n            }\n        }\n        if (function.getBodyExpression() == null && !hasAbstractModifier && nameIdentifier != null && !isPropertyAccessor) {\n            context.getTrace().report(NON_MEMBER_FUNCTION_NO_BODY.on(functionOrPropertyAccessor, nameIdentifier, functionDescriptor));\n        }\n    }","id":74393,"modified_method":"protected void checkFunction(JetNamedFunction function, FunctionDescriptor functionDescriptor) {\n        DeclarationDescriptor containingDescriptor = functionDescriptor.getContainingDeclaration();\n        PsiElement nameIdentifier = function.getNameIdentifier();\n        JetModifierList modifierList = function.getModifierList();\n        ASTNode abstractNode = modifierList != null ? modifierList.getModifierNode(JetTokens.ABSTRACT_KEYWORD) : null;\n        boolean hasAbstractModifier = abstractNode != null;\n        if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) containingDescriptor;\n            boolean inTrait = classDescriptor.getKind() == ClassKind.TRAIT;\n            boolean inEnum = classDescriptor.getKind() == ClassKind.ENUM_CLASS;\n            boolean inAbstractClass = classDescriptor.getModality() == Modality.ABSTRACT;\n            if (hasAbstractModifier && !inAbstractClass && !inTrait && !inEnum) {\n                PsiElement classElement = context.getTrace().get(BindingContext.DESCRIPTOR_TO_DECLARATION, classDescriptor);\n                assert classElement instanceof JetClass;\n                context.getTrace().report(ABSTRACT_FUNCTION_IN_NON_ABSTRACT_CLASS.on(function, abstractNode, functionDescriptor.getName(), classDescriptor, (JetClass) classElement));\n            }\n            if (hasAbstractModifier && inTrait) {\n                context.getTrace().report(REDUNDANT_MODIFIER_IN_TRAIT.on(modifierList, abstractNode, JetTokens.ABSTRACT_KEYWORD));\n            }\n            if (function.getBodyExpression() != null && hasAbstractModifier) {\n                context.getTrace().report(ABSTRACT_FUNCTION_WITH_BODY.on(function, abstractNode, functionDescriptor));\n            }\n            if (function.getBodyExpression() == null && !hasAbstractModifier && !inTrait && nameIdentifier != null) {\n                context.getTrace().report(NON_ABSTRACT_FUNCTION_WITH_NO_BODY.on(function, nameIdentifier, functionDescriptor));\n            }\n            return;\n        }\n        if (hasAbstractModifier) {\n                context.getTrace().report(NON_MEMBER_ABSTRACT_FUNCTION.on(function, abstractNode, functionDescriptor));\n        }\n        if (function.getBodyExpression() == null && !hasAbstractModifier && nameIdentifier != null) {\n            context.getTrace().report(NON_MEMBER_FUNCTION_NO_BODY.on(function, nameIdentifier, functionDescriptor));\n        }\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkAccessors(JetProperty property, PropertyDescriptor propertyDescriptor) {\n        for (JetPropertyAccessor accessor : property.getAccessors()) {\n            PropertyAccessorDescriptor accessorDescriptor = accessor.isGetter()\n                                                            ? propertyDescriptor.getGetter()\n                                                            : propertyDescriptor.getSetter();\n            checkFunction(accessor, accessorDescriptor);\n            checkModifiers(accessor.getModifierList());\n            if (propertyDescriptor.getModality() == Modality.FINAL && accessor.hasModifier(JetTokens.OPEN_KEYWORD)) {\n                ASTNode openModifierNode = accessor.getModifierList().getModifierNode(JetTokens.OPEN_KEYWORD);\n                context.getTrace().report(NON_FINAL_ACCESSOR_OF_FINAL_PROPERTY.on(accessor, openModifierNode, property));\n            }\n            if (propertyDescriptor.getModality() != Modality.ABSTRACT && accessor.hasModifier(JetTokens.ABSTRACT_KEYWORD)) {\n                ASTNode abstractModifierNode = accessor.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD);\n                context.getTrace().report(ABSTRACT_ACCESSOR_OF_NON_ABSTRACT_PROPERTY.on(accessor, abstractModifierNode, property));\n            }\n        }\n    }","id":74394,"modified_method":"private void checkAccessors(JetProperty property, PropertyDescriptor propertyDescriptor) {\n        for (JetPropertyAccessor accessor : property.getAccessors()) {\n            checkIllegalInThisContextModifiers(accessor.getModifierList(), Sets.newHashSet(JetTokens.ABSTRACT_KEYWORD, JetTokens.OPEN_KEYWORD, JetTokens.FINAL_KEYWORD, JetTokens.OVERRIDE_KEYWORD));\n        }\n        JetPropertyAccessor getter = property.getGetter();\n        PropertyGetterDescriptor getterDescriptor = propertyDescriptor.getGetter();\n        JetModifierList getterModifierList = getter != null ? getter.getModifierList() : null;\n        if (getterModifierList != null && getterDescriptor != null) {\n            Map<JetKeywordToken, ASTNode> nodes = getNodesCorrespondingToModifiers(getterModifierList, Sets.newHashSet(JetTokens.PUBLIC_KEYWORD, JetTokens.PROTECTED_KEYWORD, JetTokens.PRIVATE_KEYWORD, JetTokens.INTERNAL_KEYWORD));\n            if (getterDescriptor.getVisibility() != propertyDescriptor.getVisibility()) {\n                for (Map.Entry<JetKeywordToken, ASTNode> entry : nodes.entrySet()) {\n                    context.getTrace().report(Errors.GETTER_VISIBILITY_DIFFERS_FROM_PROPERTY_VISIBILITY.on(getterModifierList, entry.getValue(), entry.getKey()));\n                }\n            }\n            else {\n                for (Map.Entry<JetKeywordToken, ASTNode> entry : nodes.entrySet()) {\n                    context.getTrace().report(Errors.REDUNDANT_MODIFIER_IN_GETTER.on(getterModifierList, entry.getValue(), entry.getKey()));\n                }\n            }\n        }\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkObject(JetObjectDeclaration objectDeclaration, MutableClassDescriptor classDescriptor) {\n        checkIllegalInThisContextModifiers(objectDeclaration.getModifierList(), JetTokens.ABSTRACT_KEYWORD, JetTokens.OPEN_KEYWORD, JetTokens.OVERRIDE_KEYWORD);        \n    }","id":74395,"modified_method":"private void checkObject(JetObjectDeclaration objectDeclaration, MutableClassDescriptor classDescriptor) {\n        checkIllegalInThisContextModifiers(objectDeclaration.getModifierList(), Sets.newHashSet(JetTokens.ABSTRACT_KEYWORD, JetTokens.OPEN_KEYWORD, JetTokens.OVERRIDE_KEYWORD));\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void checkOverride(CallableMemberDescriptor declared) {\n        JetNamedDeclaration member = (JetNamedDeclaration) context.getTrace().get(BindingContext.DESCRIPTOR_TO_DECLARATION, declared);\n        if (member == null) {\n            assert context.getTrace().get(DELEGATED, declared);\n            return;\n        }\n\n        JetModifierList modifierList = member.getModifierList();\n        ASTNode overrideNode = modifierList != null ? modifierList.getModifierNode(JetTokens.OVERRIDE_KEYWORD) : null;\n        boolean hasOverrideModifier = overrideNode != null;\n\n        boolean finalOverriddenError = false;\n        boolean typeMismatchError = false;\n        boolean kindMismatchError = false;\n        for (CallableMemberDescriptor overridden : declared.getOverriddenDescriptors()) {\n            if (overridden != null) {\n                if (hasOverrideModifier) {\n                    if (!overridden.getModality().isOverridable() && !finalOverriddenError) {\n    //                    context.getTrace().getErrorHandler().genericError(overrideNode, \"Method \" + overridden.getName() + \" in \" + overridden.getContainingDeclaration().getName() + \" is final and cannot be overridden\");\n                        context.getTrace().report(OVERRIDING_FINAL_MEMBER.on(overrideNode, overridden, overridden.getContainingDeclaration()));\n                        finalOverriddenError = true;\n                    }\n\n                    if (!OverridingUtil.isReturnTypeOkForOverride(JetTypeChecker.INSTANCE, overridden, declared) && !typeMismatchError) {\n                        context.getTrace().report(RETURN_TYPE_MISMATCH_ON_OVERRIDE.on(member, declared, overridden));\n                        typeMismatchError = true;\n                    }\n\n                    if (checkPropertyKind(overridden, true) && checkPropertyKind(declared, false) && !kindMismatchError) {\n                        context.getTrace().report(VAR_OVERRIDDEN_BY_VAL.on(member, ((JetProperty) member).getValOrVarNode(), (PropertyDescriptor) declared, (PropertyDescriptor) overridden));\n                        kindMismatchError = true;\n                    }\n                }\n            }\n        }\n        if (hasOverrideModifier && declared.getOverriddenDescriptors().size() == 0) {\n//            context.getTrace().getErrorHandler().genericError(overrideNode, \"Method \" + declared.getName() + \" overrides nothing\");\n            context.getTrace().report(NOTHING_TO_OVERRIDE.on(member, overrideNode, declared));\n        }\n        PsiElement nameIdentifier = member.getNameIdentifier();\n        if (!hasOverrideModifier && declared.getOverriddenDescriptors().size() > 0 && nameIdentifier != null) {\n            CallableMemberDescriptor overridden = declared.getOverriddenDescriptors().iterator().next();\n//            context.getTrace().getErrorHandler().genericError(nameIdentifier.getNode(),\n//                                                 \"Method '\" + declared.getName() + \"' overrides method '\" + overridden.getName() + \"' in class \" +\n//                                                 overridden.getContainingDeclaration().getName() + \" and needs 'override' modifier\");\n            context.getTrace().report(VIRTUAL_MEMBER_HIDDEN.on(member, nameIdentifier, declared, overridden, overridden.getContainingDeclaration()));\n        }\n    }","id":74396,"modified_method":"private void checkOverride(CallableMemberDescriptor declared) {\n        JetNamedDeclaration member = (JetNamedDeclaration) context.getTrace().get(BindingContext.DESCRIPTOR_TO_DECLARATION, declared);\n        if (member == null) {\n            assert context.getTrace().get(DELEGATED, declared);\n            return;\n        }\n\n        JetModifierList modifierList = member.getModifierList();\n        ASTNode overrideNode = modifierList != null ? modifierList.getModifierNode(JetTokens.OVERRIDE_KEYWORD) : null;\n        boolean hasOverrideModifier = overrideNode != null;\n\n        boolean finalOverriddenError = false;\n        boolean typeMismatchError = false;\n        boolean kindMismatchError = false;\n        for (CallableMemberDescriptor overridden : declared.getOverriddenDescriptors()) {\n            if (overridden != null) {\n                if (hasOverrideModifier) {\n                    if (!overridden.getModality().isOverridable() && !finalOverriddenError) {\n    //                    context.getTrace().getErrorHandler().genericError(overrideNode, \"Method \" + overridden.getName() + \" in \" + overridden.getContainingDeclaration().getName() + \" is final and cannot be overridden\");\n                        context.getTrace().report(OVERRIDING_FINAL_MEMBER.on(overrideNode, overridden, overridden.getContainingDeclaration()));\n                        finalOverriddenError = true;\n                    }\n\n                    if (!OverridingUtil.isReturnTypeOkForOverride(JetTypeChecker.INSTANCE, overridden, declared) && !typeMismatchError) {\n                        context.getTrace().report(RETURN_TYPE_MISMATCH_ON_OVERRIDE.on(member, declared, overridden));\n                        typeMismatchError = true;\n                    }\n\n                    if (checkPropertyKind(overridden, true) && checkPropertyKind(declared, false) && !kindMismatchError) {\n                        context.getTrace().report(VAR_OVERRIDDEN_BY_VAL.on(member, ((JetProperty) member).getValOrVarNode(), (PropertyDescriptor) declared, (PropertyDescriptor) overridden));\n                        kindMismatchError = true;\n                    }\n                }\n            }\n        }\n        if (hasOverrideModifier && declared.getOverriddenDescriptors().size() == 0) {\n//            context.getTrace().getErrorHandler().genericError(overrideNode, \"Method \" + declared.getName() + \" overrides nothing\");\n            context.getTrace().report(NOTHING_TO_OVERRIDE.on(modifierList, overrideNode, declared));\n        }\n        PsiElement nameIdentifier = member.getNameIdentifier();\n        if (!hasOverrideModifier && declared.getOverriddenDescriptors().size() > 0 && nameIdentifier != null) {\n            CallableMemberDescriptor overridden = declared.getOverriddenDescriptors().iterator().next();\n//            context.getTrace().getErrorHandler().genericError(nameIdentifier.getNode(),\n//                                                 \"Method '\" + declared.getName() + \"' overrides method '\" + overridden.getName() + \"' in class \" +\n//                                                 overridden.getContainingDeclaration().getName() + \" and needs 'override' modifier\");\n            context.getTrace().report(VIRTUAL_MEMBER_HIDDEN.on(member, nameIdentifier, declared, overridden, overridden.getContainingDeclaration()));\n        }\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static JetIntentionActionFactory<JetFunctionOrPropertyAccessor> createFactory() {\n        return new JetIntentionActionFactory<JetFunctionOrPropertyAccessor>() {\n            @Override\n            public JetIntentionAction<JetFunctionOrPropertyAccessor> createAction(DiagnosticWithPsiElement diagnostic) {\n                assert diagnostic.getPsiElement() instanceof JetFunctionOrPropertyAccessor;\n                return new RemoveFunctionBodyFix((JetFunctionOrPropertyAccessor) diagnostic.getPsiElement());\n            }\n        };\n    }","id":74397,"modified_method":"public static JetIntentionActionFactory<JetFunction> createFactory() {\n        return new JetIntentionActionFactory<JetFunction>() {\n            @Override\n            public JetIntentionAction<JetFunction> createAction(DiagnosticWithPsiElement diagnostic) {\n                assert diagnostic.getPsiElement() instanceof JetFunction;\n                return new RemoveFunctionBodyFix((JetFunction) diagnostic.getPsiElement());\n            }\n        };\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        JetFunctionOrPropertyAccessor newElement = (JetFunctionOrPropertyAccessor) element.copy();\n        JetExpression bodyExpression = newElement.getBodyExpression();\n        if (bodyExpression != null) {\n            PsiElement prevSibling = bodyExpression.getPrevSibling();\n            if (prevSibling instanceof PsiWhiteSpace) {\n                ((JetElement)newElement).deleteChildInternal(prevSibling.getNode());\n            }\n            ((JetElement)newElement).deleteChildInternal(bodyExpression.getNode());\n        }\n        element.replace(newElement);\n    }","id":74398,"modified_method":"@Override\n    public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n        JetFunction function = (JetFunction) element.copy();\n        JetExpression bodyExpression = function.getBodyExpression();\n        assert bodyExpression != null;\n        if (function.hasBlockBody()) {\n            PsiElement prevElement = bodyExpression.getPrevSibling();\n            QuickFixUtil.removePossiblyWhiteSpace(function, prevElement);\n            function.deleteChildInternal(bodyExpression.getNode());\n        }\n        else {\n            PsiElement prevElement = bodyExpression.getPrevSibling();\n            PsiElement prevPrevElement = prevElement.getPrevSibling();\n            QuickFixUtil.removePossiblyWhiteSpace(function, prevElement);\n            removePossiblyEquationSign(function, prevElement);\n            removePossiblyEquationSign(function, prevPrevElement);\n            function.deleteChildInternal(bodyExpression.getNode());\n        }\n        element.replace(function);\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public RemoveFunctionBodyFix(@NotNull JetFunctionOrPropertyAccessor element) {\n        super(element);\n    }","id":74399,"modified_method":"public RemoveFunctionBodyFix(@NotNull JetFunction element) {\n        super(element);\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"static JetModifierList removeModifierFromList(@NotNull JetModifierList modifierList, JetToken modifier) {\n        assert modifierList.hasModifier(modifier);\n        ASTNode modifierNode = modifierList.getModifierNode(modifier);\n        PsiElement whiteSpace = modifierNode.getPsi().getNextSibling();\n        boolean wsRemoved = removeWhiteSpace(modifierList, whiteSpace);\n        modifierList.deleteChildInternal(modifierNode);\n        if (!wsRemoved) {\n            removeWhiteSpace(modifierList, modifierList.getLastChild());\n        }\n        return modifierList;\n    }","id":74400,"modified_method":"@NotNull\n    private static JetModifierList removeModifierFromList(@NotNull JetModifierList modifierList, JetToken modifier) {\n        assert modifierList.hasModifier(modifier);\n        ASTNode modifierNode = modifierList.getModifierNode(modifier);\n        PsiElement whiteSpace = modifierNode.getPsi().getNextSibling();\n        boolean wsRemoved = QuickFixUtil.removePossiblyWhiteSpace(modifierList, whiteSpace);\n        modifierList.deleteChildInternal(modifierNode);\n        if (!wsRemoved) {\n            QuickFixUtil.removePossiblyWhiteSpace(modifierList, modifierList.getLastChild());\n        }\n        return modifierList;\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    /*package*/ static <T extends JetModifierListOwner> T removeModifier(T element, JetToken modifier) {\n        JetModifierList modifierList = element.getModifierList();\n        assert modifierList != null;\n        removeModifierFromList(modifierList, modifier);\n        if (modifierList.getFirstChild() == null) {\n            PsiElement whiteSpace = modifierList.getNextSibling();\n            assert element instanceof JetElement;\n            ((JetElement) element).deleteChildInternal(modifierList.getNode());\n            removeWhiteSpace((JetElement) element, whiteSpace);\n        }\n        return element;\n    }","id":74401,"modified_method":"@NotNull\n    private static <T extends JetModifierListOwner> T removeModifier(T element, JetToken modifier) {\n        JetModifierList modifierList = element.getModifierList();\n        assert modifierList != null;\n        removeModifierFromList(modifierList, modifier);\n        if (modifierList.getFirstChild() == null) {\n            PsiElement whiteSpace = modifierList.getNextSibling();\n            assert element instanceof JetElement;\n            ((JetElement) element).deleteChildInternal(modifierList.getNode());\n            QuickFixUtil.removePossiblyWhiteSpace((JetElement) element, whiteSpace);\n        }\n        return element;\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    @Override\n    public String getFamilyName() {\n        return \"Remove modifier\";\n    }","id":74402,"modified_method":"private static String getFamilyName() {\n        return \"Remove modifier fix\";\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public RemoveModifierFix(@NotNull JetModifierListOwner element, JetKeywordToken modifier) {\n        super(element, modifier);\n    }","id":74403,"modified_method":"public RemoveModifierFix(JetKeywordToken modifier, boolean isRedundant) {\n        this.modifier = modifier;\n        this.isRedundant = isRedundant;\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static JetIntentionActionFactory<JetModifierListOwner> createFactory(final JetKeywordToken modifier) {\n        return new JetIntentionActionFactory<JetModifierListOwner>() {\n            @Override\n            public JetIntentionAction<JetModifierListOwner> createAction(DiagnosticWithPsiElement diagnostic) {\n                assert diagnostic.getPsiElement() instanceof JetModifierListOwner;\n                return new RemoveModifierFix((JetModifierListOwner) diagnostic.getPsiElement(), modifier);\n            }\n        };\n    }","id":74404,"modified_method":"public static JetIntentionActionFactory<JetModifierList> createRemoveModifierFromListFactory(final JetKeywordToken modifier) {\n        return createRemoveModifierFromListFactory(modifier, false);\n    }","commit_id":"50418698dbc8ddd484d35b03f5a7054df2b38bdd","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private Set<VariableDescriptor> resolveNamedGroupProperties(\n            @NotNull ClassOrNamespaceDescriptor owner,\n            @NotNull ResolverScopeData scopeData,\n            @NotNull NamedMembers namedMembers,\n            @NotNull Name propertyName,\n            @NotNull String context\n    ) {\n        Map<String, PropertyPsiData> map = PropertyPsiData.collectGroupingValuesFromAccessors(namedMembers.getPropertyPsiDataElements());\n\n        Set<PropertyDescriptor> propertiesFromCurrent = new HashSet<PropertyDescriptor>(1);\n\n        int regularPropertiesCount = getNumberOfNonExtensionProperties(map);\n\n        for (PropertyPsiData members : map.values()) {\n\n            // we cannot have more then one property with given name even if java code\n            // has several fields, getters and setter of different types\n            if (!members.isExtension() && regularPropertiesCount > 1) {\n                continue;\n            }\n\n            boolean isFinal = isPropertyFinal(scopeData, members);\n            boolean isVar = members.isVar();\n\n            PropertyPsiDataElement characteristicMember = members.getCharacteristicMember();\n\n            Visibility visibility = DescriptorResolverUtils.resolveVisibility(characteristicMember.getMember().getPsiMember(), null);\n            CallableMemberDescriptor.Kind kind = CallableMemberDescriptor.Kind.DECLARATION;\n\n            if (members.getGetter() != null && members.getGetter().getMember() instanceof PsiMethodWrapper) {\n                JetMethodAnnotation jetMethod = ((PsiMethodWrapper) members.getGetter().getMember()).getJetMethod();\n                visibility = DescriptorResolverUtils.resolveVisibility(characteristicMember.getMember().getPsiMember(), jetMethod);\n                kind = DescriptorKindUtils.flagsToKind(jetMethod.kind());\n            }\n\n            DeclarationDescriptor realOwner = getRealOwner(owner, scopeData, characteristicMember.getMember().isStatic());\n            boolean isEnumEntry = DescriptorUtils.isEnumClassObject(realOwner);\n            boolean isPropertyForNamedObject = members.getField() != null && JvmAbi.INSTANCE_FIELD.equals(members.getField().getMember().getName());\n            PropertyDescriptor propertyDescriptor = new PropertyDescriptor(\n                    realOwner,\n                    annotationResolver.resolveAnnotations(characteristicMember.getMember().getPsiMember()),\n                    DescriptorResolverUtils\n                            .resolveModality(characteristicMember.getMember(), isFinal || isEnumEntry || isPropertyForNamedObject),\n                    visibility,\n                    isVar,\n                    propertyName,\n                    kind);\n\n            //TODO: this is a hack to indicate that this enum entry is an object\n            // class descriptor for enum entries is not used by backends so for now this should be safe to use\n            // remove this when JavaDescriptorResolver gets rewritten\n            if (isEnumEntry) {\n                ClassDescriptorImpl dummyClassDescriptorForEnumEntryObject =\n                        new ClassDescriptorImpl(realOwner, Collections.<AnnotationDescriptor>emptyList(), Modality.FINAL, propertyName);\n                dummyClassDescriptorForEnumEntryObject.initialize(\n                        true,\n                        Collections.<TypeParameterDescriptor>emptyList(),\n                        Collections.<JetType>emptyList(), JetScope.EMPTY,\n                        Collections.<ConstructorDescriptor>emptySet(), null);\n                trace.record(BindingContext.OBJECT_DECLARATION_CLASS, propertyDescriptor, dummyClassDescriptorForEnumEntryObject);\n            }\n\n            PropertyGetterDescriptor getterDescriptor = null;\n            PropertySetterDescriptor setterDescriptor = null;\n\n            if (members.getGetter() != null) {\n                getterDescriptor = new PropertyGetterDescriptor(\n                        propertyDescriptor,\n                        annotationResolver.resolveAnnotations(members.getGetter().getMember().getPsiMember()),\n                        Modality.OPEN,\n                        visibility,\n                        true,\n                        false,\n                        kind);\n            }\n\n            if (members.getSetter() != null) {\n                Visibility setterVisibility = DescriptorResolverUtils.resolveVisibility(members.getSetter().getMember().getPsiMember(), null);\n                if (members.getSetter().getMember() instanceof PsiMethodWrapper) {\n                    setterVisibility = DescriptorResolverUtils.resolveVisibility(\n                            members.getSetter().getMember().getPsiMember(),\n                            ((PsiMethodWrapper) members.getSetter().getMember())\n                                    .getJetMethod());\n                }\n                setterDescriptor = new PropertySetterDescriptor(\n                        propertyDescriptor,\n                        annotationResolver.resolveAnnotations(members.getSetter().getMember().getPsiMember()),\n                        Modality.OPEN,\n                        setterVisibility,\n                        true,\n                        false,\n                        kind);\n            }\n\n            propertyDescriptor.initialize(getterDescriptor, setterDescriptor);\n\n            List<TypeParameterDescriptor> typeParameters = resolvePropertyTypeParameters(members, characteristicMember, propertyDescriptor);\n\n            TypeVariableResolver typeVariableResolverForPropertyInternals = TypeVariableResolvers.typeVariableResolverFromTypeParameters(\n                    typeParameters, propertyDescriptor, \"property \" + propertyName + \" in \" + context);\n\n            JetType propertyType = getPropertyType(members, characteristicMember, typeVariableResolverForPropertyInternals);\n            JetType receiverType = getReceiverType(characteristicMember, typeVariableResolverForPropertyInternals);\n\n\n            if (characteristicMember.isField()) {\n                AlternativeFieldSignatureData signatureData =\n                        new AlternativeFieldSignatureData((PsiFieldWrapper) characteristicMember.getMember(), propertyType, isVar);\n                if (!signatureData.hasErrors()) {\n                    if (signatureData.isAnnotated()) {\n                        propertyType = signatureData.getReturnType();\n                    }\n                }\n                else {\n                    trace.record(BindingContext.ALTERNATIVE_SIGNATURE_DATA_ERROR, propertyDescriptor, signatureData.getError());\n                }\n            }\n\n            propertyDescriptor.setType(\n                    propertyType,\n                    typeParameters,\n                    DescriptorUtils.getExpectedThisObjectIfNeeded(realOwner),\n                    receiverType\n            );\n            if (getterDescriptor != null) {\n                getterDescriptor.initialize(propertyType);\n            }\n            if (setterDescriptor != null) {\n                setterDescriptor.initialize(new ValueParameterDescriptorImpl(\n                        setterDescriptor,\n                        0,\n                        Collections.<AnnotationDescriptor>emptyList(),\n                        Name.identifier(\"p0\") /*TODO*/,\n                        false,\n                        propertyDescriptor.getType(),\n                        false,\n                        null));\n            }\n\n            if (kind == CallableMemberDescriptor.Kind.DECLARATION) {\n                trace.record(BindingContext.VARIABLE, characteristicMember.getMember().getPsiMember(), propertyDescriptor);\n            }\n\n            if (isPropertyForNamedObject) {\n                ClassDescriptor objectDescriptor = (ClassDescriptor) propertyType.getConstructor().getDeclarationDescriptor();\n\n                assert objectDescriptor.getKind() == ClassKind.OBJECT;\n                assert objectDescriptor.getContainingDeclaration() == realOwner;\n\n                trace.record(BindingContext.OBJECT_DECLARATION_CLASS, propertyDescriptor, objectDescriptor);\n            }\n\n            if (!scopeData.isKotlin()) {\n                trace.record(BindingContext.IS_DECLARED_IN_JAVA, propertyDescriptor);\n            }\n\n            propertiesFromCurrent.add(propertyDescriptor);\n        }\n\n        Set<PropertyDescriptor> propertiesFromSupertypes = getPropertiesFromSupertypes(scopeData, propertyName);\n\n        final Set<PropertyDescriptor> properties = Sets.newHashSet();\n\n        if (owner instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) owner;\n\n            OverrideResolver.generateOverridesInFunctionGroup(\n                    propertyName, propertiesFromSupertypes, propertiesFromCurrent, classDescriptor,\n                    new OverrideResolver.DescriptorSink() {\n                        @Override\n                        public void addToScope(@NotNull CallableMemberDescriptor fakeOverride) {\n                            properties.add((PropertyDescriptor) fakeOverride);\n                        }\n\n                        @Override\n                        public void conflict(\n                                @NotNull CallableMemberDescriptor fromSuper,\n                                @NotNull CallableMemberDescriptor fromCurrent\n                        ) {\n                            // nop\n                        }\n                    });\n        }\n\n        OverrideResolver.resolveUnknownVisibilities(properties, trace);\n        properties.addAll(propertiesFromCurrent);\n\n        return Sets.<VariableDescriptor>newHashSet(properties);\n    }","id":74405,"modified_method":"@NotNull\n    private Set<VariableDescriptor> resolveNamedGroupProperties(\n            @NotNull ClassOrNamespaceDescriptor owner,\n            @NotNull ResolverScopeData scopeData,\n            @NotNull NamedMembers namedMembers,\n            @NotNull Name propertyName,\n            @NotNull String context\n    ) {\n        Collection<PropertyPsiData> psiDataCollection = PropertyPsiData.collectGroupingValuesFromAccessors(namedMembers.getPropertyPsiDataElements());\n\n        Set<PropertyDescriptor> propertiesFromCurrent = new HashSet<PropertyDescriptor>(1);\n\n        int regularPropertiesCount = getNumberOfNonExtensionProperties(psiDataCollection);\n\n        for (PropertyPsiData members : psiDataCollection) {\n\n            // we cannot have more then one property with given name even if java code\n            // has several fields, getters and setter of different types\n            if (!members.isExtension() && regularPropertiesCount > 1) {\n                continue;\n            }\n\n            boolean isFinal = isPropertyFinal(scopeData, members);\n            boolean isVar = members.isVar();\n\n            PropertyPsiDataElement characteristicMember = members.getCharacteristicMember();\n\n            Visibility visibility = DescriptorResolverUtils.resolveVisibility(members.getCharacteristicPsi(), null);\n            CallableMemberDescriptor.Kind kind = CallableMemberDescriptor.Kind.DECLARATION;\n\n            PropertyPsiDataElement getter = members.getGetter();\n            if (getter != null) {\n                JetMethodAnnotation jetMethod = ((PsiMethodWrapper) getter.getMember()).getJetMethod();\n                visibility = DescriptorResolverUtils.resolveVisibility(members.getCharacteristicPsi(), jetMethod);\n                kind = DescriptorKindUtils.flagsToKind(jetMethod.kind());\n            }\n\n            DeclarationDescriptor realOwner = getRealOwner(owner, scopeData, members.isStatic());\n            boolean isEnumEntry = DescriptorUtils.isEnumClassObject(realOwner);\n            boolean isPropertyForNamedObject = members.getField() != null && JvmAbi.INSTANCE_FIELD.equals(members.getField().getMember().getName());\n            PropertyDescriptor propertyDescriptor = new PropertyDescriptor(\n                    realOwner,\n                    annotationResolver.resolveAnnotations(characteristicMember.getMember().getPsiMember()),\n                    DescriptorResolverUtils\n                            .resolveModality(characteristicMember.getMember(), isFinal || isEnumEntry || isPropertyForNamedObject),\n                    visibility,\n                    isVar,\n                    propertyName,\n                    kind);\n\n            //TODO: this is a hack to indicate that this enum entry is an object\n            // class descriptor for enum entries is not used by backends so for now this should be safe to use\n            // remove this when JavaDescriptorResolver gets rewritten\n            if (isEnumEntry) {\n                ClassDescriptorImpl dummyClassDescriptorForEnumEntryObject =\n                        new ClassDescriptorImpl(realOwner, Collections.<AnnotationDescriptor>emptyList(), Modality.FINAL, propertyName);\n                dummyClassDescriptorForEnumEntryObject.initialize(\n                        true,\n                        Collections.<TypeParameterDescriptor>emptyList(),\n                        Collections.<JetType>emptyList(), JetScope.EMPTY,\n                        Collections.<ConstructorDescriptor>emptySet(), null);\n                trace.record(BindingContext.OBJECT_DECLARATION_CLASS, propertyDescriptor, dummyClassDescriptorForEnumEntryObject);\n            }\n\n            PropertyGetterDescriptor getterDescriptor = null;\n            PropertySetterDescriptor setterDescriptor = null;\n\n            if (getter != null) {\n                getterDescriptor = new PropertyGetterDescriptor(\n                        propertyDescriptor,\n                        annotationResolver.resolveAnnotations(getter.getMember().getPsiMember()),\n                        Modality.OPEN,\n                        visibility,\n                        true,\n                        false,\n                        kind);\n            }\n\n            PropertyPsiDataElement setter = members.getSetter();\n            if (setter != null) {\n                Visibility setterVisibility = DescriptorResolverUtils.resolveVisibility(setter.getMember().getPsiMember(), null);\n                if (setter.getMember() instanceof PsiMethodWrapper) {\n                    setterVisibility = DescriptorResolverUtils.resolveVisibility(\n                            setter.getMember().getPsiMember(),\n                            ((PsiMethodWrapper) setter.getMember())\n                                    .getJetMethod());\n                }\n                setterDescriptor = new PropertySetterDescriptor(\n                        propertyDescriptor,\n                        annotationResolver.resolveAnnotations(setter.getMember().getPsiMember()),\n                        Modality.OPEN,\n                        setterVisibility,\n                        true,\n                        false,\n                        kind);\n            }\n\n            propertyDescriptor.initialize(getterDescriptor, setterDescriptor);\n\n            List<TypeParameterDescriptor> typeParameters = resolvePropertyTypeParameters(members, characteristicMember, propertyDescriptor);\n\n            TypeVariableResolver typeVariableResolverForPropertyInternals = TypeVariableResolvers.typeVariableResolverFromTypeParameters(\n                    typeParameters, propertyDescriptor, \"property \" + propertyName + \" in \" + context);\n\n            JetType propertyType = getPropertyType(members, characteristicMember, typeVariableResolverForPropertyInternals);\n            JetType receiverType = getReceiverType(characteristicMember, typeVariableResolverForPropertyInternals);\n\n\n            if (characteristicMember.isField()) {\n                AlternativeFieldSignatureData signatureData =\n                        new AlternativeFieldSignatureData((PsiFieldWrapper) characteristicMember.getMember(), propertyType, isVar);\n                if (!signatureData.hasErrors()) {\n                    if (signatureData.isAnnotated()) {\n                        propertyType = signatureData.getReturnType();\n                    }\n                }\n                else {\n                    trace.record(BindingContext.ALTERNATIVE_SIGNATURE_DATA_ERROR, propertyDescriptor, signatureData.getError());\n                }\n            }\n\n            propertyDescriptor.setType(\n                    propertyType,\n                    typeParameters,\n                    DescriptorUtils.getExpectedThisObjectIfNeeded(realOwner),\n                    receiverType\n            );\n            if (getterDescriptor != null) {\n                getterDescriptor.initialize(propertyType);\n            }\n            if (setterDescriptor != null) {\n                setterDescriptor.initialize(new ValueParameterDescriptorImpl(\n                        setterDescriptor,\n                        0,\n                        Collections.<AnnotationDescriptor>emptyList(),\n                        Name.identifier(\"p0\") /*TODO*/,\n                        false,\n                        propertyDescriptor.getType(),\n                        false,\n                        null));\n            }\n\n            if (kind == CallableMemberDescriptor.Kind.DECLARATION) {\n                trace.record(BindingContext.VARIABLE, characteristicMember.getMember().getPsiMember(), propertyDescriptor);\n            }\n\n            if (isPropertyForNamedObject) {\n                ClassDescriptor objectDescriptor = (ClassDescriptor) propertyType.getConstructor().getDeclarationDescriptor();\n\n                assert objectDescriptor.getKind() == ClassKind.OBJECT;\n                assert objectDescriptor.getContainingDeclaration() == realOwner;\n\n                trace.record(BindingContext.OBJECT_DECLARATION_CLASS, propertyDescriptor, objectDescriptor);\n            }\n\n            if (!scopeData.isKotlin()) {\n                trace.record(BindingContext.IS_DECLARED_IN_JAVA, propertyDescriptor);\n            }\n\n            propertiesFromCurrent.add(propertyDescriptor);\n        }\n\n        Set<PropertyDescriptor> propertiesFromSupertypes = getPropertiesFromSupertypes(scopeData, propertyName);\n\n        final Set<PropertyDescriptor> properties = Sets.newHashSet();\n\n        if (owner instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) owner;\n\n            OverrideResolver.generateOverridesInFunctionGroup(\n                    propertyName, propertiesFromSupertypes, propertiesFromCurrent, classDescriptor,\n                    new OverrideResolver.DescriptorSink() {\n                        @Override\n                        public void addToScope(@NotNull CallableMemberDescriptor fakeOverride) {\n                            properties.add((PropertyDescriptor) fakeOverride);\n                        }\n\n                        @Override\n                        public void conflict(\n                                @NotNull CallableMemberDescriptor fromSuper,\n                                @NotNull CallableMemberDescriptor fromCurrent\n                        ) {\n                            // nop\n                        }\n                    });\n        }\n\n        OverrideResolver.resolveUnknownVisibilities(properties, trace);\n        properties.addAll(propertiesFromCurrent);\n\n        return Sets.<VariableDescriptor>newHashSet(properties);\n    }","commit_id":"fca3cbb619785c93826ac4511340956f521b004d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Nullable\n    private JetType getReceiverType(\n            PropertyPsiDataElement characteristicMember,\n            TypeVariableResolver typeVariableResolverForPropertyInternals\n    ) {\n        JetType receiverType;\n        if (characteristicMember.getReceiverType() == null) {\n            receiverType = null;\n        }\n        else if (characteristicMember.getReceiverType().getTypeString().length() > 0) {\n            receiverType = semanticServices.getTypeTransformer().transformToType(characteristicMember.getReceiverType().getTypeString(), typeVariableResolverForPropertyInternals);\n        }\n        else {\n            receiverType = semanticServices.getTypeTransformer().transformToType(characteristicMember.getReceiverType().getPsiType(), typeVariableResolverForPropertyInternals);\n        }\n        return receiverType;\n    }","id":74406,"modified_method":"private static int getNumberOfNonExtensionProperties(@NotNull Collection<PropertyPsiData> propertyPsiDataCollection) {\n        int regularPropertiesCount = 0;\n        for (PropertyPsiData members : propertyPsiDataCollection) {\n            if (!members.isExtension()) {\n                ++regularPropertiesCount;\n            }\n        }\n        return regularPropertiesCount;\n    }","commit_id":"fca3cbb619785c93826ac4511340956f521b004d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean isExtension() {\n        return isExtension;\n    }","id":74407,"modified_method":"public boolean isExtension() {\n        boolean isExtension = getCharacteristicMember().isExtension();\n        for (PropertyPsiDataElement element : getElements()) {\n            assert (element.isExtension() == isExtension);\n        }\n        return isExtension;\n    }","commit_id":"fca3cbb619785c93826ac4511340956f521b004d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static Map<String, PropertyPsiData> collectGroupingValuesFromAccessors(List<PropertyPsiDataElement> propertyAccessors) {\n        Map<String, PropertyPsiData> map = new HashMap<String, PropertyPsiData>();\n        for (PropertyPsiDataElement propertyAccessor : propertyAccessors) {\n            String key = propertyKeyForGrouping(propertyAccessor);\n\n            PropertyPsiData value = map.get(key);\n            if (value == null) {\n                value = new PropertyPsiData();\n                value.isExtension = propertyAccessor.getReceiverType() != null;\n                map.put(key, value);\n            }\n\n            if (value.isExtension && (propertyAccessor.getReceiverType() == null)) {\n                throw new IllegalStateException(\"internal error, incorrect key\");\n            }\n\n            if (propertyAccessor.isGetter()) {\n                if (value.getter != null) {\n                    throw new IllegalStateException(\"oops, duplicate key\");\n                }\n                value.getter = propertyAccessor;\n            }\n            else if (propertyAccessor.isSetter()) {\n                if (value.setter != null) {\n                    throw new IllegalStateException(\"oops, duplicate key\");\n                }\n                value.setter = propertyAccessor;\n            }\n            else if (propertyAccessor.isField()) {\n                if (value.field != null) {\n                    throw new IllegalStateException(\"oops, duplicate key\");\n                }\n                value.field = propertyAccessor;\n            }\n            else {\n                throw new IllegalStateException();\n            }\n        }\n\n        return map;\n    }","id":74408,"modified_method":"@NotNull\n    public static Collection<PropertyPsiData> collectGroupingValuesFromAccessors(@NotNull List<PropertyPsiDataElement> elements) {\n        Map<String, PropertyPsiData> map = new HashMap<String, PropertyPsiData>();\n        for (PropertyPsiDataElement element : elements) {\n            String key = propertyKeyForGrouping(element);\n\n            PropertyPsiData value = map.get(key);\n            if (value == null) {\n                value = new PropertyPsiData();\n                map.put(key, value);\n            }\n\n            if (element.isGetter()) {\n                if (value.getter != null) {\n                    throw new IllegalStateException(\"oops, duplicate key\");\n                }\n                value.getter = element;\n            }\n            else if (element.isSetter()) {\n                if (value.setter != null) {\n                    throw new IllegalStateException(\"oops, duplicate key\");\n                }\n                value.setter = element;\n            }\n            else if (element.isField()) {\n                if (value.field != null) {\n                    throw new IllegalStateException(\"oops, duplicate key\");\n                }\n                value.field = element;\n            }\n            else {\n                throw new IllegalStateException();\n            }\n        }\n\n        return map.values();\n    }","commit_id":"fca3cbb619785c93826ac4511340956f521b004d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public boolean isVar() {\n        if (getter == null && setter == null) {\n            return !field.getMember().isFinal();\n        }\n        return setter != null;\n    }","id":74409,"modified_method":"public boolean isVar() {\n        if (getter == null && setter == null) {\n            assert field != null;\n            return !field.getMember().isFinal();\n        }\n        return setter != null;\n    }","commit_id":"fca3cbb619785c93826ac4511340956f521b004d","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public AbstractConfigurableProperty( Class definingClass, String entrySetName, String propertyName, String defaultValue, String description, PropertyTypeParser typeParser, Boolean readOnly, String displayName, String widgetType ) {\n    this.definingClass = definingClass;\n    this.entrySetName = entrySetName.toLowerCase( );\n    this.fieldName = propertyName.toLowerCase( );\n    this.qualifiedName = this.entrySetName + \".\" + this.fieldName;\n    this.description = description;\n    this.typeParser = typeParser;\n    this.defaultValue = defaultValue;\n    this.readOnly = readOnly;\n    this.displayName = displayName;\n    this.widgetType = widgetType;\n  }","id":74410,"modified_method":"public AbstractConfigurableProperty( Class definingClass, String entrySetName, String propertyName, String defaultValue, String description, PropertyTypeParser typeParser, Boolean readOnly, String displayName, ConfigurableFieldType widgetType, String alias ) {\n    this.definingClass = definingClass;\n    this.entrySetName = entrySetName.toLowerCase( );\n    this.fieldName = propertyName.toLowerCase( );\n    this.qualifiedName = this.entrySetName + \".\" + this.fieldName;\n    this.description = description;\n    this.typeParser = typeParser;\n    this.defaultValue = defaultValue;\n    this.readOnly = readOnly;\n    this.displayName = displayName;\n    this.widgetType = widgetType;\n    this.alias = alias;\n    this.changeListener = NoopEventListener.NOOP;\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public String getWidgetType( ) {\n\t  return this.widgetType;\n  }","id":74411,"modified_method":"public ConfigurableFieldType getWidgetType( ) {\n\treturn this.widgetType;\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private void transferSnapshot(String sizeAsString) {\n\t\t\tlong size = Long.parseLong(sizeAsString);\n\n\t\t\tFile snapshotFile = new File(snapshotFileName);\n\t\t\tassert(snapshotFile.exists());\n\t\t\tSnapshotProgressCallback callback = new SnapshotProgressCallback(snapshotId, size, StorageProperties.TRANSFER_CHUNK_SIZE);\n\t\t\tMap<String, String> httpParamaters = new HashMap<String, String>();\n\t\t\tHttpWriter httpWriter;\n\t\t\thttpWriter = new HttpWriter(\"PUT\", snapshotFile, sizeAsString, callback, volumeBucket, snapshotId, \"StoreSnapshot\", null, httpParamaters);\n\t\t\ttry {\n\t\t\t\thttpWriter.run();\n\t\t\t} catch(Exception ex) {\n\t\t\t\tLOG.error(ex, ex);\n\t\t\t\tchecker.cleanFailedSnapshot(snapshotId);\n\t\t\t}\n\t\t}","id":74412,"modified_method":"private void transferSnapshot(String sizeAsString) throws EucalyptusCloudException {\n\t\t\tlong size = Long.parseLong(sizeAsString);\n\n\t\t\tFile snapshotFile = new File(snapshotFileName);\n\t\t\tassert(snapshotFile.exists());\n\t\t\t//do a little test to check if we can read from it\n\t\t\tFileInputStream snapInStream = null;\n\t\t\ttry {\n\t\t\t\tsnapInStream = new FileInputStream(snapshotFile);\n\t\t\t\tbyte[] bytes = new byte[1024];\n\t\t\t\tif(snapInStream.read(bytes) <= 0) {\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to read snapshot file\");\n\t\t\t\t}\t\t\t\t\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new EucalyptusCloudException(e);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new EucalyptusCloudException(e);\n\t\t\t} finally {\n\t\t\t\tif(snapInStream != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsnapInStream.close();\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tthrow new EucalyptusCloudException(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSnapshotProgressCallback callback = new SnapshotProgressCallback(snapshotId, size, StorageProperties.TRANSFER_CHUNK_SIZE);\n\t\t\tMap<String, String> httpParamaters = new HashMap<String, String>();\n\t\t\tHttpWriter httpWriter;\n\t\t\thttpWriter = new HttpWriter(\"PUT\", snapshotFile, sizeAsString, callback, volumeBucket, snapshotId, \"StoreSnapshot\", null, httpParamaters);\n\t\t\ttry {\n\t\t\t\thttpWriter.run();\n\t\t\t} catch(Exception ex) {\n\t\t\t\tLOG.error(ex, ex);\n\t\t\t\tchecker.cleanFailedSnapshot(snapshotId);\n\t\t\t}\n\t\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public UpdateStorageConfigurationResponseType UpdateStorageConfiguration(UpdateStorageConfigurationType request) throws EucalyptusCloudException {\n\t\tUpdateStorageConfigurationResponseType reply = (UpdateStorageConfigurationResponseType) request.getReply();\n\t\tif(Component.eucalyptus.name( ).equals(request.getEffectiveUserId()))\n\t\t\tthrow new AccessDeniedException(\"Only admin can change walrus properties.\");\n\t\t//test connection to Walrus\n\t\tStorageProperties.updateWalrusUrl();\n\t\ttry {\n\t\t\tblockManager.checkPreconditions();\n\t\t\tStorageProperties.enableStorage = true;\n\t\t} catch (Exception ex) {\n\t\t\tStorageProperties.enableStorage = false;\n\t\t\tLOG.error(ex);\n\t\t}\n\t\tif(request.getStorageParams() != null) {\n\t\t\tfor(ComponentProperty param : request.getStorageParams()) {\n\t\t\t\tLOG.info(\"Storage Param: \" + param.getDisplayName() + \" Qname: \" + param.getQualifiedName() + \" Value: \" + param.getValue());\n\t\t\t}\n\t\t\tblockManager.setStorageProps(request.getStorageParams());\n\t\t}\n\t\treturn reply;\n\t}","id":74413,"modified_method":"public UpdateStorageConfigurationResponseType UpdateStorageConfiguration(UpdateStorageConfigurationType request) throws EucalyptusCloudException {\n\t\tUpdateStorageConfigurationResponseType reply = (UpdateStorageConfigurationResponseType) request.getReply();\n\t\tif(Component.eucalyptus.name( ).equals(request.getEffectiveUserId()))\n\t\t\tthrow new AccessDeniedException(\"Only admin can change walrus properties.\");\n\t\t//test connection to Walrus\n\t\tStorageProperties.updateWalrusUrl();\n\t\ttry {\n\t\t\tblockManager.checkPreconditions();\n\t\t\tStorageProperties.enableStorage = true;\n\t\t} catch (Exception ex) {\n\t\t\tStorageProperties.enableStorage = false;\n\t\t\tLOG.error(ex);\n\t\t}\n\t\tif(request.getStorageParams() != null) {\n\t\t\tfor(ComponentProperty param : request.getStorageParams()) {\n\t\t\t\tLOG.debug(\"Storage Param: \" + param.getDisplayName() + \" Qname: \" + param.getQualifiedName() + \" Value: \" + param.getValue());\n\t\t\t}\n\t\t\tblockManager.setStorageProps(request.getStorageParams());\n\t\t}\n\t\treturn reply;\n\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n\t\tDeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo();\n\t\tvolumeInfo.setVolumeId(volumeId);\n\t\tList<VolumeInfo> volumeList = db.query(volumeInfo);\n\n\t\treply.set_return(Boolean.FALSE);\n\t\tif(volumeList.size() > 0) {\n\t\t\tVolumeInfo foundVolume = volumeList.get(0);\n\t\t\t//check its status\n\t\t\tString status = foundVolume.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\tVolumeDeleter volumeDeleter = new VolumeDeleter(volumeId);\n\t\t\t\tvolumeService.add(volumeDeleter);\n\t\t\t\treply.set_return(Boolean.TRUE);\n\t\t\t}\n\t\t} \n\t\tdb.commit();\n\t\treturn reply;\n\t}","id":74414,"modified_method":"public DeleteStorageVolumeResponseType DeleteStorageVolume(DeleteStorageVolumeType request) throws EucalyptusCloudException {\n\t\tDeleteStorageVolumeResponseType reply = (DeleteStorageVolumeResponseType) request.getReply();\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo();\n\t\tvolumeInfo.setVolumeId(volumeId);\n\t\tList<VolumeInfo> volumeList = db.query(volumeInfo);\n\n\t\t//always return true. \n\t\treply.set_return(Boolean.TRUE);\n\t\tif(volumeList.size() > 0) {\n\t\t\tVolumeInfo foundVolume = volumeList.get(0);\n\t\t\t//check its status\n\t\t\tString status = foundVolume.getStatus();\n\t\t\tif(status.equals(StorageProperties.Status.available.toString()) || status.equals(StorageProperties.Status.failed.toString())) {\n\t\t\t\tVolumeDeleter volumeDeleter = new VolumeDeleter(volumeId);\n\t\t\t\tvolumeService.add(volumeDeleter);\n\t\t\t} \n\t\t} \n\t\tdb.commit();\n\t\treturn reply;\n\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tblockManager.deleteVolume(volumeId);\n\t\t\t} catch (EucalyptusCloudException e1) {\n\t\t\t\tLOG.error(e1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\t\tVolumeInfo foundVolume;\n\t\t\ttry {\n\t\t\t\tfoundVolume = db.getUnique(new VolumeInfo(volumeId));\n\t\t\t\tdb.delete(foundVolume);\n\t\t\t\tdb.commit();\n\t\t\t\tEucaSemaphoreDirectory.removeSemaphore(volumeId);\n\t\t\t\tif(StorageProperties.trackUsageStatistics) { \n\t\t\t\t\tblockStorageStatistics.decrementVolumeCount();\n\t\t\t\t\tblockStorageStatistics.updateSpaceUsed(-(foundVolume.getSize() * StorageProperties.GB));\n\t\t\t\t}\n\t\t\t} catch (EucalyptusCloudException e) {\n\t\t\t\tdb.rollback();\n\t\t\t\tLOG.error(e);\t\n\t\t\t}\n\t\t}","id":74415,"modified_method":"@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tblockManager.deleteVolume(volumeId);\n\t\t\t} catch (EucalyptusCloudException e1) {\n\t\t\t\tLOG.error(e1);\n\t\t\t}\n\t\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\t\tVolumeInfo foundVolume;\n\t\t\ttry {\n\t\t\t\tfoundVolume = db.getUnique(new VolumeInfo(volumeId));\n\t\t\t\tdb.delete(foundVolume);\n\t\t\t\tdb.commit();\n\t\t\t\tEucaSemaphoreDirectory.removeSemaphore(volumeId);\n\t\t\t\tif(StorageProperties.trackUsageStatistics) { \n\t\t\t\t\tblockStorageStatistics.decrementVolumeCount(-(foundVolume.getSize() * StorageProperties.GB));\n\t\t\t\t}\n\t\t\t} catch (EucalyptusCloudException e) {\n\t\t\t\tdb.rollback();\n\t\t\t}\n\t\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateStorageSnapshotResponseType CreateStorageSnapshot( CreateStorageSnapshotType request ) throws EucalyptusCloudException {\n\t\tCreateStorageSnapshotResponseType reply = ( CreateStorageSnapshotResponseType ) request.getReply();\n\n\t\tStorageProperties.updateWalrusUrl();\n\t\tif(!StorageProperties.enableSnapshots) {\n\t\t\tLOG.error(\"Snapshots have been disabled. Please check connection to Walrus.\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\t\tString snapshotId = request.getSnapshotId();\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\tList<VolumeInfo> volumeInfos = db.query(volumeInfo);\n\n\t\tif(volumeInfos.size() > 0) {\n\t\t\tVolumeInfo foundVolumeInfo = volumeInfos.get(0);\n\t\t\t//check status\n\t\t\tif(foundVolumeInfo.getStatus().equals(StorageProperties.Status.available.toString())) {\n\t\t\t\t//create snapshot\n\t\t\t\tif(StorageProperties.shouldEnforceUsageLimits) {\n\t\t\t\t\tint volSize = foundVolumeInfo.getSize();\n\t\t\t\t\tint totalSnapshotSize = 0;\n\t\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo();\n\t\t\t\t\tEntityWrapper<SnapshotInfo> dbSnap = db.recast(SnapshotInfo.class);\n\n\t\t\t\t\tList<SnapshotInfo> snapInfos = dbSnap.query(snapInfo);\n\t\t\t\t\tfor (SnapshotInfo sInfo : snapInfos) {\n\t\t\t\t\t\ttotalSnapshotSize += blockManager.getSnapshotSize(sInfo.getSnapshotId());\n\t\t\t\t\t}\n\t\t\t\t\tif((totalSnapshotSize + volSize) > WalrusInfo.getWalrusInfo().getStorageMaxTotalSnapshotSizeInGb()) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new EntityTooLargeException(snapshotId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEntityWrapper<SnapshotInfo> db2 = StorageProperties.getEntityWrapper();\n\t\t\t\tedu.ucsb.eucalyptus.cloud.entities.SnapshotInfo snapshotInfo = new edu.ucsb.eucalyptus.cloud.entities.SnapshotInfo(snapshotId);\n\t\t\t\tsnapshotInfo.setUserName(foundVolumeInfo.getUserName());\n\t\t\t\tsnapshotInfo.setVolumeId(volumeId);\n\t\t\t\tDate startTime = new Date();\n\t\t\t\tsnapshotInfo.setStartTime(startTime);\n\t\t\t\tsnapshotInfo.setProgress(\"0\");\n\t\t\t\tsnapshotInfo.setStatus(StorageProperties.Status.creating.toString());\n\t\t\t\tdb2.add(snapshotInfo);\n\t\t\t\t//snapshot asynchronously\n\t\t\t\tString snapshotSet = \"snapset-\" + UUID.randomUUID();\n\n\t\t\t\tSnapshotter snapshotter = new Snapshotter(snapshotSet, volumeId, snapshotId);\n\t\t\t\tsnapshotService.add(snapshotter);\n\t\t\t\tdb2.commit();\n\t\t\t\tdb.commit();\n\t\t\t\treply.setSnapshotId(snapshotId);\n\t\t\t\treply.setVolumeId(volumeId);\n\t\t\t\treply.setStatus(snapshotInfo.getStatus());\n\t\t\t\treply.setStartTime(DateUtils.format(startTime.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\treply.setProgress(snapshotInfo.getProgress());\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new VolumeNotReadyException(volumeId);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchVolumeException(volumeId);\n\t\t}\n\t\treturn reply;\n\t}","id":74416,"modified_method":"public CreateStorageSnapshotResponseType CreateStorageSnapshot( CreateStorageSnapshotType request ) throws EucalyptusCloudException {\n\t\tCreateStorageSnapshotResponseType reply = ( CreateStorageSnapshotResponseType ) request.getReply();\n\n\t\tStorageProperties.updateWalrusUrl();\n\t\tif(!StorageProperties.enableSnapshots) {\n\t\t\tLOG.error(\"Snapshots have been disabled. Please check connection to Walrus.\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString volumeId = request.getVolumeId();\n\t\tString snapshotId = request.getSnapshotId();\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\tList<VolumeInfo> volumeInfos = db.query(volumeInfo);\n\n\t\tif(volumeInfos.size() > 0) {\n\t\t\tVolumeInfo foundVolumeInfo = volumeInfos.get(0);\n\t\t\t//check status\n\t\t\tif(foundVolumeInfo.getStatus().equals(StorageProperties.Status.available.toString())) {\n\t\t\t\t//create snapshot\n\t\t\t\tif(StorageProperties.shouldEnforceUsageLimits) {\n\t\t\t\t\tint volSize = foundVolumeInfo.getSize();\n\t\t\t\t\tint totalSnapshotSize = 0;\n\t\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo();\n\t\t\t\t\tsnapInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\t\t\tEntityWrapper<SnapshotInfo> dbSnap = db.recast(SnapshotInfo.class);\n\n\t\t\t\t\tList<SnapshotInfo> snapInfos = dbSnap.query(snapInfo);\n\t\t\t\t\tfor (SnapshotInfo sInfo : snapInfos) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\ttotalSnapshotSize += blockManager.getSnapshotSize(sInfo.getSnapshotId());\n\t\t\t\t\t\t} catch(EucalyptusCloudException e) {\n\t\t\t\t\t\t\tLOG.error(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif((totalSnapshotSize + volSize) > WalrusInfo.getWalrusInfo().getStorageMaxTotalSnapshotSizeInGb()) {\n\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\tthrow new EntityTooLargeException(snapshotId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tEntityWrapper<SnapshotInfo> db2 = StorageProperties.getEntityWrapper();\n\t\t\t\tSnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n\t\t\t\tsnapshotInfo.setUserName(foundVolumeInfo.getUserName());\n\t\t\t\tsnapshotInfo.setVolumeId(volumeId);\n\t\t\t\tDate startTime = new Date();\n\t\t\t\tsnapshotInfo.setStartTime(startTime);\n\t\t\t\tsnapshotInfo.setProgress(\"0\");\n\t\t\t\tsnapshotInfo.setStatus(StorageProperties.Status.creating.toString());\n\t\t\t\tdb2.add(snapshotInfo);\n\t\t\t\t//snapshot asynchronously\n\t\t\t\tString snapshotSet = \"snapset-\" + UUID.randomUUID();\n\n\t\t\t\tSnapshotter snapshotter = new Snapshotter(snapshotSet, volumeId, snapshotId);\n\t\t\t\tsnapshotService.add(snapshotter);\n\t\t\t\tdb2.commit();\n\t\t\t\tdb.commit();\n\t\t\t\treply.setSnapshotId(snapshotId);\n\t\t\t\treply.setVolumeId(volumeId);\n\t\t\t\treply.setStatus(snapshotInfo.getStatus());\n\t\t\t\treply.setStartTime(DateUtils.format(startTime.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\t\t\treply.setProgress(snapshotInfo.getProgress());\n\t\t\t} else {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new VolumeNotReadyException(volumeId);\n\t\t\t}\n\t\t} else {\n\t\t\tdb.rollback();\n\t\t\tthrow new NoSuchVolumeException(volumeId);\n\t\t}\n\t\treturn reply;\n\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\t\tpublic void run() {\n\t\t\tboolean success = true;\n\t\t\tif(snapshotId != null) {\n\t\t\t\tEntityWrapper<SnapshotInfo> db = StorageProperties.getEntityWrapper();\n\t\t\t\ttry {\n\t\t\t\t\tSnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n\t\t\t\t\tList<SnapshotInfo> foundSnapshotInfos = db.query(snapshotInfo);\n\t\t\t\t\tif(foundSnapshotInfos.size() == 0) {\n\t\t\t\t\t\tdb.commit();\t\t\t\t\t\t\n\t\t\t\t\t\t//get snapshot size from walrus\n\t\t\t\t\t\tint sizeExpected = getSnapshotSize(snapshotId);\n\t\t\t\t\t\tString snapDestination = blockManager.prepareSnapshot(snapshotId, sizeExpected);\n\t\t\t\t\t\tgetSnapshot(snapshotId, snapDestination);\n\t\t\t\t\t\tsize = blockManager.createVolume(volumeId, snapshotId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSnapshotInfo foundSnapshotInfo = foundSnapshotInfos.get(0);\n\t\t\t\t\t\tif(!foundSnapshotInfo.getStatus().equals(StorageProperties.Status.available.toString())) {\n\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tLOG.warn(\"snapshot \" + foundSnapshotInfo.getSnapshotId() + \" not available.\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\tsize = blockManager.createVolume(volumeId, snapshotId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tsuccess = false;\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tassert(size > 0);\n\t\t\t\t\tblockManager.createVolume(volumeId, size);\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tsuccess = false;\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\t\ttry {\n\t\t\t\tVolumeInfo foundVolumeInfo = db.getUnique(volumeInfo);\n\t\t\t\tif(foundVolumeInfo != null) {\n\t\t\t\t\tif(success) {\n\t\t\t\t\t\tif(StorageProperties.shouldEnforceUsageLimits && \n\t\t\t\t\t\t\t\tStorageProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\tint totalVolumeSize = (int)(blockStorageStatistics.getTotalSpaceUsed() / StorageProperties.GB);\n\t\t\t\t\t\t\tif((totalVolumeSize + size) > StorageInfo.getStorageInfo().getMaxTotalVolumeSizeInGb() ||\n\t\t\t\t\t\t\t\t\t(size > StorageInfo.getStorageInfo().getMaxVolumeSizeInGB())) {\n\t\t\t\t\t\t\t\tLOG.error(\"Volume size limit exceeeded\");\n\t\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\t\tchecker.cleanFailedVolume(volumeId);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\t\t\t\tif(StorageProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\tblockStorageStatistics.incrementVolumeCount();\n\t\t\t\t\t\t\tblockStorageStatistics.updateSpaceUsed((size * StorageProperties.GB));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfoundVolumeInfo.setStatus(StorageProperties.Status.failed.toString());\n\t\t\t\t\t}\n\t\t\t\t\tif(snapshotId != null) {\n\t\t\t\t\t\tfoundVolumeInfo.setSize(size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new EucalyptusCloudException();\n\t\t\t\t}\n\t\t\t\tdb.commit();\n\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\tdb.rollback();\n\t\t\t\tLOG.error(ex);\n\t\t\t}\n\t\t}","id":74417,"modified_method":"@Override\n\t\tpublic void run() {\n\t\t\tboolean success = true;\n\t\t\tif(snapshotId != null) {\n\t\t\t\tEntityWrapper<SnapshotInfo> db = StorageProperties.getEntityWrapper();\n\t\t\t\ttry {\n\t\t\t\t\tSnapshotInfo snapshotInfo = new SnapshotInfo(snapshotId);\n\t\t\t\t\tList<SnapshotInfo> foundSnapshotInfos = db.query(snapshotInfo);\n\t\t\t\t\tif(foundSnapshotInfos.size() == 0) {\n\t\t\t\t\t\tdb.commit();\t\t\t\t\t\t\n\t\t\t\t\t\t//get snapshot size from walrus\n\t\t\t\t\t\tint sizeExpected = getSnapshotSize(snapshotId);\n\t\t\t\t\t\tString snapDestination = blockManager.prepareSnapshot(snapshotId, sizeExpected);\n\t\t\t\t\t\tgetSnapshot(snapshotId, snapDestination);\n\t\t\t\t\t\tsize = blockManager.createVolume(volumeId, snapshotId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSnapshotInfo foundSnapshotInfo = foundSnapshotInfos.get(0);\n\t\t\t\t\t\tif(!foundSnapshotInfo.getStatus().equals(StorageProperties.Status.available.toString())) {\n\t\t\t\t\t\t\tsuccess = false;\n\t\t\t\t\t\t\tdb.rollback();\n\t\t\t\t\t\t\tLOG.warn(\"snapshot \" + foundSnapshotInfo.getSnapshotId() + \" not available.\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\tsize = blockManager.createVolume(volumeId, snapshotId);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tsuccess = false;\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tassert(size > 0);\n\t\t\t\t\tblockManager.createVolume(volumeId, size);\n\t\t\t\t} catch(Exception ex) {\n\t\t\t\t\tsuccess = false;\n\t\t\t\t\tLOG.error(ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\t\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\t\ttry {\n\t\t\t\tVolumeInfo foundVolumeInfo = db.getUnique(volumeInfo);\n\t\t\t\tif(foundVolumeInfo != null) {\n\t\t\t\t\tif(success) {\n\t\t\t\t\t\tif(StorageProperties.shouldEnforceUsageLimits && \n\t\t\t\t\t\t\t\tStorageProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\tint totalVolumeSize = (int)(blockStorageStatistics.getTotalSpaceUsed() / StorageProperties.GB);\n\t\t\t\t\t\t\tif((totalVolumeSize + size) > StorageInfo.getStorageInfo().getMaxTotalVolumeSizeInGb() ||\n\t\t\t\t\t\t\t\t\t(size > StorageInfo.getStorageInfo().getMaxVolumeSizeInGB())) {\n\t\t\t\t\t\t\t\tLOG.error(\"Volume size limit exceeeded\");\n\t\t\t\t\t\t\t\tdb.commit();\n\t\t\t\t\t\t\t\tchecker.cleanFailedVolume(volumeId);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfoundVolumeInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\t\t\t\tif(StorageProperties.trackUsageStatistics) {\n\t\t\t\t\t\t\tblockStorageStatistics.incrementVolumeCount((size * StorageProperties.GB));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfoundVolumeInfo.setStatus(StorageProperties.Status.failed.toString());\n\t\t\t\t\t}\n\t\t\t\t\tif(snapshotId != null) {\n\t\t\t\t\t\tfoundVolumeInfo.setSize(size);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new EucalyptusCloudException();\n\t\t\t\t}\n\t\t\t\tdb.commit();\n\t\t\t} catch(EucalyptusCloudException ex) {\n\t\t\t\tdb.rollback();\n\t\t\t\tLOG.error(ex);\n\t\t\t}\n\t\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tEucaSemaphore semaphore = EucaSemaphoreDirectory.getSolitarySemaphore(volumeId);\n\t\t\t\ttry {\n\t\t\t\t\tsemaphore.acquire();\n\t\t\t\t} catch(InterruptedException ex) {\n\t\t\t\t\tthrow new EucalyptusCloudException(\"semaphore could not be acquired\");\n\t\t\t\t}\n\t\t\t\tList<String> returnValues = blockManager.createSnapshot(volumeId, snapshotId);\n\t\t\t\tsemaphore.release();\n\t\t\t\tif(returnValues.size() < 2) {\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to transfer snapshot\");\n\t\t\t\t}\n\t\t\t\tsnapshotFileName = returnValues.get(0);\n\t\t\t\ttransferSnapshot(returnValues.get(1));\n\t\t\t\tblockManager.finishSnapshot(snapshotId);\n\t\t\t} catch(Exception ex) {\n\t\t\t\tLOG.error(ex);\n\t\t\t}\n\t\t}","id":74418,"modified_method":"@Override\n\t\tpublic void run() {\n\t\t\tEucaSemaphore semaphore = EucaSemaphoreDirectory.getSolitarySemaphore(volumeId);\n\t\t\ttry {\n\t\t\t\ttry {\n\t\t\t\t\tsemaphore.acquire();\n\t\t\t\t} catch(InterruptedException ex) {\n\t\t\t\t\tthrow new EucalyptusCloudException(\"semaphore could not be acquired\");\n\t\t\t\t}\n\t\t\t\tList<String> returnValues = blockManager.createSnapshot(volumeId, snapshotId);\n\t\t\t\tsemaphore.release();\n\t\t\t\tif(returnValues.size() < 2) {\n\t\t\t\t\tthrow new EucalyptusCloudException(\"Unable to transfer snapshot\");\n\t\t\t\t}\n\t\t\t\tsnapshotFileName = returnValues.get(0);\n\t\t\t\ttransferSnapshot(returnValues.get(1));\n\t\t\t\tblockManager.finishVolume(snapshotId);\n\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo(snapshotId);\n\t\t\t\tEntityWrapper<SnapshotInfo> db = StorageProperties.getEntityWrapper();\n\t\t\t\ttry {\n\t\t\t\t\tSnapshotInfo snapshotInfo = db.getUnique(snapInfo);\n\t\t\t\t\tsnapshotInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\t\t} catch(EucalyptusCloudException e) {\n\t\t\t\t\tLOG.error(e);\n\t\t\t\t} finally {\n\t\t\t\t\tdb.commit();\n\t\t\t\t}\n\t\t\t} catch(Exception ex) {\n\t\t\t\tsemaphore.release();\n\t\t\t\ttry {\n\t\t\t\t\tblockManager.finishVolume(snapshotId);\n\t\t\t\t} catch (EucalyptusCloudException e1) {\n\t\t\t\t\tLOG.error(e1);\n\t\t\t\t}\n\t\t\t\tSnapshotInfo snapInfo = new SnapshotInfo(snapshotId);\n\t\t\t\tEntityWrapper<SnapshotInfo> db = StorageProperties.getEntityWrapper();\n\t\t\t\ttry {\n\t\t\t\t\tSnapshotInfo snapshotInfo = db.getUnique(snapInfo);\n\t\t\t\t\tsnapshotInfo.setStatus(StorageProperties.Status.failed.toString());\n\t\t\t\t} catch(EucalyptusCloudException e) {\n\t\t\t\t\tLOG.error(e);\n\t\t\t\t} finally {\n\t\t\t\t\tdb.commit();\n\t\t\t\t}\n\t\t\t\tLOG.error(ex);\n\t\t\t}\n\t\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public CreateStorageVolumeResponseType CreateStorageVolume(CreateStorageVolumeType request) throws EucalyptusCloudException {\n\t\tCreateStorageVolumeResponseType reply = (CreateStorageVolumeResponseType) request.getReply();\n\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString snapshotId = request.getSnapshotId();\n\t\tString userId = request.getUserId();\n\t\tString volumeId = request.getVolumeId();\n\n\t\t//in GB\n\t\tString size = request.getSize();\n\t\tint sizeAsInt = 0;\n\t\tif(StorageProperties.shouldEnforceUsageLimits && StorageProperties.trackUsageStatistics) {\n\t\t\tif(size != null) {\n\t\t\t\tsizeAsInt = Integer.parseInt(size);\n\t\t\t\tint totalVolumeSize = (int)(blockStorageStatistics.getTotalSpaceUsed() / StorageProperties.GB);\n\t\t\t\t;\t\t\t\tif(((totalVolumeSize + sizeAsInt) > StorageInfo.getStorageInfo().getMaxTotalVolumeSizeInGb()) ||\n\t\t\t\t\t\t(sizeAsInt > StorageInfo.getStorageInfo().getMaxVolumeSizeInGB()))\n\t\t\t\t\tthrow new EntityTooLargeException(volumeId);\n\t\t\t}\n\t\t}\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\n\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\tList<VolumeInfo> volumeInfos = db.query(volumeInfo);\n\t\tif(volumeInfos.size() > 0) {\n\t\t\tdb.rollback();\n\t\t\tthrow new VolumeAlreadyExistsException(volumeId);\n\t\t}\n\t\tvolumeInfo.setUserName(userId);\n\t\tvolumeInfo.setSize(sizeAsInt);\n\t\tvolumeInfo.setStatus(StorageProperties.Status.creating.toString());\n\t\tDate creationDate = new Date();\n\t\tvolumeInfo.setCreateTime(creationDate);\n\t\tif(snapshotId != null) {\n\t\t\tvolumeInfo.setSnapshotId(snapshotId);\n\t\t\treply.setSnapshotId(snapshotId);\n\t\t}\n\t\tdb.add(volumeInfo);\n\t\treply.setVolumeId(volumeId);\n\t\treply.setCreateTime(DateUtils.format(creationDate.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treply.setSize(size);\n\t\treply.setStatus(volumeInfo.getStatus());\n\t\tdb.commit();\n\n\t\t//create volume asynchronously\n\t\tVolumeCreator volumeCreator = new VolumeCreator(volumeId, \"snapset\", snapshotId, sizeAsInt);\n\t\tvolumeService.add(volumeCreator);\n\n\t\treturn reply;\n\t}","id":74419,"modified_method":"public CreateStorageVolumeResponseType CreateStorageVolume(CreateStorageVolumeType request) throws EucalyptusCloudException {\n\t\tCreateStorageVolumeResponseType reply = (CreateStorageVolumeResponseType) request.getReply();\n\n\t\tif(!StorageProperties.enableStorage) {\n\t\t\tLOG.error(\"BlockStorage has been disabled. Please check your setup\");\n\t\t\treturn reply;\n\t\t}\n\n\t\tString snapshotId = request.getSnapshotId();\n\t\tString userId = request.getUserId();\n\t\tString volumeId = request.getVolumeId();\n\n\t\t//in GB\n\t\tString size = request.getSize();\n\t\tint sizeAsInt = 0;\n\t\tif(StorageProperties.shouldEnforceUsageLimits && StorageProperties.trackUsageStatistics) {\n\t\t\tif(size != null) {\n\t\t\t\tsizeAsInt = Integer.parseInt(size);\n\t\t\t\tint totalVolumeSize = (int)(blockStorageStatistics.getTotalSpaceUsed() / StorageProperties.GB);\n\t\t\t\t;\t\t\t\tif(((totalVolumeSize + sizeAsInt) > StorageInfo.getStorageInfo().getMaxTotalVolumeSizeInGb()) ||\n\t\t\t\t\t\t(sizeAsInt > StorageInfo.getStorageInfo().getMaxVolumeSizeInGB()))\n\t\t\t\t\tthrow new EntityTooLargeException(volumeId);\n\t\t\t}\n\t\t}\n\t\tEntityWrapper<VolumeInfo> db = StorageProperties.getEntityWrapper();\n\n\t\tVolumeInfo volumeInfo = new VolumeInfo(volumeId);\n\t\tList<VolumeInfo> volumeInfos = db.query(volumeInfo);\n\t\tif(volumeInfos.size() > 0) {\n\t\t\tdb.rollback();\n\t\t\tthrow new VolumeAlreadyExistsException(volumeId);\n\t\t}\n\t\tif(snapshotId != null) {\n\t\t\tSnapshotInfo snapInfo = new SnapshotInfo(snapshotId);\n\t\t\tsnapInfo.setStatus(StorageProperties.Status.available.toString());\n\t\t\tEntityWrapper<SnapshotInfo> dbSnap = db.recast(SnapshotInfo.class);\t\t\t\n\t\t\tList<SnapshotInfo> snapInfos = dbSnap.query(snapInfo);\n\t\t\tif(snapInfos.size() != 1) {\n\t\t\t\tdb.rollback();\n\t\t\t\tthrow new NoSuchEntityException(\"Snapshot \" + snapshotId + \" does not exist or is unavailable\");\n\t\t\t}\n\t\t\tvolumeInfo.setSnapshotId(snapshotId);\n\t\t\treply.setSnapshotId(snapshotId);\n\t\t}\n\t\tvolumeInfo.setUserName(userId);\n\t\tvolumeInfo.setSize(sizeAsInt);\n\t\tvolumeInfo.setStatus(StorageProperties.Status.creating.toString());\n\t\tDate creationDate = new Date();\n\t\tvolumeInfo.setCreateTime(creationDate);\n\t\tdb.add(volumeInfo);\n\t\treply.setVolumeId(volumeId);\n\t\treply.setCreateTime(DateUtils.format(creationDate.getTime(), DateUtils.ISO8601_DATETIME_PATTERN) + \".000Z\");\n\t\treply.setSize(size);\n\t\treply.setStatus(volumeInfo.getStatus());\n\t\tdb.commit();\n\n\t\t//create volume asynchronously\n\t\tVolumeCreator volumeCreator = new VolumeCreator(volumeId, \"snapset\", snapshotId, sizeAsInt);\n\t\tvolumeService.add(volumeCreator);\n\n\t\treturn reply;\n\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( \"deprecation\" )\n  public static void configure( String entrySetName ) {\n    File propsFile = getPropertyFile( entrySetName );\n    if( !propsFile.exists( ) ) {\n      ConfigurationProperties.store( entrySetName );\n    }\n    Properties props = new Properties( );\n    try {\n      props.load( new FileReader( propsFile ) );\n    } catch ( FileNotFoundException e ) {\n      LOG.trace( e, e );\n    } catch ( IOException e ) {\n      LOG.trace( e, e );\n    }\n    List<ConfigurableProperty> prefixProps = PropertyDirectory.getPropertyEntrySet( entrySetName );\n    Map<String,String> properties = Maps.fromProperties( props );\n    props.clear( );\n    for( final ConfigurableProperty p : prefixProps ) {\n      if( p instanceof StaticPropertyEntry ) {\n        boolean hasProp = Iterables.any( properties.keySet( ), new Predicate<String>() {\n          @Override\n          public boolean apply( String arg0 ) {\n            return p.getFieldName( ).equals( arg0.toLowerCase( ) );\n          }\n        } );\n        if( hasProp ) {\n          p.setValue( properties.get( p.getFieldName( ) ) );\n        } else {\n          properties.put( p.getFieldName( ), p.getValue( ) );\n        }\n      }\n    }\n    if( !properties.isEmpty( ) ) {\n      props.putAll( properties );\n      try {\n        props.save( new FileOutputStream( propsFile ), PropertyDirectory.getEntrySetDescription( entrySetName ) );\n      } catch ( FileNotFoundException e ) {\n        LOG.warn( \"Failed to save property set: \" + entrySetName, e );\n      }\n    }\n  }","id":74420,"modified_method":"@SuppressWarnings( \"deprecation\" )\n  public static void configure( String entrySetName ) {\n    File propsFile = getPropertyFile( entrySetName );\n    if( !propsFile.exists( ) ) {\n      ConfigurationProperties.store( entrySetName );\n    }\n    Properties props = new Properties( );\n    FileReader fileReader = null;\n    try {\n      fileReader = new FileReader( propsFile );\n\t  props.load( fileReader );\n    } catch ( FileNotFoundException e ) {\n      LOG.trace( e, e );\n    } catch ( IOException e ) {\n      LOG.trace( e, e );\n    } finally {\n      if( fileReader != null ) {\n    \ttry {\n          fileReader.close();\n    \t} catch(IOException e) {\n          LOG.error(e);\n    \t}\n      }\n    }\n    List<ConfigurableProperty> prefixProps = PropertyDirectory.getPropertyEntrySet( entrySetName );\n    Map<String,String> properties = Maps.fromProperties( props );\n    props.clear( );\n    for( final ConfigurableProperty p : prefixProps ) {\n      if( p instanceof StaticPropertyEntry ) {\n        boolean hasProp = Iterables.any( properties.keySet( ), new Predicate<String>() {\n          @Override\n          public boolean apply( String arg0 ) {\n            return p.getFieldName( ).equals( arg0.toLowerCase( ) );\n          }\n        } );\n        if( hasProp ) {\n          p.setValue( properties.get( p.getFieldName( ) ) );\n        } else {\n          properties.put( p.getFieldName( ), p.getValue( ) );\n        }\n      }\n    }\n    if( !properties.isEmpty( ) ) {\n      props.putAll( properties );\n      FileOutputStream fileOutputStream = null;\n      try {\n        fileOutputStream = new FileOutputStream( propsFile );\n\t\tprops.save( fileOutputStream, PropertyDirectory.getEntrySetDescription( entrySetName ) );\n      } catch ( FileNotFoundException e ) {\n        LOG.warn( \"Failed to save property set: \" + entrySetName, e );\n      } finally {\n    \tif ( fileOutputStream != null ) {\n    \t  try {\n    \t    fileOutputStream.close();\n    \t  } catch(IOException e) {\n    \t\tLOG.error(e);\n    \t  }\n    \t}\n      }\n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void store( String entrySetName ) {\n    File propsFile = getPropertyFile( entrySetName );\n    Properties props = new Properties( );\n    try {\n      props.load( new FileReader( propsFile ) );\n    } catch ( Exception e1 ) {\n    }\n    props.clear( );\n    for( final ConfigurableProperty p : PropertyDirectory.getPropertyEntrySet( entrySetName ) ) {\n      if( !( p instanceof SingletonDatabasePropertyEntry ) ) {\n        props.setProperty( p.getFieldName( ), p.getValue( ) );\n      }\n    }\n    if( !props.isEmpty( ) ) {\n      try {\n        props.store( new FileWriter( propsFile ), PropertyDirectory.getEntrySetDescription( entrySetName ) );\n      } catch ( IOException e ) {\n        LOG.warn( e, e );\n      }\n    }\n  }","id":74421,"modified_method":"public static void store( String entrySetName ) {\n    File propsFile = getPropertyFile( entrySetName );\n    Properties props = new Properties( );\n    FileReader fileReader = null;\n    try {\n      fileReader = new FileReader( propsFile );\n\t  props.load( fileReader );\n    } catch ( Exception e1 ) {\n    } finally {\n      if(fileReader != null) {\n    \ttry {\n          fileReader.close();\n    \t} catch(IOException e) {\n          LOG.error(e);\n    \t}\n      }\n    }\n    props.clear( );\n    for( final ConfigurableProperty p : PropertyDirectory.getPropertyEntrySet( entrySetName ) ) {\n      if( !( p instanceof SingletonDatabasePropertyEntry ) && !( p instanceof MultiDatabasePropertyEntry ) ) {\n        props.setProperty( p.getFieldName( ), p.getValue( ) );\n      }\n    }\n    if( !props.isEmpty( ) ) {\n      FileWriter fileWriter = null;\n      try {\n        fileWriter = new FileWriter( propsFile );\n\t\tprops.store( fileWriter, PropertyDirectory.getEntrySetDescription( entrySetName ) );\n      } catch ( IOException e ) {\n        LOG.warn( e, e );\n      } finally {\n    \tif(fileWriter != null) {\n    \t  try { \n    \t    fileWriter.close();\n    \t  } catch (IOException e) {\n    \t    LOG.error(e);\n    \t  }\n    \t}\n      }\n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public boolean processsClass( Class c ) throws Throwable {\n    if ( c.getAnnotation( ConfigurableClass.class ) != null ) {\n      LOG.info( \"-> Registrering configuration properties for entry: \" + c.getName( ) );\n      LOG.debug( \"Checking fields: \" + Arrays.asList( c.getDeclaredFields( ) ));\n      for( Field  f : c.getDeclaredFields( ) ) {\n        LOG.debug( \"Checking field: \" + f );\n        try {\n          ConfigurableProperty prop = PropertyDirectory.buildPropertyEntry( c, f );\n          if( prop == null ) {\n            continue;\n          } else {\n            LOG.info( \"--> Adding property: \" + prop.getQualifiedName( )  );\n          }\n        } catch ( Throwable e ) {\n          LOG.debug( e, e );\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }","id":74422,"modified_method":"@Override\n  public boolean processClass( Class c ) throws Throwable {\n    if ( (c.getAnnotation( ConfigurableClass.class ) != null) )  {\n      LOG.info( \"-> Registrering configuration properties for entry: \" + c.getName( ) );\n      LOG.debug( \"Checking fields: \" + Arrays.asList( c.getDeclaredFields( ) ));\n      for( Field  f : c.getDeclaredFields( ) ) {\n        LOG.debug( \"Checking field: \" + f );\n        try {\n          ConfigurableProperty prop = PropertyDirectory.buildPropertyEntry( c, f );\n          if( prop == null ) {\n            continue;\n          } else {\n            LOG.info( \"--> Adding property: \" + prop.getQualifiedName( )  );\n          }\n        } catch ( Throwable e ) {\n          LOG.debug( e, e );\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static List<ComponentProperty> getComponentPropertySet( String prefix ) {\n\t  List<ComponentProperty> componentProps = Lists.newArrayList();\n\t  List<ConfigurableProperty> props = getPropertyEntrySet( prefix );\n\t  for (ConfigurableProperty prop : props) {\n\t\t  componentProps.add(new ComponentProperty(prop.getWidgetType(), prop.getDisplayName(), prop.getValue(), prop.getQualifiedName()));\n\t  }\n\t  return componentProps;\n  }","id":74423,"modified_method":"public static List<ComponentProperty> getComponentPropertySet( String prefix ) {\n\t  List<ComponentProperty> componentProps = Lists.newArrayList();\n\t  List<ConfigurableProperty> props = getPropertyEntrySet( prefix );\n\t  for (ConfigurableProperty prop : props) {\n\t\t  componentProps.add(new ComponentProperty(prop.getWidgetType().toString(), prop.getDisplayName(), prop.getValue(), prop.getQualifiedName()));\n\t  }\n\t  return componentProps;\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( { \"unchecked\" } )\n  public static ConfigurableProperty buildPropertyEntry( Class c, Field field ) {\n    for ( ConfigurablePropertyBuilder b : builders ) {\n      try {\n        ConfigurableProperty prop = b.buildProperty( c, field );\n        if ( prop != null ) {\n          if ( !fqMap.containsKey( prop.getQualifiedName( ) ) ) {\n            fqMap.put( prop.getQualifiedName( ), prop );\n            fqPrefixMap.put( prop.getEntrySetName( ), prop );\n            return prop;\n          } else {\n            RuntimeException r = new RuntimeException( \"Duplicate configurable field in same config file: \\n\" + \"-> \"\n                                                       + fqMap.get( prop.getQualifiedName( ) ).getDefiningClass( ).getCanonicalName( ) + \".\" + field.getName( )\n                                                       + \"\\n\" + \"-> \" + c.getCanonicalName( ) + \".\" + field.getName( ) + \"\\n\" );\n            LOG.fatal( r, r );\n            System.exit( 1 );\n            throw r;\n          }\n        }\n      } catch ( ConfigurablePropertyException e ) {\n        LOG.debug( e, e );\n      }\n    }\n    return null;\n  }","id":74424,"modified_method":"@SuppressWarnings( { \"unchecked\" } )\n  public static ConfigurableProperty buildPropertyEntry( Class c, Field field ) {\n    for ( ConfigurablePropertyBuilder b : builders ) {\n      try {\n        ConfigurableProperty prop = null;\n        try {\n          prop = b.buildProperty( c, field );\n        } catch ( ConfigurablePropertyException e ) {\n          throw e;\n        } catch ( Throwable t ) {\n          LOG.error( \"Failed to prepare configurable field: \" + c.getCanonicalName( ) + \".\" + field.getName( ) );\n          System.exit( 1 );\n        }\n        if ( prop != null ) {\n          ConfigurableClass configurableAnnot = (ConfigurableClass) c.getAnnotation(ConfigurableClass.class);\n          if ( configurableAnnot.deferred() ) {\n        \tif ( !fqPendingMap.containsKey( prop.getQualifiedName( ) ) ) {\n              fqPendingMap.put( prop.getQualifiedName( ), prop );\n              fqPendingPrefixMap.put( prop.getEntrySetName( ), prop );\n              return prop;\n            }    \n          } else {\n            if ( !fqMap.containsKey( prop.getQualifiedName( ) ) ) {\n              fqMap.put( prop.getQualifiedName( ), prop );\n              fqPrefixMap.put( prop.getEntrySetName( ), prop );\n              return prop;\n            } else {\n              RuntimeException r = new RuntimeException( \"Duplicate configurable field in same config file: \\n\" + \"-> \"\n                                                       + fqMap.get( prop.getQualifiedName( ) ).getDefiningClass( ).getCanonicalName( ) + \".\" + field.getName( )\n                                                       + \"\\n\" + \"-> \" + c.getCanonicalName( ) + \".\" + field.getName( ) + \"\\n\" );\n              LOG.fatal( r, r );\n              System.exit( 1 );\n              throw r;\n            }\n          }\n        }\n      } catch ( ConfigurablePropertyException e ) {\n        LOG.debug( e, e );\n      }\n    }\n    return null;\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static PropertyTypeParser get( Class c ) {\n    if( !typeParsers.containsKey( c ) || typeParsers.get( c ) == null ) {\n      RuntimeException r = new RuntimeException(\"Invalid configurable type: \" + c );\n      LOG.fatal( r, r );\n      System.exit( 1 );\n      throw r;\n    } else {\n      return typeParsers.get( c );      \n    }\n  }","id":74425,"modified_method":"public static PropertyTypeParser get( Class c ) {\n    if( !typeParsers.containsKey( c ) || typeParsers.get( c ) == null ) {\n      RuntimeException r = new RuntimeException(\"Invalid configurable type: \" + c );\n      LOG.fatal( r, r );\n      throw r;\n    } else {\n      return typeParsers.get( c );      \n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public void checkClass( Class candidate ) {\n    try {\n      if ( this.processsClass( candidate ) ) {\n        ServiceJarDiscovery.checkUniqueness( candidate );\n        EventRecord.here( ServiceJarDiscovery.class, EventType.DISCOVERY_LOADED_ENTRY, this.getClass( ).getSimpleName( ), candidate.getName( ) ).info( );\n      }\n    } catch ( Throwable e ) {\n      LOG.trace( e, e );\n    }\n  }","id":74426,"modified_method":"public void checkClass( Class candidate ) {\n    try {\n      if ( this.processClass( candidate ) ) {\n        ServiceJarDiscovery.checkUniqueness( candidate );\n        EventRecord.here( ServiceJarDiscovery.class, EventType.DISCOVERY_LOADED_ENTRY, this.getClass( ).getSimpleName( ), candidate.getName( ) ).info( );\n      }\n    } catch ( Throwable e ) {\n      if ( e instanceof InstantiationException ) {} else {\n        LOG.trace( e, e );\n      }\n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"/**\n   * Process the potential bootstrap-related class. Return false or throw an exception if the class is rejected.\n   * \n   * @param candidate\n   * @return TODO\n   * @throws Throwable\n   */\n  public abstract boolean processsClass( Class candidate ) throws Throwable;","id":74427,"modified_method":"/**\n   * Process the potential bootstrap-related class. Return false or throw an exception if the class is rejected.\n   * \n   * @param candidate\n   * @return TODO\n   * @throws Throwable\n   */\n  public abstract boolean processClass( Class candidate ) throws Throwable;","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@SuppressWarnings( { \"deprecation\", \"unchecked\" } )\n  public static void processFile( File f ) throws IOException {\n    JarFile jar = new JarFile( f );\n    Properties props = new Properties( );\n    Enumeration<JarEntry> jarList = jar.entries( );\n    LOG.info( \"-> Trying to load component info from \" + f.getAbsolutePath( ) );\n    while ( jarList.hasMoreElements( ) ) {\n      JarEntry j = jarList.nextElement( );\n      if ( j.getName( ).matches( \".*\\\\.class.{0,1}\" ) ) {\n        String classGuess = j.getName( ).replaceAll( \"/\", \".\" ).replaceAll( \"\\\\.class.{0,1}\", \"\" );\n        try {\n          Class candidate = ClassLoader.getSystemClassLoader( ).loadClass( classGuess );\n          classList.put( candidate, f.getAbsolutePath( ) );\n          if ( ServiceJarDiscovery.class.isAssignableFrom( candidate ) && !ServiceJarDiscovery.class.equals( candidate ) ) {\n            try {\n              ServiceJarDiscovery discover = ( ServiceJarDiscovery ) candidate.newInstance( );\n              discovery.add( discover );\n            } catch ( Exception e ) {\n              LOG.fatal( e, e );\n              throw new RuntimeException( e );\n            }\n          }\n        } catch ( ClassNotFoundException e ) {\n          LOG.debug( e, e );\n        }\n      }\n    }\n  }","id":74428,"modified_method":"@SuppressWarnings( { \"deprecation\", \"unchecked\" } )\n  public static void processFile( File f ) throws IOException {\n    JarFile jar = new JarFile( f );\n    Properties props = new Properties( );\n    Enumeration<JarEntry> jarList = jar.entries( );\n    LOG.info( \"-> Trying to load component info from \" + f.getAbsolutePath( ) );\n    while ( jarList.hasMoreElements( ) ) {\n      JarEntry j = jarList.nextElement( );\n      if ( j.getName( ).matches( \".*\\\\.class.{0,1}\" ) ) {\n        String classGuess = j.getName( ).replaceAll( \"/\", \".\" ).replaceAll( \"\\\\.class.{0,1}\", \"\" );\n        try {\n          Class candidate = ClassLoader.getSystemClassLoader( ).loadClass( classGuess );\n          classList.put( candidate, f.getAbsolutePath( ) );\n          if ( ServiceJarDiscovery.class.isAssignableFrom( candidate ) && !ServiceJarDiscovery.class.equals( candidate ) ) {\n            try {\n              ServiceJarDiscovery discover = ( ServiceJarDiscovery ) candidate.newInstance( );\n              discovery.add( discover );\n              EventRecord.here( ServiceJarDiscovery.class, EventType.BOOTSTRAP_INIT_DISCOVERY, discovery.getClass( ).getCanonicalName( ) );\n            } catch ( Exception e ) {\n              LOG.fatal( e, e );\n              jar.close( );\n              throw new RuntimeException( e );\n            }\n          }\n        } catch ( ClassNotFoundException e ) {\n          LOG.debug( e, e );\n        }\n      }\n    }\n    jar.close( );\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public SingletonDatabasePropertyEntry( Class definingClass, String entrySetName, Field field, String description, String defaultValue, PropertyTypeParser typeParser,\n                                Boolean readOnly, String displayName, String widgetType ) {\n    super( definingClass, entrySetName, field.getName( ), defaultValue, description, typeParser, readOnly, displayName, widgetType );\n    this.baseMethodName = field.getName( ).substring( 0, 1 ).toUpperCase( ) + field.getName( ).substring( 1 );\n    this.persistenceContext = ( ( PersistenceContext ) definingClass.getAnnotation( PersistenceContext.class ) ).name( );\n    this.setArgs = new Class[] { field.getType( ) };\n    try {\n      get = definingClass.getDeclaredMethod( \"get\" + this.baseMethodName );\n      set = definingClass.getDeclaredMethod( \"set\" + this.baseMethodName, this.setArgs );\n    } catch ( Exception e ) {\n      LOG.debug( e, e );\n    }\n  }","id":74429,"modified_method":"public SingletonDatabasePropertyEntry( Class definingClass, String entrySetName, Field field, String description, String defaultValue, PropertyTypeParser typeParser,\n                                Boolean readOnly, String displayName, ConfigurableFieldType widgetType, String alias ) {\n    super( definingClass, entrySetName, field.getName( ), defaultValue, description, typeParser, readOnly, displayName, widgetType, alias );\n    this.baseMethodName = field.getName( ).substring( 0, 1 ).toUpperCase( ) + field.getName( ).substring( 1 );\n    this.persistenceContext = ( ( PersistenceContext ) definingClass.getAnnotation( PersistenceContext.class ) ).name( );\n    this.setArgs = new Class[] { field.getType( ) };\n    try {\n      get = definingClass.getDeclaredMethod( \"get\" + this.baseMethodName );\n      set = definingClass.getDeclaredMethod( \"set\" + this.baseMethodName, this.setArgs );\n    } catch ( Exception e ) {\n      LOG.debug( e, e );\n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public String getValue( ) {\n    EntityWrapper db = new EntityWrapper( this.persistenceContext );\n    try {\n      Object o = db.getUnique( this.getQueryObject( ) );\n      Object prop = this.getGetter( ).invoke( o );\n      String result = prop != null ? prop.toString( ) : \"null\";\n      db.commit( );\n      return result;\n    } catch ( Exception e ) {\n      db.rollback( );\n      return \"Error: \" + e.getMessage( );\n    }\n  }","id":74430,"modified_method":"@Override\n  public String getValue( ) {\n    EntityWrapper db = new EntityWrapper( this.persistenceContext );\n    try {\n      Object o = db.getUnique( this.getQueryObject( ) );\n      Method getter = this.getGetter( );\n      Object prop = null;\n      if ( getter != null ) {\n\t    prop = getter.invoke( o );\n      }\n      String result = prop != null ? prop.toString( ) : \"null\";\n      db.commit( );\n      return result;\n    } catch ( Exception e ) {\n      db.rollback( );\n      return \"Error: \" + e.getMessage( );\n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public String setValue( String s ) {\n    EntityWrapper db = new EntityWrapper( this.persistenceContext );\n    try {\n      Object o = db.getUnique( this.getQueryObject( ) );\n      Object prop = this.getTypeParser( ).parse( s );\n      this.getSetter( ).invoke( o, prop );\n      db.commit( );\n      return s;\n    } catch ( Exception e ) {\n      db.rollback( );\n      return \"Error: \" + e.getMessage( );\n    }\n  }","id":74431,"modified_method":"@Override\n  public String setValue( String s ) {\n    EntityWrapper db = new EntityWrapper( this.persistenceContext );\n    try {\n      Object o = db.getUnique( this.getQueryObject( ) );\n      Object prop = this.getTypeParser( ).parse( s );\n      Method setter = this.getSetter( );\n      if ( setter != null ) {\n\t    setter.invoke( o, prop );\n      }\n      db.commit( );\n      return s;\n    } catch ( Exception e ) {\n      db.rollback( );\n      return \"Error: \" + e.getMessage( );\n    }\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public ConfigurableProperty buildProperty( Class c, Field f ) throws ConfigurablePropertyException {\n      if ( c.isAnnotationPresent( Entity.class ) && f.isAnnotationPresent( ConfigurableField.class ) ) {\n        LOG.debug( \"Checking field: \" + c.getName( ) + \".\" + f.getName( ) );\n        ConfigurableClass classAnnote = ( ConfigurableClass ) c.getAnnotation( ConfigurableClass.class );\n        ConfigurableField annote = f.getAnnotation( ConfigurableField.class );\n        String fqPrefix = classAnnote.alias( );\n        String description = annote.description( );\n        String defaultValue = annote.initial( );\n        PropertyTypeParser p = PropertyTypeParser.get( f.getType( ) );\n        try {\n          if ( !Modifier.isStatic( f.getModifiers( ) ) && !f.isAnnotationPresent( Transient.class ) ) {\n            ConfigurableProperty prop = new SingletonDatabasePropertyEntry( c, fqPrefix, f, description, defaultValue, p, annote.readonly( ), annote.displayName(), annote.type().toString() );\n            return prop;\n          }\n        } catch ( Throwable e ) {\n          LOG.debug( e, e );\n          return null;\n        }\n      } else {\n        return null;\n      }\n      return null;\n    }","id":74432,"modified_method":"@Override\n    public ConfigurableProperty buildProperty( Class c, Field f ) throws ConfigurablePropertyException {\n      if ( c.isAnnotationPresent( Entity.class ) && \n    \t\t  ((ConfigurableClass)c.getAnnotation(ConfigurableClass.class)).singleton() &&\n    \t\t  f.isAnnotationPresent( ConfigurableField.class ) ) {\n        LOG.debug( \"Checking field: \" + c.getName( ) + \".\" + f.getName( ) );\n        ConfigurableClass classAnnote = ( ConfigurableClass ) c.getAnnotation( ConfigurableClass.class );\n        ConfigurableField annote = f.getAnnotation( ConfigurableField.class );\n        String fqPrefix = classAnnote.root( );\n        String alias = classAnnote.alias();\n        String description = annote.description( );\n        String defaultValue = annote.initial( );\n        PropertyTypeParser p = PropertyTypeParser.get( f.getType( ) );\n        try {\n          if ( !Modifier.isStatic( f.getModifiers( ) ) && !f.isAnnotationPresent( Transient.class ) ) {\n            ConfigurableProperty prop = new SingletonDatabasePropertyEntry( c, fqPrefix, f, description, defaultValue, p, annote.readonly( ), annote.displayName(), annote.type(), alias );\n            return prop;\n          }\n        } catch ( Throwable e ) {\n          LOG.debug( e, e );\n          return null;\n        }\n      } else {\n        return null;\n      }\n      return null;\n    }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"private static String qualifiedName( Class c, Field f ) {\n      ConfigurableClass annote = ( ConfigurableClass ) c.getAnnotation( ConfigurableClass.class );\n      return annote.alias( ) + \".\" + f.getName( ).toLowerCase( );\n    }","id":74433,"modified_method":"private static String qualifiedName( Class c, Field f ) {\n      ConfigurableClass annote = ( ConfigurableClass ) c.getAnnotation( ConfigurableClass.class );\n      return annote.root( ) + \".\" + f.getName( ).toLowerCase( );\n    }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n  public String setValue( String s ) {\n    try {\n      Object o = super.getTypeParser( ).parse( s );\n      this.field.set( null, o );\n      LOG.info( \"Set configurable property: \" + super.getQualifiedName( ) + \" to \" + s );\n    } catch ( Throwable t ) {\n      LOG.warn( \"Failed to set property: \" + super.getQualifiedName( ) + \" because of \" + t.getMessage( ) );\n      LOG.debug( t, t );\n    }\n    return this.getValue( );\n  }","id":74434,"modified_method":"@Override\n  public String setValue( String s ) {\n    try {\n      Object o = super.getTypeParser( ).parse( s );\n      this.field.set( null, o );\n      this.fireChange( );\n      LOG.info( \"Set configurable property: \" + super.getQualifiedName( ) + \" to \" + s );\n    } catch ( Throwable t ) {\n      LOG.warn( \"Failed to set property: \" + super.getQualifiedName( ) + \" because of \" + t.getMessage( ) );\n      LOG.debug( t, t );\n    }\n    return this.getValue( );\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public StaticPropertyEntry( Class definingClass, String entrySetName, Field field, String description, String defaultValue, PropertyTypeParser typeParser, Boolean readOnly, String displayName, String widgetType ) {\n    super( definingClass, entrySetName, field.getName( ), defaultValue, description, typeParser, readOnly, displayName, widgetType );\n    this.field = field;\n  }","id":74435,"modified_method":"public StaticPropertyEntry( Class definingClass, String entrySetName, Field field, String description, String defaultValue, PropertyTypeParser typeParser, Boolean readOnly, String displayName, ConfigurableFieldType widgetType, String alias, PassiveEventListener changeListener ) {\n    super( definingClass, entrySetName, field.getName( ), defaultValue, description, typeParser, readOnly, displayName, widgetType, alias, changeListener );\n    this.field = field;\n  }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override\n    public ConfigurableProperty buildProperty( Class c, Field field ) throws ConfigurablePropertyException {\n      if( c.isAnnotationPresent( ConfigurableClass.class ) && field.isAnnotationPresent( ConfigurableField.class ) ) {\n        ConfigurableClass classAnnote = ( ConfigurableClass ) c.getAnnotation( ConfigurableClass.class );\n        ConfigurableField annote = ( ConfigurableField ) field.getAnnotation( ConfigurableField.class );\n        String description = annote.description( );\n        String defaultValue = annote.initial( );\n        String fq = qualifiedName( c, field );\n        String fqPrefix = fq.replaceAll( \"\\\\..*\", \"\" );\n        PropertyTypeParser p = PropertyTypeParser.get( field.getType( ) );\n        ConfigurableProperty entry = null;\n        int modifiers = field.getModifiers( );\n        if ( Modifier.isPublic( modifiers ) && Modifier.isStatic( modifiers ) ) {\n          entry = new StaticPropertyEntry( c, fqPrefix, field, description, defaultValue, p, annote.readonly( ), annote.displayName(), annote.type().toString() );\n          entry.setValue( defaultValue );\n          return entry;\n        } \n      } \n      return null;\n    }","id":74436,"modified_method":"@Override\n    public ConfigurableProperty buildProperty( Class c, Field field ) throws ConfigurablePropertyException {\n      if( c.isAnnotationPresent( ConfigurableClass.class ) && field.isAnnotationPresent( ConfigurableField.class ) ) {\n        ConfigurableClass classAnnote = ( ConfigurableClass ) c.getAnnotation( ConfigurableClass.class );\n        ConfigurableField annote = ( ConfigurableField ) field.getAnnotation( ConfigurableField.class );\n        String description = annote.description( );\n        String defaultValue = annote.initial( );\n        String fq = qualifiedName( c, field );\n        String fqPrefix = fq.replaceAll( \"\\\\..*\", \"\" );\n        String alias = classAnnote.alias();\n        PropertyTypeParser p = PropertyTypeParser.get( field.getType( ) );\n        ConfigurableProperty entry = null;\n        Class<? extends PassiveEventListener> changeListenerClass = annote.changeListener( );\n        PassiveEventListener changeListener;\n        if( !changeListenerClass.equals( NoopEventListener.class ) ) {\n          try {\n            changeListener = changeListenerClass.newInstance( );\n          } catch ( Throwable e ) {\n            changeListener = NoopEventListener.NOOP;\n          }          \n        } else {\n          changeListener = NoopEventListener.NOOP; \n        }\n        int modifiers = field.getModifiers( );\n        if ( Modifier.isPublic( modifiers ) && Modifier.isStatic( modifiers ) ) {\n          entry = new StaticPropertyEntry( c, fqPrefix, field, description, defaultValue, p, annote.readonly( ), annote.displayName(), annote.type(), alias, changeListener );\n          entry.setValue( defaultValue );\n          return entry;\n        } \n      } \n      return null;\n    }","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"public static void updateStorageHost() {\n\t\ttry {\n\t\t\tStorageControllerConfiguration config = Configuration.getStorageControllerConfiguration(StorageProperties.NAME);\n\t\t\tSTORAGE_HOST = config.getHostName();\n\t\t} catch (EucalyptusCloudException e) {\n\t\t\tLOG.error(e);\n\t\t}\n\t}","id":74437,"modified_method":"public static void updateStorageHost() {\n\t\ttry {\n\t\t\tif(!\"unregistered\".equals(StorageProperties.NAME)) {\n\t\t\t\tStorageControllerConfiguration config = Configuration.getStorageControllerConfiguration(StorageProperties.NAME);\n\t\t\t\tSTORAGE_HOST = config.getHostName();\n\t\t\t} else {\n\t\t\t\tLOG.info(\"Storage Controller not registered yet.\");\n\t\t\t}\n\t\t} catch (EucalyptusCloudException e) {\n\t\t\tLOG.error(e);\n\t\t}\n\t}","commit_id":"3bee6036927428f82a8ed99f7bcd6dba5d738ba4","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@CalledWithWriteLock\n      public void appendChange(@NotNull TextMergeChange change, @NotNull Side side) {\n        ThreeSide sourceSide = side.select(ThreeSide.LEFT, ThreeSide.RIGHT);\n        ThreeSide outputSide = ThreeSide.BASE;\n\n        DiffUtil.applyModification(getContent(outputSide).getDocument(), change.getEndLine(outputSide), change.getEndLine(outputSide),\n                                   getContent(sourceSide).getDocument(), change.getStartLine(sourceSide), change.getEndLine(sourceSide));\n      }","id":74438,"modified_method":"@CalledWithWriteLock\n      public void appendChange(@NotNull TextMergeChange change, @NotNull Side side) {\n        ThreeSide sourceSide = side.select(ThreeSide.LEFT, ThreeSide.RIGHT);\n        ThreeSide outputSide = ThreeSide.BASE;\n\n        int outputStartLine = change.getStartLine(outputSide);\n        int outputEndLine = change.getEndLine(outputSide);\n        int sourceStartLine = change.getStartLine(sourceSide);\n        int sourceEndLine = change.getEndLine(sourceSide);\n\n        DiffUtil.applyModification(getContent(outputSide).getDocument(), outputEndLine, outputEndLine,\n                                   getContent(sourceSide).getDocument(), sourceStartLine, sourceEndLine);\n\n        int newOutputEndLine = outputEndLine + (sourceEndLine - sourceStartLine);\n        moveChangesAfterInsertion(change, outputStartLine, newOutputEndLine);\n      }","commit_id":"373eeb6f9b8617ce45eedd43fe565bbc0abedfe2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@CalledWithWriteLock\n      public void replaceChange(@NotNull TextMergeChange change, @NotNull Side side) {\n        ThreeSide sourceSide = side.select(ThreeSide.LEFT, ThreeSide.RIGHT);\n        ThreeSide outputSide = ThreeSide.BASE;\n\n        DiffUtil.applyModification(getContent(outputSide).getDocument(), change.getStartLine(outputSide), change.getEndLine(outputSide),\n                                   getContent(sourceSide).getDocument(), change.getStartLine(sourceSide), change.getEndLine(sourceSide));\n      }","id":74439,"modified_method":"@CalledWithWriteLock\n      public void replaceChange(@NotNull TextMergeChange change, @NotNull Side side) {\n        ThreeSide sourceSide = side.select(ThreeSide.LEFT, ThreeSide.RIGHT);\n        ThreeSide outputSide = ThreeSide.BASE;\n\n        int outputStartLine = change.getStartLine(outputSide);\n        int outputEndLine = change.getEndLine(outputSide);\n        int sourceStartLine = change.getStartLine(sourceSide);\n        int sourceEndLine = change.getEndLine(sourceSide);\n\n        DiffUtil.applyModification(getContent(outputSide).getDocument(), outputStartLine, outputEndLine,\n                                   getContent(sourceSide).getDocument(), sourceStartLine, sourceEndLine);\n\n        if (outputStartLine == outputEndLine) { // onBeforeDocumentChange() should process other cases correctly\n          int newOutputEndLine = outputStartLine + (sourceEndLine - sourceStartLine);\n          moveChangesAfterInsertion(change, outputStartLine, newOutputEndLine);\n        }\n      }","commit_id":"373eeb6f9b8617ce45eedd43fe565bbc0abedfe2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static PsiDocComment getDocComment(final PsiDocCommentOwner docOwner) {\n    return ((PsiDocCommentOwner)docOwner.getNavigationElement()).getDocComment();\n  }","id":74440,"modified_method":"@Nullable\n  private static PsiDocComment getDocComment(final PsiDocCommentOwner docOwner) {\n    PsiDocComment comment = ((PsiDocCommentOwner)docOwner.getNavigationElement()).getDocComment();\n    if (comment == null) { //check for non-normalized fields\n      final PsiModifierList modifierList = docOwner.getModifierList();\n      if (modifierList != null) {\n        final PsiElement parent = modifierList.getParent();\n        if (parent instanceof PsiDocCommentOwner) {\n          return ((PsiDocCommentOwner)parent.getNavigationElement()).getDocComment();\n        }\n      }\n    }\n    return comment;\n  }","commit_id":"75fb3e76979991fbfbe34bb3b1dc75582f7d4042","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Map<TypeElement, Map<String, CodecModel>> createAllCodecModel(Lang lang) {\n        Map<TypeElement, Map<String, CodecModel>> model = new HashMap<TypeElement, Map<String, CodecModel>>();\n\n        for (Map.Entry<TypeElement, Map<String, ExecutableElement>> entry : requestMap.entrySet()) {\n            HashMap<String, CodecModel> map = new HashMap<String, CodecModel>();\n            TypeElement parent = entry.getKey();\n            model.put(parent, map);\n\n\n            for (Map.Entry<String, ExecutableElement> entrySub : entry.getValue().entrySet()) {\n                ExecutableElement methodElement = entrySub.getValue();\n                CodecModel codecModel = createCodecModel(methodElement, lang);\n                codecModel.comment = elementUtils.getDocComment(methodElement);\n                map.put(entrySub.getKey(), codecModel);\n            }\n        }\n        return model;\n    }","id":74441,"modified_method":"private Map<TypeElement, Map<String, CodecModel>> createAllCodecModel(Lang lang) {\n        Map<TypeElement, Map<String, CodecModel>> model = new HashMap<TypeElement, Map<String, CodecModel>>();\n\n        for (Map.Entry<TypeElement, Map<String, ExecutableElement>> entry : requestMap.entrySet()) {\n            HashMap<String, CodecModel> map = new HashMap<String, CodecModel>();\n            TypeElement parent = entry.getKey();\n            model.put(parent, map);\n\n\n            for (Map.Entry<String, ExecutableElement> entrySub : entry.getValue().entrySet()) {\n                ExecutableElement methodElement = entrySub.getValue();\n                CodecModel codecModel = createCodecModel(methodElement, lang);\n                String docComment = elementUtils.getDocComment(methodElement);\n                if (null != docComment) {\n                    codecModel.setComment(docComment);\n                }\n                map.put(entrySub.getKey(), codecModel);\n            }\n        }\n        return model;\n    }","commit_id":"8180aa02aff2ad0c79e027b29d98f02354a36e6e","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public static PsiClass doMoveClass(PsiClass aClass, MoveDestination moveDestination, UsageInfo[] usages)\n    throws IncorrectOperationException {\n\n    PsiFile file = aClass.getContainingFile();\n    PsiDirectory newDirectory = moveDestination.getTargetDirectory(file);\n\n    PsiClass newClass;\n    if (file instanceof PsiJavaFile && ((PsiJavaFile)file).getClasses().length > 1) {\n      correctSelfReferences(aClass, newDirectory.getPackage());\n      final PsiClass created = newDirectory.createClass(aClass.getName());\n      if (aClass.getDocComment() == null && created.getDocComment() != null) {\n        aClass.addAfter(created.getDocComment(), null);\n      }\n      newClass = (PsiClass)created.replace(aClass);\n      aClass.delete();\n    }\n    else {\n      newClass = aClass;\n      if (!newDirectory.equals(file.getContainingDirectory())) {\n        aClass.getManager().moveFile(file, newDirectory);\n        if (file instanceof PsiJavaFile) {\n          setPackageStatement((PsiJavaFile)file, newDirectory.getPackage());\n        }\n      }\n    }\n\n    // rebind all references\n    for (UsageInfo usage1 : usages) {\n      MoveRenameUsageInfo usage = (MoveRenameUsageInfo)usage1;\n      if (usage.getElement() == null) continue;\n      PsiReference reference = usage.getReference();\n      if (reference != null) {\n        PsiElement parent = reference.getElement().getParent();\n        if (parent instanceof PsiImportStatement) {\n          if (parent.getContainingFile().getContainingDirectory().equals(newDirectory)) {\n            parent.delete(); // remove import statement to the class in the same package\n            continue;\n          }\n        }\n\n        reference.bindToElement(newClass);\n      }\n    }\n\n    return newClass;\n  }","id":74442,"modified_method":"public static PsiClass doMoveClass(PsiClass aClass, MoveDestination moveDestination, UsageInfo[] usages)\n    throws IncorrectOperationException {\n\n    PsiFile file = aClass.getContainingFile();\n    PsiDirectory newDirectory = moveDestination.getTargetDirectory(file);\n\n    PsiClass newClass;\n    if (file instanceof PsiJavaFile && ((PsiJavaFile)file).getClasses().length > 1) {\n      correctSelfReferences(aClass, newDirectory.getPackage());\n      final PsiClass created = newDirectory.createClass(aClass.getName());\n      if (aClass.getDocComment() == null) {\n        final PsiDocComment createdDocComment = created.getDocComment();\n        if (createdDocComment != null) {\n          aClass.addAfter(createdDocComment, null);\n        }\n      }\n      newClass = (PsiClass)created.replace(aClass);\n      aClass.delete();\n    }\n    else {\n      newClass = aClass;\n      if (!newDirectory.equals(file.getContainingDirectory())) {\n        aClass.getManager().moveFile(file, newDirectory);\n        if (file instanceof PsiJavaFile) {\n          setPackageStatement((PsiJavaFile)file, newDirectory.getPackage());\n        }\n      }\n    }\n\n    // rebind all references\n    for (UsageInfo usage1 : usages) {\n      MoveRenameUsageInfo usage = (MoveRenameUsageInfo)usage1;\n      if (usage.getElement() == null) continue;\n      PsiReference reference = usage.getReference();\n      if (reference != null) {\n        PsiElement parent = reference.getElement().getParent();\n        if (parent instanceof PsiImportStatement) {\n          if (parent.getContainingFile().getContainingDirectory().equals(newDirectory)) {\n            parent.delete(); // remove import statement to the class in the same package\n            continue;\n          }\n        }\n\n        reference.bindToElement(newClass);\n      }\n    }\n\n    return newClass;\n  }","commit_id":"faa449150a78aafde12fa9e727e86c773467b964","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ClassMemberHolder(Project project, String classSource) {\n      myClassSource = classSource;\n\n      final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(project);\n\n      myClass = (GrTypeDefinition)elementFactory.createGroovyFile(classSource, false, null).getClasses()[0];\n\n      // Collect fields.\n      myFieldMap = new HashMap<String, PsiField[]>();\n      myStaticFieldMap = new HashMap<String, PsiField[]>();\n      myNonStaticFieldMap = new HashMap<String, PsiField[]>();\n\n      GrField[] fields = myClass.getFields();\n\n      PsiField[] allFields = new PsiField[fields.length];\n\n      int i = 0;\n      for (PsiField field : fields) {\n        PsiField dynamicField = new MyGrDynamicPropertyImpl(myClass, (GrField)field, null, classSource);\n        PsiField[] dynamicFieldArray = new PsiField[]{dynamicField};\n\n        if (field.hasModifierProperty(PsiModifier.STATIC)) {\n          myStaticFieldMap.put(field.getName(), dynamicFieldArray);\n        }\n        else {\n          myNonStaticFieldMap.put(field.getName(), dynamicFieldArray);\n        }\n\n        Object oldValue = myFieldMap.put(field.getName(), dynamicFieldArray);\n        assert oldValue == null : \"Duplicated field in dynamic class: \" + myClass.getName() + \":\" + field.getName();\n\n        allFields[i++] = dynamicField;\n      }\n\n      myFieldMap.put(null, allFields);\n\n      // Collect methods..\n      checkDuplicatedMethods(myClass);\n\n      MultiMap<String, PsiMethod> multiMap = new MultiMap<String, PsiMethod>();\n      MultiMap<String, PsiMethod> staticMultiMap = new MultiMap<String, PsiMethod>();\n      MultiMap<String, PsiMethod> nonStaticMultiMap = new MultiMap<String, PsiMethod>();\n\n      for (GrMethod method : myClass.getGroovyMethods()) {\n        PsiMethod dynamicMethod = new GrDynamicMethodWithCache(method, classSource);\n\n        GrDocComment comment = method.getDocComment();\n        if (comment != null) {\n          Map<String, String> commentMap = new HashMap<String, String>();\n          for (GrDocTag tag : comment.getTags()) {\n            String tagText = tag.getText().trim();\n            String valueText = tag.getValueElement().getText().trim();\n            assert tagText.endsWith(valueText);\n            \n            commentMap.put(tagText.substring(0, tagText.length() - valueText.length()).trim(), valueText);\n          }\n          \n          dynamicMethod.putUserData(COMMENT_KEY, commentMap);\n        }\n\n        multiMap.putValue(null, dynamicMethod);\n        multiMap.putValue(method.getName(), dynamicMethod);\n\n        if (method.hasModifierProperty(PsiModifier.STATIC)) {\n          staticMultiMap.putValue(null, dynamicMethod);\n          staticMultiMap.putValue(method.getName(), dynamicMethod);\n        }\n        else {\n          nonStaticMultiMap.putValue(null, dynamicMethod);\n          nonStaticMultiMap.putValue(method.getName(), dynamicMethod);\n        }\n      }\n\n      myMethodMap = convertMap(multiMap);\n      myStaticMethodMap = convertMap(staticMultiMap);\n      myNonStaticMethodMap = convertMap(nonStaticMultiMap);\n    }","id":74443,"modified_method":"private ClassMemberHolder(Project project, String classSource) {\n      myClassSource = classSource;\n\n      final GroovyPsiElementFactory elementFactory = GroovyPsiElementFactory.getInstance(project);\n\n      myClass = (GrTypeDefinition)elementFactory.createGroovyFile(classSource, false, null).getClasses()[0];\n\n      Map<String, String> classCommentMap = parseComment(myClass.getDocComment());\n\n      // Collect fields.\n      myFieldMap = new HashMap<String, PsiField[]>();\n      myStaticFieldMap = new HashMap<String, PsiField[]>();\n      myNonStaticFieldMap = new HashMap<String, PsiField[]>();\n\n      GrField[] fields = myClass.getFields();\n\n      PsiField[] allFields = new PsiField[fields.length];\n\n      int i = 0;\n      for (PsiField field : fields) {\n        MyGrDynamicPropertyImpl dynamicField = new MyGrDynamicPropertyImpl(myClass, (GrField)field, null, classSource);\n\n        Map<String, String> commentMap = parseComment(((GrField)field).getDocComment());\n        String originalInfo = commentMap.get(\"originalInfo\");\n        if (originalInfo == null) {\n          originalInfo = classCommentMap.get(\"originalInfo\");\n        }\n        dynamicField.setOriginalInfo(originalInfo);\n\n        PsiField[] dynamicFieldArray = new PsiField[]{dynamicField};\n\n        if (field.hasModifierProperty(PsiModifier.STATIC)) {\n          myStaticFieldMap.put(field.getName(), dynamicFieldArray);\n        }\n        else {\n          myNonStaticFieldMap.put(field.getName(), dynamicFieldArray);\n        }\n\n        Object oldValue = myFieldMap.put(field.getName(), dynamicFieldArray);\n        assert oldValue == null : \"Duplicated field in dynamic class: \" + myClass.getName() + \":\" + field.getName();\n\n        allFields[i++] = dynamicField;\n      }\n\n      myFieldMap.put(null, allFields);\n\n      // Collect methods..\n      checkDuplicatedMethods(myClass);\n\n      MultiMap<String, PsiMethod> multiMap = new MultiMap<String, PsiMethod>();\n      MultiMap<String, PsiMethod> staticMultiMap = new MultiMap<String, PsiMethod>();\n      MultiMap<String, PsiMethod> nonStaticMultiMap = new MultiMap<String, PsiMethod>();\n\n      for (GrMethod method : myClass.getGroovyMethods()) {\n        GrDynamicMethodWithCache dynamicMethod = new GrDynamicMethodWithCache(method, classSource);\n\n        Map<String, String> commentMap = parseComment(method.getDocComment());\n        if (!commentMap.isEmpty()) {\n          dynamicMethod.putUserData(COMMENT_KEY, commentMap);\n        }\n\n        String originalInfo = commentMap.get(\"originalInfo\");\n        if (originalInfo == null) {\n          originalInfo = classCommentMap.get(\"originalInfo\");\n        }\n        dynamicMethod.setOriginalInfo(originalInfo);\n\n        multiMap.putValue(null, dynamicMethod);\n        multiMap.putValue(method.getName(), dynamicMethod);\n\n        if (method.hasModifierProperty(PsiModifier.STATIC)) {\n          staticMultiMap.putValue(null, dynamicMethod);\n          staticMultiMap.putValue(method.getName(), dynamicMethod);\n        }\n        else {\n          nonStaticMultiMap.putValue(null, dynamicMethod);\n          nonStaticMultiMap.putValue(method.getName(), dynamicMethod);\n        }\n      }\n\n      myMethodMap = convertMap(multiMap);\n      myStaticMethodMap = convertMap(staticMultiMap);\n      myNonStaticMethodMap = convertMap(nonStaticMultiMap);\n    }","commit_id":"85dc34c8415427488782773dbcec8ccb33bd3f15","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener) throws IOException {\n        server = worker.createStreamConnectionServer(socketAddress, acceptListener, OptionMap.builder().addAll(commonOptions).addAll(socketOptions).getMap());\n        server.resumeAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"AJP\", getName(), binding.getValue().getSocketAddress());\n    }","id":74444,"modified_method":"@Override\n    void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener) throws IOException {\n        server = worker.createStreamConnectionServer(socketAddress, acceptListener, OptionMap.builder().addAll(commonOptions).addAll(socketOptions).getMap());\n        server.resumeAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"AJP\", getName(), NetworkUtils.formatIPAddressForURI(binding.getValue().getSocketAddress().getAddress()), binding.getValue().getPort());\n    }","commit_id":"31d6b7a1c72e404c41081410315a423aeaffe9ec","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    void stopListening() {\n        server.suspendAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerSuspend(\"AJP\", getName());\n        IoUtils.safeClose(server);\n        UndertowLogger.ROOT_LOGGER.listenerStopped(\"AJP\", getName(), getBinding().getValue().getSocketAddress());\n    }","id":74445,"modified_method":"@Override\n    void stopListening() {\n        server.suspendAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerSuspend(\"AJP\", getName());\n        IoUtils.safeClose(server);\n        UndertowLogger.ROOT_LOGGER.listenerStopped(\"AJP\", getName(), NetworkUtils.formatIPAddressForURI(getBinding().getValue().getSocketAddress().getAddress()), getBinding().getValue().getPort());\n    }","commit_id":"31d6b7a1c72e404c41081410315a423aeaffe9ec","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void stopListening() {\n        server.suspendAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerSuspend(\"HTTP\", getName());\n        IoUtils.safeClose(server);\n        server = null;\n        UndertowLogger.ROOT_LOGGER.listenerStopped(\"HTTP\", getName(), getBinding().getValue().getSocketAddress());\n        httpListenerRegistry.getValue().removeListener(getName());\n    }","id":74446,"modified_method":"@Override\n    protected void stopListening() {\n        server.suspendAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerSuspend(\"HTTP\", getName());\n        IoUtils.safeClose(server);\n        server = null;\n        UndertowLogger.ROOT_LOGGER.listenerStopped(\"HTTP\", getName(), NetworkUtils.formatIPAddressForURI(getBinding().getValue().getSocketAddress().getAddress()), getBinding().getValue().getPort());\n        httpListenerRegistry.getValue().removeListener(getName());\n    }","commit_id":"31d6b7a1c72e404c41081410315a423aeaffe9ec","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener)\n            throws IOException {\n        server = worker.createStreamConnectionServer(socketAddress, acceptListener, OptionMap.builder().addAll(commonOptions).addAll(socketOptions).getMap());\n        server.resumeAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"HTTP\", getName(), socketAddress);\n    }","id":74447,"modified_method":"protected void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener)\n            throws IOException {\n        server = worker.createStreamConnectionServer(socketAddress, acceptListener, OptionMap.builder().addAll(commonOptions).addAll(socketOptions).getMap());\n        server.resumeAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"HTTP\", getName(), NetworkUtils.formatIPAddressForURI(socketAddress.getAddress()), socketAddress.getPort());\n    }","commit_id":"31d6b7a1c72e404c41081410315a423aeaffe9ec","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void stopListening() {\n        sslServer.suspendAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerSuspend(\"HTTPS\", getName());\n        IoUtils.safeClose(sslServer);\n        sslServer = null;\n        UndertowLogger.ROOT_LOGGER.listenerStopped(\"HTTPS\", getName(), getBinding().getValue().getSocketAddress());\n        httpListenerRegistry.getValue().removeListener(getName());\n    }","id":74448,"modified_method":"@Override\n    protected void stopListening() {\n        sslServer.suspendAccepts();\n        UndertowLogger.ROOT_LOGGER.listenerSuspend(\"HTTPS\", getName());\n        IoUtils.safeClose(sslServer);\n        sslServer = null;\n        UndertowLogger.ROOT_LOGGER.listenerStopped(\"HTTPS\", getName(), NetworkUtils.formatIPAddressForURI(getBinding().getValue().getSocketAddress().getAddress()), getBinding().getValue().getPort());\n        httpListenerRegistry.getValue().removeListener(getName());\n    }","commit_id":"31d6b7a1c72e404c41081410315a423aeaffe9ec","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener) throws IOException {\n\n        SSLContext sslContext = securityRealm.getValue().getSSLContext();\n        Builder builder = OptionMap.builder().addAll(commonOptions);\n        builder.addAll(socketOptions);\n        builder.set(Options.USE_DIRECT_BUFFERS, true);\n        OptionMap combined = builder.getMap();\n\n        XnioSsl xnioSsl = new UndertowXnioSsl(worker.getXnio(), combined, sslContext);\n        sslServer = xnioSsl.createSslConnectionServer(worker, socketAddress, (ChannelListener) acceptListener, combined);\n        sslServer.resumeAccepts();\n\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"HTTPS\", getName(), socketAddress);\n    }","id":74449,"modified_method":"@Override\n    protected void startListening(XnioWorker worker, InetSocketAddress socketAddress, ChannelListener<AcceptingChannel<StreamConnection>> acceptListener) throws IOException {\n\n        SSLContext sslContext = securityRealm.getValue().getSSLContext();\n        Builder builder = OptionMap.builder().addAll(commonOptions);\n        builder.addAll(socketOptions);\n        builder.set(Options.USE_DIRECT_BUFFERS, true);\n        OptionMap combined = builder.getMap();\n\n        XnioSsl xnioSsl = new UndertowXnioSsl(worker.getXnio(), combined, sslContext);\n        sslServer = xnioSsl.createSslConnectionServer(worker, socketAddress, (ChannelListener) acceptListener, combined);\n        sslServer.resumeAccepts();\n\n        UndertowLogger.ROOT_LOGGER.listenerStarted(\"HTTPS\", getName(), NetworkUtils.formatIPAddressForURI(socketAddress.getAddress()), socketAddress.getPort());\n    }","commit_id":"31d6b7a1c72e404c41081410315a423aeaffe9ec","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n   * Get the tags for the given resources, grouped by ID and ordered for display.\n   * \n   * @param owner The account for the tags\n   * @param identifiers The resource identifiers for the tags\n   * @return The tag map with an entry for each requested resource\n   */\n  public Map<String,List<Tag>> getResourceTagMap( final OwnerFullName owner,\n                                                  final Iterable<String> identifiers ) {\n    final Map<String,List<Tag>> tagMap = Maps.newHashMap();\n    for ( final String id : identifiers ) {\n      tagMap.put( id, Lists.<Tag>newArrayList() );\n    }\n    if ( !tagMap.isEmpty() ) {\n      final Tag example = example( owner );\n      final DetachedCriteria detachedCriteria = DetachedCriteria.forClass( resourceClass )\n          .add( Restrictions.in( resourceClassIdField, Lists.newArrayList( identifiers ) ) )\n          .setProjection( Projections.id() );\n      final Criterion idRestriction = Property.forName( tagClassResourceField ).in( detachedCriteria );\n      try {\n        final List<Tag> tags = Tags.list( example, Predicates.alwaysTrue(), idRestriction, Collections.<String,String>emptyMap()  );\n        for ( final Tag tag : tags ) {\n          tagMap.get( tag.getResourceId() ).add( tag );\n        }\n      } catch ( Exception e ) {\n        log.error( e, e );\n      }\n      Ordering<Tag> order = Ordering.natural().onResultOf( Tags.key() );\n      for ( final String id : identifiers ) {\n        Collections.sort( tagMap.get( id ), order );\n      }\n    }\n    return tagMap;\n  }","id":74450,"modified_method":"/**\n   * Get the tags for the given resources, grouped by ID and ordered for display.\n   * \n   * @param owner The account for the tags\n   * @param identifiers The resource identifiers for the tags\n   * @return The tag map with an entry for each requested resource\n   */\n  public Map<String,List<Tag>> getResourceTagMap( final OwnerFullName owner,\n                                                  final Iterable<String> identifiers ) {\n    final int identifiersSize = Iterables.size( identifiers );\n    final Map<String,List<Tag>> tagMap = Maps.newHashMapWithExpectedSize( identifiersSize );\n    for ( final String id : identifiers ) {\n      tagMap.put( id, Lists.<Tag>newArrayList() );\n    }\n    if ( !tagMap.isEmpty() ) {\n      final Tag example = example( owner );\n      final Criterion idRestriction = identifiersSize < 1000 ?\n          Property.forName( tagClassResourceField ).in( DetachedCriteria.forClass( resourceClass )\n              .add( Restrictions.in( resourceClassIdField, Lists.newArrayList( identifiers ) ) )\n              .setProjection( Projections.id( ) ) ) :\n          Restrictions.conjunction( );\n      try {\n        final List<Tag> tags = Tags.list( example, Predicates.alwaysTrue(), idRestriction, Collections.<String,String>emptyMap()  );\n        for ( final Tag tag : tags ) {\n          final List<Tag> keyTags = tagMap.get( tag.getResourceId( ) );\n          if ( keyTags != null ) {\n            keyTags.add( tag );\n          }\n        }\n      } catch ( Exception e ) {\n        log.error( e, e );\n      }\n      Ordering<Tag> order = Ordering.natural().onResultOf( Tags.key() );\n      for ( final String id : identifiers ) {\n        Collections.sort( tagMap.get( id ), order );\n      }\n    }\n    return tagMap;\n  }","commit_id":"6e73a3f1312f0893dc2dfba51727110193021cfb","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"@Override protected void configure() {\n        MapBinder<String, CharFilterFactoryFactory> charFilterBinder\n                = MapBinder.newMapBinder(binder(), String.class, CharFilterFactoryFactory.class);\n\n        // CHAR FILTERS\n\n        AnalysisBinderProcessor.CharFiltersBindings charFiltersBindings = new AnalysisBinderProcessor.CharFiltersBindings();\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processCharFilters(charFiltersBindings);\n        }\n\n        Map<String, Settings> charFiltersSettings = settings.getGroups(\"index.analysis.char_filter\");\n        for (Map.Entry<String, Settings> entry : charFiltersSettings.entrySet()) {\n            String charFilterName = entry.getKey();\n            Settings charFilterSettings = entry.getValue();\n\n            Class<? extends CharFilterFactory> type = null;\n            try {\n                type = charFilterSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"CharFilterFactory\");\n            } catch (NoClassSettingsException e) {\n                // nothing found, see if its in bindings as a binding name\n                if (charFilterSettings.get(\"type\") != null) {\n                    type = charFiltersBindings.charFilters.get(charFilterSettings.get(\"type\"));\n                }\n            }\n            if (type == null) {\n                // nothing found, see if its in bindings as a binding name\n                throw new ElasticSearchIllegalArgumentException(\"Char Filter [\" + charFilterName + \"] must have a type associated with it\");\n            }\n            charFilterBinder.addBinding(charFilterName).toProvider(FactoryProvider.newFactory(CharFilterFactoryFactory.class, type)).in(Scopes.SINGLETON);\n        }\n        // go over the char filters in the bindings and register the ones that are not configured\n        for (Map.Entry<String, Class<? extends CharFilterFactory>> entry : charFiltersBindings.charFilters.entrySet()) {\n            String charFilterName = entry.getKey();\n            Class<? extends CharFilterFactory> clazz = entry.getValue();\n            // we don't want to re-register one that already exists\n            if (charFiltersSettings.containsKey(charFilterName)) {\n                continue;\n            }\n            // check, if it requires settings, then don't register it, we know default has no settings...\n            if (clazz.getAnnotation(AnalysisSettingsRequired.class) != null) {\n                continue;\n            }\n            // register it as default under the name\n            charFilterBinder.addBinding(charFilterName).toProvider(FactoryProvider.newFactory(CharFilterFactoryFactory.class, clazz)).in(Scopes.SINGLETON);\n        }\n\n\n        // TOKEN FILTERS\n\n        MapBinder<String, TokenFilterFactoryFactory> tokenFilterBinder\n                = MapBinder.newMapBinder(binder(), String.class, TokenFilterFactoryFactory.class);\n\n        // initial default bindings\n        AnalysisBinderProcessor.TokenFiltersBindings tokenFiltersBindings = new AnalysisBinderProcessor.TokenFiltersBindings();\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processTokenFilters(tokenFiltersBindings);\n        }\n\n        Map<String, Settings> tokenFiltersSettings = settings.getGroups(\"index.analysis.filter\");\n        for (Map.Entry<String, Settings> entry : tokenFiltersSettings.entrySet()) {\n            String tokenFilterName = entry.getKey();\n            Settings tokenFilterSettings = entry.getValue();\n\n            Class<? extends TokenFilterFactory> type = null;\n            try {\n                type = tokenFilterSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"TokenFilterFactory\");\n            } catch (NoClassSettingsException e) {\n                // nothing found, see if its in bindings as a binding name\n                if (tokenFilterSettings.get(\"type\") != null) {\n                    type = tokenFiltersBindings.tokenFilters.get(tokenFilterSettings.get(\"type\"));\n                }\n            }\n            if (type == null) {\n                throw new ElasticSearchIllegalArgumentException(\"Token Filter [\" + tokenFilterName + \"] must have a type associated with it\");\n            }\n            tokenFilterBinder.addBinding(tokenFilterName).toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, type)).in(Scopes.SINGLETON);\n        }\n        // go over the filters in the bindings and register the ones that are not configured\n        for (Map.Entry<String, Class<? extends TokenFilterFactory>> entry : tokenFiltersBindings.tokenFilters.entrySet()) {\n            String tokenFilterName = entry.getKey();\n            Class<? extends TokenFilterFactory> clazz = entry.getValue();\n            // we don't want to re-register one that already exists\n            if (tokenFiltersSettings.containsKey(tokenFilterName)) {\n                continue;\n            }\n            // check, if it requires settings, then don't register it, we know default has no settings...\n            if (clazz.getAnnotation(AnalysisSettingsRequired.class) != null) {\n                continue;\n            }\n            // register it as default under the name\n            tokenFilterBinder.addBinding(tokenFilterName).toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, clazz)).in(Scopes.SINGLETON);\n        }\n\n        // TOKENIZER\n\n        MapBinder<String, TokenizerFactoryFactory> tokenizerBinder\n                = MapBinder.newMapBinder(binder(), String.class, TokenizerFactoryFactory.class);\n\n        Map<String, Settings> tokenizersSettings = settings.getGroups(\"index.analysis.tokenizer\");\n        for (Map.Entry<String, Settings> entry : tokenizersSettings.entrySet()) {\n            String tokenizerName = entry.getKey();\n            Settings tokenizerSettings = entry.getValue();\n\n            Class<? extends TokenizerFactory> type = tokenizerSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"TokenizerFactory\");\n            if (type == null) {\n                throw new ElasticSearchIllegalArgumentException(\"Tokenizer [\" + tokenizerName + \"] must have a type associated with it\");\n            }\n            tokenizerBinder.addBinding(tokenizerName).toProvider(FactoryProvider.newFactory(TokenizerFactoryFactory.class, type)).in(Scopes.SINGLETON);\n        }\n\n        AnalysisBinderProcessor.TokenizersBindings tokenizersBindings = new AnalysisBinderProcessor.TokenizersBindings(tokenizerBinder, tokenizersSettings);\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processTokenizers(tokenizersBindings);\n        }\n\n        // ANALYZER\n\n        MapBinder<String, AnalyzerProviderFactory> analyzerBinder\n                = MapBinder.newMapBinder(binder(), String.class, AnalyzerProviderFactory.class);\n\n        Map<String, Settings> analyzersSettings = settings.getGroups(\"index.analysis.analyzer\");\n        for (Map.Entry<String, Settings> entry : analyzersSettings.entrySet()) {\n            String analyzerName = entry.getKey();\n            Settings analyzerSettings = entry.getValue();\n            Class<? extends AnalyzerProvider> type = analyzerSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"AnalyzerProvider\");\n            if (type == null) {\n                // no specific type, check if it has a tokenizer associated with it\n                String tokenizerName = analyzerSettings.get(\"tokenizer\");\n                if (tokenizerName != null) {\n                    // we have a tokenizer, use the CustomAnalyzer\n                    type = CustomAnalyzerProvider.class;\n                } else {\n                    throw new ElasticSearchIllegalArgumentException(\"Analyzer [\" + analyzerName + \"] must have a type associated with it or a tokenizer\");\n                }\n            }\n            analyzerBinder.addBinding(analyzerName).toProvider(FactoryProvider.newFactory(AnalyzerProviderFactory.class, type)).in(Scopes.SINGLETON);\n        }\n\n        AnalysisBinderProcessor.AnalyzersBindings analyzersBindings = new AnalysisBinderProcessor.AnalyzersBindings(analyzerBinder, analyzersSettings, indicesAnalysisService);\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processAnalyzers(analyzersBindings);\n        }\n\n        bind(AnalysisService.class).in(Scopes.SINGLETON);\n    }","id":74451,"modified_method":"@Override protected void configure() {\n        MapBinder<String, CharFilterFactoryFactory> charFilterBinder\n                = MapBinder.newMapBinder(binder(), String.class, CharFilterFactoryFactory.class);\n\n        // CHAR FILTERS\n\n        AnalysisBinderProcessor.CharFiltersBindings charFiltersBindings = new AnalysisBinderProcessor.CharFiltersBindings();\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processCharFilters(charFiltersBindings);\n        }\n\n        Map<String, Settings> charFiltersSettings = settings.getGroups(\"index.analysis.char_filter\");\n        for (Map.Entry<String, Settings> entry : charFiltersSettings.entrySet()) {\n            String charFilterName = entry.getKey();\n            Settings charFilterSettings = entry.getValue();\n\n            Class<? extends CharFilterFactory> type = null;\n            try {\n                type = charFilterSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"CharFilterFactory\");\n            } catch (NoClassSettingsException e) {\n                // nothing found, see if its in bindings as a binding name\n                if (charFilterSettings.get(\"type\") != null) {\n                    type = charFiltersBindings.charFilters.get(charFilterSettings.get(\"type\"));\n                }\n            }\n            if (type == null) {\n                // nothing found, see if its in bindings as a binding name\n                throw new ElasticSearchIllegalArgumentException(\"Char Filter [\" + charFilterName + \"] must have a type associated with it\");\n            }\n            charFilterBinder.addBinding(charFilterName).toProvider(FactoryProvider.newFactory(CharFilterFactoryFactory.class, type)).in(Scopes.SINGLETON);\n        }\n        // go over the char filters in the bindings and register the ones that are not configured\n        for (Map.Entry<String, Class<? extends CharFilterFactory>> entry : charFiltersBindings.charFilters.entrySet()) {\n            String charFilterName = entry.getKey();\n            Class<? extends CharFilterFactory> clazz = entry.getValue();\n            // we don't want to re-register one that already exists\n            if (charFiltersSettings.containsKey(charFilterName)) {\n                continue;\n            }\n            // check, if it requires settings, then don't register it, we know default has no settings...\n            if (clazz.getAnnotation(AnalysisSettingsRequired.class) != null) {\n                continue;\n            }\n            // register it as default under the name\n            if (indicesAnalysisService != null && indicesAnalysisService.hasCharFilter(charFilterName)) {\n                charFilterBinder.addBinding(charFilterName).toInstance(indicesAnalysisService.charFilterFactoryFactory(charFilterName));\n            } else {\n                charFilterBinder.addBinding(charFilterName).toProvider(FactoryProvider.newFactory(CharFilterFactoryFactory.class, clazz)).in(Scopes.SINGLETON);\n            }\n        }\n\n\n        // TOKEN FILTERS\n\n        MapBinder<String, TokenFilterFactoryFactory> tokenFilterBinder\n                = MapBinder.newMapBinder(binder(), String.class, TokenFilterFactoryFactory.class);\n\n        // initial default bindings\n        AnalysisBinderProcessor.TokenFiltersBindings tokenFiltersBindings = new AnalysisBinderProcessor.TokenFiltersBindings();\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processTokenFilters(tokenFiltersBindings);\n        }\n\n        Map<String, Settings> tokenFiltersSettings = settings.getGroups(\"index.analysis.filter\");\n        for (Map.Entry<String, Settings> entry : tokenFiltersSettings.entrySet()) {\n            String tokenFilterName = entry.getKey();\n            Settings tokenFilterSettings = entry.getValue();\n\n            Class<? extends TokenFilterFactory> type = null;\n            try {\n                type = tokenFilterSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"TokenFilterFactory\");\n            } catch (NoClassSettingsException e) {\n                // nothing found, see if its in bindings as a binding name\n                if (tokenFilterSettings.get(\"type\") != null) {\n                    type = tokenFiltersBindings.tokenFilters.get(tokenFilterSettings.get(\"type\"));\n                }\n            }\n            if (type == null) {\n                throw new ElasticSearchIllegalArgumentException(\"Token Filter [\" + tokenFilterName + \"] must have a type associated with it\");\n            }\n            tokenFilterBinder.addBinding(tokenFilterName).toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, type)).in(Scopes.SINGLETON);\n        }\n        // go over the filters in the bindings and register the ones that are not configured\n        for (Map.Entry<String, Class<? extends TokenFilterFactory>> entry : tokenFiltersBindings.tokenFilters.entrySet()) {\n            String tokenFilterName = entry.getKey();\n            Class<? extends TokenFilterFactory> clazz = entry.getValue();\n            // we don't want to re-register one that already exists\n            if (tokenFiltersSettings.containsKey(tokenFilterName)) {\n                continue;\n            }\n            // check, if it requires settings, then don't register it, we know default has no settings...\n            if (clazz.getAnnotation(AnalysisSettingsRequired.class) != null) {\n                continue;\n            }\n            // register it as default under the name\n            if (indicesAnalysisService != null && indicesAnalysisService.hasTokenFilter(tokenFilterName)) {\n                tokenFilterBinder.addBinding(tokenFilterName).toInstance(indicesAnalysisService.tokenFilterFactoryFactory(tokenFilterName));\n            } else {\n                tokenFilterBinder.addBinding(tokenFilterName).toProvider(FactoryProvider.newFactory(TokenFilterFactoryFactory.class, clazz)).in(Scopes.SINGLETON);\n            }\n        }\n\n        // TOKENIZER\n\n        MapBinder<String, TokenizerFactoryFactory> tokenizerBinder\n                = MapBinder.newMapBinder(binder(), String.class, TokenizerFactoryFactory.class);\n\n        Map<String, Settings> tokenizersSettings = settings.getGroups(\"index.analysis.tokenizer\");\n        for (Map.Entry<String, Settings> entry : tokenizersSettings.entrySet()) {\n            String tokenizerName = entry.getKey();\n            Settings tokenizerSettings = entry.getValue();\n\n            Class<? extends TokenizerFactory> type = tokenizerSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"TokenizerFactory\");\n            if (type == null) {\n                throw new ElasticSearchIllegalArgumentException(\"Tokenizer [\" + tokenizerName + \"] must have a type associated with it\");\n            }\n            tokenizerBinder.addBinding(tokenizerName).toProvider(FactoryProvider.newFactory(TokenizerFactoryFactory.class, type)).in(Scopes.SINGLETON);\n        }\n\n        AnalysisBinderProcessor.TokenizersBindings tokenizersBindings = new AnalysisBinderProcessor.TokenizersBindings(tokenizerBinder, tokenizersSettings, indicesAnalysisService);\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processTokenizers(tokenizersBindings);\n        }\n\n        // ANALYZER\n\n        MapBinder<String, AnalyzerProviderFactory> analyzerBinder\n                = MapBinder.newMapBinder(binder(), String.class, AnalyzerProviderFactory.class);\n\n        Map<String, Settings> analyzersSettings = settings.getGroups(\"index.analysis.analyzer\");\n        for (Map.Entry<String, Settings> entry : analyzersSettings.entrySet()) {\n            String analyzerName = entry.getKey();\n            Settings analyzerSettings = entry.getValue();\n            Class<? extends AnalyzerProvider> type = analyzerSettings.getAsClass(\"type\", null, \"org.elasticsearch.index.analysis.\", \"AnalyzerProvider\");\n            if (type == null) {\n                // no specific type, check if it has a tokenizer associated with it\n                String tokenizerName = analyzerSettings.get(\"tokenizer\");\n                if (tokenizerName != null) {\n                    // we have a tokenizer, use the CustomAnalyzer\n                    type = CustomAnalyzerProvider.class;\n                } else {\n                    throw new ElasticSearchIllegalArgumentException(\"Analyzer [\" + analyzerName + \"] must have a type associated with it or a tokenizer\");\n                }\n            }\n            analyzerBinder.addBinding(analyzerName).toProvider(FactoryProvider.newFactory(AnalyzerProviderFactory.class, type)).in(Scopes.SINGLETON);\n        }\n\n        AnalysisBinderProcessor.AnalyzersBindings analyzersBindings = new AnalysisBinderProcessor.AnalyzersBindings(analyzerBinder, analyzersSettings, indicesAnalysisService);\n        for (AnalysisBinderProcessor processor : processors) {\n            processor.processAnalyzers(analyzersBindings);\n        }\n\n        bind(AnalysisService.class).in(Scopes.SINGLETON);\n    }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public TokenizersBindings(MapBinder<String, TokenizerFactoryFactory> binder, Map<String, Settings> groupSettings) {\n                this.binder = binder;\n                this.groupSettings = groupSettings;\n            }","id":74452,"modified_method":"public TokenizersBindings(MapBinder<String, TokenizerFactoryFactory> binder, Map<String, Settings> groupSettings, IndicesAnalysisService indicesAnalysisService) {\n                this.binder = binder;\n                this.groupSettings = groupSettings;\n                this.indicesAnalysisService = indicesAnalysisService;\n            }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public void processTokenizers(TokenizersBindings tokenizersBindings) {\n            tokenizersBindings.processTokenizer(\"standard\", StandardTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"uax_url_email\", UAX29URLEmailTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"uaxUrlEmail\", UAX29URLEmailTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"path_hierarchy\", PathHierarchyTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"pathHierarchy\", PathHierarchyTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"keyword\", KeywordTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"letter\", LetterTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"lowercase\", LowerCaseTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"whitespace\", WhitespaceTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"russian_letter\", RussianLetterTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"russianLetter\", RussianLetterTokenizerFactory.class);\n\n            tokenizersBindings.processTokenizer(\"nGram\", NGramTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"ngram\", NGramTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"edgeNGram\", EdgeNGramTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"edge_ngram\", EdgeNGramTokenizerFactory.class);\n        }","id":74453,"modified_method":"@Override public void processTokenizers(TokenizersBindings tokenizersBindings) {\n            tokenizersBindings.processTokenizer(\"standard\", StandardTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"uax_url_email\", UAX29URLEmailTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"uaxUrlEmail\", UAX29URLEmailTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"path_hierarchy\", PathHierarchyTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"pathHierarchy\", PathHierarchyTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"keyword\", KeywordTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"letter\", LetterTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"lowercase\", LowerCaseTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"whitespace\", WhitespaceTokenizerFactory.class);\n\n            tokenizersBindings.processTokenizer(\"nGram\", NGramTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"ngram\", NGramTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"edgeNGram\", EdgeNGramTokenizerFactory.class);\n            tokenizersBindings.processTokenizer(\"edge_ngram\", EdgeNGramTokenizerFactory.class);\n        }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public void processTokenizer(String name, Class<? extends TokenizerFactory> tokenizerFactory) {\n                if (!groupSettings.containsKey(name)) {\n                    binder.addBinding(name).toProvider(FactoryProvider.newFactory(TokenizerFactoryFactory.class, tokenizerFactory)).in(Scopes.SINGLETON);\n                }\n            }","id":74454,"modified_method":"public void processTokenizer(String name, Class<? extends TokenizerFactory> tokenizerFactory) {\n                if (!groupSettings.containsKey(name)) {\n                    if (indicesAnalysisService != null && indicesAnalysisService.hasTokenizer(name)) {\n                        binder.addBinding(name).toInstance(indicesAnalysisService.tokenizerFactoryFactory(name));\n                    } else {\n                        binder.addBinding(name).toProvider(FactoryProvider.newFactory(TokenizerFactoryFactory.class, tokenizerFactory)).in(Scopes.SINGLETON);\n                    }\n                }\n            }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public static ESLogger getLogger(String prefix, String name) {\n        return defaultFactory.newInstance(prefix.intern(), name.intern());\n    }","id":74455,"modified_method":"public static ESLogger getLogger(String prefix, String name) {\n        return defaultFactory.newInstance(prefix == null ? null : prefix.intern(), name.intern());\n    }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject public IndicesAnalysisService(Settings settings) {\n        super(settings);\n\n        StandardAnalyzer standardAnalyzer = new StandardAnalyzer(Lucene.ANALYZER_VERSION);\n        analyzerProviderFactories.put(\"default\", new PreBuiltAnalyzerProviderFactory(\"default\", AnalyzerScope.INDICES, standardAnalyzer));\n        analyzerProviderFactories.put(\"standard\", new PreBuiltAnalyzerProviderFactory(\"standard\", AnalyzerScope.INDICES, standardAnalyzer));\n        analyzerProviderFactories.put(\"keyword\", new PreBuiltAnalyzerProviderFactory(\"keyword\", AnalyzerScope.INDICES, new KeywordAnalyzer()));\n        analyzerProviderFactories.put(\"stop\", new PreBuiltAnalyzerProviderFactory(\"stop\", AnalyzerScope.INDICES, new StopAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"whitespace\", new PreBuiltAnalyzerProviderFactory(\"whitespace\", AnalyzerScope.INDICES, new WhitespaceAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"simple\", new PreBuiltAnalyzerProviderFactory(\"simple\", AnalyzerScope.INDICES, new SimpleAnalyzer(Lucene.ANALYZER_VERSION)));\n\n        // extended ones\n        analyzerProviderFactories.put(\"arabic\", new PreBuiltAnalyzerProviderFactory(\"arabic\", AnalyzerScope.INDICES, new ArabicAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"brazilian\", new PreBuiltAnalyzerProviderFactory(\"brazilian\", AnalyzerScope.INDICES, new BrazilianAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"chinese\", new PreBuiltAnalyzerProviderFactory(\"chinese\", AnalyzerScope.INDICES, new ChineseAnalyzer()));\n        analyzerProviderFactories.put(\"cjk\", new PreBuiltAnalyzerProviderFactory(\"cjk\", AnalyzerScope.INDICES, new ChineseAnalyzer()));\n        analyzerProviderFactories.put(\"czech\", new PreBuiltAnalyzerProviderFactory(\"czech\", AnalyzerScope.INDICES, new CzechAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"dutch\", new PreBuiltAnalyzerProviderFactory(\"dutch\", AnalyzerScope.INDICES, new DutchAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"french\", new PreBuiltAnalyzerProviderFactory(\"french\", AnalyzerScope.INDICES, new FrenchAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"german\", new PreBuiltAnalyzerProviderFactory(\"german\", AnalyzerScope.INDICES, new GermanAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"greek\", new PreBuiltAnalyzerProviderFactory(\"greek\", AnalyzerScope.INDICES, new GreekAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"persian\", new PreBuiltAnalyzerProviderFactory(\"persian\", AnalyzerScope.INDICES, new PersianAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"russian\", new PreBuiltAnalyzerProviderFactory(\"russian\", AnalyzerScope.INDICES, new RussianAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"thai\", new PreBuiltAnalyzerProviderFactory(\"thai\", AnalyzerScope.INDICES, new ThaiAnalyzer(Lucene.ANALYZER_VERSION)));\n    }","id":74456,"modified_method":"@Inject public IndicesAnalysisService(Settings settings) {\n        super(settings);\n\n        StandardAnalyzer standardAnalyzer = new StandardAnalyzer(Lucene.ANALYZER_VERSION);\n        analyzerProviderFactories.put(\"default\", new PreBuiltAnalyzerProviderFactory(\"default\", AnalyzerScope.INDICES, standardAnalyzer));\n        analyzerProviderFactories.put(\"standard\", new PreBuiltAnalyzerProviderFactory(\"standard\", AnalyzerScope.INDICES, standardAnalyzer));\n        analyzerProviderFactories.put(\"keyword\", new PreBuiltAnalyzerProviderFactory(\"keyword\", AnalyzerScope.INDICES, new KeywordAnalyzer()));\n        analyzerProviderFactories.put(\"stop\", new PreBuiltAnalyzerProviderFactory(\"stop\", AnalyzerScope.INDICES, new StopAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"whitespace\", new PreBuiltAnalyzerProviderFactory(\"whitespace\", AnalyzerScope.INDICES, new WhitespaceAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"simple\", new PreBuiltAnalyzerProviderFactory(\"simple\", AnalyzerScope.INDICES, new SimpleAnalyzer(Lucene.ANALYZER_VERSION)));\n\n        // extended ones\n        analyzerProviderFactories.put(\"pattern\", new PreBuiltAnalyzerProviderFactory(\"pattern\", AnalyzerScope.INDICES, new PatternAnalyzer(Lucene.ANALYZER_VERSION, Regex.compile(\"\\\\W+\" /*PatternAnalyzer.NON_WORD_PATTERN*/, null), true, StopAnalyzer.ENGLISH_STOP_WORDS_SET)));\n        analyzerProviderFactories.put(\"snowball\", new PreBuiltAnalyzerProviderFactory(\"snowball\", AnalyzerScope.INDICES, new SnowballAnalyzer(Lucene.ANALYZER_VERSION, \"English\", StopAnalyzer.ENGLISH_STOP_WORDS_SET)));\n        analyzerProviderFactories.put(\"standard_html_strip\", new PreBuiltAnalyzerProviderFactory(\"standard_html_strip\", AnalyzerScope.INDICES, new StandardHtmlStripAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"standardHtmlStrip\", new PreBuiltAnalyzerProviderFactory(\"standardHtmlStrip\", AnalyzerScope.INDICES, new StandardHtmlStripAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"arabic\", new PreBuiltAnalyzerProviderFactory(\"arabic\", AnalyzerScope.INDICES, new ArabicAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"brazilian\", new PreBuiltAnalyzerProviderFactory(\"brazilian\", AnalyzerScope.INDICES, new BrazilianAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"chinese\", new PreBuiltAnalyzerProviderFactory(\"chinese\", AnalyzerScope.INDICES, new ChineseAnalyzer()));\n        analyzerProviderFactories.put(\"cjk\", new PreBuiltAnalyzerProviderFactory(\"cjk\", AnalyzerScope.INDICES, new ChineseAnalyzer()));\n        analyzerProviderFactories.put(\"czech\", new PreBuiltAnalyzerProviderFactory(\"czech\", AnalyzerScope.INDICES, new CzechAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"dutch\", new PreBuiltAnalyzerProviderFactory(\"dutch\", AnalyzerScope.INDICES, new DutchAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"french\", new PreBuiltAnalyzerProviderFactory(\"french\", AnalyzerScope.INDICES, new FrenchAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"german\", new PreBuiltAnalyzerProviderFactory(\"german\", AnalyzerScope.INDICES, new GermanAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"greek\", new PreBuiltAnalyzerProviderFactory(\"greek\", AnalyzerScope.INDICES, new GreekAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"persian\", new PreBuiltAnalyzerProviderFactory(\"persian\", AnalyzerScope.INDICES, new PersianAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"russian\", new PreBuiltAnalyzerProviderFactory(\"russian\", AnalyzerScope.INDICES, new RussianAnalyzer(Lucene.ANALYZER_VERSION)));\n        analyzerProviderFactories.put(\"thai\", new PreBuiltAnalyzerProviderFactory(\"thai\", AnalyzerScope.INDICES, new ThaiAnalyzer(Lucene.ANALYZER_VERSION)));\n\n        // Base Tokenizers\n        tokenizerFactories.put(\"standard\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"standard\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new StandardTokenizer(Lucene.ANALYZER_VERSION, reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"uax_url_email\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"uax_url_email\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new UAX29URLEmailTokenizer(reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"uaxUrlEmail\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"uaxUrlEmail\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new UAX29URLEmailTokenizer(reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"path_hierarchy\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"path_hierarchy\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new PathHierarchyTokenizer(reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"pathHierarchy\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"pathHierarchy\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new PathHierarchyTokenizer(reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"keyword\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"keyword\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new KeywordTokenizer(reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"letter\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"letter\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new LetterTokenizer(Lucene.ANALYZER_VERSION, reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"lowercase\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"lowercase\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new LowerCaseTokenizer(Lucene.ANALYZER_VERSION, reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"whitespace\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"whitespace\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new WhitespaceTokenizer(Lucene.ANALYZER_VERSION, reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"nGram\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"nGram\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new NGramTokenizer(reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"ngram\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"ngram\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new NGramTokenizer(reader);\n            }\n        }));\n\n        tokenizerFactories.put(\"edgeNGram\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"edgeNGram\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new EdgeNGramTokenizer(reader, EdgeNGramTokenizer.DEFAULT_SIDE, EdgeNGramTokenizer.DEFAULT_MIN_GRAM_SIZE, EdgeNGramTokenizer.DEFAULT_MAX_GRAM_SIZE);\n            }\n        }));\n\n        tokenizerFactories.put(\"edge_ngram\", new PreBuiltTokenizerFactoryFactory(new TokenizerFactory() {\n            @Override public String name() {\n                return \"edge_ngram\";\n            }\n\n            @Override public Tokenizer create(Reader reader) {\n                return new EdgeNGramTokenizer(reader, EdgeNGramTokenizer.DEFAULT_SIDE, EdgeNGramTokenizer.DEFAULT_MIN_GRAM_SIZE, EdgeNGramTokenizer.DEFAULT_MAX_GRAM_SIZE);\n            }\n        }));\n\n        // Token Filters\n        tokenFilterFactories.put(\"stop\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"stop\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new StopFilter(Lucene.ANALYZER_VERSION, tokenStream, StopAnalyzer.ENGLISH_STOP_WORDS_SET);\n            }\n        }));\n\n        tokenFilterFactories.put(\"reverse\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"reverse\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new ReverseStringFilter(Lucene.ANALYZER_VERSION, tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"asciifolding\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"asciifolding\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new ASCIIFoldingFilter(tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"length\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"length\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new LengthFilter(true, tokenStream, 0, Integer.MAX_VALUE);\n            }\n        }));\n\n        tokenFilterFactories.put(\"lowercase\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"lowercase\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new LowerCaseFilter(Lucene.ANALYZER_VERSION, tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"porterStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"porterStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new PorterStemFilter(tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"porter_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"porter_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new PorterStemFilter(tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"standard\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"standard\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new StandardFilter(Lucene.ANALYZER_VERSION, tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"nGram\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"nGram\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new NGramTokenFilter(tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"ngram\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"ngram\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new NGramTokenFilter(tokenStream);\n            }\n        }));\n\n        tokenFilterFactories.put(\"edgeNGram\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"edgeNGram\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new EdgeNGramTokenFilter(tokenStream, EdgeNGramTokenFilter.DEFAULT_SIDE, EdgeNGramTokenFilter.DEFAULT_MIN_GRAM_SIZE, EdgeNGramTokenFilter.DEFAULT_MAX_GRAM_SIZE);\n            }\n        }));\n\n        tokenFilterFactories.put(\"edge_ngram\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"edge_ngram\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new EdgeNGramTokenFilter(tokenStream, EdgeNGramTokenFilter.DEFAULT_SIDE, EdgeNGramTokenFilter.DEFAULT_MIN_GRAM_SIZE, EdgeNGramTokenFilter.DEFAULT_MAX_GRAM_SIZE);\n            }\n        }));\n\n        tokenFilterFactories.put(\"shingle\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"shingle\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new ShingleFilter(tokenStream, ShingleFilter.DEFAULT_MAX_SHINGLE_SIZE);\n            }\n        }));\n\n        // Extended Token Filters\n        tokenFilterFactories.put(\"snowball\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"snowball\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new SnowballFilter(tokenStream, \"English\");\n            }\n        }));\n        tokenFilterFactories.put(\"arabicStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"arabicStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new ArabicStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"arabic_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"arabic_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new ArabicStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"brazilianStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"brazilianStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new BrazilianStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"brazilian_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"brazilian_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new BrazilianStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"czechStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"czechStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new CzechStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"czech_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"czech_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new CzechStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"dutchStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"dutchStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new DutchStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"dutch_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"dutch_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new DutchStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"frenchStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"frenchStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new FrenchStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"french_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"french_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new FrenchStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"germanStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"germanStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new GermanStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"german_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"german_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new GermanStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"russianStem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"russianStem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new RussianStemFilter(tokenStream);\n            }\n        }));\n        tokenFilterFactories.put(\"russian_stem\", new PreBuiltTokenFilterFactoryFactory(new TokenFilterFactory() {\n            @Override public String name() {\n                return \"russian_stem\";\n            }\n\n            @Override public TokenStream create(TokenStream tokenStream) {\n                return new RussianStemFilter(tokenStream);\n            }\n        }));\n\n        // Char Filter\n        charFilterFactories.put(\"html_strip\", new PreBuiltCharFilterFactoryFactory(new CharFilterFactory() {\n            @Override public String name() {\n                return \"html_strip\";\n            }\n\n            @Override public CharStream create(CharStream tokenStream) {\n                return new HTMLStripCharFilter(tokenStream);\n            }\n        }));\n\n        charFilterFactories.put(\"htmlStrip\", new PreBuiltCharFilterFactoryFactory(new CharFilterFactory() {\n            @Override public String name() {\n                return \"htmlStrip\";\n            }\n\n            @Override public CharStream create(CharStream tokenStream) {\n                return new HTMLStripCharFilter(tokenStream);\n            }\n        }));\n    }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject public LengthTokenFilterFactory(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {\n        super(index, indexSettings, name, settings);\n        min = settings.getAsInt(\"min\", 0);\n        max = settings.getAsInt(\"max\", Integer.MAX_VALUE);\n        enablePositionIncrements = settings.getAsBoolean(\"enabled_position_increments\", false);\n    }","id":74457,"modified_method":"@Inject public LengthTokenFilterFactory(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {\n        super(index, indexSettings, name, settings);\n        min = settings.getAsInt(\"min\", 0);\n        max = settings.getAsInt(\"max\", Integer.MAX_VALUE);\n        enablePositionIncrements = settings.getAsBoolean(\"enabled_position_increments\", true);\n    }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Inject public StandardHtmlStripAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {\n        super(index, indexSettings, name, settings);\n        analyzer = new CustomAnalyzer(new StandardTokenizerFactory(index, indexSettings, name, settings),\n                new CharFilterFactory[]{new HtmlStripCharFilterFactory(index, indexSettings, name, settings)},\n                new TokenFilterFactory[]{\n                        new StandardTokenFilterFactory(index, indexSettings, name, settings),\n                        new LowerCaseTokenFilterFactory(index, indexSettings, name, settings),\n                        new StopTokenFilterFactory(index, indexSettings, name, settings)\n                });\n    }","id":74458,"modified_method":"@Inject public StandardHtmlStripAnalyzerProvider(Index index, @IndexSettings Settings indexSettings, @Assisted String name, @Assisted Settings settings) {\n        super(index, indexSettings, name, settings);\n        analyzer = new StandardHtmlStripAnalyzer(version);\n    }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override public CustomAnalyzer get() {\n        return this.analyzer;\n    }","id":74459,"modified_method":"@Override public StandardHtmlStripAnalyzer get() {\n        return this.analyzer;\n    }","commit_id":"343c80b100c982ff9103ee9a6c192fa756dda6f2","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n        NodeProxy p;\n        if((p = ancestors.get(doc, gid)) != null) {\n            return p;\n        } else\n            return null;\n    }","id":74460,"modified_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n        NodeProxy p = ancestors.get(doc, gid);        \n        return p;            \n    }","commit_id":"6ca84761936921162ec8f0467749138dd1d27b23","url":"https://github.com/eXist-db/exist"},{"original_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n        \n        NodeProxy p = new NodeProxy(doc, gid);\n        if(p == null) \n            return null;         \n        NodeProxy contextNode;         \n        \n        //What is this mysterious condition apart a Constants.ATTRIBUTE_AXIS ???\n\t\tif (mysteriousCondition) {\n\t\t    //Like in SelfSelector            \n            contextNode = p;\n            if (rememberContext)\n                p.addContextNode(contextNode);\n            //no else clause !\n        } else {\n            //Like in ChildSelector            \n            contextNode = context.parentWithChild(doc, gid, true, false, NodeProxy.UNKNOWN_NODE_LEVEL);            \n\t\t\tif (contextNode == null)\n               return null;\n            if (rememberContext)\n                p.addContextNode(contextNode);\n            else\n                p.copyContext(contextNode);\n        }\n \t\treturn p;\t\t\t\n\t}","id":74461,"modified_method":"public NodeProxy match(DocumentImpl doc, long gid) {        \n        NodeProxy p = new NodeProxy(doc, gid);\n        if(p == null) \n            return null;         \n        NodeProxy contextNode = context.parentWithChild(doc, gid, true, false, NodeProxy.UNKNOWN_NODE_LEVEL);            \n\t\tif (contextNode == null)\n           return null;\n        if (rememberContext)\n            p.addContextNode(contextNode);\n        else\n            p.copyContext(contextNode);        \n \t\treturn p;\t\t\t\n\t}","commit_id":"6ca84761936921162ec8f0467749138dd1d27b23","url":"https://github.com/eXist-db/exist"},{"original_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n\t\tNodeProxy p;\n\t\tif((p = context.parentWithChild(doc, gid, false, true,\n\t\t\t\tNodeProxy.UNKNOWN_NODE_LEVEL )) != null) {\n\t\t\tNodeProxy newNode = new NodeProxy(doc, gid);\n\t\t\tif (rememberContext)\n\t\t\t\tnewNode.addContextNode(p);\n\t\t\telse\n\t\t\t\tnewNode.copyContext(p);\n\t\t\treturn newNode;\n\t\t}\n\t\treturn null;\n\t}","id":74462,"modified_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n        NodeProxy p = new NodeProxy(doc, gid);\n        if (p == null) \n            return null;    \n        NodeProxy contextNode = context.parentWithChild(doc, gid, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);\n        if(contextNode == null)\n            return null;        \n\t\tif (rememberContext)\n\t\t\tp.addContextNode(contextNode);\n\t\telse\n\t\t\tp.copyContext(contextNode);\n\t\treturn p;\n\n\t}","commit_id":"6ca84761936921162ec8f0467749138dd1d27b23","url":"https://github.com/eXist-db/exist"},{"original_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n\t\tNodeProxy p;\n\t\tif((p = context.parentWithChild(doc, gid, false, false,\n\t\t\t\tNodeProxy.UNKNOWN_NODE_LEVEL )) != null) {\n\t\t    NodeProxy newNode = new NodeProxy(doc, gid);\n\t\t\tif (rememberContext)\n\t\t\t\tnewNode.addContextNode(p);\n\t\t\telse\n\t\t\t\tnewNode.copyContext(p);\n\t\t\treturn newNode;\n\t\t}\n\t\treturn null;\n\t}","id":74463,"modified_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n        NodeProxy p = new NodeProxy(doc, gid);  \n        if (p == null) \n            return null;   \n\t\tNodeProxy contextNode = context.parentWithChild(doc, gid, false, false, NodeProxy.UNKNOWN_NODE_LEVEL);\n\t\tif (contextNode == null)\n            return null;\t    \n\t\tif (rememberContext)\n            p.addContextNode(contextNode);\n\t\telse\n            p.copyContext(contextNode);\n\t\treturn p;\n\t}","commit_id":"6ca84761936921162ec8f0467749138dd1d27b23","url":"https://github.com/eXist-db/exist"},{"original_method":"protected NodeSet getAttributes(XQueryContext context, NodeSet contextSet) {\t\t\n\t\tif (test.isWildcardTest()) {\n            NodeSet result = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t((VirtualNodeSet) result).setInPredicate(inPredicate);           \n            return result;\n\t\t// if there's just a single known node in the context, it is faster\n\t    // do directly search for the attribute in the parent node.\n        } else if(axis == Constants.ATTRIBUTE_AXIS && contextSet.getLength() == 1\n                && !(contextSet instanceof VirtualNodeSet)) {\n            NodeProxy proxy = contextSet.get(0);\n            if (proxy.getInternalAddress() != NodeProxy.UNKNOWN_NODE_ADDRESS)\n                return contextSet.directSelectAttribute(test.getName(), inPredicate);          \n        }       \n        if (preloadNodeSets()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) { \n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \n                            \"OPTIMIZATION\", \"using index '\" + index.toString() + \"'\");   \n                //TODO : why a null selector here ? We have one below !\n                currentSet = index.findElementsByTagName(ElementValue.ATTRIBUTE, docs, test.getName(), null);  \n                currentDocs = docs;      \n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, inPredicate);                              \n                case Constants.DESCENDANT_ATTRIBUTE_AXIS :             \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, false, inPredicate);                    \n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }       \n\t\t} else {\n\t\t\tNodeSelector selector;            \n            DocumentSet docs = getDocumentSet(contextSet);\n            //TODO : why a selector here ? We havn't one above !\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    selector = new ChildSelector(contextSet, inPredicate);  \n                    //TODO : find when this condition must be set !                                        \n                    //It should be for :\n                    //let $a := (<c id=\"1\"><d id=\"2\">d<\/d><e>e<\/e><\/c>)/descendant-or-self::node()\n                    //for $b in $a/attribute::id\n                    //return <b>{$b}<\/b>\n                    //Note that this expression also works with selector = null\n                    if (false) \n                        ((ChildSelector)selector).setMysteriousCondition();\n                    break;\n                case Constants.DESCENDANT_ATTRIBUTE_AXIS : \n                    selector = new DescendantSelector(contextSet, inPredicate); \n                    break;\n               default:\n                   throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n\t\t\t}    \t\t\t\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \n                        \"OPTIMIZATION\", \"using index '\" + index.toString() + \"'\");              \n            return index.getAttributesByName(docs, test.getName(), selector);            \n\t\t}    \n\t}","id":74464,"modified_method":"protected NodeSet getAttributes(XQueryContext context, NodeSet contextSet) {\t\t\n\t\tif (test.isWildcardTest()) {\n            NodeSet result = new VirtualNodeSet(axis, test, contextSet);\n\t\t\t((VirtualNodeSet) result).setInPredicate(inPredicate);           \n            return result;\n\t\t// if there's just a single known node in the context, it is faster\n\t    // do directly search for the attribute in the parent node.\n        } else if(axis == Constants.ATTRIBUTE_AXIS && contextSet.getLength() == 1\n                && !(contextSet instanceof VirtualNodeSet)) {\n            NodeProxy proxy = contextSet.get(0);\n            if (proxy.getInternalAddress() != NodeProxy.UNKNOWN_NODE_ADDRESS)\n                return contextSet.directSelectAttribute(test.getName(), inPredicate);          \n        }       \n        if (preloadNodeSets()) {\n            DocumentSet docs = getDocumentSet(contextSet);\n            if (currentSet == null || currentDocs == null || !(docs.equals(currentDocs))) { \n                ElementIndex index = context.getBroker().getElementIndex();\n                if (context.getProfiler().isEnabled())\n                    context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \n                            \"OPTIMIZATION\", \"using index '\" + index.toString() + \"'\");   \n                //TODO : why a null selector here ? We have one below !\n                currentSet = index.findElementsByTagName(ElementValue.ATTRIBUTE, docs, test.getName(), null);  \n                currentDocs = docs;      \n                registerUpdateListener();\n            }\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    return currentSet.selectParentChild(contextSet, NodeSet.DESCENDANT, inPredicate);                              \n                case Constants.DESCENDANT_ATTRIBUTE_AXIS :             \n                    return currentSet.selectAncestorDescendant(contextSet, NodeSet.DESCENDANT, false, inPredicate);                    \n                default:\n                    throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n            }       \n\t\t} else {\n\t\t\tNodeSelector selector;            \n            DocumentSet docs = getDocumentSet(contextSet);\n            //TODO : why a selector here ? We havn't one above !\n            switch (axis) {\n                case Constants.ATTRIBUTE_AXIS :\n                    selector = new ChildSelector(contextSet, inPredicate);  \n                    break;\n                case Constants.DESCENDANT_ATTRIBUTE_AXIS : \n                    selector = new DescendantSelector(contextSet, inPredicate); \n                    break;\n               default:\n                   throw new IllegalArgumentException(\"Unsupported axis specified\");                   \n\t\t\t}    \t\t\t\n            ElementIndex index = context.getBroker().getElementIndex();\n            if (context.getProfiler().isEnabled())\n                context.getProfiler().message(this, Profiler.OPTIMIZATIONS, \n                        \"OPTIMIZATION\", \"using index '\" + index.toString() + \"'\");              \n            return index.getAttributesByName(docs, test.getName(), selector);            \n\t\t}    \n\t}","commit_id":"6ca84761936921162ec8f0467749138dd1d27b23","url":"https://github.com/eXist-db/exist"},{"original_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n\t\tNodeProxy p;\n\t\tif((p = parents.get(doc, gid)) != null) {\n\t\t\treturn p;\n\t\t} else\n\t\t\treturn null;\n\t}","id":74465,"modified_method":"public NodeProxy match(DocumentImpl doc, long gid) {\n\t\tNodeProxy p = parents.get(doc, gid);\n        return p;\t\t\t\n\t}","commit_id":"6ca84761936921162ec8f0467749138dd1d27b23","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dropIndex(Collection collection) {        \n        Value ref = new ElementValue(collection.getId());\n        IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        Lock lock = dbValues.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            //TODO : flush ? -pb\n            dbValues.removeAll(query);\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);\n        } catch (BTreeException e) {\n            LOG.error(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.error(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","id":74466,"modified_method":"public void dropIndex(Collection collection) {        \n        final Value ref = new ElementValue(collection.getId());\n        final IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        final Lock lock = dbValues.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            //TODO : flush ? -pb\n            dbValues.removeAll(query);\n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);\n        } catch (BTreeException e) {\n            LOG.error(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.error(e.getMessage(), e);\n        } finally {\n            lock.release();\n        }\n    }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void dropIndex(DocumentImpl document) throws ReadOnlyException {\n        Value key;\n        Value value;\n        int gidsCount;\n        long delta;        \n        VariableByteArrayInput is;\n        int storedDocId;\n        boolean changed;        \n        final short collectionId = document.getCollection().getId();\n        final Value ref = new ElementValue(collectionId);\n        final IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        final Lock lock = dbValues.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            ArrayList elements = dbValues.findKeys(query);\n            for (int i = 0; i < elements.size(); i++) {\n                changed = false;\n                key = (Value) elements.get(i);\n                value = dbValues.get(key);                \n                is = new VariableByteArrayInput(value.getData());\n                os.clear();                \n                while (is.available() > 0) {\n                    storedDocId = is.readInt();\n                    gidsCount = is.readInt();                        \n\t\t\t\t\tif (storedDocId != document.getDocId()) {\n\t\t\t\t\t    // data are related to another document:\n                        // copy them to any existing data\n                        os.writeInt(storedDocId);\n                        os.writeInt(gidsCount);\n                        for (int j = 0; j < gidsCount; j++) {\n                            delta = is.readLong();\n                            os.writeLong(delta);\n                        }\n                    } else {\n                        // data are related to our document:\n                        // skip them                          \n                        is.skip(gidsCount);\n                        changed = true;\n                    }\n                }\n                //Store new data, if relevant\n                if (changed) {\n                    if (os.data().size() == 0) {\n                        //Well, nothing to store : remove the existing data\n                        dbValues.remove(key);\n                    } else {                      \n                        if (dbValues.put(key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                            LOG.warn(\"Could not put index data for value '\" +  ref + \"'\");\n                        }\n                    }\n                }\n            }            \n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);       \n        } catch (TerminatedException e) {\n            LOG.warn(e.getMessage(), e);            \n        } catch (BTreeException e) {\n            LOG.error(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.error(e.getMessage(), e);    \n        } finally {\n            lock.release();\n        }\n    }","id":74467,"modified_method":"public void dropIndex(DocumentImpl document) throws ReadOnlyException {    \n        final short collectionId = document.getCollection().getId();\n        final Value ref = new ElementValue(collectionId);\n        final IndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, ref);\n        final Lock lock = dbValues.getLock();\n        try {\n            lock.acquire(Lock.WRITE_LOCK);\n            ArrayList elements = dbValues.findKeys(query);\n            for (int i = 0; i < elements.size(); i++) {\n                boolean changed = false;\n                Value key = (Value) elements.get(i);\n                Value value = dbValues.get(key);                \n                VariableByteArrayInput is = new VariableByteArrayInput(value.getData());\n                os.clear();                \n                while (is.available() > 0) {\n                    int storedDocId = is.readInt();\n                    int gidsCount = is.readInt();                        \n\t\t\t\t\tif (storedDocId != document.getDocId()) {\n\t\t\t\t\t    // data are related to another document:\n                        // copy them to any existing data\n                        os.writeInt(storedDocId);\n                        os.writeInt(gidsCount);\n                        for (int j = 0; j < gidsCount; j++) {\n                            long delta = is.readLong();\n                            os.writeLong(delta);\n                        }\n                    } else {\n                        // data are related to our document:\n                        // skip them                          \n                        is.skip(gidsCount);\n                        changed = true;\n                    }\n                }\n                //Store new data, if relevant\n                if (changed) {\n                    if (os.data().size() == 0) {\n                        //Well, nothing to store : remove the existing data\n                        dbValues.remove(key);\n                    } else {                      \n                        if (dbValues.put(key, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                            LOG.warn(\"Could not put index data for value '\" +  ref + \"'\");\n                        }\n                    }\n                }\n            }            \n        } catch (LockException e) {\n            LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);       \n        } catch (TerminatedException e) {\n            LOG.warn(e.getMessage(), e);            \n        } catch (BTreeException e) {\n            LOG.error(e.getMessage(), e);\n        } catch (IOException e) {\n            LOG.error(e.getMessage(), e);    \n        } finally {\n            lock.release();\n        }\n    }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean indexInfo(Value key, long pointer) throws TerminatedException {\n            \n            AtomicValue atomic;\n            try {\n                atomic = ValueIndexFactory.deserialize(key.data(), key.start(), key.getLength());\n                if (atomic.getType() != type)\n                    return false;\n            } catch (EXistException e) {\n                LOG.error(e.getMessage(), e);\n                return true;\n            }\n            \n            VariableByteInput is;\n            try {\n                is = dbValues.getAsStream(pointer);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n                return true;\n            }   \n            \n            int storedDocId;\n            int gidsCount;\n            long storedGID; \n            long delta;       \n            DocumentImpl storedDocument;                \n            boolean docAdded;\n            ValueOccurrences oc = (ValueOccurrences) map.get(atomic);\n            try {\n                while (is.available() > 0) {\n                    docAdded = false;\n                    storedDocId = is.readInt();\n                    gidsCount = is.readInt();\n                    storedDocument = docs.getDoc(storedDocId); \n                    //Exit if the document is not concerned\n                    if (storedDocument == null) {\n                        is.skip(gidsCount);\n                        continue;\n                    }                    \n                    storedGID = 0;                    \n                    for (int j = 0; j < gidsCount; j++) {\n                        delta = is.readLong();\n                        storedGID = storedGID + delta;                        \n                        if (contextSet != null) {\n                            if (contextSet.parentWithChild(storedDocument, storedGID, false, true) != null) {\n                                if (oc == null) {\n                                    oc = new ValueOccurrences(atomic);\n                                    map.put(atomic, oc);\n                                }\n                                if (!docAdded) {\n                                    oc.addDocument(storedDocument);\n                                    docAdded = true;\n                                }\n                                oc.addOccurrences(1);\n                            }\n                        }\n                        //TODO : what if contextSet == null ? -pb\n                        //See above where we have this behaviour :\n                        //otherwise, we add all nodes without check                        \n                    }\n                }\n            } catch(EOFException e) {\n                //Is it expected ? -pb\n                LOG.warn(e.getMessage(), e);\n            } catch(IOException e) {\n                LOG.error(e.getMessage(), e);\n            }\n            return true;\n        }","id":74468,"modified_method":"public boolean indexInfo(Value key, long pointer) throws TerminatedException {            \n            AtomicValue atomic;\n            try {\n                atomic = ValueIndexFactory.deserialize(key.data(), key.start(), key.getLength());\n                if (atomic.getType() != type)\n                    return false;\n            } catch (EXistException e) {\n                LOG.error(e.getMessage(), e);\n                return true;\n            }\n            \n            VariableByteInput is;\n            try {\n                is = dbValues.getAsStream(pointer);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n                return true;\n            } \n            \n            ValueOccurrences oc = (ValueOccurrences) map.get(atomic);                        \n            try {\n                while (is.available() > 0) {\n                    boolean docAdded = false;\n                    int storedDocId = is.readInt();\n                    int gidsCount = is.readInt();\n                    DocumentImpl storedDocument = docs.getDoc(storedDocId); \n                    //Exit if the document is not concerned\n                    if (storedDocument == null) {\n                        is.skip(gidsCount);\n                        continue;\n                    }                    \n                    long previousGID = 0;                    \n                    for (int j = 0; j < gidsCount; j++) {\n                        long delta = is.readLong();\n                        long storedGID = previousGID + delta;                        \n                        if (contextSet != null) {\n                            NodeProxy parentNode = contextSet.parentWithChild(storedDocument, storedGID, false, true);\n                            if (parentNode != null) {                                \n                                if (oc == null) {\n                                    oc = new ValueOccurrences(atomic);\n                                    map.put(atomic, oc);\n                                }\n                                oc.addOccurrences(1);\n                                if (!docAdded) {                                \n                                    oc.addDocument(storedDocument);\n                                    docAdded = true;\n                                }                                \n                            }\n                        }\n                        //TODO : what if contextSet == null ? -pb\n                        //See above where we have this behaviour :\n                        //otherwise, we add all nodes without check    \n                        previousGID = storedGID;\n                    }\n                }\n            } catch(EOFException e) {\n                //Is it expected ? -pb\n                LOG.warn(e.getMessage(), e);\n            } catch(IOException e) {\n                LOG.error(e.getMessage(), e);\n            }\n            return true;\n        }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"public boolean indexInfo(Value value, long pointer) throws TerminatedException {\n            VariableByteInput is;\n\t\t\ttry {\n\t\t\t\tis = dbValues.getAsStream(pointer);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.error(e.getMessage(), e);\n                return true;\n\t\t\t}\n            \n            int storedDocId;            \n            int gidsCount;\n            long storedGID;\n            long delta;  \n            DocumentImpl storedDocument;        \n            NodeProxy storedNode, parentNode;            \n\t\t\ttry {\n                int sizeHint = -1;\n                while (is.available() > 0) {\n                    storedDocId = is.readInt();\n                \tgidsCount = is.readInt();\n                    storedDocument = docs.getDoc(storedDocId);\n                    //Exit if the document is not concerned\n                \tif (storedDocument == null) {\n                        is.skip(gidsCount);\n                        continue;                        \n                    }                \n                \tif (contextSet != null) { \n                        //Exit if the document is not concerned\n                \t    if (!contextSet.containsDoc(storedDocument)) {\n                \t        is.skip(gidsCount);\n                \t        continue;\n                        }                        \n                \t}\n                \t//Process the nodes\n                    storedGID = 0;                \t\n                \tfor (int j = 0; j < gidsCount; j++) {\n                        delta = is.readLong();\n                        storedGID = storedGID + delta;                        \n                        storedNode = new NodeProxy(storedDocument, storedGID);\t\t\t\t\t\t\n                \t\t// if a context set is specified, we can directly check if the\n                \t\t// matching node is a descendant of one of the nodes\n                \t\t// in the context set.\n                \t\tif (contextSet != null) {\n                            sizeHint = contextSet.getSizeHint(storedDocument);\n                            if (returnAncestor) {\n                                parentNode = contextSet.parentWithChild(storedNode, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);\n                                if (parentNode != null) \n                                    result.add(parentNode, sizeHint);\n                \t\t\t} else\n                                result.add(storedNode, sizeHint);\n                \t\t// otherwise, we add all nodes without check\n                \t\t} else {\n                \t\t\tresult.add(storedNode, -1);\n                \t\t}\n                \t}\n                }\n            } catch (EOFException e) {\n                // EOF is expected here\n            } catch (IOException e) {                \n                LOG.error(e.getMessage(), e);\n            }\n            return false;\n        }","id":74469,"modified_method":"public boolean indexInfo(Value value, long pointer) throws TerminatedException {\n            VariableByteInput is;\n\t\t\ttry {\n\t\t\t\tis = dbValues.getAsStream(pointer);\n\t\t\t} catch (IOException e) {\n\t\t\t\tLOG.error(e.getMessage(), e);\n                return true;\n\t\t\t}         \n\t\t\ttry {\n                int sizeHint = -1;\n                while (is.available() > 0) {\n                    int storedDocId = is.readInt();\n                    int gidsCount = is.readInt();\n                    DocumentImpl storedDocument = docs.getDoc(storedDocId);\n                    //Exit if the document is not concerned\n                \tif (storedDocument == null) {\n                        is.skip(gidsCount);\n                        continue;                        \n                    }                \n                \tif (contextSet != null) { \n                        //Exit if the document is not concerned\n                \t    if (!contextSet.containsDoc(storedDocument)) {\n                \t        is.skip(gidsCount);\n                \t        continue;\n                        }                        \n                \t}\n                \t//Process the nodes\n                    long storedGID = 0;                \t\n                \tfor (int j = 0; j < gidsCount; j++) {\n                        long delta = is.readLong();\n                        storedGID = storedGID + delta;                        \n                        NodeProxy storedNode = new NodeProxy(storedDocument, storedGID);\t\t\t\t\t\t\n                \t\t// if a context set is specified, we can directly check if the\n                \t\t// matching node is a descendant of one of the nodes\n                \t\t// in the context set.\n                \t\tif (contextSet != null) {\n                            sizeHint = contextSet.getSizeHint(storedDocument);\n                            if (returnAncestor) {\n                                NodeProxy parentNode = contextSet.parentWithChild(storedNode, false, true, NodeProxy.UNKNOWN_NODE_LEVEL);\n                                if (parentNode != null) \n                                    result.add(parentNode, sizeHint);\n                \t\t\t} else\n                                result.add(storedNode, sizeHint);\n                \t\t// otherwise, we add all nodes without check\n                \t\t} else {\n                \t\t\tresult.add(storedNode, -1);\n                \t\t}\n                \t}\n                }\n            } catch (EOFException e) {\n                // EOF is expected here\n            } catch (IOException e) {                \n                LOG.error(e.getMessage(), e);\n            }\n            return false;\n        }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void reindex(DocumentImpl document, NodeImpl node) {\n        if (pending.size() == 0) \n            return;        \n        Indexable indexable;\n        //TODO : NativeElementIndex uses ArrayLists -pb\n        LongLinkedList storedGIDList;\n        LongLinkedList newGIDList;\n        long[] gids;        \n        int gidsCount;\n        long storedGID;\n        long previousGID;        \n        long delta;        \n        Value ref;\n        Map.Entry entry;        \n        VariableByteInput is;        \n        int storedDocId;\n        long address;\n        final short collectionId = document.getCollection().getId();\n        final Lock lock = dbValues.getLock();              \n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            //Compute a key for the value\n            entry = (Map.Entry) i.next();\n            indexable = (Indexable) entry.getKey();\n            storedGIDList = (LongLinkedList) entry.getValue();\n            ref = new Value(indexable.serialize(collectionId, caseSensitive)); \n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                is = dbValues.getAsStream(ref);\n                os.clear();\n                newGIDList = new LongLinkedList();\n                //Does the value already has data in the index ?\n                if (is != null) {                    \n                    try {\n                        while (is.available() > 0) {\n                            storedDocId = is.readInt();\n                            gidsCount = is.readInt();\n                            if (storedDocId != document.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(gidsCount);\n                                os.writeInt(gidsCount);\n                                is.copyTo(os, gidsCount);\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs                                    \n                                previousGID = 0;\n                                for (int j = 0; j < gidsCount; j++) {\n                                    delta = is.readLong();\n                                    storedGID = previousGID + delta;    \n                                    if (node == null) {\n                                        if (document.getTreeLevel(storedGID) < document.reindexRequired())\n                                            storedGIDList.add(storedGID);\n                                    } else {\n                                         if (!XMLUtil.isDescendant(document, node.getGID(), storedGID))\n                                             //TO UNDERSTAND : what will these GIDs become ? -pb\n                                             newGIDList.add(storedGID);\n                                    }\n                                    previousGID = storedGID;\n                                }\n                            }\n                        }\n                    } catch (EOFException e) {\n                        //Is it expected ? Remove this block if not -pb\n                        LOG.warn(e.getMessage(), e);\n                    }\n                }\n                // append the new list to any existing data\n                gids = storedGIDList.getData();\n                gidsCount = gids.length;\n                //Don't forget this one\n                Arrays.sort(gids);\n                os.writeInt(document.getDocId());\n                os.writeInt(gidsCount);\n                previousGID = 0;\n                for (int j = 0; j < gidsCount; j++) {\n                    delta = gids[j] - previousGID;                        \n                    os.writeLong(delta);\n                    previousGID = gids[j];\n                }\n                //Store the data\n                if (is == null) {\n                    //TOUNDERSTAND : Should is be null, what will there be in os.data() ? -pb\n                    if (dbValues.put(ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not put index data for value '\" +  ref + \"'\");\n                    }\n                } else {\n                    address = ((BFile.PageInputStream) is).getAddress();\n                    if (dbValues.update(address, ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not update index data for value '\" +  ref + \"'\");\n                    }\n                }\n                \n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);     \n                return;\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n                is = null;\n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(e.getMessage(), e);  \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n            }\n        }\n        pending.clear();\n    }","id":74470,"modified_method":"public void reindex(DocumentImpl document, NodeImpl node) {\n        if (pending.size() == 0) \n            return;        \n        final short collectionId = document.getCollection().getId();\n        final Lock lock = dbValues.getLock();              \n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            //Compute a key for the value\n            Map.Entry entry = (Map.Entry) i.next();\n            Indexable indexable = (Indexable) entry.getKey();\n            //TODO : NativeElementIndex uses ArrayLists -pb\n            LongLinkedList storedGIDList = (LongLinkedList) entry.getValue();\n            Value ref = new Value(indexable.serialize(collectionId, caseSensitive)); \n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                VariableByteInput is = dbValues.getAsStream(ref);\n                os.clear();\n                //TODO : NativeElementIndex uses ArrayLists -pb\n                LongLinkedList newGIDList = new LongLinkedList();\n                //Does the value already has data in the index ?\n                if (is != null) {                    \n                    try {\n                        while (is.available() > 0) {\n                            int storedDocId = is.readInt();\n                            int gidsCount = is.readInt();\n                            if (storedDocId != document.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(gidsCount);\n                                os.writeInt(gidsCount);\n                                is.copyTo(os, gidsCount);\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs                                    \n                                long previousGID = 0;\n                                for (int j = 0; j < gidsCount; j++) {\n                                    long delta = is.readLong();\n                                    long storedGID = previousGID + delta;    \n                                    if (node == null) {\n                                        if (document.getTreeLevel(storedGID) < document.reindexRequired())\n                                            storedGIDList.add(storedGID);\n                                    } else {\n                                         if (!XMLUtil.isDescendant(document, node.getGID(), storedGID))\n                                             //TO UNDERSTAND : what will these GIDs become ? -pb\n                                             newGIDList.add(storedGID);\n                                    }\n                                    previousGID = storedGID;\n                                }\n                            }\n                        }\n                    } catch (EOFException e) {\n                        //Is it expected ? Remove this block if not -pb\n                        LOG.warn(e.getMessage(), e);\n                    }\n                }\n                if (storedGIDList.getSize() > 0) {\n                    // append the new list to any existing data\n                    long[] gids = storedGIDList.getData();\n                    int gidsCount = gids.length;\n                    //Don't forget this one\n                    Arrays.sort(gids);\n                    os.writeInt(document.getDocId());\n                    os.writeInt(gidsCount);\n                    long previousGID = 0;\n                    for (int j = 0; j < gidsCount; j++) {\n                        long delta = gids[j] - previousGID;                        \n                        os.writeLong(delta);\n                        previousGID = gids[j];\n                    }\n                }\n                //Store the data\n                if (is == null) {\n                    //TOUNDERSTAND : Should is be null, what will there be in os.data() ? -pb\n                    if (dbValues.put(ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not put index data for value '\" +  ref + \"'\");\n                    }\n                } else {\n                    long address = ((BFile.PageInputStream) is).getAddress();\n                    if (dbValues.update(address, ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.warn(\"Could not update index data for value '\" +  ref + \"'\");\n                    }\n                }\n                \n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);     \n                return;\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);                \n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(e.getMessage(), e);  \n                //TODO : return ?\n            } finally {\n                lock.release(Lock.WRITE_LOCK);\n            }\n        }\n        pending.clear();\n    }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void remove() { \n        //TODO : return if doc == null? -pb  \n        if (pending.size() == 0) \n            return;        \n        Indexable indexable;\n        //TODO : NativeElementIndex uses ArrayLists -pb\n        LongLinkedList storedGIDList;\n        LongLinkedList newGIDList;\n        long[] gids;        \n        int gidsCount;\n        long storedGID;\n        long previousGID;        \n        long delta; \n        Map.Entry entry;    \n        Value searchKey;\n        Value value;\n        VariableByteArrayInput is;\n        int storedDocId;\n        final short collectionId = this.doc.getCollection().getId();\n        final Lock lock = dbValues.getLock();           \n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            entry = (Map.Entry) i.next();\n            indexable = (Indexable) entry.getKey();\n            storedGIDList = (LongLinkedList) entry.getValue();   \n            //Compute a key for the value\n            searchKey = new Value(indexable.serialize(collectionId, caseSensitive)); \n            newGIDList = new LongLinkedList();\n            os.clear();              \n            try {                    \n                lock.acquire(Lock.WRITE_LOCK); \n                value = dbValues.get(searchKey);\n                //Does the value already exist in the index ?\n                if (value != null) {\n                    //Add its data to the new list\n                    is = new VariableByteArrayInput(value.getData());\n                    try {                            \n                        while (is.available() > 0) {\n                            storedDocId = is.readInt();\n                            gidsCount = is.readInt();\n                            if (storedDocId != this.doc.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(storedDocId);\n                                os.writeInt(gidsCount);                                                                       \n                                is.copyTo(os, gidsCount);\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs\n                                previousGID = 0;\n                                for (int j = 0; j < gidsCount; j++) {\n                                    delta = is.readLong();\n                                    storedGID = previousGID + delta;  \n                                    // add the node to the new list if it is not \n                                    // in the list of removed nodes\n                                    if (!storedGIDList.contains(storedGID)) {\n                                        newGIDList.add(storedGID);\n                                    }\n                                    previousGID = storedGID;\n                                }\n                            }\n                        }\n                    } catch (EOFException e) {\n                        //Is it expected ? if not, remove the block -pb\n                        LOG.warn(e.getMessage(), e);\n                    }\n                    //append the data from the new list\n                    if (newGIDList.getSize() > 0) {                        \n                        gids = newGIDList.getData();\n                        gidsCount = gids.length;\n                        //Don't forget this one\n                        Arrays.sort(gids);\n                        os.writeInt(this.doc.getDocId());\n                        os.writeInt(gidsCount);\n                        previousGID = 0;\n                        for (int j = 0; j < gidsCount; j++) {\n                            delta = gids[j] - previousGID;                            \n                            os.writeLong(delta);\n                            previousGID = gids[j];\n                        } \n                    }\n                }                \n                //Store the data\n                if (value == null) {\n                    if (dbValues.put(searchKey, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not put index data for value '\" +  searchKey + \"'\");  \n                    }                    \n                } else {\n                    if (dbValues.update(value.getAddress(), searchKey, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not update index data for value '\" +  searchKey + \"'\");  \n                    }                    \n                }  \n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);\n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(\"Read-only error on '\" + dbValues.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);                \n            } finally {\n                lock.release();\n            }            \n        }\n        pending.clear();\n    }","id":74471,"modified_method":"public void remove() { \n        //TODO : return if doc == null? -pb  \n        if (pending.size() == 0) \n            return;\n        final short collectionId = this.doc.getCollection().getId();\n        final Lock lock = dbValues.getLock();           \n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            Map.Entry entry = (Map.Entry) i.next();\n            Indexable indexable = (Indexable) entry.getKey();\n            //TODO : NativeElementIndex uses ArrayLists -pb\n            LongLinkedList storedGIDList = (LongLinkedList) entry.getValue();   \n            //Compute a key for the value\n            Value searchKey = new Value(indexable.serialize(collectionId, caseSensitive));\n            //TODO : NativeElementIndex uses ArrayLists -pb\n            LongLinkedList newGIDList = new LongLinkedList();\n            os.clear();              \n            try {                    \n                lock.acquire(Lock.WRITE_LOCK); \n                Value value = dbValues.get(searchKey);\n                //Does the value already exist in the index ?\n                if (value != null) {\n                    //Add its data to the new list\n                    VariableByteArrayInput is = new VariableByteArrayInput(value.getData());\n                    try {                            \n                        while (is.available() > 0) {\n                            int storedDocId = is.readInt();\n                            int gidsCount = is.readInt();\n                            if (storedDocId != this.doc.getDocId()) {\n                                // data are related to another document:\n                                // append them to any existing data\n                                os.writeInt(storedDocId);\n                                os.writeInt(gidsCount);                                                                       \n                                is.copyTo(os, gidsCount);\n                            } else {\n                                // data are related to our document:\n                                // feed the new list with the GIDs\n                                long previousGID = 0;\n                                for (int j = 0; j < gidsCount; j++) {\n                                    long delta = is.readLong();\n                                    long storedGID = previousGID + delta;  \n                                    // add the node to the new list if it is not \n                                    // in the list of removed nodes\n                                    if (!storedGIDList.contains(storedGID)) {\n                                        newGIDList.add(storedGID);\n                                    }\n                                    previousGID = storedGID;\n                                }\n                            }\n                        }\n                    } catch (EOFException e) {\n                        //Is it expected ? if not, remove the block -pb\n                        LOG.warn(e.getMessage(), e);\n                    }\n                    //append the data from the new list\n                    if (newGIDList.getSize() > 0) {                        \n                        long[] gids = newGIDList.getData();\n                        int gidsCount = gids.length;\n                        //Don't forget this one\n                        Arrays.sort(gids);\n                        os.writeInt(this.doc.getDocId());\n                        os.writeInt(gidsCount);\n                        long previousGID = 0;\n                        for (int j = 0; j < gidsCount; j++) {\n                            long delta = gids[j] - previousGID;                            \n                            os.writeLong(delta);\n                            previousGID = gids[j];\n                        } \n                    }\n                }                \n                //Store the data\n                if (value == null) {\n                    if (dbValues.put(searchKey, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not put index data for value '\" +  searchKey + \"'\");  \n                    }                    \n                } else {\n                    if (dbValues.update(value.getAddress(), searchKey, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                        LOG.error(\"Could not update index data for value '\" +  searchKey + \"'\");  \n                    }                    \n                }  \n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);\n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(\"Read-only error on '\" + dbValues.getFile().getName() + \"'\", e);\n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);                \n            } finally {\n                lock.release();\n            }            \n        }\n        pending.clear();\n    }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"/** Regular expression search\n\t * @param type  like type argument for {@link RegexMatcher} constructor\n\t * @param flags like flags argument for {@link RegexMatcher} constructor\n\t *  */\n    public NodeSet match(DocumentSet docs, NodeSet contextSet, String expr, int type, int flags, boolean caseSensitiveQuery)\n        throws TerminatedException, EXistException {\n        \n    \t// if the regexp starts with a char sequence, we restrict the index scan to entries starting with\n    \t// the same sequence. Otherwise, we have to scan the whole index.\n        StringValue startTerm = null;\n        if (expr.startsWith(\"^\") && caseSensitiveQuery == caseSensitive) {\n        \tStringBuffer term = new StringBuffer();\n    \t\tfor (int j = 1; j < expr.length(); j++)\n    \t\t\tif (Character.isLetterOrDigit(expr.charAt(j)))\n    \t\t\t\tterm.append(expr.charAt(j));\n    \t\t\telse\n    \t\t\t\tbreak;\n    \t\tif(term.length() > 0) {\n                startTerm = new StringValue(term.toString());\n                LOG.debug(\"Match will begin index scan at '\" + startTerm + \"'\");\n    \t\t}\n        }\n        \n\t\tTermMatcher comparator = new RegexMatcher(expr, type, flags);\n        NodeSet result = new ExtArrayNodeSet();\n        RegexCallback callback = new RegexCallback(docs, contextSet, result, comparator);\n        final Lock lock = dbValues.getLock();\n        for (Iterator iter = docs.getCollectionIterator(); iter.hasNext();) {\n\t\t\tCollection collection = (Collection) iter.next();\n\t\t\tshort collectionId = collection.getId();\n\t\t\tValue searchKey;\n\t\t\tif (startTerm != null) {\n                byte[] key = startTerm.serialize(collectionId, caseSensitive);\n                searchKey = new Value(key);\n            } else {\n                searchKey = computeKeyPrefix(Type.STRING, collectionId);                \n\t\t\t\t//key = new byte[3];\n\t\t\t\t//ByteConversion.shortToByte(collectionId, key, 0);\n\t\t\t\t//key[2] = (byte) Type.STRING;\n\t\t\t}\n\t\t\tIndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, searchKey);\n\t\t\ttry {\n\t\t\t\tlock.acquire();\n\t\t\t\tdbValues.query(query, callback);\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);  \n\t\t\t} catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n\t\t\t} catch (BTreeException e) {\n                LOG.error(e.getMessage(), e);\t\t\t\n\t\t\t} finally {\n\t\t\t\tlock.release();\n\t\t\t}\n        }\n        return result;\n    }","id":74472,"modified_method":"/** Regular expression search\n\t * @param type  like type argument for {@link RegexMatcher} constructor\n\t * @param flags like flags argument for {@link RegexMatcher} constructor\n\t *  */\n    public NodeSet match(DocumentSet docs, NodeSet contextSet, String expr, int type, int flags, boolean caseSensitiveQuery)\n        throws TerminatedException, EXistException {\n        \n    \t// if the regexp starts with a char sequence, we restrict the index scan to entries starting with\n    \t// the same sequence. Otherwise, we have to scan the whole index.\n        StringValue startTerm = null;\n        if (expr.startsWith(\"^\") && caseSensitiveQuery == caseSensitive) {\n        \tStringBuffer term = new StringBuffer();\n    \t\tfor (int j = 1; j < expr.length(); j++)\n    \t\t\tif (Character.isLetterOrDigit(expr.charAt(j)))\n    \t\t\t\tterm.append(expr.charAt(j));\n    \t\t\telse\n    \t\t\t\tbreak;\n    \t\tif(term.length() > 0) {\n                startTerm = new StringValue(term.toString());\n                LOG.debug(\"Match will begin index scan at '\" + startTerm + \"'\");\n    \t\t}\n        }\n        \n\t\tfinal TermMatcher comparator = new RegexMatcher(expr, type, flags);\n        final NodeSet result = new ExtArrayNodeSet();\n        final RegexCallback callback = new RegexCallback(docs, contextSet, result, comparator);\n        final Lock lock = dbValues.getLock();\n        for (Iterator iter = docs.getCollectionIterator(); iter.hasNext();) {\n\t\t\tCollection collection = (Collection) iter.next();\n\t\t\tshort collectionId = collection.getId();\n\t\t\tValue searchKey;\n\t\t\tif (startTerm != null) {\n                byte[] key = startTerm.serialize(collectionId, caseSensitive);\n                searchKey = new Value(key);\n            } else {\n                searchKey = computeKeyPrefix(Type.STRING, collectionId);                \n\t\t\t\t//key = new byte[3];\n\t\t\t\t//ByteConversion.shortToByte(collectionId, key, 0);\n\t\t\t\t//key[2] = (byte) Type.STRING;\n\t\t\t}\n\t\t\tIndexQuery query = new IndexQuery(IndexQuery.TRUNC_RIGHT, searchKey);\n\t\t\ttry {\n\t\t\t\tlock.acquire();\n\t\t\t\tdbValues.query(query, callback);\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);  \n\t\t\t} catch (IOException e) {\n                LOG.error(e.getMessage(), e);\n\t\t\t} catch (BTreeException e) {\n                LOG.error(e.getMessage(), e);\t\t\t\n\t\t\t} finally {\n\t\t\t\tlock.release();\n\t\t\t}\n        }\n        return result;\n    }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"public void flush() {\n        //TODO : return if doc == null? -pb        \n        if (pending.size() == 0) \n            return;        \n        Indexable indexable;\n        //TODO : NativeElementIndex uses ArrayLists -pb\n        LongLinkedList gidList;\n        long gids[];\n        int gidsCount;        \n        long previousGID;\n        long delta;\n        Value ref;\n        Map.Entry entry;        \n        final short collectionId = this.doc.getCollection().getId();\n        final Lock lock = dbValues.getLock();\n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            entry = (Map.Entry) i.next();\n            indexable = (Indexable) entry.getKey();\n            gidList = (LongLinkedList) entry.getValue();\n            gids = gidList.getData();\n            gidsCount = gids.length;\n            //Don't forget this one\n            Arrays.sort(gids);\n            os.clear();\n            os.writeInt(this.doc.getDocId());\n            os.writeInt(gidsCount);\n            //Compute the GID list\n            previousGID = 0;\n            for (int j = 0; j < gidsCount; j++) {                    \n                delta = gids[j] - previousGID;                    \n                os.writeLong(delta);\n                previousGID = gids[j];\n            }\n            //Compute a key for the value\n            ref = new Value(indexable.serialize(collectionId, caseSensitive));\n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                //Store data\n                if (dbValues.append(ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                    LOG.warn(\"Could not append index data for value '\" +  ref + \"'\");                   \n                }\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);\n               //TODO : return ?                         \n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);  \n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(e.getMessage(), e);     \n                //Return without clearing the pending entries\n                return;                 \n            } finally {\n                lock.release();\n            }\n        }\n        pending.clear();\n    }","id":74473,"modified_method":"public void flush() {\n        //TODO : return if doc == null? -pb        \n        if (pending.size() == 0) \n            return;             \n        final short collectionId = this.doc.getCollection().getId();\n        final Lock lock = dbValues.getLock();\n        for (Iterator i = pending.entrySet().iterator(); i.hasNext();) {\n            Map.Entry entry = (Map.Entry) i.next();\n            Indexable indexable = (Indexable) entry.getKey();\n            //TODO : NativeElementIndex uses ArrayLists -pb\n            LongLinkedList gidList = (LongLinkedList) entry.getValue();\n            long[] gids = gidList.getData();\n            int gidsCount = gids.length;\n            //Don't forget this one\n            Arrays.sort(gids);\n            os.clear();\n            os.writeInt(this.doc.getDocId());\n            os.writeInt(gidsCount);\n            //Compute the GID list\n            long previousGID = 0;\n            for (int j = 0; j < gidsCount; j++) {                    \n                long delta = gids[j] - previousGID;                    \n                os.writeLong(delta);\n                previousGID = gids[j];\n            }\n            //Compute a key for the value\n            Value ref = new Value(indexable.serialize(collectionId, caseSensitive));\n            try {\n                lock.acquire(Lock.WRITE_LOCK);\n                //Store data\n                if (dbValues.append(ref, os.data()) == BFile.UNKNOWN_ADDRESS) {\n                    LOG.warn(\"Could not append index data for value '\" +  ref + \"'\");                   \n                }\n            } catch (LockException e) {\n                LOG.warn(\"Failed to acquire lock for '\" + dbValues.getFile().getName() + \"'\", e);\n               //TODO : return ?                         \n            } catch (IOException e) {\n                LOG.error(e.getMessage(), e);  \n                //TODO : return ?\n            } catch (ReadOnlyException e) {\n                LOG.warn(e.getMessage(), e);     \n                //Return without clearing the pending entries\n                return;                 \n            } finally {\n                lock.release();\n            }\n        }\n        pending.clear();\n    }","commit_id":"dee8434f76759af52ac0b7c14efa52d2dab77a3d","url":"https://github.com/eXist-db/exist"},{"original_method":"/**\n   * Prepare Text for Extended Matching Item Questions\n   * @param item\n   * @param bean\n   * @param itemauthor\n   * @return\n   */\n  private void preparePublishedTextForEMI(ItemFacade item,\n\t\t\tItemBean bean, ItemService delegate) {\n\t  \n\t  \t// ///////////////////////////////////////////////////////////\n\t\t//\n\t\t// 1. save Theme and Lead-In Text and Answer Options\n\t\t//  \n\t\t// ///////////////////////////////////////////////////////////\n        ItemTextIfc textTheme = item.getItemTextBySequence(ItemTextIfc.EMI_THEME_TEXT_SEQUENCE);\n\t\ttextTheme.setText(bean.getItemText());\n\t\t\n\t\tItemTextIfc textAnswerOptions = item.getItemTextBySequence(ItemTextIfc.EMI_ANSWER_OPTIONS_SEQUENCE);\n\t\ttextAnswerOptions.setText(bean.getEmiAnswerOptionsRich());\n\n\t\tItemTextIfc textLeadIn = item.getItemTextBySequence(ItemTextIfc.EMI_LEAD_IN_TEXT_SEQUENCE);\n\t\ttextLeadIn.setText(bean.getLeadInStatement());\n\t\t\n\t\t// ///////////////////////////////////////////////////////////\n\t\t//\n\t\t// 2. save Answer Options - emiAnswerOptions\n\t\t// with ItemText  (seq=ItemTextIfc.EMI_ANSWER_OPTIONS_SEQUENCE).\n\t\t// These will be used to construct the actual answers.\n        //\n        // ///////////////////////////////////////////////////////////\n        Set<AnswerIfc> answerOptions = textAnswerOptions.getAnswerSet();\n        Set<AnswerIfc> deleteAnswerOptions = new HashSet<AnswerIfc>(answerOptions);\n        answerOptions.clear();\n        outer: for(AnswerBean answerBean: bean.getEmiAnswerOptionsClean()){\n            for(AnswerIfc currentAnswerOption: deleteAnswerOptions){\n                if(currentAnswerOption.getSequence() == answerBean.getSequence()){\n                    //update the existing answer\n                    currentAnswerOption.setText(stripPtags(answerBean.getText()));\n                    currentAnswerOption.setLabel(answerBean.getLabel());\n                    currentAnswerOption.setIsCorrect(Boolean.FALSE);\n                    answerOptions.add(currentAnswerOption);\n                    continue outer;\n                }\n            }\n            //This is a new answer option, so add it\n            //later (a little below this) we will add all the answer options to the items too\n            AnswerIfc answerOption = new PublishedAnswer(textAnswerOptions,\n\t\t\t\t\tstripPtags(answerBean.getText()), answerBean\n\t\t\t\t\t.getSequence(), answerBean.getLabel(),\n\t\t\t\t\tBoolean.FALSE, null, null, null, null, null);\n\t\t\tanswerOptions.add(answerOption);\n\t\t}\n        //The deleted answer options that will be removed\n        deleteAnswerOptions.removeAll(answerOptions);\n        delegate.deleteSet(deleteAnswerOptions);\n\t\t\n\t\t// ///////////////////////////////////////////////////////////\n\t\t//\n\t\t// 3. Prepare and save actual answers from answer components \n\t\t// (emiAnswerOptions and emiQuestionAnswerCombinations)\n\t\t// ///////////////////////////////////////////////////////////\n\t\tList<AnswerBean> emiQuestionAnswerCombinations = bean.getEmiQuestionAnswerCombinationsClean();\n        Double itemScore = 0.0;\n        Set<ItemTextIfc> deleteItemText = new HashSet<ItemTextIfc>(item.getItemTextSet());\n        item.getItemTextSet().clear();\n        //Put the theme, options and lead in back\n        for(ItemTextIfc currentItemText : deleteItemText) {\n          if (currentItemText.getSequence() < 1) {\n              item.getItemTextSet().add(currentItemText);\n          }\n        }\n        deleteItemText.removeAll(item.getItemTextSet());\n        for(AnswerBean answerBean: emiQuestionAnswerCombinations){\n            ItemTextIfc itemText = null;\n\t\t\tfor(ItemTextIfc currentItemText: deleteItemText){\n                if(currentItemText.getSequence() == answerBean.getSequence()){\n                    itemText = currentItemText;\n                    break;\n                }\n            }\n            if(itemText == null){\n                itemText = new PublishedItemText();\n                itemText.setItem(item.getData());\n                itemText.setSequence(answerBean.getSequence());\n            }\n\t\t\titemText.setText(answerBean.getText());\n\t\t\t\n\t\t\tint requiredOptions = (Integer.valueOf(answerBean.getRequiredOptionsCount())).intValue();\n\t\t\tif (requiredOptions == 0) {\n\t\t\t\trequiredOptions = answerBean.correctOptionsCount();\n\t\t\t}\n\t\t\titemText.setRequiredOptionsCount(requiredOptions);\n            itemScore += answerBean.getScore();\n\t\t\t\n            Set<AnswerIfc> deleteItemAnswerSet = new HashSet<AnswerIfc>(itemText.getAnswerSet());\n            itemText.getAnswerSet().clear();\n\t\t\tif (Integer.valueOf(bean.getAnswerOptionsSimpleOrRich()).equals(ItemDataIfc.ANSWER_OPTIONS_SIMPLE) ) {\n                outer2: for(AnswerIfc currentAnswerOption: answerOptions){\n\t\t\t\t    String correctLabels = answerBean.getCorrectOptionLabels();\n                    int correctRequiredCount = correctLabels.length()<requiredOptions?correctLabels.length():requiredOptions;\n                    boolean isCorrect = answerBean.getCorrectOptionLabels().contains(currentAnswerOption.getLabel());\n\n                    // item option score\n                    Double score = answerBean.getScore() / correctRequiredCount;\n                    for(AnswerIfc currentItemAnswer: deleteItemAnswerSet){\n                        //if the answer option was removed before then the item\n                        //answer will also be removed (not added back here)\n                        if(currentItemAnswer.getSequence() == currentAnswerOption.getSequence()){\n                            currentItemAnswer.setText(currentAnswerOption.getText());\n                            currentItemAnswer.setLabel(currentAnswerOption.getLabel());\n                            currentItemAnswer.setIsCorrect(isCorrect);\n                            currentItemAnswer.setGrade(answerBean.getScoreUserSet() ? \"user\" : \"auto\");\n                            currentItemAnswer.setScore(isCorrect ? score : 0.0);\n                            currentItemAnswer.setPartialCredit(null);\n                            currentItemAnswer.setDiscount(isCorrect ? 0.0 : -score / 2);\n                            currentItemAnswer.setAnswerFeedbackSet(null);\n                            itemText.getAnswerSet().add(currentItemAnswer);\n                            continue outer2;\n                        }\n                    }\n                    //if we get here then there is a new answer option and we need to \n                    //add it to the itemtext\n                    itemText.getAnswerSet().add(new PublishedAnswer(itemText, currentAnswerOption.getText(),\n                                            currentAnswerOption.getSequence(), currentAnswerOption.getLabel(),\n                                            isCorrect, answerBean.getScoreUserSet() ? \"user\" : \"auto\",\n                                            isCorrect ? score : 0.0, null, isCorrect ? 0.0 : -score / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { // ANSWER_OPTION_RICH\n\t\t\t\tint answerOptionsCount = Integer.valueOf(bean.getAnswerOptionsRichCount());\n                outer3: for (int i=0; i<answerOptionsCount; i++) {\n\t\t\t\t\tString label = ItemDataIfc.ANSWER_OPTION_LABELS.substring(i, i+1);\n\t\t\t\t\tString correctLabels = answerBean.getCorrectOptionLabels();\n                    int correctRequiredCount = correctLabels.length()<requiredOptions?correctLabels.length():requiredOptions;\n                    boolean isCorrect = answerBean.getCorrectOptionLabels().contains(label);\n\n                    // item option score\n                    Double score = answerBean.getScore() / correctRequiredCount;\n                    for(AnswerIfc currentItemAnswer: deleteItemAnswerSet){\n                        //if the answer option was removed before then the item\n                        //answer will also be removed (not added back here)\n                        if(currentItemAnswer.getSequence() == i){\n                            currentItemAnswer.setText(label);\n                            currentItemAnswer.setLabel(label);\n                            currentItemAnswer.setIsCorrect(isCorrect);\n                            currentItemAnswer.setGrade(answerBean.getScoreUserSet() ? \"user\" : \"auto\");\n                            currentItemAnswer.setScore(isCorrect ? score : 0.0);\n                            currentItemAnswer.setPartialCredit(null);\n                            currentItemAnswer.setDiscount(isCorrect ? 0.0 : -score / 2);\n                            currentItemAnswer.setAnswerFeedbackSet(null);\n                            itemText.getAnswerSet().add(currentItemAnswer);\n                            continue outer3;\n                        }\n                    }\n                    //if we get here then there is a new answer option and we need to \n                    //add it to the itemtext\n                    itemText.getAnswerSet().add(new PublishedAnswer(itemText, label,\n                                            Long.valueOf(i), label,\n                                            isCorrect, answerBean.getScoreUserSet() ? \"user\" : \"auto\",\n                                            isCorrect ? score : 0.0, null, isCorrect ? 0.0 : -score / 2));\n\t\t\t\t}\n\t\t\t}\n            deleteItemAnswerSet.removeAll(itemText.getAnswerSet());\n            delegate.deleteSet(deleteItemAnswerSet);\n\t\t\titem.getItemTextSet().add(itemText);\n\t\t}\n        deleteItemText.removeAll(item.getItemTextSet());\n        delegate.deleteSet(deleteItemText);\n        item.setScore(itemScore);\n\t}","id":74474,"modified_method":"/**\n   * Prepare Text for Extended Matching Item Questions\n   * @param item\n   * @param bean\n   * @param itemauthor\n   * @return\n   */\n  private void preparePublishedTextForEMI(ItemFacade item,\n\t\t\tItemBean bean, ItemService delegate) {\n\t  \n\t  \t// ///////////////////////////////////////////////////////////\n\t\t//\n\t\t// 1. save Theme and Lead-In Text and Answer Options\n\t\t//  \n\t\t// ///////////////////////////////////////////////////////////\n        ItemTextIfc textTheme = item.getItemTextBySequence(ItemTextIfc.EMI_THEME_TEXT_SEQUENCE);\n\t\ttextTheme.setText(bean.getItemText());\n\t\t\n\t\tItemTextIfc textAnswerOptions = item.getItemTextBySequence(ItemTextIfc.EMI_ANSWER_OPTIONS_SEQUENCE);\n\t\ttextAnswerOptions.setText(bean.getEmiAnswerOptionsRich());\n\n\t\tItemTextIfc textLeadIn = item.getItemTextBySequence(ItemTextIfc.EMI_LEAD_IN_TEXT_SEQUENCE);\n\t\ttextLeadIn.setText(bean.getLeadInStatement());\n\t\t\n\t\t// ///////////////////////////////////////////////////////////\n\t\t//\n\t\t// 2. save Answer Options - emiAnswerOptions\n\t\t// with ItemText  (seq=ItemTextIfc.EMI_ANSWER_OPTIONS_SEQUENCE).\n\t\t// These will be used to construct the actual answers.\n        //\n        // ///////////////////////////////////////////////////////////\n        Set<AnswerIfc> answerOptions = textAnswerOptions.getAnswerSet();\n        Set<AnswerIfc> deleteAnswerOptions = new HashSet<AnswerIfc>(answerOptions);\n        answerOptions.clear();\n        outer: for(AnswerBean answerBean: bean.getEmiAnswerOptionsClean()){\n            for(AnswerIfc currentAnswerOption: deleteAnswerOptions){\n                if(currentAnswerOption.getSequence().equals(answerBean.getSequence())){\n                    //update the existing answer\n                    currentAnswerOption.setText(stripPtags(answerBean.getText()));\n                    currentAnswerOption.setLabel(answerBean.getLabel());\n                    currentAnswerOption.setIsCorrect(Boolean.FALSE);\n                    answerOptions.add(currentAnswerOption);\n                    continue outer;\n                }\n            }\n            //This is a new answer option, so add it\n            //later (a little below this) we will add all the answer options to the items too\n            AnswerIfc answerOption = new PublishedAnswer(textAnswerOptions,\n\t\t\t\t\tstripPtags(answerBean.getText()), answerBean\n\t\t\t\t\t.getSequence(), answerBean.getLabel(),\n\t\t\t\t\tBoolean.FALSE, null, null, null, null, null);\n\t\t\tanswerOptions.add(answerOption);\n\t\t}\n        //The deleted answer options that will be removed\n        deleteAnswerOptions.removeAll(answerOptions);\n        delegate.deleteSet(deleteAnswerOptions);\n\t\t\n\t\t// ///////////////////////////////////////////////////////////\n\t\t//\n\t\t// 3. Prepare and save actual answers from answer components \n\t\t// (emiAnswerOptions and emiQuestionAnswerCombinations)\n\t\t// ///////////////////////////////////////////////////////////\n\t\tList<AnswerBean> emiQuestionAnswerCombinations = bean.getEmiQuestionAnswerCombinationsClean();\n        Double itemScore = 0.0;\n        Set<ItemTextIfc> deleteItemText = new HashSet<ItemTextIfc>(item.getItemTextSet());\n        item.getItemTextSet().clear();\n        //Put the theme, options and lead in back\n        for(ItemTextIfc currentItemText : deleteItemText) {\n          if (currentItemText.getSequence() < 1) {\n              item.getItemTextSet().add(currentItemText);\n          }\n        }\n        deleteItemText.removeAll(item.getItemTextSet());\n        for(AnswerBean answerBean: emiQuestionAnswerCombinations){\n            ItemTextIfc itemText = null;\n\t\t\tfor(ItemTextIfc currentItemText: deleteItemText){\n                if(currentItemText.getSequence().equals(answerBean.getSequence())){\n                    itemText = currentItemText;\n                    break;\n                }\n            }\n            if(itemText == null){\n                itemText = new PublishedItemText();\n                itemText.setItem(item.getData());\n                itemText.setSequence(answerBean.getSequence());\n            }\n\t\t\titemText.setText(answerBean.getText());\n\t\t\t\n\t\t\tint requiredOptions = (Integer.valueOf(answerBean.getRequiredOptionsCount())).intValue();\n\t\t\tif (requiredOptions == 0) {\n\t\t\t\trequiredOptions = answerBean.correctOptionsCount();\n\t\t\t}\n\t\t\titemText.setRequiredOptionsCount(requiredOptions);\n            itemScore += answerBean.getScore();\n\t\t\t\n            Set<AnswerIfc> deleteItemAnswerSet = new HashSet<AnswerIfc>(itemText.getAnswerSet());\n            itemText.getAnswerSet().clear();\n\t\t\tif (Integer.valueOf(bean.getAnswerOptionsSimpleOrRich()).equals(ItemDataIfc.ANSWER_OPTIONS_SIMPLE) ) {\n                outer2: for(AnswerIfc currentAnswerOption: answerOptions){\n\t\t\t\t    String correctLabels = answerBean.getCorrectOptionLabels();\n                    int correctRequiredCount = correctLabels.length()<requiredOptions?correctLabels.length():requiredOptions;\n                    boolean isCorrect = answerBean.getCorrectOptionLabels().contains(currentAnswerOption.getLabel());\n\n                    // item option score\n                    Double score = answerBean.getScore() / correctRequiredCount;\n                    for(AnswerIfc currentItemAnswer: deleteItemAnswerSet){\n                        //if the answer option was removed before then the item\n                        //answer will also be removed (not added back here)\n                        if(currentItemAnswer.getSequence().equals(currentAnswerOption.getSequence())){\n                            currentItemAnswer.setText(currentAnswerOption.getText());\n                            currentItemAnswer.setLabel(currentAnswerOption.getLabel());\n                            currentItemAnswer.setIsCorrect(isCorrect);\n                            currentItemAnswer.setGrade(answerBean.getScoreUserSet() ? \"user\" : \"auto\");\n                            currentItemAnswer.setScore(isCorrect ? score : 0.0);\n                            currentItemAnswer.setPartialCredit(null);\n                            currentItemAnswer.setDiscount(isCorrect ? 0.0 : -score / 2);\n                            currentItemAnswer.setAnswerFeedbackSet(null);\n                            itemText.getAnswerSet().add(currentItemAnswer);\n                            continue outer2;\n                        }\n                    }\n                    //if we get here then there is a new answer option and we need to \n                    //add it to the itemtext\n                    itemText.getAnswerSet().add(new PublishedAnswer(itemText, currentAnswerOption.getText(),\n                                            currentAnswerOption.getSequence(), currentAnswerOption.getLabel(),\n                                            isCorrect, answerBean.getScoreUserSet() ? \"user\" : \"auto\",\n                                            isCorrect ? score : 0.0, null, isCorrect ? 0.0 : -score / 2));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse { // ANSWER_OPTION_RICH\n\t\t\t\tint answerOptionsCount = Integer.valueOf(bean.getAnswerOptionsRichCount());\n                outer3: for (int i=0; i<answerOptionsCount; i++) {\n\t\t\t\t\tString label = ItemDataIfc.ANSWER_OPTION_LABELS.substring(i, i+1);\n\t\t\t\t\tString correctLabels = answerBean.getCorrectOptionLabels();\n                    int correctRequiredCount = correctLabels.length()<requiredOptions?correctLabels.length():requiredOptions;\n                    boolean isCorrect = answerBean.getCorrectOptionLabels().contains(label);\n\n                    // item option score\n                    Double score = answerBean.getScore() / correctRequiredCount;\n                    for(AnswerIfc currentItemAnswer: deleteItemAnswerSet){\n                        //if the answer option was removed before then the item\n                        //answer will also be removed (not added back here)\n                        if(currentItemAnswer.getSequence() == i){\n                            currentItemAnswer.setText(label);\n                            currentItemAnswer.setLabel(label);\n                            currentItemAnswer.setIsCorrect(isCorrect);\n                            currentItemAnswer.setGrade(answerBean.getScoreUserSet() ? \"user\" : \"auto\");\n                            currentItemAnswer.setScore(isCorrect ? score : 0.0);\n                            currentItemAnswer.setPartialCredit(null);\n                            currentItemAnswer.setDiscount(isCorrect ? 0.0 : -score / 2);\n                            currentItemAnswer.setAnswerFeedbackSet(null);\n                            itemText.getAnswerSet().add(currentItemAnswer);\n                            continue outer3;\n                        }\n                    }\n                    //if we get here then there is a new answer option and we need to \n                    //add it to the itemtext\n                    itemText.getAnswerSet().add(new PublishedAnswer(itemText, label,\n                                            Long.valueOf(i), label,\n                                            isCorrect, answerBean.getScoreUserSet() ? \"user\" : \"auto\",\n                                            isCorrect ? score : 0.0, null, isCorrect ? 0.0 : -score / 2));\n\t\t\t\t}\n\t\t\t}\n            deleteItemAnswerSet.removeAll(itemText.getAnswerSet());\n            delegate.deleteSet(deleteItemAnswerSet);\n\t\t\titem.getItemTextSet().add(itemText);\n\t\t}\n        deleteItemText.removeAll(item.getItemTextSet());\n        delegate.deleteSet(deleteItemText);\n        item.setScore(itemScore);\n\t}","commit_id":"3fc5f717d47ecd3afe2f4e3fbffc169e53c2a482","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final ModuleSpecification attachment = phaseContext.getDeploymentUnit().getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (attachment == null) {\n            return;\n        }\n        final List<PermissionFactory> permissions = attachment.getPermissionFactories();\n        final Enumeration<Permission> e = DEFAULT_PERMISSIONS.elements();\n        while (e.hasMoreElements()) {\n            permissions.add(new ImmediatePermissionFactory(e.nextElement()));\n        }\n    }","id":74475,"modified_method":"public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ModuleSpecification attachment = deploymentUnit.getAttachment(Attachments.MODULE_SPECIFICATION);\n        if (attachment == null) {\n            return;\n        }\n        final List<PermissionFactory> permissions = attachment.getPermissionFactories();\n        final Enumeration<Permission> e = DEFAULT_PERMISSIONS.elements();\n        while (e.hasMoreElements()) {\n            permissions.add(new ImmediatePermissionFactory(e.nextElement()));\n        }\n\n        //make sure they can read the contents of the deployment\n        ResourceRoot root = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        try {\n            File file = root.getRoot().getPhysicalFile();\n            if(file != null && file.isDirectory()) {\n                FilePermission permission = new FilePermission(file.getAbsolutePath() + \"/-\", \"read\");\n                permissions.add(new ImmediatePermissionFactory(permission));\n            }\n        } catch (IOException ex) {\n            throw new DeploymentUnitProcessingException(ex);\n        }\n\n    }","commit_id":"816ef03d79bd05f471148b87d5baad9a423f822f","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process a deployment for standard ra deployment files. Will parse the xml\n     * file and attach an configuration discovered during processing.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final ResourceRoot deploymentRoot = phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        final VirtualFile file = deploymentRoot.getRoot();\n        if (file == null || !file.exists())\n            return;\n\n        final String deploymentRootName = file.getLowerCaseName();\n        if (!deploymentRootName.endsWith(\".rar\")) {\n            return;\n        }\n\n        final VirtualFile alternateDescriptor = deploymentRoot.getAttachment(org.jboss.as.ee.structure.Attachments.ALTERNATE_CONNECTOR_DEPLOYMENT_DESCRIPTOR);\n        // Locate the descriptor\n        final VirtualFile serviceXmlFile;\n        if (alternateDescriptor != null) {\n            serviceXmlFile = alternateDescriptor;\n        } else {\n            serviceXmlFile = file.getChild(\"/META-INF/ra.xml\");\n        }\n        InputStream xmlStream = null;\n        Connector result = null;\n        try {\n            if (serviceXmlFile != null && serviceXmlFile.exists()) {\n\n                xmlStream = serviceXmlFile.openStream();\n                result = (new RaParser()).parse(xmlStream);\n                if (result == null)\n                    throw MESSAGES.failedToParseServiceXml(serviceXmlFile);\n            }\n            File root = file.getPhysicalFile();\n            URL url = root.toURI().toURL();\n            String deploymentName = file.getName().substring(0, file.getName().indexOf(\".rar\"));\n            ConnectorXmlDescriptor xmlDescriptor = new ConnectorXmlDescriptor(result, root, url, deploymentName);\n            phaseContext.getDeploymentUnit().putAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);\n\n        } catch (Exception e) {\n            throw MESSAGES.failedToParseServiceXml(e, serviceXmlFile);\n        } finally {\n            VFSUtils.safeClose(xmlStream);\n        }\n    }","id":74476,"modified_method":"/**\n     * Process a deployment for standard ra deployment files. Will parse the xml\n     * file and attach an configuration discovered during processing.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        final VirtualFile file = deploymentRoot.getRoot();\n        if (file == null || !file.exists())\n            return;\n\n        final String deploymentRootName = file.getLowerCaseName();\n        if (!deploymentRootName.endsWith(\".rar\")) {\n            return;\n        }\n\n        final VirtualFile alternateDescriptor = deploymentRoot.getAttachment(org.jboss.as.ee.structure.Attachments.ALTERNATE_CONNECTOR_DEPLOYMENT_DESCRIPTOR);\n        // Locate the descriptor\n        final VirtualFile serviceXmlFile;\n        if (alternateDescriptor != null) {\n            serviceXmlFile = alternateDescriptor;\n        } else {\n            serviceXmlFile = file.getChild(\"/META-INF/ra.xml\");\n        }\n        InputStream xmlStream = null;\n        Connector result = null;\n        try {\n            if (serviceXmlFile != null && serviceXmlFile.exists()) {\n\n                xmlStream = serviceXmlFile.openStream();\n                result = (new RaParser()).parse(xmlStream);\n                if (result == null)\n                    throw MESSAGES.failedToParseServiceXml(serviceXmlFile);\n            }\n            File root = file.getPhysicalFile();\n            URL url = root.toURI().toURL();\n            String prefix = \"\";\n\n            if (deploymentUnit.getParent() != null) {\n                prefix = deploymentUnit.getParent().getName() + \"#\";\n            }\n\n            String deploymentName = prefix + file.getName().substring(0, file.getName().indexOf(\".rar\"));\n            ConnectorXmlDescriptor xmlDescriptor = new ConnectorXmlDescriptor(result, root, url, deploymentName);\n            phaseContext.getDeploymentUnit().putAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);\n\n        } catch (Exception e) {\n            throw MESSAGES.failedToParseServiceXml(e, serviceXmlFile);\n        } finally {\n            VFSUtils.safeClose(xmlStream);\n        }\n    }","commit_id":"d39fdef7ed777eaaf57d9a909436d48314d527cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process a deployment for a Connector. Will install a {@Code\n     * JBossService} for this ResourceAdapter.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ConnectorXmlDescriptor connectorXmlDescriptor = deploymentUnit\n                .getAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY);\n        if (connectorXmlDescriptor == null) {\n            return; // Skip non ra deployments\n        }\n\n        ResourceAdapters raxmls = null;\n        // getResourceAdaptersAttachment(deploymentUnit);\n        final ServiceController<?> raService = phaseContext.getServiceRegistry().getService(\n                ConnectorServices.RESOURCEADAPTERS_SERVICE);\n        if (raService != null)\n            raxmls = ((ResourceAdapters) raService.getValue());\n        if (raxmls == null)\n            return;\n\n        ROOT_LOGGER.tracef(\"processing Raxml\");\n        Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n\n        if (module == null)\n            throw MESSAGES.failedToGetModuleAttachment(deploymentUnit);\n\n        try {\n            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n\n            for (org.jboss.jca.common.api.metadata.resourceadapter.ResourceAdapter raxml : raxmls.getResourceAdapters()) {\n                if (deploymentUnit.getName().equals(raxml.getArchive())) {\n\n                    final String deployment;\n                    if (deploymentUnit.getName().lastIndexOf('.') == -1) {\n                        deployment = deploymentUnit.getName();\n                    } else {\n                        deployment = deploymentUnit.getName().substring(0, deploymentUnit.getName().lastIndexOf('.'));\n                    }\n\n                    // Create the service\n                    String raName = connectorXmlDescriptor.getDeploymentName();\n                    ServiceName serviceName = ConnectorServices.registerDeployment(raName);\n\n                    ResourceAdapterXmlDeploymentService service = new ResourceAdapterXmlDeploymentService(connectorXmlDescriptor,\n                        raxml, module, deployment, serviceName);\n\n                    serviceTarget\n                            .addService(serviceName, service)\n                            .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, service.getMdrInjector())\n                            .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class,\n                                    service.getRaRepositoryInjector())\n                            .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n                                    service.getManagementRepositoryInjector())\n                            .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                                    ResourceAdapterDeploymentRegistry.class, service.getRegistryInjector())\n                            .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                                    service.getTxIntegrationInjector())\n                            .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE, JcaSubsystemConfiguration.class,\n                                    service.getConfigInjector())\n                            .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                                    service.getSubjectFactoryInjector())\n                            .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, service.getCcmInjector())\n                            .addDependency(NamingService.SERVICE_NAME)\n                            .addDependency(ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(connectorXmlDescriptor.getDeploymentName()))\n                            .setInitialMode(Mode.ACTIVE).install();\n                }\n            }\n        } catch (Throwable t) {\n            throw new DeploymentUnitProcessingException(t);\n        }\n    }","id":74477,"modified_method":"/**\n     * Process a deployment for a Connector. Will install a {@Code\n     * JBossService} for this ResourceAdapter.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ConnectorXmlDescriptor connectorXmlDescriptor = deploymentUnit\n                .getAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY);\n        if (connectorXmlDescriptor == null) {\n            return; // Skip non ra deployments\n        }\n\n        ResourceAdapters raxmls = null;\n        final ServiceController<?> raService = phaseContext.getServiceRegistry().getService(\n                ConnectorServices.RESOURCEADAPTERS_SERVICE);\n        if (raService != null)\n            raxmls = ((ResourceAdapters) raService.getValue());\n        if (raxmls == null)\n            return;\n\n        ROOT_LOGGER.tracef(\"processing Raxml\");\n        Module module = deploymentUnit.getAttachment(Attachments.MODULE);\n\n        if (module == null)\n            throw MESSAGES.failedToGetModuleAttachment(deploymentUnit);\n\n        try {\n            final ServiceTarget serviceTarget = phaseContext.getServiceTarget();\n\n            for (org.jboss.jca.common.api.metadata.resourceadapter.ResourceAdapter raxml : raxmls.getResourceAdapters()) {\n                String deploymentUnitPrefix = \"\";\n\n                if (deploymentUnit.getParent() != null) {\n                    deploymentUnitPrefix = deploymentUnit.getParent().getName() + \"#\";\n                }\n\n                String deploymentUnitName = deploymentUnitPrefix + deploymentUnit.getName();\n\n                if (deploymentUnitName.equals(raxml.getArchive())) {\n                    final String deployment;\n                    if (deploymentUnitName.lastIndexOf('.') == -1) {\n                        deployment = deploymentUnitName;\n                    } else {\n                        deployment = deploymentUnitName.substring(0, deploymentUnitName.lastIndexOf('.'));\n                    }\n\n                    // Create the service\n                    String raName = connectorXmlDescriptor.getDeploymentName();\n                    ServiceName serviceName = ConnectorServices.registerDeployment(raName);\n\n                    ResourceAdapterXmlDeploymentService service = new ResourceAdapterXmlDeploymentService(connectorXmlDescriptor,\n                        raxml, module, deployment, serviceName);\n\n                    serviceTarget\n                            .addService(serviceName, service)\n                            .addDependency(ConnectorServices.IRONJACAMAR_MDR, MetadataRepository.class, service.getMdrInjector())\n                            .addDependency(ConnectorServices.RA_REPOSISTORY_SERVICE, ResourceAdapterRepository.class,\n                                    service.getRaRepositoryInjector())\n                            .addDependency(ConnectorServices.MANAGEMENT_REPOSISTORY_SERVICE, ManagementRepository.class,\n                                    service.getManagementRepositoryInjector())\n                            .addDependency(ConnectorServices.RESOURCE_ADAPTER_REGISTRY_SERVICE,\n                                    ResourceAdapterDeploymentRegistry.class, service.getRegistryInjector())\n                            .addDependency(ConnectorServices.TRANSACTION_INTEGRATION_SERVICE, TransactionIntegration.class,\n                                    service.getTxIntegrationInjector())\n                            .addDependency(ConnectorServices.CONNECTOR_CONFIG_SERVICE, JcaSubsystemConfiguration.class,\n                                    service.getConfigInjector())\n                            .addDependency(SubjectFactoryService.SERVICE_NAME, SubjectFactory.class,\n                                    service.getSubjectFactoryInjector())\n                            .addDependency(ConnectorServices.CCM_SERVICE, CachedConnectionManager.class, service.getCcmInjector())\n                            .addDependency(NamingService.SERVICE_NAME)\n                            .addDependency(ConnectorServices.RESOURCE_ADAPTER_DEPLOYER_SERVICE_PREFIX.append(connectorXmlDescriptor.getDeploymentName()))\n                            .setInitialMode(Mode.ACTIVE).install();\n                }\n            }\n        } catch (Throwable t) {\n            throw new DeploymentUnitProcessingException(t);\n        }\n    }","commit_id":"d39fdef7ed777eaaf57d9a909436d48314d527cb","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process this deployment for annotations.  This will use an annotation indexer to create an index of all annotations\n     * found in this deployment and attach it to the deployment unit context.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final List<ResourceRoot> allResourceRoots = new ArrayList<ResourceRoot>();\n        final List<ResourceRoot> resourceRoots = phaseContext.getDeploymentUnit().getAttachment(Attachments.RESOURCE_ROOTS);\n        if (resourceRoots != null) {\n            allResourceRoots.addAll(resourceRoots);\n        }\n        allResourceRoots.add(phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_ROOT));\n        for (ResourceRoot resourceRoot : allResourceRoots) {\n            if (resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX) != null) {\n                continue;\n            }\n\n            VirtualFile indexFile = resourceRoot.getRoot().getChild(ModuleIndexBuilder.INDEX_LOCATION);\n            if (indexFile.exists()) {\n                try {\n                    IndexReader reader = new IndexReader(indexFile.openStream());\n                    resourceRoot.putAttachment(Attachments.ANNOTATION_INDEX, reader.read());\n                    logger.tracef(\"Found and read index at: %s\", indexFile);\n                    continue;\n                } catch (Exception e) {\n                    logger.debugf(\"Could not read provided index: %s\", indexFile, e);\n                }\n            }\n\n            // if this flag is present and set to false then do not index the resource\n            Boolean shouldIndexResource = resourceRoot.getAttachment(Attachments.INDEX_RESOURCE_ROOT);\n            if (shouldIndexResource != null && !shouldIndexResource) {\n                continue;\n            }\n\n            final List<String> indexIgnorePathList = resourceRoot.getAttachment(Attachments.INDEX_IGNORE_PATHS);\n            final Set<String> indexIgnorePaths;\n            if (indexIgnorePathList != null && !indexIgnorePathList.isEmpty()) {\n                indexIgnorePaths = new HashSet<String>(indexIgnorePathList);\n            } else {\n                indexIgnorePaths = null;\n            }\n\n            final VirtualFile virtualFile = resourceRoot.getRoot();\n            final Indexer indexer = new Indexer();\n            try {\n                final VisitorAttributes visitorAttributes = new VisitorAttributes();\n                visitorAttributes.setLeavesOnly(true);\n                visitorAttributes.setRecurseFilter(new VirtualFileFilter() {\n                    public boolean accepts(VirtualFile file) {\n                        return indexIgnorePaths == null || !indexIgnorePaths.contains(file.getPathNameRelativeTo(virtualFile));\n                    }\n                });\n\n                final List<VirtualFile> classChildren = virtualFile.getChildren(new SuffixMatchFilter(\".class\", visitorAttributes));\n                for (VirtualFile classFile : classChildren) {\n                    InputStream inputStream = null;\n                    try {\n                        inputStream = classFile.openStream();\n                        indexer.index(inputStream);\n                    } catch (Exception e) {\n                        logger.warn(\"Could not index class \" + classFile.getPathNameRelativeTo(virtualFile) + \" in archive '\" + virtualFile + \"'\", e);\n                    } finally {\n                        VFSUtils.safeClose(inputStream);\n                    }\n                }\n                final Index index = indexer.complete();\n                resourceRoot.putAttachment(Attachments.ANNOTATION_INDEX, index);\n                logger.tracef(\"Generated index for archive %s\", virtualFile);\n            } catch (Throwable t) {\n                throw new DeploymentUnitProcessingException(\"Failed to index deployment root for annotations\", t);\n            }\n        }\n    }","id":74478,"modified_method":"/**\n     * Process this deployment for annotations.  This will use an annotation indexer to create an index of all annotations\n     * found in this deployment and attach it to the deployment unit context.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final List<ResourceRoot> allResourceRoots = new ArrayList<ResourceRoot>();\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final List<ResourceRoot> resourceRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n        if (resourceRoots != null) {\n            allResourceRoots.addAll(resourceRoots);\n        }\n\n        allResourceRoots.add(deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT));\n        for (ResourceRoot resourceRoot : allResourceRoots) {\n            if (resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX) != null) {\n                continue;\n            }\n\n            VirtualFile indexFile = resourceRoot.getRoot().getChild(ModuleIndexBuilder.INDEX_LOCATION);\n            if (indexFile.exists()) {\n                try {\n                    IndexReader reader = new IndexReader(indexFile.openStream());\n                    resourceRoot.putAttachment(Attachments.ANNOTATION_INDEX, reader.read());\n                    logger.tracef(\"Found and read index at: %s\", indexFile);\n                    continue;\n                } catch (Exception e) {\n                    logger.debugf(\"Could not read provided index: %s\", indexFile, e);\n                }\n            }\n\n            // if this flag is present and set to false then do not index the resource\n            Boolean shouldIndexResource = resourceRoot.getAttachment(Attachments.INDEX_RESOURCE_ROOT);\n            if (shouldIndexResource != null && !shouldIndexResource) {\n                continue;\n            }\n\n            final List<String> indexIgnorePathList = resourceRoot.getAttachment(Attachments.INDEX_IGNORE_PATHS);\n            final Set<String> indexIgnorePaths;\n            if (indexIgnorePathList != null && !indexIgnorePathList.isEmpty()) {\n                indexIgnorePaths = new HashSet<String>(indexIgnorePathList);\n            } else {\n                indexIgnorePaths = null;\n            }\n\n            final VirtualFile virtualFile = resourceRoot.getRoot();\n            final Indexer indexer = new Indexer();\n            try {\n                final VisitorAttributes visitorAttributes = new VisitorAttributes();\n                visitorAttributes.setLeavesOnly(true);\n                visitorAttributes.setRecurseFilter(new VirtualFileFilter() {\n                    public boolean accepts(VirtualFile file) {\n                        return indexIgnorePaths == null || !indexIgnorePaths.contains(file.getPathNameRelativeTo(virtualFile));\n                    }\n                });\n\n                final List<VirtualFile> classChildren = virtualFile.getChildren(new SuffixMatchFilter(\".class\", visitorAttributes));\n                for (VirtualFile classFile : classChildren) {\n                    InputStream inputStream = null;\n                    try {\n                        inputStream = classFile.openStream();\n                        indexer.index(inputStream);\n                    } catch (Exception e) {\n                        logger.warn(\"Could not index class \" + classFile.getPathNameRelativeTo(virtualFile) + \" in archive '\" + virtualFile + \"'\", e);\n                    } finally {\n                        VFSUtils.safeClose(inputStream);\n                    }\n                }\n                final Index index = indexer.complete();\n                resourceRoot.putAttachment(Attachments.ANNOTATION_INDEX, index);\n                logger.tracef(\"Generated index for archive %s\", virtualFile);\n            } catch (Throwable t) {\n                throw new DeploymentUnitProcessingException(\"Failed to index deployment root for annotations\", t);\n            }\n        }\n\n\n    }","commit_id":"fa1542b93b53be49e693bbbaa69eae846ab26607","url":"https://github.com/wildfly/wildfly"},{"original_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final Boolean computeCompositeIndex = deploymentUnit.getAttachment(Attachments.COMPUTE_COMPOSITE_ANNOTATION_INDEX);\n        if(computeCompositeIndex != null && !computeCompositeIndex) {\n            return;\n        }\n\n        final List<ModuleIdentifier> additionalModuleIndexes = deploymentUnit.getAttachmentList(Attachments.ADDITIONAL_ANNOTATION_INDEXES);\n        final List<Index> indexes = new ArrayList<Index>();\n        for(ModuleIdentifier moduleIdentifier : additionalModuleIndexes) {\n            try {\n                Module module = Module.getBootModuleLoader().loadModule(moduleIdentifier);\n                final CompositeIndex additionalIndex = ModuleIndexBuilder.buildCompositeIndex(module);\n                if(additionalIndex != null) {\n                    indexes.addAll(additionalIndex.indexes);\n                }else {\n                    log.errorf(\"Module %s will not have it's annotations processed as no %s file was found in the deployment. Please generate this file using the Jandex ant task.\", module.getIdentifier(), ModuleIndexBuilder.INDEX_LOCATION);\n                }\n            } catch (ModuleLoadException e) {\n                throw new DeploymentUnitProcessingException(e);\n            }\n        }\n\n        final List<ResourceRoot> allResourceRoots = new ArrayList<ResourceRoot>();\n        final Boolean processChildren = deploymentUnit.getAttachment(Attachments.PROCESS_CHILD_ANNOTATION_INDEX);\n        if(processChildren == null || processChildren) {\n            final List<ResourceRoot> resourceRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n            if (resourceRoots != null) {\n                for (ResourceRoot resourceRoot : resourceRoots) {\n                    // do not add child sub deployments to the composite index\n                    if (!SubDeploymentMarker.isSubDeployment(resourceRoot) && ModuleRootMarker.isModuleRoot(resourceRoot)) {\n                        allResourceRoots.add(resourceRoot);\n                    }\n                }\n            }\n        }\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        if(ModuleRootMarker.isModuleRoot(deploymentRoot)) {\n            allResourceRoots.add(deploymentRoot);\n        }\n        for (ResourceRoot resourceRoot : allResourceRoots) {\n            Index index = resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX);\n            if (index != null) {\n                indexes.add(index);\n            }\n        }\n        deploymentUnit.putAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX, new CompositeIndex(indexes));\n    }","id":74479,"modified_method":"public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final Boolean computeCompositeIndex = deploymentUnit.getAttachment(Attachments.COMPUTE_COMPOSITE_ANNOTATION_INDEX);\n        if(computeCompositeIndex != null && !computeCompositeIndex) {\n            return;\n        }\n\n        final List<ModuleIdentifier> additionalModuleIndexes = deploymentUnit.getAttachmentList(Attachments.ADDITIONAL_ANNOTATION_INDEXES);\n        final List<Index> indexes = new ArrayList<Index>();\n        for(final ModuleIdentifier moduleIdentifier : additionalModuleIndexes) {\n            try {\n                Module module = Module.getBootModuleLoader().loadModule(moduleIdentifier);\n                final CompositeIndex additionalIndex = ModuleIndexBuilder.buildCompositeIndex(module);\n                if(additionalIndex != null) {\n                    indexes.addAll(additionalIndex.indexes);\n                }else {\n                    log.errorf(\"Module %s will not have it's annotations processed as no %s file was found in the deployment. Please generate this file using the Jandex ant task.\", module.getIdentifier(), ModuleIndexBuilder.INDEX_LOCATION);\n                }\n            } catch (ModuleLoadException e) {\n                throw new DeploymentUnitProcessingException(e);\n            }\n        }\n\n        final List<ResourceRoot> allResourceRoots = new ArrayList<ResourceRoot>();\n        final Boolean processChildren = deploymentUnit.getAttachment(Attachments.PROCESS_CHILD_ANNOTATION_INDEX);\n        if(processChildren == null || processChildren) {\n            final List<ResourceRoot> resourceRoots = deploymentUnit.getAttachment(Attachments.RESOURCE_ROOTS);\n            if (resourceRoots != null) {\n                for (ResourceRoot resourceRoot : resourceRoots) {\n                    // do not add child sub deployments to the composite index\n                    if (!SubDeploymentMarker.isSubDeployment(resourceRoot) && ModuleRootMarker.isModuleRoot(resourceRoot)) {\n                        allResourceRoots.add(resourceRoot);\n                    }\n                }\n            }\n        }\n\n        //we merge all Class-Path annotation indexes into the deployments composite index\n        //this means that if component defining annotations (e.g. @Stateless) are specified in a Class-Path\n        //entry references by two sub deployments this component will be created twice.\n        //the spec expects this behaviour, and explicitly warns not to put component defining annotations\n        //in Class-Path items\n        allResourceRoots.addAll(deploymentUnit.getAttachmentList(Attachments.CLASS_PATH_RESOURCE_ROOTS));\n\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        if(ModuleRootMarker.isModuleRoot(deploymentRoot)) {\n            allResourceRoots.add(deploymentRoot);\n        }\n        for (ResourceRoot resourceRoot : allResourceRoots) {\n            Index index = resourceRoot.getAttachment(Attachments.ANNOTATION_INDEX);\n            if (index != null) {\n                indexes.add(index);\n            }\n        }\n        deploymentUnit.putAttachment(Attachments.COMPOSITE_ANNOTATION_INDEX, new CompositeIndex(indexes));\n    }","commit_id":"fa1542b93b53be49e693bbbaa69eae846ab26607","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates a {@link ResourceRoot} for the passed {@link VirtualFile file} and adds it to the list of {@link ResourceRoot}s\n     * in the {@link DeploymentUnit deploymentUnit}\n     *\n     * @param deploymentUnit The deployment unit\n     * @param file           The file for which the resource root will be created\n     * @return Returns the created {@link ResourceRoot}\n     * @throws java.io.IOException\n     */\n    private ResourceRoot createResourceRoot(final DeploymentUnit deploymentUnit, final VirtualFile file) {\n        try {\n            final Closeable closable = file.isFile() ? VFS.mountZip(file, file, TempFileProviderService.provider()) : null;\n            final MountHandle mountHandle = new MountHandle(closable);\n            final ResourceRoot resourceRoot = new ResourceRoot(file, mountHandle);\n            deploymentUnit.addToAttachmentList(Attachments.RESOURCE_ROOTS, resourceRoot);\n            return resourceRoot;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":74480,"modified_method":"/**\n     * Creates a {@link ResourceRoot} for the passed {@link VirtualFile file} and adds it to the list of {@link ResourceRoot}s\n     * in the {@link DeploymentUnit deploymentUnit}\n     *\n     * @param deploymentUnit The deployment unit\n     * @param file           The file for which the resource root will be created\n     * @return Returns the created {@link ResourceRoot}\n     * @throws java.io.IOException\n     */\n    private ResourceRoot createResourceRoot(final DeploymentUnit deploymentUnit, final VirtualFile file) throws DeploymentUnitProcessingException {\n        try {\n            final Closeable closable = file.isFile() ? VFS.mountZip(file, file, TempFileProviderService.provider()) : null;\n            final MountHandle mountHandle = new MountHandle(closable);\n            final ResourceRoot resourceRoot = new ResourceRoot(file, mountHandle);\n            deploymentUnit.addToAttachmentList(Attachments.RESOURCE_ROOTS, resourceRoot);\n            indexResourceRoot(resourceRoot);\n            deploymentUnit.addToAttachmentList(Attachments.CLASS_PATH_RESOURCE_ROOTS, resourceRoot);\n            return resourceRoot;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"fa1542b93b53be49e693bbbaa69eae846ab26607","url":"https://github.com/wildfly/wildfly"},{"original_method":"public boolean equals(Object o) {\n        if (this == o)\n            return true;\n\n        if (!(o instanceof EjbInjectionSource))\n            return false;\n        if(error != null) {\n            //we can't do a real equals comparison in this case, so throw the original error\n            throw new RuntimeException(error);\n        }\n        if(resolvedViewName == null) {\n            throw new RuntimeException(\"Error equals() cannot be called before resolve()\");\n        }\n\n        EjbInjectionSource other = (EjbInjectionSource) o;\n        return eq(typeName, other.typeName) && eq(resolvedViewName, other.resolvedViewName);\n    }","id":74481,"modified_method":"public boolean equals(Object o) {\n        if (this == o)\n            return true;\n\n        if (!(o instanceof EjbInjectionSource))\n            return false;\n        if(error != null) {\n            //we can't do a real equals comparison in this case, so just return false\n            return false;\n        }\n        if(resolvedViewName == null) {\n            throw new RuntimeException(\"Error equals() cannot be called before resolve()\");\n        }\n\n        EjbInjectionSource other = (EjbInjectionSource) o;\n        return eq(typeName, other.typeName) && eq(resolvedViewName, other.resolvedViewName);\n    }","commit_id":"fa1542b93b53be49e693bbbaa69eae846ab26607","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void handlingExistingClassPathEntry(final DeploymentUnit deploymentUnit, final ArrayDeque<ResourceRoot> resourceRoots, final DeploymentUnit topLevelDeployment, final VirtualFile topLevelRoot, final Map<VirtualFile, ResourceRoot> subDeployments, final Map<VirtualFile, AdditionalModuleSpecification> additionalModules, final Set<VirtualFile> earLibJars, final ResourceRoot resourceRoot, final Attachable target, final VirtualFile topLevelClassPathFile) {\n        if (earLibJars.contains(topLevelClassPathFile)) {\n            log.debugf(\"Class-Path entry %s in %s ignored, as target is in or referenced by /lib\", topLevelClassPathFile, resourceRoot.getRoot());\n        } else if (additionalModules.containsKey(topLevelClassPathFile)) {\n            target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, additionalModules.get(topLevelClassPathFile).getModuleIdentifier());\n        } else if (subDeployments.containsKey(topLevelClassPathFile)) {\n            //now we need to calculate the sub deployment module identifer\n            //unfortunately the sub deployment has not been setup yet, so we cannot just\n            //get it from the sub deployment directly\n            final ResourceRoot otherRoot = subDeployments.get(topLevelClassPathFile);\n            target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, ModuleIdentifierProcessor.createModuleIdentifier(otherRoot.getRootName(), otherRoot, topLevelDeployment, topLevelRoot, false));\n        } else {\n            createAdditionalModule(deploymentUnit, topLevelDeployment, topLevelRoot, additionalModules, resourceRoot, topLevelClassPathFile, resourceRoots);\n        }\n    }","id":74482,"modified_method":"private void handlingExistingClassPathEntry(final DeploymentUnit deploymentUnit, final ArrayDeque<ResourceRoot> resourceRoots, final DeploymentUnit topLevelDeployment, final VirtualFile topLevelRoot, final Map<VirtualFile, ResourceRoot> subDeployments, final Map<VirtualFile, AdditionalModuleSpecification> additionalModules, final Set<VirtualFile> earLibJars, final ResourceRoot resourceRoot, final Attachable target, final VirtualFile topLevelClassPathFile) throws DeploymentUnitProcessingException {\n        if (earLibJars.contains(topLevelClassPathFile)) {\n            log.debugf(\"Class-Path entry %s in %s ignored, as target is in or referenced by /lib\", topLevelClassPathFile, resourceRoot.getRoot());\n        } else if (additionalModules.containsKey(topLevelClassPathFile)) {\n            final AdditionalModuleSpecification moduleSpecification = additionalModules.get(topLevelClassPathFile);\n            target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, moduleSpecification.getModuleIdentifier());\n            for (final ResourceRoot root : moduleSpecification.getResourceRoots()) {\n                //add this to the list of roots to be processed, so transitive class path entries will be respected\n                resourceRoots.add(root);\n                deploymentUnit.addToAttachmentList(Attachments.CLASS_PATH_RESOURCE_ROOTS, root);\n            }\n        } else if (subDeployments.containsKey(topLevelClassPathFile)) {\n            //now we need to calculate the sub deployment module identifer\n            //unfortunately the sub deployment has not been setup yet, so we cannot just\n            //get it from the sub deployment directly\n            final ResourceRoot otherRoot = subDeployments.get(topLevelClassPathFile);\n            target.addToAttachmentList(Attachments.CLASS_PATH_ENTRIES, ModuleIdentifierProcessor.createModuleIdentifier(otherRoot.getRootName(), otherRoot, topLevelDeployment, topLevelRoot, false));\n        } else {\n            createAdditionalModule(deploymentUnit, topLevelDeployment, topLevelRoot, additionalModules, resourceRoot, topLevelClassPathFile, resourceRoots);\n        }\n    }","commit_id":"fa1542b93b53be49e693bbbaa69eae846ab26607","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Creates a {@link ResourceRoot} for the passed {@link VirtualFile file} and adds it to the list of {@link ResourceRoot}s\n     * in the {@link DeploymentUnit deploymentUnit}\n     *\n     * @param deploymentUnit The deployment unit\n     * @param file           The file for which the resource root will be created\n     * @return Returns the created {@link ResourceRoot}\n     * @throws java.io.IOException\n     */\n    private synchronized ResourceRoot createResourceRoot(final DeploymentUnit deploymentUnit, final VirtualFile file) {\n        try {\n            final Closeable closable = file.isFile() ? VFS.mountZip(file, file, TempFileProviderService.provider()) : null;\n            final MountHandle mountHandle = new MountHandle(closable);\n            final ResourceRoot resourceRoot = new ResourceRoot(file, mountHandle);\n            deploymentUnit.addToAttachmentList(Attachments.RESOURCE_ROOTS, resourceRoot);\n            ModuleRootMarker.mark(resourceRoot);\n            return resourceRoot;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","id":74483,"modified_method":"/**\n     * Creates a {@link ResourceRoot} for the passed {@link VirtualFile file} and adds it to the list of {@link ResourceRoot}s\n     * in the {@link DeploymentUnit deploymentUnit}\n     *\n     * @param deploymentUnit The deployment unit\n     * @param file           The file for which the resource root will be created\n     * @return Returns the created {@link ResourceRoot}\n     * @throws java.io.IOException\n     */\n    private synchronized ResourceRoot createResourceRoot(final DeploymentUnit deploymentUnit, final VirtualFile file) throws DeploymentUnitProcessingException {\n        try {\n            final Closeable closable = file.isFile() ? VFS.mountZip(file, file, TempFileProviderService.provider()) : null;\n            final MountHandle mountHandle = new MountHandle(closable);\n            final ResourceRoot resourceRoot = new ResourceRoot(file, mountHandle);\n            deploymentUnit.addToAttachmentList(Attachments.RESOURCE_ROOTS, resourceRoot);\n            ModuleRootMarker.mark(resourceRoot);\n            indexResourceRoot(resourceRoot);\n            return resourceRoot;\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }","commit_id":"fa1542b93b53be49e693bbbaa69eae846ab26607","url":"https://github.com/wildfly/wildfly"},{"original_method":"private void createAdditionalModule(final DeploymentUnit deploymentUnit, final DeploymentUnit topLevelDeployment, final VirtualFile topLevelRoot, final Map<VirtualFile, AdditionalModuleSpecification> additionalModules, final ResourceRoot resourceRoot, final VirtualFile classPathFile, final ArrayDeque<ResourceRoot> resourceRoots) {\n        final ResourceRoot root = createResourceRoot(deploymentUnit, classPathFile);\n\n        //add this to the list of roots to be processed, so transitive class path entries will be respected\n        resourceRoots.add(root);\n        String pathName = root.getRoot().getPathNameRelativeTo(topLevelRoot);\n        ModuleIdentifier identifier = ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX + topLevelDeployment.getName() + \".\" + pathName);\n        AdditionalModuleSpecification module = new AdditionalModuleSpecification(identifier, root);\n        topLevelDeployment.addToAttachmentList(Attachments.ADDITIONAL_MODULES, module);\n        additionalModules.put(classPathFile, module);\n    }","id":74484,"modified_method":"private void createAdditionalModule(final DeploymentUnit deploymentUnit, final DeploymentUnit topLevelDeployment, final VirtualFile topLevelRoot, final Map<VirtualFile, AdditionalModuleSpecification> additionalModules, final ResourceRoot resourceRoot, final VirtualFile classPathFile, final ArrayDeque<ResourceRoot> resourceRoots) throws DeploymentUnitProcessingException {\n        final ResourceRoot root = createResourceRoot(deploymentUnit, classPathFile);\n\n        //add this to the list of roots to be processed, so transitive class path entries will be respected\n        resourceRoots.add(root);\n        String pathName = root.getRoot().getPathNameRelativeTo(topLevelRoot);\n        ModuleIdentifier identifier = ModuleIdentifier.create(ServiceModuleLoader.MODULE_PREFIX + topLevelDeployment.getName() + \".\" + pathName);\n        AdditionalModuleSpecification module = new AdditionalModuleSpecification(identifier, root);\n        topLevelDeployment.addToAttachmentList(Attachments.ADDITIONAL_MODULES, module);\n        additionalModules.put(classPathFile, module);\n        deploymentUnit.addToAttachmentList(Attachments.CLASS_PATH_RESOURCE_ROOTS, root);\n    }","commit_id":"fa1542b93b53be49e693bbbaa69eae846ab26607","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process a deployment for standard ra deployment files. Will parse the xml\n     * file and attach an configuration discovered during processing.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n\n        final Set<VirtualFile> files = dataSources(deploymentUnit);\n\n        for (VirtualFile f : files) {\n            InputStream xmlStream = null;\n            try {\n                xmlStream = new FileInputStream(f.getPhysicalFile());\n                DsParser parser = new DsParser();\n                DataSources dataSources = parser.parse(xmlStream);\n                if (dataSources != null) {\n                    deploymentUnit.addToAttachmentList(DATA_SOURCES_ATTACHMENT_KEY, dataSources);\n                }\n            } catch (Exception e) {\n                throw new DeploymentUnitProcessingException(e.getMessage(), e);\n            } finally {\n                VFSUtils.safeClose(xmlStream);\n            }\n        }\n    }","id":74485,"modified_method":"/**\n     * Process a deployment for standard ra deployment files. Will parse the xml\n     * file and attach an configuration discovered during processing.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        boolean resolveProperties = Util.shouldResolveJBoss(deploymentUnit);\n\n        final Set<VirtualFile> files = dataSources(deploymentUnit);\n\n        for (VirtualFile f : files) {\n            InputStream xmlStream = null;\n            try {\n                xmlStream = new FileInputStream(f.getPhysicalFile());\n                DsParser parser = new DsParser();\n                parser.setSystemPropertiesResolved(resolveProperties);\n                DataSources dataSources = parser.parse(xmlStream);\n                if (dataSources != null) {\n                    deploymentUnit.addToAttachmentList(DATA_SOURCES_ATTACHMENT_KEY, dataSources);\n                }\n            } catch (Exception e) {\n                throw new DeploymentUnitProcessingException(e.getMessage(), e);\n            } finally {\n                VFSUtils.safeClose(xmlStream);\n            }\n        }\n    }","commit_id":"780031532636acfd6bddb62c2abac403da88df71","url":"https://github.com/wildfly/wildfly"},{"original_method":"protected void performBoottime(OperationContext context, final ModelNode operation, final ModelNode model,\n                                   final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final EEJndiViewExtension extension = new EEJndiViewExtension();\n        context.getServiceTarget().addService(EEJndiViewExtension.SERVICE_NAME, extension)\n                .addDependency(JndiViewExtensionRegistry.SERVICE_NAME, JndiViewExtensionRegistry.class, extension.getRegistryInjector())\n                .addListener(verificationHandler)\n                .install();\n\n        final ModelNode globalModules = GlobalModulesDefinition.INSTANCE.resolveModelAttribute(context, model);\n        // see if the ear subdeployment isolation flag is set. By default, we don't isolate subdeployments, so that\n        // they can see each other's classes.\n        final boolean earSubDeploymentsIsolated = EeSubsystemRootResource.EAR_SUBDEPLOYMENTS_ISOLATED.resolveModelAttribute(context, model).asBoolean();\n        final boolean spedDescriptorPropertyReplacement = EeSubsystemRootResource.SPEC_DESCRIPTOR_PROPERTY_REPLACEMENT.resolveModelAttribute(context, model).asBoolean();\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                moduleDependencyProcessor.setGlobalModules(globalModules);\n                isolationProcessor.setEarSubDeploymentsIsolated(earSubDeploymentsIsolated);\n                specDescriptorPropertyReplacementProcessor.setDescriptorPropertyReplacement(spedDescriptorPropertyReplacement);\n\n                ROOT_LOGGER.debug(\"Activating EE subsystem\");\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_SPEC_DESC_PROPERTY_REPLACEMENT, specDescriptorPropertyReplacementProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_JBOSS_DESC_PROPERTY_REPLACEMENT, jbossDescriptorPropertyReplacementProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EAR_DEPLOYMENT_INIT, new EarInitializationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EAR_APP_XML_PARSE, new EarMetaDataParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_JBOSS_EJB_CLIENT_XML_PARSE, new EJBClientDescriptorParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EJB_EAR_APPLICATION_NAME, new EarApplicationNameProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EAR, new EarStructureProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EJB_JAR_IN_EAR, new EjbJarDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_APPLICATION_CLIENT_IN_EAR, new ApplicationClientDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_MANAGED_BEAN_JAR_IN_EAR, new ManagedBeanSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_MODULE_INIT, new EEModuleInitialProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_RESOURCE_INJECTION_REGISTRY, new ResourceReferenceRegistrySetupProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_DEPLOYMENT_PROPERTIES, new DeploymentPropertiesProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_DEPLOYMENT_PROPERTY_RESOLVER, new DeploymentPropertyResolverProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_VAULT_PROPERTY_RESOLVER, new VaultPropertyResolverProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_SYSTEM_PROPERTY_RESOLVER, new SystemPropertyResolverProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_PROPERTY_RESOLVER, new PropertyResolverProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_MODULE_NAME, new EEModuleNameProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_ANNOTATIONS, new EEAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_LIFECYCLE_ANNOTATION, new LifecycleAnnotationParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_AROUNDINVOKE_ANNOTATION, new AroundInvokeAnnotationParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EAR_SUBDEPLOYMENTS_ISOLATION_DEFAULT, isolationProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_DISTINCT_NAME, new EEDistinctNameProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EAR_MESSAGE_DESTINATIONS, new EarMessageDestinationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_MANAGED_BEAN_ANNOTATION, new ManagedBeanAnnotationProcessor());\n\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_MANAGED_BEAN, new JavaEEDependencyProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_GLOBAL_MODULES, moduleDependencyProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_EE_CLASS_DESCRIPTIONS, new ApplicationClassesAggregationProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_VALIDATOR_FACTORY, new BeanValidationFactoryDeployer());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EAR_DEPENDENCY, new EarDependencyProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_INITIALIZE_IN_ORDER, new InitializeInOrderProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_INJECTION_ANNOTATION, new ResourceInjectionAnnotationParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_ENV_ENTRY, new ResourceReferenceProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_INTERCEPTOR_ANNOTATIONS, new InterceptorAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_NAMING_CONTEXT, new ModuleContextProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APP_NAMING_CONTEXT, new ApplicationContextProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVE_MESSAGE_DESTINATIONS, new MessageDestinationResolutionProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_COMPONENT_AGGREGATION, new ComponentAggregationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_MODULE_JNDI_BINDINGS, new ModuleJndiBindingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EE_MODULE_CONFIG, new EEModuleConfigurationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EE_COMPONENT, new ComponentInstallProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.CLEANUP, Phase.CLEANUP_EE, new EECleanUpProcessor());\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n    }","id":74486,"modified_method":"protected void performBoottime(OperationContext context, final ModelNode operation, final ModelNode model,\n                                   final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) throws OperationFailedException {\n        final EEJndiViewExtension extension = new EEJndiViewExtension();\n        context.getServiceTarget().addService(EEJndiViewExtension.SERVICE_NAME, extension)\n                .addDependency(JndiViewExtensionRegistry.SERVICE_NAME, JndiViewExtensionRegistry.class, extension.getRegistryInjector())\n                .addListener(verificationHandler)\n                .install();\n\n        final ModelNode globalModules = GlobalModulesDefinition.INSTANCE.resolveModelAttribute(context, model);\n        // see if the ear subdeployment isolation flag is set. By default, we don't isolate subdeployments, so that\n        // they can see each other's classes.\n        final boolean earSubDeploymentsIsolated = EeSubsystemRootResource.EAR_SUBDEPLOYMENTS_ISOLATED.resolveModelAttribute(context, model).asBoolean();\n        final boolean specDescriptorPropertyReplacement = EeSubsystemRootResource.SPEC_DESCRIPTOR_PROPERTY_REPLACEMENT.resolveModelAttribute(context, model).asBoolean();\n        final boolean jbossDescriptorPropertyReplacement = EeSubsystemRootResource.JBOSS_DESCRIPTOR_PROPERTY_REPLACEMENT.resolveModelAttribute(context, model).asBoolean();\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n\n                moduleDependencyProcessor.setGlobalModules(globalModules);\n                isolationProcessor.setEarSubDeploymentsIsolated(earSubDeploymentsIsolated);\n                specDescriptorPropertyReplacementProcessor.setDescriptorPropertyReplacement(specDescriptorPropertyReplacement);\n                jbossDescriptorPropertyReplacementProcessor.setDescriptorPropertyReplacement(jbossDescriptorPropertyReplacement);\n\n\n                ROOT_LOGGER.debug(\"Activating EE subsystem\");\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_SPEC_DESC_PROPERTY_REPLACEMENT, specDescriptorPropertyReplacementProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_JBOSS_DESC_PROPERTY_REPLACEMENT, jbossDescriptorPropertyReplacementProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EAR_DEPLOYMENT_INIT, new EarInitializationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EAR_APP_XML_PARSE, new EarMetaDataParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_JBOSS_EJB_CLIENT_XML_PARSE, new EJBClientDescriptorParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EJB_EAR_APPLICATION_NAME, new EarApplicationNameProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EAR, new EarStructureProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EJB_JAR_IN_EAR, new EjbJarDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_APPLICATION_CLIENT_IN_EAR, new ApplicationClientDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_MANAGED_BEAN_JAR_IN_EAR, new ManagedBeanSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_MODULE_INIT, new EEModuleInitialProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_EE_RESOURCE_INJECTION_REGISTRY, new ResourceReferenceRegistrySetupProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_DEPLOYMENT_PROPERTIES, new DeploymentPropertiesProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_DEPLOYMENT_PROPERTY_RESOLVER, new DeploymentPropertyResolverProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_VAULT_PROPERTY_RESOLVER, new VaultPropertyResolverProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_SYSTEM_PROPERTY_RESOLVER, new SystemPropertyResolverProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_PROPERTY_RESOLVER, new PropertyResolverProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_MODULE_NAME, new EEModuleNameProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EE_ANNOTATIONS, new EEAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_LIFECYCLE_ANNOTATION, new LifecycleAnnotationParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_AROUNDINVOKE_ANNOTATION, new AroundInvokeAnnotationParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EAR_SUBDEPLOYMENTS_ISOLATION_DEFAULT, isolationProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_DISTINCT_NAME, new EEDistinctNameProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_EAR_MESSAGE_DESTINATIONS, new EarMessageDestinationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_MANAGED_BEAN_ANNOTATION, new ManagedBeanAnnotationProcessor());\n\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_MANAGED_BEAN, new JavaEEDependencyProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_GLOBAL_MODULES, moduleDependencyProcessor);\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_EE_CLASS_DESCRIPTIONS, new ApplicationClassesAggregationProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_VALIDATOR_FACTORY, new BeanValidationFactoryDeployer());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_EAR_DEPENDENCY, new EarDependencyProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_INITIALIZE_IN_ORDER, new InitializeInOrderProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_INJECTION_ANNOTATION, new ResourceInjectionAnnotationParsingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_ENV_ENTRY, new ResourceReferenceProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_INTERCEPTOR_ANNOTATIONS, new InterceptorAnnotationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_NAMING_CONTEXT, new ModuleContextProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.POST_MODULE, Phase.POST_MODULE_APP_NAMING_CONTEXT, new ApplicationContextProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVE_MESSAGE_DESTINATIONS, new MessageDestinationResolutionProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_COMPONENT_AGGREGATION, new ComponentAggregationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_MODULE_JNDI_BINDINGS, new ModuleJndiBindingProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EE_MODULE_CONFIG, new EEModuleConfigurationProcessor());\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_EE_COMPONENT, new ComponentInstallProcessor());\n\n                processorTarget.addDeploymentProcessor(EeExtension.SUBSYSTEM_NAME, Phase.CLEANUP, Phase.CLEANUP_EE, new EECleanUpProcessor());\n\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n    }","commit_id":"780031532636acfd6bddb62c2abac403da88df71","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process a deployment for iron-jacamar.xml files. Will parse the xml file\n     * and attach metadata discovered during processing.\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final ResourceRoot resourceRoot = phaseContext.getDeploymentUnit().getAttachment(Attachments.DEPLOYMENT_ROOT);\n        final VirtualFile deploymentRoot = resourceRoot.getRoot();\n\n        if (deploymentRoot == null || !deploymentRoot.exists())\n            return;\n\n        final String deploymentRootName = deploymentRoot.getName().toLowerCase(Locale.ENGLISH);\n        VirtualFile serviceXmlFile = null;\n        if (deploymentRootName.endsWith(\".rar\")) {\n            serviceXmlFile = deploymentRoot.getChild(\"/META-INF/ironjacamar.xml\");\n        }\n\n        if (serviceXmlFile == null || !serviceXmlFile.exists())\n            return;\n\n        InputStream xmlStream = null;\n        IronJacamar result = null;\n        try {\n            xmlStream = serviceXmlFile.openStream();\n            result = (new IronJacamarParser()).parse(xmlStream);\n            if (result != null) {\n                IronJacamarXmlDescriptor xmlDescriptor = new IronJacamarXmlDescriptor(result);\n                phaseContext.getDeploymentUnit().putAttachment(IronJacamarXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);\n            } else\n                throw MESSAGES.failedToParseServiceXml(serviceXmlFile);\n        } catch (Exception e) {\n            throw MESSAGES.failedToParseServiceXml(e, serviceXmlFile);\n        } finally {\n            VFSUtils.safeClose(xmlStream);\n        }\n    }","id":74487,"modified_method":"/**\n     * Process a deployment for iron-jacamar.xml files. Will parse the xml file\n     * and attach metadata discovered during processing.\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ResourceRoot resourceRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        final VirtualFile deploymentRoot = resourceRoot.getRoot();\n        final boolean resolveProperties = Util.shouldResolveJBoss(deploymentUnit);\n\n        if (deploymentRoot == null || !deploymentRoot.exists())\n            return;\n\n        final String deploymentRootName = deploymentRoot.getName().toLowerCase(Locale.ENGLISH);\n        VirtualFile serviceXmlFile = null;\n        if (deploymentRootName.endsWith(\".rar\")) {\n            serviceXmlFile = deploymentRoot.getChild(\"/META-INF/ironjacamar.xml\");\n        }\n\n        if (serviceXmlFile == null || !serviceXmlFile.exists())\n            return;\n\n        InputStream xmlStream = null;\n        IronJacamar result = null;\n        try {\n            xmlStream = serviceXmlFile.openStream();\n            IronJacamarParser ironJacamarParser = new IronJacamarParser();\n            ironJacamarParser.setSystemPropertiesResolved(resolveProperties);\n            result = ironJacamarParser.parse(xmlStream);\n            if (result != null) {\n                IronJacamarXmlDescriptor xmlDescriptor = new IronJacamarXmlDescriptor(result);\n                deploymentUnit.putAttachment(IronJacamarXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);\n            } else\n                throw MESSAGES.failedToParseServiceXml(serviceXmlFile);\n        } catch (Exception e) {\n            throw MESSAGES.failedToParseServiceXml(e, serviceXmlFile);\n        } finally {\n            VFSUtils.safeClose(xmlStream);\n        }\n    }","commit_id":"780031532636acfd6bddb62c2abac403da88df71","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Process a deployment for standard ra deployment files. Will parse the xml\n     * file and attach an configuration discovered during processing.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n\n        final VirtualFile file = deploymentRoot.getRoot();\n        if (file == null || !file.exists())\n            return;\n\n        final String deploymentRootName = file.getName().toLowerCase(Locale.ENGLISH);\n        if (!deploymentRootName.endsWith(\".rar\")) {\n            return;\n        }\n\n        final VirtualFile alternateDescriptor = deploymentRoot.getAttachment(org.jboss.as.ee.structure.Attachments.ALTERNATE_CONNECTOR_DEPLOYMENT_DESCRIPTOR);\n        // Locate the descriptor\n        final VirtualFile serviceXmlFile;\n        if (alternateDescriptor != null) {\n            serviceXmlFile = alternateDescriptor;\n        } else {\n            serviceXmlFile = file.getChild(\"/META-INF/ra.xml\");\n        }\n        InputStream xmlStream = null;\n        Connector result = null;\n        try {\n            if (serviceXmlFile != null && serviceXmlFile.exists()) {\n\n                xmlStream = serviceXmlFile.openStream();\n                result = (new RaParser()).parse(xmlStream);\n                if (result == null)\n                    throw MESSAGES.failedToParseServiceXml(serviceXmlFile);\n            }\n            File root = file.getPhysicalFile();\n            URL url = root.toURI().toURL();\n            String prefix = \"\";\n\n            if (deploymentUnit.getParent() != null) {\n                prefix = deploymentUnit.getParent().getName() + \"#\";\n            }\n\n            String deploymentName = prefix + file.getName().substring(0, file.getName().indexOf(\".rar\"));\n            ConnectorXmlDescriptor xmlDescriptor = new ConnectorXmlDescriptor(result, root, url, deploymentName);\n            phaseContext.getDeploymentUnit().putAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);\n\n        } catch (Exception e) {\n            throw MESSAGES.failedToParseServiceXml(e, serviceXmlFile);\n        } finally {\n            VFSUtils.safeClose(xmlStream);\n        }\n    }","id":74488,"modified_method":"/**\n     * Process a deployment for standard ra deployment files. Will parse the xml\n     * file and attach an configuration discovered during processing.\n     *\n     * @param phaseContext the deployment unit context\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n        final DeploymentUnit deploymentUnit = phaseContext.getDeploymentUnit();\n        final ResourceRoot deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        final boolean resolveProperties = Util.shouldResolveSpec(deploymentUnit);\n\n        final VirtualFile file = deploymentRoot.getRoot();\n        if (file == null || !file.exists())\n            return;\n\n        final String deploymentRootName = file.getName().toLowerCase(Locale.ENGLISH);\n        if (!deploymentRootName.endsWith(\".rar\")) {\n            return;\n        }\n\n        final VirtualFile alternateDescriptor = deploymentRoot.getAttachment(org.jboss.as.ee.structure.Attachments.ALTERNATE_CONNECTOR_DEPLOYMENT_DESCRIPTOR);\n        // Locate the descriptor\n        final VirtualFile serviceXmlFile;\n        if (alternateDescriptor != null) {\n            serviceXmlFile = alternateDescriptor;\n        } else {\n            serviceXmlFile = file.getChild(\"/META-INF/ra.xml\");\n        }\n        InputStream xmlStream = null;\n        Connector result = null;\n        try {\n            if (serviceXmlFile != null && serviceXmlFile.exists()) {\n\n                xmlStream = serviceXmlFile.openStream();\n                RaParser raParser = new RaParser();\n                raParser.setSystemPropertiesResolved(resolveProperties);\n                result = raParser.parse(xmlStream);\n                if (result == null)\n                    throw MESSAGES.failedToParseServiceXml(serviceXmlFile);\n            }\n            File root = file.getPhysicalFile();\n            URL url = root.toURI().toURL();\n            String prefix = \"\";\n\n            if (deploymentUnit.getParent() != null) {\n                prefix = deploymentUnit.getParent().getName() + \"#\";\n            }\n\n            String deploymentName = prefix + file.getName().substring(0, file.getName().indexOf(\".rar\"));\n            ConnectorXmlDescriptor xmlDescriptor = new ConnectorXmlDescriptor(result, root, url, deploymentName);\n            phaseContext.getDeploymentUnit().putAttachment(ConnectorXmlDescriptor.ATTACHMENT_KEY, xmlDescriptor);\n\n        } catch (Exception e) {\n            throw MESSAGES.failedToParseServiceXml(e, serviceXmlFile);\n        } finally {\n            VFSUtils.safeClose(xmlStream);\n        }\n    }","commit_id":"780031532636acfd6bddb62c2abac403da88df71","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, FileEntry.class.getName(),\n\t\t\tfileEntry.getFileEntryId());\n\n\t\tElement fileEntryElement =\n\t\t\tportletDataContext.getImportDataElement(\n\t\t\t\tFileEntry.class.getSimpleName(), \"path\", path);\n\n\t\tList<Element> referenceDataElements =\n\t\t\tportletDataContext.getReferenceDataElements(\n\t\t\t\tfileEntryElement, Repository.class);\n\n\t\tfor (Element referenceDataElement : referenceDataElements) {\n\t\t\tString referencePath = referenceDataElement.attributeValue(\"path\");\n\n\t\t\tStagedModel referenceStagedModel =\n\t\t\t\t(StagedModel)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\treferencePath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, referenceStagedModel);\n\t\t}\n\n\t\tif (fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tString folderPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Folder.class.getName(),\n\t\t\t\tfileEntry.getFolderId());\n\n\t\t\tFolder folder = (Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfolderPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, folder);\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderIds, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\tString[] assetTagNames = portletDataContext.getAssetTagNames(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileEntry, DLPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"sourceFileName\", \"A.\" + fileEntry.getExtension());\n\t\tserviceContext.setUserId(userId);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tInputStream is = null;\n\n\t\tif (Validator.isNull(binPath) &&\n\t\t\tportletDataContext.isPerformDirectBinaryImport()) {\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tis = portletDataContext.getZipEntryAsInputStream(binPath);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\timportMetaData(portletDataContext, fileEntryElement, serviceContext);\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tString titleWithExtension = DLUtil.getTitleWithExtension(fileEntry);\n\t\tString extension = fileEntry.getExtension();\n\n\t\tString dotExtension = StringPool.PERIOD + extension;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tString fileEntryTitle = fileEntry.getTitle();\n\n\t\t\t\tFileEntry existingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\tif ((fileEntry.getGroupId() ==\n\t\t\t\t\t\t\tportletDataContext.getSourceGroupId()) &&\n\t\t\t\t\t\tportletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwriting()) {\n\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tboolean titleHasExtension = false;\n\n\t\t\t\t\t\tif (fileEntryTitle.endsWith(dotExtension)) {\n\t\t\t\t\t\t\tfileEntryTitle = FileUtil.stripExtension(\n\t\t\t\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\t\t\t\ttitleHasExtension = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\tfileEntryTitle += StringPool.SPACE + i;\n\n\t\t\t\t\t\t\ttitleWithExtension = fileEntryTitle + dotExtension;\n\n\t\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\t\ttitleWithExtension);\n\n\t\t\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\t\t\tif (titleHasExtension) {\n\t\t\t\t\t\t\t\t\tfileEntryTitle += dotExtension;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\"fileVersionUuid\", fileVersion.getUuid());\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(), fileEntryTitle,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tif (fileVersion.isInTrash()) {\n\t\t\t\t\timportedFileEntry = DLAppServiceUtil.moveFileEntryToTrash(\n\t\t\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestExistingFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion();\n\n\t\t\t\tboolean indexEnabled = serviceContext.isIndexingEnabled();\n\n\t\t\t\ttry {\n\t\t\t\t\tserviceContext.setIndexingEnabled(false);\n\n\t\t\t\t\tif (!fileVersion.getUuid().equals(\n\t\t\t\t\t\t\tlatestExistingFileVersion.getUuid())) {\n\n\t\t\t\t\t\tDLFileVersion alreadyExistingFileVersion =\n\t\t\t\t\t\t\tDLFileVersionLocalServiceUtil.\n\t\t\t\t\t\t\t\tgetFileVersionByUuidAndGroupId(\n\t\t\t\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\t\t\t\texistingFileEntry.getGroupId());\n\n\t\t\t\t\t\tif (alreadyExistingFileVersion != null) {\n\t\t\t\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\t\t\t\"existingDLFileVersionId\",\n\t\t\t\t\t\t\t\talreadyExistingFileVersion.getFileVersionId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tserviceContext.setUuid(fileVersion.getUuid());\n\n\t\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\t\tDLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(),\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, false, is,\n\t\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tuserId, existingFileEntry,\n\t\t\t\t\t\t\tlatestExistingFileVersion, assetCategoryIds,\n\t\t\t\t\t\t\tassetTagNames, null);\n\n\t\t\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry.getFolderId() != folderId) {\n\t\t\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.moveFileEntry(\n\t\t\t\t\t\t\tuserId, importedFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\tfolderId, serviceContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry instanceof LiferayFileEntry) {\n\t\t\t\t\t\tLiferayFileEntry liferayFileEntry =\n\t\t\t\t\t\t\t(LiferayFileEntry)importedFileEntry;\n\n\t\t\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\t\t\tindexer.reindex(liferayFileEntry.getModel());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tserviceContext.setIndexingEnabled(indexEnabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getDescription(), null, is,\n\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\tString title = fileEntry.getTitle();\n\n\t\t\t\tString[] titleParts = title.split(\"\\\\.\", 2);\n\n\t\t\t\ttitle = titleParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (titleParts.length > 1) {\n\t\t\t\t\ttitle += StringPool.PERIOD + titleParts[1];\n\t\t\t\t}\n\n\t\t\t\tif (!title.endsWith(dotExtension)) {\n\t\t\t\t\ttitle += dotExtension;\n\t\t\t\t}\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitle, fileEntry.getMimeType(), title,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDLPortletDataHandler.NAMESPACE, \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.importGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, importedFileEntry,\n\t\t\t\tfileEntryElement);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileEntry, importedFileEntry, DLPortletDataHandler.NAMESPACE);\n\n\t\tMap<Long, Long> fileEntryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class);\n\n\t\tfileEntryIds.put(\n\t\t\tfileEntry.getFileEntryId(), importedFileEntry.getFileEntryId());\n\t}","id":74489,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(fileEntry.getUserUuid());\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, FileEntry.class.getName(),\n\t\t\tfileEntry.getFileEntryId());\n\n\t\tElement fileEntryElement =\n\t\t\tportletDataContext.getImportDataElement(\n\t\t\t\tFileEntry.class.getSimpleName(), \"path\", path);\n\n\t\tElement referenceDataElement =\n\t\t\tportletDataContext.getReferenceDataElement(\n\t\t\t\tfileEntryElement, Repository.class,\n\t\t\t\tfileEntry.getRepositoryId());\n\n\t\tif (referenceDataElement != null) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, referenceDataElement);\n\t\t}\n\n\t\tif (fileEntry.getFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tString folderPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Folder.class.getName(),\n\t\t\t\tfileEntry.getFolderId());\n\n\t\t\tFolder folder = (Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfolderPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, folder);\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong folderId = MapUtil.getLong(\n\t\t\tfolderIds, fileEntry.getFolderId(), fileEntry.getFolderId());\n\n\t\tlong[] assetCategoryIds = portletDataContext.getAssetCategoryIds(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\t\tString[] assetTagNames = portletDataContext.getAssetTagNames(\n\t\t\tDLFileEntry.class, fileEntry.getFileEntryId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfileEntry, DLPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"sourceFileName\", \"A.\" + fileEntry.getExtension());\n\t\tserviceContext.setUserId(userId);\n\n\t\tString binPath = fileEntryElement.attributeValue(\"bin-path\");\n\n\t\tInputStream is = null;\n\n\t\tif (Validator.isNull(binPath) &&\n\t\t\tportletDataContext.isPerformDirectBinaryImport()) {\n\n\t\t\ttry {\n\t\t\t\tis = FileEntryUtil.getContentStream(fileEntry);\n\t\t\t}\n\t\t\tcatch (NoSuchFileException nsfe) {\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tis = portletDataContext.getZipEntryAsInputStream(binPath);\n\t\t}\n\n\t\tif (is == null) {\n\t\t\tif (_log.isWarnEnabled()) {\n\t\t\t\t_log.warn(\n\t\t\t\t\t\"No file found for file entry \" +\n\t\t\t\t\t\tfileEntry.getFileEntryId());\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\timportMetaData(\n\t\t\tportletDataContext, fileEntry, fileEntryElement, serviceContext);\n\n\t\tFileEntry importedFileEntry = null;\n\n\t\tString titleWithExtension = DLUtil.getTitleWithExtension(fileEntry);\n\t\tString extension = fileEntry.getExtension();\n\n\t\tString dotExtension = StringPool.PERIOD + extension;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFileEntry existingFileEntry = FileEntryUtil.fetchByUUID_R(\n\t\t\t\tfileEntry.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tFileVersion fileVersion = fileEntry.getFileVersion();\n\n\t\t\tif (existingFileEntry == null) {\n\t\t\t\tString fileEntryTitle = fileEntry.getTitle();\n\n\t\t\t\tFileEntry existingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\tif (existingTitleFileEntry != null) {\n\t\t\t\t\tif ((fileEntry.getGroupId() ==\n\t\t\t\t\t\t\tportletDataContext.getSourceGroupId()) &&\n\t\t\t\t\t\tportletDataContext.\n\t\t\t\t\t\t\tisDataStrategyMirrorWithOverwriting()) {\n\n\t\t\t\t\t\tDLAppLocalServiceUtil.deleteFileEntry(\n\t\t\t\t\t\t\texistingTitleFileEntry.getFileEntryId());\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tboolean titleHasExtension = false;\n\n\t\t\t\t\t\tif (fileEntryTitle.endsWith(dotExtension)) {\n\t\t\t\t\t\t\tfileEntryTitle = FileUtil.stripExtension(\n\t\t\t\t\t\t\t\tfileEntryTitle);\n\n\t\t\t\t\t\t\ttitleHasExtension = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int i = 1;; i++) {\n\t\t\t\t\t\t\tfileEntryTitle += StringPool.SPACE + i;\n\n\t\t\t\t\t\t\ttitleWithExtension = fileEntryTitle + dotExtension;\n\n\t\t\t\t\t\t\texistingTitleFileEntry = FileEntryUtil.fetchByR_F_T(\n\t\t\t\t\t\t\t\tportletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\t\t\t\ttitleWithExtension);\n\n\t\t\t\t\t\t\tif (existingTitleFileEntry == null) {\n\t\t\t\t\t\t\t\tif (titleHasExtension) {\n\t\t\t\t\t\t\t\t\tfileEntryTitle += dotExtension;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\"fileVersionUuid\", fileVersion.getUuid());\n\t\t\t\tserviceContext.setUuid(fileEntry.getUuid());\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(), fileEntryTitle,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\n\t\t\t\tif (fileVersion.isInTrash()) {\n\t\t\t\t\timportedFileEntry = DLAppServiceUtil.moveFileEntryToTrash(\n\t\t\t\t\t\timportedFileEntry.getFileEntryId());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tFileVersion latestExistingFileVersion =\n\t\t\t\t\texistingFileEntry.getLatestFileVersion();\n\n\t\t\t\tboolean indexEnabled = serviceContext.isIndexingEnabled();\n\n\t\t\t\ttry {\n\t\t\t\t\tserviceContext.setIndexingEnabled(false);\n\n\t\t\t\t\tif (!fileVersion.getUuid().equals(\n\t\t\t\t\t\t\tlatestExistingFileVersion.getUuid())) {\n\n\t\t\t\t\t\tDLFileVersion alreadyExistingFileVersion =\n\t\t\t\t\t\t\tDLFileVersionLocalServiceUtil.\n\t\t\t\t\t\t\t\tgetFileVersionByUuidAndGroupId(\n\t\t\t\t\t\t\t\t\tfileVersion.getUuid(),\n\t\t\t\t\t\t\t\t\texistingFileEntry.getGroupId());\n\n\t\t\t\t\t\tif (alreadyExistingFileVersion != null) {\n\t\t\t\t\t\t\tserviceContext.setAttribute(\n\t\t\t\t\t\t\t\t\"existingDLFileVersionId\",\n\t\t\t\t\t\t\t\talreadyExistingFileVersion.getFileVersionId());\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tserviceContext.setUuid(fileVersion.getUuid());\n\n\t\t\t\t\t\timportedFileEntry =\n\t\t\t\t\t\t\tDLAppLocalServiceUtil.updateFileEntry(\n\t\t\t\t\t\t\t\tuserId, existingFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(), fileEntry.getMimeType(),\n\t\t\t\t\t\t\t\tfileEntry.getTitle(),\n\t\t\t\t\t\t\t\tfileEntry.getDescription(), null, false, is,\n\t\t\t\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tDLAppLocalServiceUtil.updateAsset(\n\t\t\t\t\t\t\tuserId, existingFileEntry,\n\t\t\t\t\t\t\tlatestExistingFileVersion, assetCategoryIds,\n\t\t\t\t\t\t\tassetTagNames, null);\n\n\t\t\t\t\t\timportedFileEntry = existingFileEntry;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry.getFolderId() != folderId) {\n\t\t\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.moveFileEntry(\n\t\t\t\t\t\t\tuserId, importedFileEntry.getFileEntryId(),\n\t\t\t\t\t\t\tfolderId, serviceContext);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (importedFileEntry instanceof LiferayFileEntry) {\n\t\t\t\t\t\tLiferayFileEntry liferayFileEntry =\n\t\t\t\t\t\t\t(LiferayFileEntry)importedFileEntry;\n\n\t\t\t\t\t\tIndexer indexer = IndexerRegistryUtil.getIndexer(\n\t\t\t\t\t\t\tDLFileEntry.class);\n\n\t\t\t\t\t\tindexer.reindex(liferayFileEntry.getModel());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tserviceContext.setIndexingEnabled(indexEnabled);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitleWithExtension, fileEntry.getMimeType(),\n\t\t\t\t\tfileEntry.getTitle(), fileEntry.getDescription(), null, is,\n\t\t\t\t\tfileEntry.getSize(), serviceContext);\n\t\t\t}\n\t\t\tcatch (DuplicateFileException dfe) {\n\t\t\t\tString title = fileEntry.getTitle();\n\n\t\t\t\tString[] titleParts = title.split(\"\\\\.\", 2);\n\n\t\t\t\ttitle = titleParts[0] + PwdGenerator.getPassword();\n\n\t\t\t\tif (titleParts.length > 1) {\n\t\t\t\t\ttitle += StringPool.PERIOD + titleParts[1];\n\t\t\t\t}\n\n\t\t\t\tif (!title.endsWith(dotExtension)) {\n\t\t\t\t\ttitle += dotExtension;\n\t\t\t\t}\n\n\t\t\t\timportedFileEntry = DLAppLocalServiceUtil.addFileEntry(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), folderId,\n\t\t\t\t\ttitle, fileEntry.getMimeType(), title,\n\t\t\t\t\tfileEntry.getDescription(), null, is, fileEntry.getSize(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDLPortletDataHandler.NAMESPACE, \"previews-and-thumbnails\")) {\n\n\t\t\tDLProcessorRegistryUtil.importGeneratedFiles(\n\t\t\t\tportletDataContext, fileEntry, importedFileEntry,\n\t\t\t\tfileEntryElement);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfileEntry, importedFileEntry, DLPortletDataHandler.NAMESPACE);\n\n\t\tMap<Long, Long> fileEntryIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFileEntry.class);\n\n\t\tfileEntryIds.put(\n\t\t\tfileEntry.getFileEntryId(), importedFileEntry.getFileEntryId());\n\t}","commit_id":"fb1bbd8ab198713d46ecfffd52e7ad7634fb1ea5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"protected void importMetaData(\n\t\t\tPortletDataContext portletDataContext, Element fileEntryElement,\n\t\t\tServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tList<Element> referenceDataElements =\n\t\t\tportletDataContext.getReferenceDataElements(\n\t\t\t\tfileEntryElement, DLFileEntryType.class);\n\n\t\tif (referenceDataElements.isEmpty()) {\n\t\t\treturn;\n\t\t}\n\n\t\tElement fileEntryTypeElement = referenceDataElements.get(0);\n\n\t\tString fileEntryTypePath = fileEntryTypeElement.attributeValue(\"path\");\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\t(DLFileEntryType)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfileEntryTypePath);\n\n\t\tDLFileEntryType existingDLFileEntryType =\n\t\t\tDLFileEntryTypeLocalServiceUtil.\n\t\t\t\tfetchDLFileEntryTypeByUuidAndGroupId(\n\t\t\t\t\tdlFileEntryType.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tif (existingDLFileEntryType == null) {\n\t\t\texistingDLFileEntryType =\n\t\t\t\tDLFileEntryTypeLocalServiceUtil.\n\t\t\t\t\tfetchDLFileEntryTypeByUuidAndGroupId(\n\t\t\t\t\t\tdlFileEntryType.getUuid(),\n\t\t\t\t\t\tportletDataContext.getCompanyGroupId());\n\t\t}\n\n\t\tif (existingDLFileEntryType == null) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, dlFileEntryType);\n\n\t\t\tMap<Long, Long> dlFileEntryTypeIds =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tDLFileEntryType.class);\n\n\t\t\tlong dlFileEntryTypeId = MapUtil.getLong(\n\t\t\t\tdlFileEntryTypeIds, dlFileEntryType.getFileEntryTypeId(),\n\t\t\t\tdlFileEntryType.getFileEntryTypeId());\n\n\t\t\texistingDLFileEntryType =\n\t\t\t\tDLFileEntryTypeLocalServiceUtil.fetchDLFileEntryType(\n\t\t\t\t\tdlFileEntryTypeId);\n\t\t}\n\n\t\tif (existingDLFileEntryType == null) {\n\t\t\tserviceContext.setAttribute(\"fileEntryTypeId\", -1);\n\n\t\t\treturn;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"fileEntryTypeId\", existingDLFileEntryType.getFileEntryTypeId());\n\n\t\tList<DDMStructure> ddmStructures =\n\t\t\texistingDLFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tElement structureFieldsElement =\n\t\t\t\t(Element)fileEntryElement.selectSingleNode(\n\t\t\t\t\t\"structure-fields[@structureUuid='\".concat(\n\t\t\t\t\t\tddmStructure.getUuid()).concat(\"']\"));\n\n\t\t\tif (structureFieldsElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString path = structureFieldsElement.attributeValue(\"path\");\n\n\t\t\tFields fields = (Fields)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\tFields.class.getName() + ddmStructure.getStructureId(), fields);\n\t\t}\n\t}","id":74490,"modified_method":"protected void importMetaData(\n\t\t\tPortletDataContext portletDataContext, FileEntry fileEntry,\n\t\t\tElement fileEntryElement, ServiceContext serviceContext)\n\t\tthrows Exception {\n\n\t\tLiferayFileEntry liferayFileEntry = (LiferayFileEntry)fileEntry;\n\n\t\tDLFileEntry dlFileEntry = liferayFileEntry.getDLFileEntry();\n\n\t\tElement fileEntryTypeElement =\n\t\t\tportletDataContext.getReferenceDataElement(\n\t\t\t\tfileEntryElement, DLFileEntryType.class,\n\t\t\t\tdlFileEntry.getFileEntryTypeId());\n\n\t\tif (fileEntryTypeElement == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tString fileEntryTypePath = fileEntryTypeElement.attributeValue(\"path\");\n\n\t\tDLFileEntryType dlFileEntryType =\n\t\t\t(DLFileEntryType)portletDataContext.getZipEntryAsObject(\n\t\t\t\tfileEntryTypePath);\n\n\t\tDLFileEntryType existingDLFileEntryType =\n\t\t\tDLFileEntryTypeLocalServiceUtil.\n\t\t\t\tfetchDLFileEntryTypeByUuidAndGroupId(\n\t\t\t\t\tdlFileEntryType.getUuid(),\n\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\tif (existingDLFileEntryType == null) {\n\t\t\texistingDLFileEntryType =\n\t\t\t\tDLFileEntryTypeLocalServiceUtil.\n\t\t\t\t\tfetchDLFileEntryTypeByUuidAndGroupId(\n\t\t\t\t\t\tdlFileEntryType.getUuid(),\n\t\t\t\t\t\tportletDataContext.getCompanyGroupId());\n\t\t}\n\n\t\tif (existingDLFileEntryType == null) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, dlFileEntryType);\n\n\t\t\tMap<Long, Long> dlFileEntryTypeIds =\n\t\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tDLFileEntryType.class);\n\n\t\t\tlong dlFileEntryTypeId = MapUtil.getLong(\n\t\t\t\tdlFileEntryTypeIds, dlFileEntryType.getFileEntryTypeId(),\n\t\t\t\tdlFileEntryType.getFileEntryTypeId());\n\n\t\t\texistingDLFileEntryType =\n\t\t\t\tDLFileEntryTypeLocalServiceUtil.fetchDLFileEntryType(\n\t\t\t\t\tdlFileEntryTypeId);\n\t\t}\n\n\t\tif (existingDLFileEntryType == null) {\n\t\t\tserviceContext.setAttribute(\"fileEntryTypeId\", -1);\n\n\t\t\treturn;\n\t\t}\n\n\t\tserviceContext.setAttribute(\n\t\t\t\"fileEntryTypeId\", existingDLFileEntryType.getFileEntryTypeId());\n\n\t\tList<DDMStructure> ddmStructures =\n\t\t\texistingDLFileEntryType.getDDMStructures();\n\n\t\tfor (DDMStructure ddmStructure : ddmStructures) {\n\t\t\tElement structureFieldsElement =\n\t\t\t\t(Element)fileEntryElement.selectSingleNode(\n\t\t\t\t\t\"structure-fields[@structureUuid='\".concat(\n\t\t\t\t\t\tddmStructure.getUuid()).concat(\"']\"));\n\n\t\t\tif (structureFieldsElement == null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tString path = structureFieldsElement.attributeValue(\"path\");\n\n\t\t\tFields fields = (Fields)portletDataContext.getZipEntryAsObject(\n\t\t\t\tpath);\n\n\t\t\tserviceContext.setAttribute(\n\t\t\t\tFields.class.getName() + ddmStructure.getStructureId(), fields);\n\t\t}\n\t}","commit_id":"fb1bbd8ab198713d46ecfffd52e7ad7634fb1ea5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Folder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(folder.getUserUuid());\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, Folder.class.getName(), folder.getFolderId());\n\n\t\tElement folderElement = portletDataContext.getImportDataElement(\n\t\t\tFolder.class.getSimpleName(), \"path\", path);\n\n\t\tList<Element> referenceDataElements =\n\t\t\tportletDataContext.getReferenceDataElements(\n\t\t\t\tfolderElement, Repository.class);\n\n\t\tfor (Element referenceDataElement : referenceDataElements) {\n\t\t\tString referencePath = referenceDataElement.attributeValue(\"path\");\n\n\t\t\tStagedModel referenceStagedModel =\n\t\t\t\t(StagedModel)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\treferencePath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, referenceStagedModel);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (folder.getParentFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tString parentFolderPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Folder.class.getName(),\n\t\t\t\tfolder.getParentFolderId());\n\n\t\t\tFolder parentFolder =\n\t\t\t\t(Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\tparentFolderPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentFolder);\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderIds, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfolder, DLPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tFolder importedFolder = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFolder existingFolder = FolderUtil.fetchByUUID_R(\n\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFolder == null) {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\tserviceContext.setUuid(folder.getUuid());\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, name, folder.getDescription(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.updateFolder(\n\t\t\t\t\texistingFolder.getFolderId(), parentFolderId, name,\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString name = getFolderName(\n\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tfolder.getName(), 2);\n\n\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tname, folder.getDescription(), serviceContext);\n\t\t}\n\n\t\timportFolderFileEntryTypes(\n\t\t\tportletDataContext, folderElement, folder, serviceContext);\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfolder, importedFolder, DLPortletDataHandler.NAMESPACE);\n\n\t\tfolderIds.put(folder.getFolderId(), importedFolder.getFolderId());\n\t}","id":74491,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, Folder folder)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(folder.getUserUuid());\n\n\t\tString path = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, Folder.class.getName(), folder.getFolderId());\n\n\t\tElement folderElement = portletDataContext.getImportDataElement(\n\t\t\tFolder.class.getSimpleName(), \"path\", path);\n\n\t\tElement referenceDataElement =\n\t\t\tportletDataContext.getReferenceDataElement(\n\t\t\t\tfolderElement, Repository.class, folder.getRepositoryId());\n\n\t\tif (referenceDataElement != null) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, referenceDataElement);\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (folder.getParentFolderId() !=\n\t\t\t\tDLFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\n\t\t\tString parentFolderPath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, Folder.class.getName(),\n\t\t\t\tfolder.getParentFolderId());\n\n\t\t\tFolder parentFolder =\n\t\t\t\t(Folder)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\tparentFolderPath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentFolder);\n\t\t}\n\n\t\tMap<Long, Long> folderIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tFolder.class);\n\n\t\tlong parentFolderId = MapUtil.getLong(\n\t\t\tfolderIds, folder.getParentFolderId(), folder.getParentFolderId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tfolder, DLPortletDataHandler.NAMESPACE);\n\n\t\tserviceContext.setUserId(userId);\n\n\t\tFolder importedFolder = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tFolder existingFolder = FolderUtil.fetchByUUID_R(\n\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId());\n\n\t\t\tif (existingFolder == null) {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\t\tfolder.getName(), 2);\n\n\t\t\t\tserviceContext.setUuid(folder.getUuid());\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, name, folder.getDescription(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString name = getFolderName(\n\t\t\t\t\tfolder.getUuid(), portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentFolderId, folder.getName(), 2);\n\n\t\t\t\timportedFolder = DLAppLocalServiceUtil.updateFolder(\n\t\t\t\t\texistingFolder.getFolderId(), parentFolderId, name,\n\t\t\t\t\tfolder.getDescription(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tString name = getFolderName(\n\t\t\t\tnull, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tfolder.getName(), 2);\n\n\t\t\timportedFolder = DLAppLocalServiceUtil.addFolder(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), parentFolderId,\n\t\t\t\tname, folder.getDescription(), serviceContext);\n\t\t}\n\n\t\timportFolderFileEntryTypes(\n\t\t\tportletDataContext, folderElement, folder, serviceContext);\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tfolder, importedFolder, DLPortletDataHandler.NAMESPACE);\n\n\t\tfolderIds.put(folder.getFolderId(), importedFolder.getFolderId());\n\t}","commit_id":"fb1bbd8ab198713d46ecfffd52e7ad7634fb1ea5","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tprepareLanguagesForImport(structure);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tif (structure.getParentStructureId() !=\n\t\t\t\tDDMStructureConstants.DEFAULT_PARENT_STRUCTURE_ID) {\n\n\t\t\tString parentStructurePath = ExportImportPathUtil.getModelPath(\n\t\t\t\tportletDataContext, DDMStructure.class.getName(),\n\t\t\t\tstructure.getParentStructureId());\n\n\t\t\tDDMStructure parentStructure =\n\t\t\t\t(DDMStructure)portletDataContext.getZipEntryAsObject(\n\t\t\t\t\tparentStructurePath);\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, parentStructure);\n\t\t}\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong parentStructureId = MapUtil.getLong(\n\t\t\tstructureIds, structure.getParentStructureId(),\n\t\t\tstructure.getParentStructureId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tstructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tDDMStructure importedStructure = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tElement element =\n\t\t\t\tportletDataContext.getImportDataStagedModelElement(structure);\n\n\t\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\t\telement.attributeValue(\"preloaded\"));\n\n\t\t\tDDMStructure existingStructure = null;\n\n\t\t\tif (!preloaded) {\n\t\t\t\texistingStructure =\n\t\t\t\t\tDDMStructureLocalServiceUtil.\n\t\t\t\t\t\tfetchDDMStructureByUuidAndGroupId(\n\t\t\t\t\t\t\tstructure.getUuid(),\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure = DDMStructureLocalServiceUtil.fetchStructure(\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tstructure.getClassNameId(), structure.getStructureKey());\n\t\t\t}\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentStructureId, structure.getClassNameId(),\n\t\t\t\t\tstructure.getStructureKey(), structure.getNameMap(),\n\t\t\t\t\tstructure.getDescriptionMap(), structure.getXsd(),\n\t\t\t\t\tstructure.getStorageType(), structure.getType(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedStructure =\n\t\t\t\t\tDDMStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getStructureId(), parentStructureId,\n\t\t\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), parentStructureId,\n\t\t\t\tstructure.getClassNameId(), structure.getStructureKey(),\n\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\tstructure.getXsd(), structure.getStorageType(),\n\t\t\t\tstructure.getType(), serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tstructure, importedStructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tstructureIds.put(\n\t\t\tstructure.getStructureId(), importedStructure.getStructureId());\n\t}","id":74492,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tprepareLanguagesForImport(structure);\n\n\t\tlong userId = portletDataContext.getUserId(structure.getUserUuid());\n\n\t\tif (structure.getParentStructureId() !=\n\t\t\t\tDDMStructureConstants.DEFAULT_PARENT_STRUCTURE_ID) {\n\n\t\t\tElement structureElement =\n\t\t\t\tportletDataContext.getReferenceDataElement(\n\t\t\t\t\tstructure, DDMStructure.class,\n\t\t\t\t\tstructure.getParentStructureId());\n\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, structureElement);\n\t\t}\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong parentStructureId = MapUtil.getLong(\n\t\t\tstructureIds, structure.getParentStructureId(),\n\t\t\tstructure.getParentStructureId());\n\n\t\tServiceContext serviceContext = portletDataContext.createServiceContext(\n\t\t\tstructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tDDMStructure importedStructure = null;\n\n\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\tElement element =\n\t\t\t\tportletDataContext.getImportDataStagedModelElement(structure);\n\n\t\t\tboolean preloaded = GetterUtil.getBoolean(\n\t\t\t\telement.attributeValue(\"preloaded\"));\n\n\t\t\tDDMStructure existingStructure = null;\n\n\t\t\tif (!preloaded) {\n\t\t\t\texistingStructure =\n\t\t\t\t\tDDMStructureLocalServiceUtil.\n\t\t\t\t\t\tfetchDDMStructureByUuidAndGroupId(\n\t\t\t\t\t\t\tstructure.getUuid(),\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId());\n\t\t\t}\n\t\t\telse {\n\t\t\t\texistingStructure = DDMStructureLocalServiceUtil.fetchStructure(\n\t\t\t\t\tportletDataContext.getScopeGroupId(),\n\t\t\t\t\tstructure.getClassNameId(), structure.getStructureKey());\n\t\t\t}\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\texistingStructure =\n\t\t\t\t\tDDMStructureLocalServiceUtil.\n\t\t\t\t\t\tfetchDDMStructureByUuidAndGroupId(\n\t\t\t\t\t\t\tstructure.getUuid(),\n\t\t\t\t\t\t\tportletDataContext.getCompanyGroupId());\n\t\t\t}\n\n\t\t\tif (existingStructure == null) {\n\t\t\t\tserviceContext.setUuid(structure.getUuid());\n\n\t\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(),\n\t\t\t\t\tparentStructureId, structure.getClassNameId(),\n\t\t\t\t\tstructure.getStructureKey(), structure.getNameMap(),\n\t\t\t\t\tstructure.getDescriptionMap(), structure.getXsd(),\n\t\t\t\t\tstructure.getStorageType(), structure.getType(),\n\t\t\t\t\tserviceContext);\n\t\t\t}\n\t\t\telse if (portletDataContext.isCompanyStagedGroupedModel(\n\t\t\t\t\t\texistingStructure)) {\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedStructure =\n\t\t\t\t\tDDMStructureLocalServiceUtil.updateStructure(\n\t\t\t\t\t\texistingStructure.getStructureId(), parentStructureId,\n\t\t\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\t\t\tstructure.getXsd(), serviceContext);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\timportedStructure = DDMStructureLocalServiceUtil.addStructure(\n\t\t\t\tuserId, portletDataContext.getScopeGroupId(), parentStructureId,\n\t\t\t\tstructure.getClassNameId(), structure.getStructureKey(),\n\t\t\t\tstructure.getNameMap(), structure.getDescriptionMap(),\n\t\t\t\tstructure.getXsd(), structure.getStorageType(),\n\t\t\t\tstructure.getType(), serviceContext);\n\t\t}\n\n\t\tportletDataContext.importClassedModel(\n\t\t\tstructure, importedStructure, DDMPortletDataHandler.NAMESPACE);\n\n\t\tstructureIds.put(\n\t\t\tstructure.getStructureId(), importedStructure.getStructureId());\n\t}","commit_id":"484bcaabf19b437f5a77ad5ccaf8ee2958d9a669","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tif (structure.getParentStructureId() !=\n\t\t\t\tDDMStructureConstants.DEFAULT_PARENT_STRUCTURE_ID) {\n\n\t\t\tDDMStructure parentStructure =\n\t\t\t\tDDMStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tstructure.getParentStructureId());\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, parentStructure);\n\t\t}\n\n\t\tElement structureElement = portletDataContext.getExportDataElement(\n\t\t\tstructure);\n\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(\n\t\t\tstructure.getCompanyId());\n\n\t\tif (defaultUserId == structure.getUserId()) {\n\t\t\tstructureElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tstructureElement, ExportImportPathUtil.getModelPath(structure),\n\t\t\tstructure, DDMPortletDataHandler.NAMESPACE);\n\t}","id":74493,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMStructure structure)\n\t\tthrows Exception {\n\n\t\tElement structureElement = portletDataContext.getExportDataElement(\n\t\t\tstructure);\n\n\t\tif (structure.getParentStructureId() !=\n\t\t\t\tDDMStructureConstants.DEFAULT_PARENT_STRUCTURE_ID) {\n\n\t\t\tDDMStructure parentStructure =\n\t\t\t\tDDMStructureLocalServiceUtil.getStructure(\n\t\t\t\t\tstructure.getParentStructureId());\n\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, parentStructure);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\tstructure, structureElement, parentStructure,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_PARENT, false);\n\t\t}\n\n\t\tlong defaultUserId = UserLocalServiceUtil.getDefaultUserId(\n\t\t\tstructure.getCompanyId());\n\n\t\tif (defaultUserId == structure.getUserId()) {\n\t\t\tstructureElement.addAttribute(\"preloaded\", \"true\");\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\tstructureElement, ExportImportPathUtil.getModelPath(structure),\n\t\t\tstructure, DDMPortletDataHandler.NAMESPACE);\n\t}","commit_id":"484bcaabf19b437f5a77ad5ccaf8ee2958d9a669","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(template.getUserUuid());\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tString structurePath = ExportImportPathUtil.getModelPath(\n\t\t\tportletDataContext, DDMStructure.class.getName(),\n\t\t\ttemplate.getClassPK());\n\n\t\tDDMStructure structure =\n\t\t\t(DDMStructure)portletDataContext.getZipEntryAsObject(structurePath);\n\n\t\tif (structure != null) {\n\t\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\t\tportletDataContext, structure);\n\t\t}\n\n\t\tlong classPK = MapUtil.getLong(\n\t\t\tstructureIds, template.getClassPK(), template.getClassPK());\n\n\t\tFile smallFile = null;\n\n\t\ttry {\n\t\t\tif (template.isSmallImage()) {\n\t\t\t\tElement element =\n\t\t\t\t\tportletDataContext.getImportDataStagedModelElement(\n\t\t\t\t\t\ttemplate);\n\n\t\t\t\tString smallImagePath = element.attributeValue(\n\t\t\t\t\t\"small-image-path\");\n\n\t\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\t\tString smallImageURL =\n\t\t\t\t\t\tExportImportHelperUtil.replaceImportContentReferences(\n\t\t\t\t\t\t\tportletDataContext, element,\n\t\t\t\t\t\t\ttemplate.getSmallImageURL(), true);\n\n\t\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(smallImagePath)) {\n\t\t\t\t\tbyte[] bytes = portletDataContext.getZipEntryAsByteArray(\n\t\t\t\t\t\tsmallImagePath);\n\n\t\t\t\t\tif (bytes != null) {\n\t\t\t\t\t\tsmallFile = FileUtil.createTempFile(\n\t\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\t\t\tFileUtil.write(smallFile, bytes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tServiceContext serviceContext =\n\t\t\t\tportletDataContext.createServiceContext(\n\t\t\t\t\ttemplate, DDMPortletDataHandler.NAMESPACE);\n\n\t\t\tDDMTemplate importedTemplate = null;\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tDDMTemplate existingTemplate =\n\t\t\t\t\tDDMTemplateLocalServiceUtil.\n\t\t\t\t\t\tfetchDDMTemplateByUuidAndGroupId(\n\t\t\t\t\t\t\ttemplate.getUuid(),\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingTemplate == null) {\n\t\t\t\t\tserviceContext.setUuid(template.getUuid());\n\n\t\t\t\t\timportedTemplate = addTemplate(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template,\n\t\t\t\t\t\tclassPK, smallFile, serviceContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedTemplate =\n\t\t\t\t\t\tDDMTemplateLocalServiceUtil.updateTemplate(\n\t\t\t\t\t\t\texistingTemplate.getTemplateId(),\n\t\t\t\t\t\t\ttemplate.getClassPK(), template.getNameMap(),\n\t\t\t\t\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\t\t\t\t\ttemplate.getMode(), template.getLanguage(),\n\t\t\t\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\t\t\t\ttemplate.isSmallImage(),\n\t\t\t\t\t\t\ttemplate.getSmallImageURL(), smallFile,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedTemplate = addTemplate(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template,\n\t\t\t\t\tclassPK, smallFile, serviceContext);\n\t\t\t}\n\n\t\t\tportletDataContext.importClassedModel(\n\t\t\t\ttemplate, importedTemplate, DDMPortletDataHandler.NAMESPACE);\n\n\t\t\tMap<String, String> ddmTemplateKeys =\n\t\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tDDMTemplate.class + \".ddmTemplateKey\");\n\n\t\t\tddmTemplateKeys.put(\n\t\t\t\ttemplate.getTemplateKey(), importedTemplate.getTemplateKey());\n\t\t}\n\t\tfinally {\n\t\t\tif (smallFile != null) {\n\t\t\t\tsmallFile.delete();\n\t\t\t}\n\t\t}\n\t}","id":74494,"modified_method":"@Override\n\tprotected void doImportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tlong userId = portletDataContext.getUserId(template.getUserUuid());\n\n\t\tElement structureElement = portletDataContext.getReferenceDataElement(\n\t\t\ttemplate, DDMStructure.class, template.getClassPK());\n\n\t\tStagedModelDataHandlerUtil.importStagedModel(\n\t\t\tportletDataContext, structureElement);\n\n\t\tMap<Long, Long> structureIds =\n\t\t\t(Map<Long, Long>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\tDDMStructure.class);\n\n\t\tlong classPK = MapUtil.getLong(\n\t\t\tstructureIds, template.getClassPK(), template.getClassPK());\n\n\t\tFile smallFile = null;\n\n\t\ttry {\n\t\t\tif (template.isSmallImage()) {\n\t\t\t\tElement element =\n\t\t\t\t\tportletDataContext.getImportDataStagedModelElement(\n\t\t\t\t\t\ttemplate);\n\n\t\t\t\tString smallImagePath = element.attributeValue(\n\t\t\t\t\t\"small-image-path\");\n\n\t\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\t\tString smallImageURL =\n\t\t\t\t\t\tExportImportHelperUtil.replaceImportContentReferences(\n\t\t\t\t\t\t\tportletDataContext, element,\n\t\t\t\t\t\t\ttemplate.getSmallImageURL(), true);\n\n\t\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t\t}\n\t\t\t\telse if (Validator.isNotNull(smallImagePath)) {\n\t\t\t\t\tbyte[] bytes = portletDataContext.getZipEntryAsByteArray(\n\t\t\t\t\t\tsmallImagePath);\n\n\t\t\t\t\tif (bytes != null) {\n\t\t\t\t\t\tsmallFile = FileUtil.createTempFile(\n\t\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\t\t\tFileUtil.write(smallFile, bytes);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tServiceContext serviceContext =\n\t\t\t\tportletDataContext.createServiceContext(\n\t\t\t\t\ttemplate, DDMPortletDataHandler.NAMESPACE);\n\n\t\t\tDDMTemplate importedTemplate = null;\n\n\t\t\tif (portletDataContext.isDataStrategyMirror()) {\n\t\t\t\tDDMTemplate existingTemplate =\n\t\t\t\t\tDDMTemplateLocalServiceUtil.\n\t\t\t\t\t\tfetchDDMTemplateByUuidAndGroupId(\n\t\t\t\t\t\t\ttemplate.getUuid(),\n\t\t\t\t\t\t\tportletDataContext.getScopeGroupId());\n\n\t\t\t\tif (existingTemplate == null) {\n\t\t\t\t\texistingTemplate =\n\t\t\t\t\t\tDDMTemplateLocalServiceUtil.\n\t\t\t\t\t\t\tfetchDDMTemplateByUuidAndGroupId(\n\t\t\t\t\t\t\t\ttemplate.getUuid(),\n\t\t\t\t\t\t\t\tportletDataContext.getCompanyGroupId());\n\t\t\t\t}\n\n\t\t\t\tif (existingTemplate == null) {\n\t\t\t\t\tserviceContext.setUuid(template.getUuid());\n\n\t\t\t\t\timportedTemplate = addTemplate(\n\t\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template,\n\t\t\t\t\t\tclassPK, smallFile, serviceContext);\n\t\t\t\t}\n\t\t\t\telse if (portletDataContext.isCompanyStagedGroupedModel(\n\t\t\t\t\t\t\texistingTemplate)) {\n\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\timportedTemplate =\n\t\t\t\t\t\tDDMTemplateLocalServiceUtil.updateTemplate(\n\t\t\t\t\t\t\texistingTemplate.getTemplateId(),\n\t\t\t\t\t\t\ttemplate.getClassPK(), template.getNameMap(),\n\t\t\t\t\t\t\ttemplate.getDescriptionMap(), template.getType(),\n\t\t\t\t\t\t\ttemplate.getMode(), template.getLanguage(),\n\t\t\t\t\t\t\ttemplate.getScript(), template.isCacheable(),\n\t\t\t\t\t\t\ttemplate.isSmallImage(),\n\t\t\t\t\t\t\ttemplate.getSmallImageURL(), smallFile,\n\t\t\t\t\t\t\tserviceContext);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\timportedTemplate = addTemplate(\n\t\t\t\t\tuserId, portletDataContext.getScopeGroupId(), template,\n\t\t\t\t\tclassPK, smallFile, serviceContext);\n\t\t\t}\n\n\t\t\tportletDataContext.importClassedModel(\n\t\t\t\ttemplate, importedTemplate, DDMPortletDataHandler.NAMESPACE);\n\n\t\t\tMap<String, String> ddmTemplateKeys =\n\t\t\t\t(Map<String, String>)portletDataContext.getNewPrimaryKeysMap(\n\t\t\t\t\tDDMTemplate.class + \".ddmTemplateKey\");\n\n\t\t\tddmTemplateKeys.put(\n\t\t\t\ttemplate.getTemplateKey(), importedTemplate.getTemplateKey());\n\t\t}\n\t\tfinally {\n\t\t\tif (smallFile != null) {\n\t\t\t\tsmallFile.delete();\n\t\t\t}\n\t\t}\n\t}","commit_id":"484bcaabf19b437f5a77ad5ccaf8ee2958d9a669","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tDDMStructure structure = DDMStructureLocalServiceUtil.fetchStructure(\n\t\t\ttemplate.getClassPK());\n\n\t\tif (structure != null) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, structure);\n\t\t}\n\n\t\tElement templateElement = portletDataContext.getExportDataElement(\n\t\t\ttemplate);\n\n\t\tif (template.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, template, templateElement,\n\t\t\t\t\t\ttemplate.getSmallImageURL().concat(StringPool.SPACE),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\ttemplate,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\ttemplateElement.addAttribute(\n\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDDMPortletDataHandler.NAMESPACE, \"referenced-content\")) {\n\n\t\t\tString content =\n\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\tportletDataContext, template, templateElement,\n\t\t\t\t\ttemplate.getScript(), true);\n\n\t\t\ttemplate.setScript(content);\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\ttemplateElement, ExportImportPathUtil.getModelPath(template),\n\t\t\ttemplate, DDMPortletDataHandler.NAMESPACE);\n\t}","id":74495,"modified_method":"@Override\n\tprotected void doExportStagedModel(\n\t\t\tPortletDataContext portletDataContext, DDMTemplate template)\n\t\tthrows Exception {\n\n\t\tElement templateElement = portletDataContext.getExportDataElement(\n\t\t\ttemplate);\n\n\t\tDDMStructure structure = DDMStructureLocalServiceUtil.fetchStructure(\n\t\t\ttemplate.getClassPK());\n\n\t\tif (structure != null) {\n\t\t\tStagedModelDataHandlerUtil.exportStagedModel(\n\t\t\t\tportletDataContext, structure);\n\n\t\t\tportletDataContext.addReferenceElement(\n\t\t\t\ttemplate, templateElement, structure,\n\t\t\t\tPortletDataContext.REFERENCE_TYPE_STRONG, false);\n\t\t}\n\n\t\tif (template.isSmallImage()) {\n\t\t\tImage smallImage = ImageLocalServiceUtil.fetchImage(\n\t\t\t\ttemplate.getSmallImageId());\n\n\t\t\tif (Validator.isNotNull(template.getSmallImageURL())) {\n\t\t\t\tString smallImageURL =\n\t\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\t\tportletDataContext, template, templateElement,\n\t\t\t\t\t\ttemplate.getSmallImageURL().concat(StringPool.SPACE),\n\t\t\t\t\t\ttrue);\n\n\t\t\t\ttemplate.setSmallImageURL(smallImageURL);\n\t\t\t}\n\t\t\telse if (smallImage != null) {\n\t\t\t\tString smallImagePath = ExportImportPathUtil.getModelPath(\n\t\t\t\t\ttemplate,\n\t\t\t\t\tsmallImage.getImageId() + StringPool.PERIOD +\n\t\t\t\t\t\ttemplate.getSmallImageType());\n\n\t\t\t\ttemplateElement.addAttribute(\n\t\t\t\t\t\"small-image-path\", smallImagePath);\n\n\t\t\t\ttemplate.setSmallImageType(smallImage.getType());\n\n\t\t\t\tportletDataContext.addZipEntry(\n\t\t\t\t\tsmallImagePath, smallImage.getTextObj());\n\t\t\t}\n\t\t}\n\n\t\tif (portletDataContext.getBooleanParameter(\n\t\t\t\tDDMPortletDataHandler.NAMESPACE, \"referenced-content\")) {\n\n\t\t\tString content =\n\t\t\t\tExportImportHelperUtil.replaceExportContentReferences(\n\t\t\t\t\tportletDataContext, template, templateElement,\n\t\t\t\t\ttemplate.getScript(), true);\n\n\t\t\ttemplate.setScript(content);\n\t\t}\n\n\t\tportletDataContext.addClassedModel(\n\t\t\ttemplateElement, ExportImportPathUtil.getModelPath(template),\n\t\t\ttemplate, DDMPortletDataHandler.NAMESPACE);\n\t}","commit_id":"484bcaabf19b437f5a77ad5ccaf8ee2958d9a669","url":"https://github.com/liferay/liferay-portal"},{"original_method":"@Override\n  public Set<SLanguage> getUsedLanguages() {\n    return ((Set) new HashSet<Language>(ModuleRepositoryFacade.getInstance().getAllModules(Language.class)));\n  }","id":74496,"modified_method":"@Override\n  public Set<SLanguage> getUsedLanguages() {\n    Collection<Language> languages = ModuleRepositoryFacade.getInstance().getAllModules(Language.class);\n    return SetSequence.fromSetWithValues(new HashSet<SLanguage>(), CollectionSequence.fromCollection(languages).select(new ISelector<Language, SLanguage>() {\n      public SLanguage select(Language it) {\n        return ((SLanguage) new SLanguageAdapter(it.getModuleName()));\n      }\n    }));\n  }","commit_id":"4ab1ac4e7a27b664474f5330ef78755ba14b9aa9","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public Iterable<SDependency> getDeclaredDependencies() {\n    return ((Iterable) MPSModuleRepository.getInstance().getModules());\n  }","id":74497,"modified_method":"@Override\n  public Iterable<SDependency> getDeclaredDependencies() {\n    Iterable<SModule> modules = MPSModuleRepository.getInstance().getModules();\n    return Sequence.fromIterable(modules).select(new ISelector<SModule, SDependency>() {\n      public SDependency select(SModule it) {\n        return ((SDependency) new SDependencyAdapter(new Dependency(it.getModuleReference(), false)));\n      }\n    });\n  }","commit_id":"4ab1ac4e7a27b664474f5330ef78755ba14b9aa9","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<IModule> getVisibleModules() {\n    return new HashSet(getModules(null));\n  }","id":74498,"modified_method":"public Iterable<IModule> getVisibleModules() {\n    return Collections.unmodifiableList(getModules(null));\n  }","commit_id":"addde34d7cd10902e0fb163cb03b7c24d40098ed","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Set<Language> getInitialUsedLanguages() {\n    return CollectionUtil.filter(Language.class, getInitialModules());\n  }","id":74499,"modified_method":"protected Collection<Language> getInitialUsedLanguages() {\n    return CollectionUtil.filter(Language.class, getInitialModules());\n  }","commit_id":"addde34d7cd10902e0fb163cb03b7c24d40098ed","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<IModule> getVisibleModules() {\n    synchronized (LOCK) {\n      initialize();\n      return Collections.unmodifiableSet(myVisibleModules);\n    }\n  }","id":74500,"modified_method":"public Iterable<IModule> getVisibleModules() {\n    synchronized (LOCK) {\n      initialize();\n      return Collections.unmodifiableSet(myVisibleModules);\n    }\n  }","commit_id":"addde34d7cd10902e0fb163cb03b7c24d40098ed","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<IModule> getVisibleModules() {\n    return new HashSet<IModule>(myMPSModuleRepository.getAllModules());\n  }","id":74501,"modified_method":"public Iterable<IModule> getVisibleModules() {\n    return Collections.unmodifiableList(myMPSModuleRepository.getAllModules());\n  }","commit_id":"addde34d7cd10902e0fb163cb03b7c24d40098ed","url":"https://github.com/JetBrains/MPS"},{"original_method":"public Set<IModule> getVisibleModules() {\n    return filterOutTransient(MPSModuleRepository.getInstance().getAllModules());\n  }","id":74502,"modified_method":"public Iterable<IModule> getVisibleModules() {\n    return new ConditionalIterable<IModule>(MPSModuleRepository.getInstance().getAllModules(), new NonTransientModuleCondition());\n  }","commit_id":"addde34d7cd10902e0fb163cb03b7c24d40098ed","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Set<IModule> getInitialModules() {\n      Set<IModule> result = new HashSet<IModule>();\n      result.add(TestModule.this);\n      result.addAll(GlobalScope.getInstance().getVisibleModules());\n      return result;\n    }","id":74503,"modified_method":"protected Set<IModule> getInitialModules() {\n      Set<IModule> result = new HashSet<IModule>();\n      result.add(TestModule.this);\n      for (IModule m : GlobalScope.getInstance().getVisibleModules()) {\n        result.add(m);\n      }\n      return result;\n    }","commit_id":"addde34d7cd10902e0fb163cb03b7c24d40098ed","url":"https://github.com/JetBrains/MPS"},{"original_method":"protected Set<IModule> getInitialModules() {\n      Set<IModule> result = new HashSet<IModule>();\n      result.add(TransientModelsModule.this);\n      result.addAll(GlobalScope.getInstance().getVisibleModules());\n      return result;\n    }","id":74504,"modified_method":"protected Set<IModule> getInitialModules() {\n      Set<IModule> result = new HashSet<IModule>();\n      result.add(TransientModelsModule.this);\n      for (IModule m : GlobalScope.getInstance().getVisibleModules()) {\n        result.add(m);\n      }\n      return result;\n    }","commit_id":"addde34d7cd10902e0fb163cb03b7c24d40098ed","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static void virtual_fetchDependencies_5908258303322131137(SNode thisNode, VisibleArtifacts artifacts, RequiredDependenciesBuilder builder) {\n    SNode project = artifacts.getProject();\n    TemplateQueryContext genContext = artifacts.getGenContext();\n\n    // fetch required plugins \n    // we may want to have an option about that? \n    // like load plugins: = all (default) | none | <list of plugins> \n    ModulePlugins plugins = new ModulePlugins(project, genContext);\n    plugins.collect(new MPSModulesClosure(genContext, ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"modules\", true)).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), it, \"virtual_getModules_4560297596904469651\", new Object[]{});\n      }\n    })).trackDevkits().runtimeClosure());\n    for (SNode plugin : Sequence.fromIterable(plugins.getDependency())) {\n      SNode pluginArtifact;\n      if (SNodeOperations.getContainingRoot(thisNode) != SNodeOperations.getContainingRoot(plugin)) {\n        pluginArtifact = SNodeOperations.as(artifacts.findArtifact(plugin), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n      } else {\n        pluginArtifact = SNodeOperations.as(artifacts.findArtifact(plugin), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n      }\n      if (pluginArtifact != null) {\n        builder.add(pluginArtifact, plugin);\n      }\n    }\n\n    // fetch modules \n    Iterable<SNode> originalModules = ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"modules\", true)).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), it, \"virtual_getModules_4560297596904469651\", new Object[]{});\n      }\n    });\n    Iterable<SNode> modules = Sequence.fromIterable(new MPSModulesClosure(genContext, originalModules).trackDevkits().runtimeClosure().getAllModules()).union(Sequence.fromIterable(originalModules));\n    for (SNode m : Sequence.fromIterable(modules)) {\n      SNode artifact;\n      SNode originalModule = DependenciesHelper.getOriginalNode(m, genContext);\n      VisibleArtifacts currentArtifacts = artifacts;\n      artifact = SNodeOperations.as(currentArtifacts.findArtifact(originalModule), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n      if (artifact != null) {\n        builder.add(DependenciesHelper.getOriginalNode(artifact, genContext), originalModule);\n      } else if (SNodeOperations.isInstanceOf(originalModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\")) {\n        artifact = SNodeOperations.as(currentArtifacts.findArtifact(SLinkOperations.getTarget(SNodeOperations.cast(originalModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"path\", true)), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n        if (artifact != null) {\n          builder.add(DependenciesHelper.getOriginalNode(artifact, artifacts.getGenContext()), originalModule);\n        }\n      }\n    }\n  }","id":74505,"modified_method":"public static void virtual_fetchDependencies_5908258303322131137(SNode thisNode, VisibleArtifacts artifacts, RequiredDependenciesBuilder builder) {\n    SNode project = artifacts.getProject();\n    TemplateQueryContext genContext = artifacts.getGenContext();\n\n    // fetch required plugins \n    // we may want to have an option about that? \n    // like load plugins: = all (default) | none | <list of plugins> \n    ModulePlugins plugins = new ModulePlugins(project, genContext);\n    plugins.collect(new MPSModulesClosure(genContext, ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"modules\", true)).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), it, \"virtual_getModules_4560297596904469651\", new Object[]{});\n      }\n    })).trackDevkits().runtimeClosure());\n    for (SNode plugin : Sequence.fromIterable(plugins.getDependency())) {\n      SNode pluginArtifact;\n      if (SNodeOperations.getContainingRoot(thisNode) != SNodeOperations.getContainingRoot(plugin)) {\n        pluginArtifact = SNodeOperations.as(artifacts.findArtifact(plugin), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n      } else {\n        pluginArtifact = SNodeOperations.as(artifacts.findArtifact(plugin), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n      }\n      if (pluginArtifact != null) {\n        builder.add(pluginArtifact, plugin);\n      }\n    }\n\n    // fetch modules \n    Iterable<SNode> originalModules = ListSequence.fromList(SLinkOperations.getTargets(thisNode, \"modules\", true)).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), it, \"virtual_getModules_4560297596904469651\", new Object[]{});\n      }\n    });\n    Iterable<SNode> modules = Sequence.fromIterable(new MPSModulesClosure(genContext, originalModules).trackDevkits().designtimeClosure().getAllModules()).union(Sequence.fromIterable(originalModules));\n    for (SNode m : Sequence.fromIterable(modules)) {\n      SNode artifact;\n      SNode originalModule = DependenciesHelper.getOriginalNode(m, genContext);\n      VisibleArtifacts currentArtifacts = artifacts;\n      artifact = SNodeOperations.as(currentArtifacts.findArtifact(originalModule), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n      if (artifact != null) {\n        builder.add(DependenciesHelper.getOriginalNode(artifact, genContext), originalModule);\n      } else if (SNodeOperations.isInstanceOf(originalModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\")) {\n        artifact = SNodeOperations.as(currentArtifacts.findArtifact(SLinkOperations.getTarget(SNodeOperations.cast(originalModule, \"jetbrains.mps.build.mps.structure.BuildMps_DevKit\"), \"path\", true)), \"jetbrains.mps.build.structure.BuildLayout_Node\");\n        if (artifact != null) {\n          builder.add(DependenciesHelper.getOriginalNode(artifact, artifacts.getGenContext()), originalModule);\n        }\n      }\n    }\n  }","commit_id":"32bad6edc4180b64c98f3f1c26b53eefffc0b09a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_8lyoff_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_8lyoff_a\");\n    editorCell.addEditorCell(this.createConstant_8lyoff_a0(editorContext, node));\n    editorCell.addEditorCell(this.createRefNode_8lyoff_b0(editorContext, node));\n    return editorCell;\n  }","id":74506,"modified_method":"private EditorCell createCollection_8lyoff_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_8lyoff_a\");\n    editorCell.setBig(true);\n    editorCell.addEditorCell(this.createConstant_8lyoff_a0(editorContext, node));\n    editorCell.addEditorCell(this.createRefNode_8lyoff_b0(editorContext, node));\n    return editorCell;\n  }","commit_id":"32bad6edc4180b64c98f3f1c26b53eefffc0b09a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private EditorCell createCollection_bxswyp_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_bxswyp_a\");\n    editorCell.addEditorCell(this.createConstant_bxswyp_a0(editorContext, node));\n    editorCell.addEditorCell(this.createAttributedNodeCell_bxswyp_b0(editorContext, node));\n    return editorCell;\n  }","id":74507,"modified_method":"private EditorCell createCollection_bxswyp_a(EditorContext editorContext, SNode node) {\n    EditorCell_Collection editorCell = EditorCell_Collection.createIndent2(editorContext, node);\n    editorCell.setCellId(\"Collection_bxswyp_a\");\n    editorCell.setBig(true);\n    editorCell.addEditorCell(this.createConstant_bxswyp_a0(editorContext, node));\n    editorCell.addEditorCell(this.createAttributedNodeCell_bxswyp_b0(editorContext, node));\n    return editorCell;\n  }","commit_id":"32bad6edc4180b64c98f3f1c26b53eefffc0b09a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object insertMacro_varValue_4608161086082556980(final IOperationContext operationContext, final TemplateQueryContext _context) {\n    return ((MPSModulesClosure) _context.getVariable(\"var:closure\")).getAllModules();\n  }","id":74508,"modified_method":"public static Object insertMacro_varValue_4608161086082556980(final IOperationContext operationContext, final TemplateQueryContext _context) {\n    return Sequence.fromIterable(((MPSModulesClosure) _context.getVariable(\"var:closure\")).getAllModules()).select(new ISelector<SNode, SNode>() {\n      public SNode select(SNode it) {\n        return SNodeOperations.cast(DependenciesHelper.getOriginalNode(it, _context), \"jetbrains.mps.build.mps.structure.BuildMps_AbstractModule\");\n      }\n    });\n  }","commit_id":"32bad6edc4180b64c98f3f1c26b53eefffc0b09a","url":"https://github.com/JetBrains/MPS"},{"original_method":"public static Object insertMacro_varValue_4005526075833130408(final IOperationContext operationContext, final TemplateQueryContext _context) {\n    return new MPSModulesClosure(_context, ListSequence.fromList(SLinkOperations.getTargets(_context.getNode(), \"modules\", true)).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), SNodeOperations.as(DependenciesHelper.getOriginalNode(it, _context), \"jetbrains.mps.build.mps.tests.structure.BuildMpsLayout_TestModules_Content\"), \"virtual_getModules_4560297596904469651\", new Object[]{});\n      }\n    })).trackDevkits().runtimeClosure();\n  }","id":74509,"modified_method":"public static Object insertMacro_varValue_4005526075833130408(final IOperationContext operationContext, final TemplateQueryContext _context) {\n    return new MPSModulesClosure(_context, ListSequence.fromList(SLinkOperations.getTargets(_context.getNode(), \"modules\", true)).translate(new ITranslator2<SNode, SNode>() {\n      public Iterable<SNode> translate(SNode it) {\n        return BehaviorReflection.invokeVirtual((Class<Iterable<SNode>>) ((Class) Object.class), SNodeOperations.as(it, \"jetbrains.mps.build.mps.tests.structure.BuildMpsLayout_TestModules_Content\"), \"virtual_getModules_4560297596904469651\", new Object[]{});\n      }\n    })).trackDevkits().designtimeClosure();\n  }","commit_id":"32bad6edc4180b64c98f3f1c26b53eefffc0b09a","url":"https://github.com/JetBrains/MPS"},{"original_method":"private static boolean scopeMatches(PsiElement element, PsiElement declaration) {\n    final InjectedLanguageManager injector = InjectedLanguageManager.getInstance(element.getProject());\n    final XmlTagChild elementContainer = PsiTreeUtil.getNonStrictParentOfType(injector.getInjectionHost(element),\n                                                                              XmlTag.class, XmlText.class);\n    final XmlTagChild declarationContainer = PsiTreeUtil.getNonStrictParentOfType(injector.getInjectionHost(declaration),\n                                                                                  XmlTag.class, XmlText.class);\n    if (elementContainer != null && declarationContainer != null) {\n      return PsiTreeUtil.isAncestor(declarationContainer, elementContainer, true);\n    }\n    return true;\n  }","id":74510,"modified_method":"private static boolean scopeMatches(PsiElement element, PsiElement declaration) {\n    final InjectedLanguageManager injector = InjectedLanguageManager.getInstance(element.getProject());\n    final PsiLanguageInjectionHost elementContainer = injector.getInjectionHost(element);\n    final XmlTagChild elementTag = PsiTreeUtil.getNonStrictParentOfType(elementContainer, XmlTag.class, XmlText.class);\n    final PsiLanguageInjectionHost declarationContainer = injector.getInjectionHost(declaration);\n    final XmlTagChild declarationTag = PsiTreeUtil.getNonStrictParentOfType(declarationContainer, XmlTag.class, XmlText.class);\n\n    if (declarationContainer != null && elementContainer != null && elementTag != null && declarationTag != null) {\n      return PsiTreeUtil.isAncestor(declarationTag, elementTag, true) ||\n             (PsiTreeUtil.isAncestor(declarationTag, elementTag, false) &&\n              declarationContainer.getTextOffset() < elementContainer.getTextOffset());\n    }\n    return true;\n  }","commit_id":"d1817907ff50c518c589d09cb3eba614b4cb9edf","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected static Pair<PsiElement, PsiElement> getElementRange(Editor editor, PsiFile file, final LineRange range) {\n    final int startOffset = editor.logicalPositionToOffset(new LogicalPosition(range.startLine, 0));\n    PsiElement startingElement = firstNonWhiteElement(startOffset, file, true);\n    if (startingElement == null) return null;\n    final int endOffset = editor.logicalPositionToOffset(new LogicalPosition(range.endLine, 0)) -1;\n\n    PsiElement endingElement = firstNonWhiteElement(endOffset, file, false);\n    if (endingElement == null) return null;\n    if (!PsiTreeUtil.isAncestor(startingElement, endingElement, false)\n        && startingElement.getTextRange().getEndOffset() > endingElement.getTextRange().getStartOffset()) return null;\n    return Pair.create(startingElement, endingElement);\n  }","id":74511,"modified_method":"protected static Pair<PsiElement, PsiElement> getElementRange(Editor editor, PsiFile file, final LineRange range) {\n    final int startOffset = editor.logicalPositionToOffset(new LogicalPosition(range.startLine, 0));\n    PsiElement startingElement = firstNonWhiteElement(startOffset, file, true);\n    if (startingElement == null) return null;\n    final int endOffset = editor.logicalPositionToOffset(new LogicalPosition(range.endLine, 0)) -1;\n\n    PsiElement endingElement = firstNonWhiteElement(endOffset, file, false);\n    if (endingElement == null) return null;\n    if (PsiTreeUtil.isAncestor(startingElement, endingElement, false) ||\n        startingElement.getTextRange().getEndOffset() <= endingElement.getTextRange().getStartOffset()) {\n      return Pair.create(startingElement, endingElement);\n    }\n    if (PsiTreeUtil.isAncestor(endingElement, startingElement, false)) {\n      return Pair.create(startingElement, endingElement);\n    }\n    return null;\n  }","commit_id":"bfb16c13471ac5149e086322a9a287fa0b1013ec","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean isInside (PsiElement place, PsiElement ancestor) {\n    if (ancestor instanceof PsiDirectoryContainer) {\n      final PsiDirectory[] directories = ((PsiDirectoryContainer)ancestor).getDirectories(place.getResolveScope());\n      for (PsiDirectory directory : directories) {\n        if (isInside(place, directory)) return true;\n      }\n    }\n\n    if (ancestor instanceof PsiFile) {\n      for (PsiFile file : ((PsiFile)ancestor).getViewProvider().getAllFiles()) {\n        if (PsiTreeUtil.isAncestor(file, place, false)) return true;\n      }\n    }\n\n    return PsiTreeUtil.isAncestor(ancestor, place, false);\n  }","id":74512,"modified_method":"public static boolean isInside (PsiElement place, PsiElement ancestor) {\n    if (ancestor instanceof PsiDirectoryContainer) {\n      final PsiDirectory[] directories = ((PsiDirectoryContainer)ancestor).getDirectories(place.getResolveScope());\n      for (PsiDirectory directory : directories) {\n        if (isInside(place, directory)) return true;\n      }\n    }\n\n    if (ancestor instanceof PsiFile) {\n      for (PsiFile file : ((PsiFile)ancestor).getViewProvider().getAllFiles()) {\n        if (PsiTreeUtil.isAncestor(file, place, false)) return true;\n      }\n    }\n\n    boolean isAncestor = PsiTreeUtil.isAncestor(ancestor, place, false);\n    if (!isAncestor && ancestor instanceof PsiNameIdentifierOwner) {\n      final PsiElement nameIdentifier = ((PsiNameIdentifierOwner)ancestor).getNameIdentifier();\n      if (nameIdentifier != null && !PsiTreeUtil.isAncestor(ancestor, nameIdentifier, true)) {\n        isAncestor = PsiTreeUtil.isAncestor(nameIdentifier.getParent(), place, false);\n      }\n    }\n    return isAncestor;\n  }","commit_id":"66122d1bd2e947cee95cf659274a30e83a72f788","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (session.isProperType(myS) && session.isProperType(myT)) {\n      if (myT == null) return myS == null || myS.equalsToText(CommonClassNames.JAVA_LANG_OBJECT); \n      if (myS == null) return true; \n      return TypeConversionUtil.isAssignable(myT, myS);\n    }\n\n    if (PsiType.NULL.equals(myT) || myT == null) return false;\n    if (PsiType.NULL.equals(myS) || myS == null || myT.equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) return true;\n\n    InferenceVariable inferenceVariable = session.getInferenceVariable(myS);\n    if (inferenceVariable != null) {\n      inferenceVariable.addBound(myT, InferenceBound.UPPER);\n      return true;\n    }\n    inferenceVariable = session.getInferenceVariable(myT);\n    if (inferenceVariable != null) {\n      inferenceVariable.addBound(myS, InferenceBound.LOWER);\n      return true;\n    }\n    if (myT instanceof PsiArrayType) {\n      if (!(myS instanceof PsiArrayType)) return false; //todo most specific array supertype\n      final PsiType tComponentType = ((PsiArrayType)myT).getComponentType();\n      final PsiType sComponentType = ((PsiArrayType)myS).getComponentType();\n      if (!(tComponentType instanceof PsiPrimitiveType) && !(sComponentType instanceof PsiPrimitiveType)) {\n        constraints.add(new StrictSubtypingConstraint(tComponentType, sComponentType));\n        return true;\n      }\n      return sComponentType instanceof PsiPrimitiveType && sComponentType.equals(tComponentType);\n    }\n    if (myT instanceof PsiClassType) {\n      final PsiClassType.ClassResolveResult TResult = ((PsiClassType)myT).resolveGenerics();\n      final PsiClass CClass = TResult.getElement();\n      if (CClass != null) {\n        if (CClass instanceof PsiTypeParameter) {\n          if (myS instanceof PsiIntersectionType) {\n            for (PsiType conjunct : ((PsiIntersectionType)myS).getConjuncts()) {\n              if (myT.equals(conjunct)) return true;\n            }\n          }\n          final PsiType lowerBound = CClass.getUserData(InferenceSession.LOWER_BOUND);\n          if (lowerBound != null) {\n            constraints.add(new StrictSubtypingConstraint(lowerBound, myS));\n            return true;\n          }\n          return false;\n        }\n\n        if (!(myS instanceof PsiClassType)) return false;\n        PsiClassType.ClassResolveResult SResult = ((PsiClassType)myS).resolveGenerics();\n        PsiClass SClass = SResult.getElement();\n        if (((PsiClassType)myT).isRaw()) {\n          return SClass != null && InheritanceUtil.isInheritorOrSelf(SClass, CClass, true);\n        }\n        final PsiSubstitutor tSubstitutor = TResult.getSubstitutor();\n        final PsiSubstitutor sSubstitutor = SClass != null ? TypeConversionUtil.getClassSubstitutor(CClass, SClass, SResult.getSubstitutor()) : null;\n        if (sSubstitutor != null) {\n          for (PsiTypeParameter parameter : CClass.getTypeParameters()) {\n            final PsiType tSubstituted = tSubstitutor.substitute(parameter);\n            final PsiType sSubstituted = sSubstitutor.substituteWithBoundsPromotion(parameter);\n            constraints.add(new SubtypingConstraint(tSubstituted, sSubstituted));\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n\n    if (myT instanceof PsiIntersectionType) {\n      for (PsiType conjunct : ((PsiIntersectionType)myT).getConjuncts()) {\n        constraints.add(new StrictSubtypingConstraint(conjunct, myS));\n      }\n      return true;\n    }\n\n    return true;\n  }","id":74513,"modified_method":"@Override\n  public boolean reduce(InferenceSession session, List<ConstraintFormula> constraints) {\n    if (session.isProperType(myS) && session.isProperType(myT)) {\n      if (myT == null) return myS == null || myS.equalsToText(CommonClassNames.JAVA_LANG_OBJECT); \n      if (myS == null) return true; \n      return TypeConversionUtil.isAssignable(myT, myS);\n    }\n\n    if (PsiType.NULL.equals(myT) || myT == null) return false;\n    if (PsiType.NULL.equals(myS) || myS == null || myT.equalsToText(CommonClassNames.JAVA_LANG_OBJECT)) return true;\n\n    InferenceVariable inferenceVariable = session.getInferenceVariable(myS);\n    if (inferenceVariable != null) {\n      inferenceVariable.addBound(myT, InferenceBound.UPPER);\n      return true;\n    }\n    inferenceVariable = session.getInferenceVariable(myT);\n    if (inferenceVariable != null) {\n      inferenceVariable.addBound(myS, InferenceBound.LOWER);\n      return true;\n    }\n    if (myT instanceof PsiArrayType) {\n      if (!(myS instanceof PsiArrayType)) return false; //todo most specific array supertype\n      final PsiType tComponentType = ((PsiArrayType)myT).getComponentType();\n      final PsiType sComponentType = ((PsiArrayType)myS).getComponentType();\n      if (!(tComponentType instanceof PsiPrimitiveType) && !(sComponentType instanceof PsiPrimitiveType)) {\n        constraints.add(new StrictSubtypingConstraint(tComponentType, sComponentType));\n        return true;\n      }\n      return sComponentType instanceof PsiPrimitiveType && sComponentType.equals(tComponentType);\n    }\n    if (myT instanceof PsiClassType) {\n      final PsiClassType.ClassResolveResult TResult = ((PsiClassType)myT).resolveGenerics();\n      final PsiClass CClass = TResult.getElement();\n      if (CClass != null) {\n        if (CClass instanceof PsiTypeParameter) {\n          if (myS instanceof PsiIntersectionType) {\n            for (PsiType conjunct : ((PsiIntersectionType)myS).getConjuncts()) {\n              if (myT.equals(conjunct)) return true;\n            }\n          }\n          final PsiType lowerBound = CClass.getUserData(InferenceSession.LOWER_BOUND);\n          if (lowerBound != null) {\n            constraints.add(new StrictSubtypingConstraint(lowerBound, myS));\n            return true;\n          }\n          return false;\n        }\n\n        PsiClassType.ClassResolveResult SResult = null;\n        if (myS instanceof PsiIntersectionType) {\n          for (PsiType conjunct : ((PsiIntersectionType)myS).getConjuncts()) {\n            if (conjunct instanceof PsiClassType) {\n              final PsiClassType.ClassResolveResult conjunctResult = ((PsiClassType)conjunct).resolveGenerics();\n              if (InheritanceUtil.isInheritorOrSelf(conjunctResult.getElement(), CClass, true)) {\n                SResult = conjunctResult;\n                break;\n              }\n            }\n          }\n        } else if (myS instanceof PsiClassType) {\n          SResult = ((PsiClassType)myS).resolveGenerics();\n        }\n\n        if (SResult == null) return false;\n        PsiClass SClass = SResult.getElement();\n        if (((PsiClassType)myT).isRaw()) {\n          return SClass != null && InheritanceUtil.isInheritorOrSelf(SClass, CClass, true);\n        }\n        final PsiSubstitutor tSubstitutor = TResult.getSubstitutor();\n        final PsiSubstitutor sSubstitutor = SClass != null ? TypeConversionUtil.getClassSubstitutor(CClass, SClass, SResult.getSubstitutor()) : null;\n        if (sSubstitutor != null) {\n          for (PsiTypeParameter parameter : CClass.getTypeParameters()) {\n            final PsiType tSubstituted = tSubstitutor.substitute(parameter);\n            final PsiType sSubstituted = sSubstitutor.substituteWithBoundsPromotion(parameter);\n            constraints.add(new SubtypingConstraint(tSubstituted, sSubstituted));\n          }\n          return true;\n        }\n      }\n      return false;\n    }\n\n    if (myT instanceof PsiIntersectionType) {\n      for (PsiType conjunct : ((PsiIntersectionType)myT).getConjuncts()) {\n        constraints.add(new StrictSubtypingConstraint(conjunct, myS));\n      }\n      return true;\n    }\n\n    return true;\n  }","commit_id":"16838a8c11b6ce169db1d061ca104d548ec33e69","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private static LookupElement castQualifier(@NotNull LookupElement item,\n                                             @Nullable final PsiTypeLookupItem castTypeItem,\n                                             @Nullable PsiType plainQualifier) {\n    if (castTypeItem == null) {\n      return item;\n    }\n    if (plainQualifier != null) {\n      Object o = item.getObject();\n      if (containsMember(plainQualifier, o)) {\n        if (!(o instanceof PsiMethod)) {\n          return item;\n        }\n        PsiType castType = castTypeItem.getPsiType();\n        if (plainQualifier instanceof PsiClassType && castType instanceof PsiClassType) {\n          PsiMethod method = (PsiMethod)o;\n          PsiSubstitutor plainSub = ((PsiClassType)plainQualifier).resolveGenerics().getSubstitutor();\n          PsiSubstitutor castSub = ((PsiClassType)castType).resolveGenerics().getSubstitutor();\n          if (method.getSignature(plainSub).equals(method.getSignature(castSub)) &&\n              plainSub.substitute(method.getReturnType()).equals(castSub.substitute(method.getReturnType()))) {\n            return item;\n          }\n        }\n      }\n    }\n\n    return LookupElementDecorator.withInsertHandler(item, new InsertHandlerDecorator<LookupElement>() {\n      public void handleInsert(InsertionContext context, LookupElementDecorator<LookupElement> item) {\n        final Document document = context.getEditor().getDocument();\n        context.commitDocument();\n        final PsiFile file = context.getFile();\n        final PsiJavaCodeReferenceElement ref =\n          PsiTreeUtil.findElementOfClassAtOffset(file, context.getStartOffset(), PsiJavaCodeReferenceElement.class, false);\n        if (ref != null) {\n          final PsiElement qualifier = ref.getQualifier();\n          if (qualifier != null) {\n            final CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(qualifier.getProject());\n\n            final String parenSpace = settings.SPACE_WITHIN_PARENTHESES ? \" \" : \"\";\n            document.insertString(qualifier.getTextRange().getEndOffset(), parenSpace + \")\");\n\n            final String spaceWithin = settings.SPACE_WITHIN_CAST_PARENTHESES ? \" \" : \"\";\n            final String prefix = \"(\" + parenSpace + \"(\" + spaceWithin;\n            final String spaceAfter = settings.SPACE_AFTER_TYPE_CAST ? \" \" : \"\";\n            final int exprStart = qualifier.getTextRange().getStartOffset();\n            document.insertString(exprStart, prefix + spaceWithin + \")\" + spaceAfter);\n\n            CompletionUtil.emulateInsertion(context, exprStart + prefix.length(), castTypeItem);\n            context.getEditor().getCaretModel().moveToOffset(context.getTailOffset());\n          }\n        }\n\n        item.getDelegate().handleInsert(context);\n      }\n    });\n  }","id":74514,"modified_method":"@NotNull\n  private static LookupElement castQualifier(@NotNull LookupElement item,\n                                             @Nullable final PsiTypeLookupItem castTypeItem,\n                                             @Nullable PsiType plainQualifier) {\n    if (castTypeItem == null) {\n      return item;\n    }\n    if (plainQualifier != null) {\n      Object o = item.getObject();\n      if (containsMember(plainQualifier, o)) {\n        if (!(o instanceof PsiMethod)) {\n          return item;\n        }\n        PsiType castType = castTypeItem.getPsiType();\n        if (plainQualifier instanceof PsiClassType && castType instanceof PsiClassType) {\n          PsiMethod method = (PsiMethod)o;\n          PsiClassType.ClassResolveResult plainResult = ((PsiClassType)plainQualifier).resolveGenerics();\n          PsiClass plainClass = plainResult.getElement();\n          PsiClass castClass = ((PsiClassType)castType).resolveGenerics().getElement();\n\n          if (castClass == null || plainClass == null || !castClass.isInheritor(plainClass, true)) {\n            return item;\n          }\n\n          PsiSubstitutor plainSub = plainResult.getSubstitutor();\n          PsiSubstitutor castSub = TypeConversionUtil.getSuperClassSubstitutor(plainClass, (PsiClassType)castType);\n          if (method.getSignature(plainSub).equals(method.getSignature(castSub)) &&\n              plainSub.substitute(method.getReturnType()).equals(castSub.substitute(method.getReturnType()))) {\n            return item;\n          }\n        }\n      }\n    }\n\n    return LookupElementDecorator.withInsertHandler(item, new InsertHandlerDecorator<LookupElement>() {\n      public void handleInsert(InsertionContext context, LookupElementDecorator<LookupElement> item) {\n        final Document document = context.getEditor().getDocument();\n        context.commitDocument();\n        final PsiFile file = context.getFile();\n        final PsiJavaCodeReferenceElement ref =\n          PsiTreeUtil.findElementOfClassAtOffset(file, context.getStartOffset(), PsiJavaCodeReferenceElement.class, false);\n        if (ref != null) {\n          final PsiElement qualifier = ref.getQualifier();\n          if (qualifier != null) {\n            final CodeStyleSettings settings = CodeStyleSettingsManager.getSettings(qualifier.getProject());\n\n            final String parenSpace = settings.SPACE_WITHIN_PARENTHESES ? \" \" : \"\";\n            document.insertString(qualifier.getTextRange().getEndOffset(), parenSpace + \")\");\n\n            final String spaceWithin = settings.SPACE_WITHIN_CAST_PARENTHESES ? \" \" : \"\";\n            final String prefix = \"(\" + parenSpace + \"(\" + spaceWithin;\n            final String spaceAfter = settings.SPACE_AFTER_TYPE_CAST ? \" \" : \"\";\n            final int exprStart = qualifier.getTextRange().getStartOffset();\n            document.insertString(exprStart, prefix + spaceWithin + \")\" + spaceAfter);\n\n            CompletionUtil.emulateInsertion(context, exprStart + prefix.length(), castTypeItem);\n            context.getEditor().getCaretModel().moveToOffset(context.getTailOffset());\n          }\n        }\n\n        item.getDelegate().handleInsert(context);\n      }\n    });\n  }","commit_id":"205d9f807efdb63bba06ae27d367b06c862fc4dd","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public GroovyResolveResult[] multiResolveClass() {\n    PsiClassType type = myReference.getConstructedClassType();\n    if (type == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    return new GroovyResolveResult[]{new GroovyResolveResultImpl(type.resolveGenerics())};\n  }","id":74515,"modified_method":"@Override\n  public GroovyResolveResult[] multiResolveClass() {\n    PsiClassType type = myReference.getConstructedClassType();\n    if (type == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    final GroovyResolveResult result = GroovyResolveResultImpl.from(type.resolveGenerics());\n    if (result == null) return GroovyResolveResult.EMPTY_ARRAY;\n    return new GroovyResolveResult[]{result};\n  }","commit_id":"c2762c6c6d3ad86cf4a177f2c1f21e3338264e86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public GroovyResolveResult[] multiResolve(boolean incompleteCode) {\n    PsiClassType type = getConstructedClassType();\n    if (type == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    final PsiClassType.ClassResolveResult classResolveResult = type.resolveGenerics();\n\n    final GroovyResolveResult[] constructorCandidates = PsiUtil.getConstructorCandidates(type, getCallArgumentTypes(), getElement());\n\n    if (constructorCandidates.length == 0 && classResolveResult.getElement() != null) {\n      return new GroovyResolveResult[]{new GroovyResolveResultImpl(classResolveResult)};\n    }\n    return constructorCandidates;\n  }","id":74516,"modified_method":"@NotNull\n  @Override\n  public GroovyResolveResult[] multiResolve(boolean incompleteCode) {\n    PsiClassType type = getConstructedClassType();\n    if (type == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    final PsiClassType.ClassResolveResult classResolveResult = type.resolveGenerics();\n\n    final GroovyResolveResult[] constructorCandidates = PsiUtil.getConstructorCandidates(type, getCallArgumentTypes(), getElement());\n\n    if (constructorCandidates.length == 0) {\n      final GroovyResolveResult result = GroovyResolveResultImpl.from(classResolveResult);\n      if (result != null) return new GroovyResolveResult[]{result};\n    }\n    return constructorCandidates;\n  }","commit_id":"c2762c6c6d3ad86cf4a177f2c1f21e3338264e86","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testExtensionsWithOrderingUpdate() {\n    ExtensionsAreaImpl extensionsArea = new ExtensionsAreaImpl(new DefaultPicoContainer(), new Extensions.SimpleLogProvider());\n    extensionsArea.registerExtensionPoint(\"ep1\", TestExtensionClassOne.class.getName());\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"_7\\\" order=\\\"LAST\\\"><text>7<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"fst\\\" order=\\\"FIRST\\\"><text>1<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"id\\\"><text>4<\/text><\/extension>\"));\n    ExtensionPoint extensionPoint = extensionsArea.getExtensionPoint(\"ep1\");\n    TestExtensionClassOne[] extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(3, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"4\", extensions[1].getText());\n    assertEquals(\"7\", extensions[2].getText());\n    TestExtensionClassOne extension = new TestExtensionClassOne(\"xxx\");\n    extensionPoint.registerExtension(extension);\n    extensionPoint.unregisterExtension(extension);\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"BEFORE id\\\"><text>3<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"AFTER id\\\"><text>6<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"last, after _7\\\"><text>8<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"after id, before _7, after fst\\\"><text>5<\/text><\/extension>\"));\n    extensionPoint.registerExtension(new TestExtensionClassOne(\"2\"));\n    extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(8, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"2\", extensions[1].getText());\n    assertEquals(\"3\", extensions[2].getText());\n    assertEquals(\"4\", extensions[3].getText());\n    assertEquals(\"5\", extensions[4].getText());\n    assertEquals(\"6\", extensions[5].getText());\n    assertEquals(\"7\", extensions[6].getText());\n    assertEquals(\"8\", extensions[7].getText());\n  }","id":74517,"modified_method":"public void testExtensionsWithOrderingUpdate() {\n    ExtensionsAreaImpl extensionsArea = new ExtensionsAreaImpl(new DefaultPicoContainer(), new Extensions.SimpleLogProvider());\n    extensionsArea.registerExtensionPoint(\"ep1\", TestExtensionClassOne.class.getName());\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"_7\\\" order=\\\"LAST\\\"><text>7<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"fst\\\" order=\\\"FIRST\\\"><text>1<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" id=\\\"id\\\"><text>3<\/text><\/extension>\"));\n    ExtensionPoint extensionPoint = extensionsArea.getExtensionPoint(\"ep1\");\n    TestExtensionClassOne[] extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(3, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"3\", extensions[1].getText());\n    assertEquals(\"7\", extensions[2].getText());\n    TestExtensionClassOne extension = new TestExtensionClassOne(\"xxx\");\n    extensionPoint.registerExtension(extension);\n    extensionPoint.unregisterExtension(extension);\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"BEFORE id\\\"><text>2<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"AFTER id\\\"><text>4<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"last, after _7\\\"><text>8<\/text><\/extension>\"));\n    extensionsArea.registerExtension(\"\", ExtensionComponentAdapterTest.readElement(\n        \"<extension point=\\\"ep1\\\" order=\\\"after:id, before _7, after fst\\\"><text>5<\/text><\/extension>\"));\n    extensionPoint.registerExtension(new TestExtensionClassOne(\"6\"));\n    extensions = (TestExtensionClassOne[]) extensionPoint.getExtensions();\n    assertEquals(8, extensions.length);\n    assertEquals(\"1\", extensions[0].getText());\n    assertEquals(\"2\", extensions[1].getText());\n    assertEquals(\"3\", extensions[2].getText());\n    assertEquals(\"4\", extensions[3].getText());\n    assertEquals(\"5\", extensions[4].getText());\n    assertEquals(\"6\", extensions[5].getText());\n    assertEquals(\"7\", extensions[6].getText());\n    assertEquals(\"8\", extensions[7].getText());\n  }","commit_id":"da651210dc13011d2b276c95b6153fa1b132b16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private LoadingOrder(@NonNls @NotNull String text) {\n    myName = text;\n    final String[] strings = text.split(\",\");\n    for (final String string : strings) {\n      String trimmed = string.trim();\n      if (trimmed.equalsIgnoreCase(FIRST_STR)) myFirst = true;\n      else if (trimmed.equalsIgnoreCase(LAST_STR)) myLast = true;\n      else if (StringUtil.startsWithIgnoreCase(trimmed, BEFORE_STR)) myBefore.add(trimmed.substring(BEFORE_STR.length()));\n      else if (StringUtil.startsWithIgnoreCase(trimmed, AFTER_STR)) myAfter.add(trimmed.substring(AFTER_STR.length()));\n      else throw new AssertionError(\"Invalid specification: \" + trimmed + \"; should be one of FIRST, LAST, BEFORE <id> or AFTER <id>\");\n    }\n\n  }","id":74518,"modified_method":"private LoadingOrder(@NonNls @NotNull String text) {\n    myName = text;\n    final String[] strings = text.split(\",\");\n    for (final String string : strings) {\n      String trimmed = string.trim();\n      if (trimmed.equalsIgnoreCase(FIRST_STR)) myFirst = true;\n      else if (trimmed.equalsIgnoreCase(LAST_STR)) myLast = true;\n      else if (StringUtil.startsWithIgnoreCase(trimmed, BEFORE_STR)) myBefore.add(trimmed.substring(BEFORE_STR.length()).trim());\n      else if (StringUtil.startsWithIgnoreCase(trimmed, BEFORE_STR_OLD)) myBefore.add(trimmed.substring(BEFORE_STR_OLD.length()).trim());\n      else if (StringUtil.startsWithIgnoreCase(trimmed, AFTER_STR)) myAfter.add(trimmed.substring(AFTER_STR.length()).trim());\n      else if (StringUtil.startsWithIgnoreCase(trimmed, AFTER_STR_OLD)) myAfter.add(trimmed.substring(AFTER_STR_OLD.length()).trim());\n      else throw new AssertionError(\"Invalid specification: \" + trimmed + \"; should be one of FIRST, LAST, BEFORE <id> or AFTER <id>\");\n    }\n\n  }","commit_id":"da651210dc13011d2b276c95b6153fa1b132b16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void sort(final Orderable[] orderables) {\n    final Map<String,Orderable> map = new HashMap<String, Orderable>();\n    for (final Orderable orderable : orderables) {\n      final String id = orderable.getOrderId();\n      if (StringUtil.isNotEmpty(id)) {\n        map.put(id, orderable);\n      }\n    }\n\n    DFSTBuilder<Orderable> builder = new DFSTBuilder<Orderable>(new GraphGenerator<Orderable>(new CachingSemiGraph<Orderable>(new GraphGenerator.SemiGraph<Orderable>() {\n      public Collection<Orderable> getNodes() {\n        return Arrays.asList(orderables);\n      }\n\n      public Iterator<Orderable> getIn(final Orderable n) {\n        final LoadingOrder order = n.getOrder();\n\n        Set<Orderable> predecessors = new LinkedHashSet<Orderable>();\n        for (final String id : order.myAfter) {\n          final Orderable orderable = map.get(id);\n          if (orderable != null) {\n            predecessors.add(orderable);\n          }\n        }\n\n        String id = n.getOrderId();\n        for (final Orderable orderable : orderables) {\n          final LoadingOrder hisOrder = orderable.getOrder();\n          if (StringUtil.isNotEmpty(id) && hisOrder.myBefore.contains(id) ||\n              order.myLast && !hisOrder.myLast ||\n              hisOrder.myFirst && !order.myFirst) {\n            predecessors.add(orderable);\n          }\n        }\n        return predecessors.iterator();\n      }\n    })));\n\n    if (!builder.isAcyclic()) {\n      final Pair<Orderable,Orderable> dependency = builder.getCircularDependency();\n      throw new SortingException(\"Could not satisfy sorting requirements\", new Element[]{dependency.first.getDescribingElement(), dependency.second.getDescribingElement()});\n    }\n\n    Arrays.sort(orderables, builder.comparator());\n  }","id":74519,"modified_method":"public static void sort(final Orderable[] orderables) {\n    final Map<String,Orderable> map = new HashMap<String, Orderable>();\n    for (final Orderable orderable : orderables) {\n      final String id = orderable.getOrderId();\n      if (StringUtil.isNotEmpty(id)) {\n        map.put(id, orderable);\n      }\n    }\n\n    DFSTBuilder<Orderable> builder = new DFSTBuilder<Orderable>(new GraphGenerator<Orderable>(new CachingSemiGraph<Orderable>(new GraphGenerator.SemiGraph<Orderable>() {\n      public Collection<Orderable> getNodes() {\n        final ArrayList<Orderable> list = new ArrayList<Orderable>(Arrays.asList(orderables));\n        Collections.reverse(list);\n        return list;\n      }\n\n      public Iterator<Orderable> getIn(final Orderable n) {\n        final LoadingOrder order = n.getOrder();\n\n        Set<Orderable> predecessors = new LinkedHashSet<Orderable>();\n        for (final String id : order.myAfter) {\n          final Orderable orderable = map.get(id);\n          if (orderable != null) {\n            predecessors.add(orderable);\n          }\n        }\n\n        String id = n.getOrderId();\n        for (final Orderable orderable : orderables) {\n          final LoadingOrder hisOrder = orderable.getOrder();\n          if (StringUtil.isNotEmpty(id) && hisOrder.myBefore.contains(id) ||\n              order.myLast && !hisOrder.myLast ||\n              hisOrder.myFirst && !order.myFirst) {\n            predecessors.add(orderable);\n          }\n        }\n        return predecessors.iterator();\n      }\n    })));\n\n    if (!builder.isAcyclic()) {\n      final Pair<Orderable,Orderable> dependency = builder.getCircularDependency();\n      throw new SortingException(\"Could not satisfy sorting requirements\", new Element[]{dependency.first.getDescribingElement(), dependency.second.getDescribingElement()});\n    }\n\n    Arrays.sort(orderables, builder.comparator());\n  }","commit_id":"da651210dc13011d2b276c95b6153fa1b132b16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testComplexSorting2() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    @NonNls String idOne = \"idone\";\n    target.add(createElement(LoadingOrder.before(idOne), null, \"3\"));\n    target.add(createElement(LoadingOrder.after(idOne), null, \"5\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    target.add(createElement(LoadingOrder.ANY, idOne, \"4\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"2\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"6\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"123456\");\n  }","id":74520,"modified_method":"public void testComplexSorting2() {\n    ArrayList<LoadingOrder.Orderable> target = new ArrayList<LoadingOrder.Orderable>();\n    @NonNls String idOne = \"idone\";\n    target.add(createElement(LoadingOrder.before(idOne), null, \"2\"));\n    target.add(createElement(LoadingOrder.after(idOne), null, \"4\"));\n    target.add(createElement(LoadingOrder.FIRST, null, \"1\"));\n    target.add(createElement(LoadingOrder.ANY, idOne, \"3\"));\n    target.add(createElement(LoadingOrder.ANY, null, \"5\"));\n    target.add(createElement(LoadingOrder.LAST, null, \"6\"));\n    LoadingOrder.Orderable[] array = target.toArray(new LoadingOrder.Orderable[target.size()]);\n    assertSequence(array, \"123456\");\n  }","commit_id":"da651210dc13011d2b276c95b6153fa1b132b16f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected Object executeSQLScript(final String iText, final ODatabaseDocument db) throws IOException {\r\n    Object lastResult = null;\r\n    int maxRetry = 1;\r\n\r\n    context.setVariable(\"transactionRetries\", 0);\r\n\r\n    for (int retry = 1; retry <= maxRetry; retry++) {\r\n      try {\r\n        try {\r\n          int txBegunAtLine = -1;\r\n          int txBegunAtPart = -1;\r\n          lastResult = null;\r\n\r\n          final BufferedReader reader = new BufferedReader(new StringReader(iText));\r\n\r\n          int line = 0;\r\n          int linePart = 0;\r\n          String lastLine;\r\n          boolean txBegun = false;\r\n\r\n          for (; line < txBegunAtLine; ++line)\r\n            // SKIP PREVIOUS COMMAND AND JUMP TO THE BEGIN IF ANY\r\n            reader.readLine();\r\n\r\n          for (; (lastLine = reader.readLine()) != null; ++line) {\r\n            lastLine = lastLine.trim();\r\n\r\n            final List<String> lineParts = OStringSerializerHelper.smartSplit(lastLine, ';', true);\r\n\r\n            if (line == txBegunAtLine)\r\n              // SKIP PREVIOUS COMMAND PART AND JUMP TO THE BEGIN IF ANY\r\n              linePart = txBegunAtPart;\r\n            else\r\n              linePart = 0;\r\n\r\n            for (; linePart < lineParts.size(); ++linePart) {\r\n              final String lastCommand = lineParts.get(linePart);\r\n\r\n              if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"let \")) {\r\n                lastResult = executeLet(lastCommand, db);\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"begin\")) {\r\n\r\n                if (txBegun)\r\n                  throw new OCommandSQLParsingException(\"Transaction already begun\");\r\n\r\n                if (db.getTransaction().isActive())\r\n                  // COMMIT ANY ACTIVE TX\r\n                  db.commit();\r\n\r\n                txBegun = true;\r\n                txBegunAtLine = line;\r\n                txBegunAtPart = linePart;\r\n\r\n                db.begin();\r\n\r\n                if (lastCommand.length() > \"begin \".length()) {\r\n                  String next = lastCommand.substring(\"begin \".length()).trim();\r\n                  if (OStringSerializerHelper.startsWithIgnoreCase(next, \"isolation \")) {\r\n                    next = next.substring(\"isolation \".length()).trim();\r\n                    db.getTransaction().setIsolationLevel(OTransaction.ISOLATION_LEVEL.valueOf(next.toUpperCase()));\r\n                  }\r\n                }\r\n\r\n              } else if (\"rollback\".equalsIgnoreCase(lastCommand)) {\r\n\r\n                if (!txBegun)\r\n                  throw new OCommandSQLParsingException(\"Transaction not begun\");\r\n\r\n                db.rollback();\r\n\r\n                txBegun = false;\r\n                txBegunAtLine = -1;\r\n                txBegunAtPart = -1;\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"commit\")) {\r\n                if (txBegunAtLine < 0)\r\n                  throw new OCommandSQLParsingException(\"Transaction not begun\");\r\n\r\n                if (retry == 1 && lastCommand.length() > \"commit \".length()) {\r\n                  // FIRST CYCLE: PARSE RETRY TIMES OVERWRITING DEFAULT = 1\r\n                  String next = lastCommand.substring(\"commit \".length()).trim();\r\n                  if (OStringSerializerHelper.startsWithIgnoreCase(next, \"retry \")) {\r\n                    next = next.substring(\"retry \".length()).trim();\r\n                    maxRetry = Integer.parseInt(next);\r\n                  }\r\n                }\r\n\r\n                db.commit();\r\n\r\n                txBegun = false;\r\n                txBegunAtLine = -1;\r\n                txBegunAtPart = -1;\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"sleep \")) {\r\n                executeSleep(lastCommand);\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"return \")) {\r\n                lastResult = executeReturn(lastCommand, lastResult);\r\n\r\n                // END OF SCRIPT\r\n                break;\r\n\r\n              } else if (lastCommand != null && lastCommand.length() > 0)\r\n                lastResult = executeCommand(lastCommand, db);\r\n            }\r\n          }\r\n        } catch (RuntimeException ex) {\r\n          if (db.getTransaction().isActive())\r\n            db.rollback();\r\n          throw ex;\r\n        }\r\n        // COMPLETED\r\n        break;\r\n\r\n      } catch (OTransactionException e) {\r\n        // THIS CASE IS ON UPSERT\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n        waitForNextRetry();\r\n\r\n      } catch (ORecordDuplicatedException e) {\r\n        // THIS CASE IS ON UPSERT\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n        waitForNextRetry();\r\n\r\n      } catch (ORecordNotFoundException e) {\r\n        // THIS CASE IS ON UPSERT\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n      } catch (ONeedRetryException e) {\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n        waitForNextRetry();\r\n      }\r\n    }\r\n\r\n    return lastResult;\r\n  }","id":74521,"modified_method":"protected Object executeSQLScript(final String iText, final ODatabaseDocument db) throws IOException {\r\n    Object lastResult = null;\r\n    int maxRetry = 1;\r\n\r\n    context.setVariable(\"transactionRetries\", 0);\r\n\r\n    for (int retry = 1; retry <= maxRetry; retry++) {\r\n      try {\r\n        try {\r\n          int txBegunAtLine = -1;\r\n          int txBegunAtPart = -1;\r\n          lastResult = null;\r\n\r\n          final BufferedReader reader = new BufferedReader(new StringReader(iText));\r\n\r\n          int line = 0;\r\n          int linePart = 0;\r\n          String lastLine;\r\n          boolean txBegun = false;\r\n\r\n          for (; line < txBegunAtLine; ++line)\r\n            // SKIP PREVIOUS COMMAND AND JUMP TO THE BEGIN IF ANY\r\n            reader.readLine();\r\n\r\n          for (; (lastLine = reader.readLine()) != null; ++line) {\r\n            lastLine = lastLine.trim();\r\n\r\n            final List<String> lineParts = OStringSerializerHelper.smartSplit(lastLine, ';', true);\r\n\r\n            if (line == txBegunAtLine)\r\n              // SKIP PREVIOUS COMMAND PART AND JUMP TO THE BEGIN IF ANY\r\n              linePart = txBegunAtPart;\r\n            else\r\n              linePart = 0;\r\n\r\n            for (; linePart < lineParts.size(); ++linePart) {\r\n              final String lastCommand = lineParts.get(linePart);\r\n\r\n              if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"let \")) {\r\n                lastResult = executeLet(lastCommand, db);\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"begin\")) {\r\n\r\n                if (txBegun)\r\n                  throw new OCommandSQLParsingException(\"Transaction already begun\");\r\n\r\n                if (db.getTransaction().isActive())\r\n                  // COMMIT ANY ACTIVE TX\r\n                  db.commit();\r\n\r\n                txBegun = true;\r\n                txBegunAtLine = line;\r\n                txBegunAtPart = linePart;\r\n\r\n                db.begin();\r\n\r\n                if (lastCommand.length() > \"begin \".length()) {\r\n                  String next = lastCommand.substring(\"begin \".length()).trim();\r\n                  if (OStringSerializerHelper.startsWithIgnoreCase(next, \"isolation \")) {\r\n                    next = next.substring(\"isolation \".length()).trim();\r\n                    db.getTransaction().setIsolationLevel(OTransaction.ISOLATION_LEVEL.valueOf(next.toUpperCase()));\r\n                  }\r\n                }\r\n\r\n              } else if (\"rollback\".equalsIgnoreCase(lastCommand)) {\r\n\r\n                if (!txBegun)\r\n                  throw new OCommandSQLParsingException(\"Transaction not begun\");\r\n\r\n                db.rollback();\r\n\r\n                txBegun = false;\r\n                txBegunAtLine = -1;\r\n                txBegunAtPart = -1;\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"commit\")) {\r\n                if (txBegunAtLine < 0)\r\n                  throw new OCommandSQLParsingException(\"Transaction not begun\");\r\n\r\n                if (retry == 1 && lastCommand.length() > \"commit \".length()) {\r\n                  // FIRST CYCLE: PARSE RETRY TIMES OVERWRITING DEFAULT = 1\r\n                  String next = lastCommand.substring(\"commit \".length()).trim();\r\n                  if (OStringSerializerHelper.startsWithIgnoreCase(next, \"retry \")) {\r\n                    next = next.substring(\"retry \".length()).trim();\r\n                    maxRetry = Integer.parseInt(next);\r\n                  }\r\n                }\r\n\r\n                db.commit();\r\n\r\n                txBegun = false;\r\n                txBegunAtLine = -1;\r\n                txBegunAtPart = -1;\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"sleep \")) {\r\n                executeSleep(lastCommand);\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"console.log \")) {\r\n                executeConsoleLog(lastCommand);\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"console.output \")) {\r\n                executeConsoleOutput(lastCommand);\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"console.error \")) {\r\n                executeConsoleError(lastCommand);\r\n\r\n              } else if (OStringSerializerHelper.startsWithIgnoreCase(lastCommand, \"return \")) {\r\n                lastResult = getValue(lastCommand, lastResult);\r\n\r\n                // END OF SCRIPT\r\n                break;\r\n\r\n              } else if (lastCommand != null && lastCommand.length() > 0)\r\n                lastResult = executeCommand(lastCommand, db);\r\n            }\r\n          }\r\n        } catch (RuntimeException ex) {\r\n          if (db.getTransaction().isActive())\r\n            db.rollback();\r\n          throw ex;\r\n        }\r\n        // COMPLETED\r\n        break;\r\n\r\n      } catch (OTransactionException e) {\r\n        // THIS CASE IS ON UPSERT\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n        waitForNextRetry();\r\n\r\n      } catch (ORecordDuplicatedException e) {\r\n        // THIS CASE IS ON UPSERT\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n        waitForNextRetry();\r\n\r\n      } catch (ORecordNotFoundException e) {\r\n        // THIS CASE IS ON UPSERT\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n      } catch (ONeedRetryException e) {\r\n        context.setVariable(\"retries\", retry);\r\n        getDatabase().getLocalCache().clear();\r\n        if (retry >= maxRetry)\r\n          throw e;\r\n\r\n        waitForNextRetry();\r\n      }\r\n    }\r\n\r\n    return lastResult;\r\n  }","commit_id":"b7e8aed415aea477c79839e08895b69e00142a39","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private Object executeReturn(String lastCommand, Object lastResult) {\r\n    final String variable = lastCommand.substring(\"return \".length()).trim();\r\n\r\n    if (variable.equalsIgnoreCase(\"NULL\"))\r\n      lastResult = null;\r\n    else if (variable.startsWith(\"$\"))\r\n      lastResult = getContext().getVariable(variable);\r\n    else if (variable.startsWith(\"[\") && variable.endsWith(\"]\")) {\r\n      // ARRAY - COLLECTION\r\n      final List<String> items = new ArrayList<String>();\r\n\r\n      OStringSerializerHelper.getCollection(variable, 0, items);\r\n      final List<Object> result = new ArrayList<Object>(items.size());\r\n\r\n      for (int i = 0; i < items.size(); ++i) {\r\n        String item = items.get(i);\r\n\r\n        Object res;\r\n        if (item.startsWith(\"$\"))\r\n          res = getContext().getVariable(item);\r\n        else\r\n          res = item;\r\n\r\n        if (OMultiValue.isMultiValue(res) && OMultiValue.getSize(res) == 1)\r\n          res = OMultiValue.getFirstValue(res);\r\n\r\n        result.add(res);\r\n      }\r\n      lastResult = result;\r\n    } else if (variable.startsWith(\"{\") && variable.endsWith(\"}\")) {\r\n      // MAP\r\n      final Map<String, String> map = OStringSerializerHelper.getMap(variable);\r\n      final Map<Object, Object> result = new HashMap<Object, Object>(map.size());\r\n\r\n      for (Map.Entry<String, String> entry : map.entrySet()) {\r\n        // KEY\r\n        String stringKey = entry.getKey();\r\n        if (stringKey == null)\r\n          continue;\r\n\r\n        stringKey = stringKey.trim();\r\n\r\n        Object key;\r\n        if (stringKey.startsWith(\"$\"))\r\n          key = getContext().getVariable(stringKey);\r\n        else\r\n          key = stringKey;\r\n\r\n        if (OMultiValue.isMultiValue(key) && OMultiValue.getSize(key) == 1)\r\n          key = OMultiValue.getFirstValue(key);\r\n\r\n        // VALUE\r\n        String stringValue = entry.getValue();\r\n        if (stringValue == null)\r\n          continue;\r\n\r\n        stringValue = stringValue.trim();\r\n\r\n        Object value;\r\n        if (stringValue.toString().startsWith(\"$\"))\r\n          value = getContext().getVariable(stringValue);\r\n        else\r\n          value = stringValue;\r\n\r\n        result.put(key, value);\r\n      }\r\n      lastResult = result;\r\n    } else\r\n      lastResult = variable;\r\n\r\n    // END OF THE SCRIPT\r\n    return lastResult;\r\n  }","id":74522,"modified_method":"private Object getValue(String lastCommand, Object lastResult) {\r\n    final String variable = lastCommand.substring(\"return \".length()).trim();\r\n\r\n    if (variable.equalsIgnoreCase(\"NULL\"))\r\n      lastResult = null;\r\n    else if (variable.startsWith(\"$\"))\r\n      lastResult = getContext().getVariable(variable);\r\n    else if (variable.startsWith(\"[\") && variable.endsWith(\"]\")) {\r\n      // ARRAY - COLLECTION\r\n      final List<String> items = new ArrayList<String>();\r\n\r\n      OStringSerializerHelper.getCollection(variable, 0, items);\r\n      final List<Object> result = new ArrayList<Object>(items.size());\r\n\r\n      for (int i = 0; i < items.size(); ++i) {\r\n        String item = items.get(i);\r\n\r\n        Object res;\r\n        if (item.startsWith(\"$\"))\r\n          res = getContext().getVariable(item);\r\n        else\r\n          res = item;\r\n\r\n        if (OMultiValue.isMultiValue(res) && OMultiValue.getSize(res) == 1)\r\n          res = OMultiValue.getFirstValue(res);\r\n\r\n        result.add(res);\r\n      }\r\n      lastResult = result;\r\n    } else if (variable.startsWith(\"{\") && variable.endsWith(\"}\")) {\r\n      // MAP\r\n      final Map<String, String> map = OStringSerializerHelper.getMap(variable);\r\n      final Map<Object, Object> result = new HashMap<Object, Object>(map.size());\r\n\r\n      for (Map.Entry<String, String> entry : map.entrySet()) {\r\n        // KEY\r\n        String stringKey = entry.getKey();\r\n        if (stringKey == null)\r\n          continue;\r\n\r\n        stringKey = stringKey.trim();\r\n\r\n        Object key;\r\n        if (stringKey.startsWith(\"$\"))\r\n          key = getContext().getVariable(stringKey);\r\n        else\r\n          key = stringKey;\r\n\r\n        if (OMultiValue.isMultiValue(key) && OMultiValue.getSize(key) == 1)\r\n          key = OMultiValue.getFirstValue(key);\r\n\r\n        // VALUE\r\n        String stringValue = entry.getValue();\r\n        if (stringValue == null)\r\n          continue;\r\n\r\n        stringValue = stringValue.trim();\r\n\r\n        Object value;\r\n        if (stringValue.toString().startsWith(\"$\"))\r\n          value = getContext().getVariable(stringValue);\r\n        else\r\n          value = stringValue;\r\n\r\n        result.put(key, value);\r\n      }\r\n      lastResult = result;\r\n    } else\r\n      lastResult = variable;\r\n\r\n    // END OF THE SCRIPT\r\n    return lastResult;\r\n  }","commit_id":"b7e8aed415aea477c79839e08895b69e00142a39","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Implements the core-execution. Creates the file-list for copy,\n   * and launches the Hadoop-job, to do the copy.\n   * @return Job handle\n   * @throws Exception, on failure.\n   */\n  public Job execute() throws Exception {\n    assert inputOptions != null;\n    assert getConf() != null;\n\n    Job job = null;\n    try {\n      synchronized(this) {\n        //Don't cleanup while we are setting up.\n        metaFolder = createMetaFolderPath();\n        jobFS = metaFolder.getFileSystem(getConf());\n\n        job = createJob();\n      }\n      createInputFileListing(job);\n\n      job.submit();\n      submitted = true;\n    } finally {\n      if (!submitted) {\n        cleanup();\n      }\n    }\n\n    String jobID = job.getJobID().toString();\n    job.getConfiguration().set(DistCpConstants.CONF_LABEL_DISTCP_JOB_ID, jobID);\n    \n    LOG.info(\"DistCp job-id: \" + jobID);\n    if (inputOptions.shouldBlock()) {\n      job.waitForCompletion(true);\n    }\n    return job;\n  }","id":74523,"modified_method":"/**\n   * Implements the core-execution. Creates the file-list for copy,\n   * and launches the Hadoop-job, to do the copy.\n   * @return Job handle\n   * @throws Exception, on failure.\n   */\n  public Job execute() throws Exception {\n    assert inputOptions != null;\n    assert getConf() != null;\n\n    Job job = null;\n    try {\n      synchronized(this) {\n        //Don't cleanup while we are setting up.\n        metaFolder = createMetaFolderPath();\n        jobFS = metaFolder.getFileSystem(getConf());\n\n        job = createJob();\n      }\n      createInputFileListing(job);\n\n      job.submit();\n      submitted = true;\n    } finally {\n      if (!submitted) {\n        cleanup();\n      }\n    }\n\n    String jobID = job.getJobID().toString();\n    job.getConfiguration().set(DistCpConstants.CONF_LABEL_DISTCP_JOB_ID, jobID);\n    \n    LOG.info(\"DistCp job-id: \" + jobID);\n    if (inputOptions.shouldBlock() && !job.waitForCompletion(true)) {\n      throw new IOException(\"DistCp failure: Job \" + jobID + \" has failed: \"\n          + job.getStatus().getFailureInfo());\n    }\n    return job;\n  }","commit_id":"723ef662a9aba08f6d164d3275337f233372f901","url":"https://github.com/apache/hadoop"},{"original_method":"private static boolean doCommandLine(final String[] args) {\n    // Process command-line args. TODO: Better cmd-line processing\n    // (but hopefully something not as painful as cli options).\n    if (args.length < 1) {\n      printUsage(null);\n      return false;\n    }\n    try {\n      for (int i = 0; i < args.length; i++) {\n        String cmd = args[i];\n        if (cmd.equals(\"-h\") || cmd.startsWith(\"--h\")) {\n          printUsage(null);\n          return false;\n        }\n        \n        final String startRowArgKey = \"--startrow=\";\n        if (cmd.startsWith(startRowArgKey)) {\n          startRow = cmd.substring(startRowArgKey.length());\n          continue;\n        }\n        \n        final String stopRowArgKey = \"--stoprow=\";\n        if (cmd.startsWith(stopRowArgKey)) {\n          stopRow = cmd.substring(stopRowArgKey.length());\n          continue;\n        }\n        \n        final String startTimeArgKey = \"--starttime=\";\n        if (cmd.startsWith(startTimeArgKey)) {\n          startTime = Long.parseLong(cmd.substring(startTimeArgKey.length()));\n          continue;\n        }\n\n        final String endTimeArgKey = \"--endtime=\";\n        if (cmd.startsWith(endTimeArgKey)) {\n          endTime = Long.parseLong(cmd.substring(endTimeArgKey.length()));\n          continue;\n        }\n\n        final String versionsArgKey = \"--versions=\";\n        if (cmd.startsWith(versionsArgKey)) {\n          versions = Integer.parseInt(cmd.substring(versionsArgKey.length()));\n          continue;\n        }\n\n        final String newNameArgKey = \"--new.name=\";\n        if (cmd.startsWith(newNameArgKey)) {\n          newTableName = cmd.substring(newNameArgKey.length());\n          continue;\n        }\n\n        final String peerAdrArgKey = \"--peer.adr=\";\n        if (cmd.startsWith(peerAdrArgKey)) {\n          peerAddress = cmd.substring(peerAdrArgKey.length());\n          continue;\n        }\n\n        final String familiesArgKey = \"--families=\";\n        if (cmd.startsWith(familiesArgKey)) {\n          families = cmd.substring(familiesArgKey.length());\n          continue;\n        }\n\n        if (cmd.startsWith(\"--all.cells\")) {\n          allCells = true;\n          continue;\n        }\n\n        if (i == args.length-1) {\n          tableName = cmd;\n        } else {\n          printUsage(\"Invalid argument '\" + cmd + \"'\" );\n          return false;\n        }\n      }\n      if (newTableName == null && peerAddress == null) {\n        printUsage(\"At least a new table name or a \" +\n            \"peer address must be specified\");\n        return false;\n      }\n      if ((endTime != 0) && (startTime > endTime)) {\n        printUsage(\"Invalid time range filter: starttime=\" + startTime + \" >  endtime=\" + endTime);\n        return false;\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      printUsage(\"Can't start because \" + e.getMessage());\n      return false;\n    }\n    return true;\n  }","id":74524,"modified_method":"private boolean doCommandLine(final String[] args) {\n    // Process command-line args. TODO: Better cmd-line processing\n    // (but hopefully something not as painful as cli options).\n    if (args.length < 1) {\n      printUsage(null);\n      return false;\n    }\n    try {\n      for (int i = 0; i < args.length; i++) {\n        String cmd = args[i];\n        if (cmd.equals(\"-h\") || cmd.startsWith(\"--h\")) {\n          printUsage(null);\n          return false;\n        }\n        \n        final String startRowArgKey = \"--startrow=\";\n        if (cmd.startsWith(startRowArgKey)) {\n          startRow = cmd.substring(startRowArgKey.length());\n          continue;\n        }\n        \n        final String stopRowArgKey = \"--stoprow=\";\n        if (cmd.startsWith(stopRowArgKey)) {\n          stopRow = cmd.substring(stopRowArgKey.length());\n          continue;\n        }\n        \n        final String startTimeArgKey = \"--starttime=\";\n        if (cmd.startsWith(startTimeArgKey)) {\n          startTime = Long.parseLong(cmd.substring(startTimeArgKey.length()));\n          continue;\n        }\n\n        final String endTimeArgKey = \"--endtime=\";\n        if (cmd.startsWith(endTimeArgKey)) {\n          endTime = Long.parseLong(cmd.substring(endTimeArgKey.length()));\n          continue;\n        }\n\n        final String versionsArgKey = \"--versions=\";\n        if (cmd.startsWith(versionsArgKey)) {\n          versions = Integer.parseInt(cmd.substring(versionsArgKey.length()));\n          continue;\n        }\n\n        final String newNameArgKey = \"--new.name=\";\n        if (cmd.startsWith(newNameArgKey)) {\n          dstTableName = cmd.substring(newNameArgKey.length());\n          continue;\n        }\n\n        final String peerAdrArgKey = \"--peer.adr=\";\n        if (cmd.startsWith(peerAdrArgKey)) {\n          peerAddress = cmd.substring(peerAdrArgKey.length());\n          continue;\n        }\n\n        final String familiesArgKey = \"--families=\";\n        if (cmd.startsWith(familiesArgKey)) {\n          families = cmd.substring(familiesArgKey.length());\n          continue;\n        }\n\n        if (cmd.startsWith(\"--all.cells\")) {\n          allCells = true;\n          continue;\n        }\n        \n        if (cmd.startsWith(\"--bulkload\")) {\n          bulkload = true;\n          continue;\n        }\n\n        if (i == args.length-1) {\n          tableName = cmd;\n        } else {\n          printUsage(\"Invalid argument '\" + cmd + \"'\" );\n          return false;\n        }\n      }\n      if (dstTableName == null && peerAddress == null) {\n        printUsage(\"At least a new table name or a \" +\n            \"peer address must be specified\");\n        return false;\n      }\n      if ((endTime != 0) && (startTime > endTime)) {\n        printUsage(\"Invalid time range filter: starttime=\" + startTime + \" >  endtime=\" + endTime);\n        return false;\n      }\n      \n      if (bulkload && peerAddress != null) {\n        printUsage(\"Remote bulkload is not supported!\");\n        return false;\n      }\n      \n      // set dstTableName if necessary\n      if (dstTableName == null) {\n        dstTableName = tableName;\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      printUsage(\"Can't start because \" + e.getMessage());\n      return false;\n    }\n    return true;\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Sets up the actual job.\n   *\n   * @param conf  The current configuration.\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  public static Job createSubmittableJob(Configuration conf, String[] args)\n  throws IOException {\n    if (!doCommandLine(args)) {\n      return null;\n    }\n    Job job = Job.getInstance(conf, conf.get(JOB_NAME_CONF_KEY, NAME + \"_\" + tableName));\n    job.setJarByClass(CopyTable.class);\n    Scan scan = new Scan();\n    scan.setCacheBlocks(false);\n    if (startTime != 0) {\n      scan.setTimeRange(startTime,\n          endTime == 0 ? HConstants.LATEST_TIMESTAMP : endTime);\n    }\n    if (allCells) {\n      scan.setRaw(true);\n    }\n    if (versions >= 0) {\n      scan.setMaxVersions(versions);\n    }\n    \n    if (startRow != null) {\n      scan.setStartRow(Bytes.toBytes(startRow));\n    }\n    \n    if (stopRow != null) {\n      scan.setStopRow(Bytes.toBytes(stopRow));\n    }\n    \n    if(families != null) {\n      String[] fams = families.split(\",\");\n      Map<String,String> cfRenameMap = new HashMap<String,String>();\n      for(String fam : fams) {\n        String sourceCf;\n        if(fam.contains(\":\")) { \n            // fam looks like \"sourceCfName:destCfName\"\n            String[] srcAndDest = fam.split(\":\", 2);\n            sourceCf = srcAndDest[0];\n            String destCf = srcAndDest[1];\n            cfRenameMap.put(sourceCf, destCf);\n        } else {\n            // fam is just \"sourceCf\"\n            sourceCf = fam; \n        }\n        scan.addFamily(Bytes.toBytes(sourceCf));\n      }\n      Import.configureCfRenaming(job.getConfiguration(), cfRenameMap);\n    }\n    TableMapReduceUtil.initTableMapperJob(tableName, scan,\n        Import.Importer.class, null, null, job);\n    TableMapReduceUtil.initTableReducerJob(\n        newTableName == null ? tableName : newTableName, null, job,\n        null, peerAddress, null, null);\n    job.setNumReduceTasks(0);\n    return job;\n  }","id":74525,"modified_method":"/**\n   * Sets up the actual job.\n   *\n   * @param args  The command line parameters.\n   * @return The newly created job.\n   * @throws IOException When setting up the job fails.\n   */\n  public Job createSubmittableJob(String[] args)\n  throws IOException {\n    if (!doCommandLine(args)) {\n      return null;\n    }\n    \n    Job job = Job.getInstance(getConf(), getConf().get(JOB_NAME_CONF_KEY, NAME + \"_\" + tableName));\n    job.setJarByClass(CopyTable.class);\n    Scan scan = new Scan();\n    scan.setCacheBlocks(false);\n    if (startTime != 0) {\n      scan.setTimeRange(startTime,\n          endTime == 0 ? HConstants.LATEST_TIMESTAMP : endTime);\n    }\n    if (allCells) {\n      scan.setRaw(true);\n    }\n    if (versions >= 0) {\n      scan.setMaxVersions(versions);\n    }\n    \n    if (startRow != null) {\n      scan.setStartRow(Bytes.toBytes(startRow));\n    }\n    \n    if (stopRow != null) {\n      scan.setStopRow(Bytes.toBytes(stopRow));\n    }\n    \n    if(families != null) {\n      String[] fams = families.split(\",\");\n      Map<String,String> cfRenameMap = new HashMap<String,String>();\n      for(String fam : fams) {\n        String sourceCf;\n        if(fam.contains(\":\")) { \n            // fam looks like \"sourceCfName:destCfName\"\n            String[] srcAndDest = fam.split(\":\", 2);\n            sourceCf = srcAndDest[0];\n            String destCf = srcAndDest[1];\n            cfRenameMap.put(sourceCf, destCf);\n        } else {\n            // fam is just \"sourceCf\"\n            sourceCf = fam; \n        }\n        scan.addFamily(Bytes.toBytes(sourceCf));\n      }\n      Import.configureCfRenaming(job.getConfiguration(), cfRenameMap);\n    }\n    job.setNumReduceTasks(0);\n    \n    if (bulkload) {\n      TableMapReduceUtil.initTableMapperJob(tableName, scan, Import.KeyValueImporter.class, null,\n        null, job);\n      \n      // We need to split the inputs by destination tables so that output of Map can be bulk-loaded.\n      TableInputFormat.configureSplitTable(job, TableName.valueOf(dstTableName));\n      \n      FileSystem fs = FileSystem.get(getConf());\n      Random rand = new Random();\n      Path root = new Path(fs.getWorkingDirectory(), \"copytable\");\n      fs.mkdirs(root);\n      while (true) {\n        bulkloadDir = new Path(root, \"\" + rand.nextLong());\n        if (!fs.exists(bulkloadDir)) {\n          break;\n        }\n      }\n      \n      System.out.println(\"HFiles will be stored at \" + this.bulkloadDir);\n      HFileOutputFormat2.setOutputPath(job, bulkloadDir);\n      try (Connection conn = ConnectionFactory.createConnection(getConf());\n          Table htable = conn.getTable(TableName.valueOf(dstTableName))) {\n        HFileOutputFormat2.configureIncrementalLoadMap(job, htable);\n      }\n    } else {\n      TableMapReduceUtil.initTableMapperJob(tableName, scan,\n        Import.Importer.class, null, null, job);\n      \n      TableMapReduceUtil.initTableReducerJob(dstTableName, null, job, null, peerAddress, null,\n        null);\n    }\n    \n    return job;\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"private static void printUsage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    System.err.println(\"Usage: CopyTable [general options] [--starttime=X] [--endtime=Y] \" +\n        \"[--new.name=NEW] [--peer.adr=ADR] <tablename>\");\n    System.err.println();\n    System.err.println(\"Options:\");\n    System.err.println(\" rs.class     hbase.regionserver.class of the peer cluster\");\n    System.err.println(\"              specify if different from current cluster\");\n    System.err.println(\" rs.impl      hbase.regionserver.impl of the peer cluster\");\n    System.err.println(\" startrow     the start row\");\n    System.err.println(\" stoprow      the stop row\");\n    System.err.println(\" starttime    beginning of the time range (unixtime in millis)\");\n    System.err.println(\"              without endtime means from starttime to forever\");\n    System.err.println(\" endtime      end of the time range.  Ignored if no starttime specified.\");\n    System.err.println(\" versions     number of cell versions to copy\");\n    System.err.println(\" new.name     new table's name\");\n    System.err.println(\" peer.adr     Address of the peer cluster given in the format\");\n    System.err.println(\"              hbase.zookeeer.quorum:hbase.zookeeper.client.port:zookeeper.znode.parent\");\n    System.err.println(\" families     comma-separated list of families to copy\");\n    System.err.println(\"              To copy from cf1 to cf2, give sourceCfName:destCfName. \");\n    System.err.println(\"              To keep the same name, just give \\\"cfName\\\"\");\n    System.err.println(\" all.cells    also copy delete markers and deleted cells\");\n    System.err.println();\n    System.err.println(\"Args:\");\n    System.err.println(\" tablename    Name of the table to copy\");\n    System.err.println();\n    System.err.println(\"Examples:\");\n    System.err.println(\" To copy 'TestTable' to a cluster that uses replication for a 1 hour window:\");\n    System.err.println(\" $ bin/hbase \" +\n        \"org.apache.hadoop.hbase.mapreduce.CopyTable --starttime=1265875194289 --endtime=1265878794289 \" +\n        \"--peer.adr=server1,server2,server3:2181:/hbase --families=myOldCf:myNewCf,cf2,cf3 TestTable \");\n    System.err.println(\"For performance consider the following general option:\\n\"\n        + \"  It is recommended that you set the following to >=100. A higher value uses more memory but\\n\"\n        + \"  decreases the round trip time to the server and may increase performance.\\n\"\n        + \"    -Dhbase.client.scanner.caching=100\\n\"\n        + \"  The following should always be set to false, to prevent writing data twice, which may produce \\n\"\n        + \"  inaccurate results.\\n\"\n        + \"    -Dmapreduce.map.speculative=false\");\n  }","id":74526,"modified_method":"private static void printUsage(final String errorMsg) {\n    if (errorMsg != null && errorMsg.length() > 0) {\n      System.err.println(\"ERROR: \" + errorMsg);\n    }\n    System.err.println(\"Usage: CopyTable [general options] [--starttime=X] [--endtime=Y] \" +\n        \"[--new.name=NEW] [--peer.adr=ADR] <tablename>\");\n    System.err.println();\n    System.err.println(\"Options:\");\n    System.err.println(\" rs.class     hbase.regionserver.class of the peer cluster\");\n    System.err.println(\"              specify if different from current cluster\");\n    System.err.println(\" rs.impl      hbase.regionserver.impl of the peer cluster\");\n    System.err.println(\" startrow     the start row\");\n    System.err.println(\" stoprow      the stop row\");\n    System.err.println(\" starttime    beginning of the time range (unixtime in millis)\");\n    System.err.println(\"              without endtime means from starttime to forever\");\n    System.err.println(\" endtime      end of the time range.  Ignored if no starttime specified.\");\n    System.err.println(\" versions     number of cell versions to copy\");\n    System.err.println(\" new.name     new table's name\");\n    System.err.println(\" peer.adr     Address of the peer cluster given in the format\");\n    System.err.println(\"              hbase.zookeeer.quorum:hbase.zookeeper.client.port:zookeeper.znode.parent\");\n    System.err.println(\" families     comma-separated list of families to copy\");\n    System.err.println(\"              To copy from cf1 to cf2, give sourceCfName:destCfName. \");\n    System.err.println(\"              To keep the same name, just give \\\"cfName\\\"\");\n    System.err.println(\" all.cells    also copy delete markers and deleted cells\");\n    System.err.println(\" bulkload     Write input into HFiles and bulk load to the destination \"\n        + \"table\");\n    System.err.println();\n    System.err.println(\"Args:\");\n    System.err.println(\" tablename    Name of the table to copy\");\n    System.err.println();\n    System.err.println(\"Examples:\");\n    System.err.println(\" To copy 'TestTable' to a cluster that uses replication for a 1 hour window:\");\n    System.err.println(\" $ bin/hbase \" +\n        \"org.apache.hadoop.hbase.mapreduce.CopyTable --starttime=1265875194289 --endtime=1265878794289 \" +\n        \"--peer.adr=server1,server2,server3:2181:/hbase --families=myOldCf:myNewCf,cf2,cf3 TestTable \");\n    System.err.println(\"For performance consider the following general option:\\n\"\n        + \"  It is recommended that you set the following to >=100. A higher value uses more memory but\\n\"\n        + \"  decreases the round trip time to the server and may increase performance.\\n\"\n        + \"    -Dhbase.client.scanner.caching=100\\n\"\n        + \"  The following should always be set to false, to prevent writing data twice, which may produce \\n\"\n        + \"  inaccurate results.\\n\"\n        + \"    -Dmapreduce.map.speculative=false\");\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n  public int run(String[] args) throws Exception {\n    String[] otherArgs = new GenericOptionsParser(getConf(), args).getRemainingArgs();\n    Job job = createSubmittableJob(getConf(), otherArgs);\n    if (job == null) return 1;\n    return job.waitForCompletion(true) ? 0 : 1;\n  }","id":74527,"modified_method":"@Override\n  public int run(String[] args) throws Exception {\n    String[] otherArgs = new GenericOptionsParser(getConf(), args).getRemainingArgs();\n    Job job = createSubmittableJob(otherArgs);\n    if (job == null) return 1;\n    if (!job.waitForCompletion(true)) {\n      LOG.info(\"Map-reduce job failed!\");\n      if (bulkload) {\n        LOG.info(\"Files are not bulkloaded!\");\n      }\n      return 1;\n    }\n    int code = 0;\n    if (bulkload) {\n      code = new LoadIncrementalHFiles(this.getConf()).run(new String[]{this.bulkloadDir.toString(),\n          this.dstTableName});\n      if (code == 0) {\n        // bulkloadDir is deleted only LoadIncrementalHFiles was successful so that one can rerun\n        // LoadIncrementalHFiles.\n        FileSystem fs = FileSystem.get(this.getConf());\n        if (!fs.delete(this.bulkloadDir, true)) {\n          LOG.error(\"Deleting folder \" + bulkloadDir + \" failed!\");\n          code = 1;\n        }\n      }\n    }\n    return code;\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Calculates the splits that will serve as input for the map tasks. The\n   * number of splits matches the number of regions in a table.\n   *\n   * @param context  The current job context.\n   * @return The list of input splits.\n   * @throws IOException When creating the list of splits fails.\n   * @see org.apache.hadoop.mapreduce.InputFormat#getSplits(\n   *   org.apache.hadoop.mapreduce.JobContext)\n   */\n  @Override\n  public List<InputSplit> getSplits(JobContext context) throws IOException {\n    if (table == null) {\n      throw new IOException(\"No table was provided.\");\n    }\n\n    RegionSizeCalculator sizeCalculator = new RegionSizeCalculator((HTable) table);\n\n    Pair<byte[][], byte[][]> keys = regionLocator.getStartEndKeys();\n    if (keys == null || keys.getFirst() == null ||\n        keys.getFirst().length == 0) {\n      HRegionLocation regLoc = regionLocator.getRegionLocation(HConstants.EMPTY_BYTE_ARRAY, false);\n      if (null == regLoc) {\n        throw new IOException(\"Expecting at least one region.\");\n      }\n      List<InputSplit> splits = new ArrayList<InputSplit>(1);\n      long regionSize = sizeCalculator.getRegionSize(regLoc.getRegionInfo().getRegionName());\n      TableSplit split = new TableSplit(table.getName(),\n          HConstants.EMPTY_BYTE_ARRAY, HConstants.EMPTY_BYTE_ARRAY, regLoc\n              .getHostnamePort().split(Addressing.HOSTNAME_PORT_SEPARATOR)[0], regionSize);\n      splits.add(split);\n      return splits;\n    }\n    List<InputSplit> splits = new ArrayList<InputSplit>(keys.getFirst().length);\n    for (int i = 0; i < keys.getFirst().length; i++) {\n      if ( !includeRegionInSplit(keys.getFirst()[i], keys.getSecond()[i])) {\n        continue;\n      }\n      HRegionLocation location = regionLocator.getRegionLocation(keys.getFirst()[i], false);\n      // The below InetSocketAddress creation does a name resolution.\n      InetSocketAddress isa = new InetSocketAddress(location.getHostname(), location.getPort());\n      if (isa.isUnresolved()) {\n        LOG.warn(\"Failed resolve \" + isa);\n      }\n      InetAddress regionAddress = isa.getAddress();\n      String regionLocation;\n      try {\n        regionLocation = reverseDNS(regionAddress);\n      } catch (NamingException e) {\n        LOG.warn(\"Cannot resolve the host name for \" + regionAddress + \" because of \" + e);\n        regionLocation = location.getHostname();\n      }\n\n      byte[] startRow = scan.getStartRow();\n      byte[] stopRow = scan.getStopRow();\n      // determine if the given start an stop key fall into the region\n      if ((startRow.length == 0 || keys.getSecond()[i].length == 0 ||\n          Bytes.compareTo(startRow, keys.getSecond()[i]) < 0) &&\n          (stopRow.length == 0 ||\n           Bytes.compareTo(stopRow, keys.getFirst()[i]) > 0)) {\n        byte[] splitStart = startRow.length == 0 ||\n          Bytes.compareTo(keys.getFirst()[i], startRow) >= 0 ?\n            keys.getFirst()[i] : startRow;\n        byte[] splitStop = (stopRow.length == 0 ||\n          Bytes.compareTo(keys.getSecond()[i], stopRow) <= 0) &&\n          keys.getSecond()[i].length > 0 ?\n            keys.getSecond()[i] : stopRow;\n\n        byte[] regionName = location.getRegionInfo().getRegionName();\n        long regionSize = sizeCalculator.getRegionSize(regionName);\n        TableSplit split = new TableSplit(table.getName(),\n          splitStart, splitStop, regionLocation, regionSize);\n        splits.add(split);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"getSplits: split -> \" + i + \" -> \" + split);\n        }\n      }\n    }\n    return splits;\n  }","id":74528,"modified_method":"/**\n   * Calculates the splits that will serve as input for the map tasks. The\n   * number of splits matches the number of regions in a table.\n   *\n   * @param context  The current job context.\n   * @return The list of input splits.\n   * @throws IOException When creating the list of splits fails.\n   * @see org.apache.hadoop.mapreduce.InputFormat#getSplits(\n   *   org.apache.hadoop.mapreduce.JobContext)\n   */\n  @Override\n  public List<InputSplit> getSplits(JobContext context) throws IOException {\n    if (table == null) {\n      throw new IOException(\"No table was provided.\");\n    }\n\n    RegionSizeCalculator sizeCalculator = new RegionSizeCalculator((HTable) table);\n    \n    Pair<byte[][], byte[][]> keys = getStartEndKeys();\n    if (keys == null || keys.getFirst() == null ||\n        keys.getFirst().length == 0) {\n      HRegionLocation regLoc = regionLocator.getRegionLocation(HConstants.EMPTY_BYTE_ARRAY, false);\n      if (null == regLoc) {\n        throw new IOException(\"Expecting at least one region.\");\n      }\n      List<InputSplit> splits = new ArrayList<InputSplit>(1);\n      long regionSize = sizeCalculator.getRegionSize(regLoc.getRegionInfo().getRegionName());\n      TableSplit split = new TableSplit(table.getName(),\n          HConstants.EMPTY_BYTE_ARRAY, HConstants.EMPTY_BYTE_ARRAY, regLoc\n              .getHostnamePort().split(Addressing.HOSTNAME_PORT_SEPARATOR)[0], regionSize);\n      splits.add(split);\n      return splits;\n    }\n    List<InputSplit> splits = new ArrayList<InputSplit>(keys.getFirst().length);\n    for (int i = 0; i < keys.getFirst().length; i++) {\n      if ( !includeRegionInSplit(keys.getFirst()[i], keys.getSecond()[i])) {\n        continue;\n      }\n      HRegionLocation location = regionLocator.getRegionLocation(keys.getFirst()[i], false);\n      // The below InetSocketAddress creation does a name resolution.\n      InetSocketAddress isa = new InetSocketAddress(location.getHostname(), location.getPort());\n      if (isa.isUnresolved()) {\n        LOG.warn(\"Failed resolve \" + isa);\n      }\n      InetAddress regionAddress = isa.getAddress();\n      String regionLocation;\n      try {\n        regionLocation = reverseDNS(regionAddress);\n      } catch (NamingException e) {\n        LOG.warn(\"Cannot resolve the host name for \" + regionAddress + \" because of \" + e);\n        regionLocation = location.getHostname();\n      }\n\n      byte[] startRow = scan.getStartRow();\n      byte[] stopRow = scan.getStopRow();\n      // determine if the given start an stop key fall into the region\n      if ((startRow.length == 0 || keys.getSecond()[i].length == 0 ||\n          Bytes.compareTo(startRow, keys.getSecond()[i]) < 0) &&\n          (stopRow.length == 0 ||\n           Bytes.compareTo(stopRow, keys.getFirst()[i]) > 0)) {\n        byte[] splitStart = startRow.length == 0 ||\n          Bytes.compareTo(keys.getFirst()[i], startRow) >= 0 ?\n            keys.getFirst()[i] : startRow;\n        byte[] splitStop = (stopRow.length == 0 ||\n          Bytes.compareTo(keys.getSecond()[i], stopRow) <= 0) &&\n          keys.getSecond()[i].length > 0 ?\n            keys.getSecond()[i] : stopRow;\n\n        byte[] regionName = location.getRegionInfo().getRegionName();\n        long regionSize = sizeCalculator.getRegionSize(regionName);\n        TableSplit split = new TableSplit(table.getName(),\n          splitStart, splitStop, regionLocation, regionSize);\n        splits.add(split);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"getSplits: split -> \" + i + \" -> \" + split);\n        }\n      }\n    }\n    return splits;\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Test copy of table from sourceTable to targetTable all rows from family a\n   */\n  @Test\n  public void testRenameFamily() throws Exception {\n    String sourceTable = \"sourceTable\";\n    String targetTable = \"targetTable\";\n\n    byte[][] families = { FAMILY_A, FAMILY_B };\n\n    Table t = TEST_UTIL.createTable(Bytes.toBytes(sourceTable), families);\n    Table t2 = TEST_UTIL.createTable(Bytes.toBytes(targetTable), families);\n    Put p = new Put(ROW1);\n    p.add(FAMILY_A, QUALIFIER,  Bytes.toBytes(\"Data11\"));\n    p.add(FAMILY_B, QUALIFIER,  Bytes.toBytes(\"Data12\"));\n    p.add(FAMILY_A, QUALIFIER,  Bytes.toBytes(\"Data13\"));\n    t.put(p);\n    p = new Put(ROW2);\n    p.add(FAMILY_B, QUALIFIER, Bytes.toBytes(\"Dat21\"));\n    p.add(FAMILY_A, QUALIFIER, Bytes.toBytes(\"Data22\"));\n    p.add(FAMILY_B, QUALIFIER, Bytes.toBytes(\"Data23\"));\n    t.put(p);\n\n    long currentTime = System.currentTimeMillis();\n    String[] args = new String[] { \"--new.name=\" + targetTable, \"--families=a:b\", \"--all.cells\",\n        \"--starttime=\" + (currentTime - 100000), \"--endtime=\" + (currentTime + 100000),\n        \"--versions=1\", sourceTable };\n    assertNull(t2.get(new Get(ROW1)).getRow());\n    clean();\n\n    assertTrue(runCopy(args));\n\n    assertNotNull(t2.get(new Get(ROW1)).getRow());\n    Result res = t2.get(new Get(ROW1));\n    byte[] b1 = res.getValue(FAMILY_B, QUALIFIER);\n    assertEquals(\"Data13\", new String(b1));\n    assertNotNull(t2.get(new Get(ROW2)).getRow());\n    res = t2.get(new Get(ROW2));\n    b1 = res.getValue(FAMILY_A, QUALIFIER);\n    // Data from the family of B is not copied\n    assertNull(b1);\n\n  }","id":74529,"modified_method":"/**\n   * Test copy of table from sourceTable to targetTable all rows from family a\n   */\n  @Test\n  public void testRenameFamily() throws Exception {\n    String sourceTable = \"sourceTable\";\n    String targetTable = \"targetTable\";\n\n    byte[][] families = { FAMILY_A, FAMILY_B };\n\n    Table t = TEST_UTIL.createTable(Bytes.toBytes(sourceTable), families);\n    Table t2 = TEST_UTIL.createTable(Bytes.toBytes(targetTable), families);\n    Put p = new Put(ROW1);\n    p.add(FAMILY_A, QUALIFIER,  Bytes.toBytes(\"Data11\"));\n    p.add(FAMILY_B, QUALIFIER,  Bytes.toBytes(\"Data12\"));\n    p.add(FAMILY_A, QUALIFIER,  Bytes.toBytes(\"Data13\"));\n    t.put(p);\n    p = new Put(ROW2);\n    p.add(FAMILY_B, QUALIFIER, Bytes.toBytes(\"Dat21\"));\n    p.add(FAMILY_A, QUALIFIER, Bytes.toBytes(\"Data22\"));\n    p.add(FAMILY_B, QUALIFIER, Bytes.toBytes(\"Data23\"));\n    t.put(p);\n\n    long currentTime = System.currentTimeMillis();\n    String[] args = new String[] { \"--new.name=\" + targetTable, \"--families=a:b\", \"--all.cells\",\n        \"--starttime=\" + (currentTime - 100000), \"--endtime=\" + (currentTime + 100000),\n        \"--versions=1\", sourceTable };\n    assertNull(t2.get(new Get(ROW1)).getRow());\n\n    assertTrue(runCopy(args));\n\n    assertNotNull(t2.get(new Get(ROW1)).getRow());\n    Result res = t2.get(new Get(ROW1));\n    byte[] b1 = res.getValue(FAMILY_B, QUALIFIER);\n    assertEquals(\"Data13\", new String(b1));\n    assertNotNull(t2.get(new Get(ROW2)).getRow());\n    res = t2.get(new Get(ROW2));\n    b1 = res.getValue(FAMILY_A, QUALIFIER);\n    // Data from the family of B is not copied\n    assertNull(b1);\n\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"@BeforeClass\n  public static void beforeClass() throws Exception {\n    cluster = TEST_UTIL.startMiniCluster(3);\n    TEST_UTIL.startMiniMapReduceCluster();\n  }","id":74530,"modified_method":"@BeforeClass\n  public static void beforeClass() throws Exception {\n    TEST_UTIL.startMiniCluster(3);\n    TEST_UTIL.startMiniMapReduceCluster();\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Simple end-to-end test\n   * @throws Exception\n   */\n  @Test\n  public void testCopyTable() throws Exception {\n    final TableName TABLENAME1 = TableName.valueOf(\"testCopyTable1\");\n    final TableName TABLENAME2 = TableName.valueOf(\"testCopyTable2\");\n    final byte[] FAMILY = Bytes.toBytes(\"family\");\n    final byte[] COLUMN1 = Bytes.toBytes(\"c1\");\n\n    Table t1 = TEST_UTIL.createTable(TABLENAME1, FAMILY);\n    Table t2 = TEST_UTIL.createTable(TABLENAME2, FAMILY);\n\n    // put rows into the first table\n    for (int i = 0; i < 10; i++) {\n      Put p = new Put(Bytes.toBytes(\"row\" + i));\n      p.add(FAMILY, COLUMN1, COLUMN1);\n      t1.put(p);\n    }\n\n    CopyTable copy = new CopyTable(TEST_UTIL.getConfiguration());\n\n    assertEquals(\n      0,\n      copy.run(new String[] { \"--new.name=\" + TABLENAME2.getNameAsString(),\n          TABLENAME1.getNameAsString() }));\n\n    // verify the data was copied into table 2\n    for (int i = 0; i < 10; i++) {\n      Get g = new Get(Bytes.toBytes(\"row\" + i));\n      Result r = t2.get(g);\n      assertEquals(1, r.size());\n      assertTrue(CellUtil.matchingQualifier(r.rawCells()[0], COLUMN1));\n    }\n    \n    t1.close();\n    t2.close();\n    TEST_UTIL.deleteTable(TABLENAME1);\n    TEST_UTIL.deleteTable(TABLENAME2);\n  }","id":74531,"modified_method":"/**\n   * Simple end-to-end test\n   * @throws Exception\n   */\n  @Test\n  public void testCopyTable() throws Exception {\n    doCopyTableTest(false);\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"private boolean runCopy(String[] args) throws IOException, InterruptedException,\n      ClassNotFoundException {\n    GenericOptionsParser opts = new GenericOptionsParser(\n        new Configuration(TEST_UTIL.getConfiguration()), args);\n    Configuration configuration = opts.getConfiguration();\n    args = opts.getRemainingArgs();\n    clean();\n    Job job = CopyTable.createSubmittableJob(configuration, args);\n    job.waitForCompletion(false);\n    return job.isSuccessful();\n  }","id":74532,"modified_method":"private boolean runCopy(String[] args) throws IOException, InterruptedException,\n      ClassNotFoundException {\n    GenericOptionsParser opts = new GenericOptionsParser(\n        new Configuration(TEST_UTIL.getConfiguration()), args);\n    Configuration configuration = opts.getConfiguration();\n    args = opts.getRemainingArgs();\n    Job job = new CopyTable(configuration).createSubmittableJob(args);\n    job.waitForCompletion(false);\n    return job.isSuccessful();\n  }","commit_id":"e1b69bd548bf67913ba58ef45f8bd85e743e12ce","url":"https://github.com/apache/hbase"},{"original_method":"private void copyData(final Context context,\n        final Path inputPath, final FSDataInputStream in,\n        final Path outputPath, final FSDataOutputStream out,\n        final long inputFileSize)\n        throws IOException {\n      final String statusMessage = \"copied %s/\" + StringUtils.humanReadableInt(inputFileSize) +\n                                   \" (%.3f%%)\";\n\n      try {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        long totalBytesWritten = 0;\n        int reportBytes = 0;\n        int bytesRead;\n\n        while ((bytesRead = in.read(buffer)) > 0) {\n          out.write(buffer, 0, bytesRead);\n          totalBytesWritten += bytesRead;\n          reportBytes += bytesRead;\n\n          if (reportBytes >= REPORT_SIZE) {\n            context.getCounter(Counter.BYTES_COPIED).increment(reportBytes);\n            context.setStatus(String.format(statusMessage,\n                              StringUtils.humanReadableInt(totalBytesWritten),\n                              totalBytesWritten/(float)inputFileSize) +\n                              \" from \" + inputPath + \" to \" + outputPath);\n            reportBytes = 0;\n          }\n        }\n\n        context.getCounter(Counter.BYTES_COPIED).increment(reportBytes);\n        context.setStatus(String.format(statusMessage,\n                          StringUtils.humanReadableInt(totalBytesWritten),\n                          totalBytesWritten/(float)inputFileSize) +\n                          \" from \" + inputPath + \" to \" + outputPath);\n\n        // Verify that the written size match\n        if (totalBytesWritten != inputFileSize) {\n          String msg = \"number of bytes copied not matching copied=\" + totalBytesWritten +\n                       \" expected=\" + inputFileSize + \" for file=\" + inputPath;\n          throw new IOException(msg);\n        }\n      } catch (IOException e) {\n        LOG.error(\"Error copying \" + inputPath + \" to \" + outputPath, e);\n        context.getCounter(Counter.COPY_FAILED).increment(1);\n        throw e;\n      }\n    }","id":74533,"modified_method":"private void copyData(final Context context,\n        final Path inputPath, final FSDataInputStream in,\n        final Path outputPath, final FSDataOutputStream out,\n        final long inputFileSize)\n        throws IOException {\n      final String statusMessage = \"copied %s/\" + StringUtils.humanReadableInt(inputFileSize) +\n                                   \" (%.1f%%)\";\n\n      try {\n        byte[] buffer = new byte[bufferSize];\n        long totalBytesWritten = 0;\n        int reportBytes = 0;\n        int bytesRead;\n\n        long stime = System.currentTimeMillis();\n        while ((bytesRead = in.read(buffer)) > 0) {\n          out.write(buffer, 0, bytesRead);\n          totalBytesWritten += bytesRead;\n          reportBytes += bytesRead;\n\n          if (reportBytes >= REPORT_SIZE) {\n            context.getCounter(Counter.BYTES_COPIED).increment(reportBytes);\n            context.setStatus(String.format(statusMessage,\n                              StringUtils.humanReadableInt(totalBytesWritten),\n                              (totalBytesWritten/(float)inputFileSize) * 100.0f) +\n                              \" from \" + inputPath + \" to \" + outputPath);\n            reportBytes = 0;\n          }\n        }\n        long etime = System.currentTimeMillis();\n\n        context.getCounter(Counter.BYTES_COPIED).increment(reportBytes);\n        context.setStatus(String.format(statusMessage,\n                          StringUtils.humanReadableInt(totalBytesWritten),\n                          (totalBytesWritten/(float)inputFileSize) * 100.0f) +\n                          \" from \" + inputPath + \" to \" + outputPath);\n\n        // Verify that the written size match\n        if (totalBytesWritten != inputFileSize) {\n          String msg = \"number of bytes copied not matching copied=\" + totalBytesWritten +\n                       \" expected=\" + inputFileSize + \" for file=\" + inputPath;\n          throw new IOException(msg);\n        }\n\n        LOG.info(\"copy completed for input=\" + inputPath + \" output=\" + outputPath);\n        LOG.info(\"size=\" + totalBytesWritten +\n            \" (\" + StringUtils.humanReadableInt(totalBytesWritten) + \")\" +\n            \" time=\" + StringUtils.formatTimeDiff(etime, stime) +\n            String.format(\" %.3fM/sec\", (totalBytesWritten / ((etime - stime)/1000.0))/1048576.0));\n        context.getCounter(Counter.FILES_COPIED).increment(1);\n      } catch (IOException e) {\n        LOG.error(\"Error copying \" + inputPath + \" to \" + outputPath, e);\n        context.getCounter(Counter.COPY_FAILED).increment(1);\n        throw e;\n      }\n    }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"private FileStatus getFileStatus(final FileSystem fs, final Path path) {\n      try {\n        if (HFileLink.isHFileLink(path) || StoreFileInfo.isReference(path)) {\n          HFileLink link = new HFileLink(inputRoot, inputArchive, path);\n          return link.getFileStatus(fs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).getFileStatus(fs);\n        }\n        return fs.getFileStatus(path);\n      } catch (IOException e) {\n        LOG.warn(\"Unable to get the status for file=\" + path);\n        return null;\n      }\n    }","id":74534,"modified_method":"private FileStatus getSourceFileStatus(Context context, final Path path) throws IOException {\n      try {\n        if (HFileLink.isHFileLink(path) || StoreFileInfo.isReference(path)) {\n          HFileLink link = new HFileLink(inputRoot, inputArchive, path);\n          return link.getFileStatus(inputFs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).getFileStatus(inputFs);\n        }\n        return inputFs.getFileStatus(path);\n      } catch (FileNotFoundException e) {\n        context.getCounter(Counter.MISSING_FILES).increment(1);\n        LOG.error(\"Unable to get the status for source file=\" + path, e);\n        throw e;\n      } catch (IOException e) {\n        LOG.error(\"Unable to get the status for source file=\" + path, e);\n        throw e;\n      }\n    }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"private void copyFile(final Context context, final Path inputPath, final Path outputPath)\n        throws IOException {\n      injectTestFailure(context, inputPath);\n\n      FSDataInputStream in = openSourceFile(inputPath);\n      if (in == null) {\n        context.getCounter(Counter.MISSING_FILES).increment(1);\n        throw new FileNotFoundException(inputPath.toString());\n      }\n\n      try {\n        // Verify if the input file exists\n        FileStatus inputStat = getFileStatus(inputFs, inputPath);\n        if (inputStat == null) {\n          context.getCounter(Counter.MISSING_FILES).increment(1);\n          throw new FileNotFoundException(inputPath.toString());\n        }\n\n        // Verify if the output file exists and is the same that we want to copy\n        if (outputFs.exists(outputPath)) {\n          FileStatus outputStat = outputFs.getFileStatus(outputPath);\n          if (sameFile(inputStat, outputStat)) {\n            LOG.info(\"Skip copy \" + inputPath + \" to \" + outputPath + \", same file.\");\n            return;\n          }\n        }\n\n        context.getCounter(Counter.BYTES_EXPECTED).increment(inputStat.getLen());\n\n        // Ensure that the output folder is there and copy the file\n        outputFs.mkdirs(outputPath.getParent());\n        FSDataOutputStream out = outputFs.create(outputPath, true);\n        try {\n          copyData(context, inputPath, in, outputPath, out, inputStat.getLen());\n        } finally {\n          out.close();\n        }\n\n        // Preserve attributes\n        preserveAttributes(outputPath, inputStat);\n      } finally {\n        in.close();\n      }\n    }","id":74535,"modified_method":"private void copyFile(final Context context, final Path inputPath, final Path outputPath)\n        throws IOException {\n      injectTestFailure(context, inputPath);\n\n      // Get the file information\n      FileStatus inputStat = getSourceFileStatus(context, inputPath);\n\n      // Verify if the output file exists and is the same that we want to copy\n      if (outputFs.exists(outputPath)) {\n        FileStatus outputStat = outputFs.getFileStatus(outputPath);\n        if (outputStat != null && sameFile(inputStat, outputStat)) {\n          LOG.info(\"Skip copy \" + inputPath + \" to \" + outputPath + \", same file.\");\n          return;\n        }\n      }\n\n      FSDataInputStream in = openSourceFile(context, inputPath);\n      try {\n        context.getCounter(Counter.BYTES_EXPECTED).increment(inputStat.getLen());\n\n        // Ensure that the output folder is there and copy the file\n        outputFs.mkdirs(outputPath.getParent());\n        FSDataOutputStream out = outputFs.create(outputPath, true);\n        try {\n          copyData(context, inputPath, in, outputPath, out, inputStat.getLen());\n        } finally {\n          out.close();\n        }\n\n        // Try to Preserve attributes\n        if (!preserveAttributes(outputPath, inputStat)) {\n          LOG.warn(\"You may have to run manually chown on: \" + outputPath);\n        }\n      } finally {\n        in.close();\n      }\n    }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Execute the export snapshot by copying the snapshot metadata, hfiles and hlogs.\n   * @return 0 on success, and != 0 upon failure.\n   */\n  @Override\n  public int run(String[] args) throws Exception {\n    boolean verifyChecksum = true;\n    String snapshotName = null;\n    boolean overwrite = false;\n    String filesGroup = null;\n    String filesUser = null;\n    Path outputRoot = null;\n    int filesMode = 0;\n    int mappers = getConf().getInt(\"mapreduce.job.maps\", 1);\n\n    // Process command line args\n    for (int i = 0; i < args.length; i++) {\n      String cmd = args[i];\n      try {\n        if (cmd.equals(\"-snapshot\")) {\n          snapshotName = args[++i];\n        } else if (cmd.equals(\"-copy-to\")) {\n          outputRoot = new Path(args[++i]);\n        } else if (cmd.equals(\"-no-checksum-verify\")) {\n          verifyChecksum = false;\n        } else if (cmd.equals(\"-mappers\")) {\n          mappers = Integer.parseInt(args[++i]);\n        } else if (cmd.equals(\"-chuser\")) {\n          filesUser = args[++i];\n        } else if (cmd.equals(\"-chgroup\")) {\n          filesGroup = args[++i];\n        } else if (cmd.equals(\"-chmod\")) {\n          filesMode = Integer.parseInt(args[++i], 8);\n        } else if (cmd.equals(\"-overwrite\")) {\n          overwrite = true;\n        } else if (cmd.equals(\"-h\") || cmd.equals(\"--help\")) {\n          printUsageAndExit();\n        } else {\n          System.err.println(\"UNEXPECTED: \" + cmd);\n          printUsageAndExit();\n        }\n      } catch (Exception e) {\n        printUsageAndExit();\n      }\n    }\n\n    // Check user options\n    if (snapshotName == null) {\n      System.err.println(\"Snapshot name not provided.\");\n      printUsageAndExit();\n    }\n\n    if (outputRoot == null) {\n      System.err.println(\"Destination file-system not provided.\");\n      printUsageAndExit();\n    }\n\n    Configuration conf = getConf();\n    Path inputRoot = FSUtils.getRootDir(conf);\n    FileSystem inputFs = FileSystem.get(conf);\n    FileSystem outputFs = FileSystem.get(outputRoot.toUri(), conf);\n\n    Path snapshotDir = SnapshotDescriptionUtils.getCompletedSnapshotDir(snapshotName, inputRoot);\n    Path snapshotTmpDir = SnapshotDescriptionUtils.getWorkingSnapshotDir(snapshotName, outputRoot);\n    Path outputSnapshotDir = SnapshotDescriptionUtils.getCompletedSnapshotDir(snapshotName, outputRoot);\n\n    // Check if the snapshot already exists\n    if (outputFs.exists(outputSnapshotDir)) {\n      if (overwrite) {\n        if (!outputFs.delete(outputSnapshotDir, true)) {\n          System.err.println(\"Unable to remove existing snapshot directory: \" + outputSnapshotDir);\n          return 1;\n        }\n      } else {\n        System.err.println(\"The snapshot '\" + snapshotName +\n          \"' already exists in the destination: \" + outputSnapshotDir);\n        return 1;\n      }\n    }\n\n    // Check if the snapshot already in-progress\n    if (!overwrite && outputFs.exists(snapshotTmpDir)) {\n      System.err.println(\"A snapshot with the same name '\" + snapshotName + \"' may be in-progress\");\n      System.err.println(\"Please check \" + snapshotTmpDir + \". If the snapshot has completed, \");\n      System.err.println(\"consider removing \" + snapshotTmpDir + \" before retrying export\");\n      return 1;\n    }\n\n    // Step 0 - Extract snapshot files to copy\n    final List<Pair<Path, Long>> files = getSnapshotFiles(inputFs, snapshotDir);\n\n    // Step 1 - Copy fs1:/.snapshot/<snapshot> to  fs2:/.snapshot/.tmp/<snapshot>\n    // The snapshot references must be copied before the hfiles otherwise the cleaner\n    // will remove them because they are unreferenced.\n    try {\n      FileUtil.copy(inputFs, snapshotDir, outputFs, snapshotTmpDir, false, overwrite, conf);\n    } catch (IOException e) {\n      System.err.println(\"Failed to copy the snapshot directory: from=\" + snapshotDir +\n        \" to=\" + snapshotTmpDir);\n      e.printStackTrace(System.err);\n      return 1;\n    }\n\n    // Step 2 - Start MR Job to copy files\n    // The snapshot references must be copied before the files otherwise the files gets removed\n    // by the HFileArchiver, since they have no references.\n    try {\n      if (files.size() == 0) {\n        LOG.warn(\"There are 0 store file to be copied. There may be no data in the table.\");\n      } else {\n        if (!runCopyJob(inputFs, inputRoot, outputFs, outputRoot, files, verifyChecksum,\n            filesUser, filesGroup, filesMode, mappers)) {\n          throw new ExportSnapshotException(\"Snapshot export failed!\");\n        }\n      }\n\n      // Step 3 - Rename fs2:/.snapshot/.tmp/<snapshot> fs2:/.snapshot/<snapshot>\n      if (!outputFs.rename(snapshotTmpDir, outputSnapshotDir)) {\n        System.err.println(\"Snapshot export failed!\");\n        System.err.println(\"Unable to rename snapshot directory from=\" +\n                           snapshotTmpDir + \" to=\" + outputSnapshotDir);\n        return 1;\n      }\n      return 0;\n    } catch (Exception e) {\n      LOG.error(\"Snapshot export failed\", e);\n      System.err.println(\"Snapshot export failed!\");\n      e.printStackTrace(System.err);\n      outputFs.delete(outputSnapshotDir, true);\n      return 1;\n    }\n  }","id":74536,"modified_method":"/**\n   * Execute the export snapshot by copying the snapshot metadata, hfiles and hlogs.\n   * @return 0 on success, and != 0 upon failure.\n   */\n  @Override\n  public int run(String[] args) throws IOException {\n    boolean verifyChecksum = true;\n    String snapshotName = null;\n    boolean overwrite = false;\n    String filesGroup = null;\n    String filesUser = null;\n    Path outputRoot = null;\n    int filesMode = 0;\n    int mappers = 0;\n\n    // Process command line args\n    for (int i = 0; i < args.length; i++) {\n      String cmd = args[i];\n      try {\n        if (cmd.equals(\"-snapshot\")) {\n          snapshotName = args[++i];\n        } else if (cmd.equals(\"-copy-to\")) {\n          outputRoot = new Path(args[++i]);\n        } else if (cmd.equals(\"-no-checksum-verify\")) {\n          verifyChecksum = false;\n        } else if (cmd.equals(\"-mappers\")) {\n          mappers = Integer.parseInt(args[++i]);\n        } else if (cmd.equals(\"-chuser\")) {\n          filesUser = args[++i];\n        } else if (cmd.equals(\"-chgroup\")) {\n          filesGroup = args[++i];\n        } else if (cmd.equals(\"-chmod\")) {\n          filesMode = Integer.parseInt(args[++i], 8);\n        } else if (cmd.equals(\"-overwrite\")) {\n          overwrite = true;\n        } else if (cmd.equals(\"-h\") || cmd.equals(\"--help\")) {\n          printUsageAndExit();\n        } else {\n          System.err.println(\"UNEXPECTED: \" + cmd);\n          printUsageAndExit();\n        }\n      } catch (Exception e) {\n        printUsageAndExit();\n      }\n    }\n\n    // Check user options\n    if (snapshotName == null) {\n      System.err.println(\"Snapshot name not provided.\");\n      printUsageAndExit();\n    }\n\n    if (outputRoot == null) {\n      System.err.println(\"Destination file-system not provided.\");\n      printUsageAndExit();\n    }\n\n    Configuration conf = getConf();\n    Path inputRoot = FSUtils.getRootDir(conf);\n    FileSystem inputFs = FileSystem.get(conf);\n    FileSystem outputFs = FileSystem.get(outputRoot.toUri(), conf);\n\n    Path snapshotDir = SnapshotDescriptionUtils.getCompletedSnapshotDir(snapshotName, inputRoot);\n    Path snapshotTmpDir = SnapshotDescriptionUtils.getWorkingSnapshotDir(snapshotName, outputRoot);\n    Path outputSnapshotDir = SnapshotDescriptionUtils.getCompletedSnapshotDir(snapshotName, outputRoot);\n\n    // Check if the snapshot already exists\n    if (outputFs.exists(outputSnapshotDir)) {\n      if (overwrite) {\n        if (!outputFs.delete(outputSnapshotDir, true)) {\n          System.err.println(\"Unable to remove existing snapshot directory: \" + outputSnapshotDir);\n          return 1;\n        }\n      } else {\n        System.err.println(\"The snapshot '\" + snapshotName +\n          \"' already exists in the destination: \" + outputSnapshotDir);\n        return 1;\n      }\n    }\n\n    // Check if the snapshot already in-progress\n    if (outputFs.exists(snapshotTmpDir)) {\n      if (overwrite) {\n        if (!outputFs.delete(snapshotTmpDir, true)) {\n          System.err.println(\"Unable to remove existing snapshot tmp directory: \" + snapshotTmpDir);\n          return 1;\n        }\n      } else {\n        System.err.println(\"A snapshot with the same name '\"+ snapshotName +\"' may be in-progress\");\n        System.err.println(\"Please check \" + snapshotTmpDir + \". If the snapshot has completed, \");\n        System.err.println(\"consider removing \" + snapshotTmpDir + \" before retrying export\");\n        return 1;\n      }\n    }\n\n    // Step 0 - Extract snapshot files to copy\n    final List<Pair<Path, Long>> files = getSnapshotFiles(inputFs, snapshotDir);\n    if (mappers == 0 && files.size() > 0) {\n      mappers = 1 + (files.size() / conf.getInt(CONF_MAP_GROUP, 10));\n      mappers = Math.min(mappers, files.size());\n    }\n\n    // Step 1 - Copy fs1:/.snapshot/<snapshot> to  fs2:/.snapshot/.tmp/<snapshot>\n    // The snapshot references must be copied before the hfiles otherwise the cleaner\n    // will remove them because they are unreferenced.\n    try {\n      FileUtil.copy(inputFs, snapshotDir, outputFs, snapshotTmpDir, false, false, conf);\n    } catch (IOException e) {\n      throw new ExportSnapshotException(\"Failed to copy the snapshot directory: from=\" +\n        snapshotDir + \" to=\" + snapshotTmpDir);\n    }\n\n    // Step 2 - Start MR Job to copy files\n    // The snapshot references must be copied before the files otherwise the files gets removed\n    // by the HFileArchiver, since they have no references.\n    try {\n      if (files.size() == 0) {\n        LOG.warn(\"There are 0 store file to be copied. There may be no data in the table.\");\n      } else {\n        runCopyJob(inputFs, inputRoot, outputFs, outputRoot, files, verifyChecksum,\n                   filesUser, filesGroup, filesMode, mappers);\n      }\n\n      // Step 3 - Rename fs2:/.snapshot/.tmp/<snapshot> fs2:/.snapshot/<snapshot>\n      if (!outputFs.rename(snapshotTmpDir, outputSnapshotDir)) {\n        throw new ExportSnapshotException(\"Unable to rename snapshot directory from=\" +\n          snapshotTmpDir + \" to=\" + outputSnapshotDir);\n      }\n      return 0;\n    } catch (Exception e) {\n      LOG.error(\"Snapshot export failed\", e);\n      outputFs.delete(snapshotTmpDir, true);\n      outputFs.delete(outputSnapshotDir, true);\n      return 1;\n    }\n  }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n   * Run Map-Reduce Job to perform the files copy.\n   */\n  private boolean runCopyJob(final FileSystem inputFs, final Path inputRoot,\n      final FileSystem outputFs, final Path outputRoot,\n      final List<Pair<Path, Long>> snapshotFiles, final boolean verifyChecksum,\n      final String filesUser, final String filesGroup, final int filesMode,\n      final int mappers) throws IOException, InterruptedException, ClassNotFoundException {\n    Configuration conf = getConf();\n    if (filesGroup != null) conf.set(CONF_FILES_GROUP, filesGroup);\n    if (filesUser != null) conf.set(CONF_FILES_USER, filesUser);\n    conf.setInt(CONF_FILES_MODE, filesMode);\n    conf.setBoolean(CONF_CHECKSUM_VERIFY, verifyChecksum);\n    conf.set(CONF_OUTPUT_ROOT, outputRoot.toString());\n    conf.set(CONF_INPUT_ROOT, inputRoot.toString());\n    conf.setInt(\"mapreduce.job.maps\", mappers);\n\n    Job job = new Job(conf);\n    job.setJobName(\"ExportSnapshot\");\n    job.setJarByClass(ExportSnapshot.class);\n    TableMapReduceUtil.addDependencyJars(job);\n    job.setMapperClass(ExportMapper.class);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    job.setOutputFormatClass(NullOutputFormat.class);\n    job.setMapSpeculativeExecution(false);\n    job.setNumReduceTasks(0);\n    for (Path path: createInputFiles(conf, snapshotFiles, mappers)) {\n      LOG.debug(\"Add Input Path=\" + path);\n      SequenceFileInputFormat.addInputPath(job, path);\n    }\n\n    UserProvider userProvider = UserProvider.instantiate(job.getConfiguration());\n    FsDelegationToken inputFsToken = new FsDelegationToken(userProvider, \"irenewer\");\n    FsDelegationToken outputFsToken = new FsDelegationToken(userProvider, \"orenewer\");\n    try {\n      // Acquire the delegation Tokens\n      inputFsToken.acquireDelegationToken(inputFs);\n      outputFsToken.acquireDelegationToken(outputFs);\n\n      // Run the MR Job\n      return job.waitForCompletion(true);\n    } finally {\n      inputFsToken.releaseDelegationToken();\n      outputFsToken.releaseDelegationToken();\n    }\n  }","id":74537,"modified_method":"/**\n   * Run Map-Reduce Job to perform the files copy.\n   */\n  private void runCopyJob(final FileSystem inputFs, final Path inputRoot,\n      final FileSystem outputFs, final Path outputRoot,\n      final List<Pair<Path, Long>> snapshotFiles, final boolean verifyChecksum,\n      final String filesUser, final String filesGroup, final int filesMode,\n      final int mappers) throws IOException, InterruptedException, ClassNotFoundException {\n    Configuration conf = getConf();\n    if (filesGroup != null) conf.set(CONF_FILES_GROUP, filesGroup);\n    if (filesUser != null) conf.set(CONF_FILES_USER, filesUser);\n    conf.setInt(CONF_FILES_MODE, filesMode);\n    conf.setBoolean(CONF_CHECKSUM_VERIFY, verifyChecksum);\n    conf.set(CONF_OUTPUT_ROOT, outputRoot.toString());\n    conf.set(CONF_INPUT_ROOT, inputRoot.toString());\n    conf.setInt(\"mapreduce.job.maps\", mappers);\n\n    Job job = new Job(conf);\n    job.setJobName(\"ExportSnapshot\");\n    job.setJarByClass(ExportSnapshot.class);\n    TableMapReduceUtil.addDependencyJars(job);\n    job.setMapperClass(ExportMapper.class);\n    job.setInputFormatClass(SequenceFileInputFormat.class);\n    job.setOutputFormatClass(NullOutputFormat.class);\n    job.setMapSpeculativeExecution(false);\n    job.setNumReduceTasks(0);\n    for (Path path: createInputFiles(conf, snapshotFiles, mappers)) {\n      LOG.debug(\"Add Input Path=\" + path);\n      SequenceFileInputFormat.addInputPath(job, path);\n    }\n\n    UserProvider userProvider = UserProvider.instantiate(job.getConfiguration());\n    FsDelegationToken inputFsToken = new FsDelegationToken(userProvider, \"irenewer\");\n    FsDelegationToken outputFsToken = new FsDelegationToken(userProvider, \"orenewer\");\n    try {\n      // Acquire the delegation Tokens\n      inputFsToken.acquireDelegationToken(inputFs);\n      outputFsToken.acquireDelegationToken(outputFs);\n\n      // Run the MR Job\n      if (!job.waitForCompletion(true)) {\n        // TODO: Replace the fixed string with job.getStatus().getFailureInfo()\n        // when it will be available on all the supported versions.\n        throw new ExportSnapshotException(\"Copy Files Map-Reduce Job failed\");\n      }\n    } finally {\n      inputFsToken.releaseDelegationToken();\n      outputFsToken.releaseDelegationToken();\n    }\n  }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"private FSDataInputStream openSourceFile(final Path path) {\n      try {\n        if (HFileLink.isHFileLink(path) || StoreFileInfo.isReference(path)) {\n          return new HFileLink(inputRoot, inputArchive, path).open(inputFs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).open(inputFs);\n        }\n        return inputFs.open(path);\n      } catch (IOException e) {\n        LOG.error(\"Unable to open source file=\" + path, e);\n        return null;\n      }\n    }","id":74538,"modified_method":"/**\n     * Try to open the \"source\" file.\n     * Throws an IOException if the communication with the inputFs fail or\n     * if the file is not found.\n     */\n    private FSDataInputStream openSourceFile(Context context, final Path path) throws IOException {\n      try {\n        if (HFileLink.isHFileLink(path) || StoreFileInfo.isReference(path)) {\n          return new HFileLink(inputRoot, inputArchive, path).open(inputFs);\n        } else if (isHLogLinkPath(path)) {\n          String serverName = path.getParent().getName();\n          String logName = path.getName();\n          return new HLogLink(inputRoot, serverName, logName).open(inputFs);\n        }\n        return inputFs.open(path);\n      } catch (IOException e) {\n        context.getCounter(Counter.MISSING_FILES).increment(1);\n        LOG.error(\"Unable to open source file=\" + path, e);\n        throw e;\n      }\n    }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void setup(Context context) {\n      Configuration conf = context.getConfiguration();\n      verifyChecksum = conf.getBoolean(CONF_CHECKSUM_VERIFY, true);\n\n      filesGroup = conf.get(CONF_FILES_GROUP);\n      filesUser = conf.get(CONF_FILES_USER);\n      filesMode = (short)conf.getInt(CONF_FILES_MODE, 0);\n      outputRoot = new Path(conf.get(CONF_OUTPUT_ROOT));\n      inputRoot = new Path(conf.get(CONF_INPUT_ROOT));\n\n      inputArchive = new Path(inputRoot, HConstants.HFILE_ARCHIVE_DIRECTORY);\n      outputArchive = new Path(outputRoot, HConstants.HFILE_ARCHIVE_DIRECTORY);\n\n      testFailures = conf.getBoolean(CONF_TEST_FAILURE, false);\n\n      try {\n        inputFs = FileSystem.get(inputRoot.toUri(), conf);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Could not get the input FileSystem with root=\" + inputRoot, e);\n      }\n\n      try {\n        outputFs = FileSystem.get(outputRoot.toUri(), conf);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Could not get the output FileSystem with root=\"+ outputRoot, e);\n      }\n    }","id":74539,"modified_method":"@Override\n    public void setup(Context context) throws IOException {\n      Configuration conf = context.getConfiguration();\n      verifyChecksum = conf.getBoolean(CONF_CHECKSUM_VERIFY, true);\n\n      filesGroup = conf.get(CONF_FILES_GROUP);\n      filesUser = conf.get(CONF_FILES_USER);\n      filesMode = (short)conf.getInt(CONF_FILES_MODE, 0);\n      outputRoot = new Path(conf.get(CONF_OUTPUT_ROOT));\n      inputRoot = new Path(conf.get(CONF_INPUT_ROOT));\n\n      inputArchive = new Path(inputRoot, HConstants.HFILE_ARCHIVE_DIRECTORY);\n      outputArchive = new Path(outputRoot, HConstants.HFILE_ARCHIVE_DIRECTORY);\n\n      testFailures = conf.getBoolean(CONF_TEST_FAILURE, false);\n\n      try {\n        inputFs = FileSystem.get(inputRoot.toUri(), conf);\n      } catch (IOException e) {\n        throw new IOException(\"Could not get the input FileSystem with root=\" + inputRoot, e);\n      }\n\n      try {\n        outputFs = FileSystem.get(outputRoot.toUri(), conf);\n      } catch (IOException e) {\n        throw new IOException(\"Could not get the output FileSystem with root=\"+ outputRoot, e);\n      }\n\n      // Use the default block size of the outputFs if bigger\n      int defaultBlockSize = Math.max((int) outputFs.getDefaultBlockSize(), BUFFER_SIZE);\n      bufferSize = conf.getInt(CONF_BUFFER_SIZE, defaultBlockSize);\n      LOG.info(\"Using bufferSize=\" + StringUtils.humanReadableInt(bufferSize));\n    }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n     * Preserve the files attribute selected by the user copying them from the source file\n     */\n    private boolean preserveAttributes(final Path path, final FileStatus refStat) {\n      FileStatus stat;\n      try {\n        stat = outputFs.getFileStatus(path);\n      } catch (IOException e) {\n        LOG.warn(\"Unable to get the status for file=\" + path);\n        return false;\n      }\n\n      try {\n        if (filesMode > 0 && stat.getPermission().toShort() != filesMode) {\n          outputFs.setPermission(path, new FsPermission(filesMode));\n        } else if (!stat.getPermission().equals(refStat.getPermission())) {\n          outputFs.setPermission(path, refStat.getPermission());\n        }\n      } catch (IOException e) {\n        LOG.error(\"Unable to set the permission for file=\" + path, e);\n        return false;\n      }\n\n      try {\n        String user = (filesUser != null) ? filesUser : refStat.getOwner();\n        String group = (filesGroup != null) ? filesGroup : refStat.getGroup();\n        if (!(user.equals(stat.getOwner()) && group.equals(stat.getGroup()))) {\n          outputFs.setOwner(path, user, group);\n        }\n      } catch (IOException e) {\n        LOG.error(\"Unable to set the owner/group for file=\" + path, e);\n        return false;\n      }\n\n      return true;\n    }","id":74540,"modified_method":"/**\n     * Try to Preserve the files attribute selected by the user copying them from the source file\n     * This is only required when you are exporting as a different user than \"hbase\" or on a system\n     * that doesn't have the \"hbase\" user.\n     *\n     * This is not considered a blocking failure since the user can force a chmod with the user\n     * that knows is available on the system.\n     */\n    private boolean preserveAttributes(final Path path, final FileStatus refStat) {\n      FileStatus stat;\n      try {\n        stat = outputFs.getFileStatus(path);\n      } catch (IOException e) {\n        LOG.warn(\"Unable to get the status for file=\" + path);\n        return false;\n      }\n\n      try {\n        if (filesMode > 0 && stat.getPermission().toShort() != filesMode) {\n          outputFs.setPermission(path, new FsPermission(filesMode));\n        } else if (!stat.getPermission().equals(refStat.getPermission())) {\n          outputFs.setPermission(path, refStat.getPermission());\n        }\n      } catch (IOException e) {\n        LOG.warn(\"Unable to set the permission for file=\"+ stat.getPath() +\": \"+ e.getMessage());\n        return false;\n      }\n\n      String user = stringIsNotEmpty(filesUser) ? filesUser : refStat.getOwner();\n      String group = stringIsNotEmpty(filesGroup) ? filesGroup : refStat.getGroup();\n      if (stringIsNotEmpty(user) || stringIsNotEmpty(group)) {\n        try {\n          if (!(user.equals(stat.getOwner()) && group.equals(stat.getGroup()))) {\n            outputFs.setOwner(path, user, group);\n          }\n        } catch (IOException e) {\n          LOG.warn(\"Unable to set the owner/group for file=\"+ stat.getPath() +\": \"+ e.getMessage());\n          LOG.warn(\"The user/group may not exist on the destination cluster: user=\" +\n                   user + \" group=\" + group);\n          return false;\n        }\n      }\n\n      return true;\n    }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"@Override\n    public void map(Text key, NullWritable value, Context context)\n        throws InterruptedException, IOException {\n      Path inputPath = new Path(key.toString());\n      Path outputPath = getOutputPath(inputPath);\n\n      LOG.info(\"copy file input=\" + inputPath + \" output=\" + outputPath);\n      copyFile(context, inputPath, outputPath);\n      LOG.info(\"copy completed for input=\" + inputPath + \" output=\" + outputPath);\n    }","id":74541,"modified_method":"@Override\n    public void map(Text key, NullWritable value, Context context)\n        throws InterruptedException, IOException {\n      Path inputPath = new Path(key.toString());\n      Path outputPath = getOutputPath(inputPath);\n\n      LOG.info(\"copy file input=\" + inputPath + \" output=\" + outputPath);\n      copyFile(context, inputPath, outputPath);\n    }","commit_id":"50f857944e3cc9d650d5fbe7619b26292646cc1e","url":"https://github.com/apache/hbase"},{"original_method":"/**\n\t * @param inputRowMeta the input row metadata\n\t * @param r the input row (data)\n\t * @throws KettleValidatorException in case there is a validation error, details are stored in the exception.\n\t */\n    private void validateFields(RowMetaInterface inputRowMeta, Object[] r) throws KettleValidatorException, KettleValueException\n    {\n        for (int i=0;i<meta.getValidatorField().length;i++)\n        {\n            ValidatorField field = meta.getValidatorField()[i];\r\n            \r\n            int valueIndex = data.fieldIndexes[i];\r\n            ValueMetaInterface validatorMeta = data.constantsMeta[i];\r\n            \r\n            ValueMetaInterface valueMeta = inputRowMeta.getValueMeta(valueIndex);\r\n            Object valueData = r[valueIndex];\r\n\r\n            // Check for null\r\n            //\r\n            boolean isNull = valueMeta.isNull(valueData);\r\n            if (!field.isNullAllowed() && isNull) {\r\n            \tthrow new KettleValidatorException(KettleValidatorException.ERROR_NULL_VALUE_NOT_ALLOWED, Messages.getString(\"Validator.Exception.NullNotAllowed\", field.getName(), inputRowMeta.getString(r)), field.getName());\r\n            }\r\n            \r\n            // Check the data type!\r\n            //\r\n            if (field.getDataType()!=ValueMetaInterface.TYPE_NONE) {\r\n            \t\r\n            \t// Same data type?\r\n            \t//\r\n            \tif (field.getDataType() != valueMeta.getType()) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_UNEXPECTED_DATA_TYPE, Messages.getString(\"Validator.Exception.UnexpectedDataType\", field.getName(), valueMeta.toStringMeta(), validatorMeta.toStringMeta()), field.getName());\r\n            \t}\r\n            }\r\n            \r\n            // Check various things if the value is not null..\r\n            //\r\n            if (!isNull) {\r\n            \t\r\n            \tString stringValue = valueMeta.getString(valueData);\r\n            \t\r\n            \t// Minimum length\r\n            \t//\r\n            \tif (field.getMinimumLength()>=0 && stringValue.length()<field.getMinimumLength() ) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_SHORTER_THAN_MINIMUM_LENGTH, Messages.getString(\"Validator.Exception.ShorterThanMininumLength\", field.getName(), inputRowMeta.getString(r)), field.getName());\r\n            \t}\r\n            \t\r\n            \t// Maximum length\r\n            \t//\r\n            \tif (field.getMaximumLength()>=0 && stringValue.length()>field.getMaximumLength() ) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_SHORTER_THAN_MINIMUM_LENGTH, Messages.getString(\"Validator.Exception.ShorterThanMininumLength\", field.getName(), inputRowMeta.getString(r)), field.getName());\r\n            \t}\r\n            \t\r\n            \t// Minimal value\r\n            \t//\r\n            \tif (data.minimumValue!=null && valueMeta.compare(valueData, validatorMeta, data.minimumValue[i])<0) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_LOWER_THAN_ALLOWED_MINIMUM, Messages.getString(\"Validator.Exception.LowerThanMinimumValue\", field.getName(), valueMeta.getString(valueData), validatorMeta.getString(data.minimumValue)), field.getName());\r\n            \t}\r\n\r\n            \t// Maximum value\r\n            \t//\r\n            \tif (data.maximumValue!=null && valueMeta.compare(valueData, validatorMeta, data.maximumValue[i])>0) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_HIGHER_THAN_ALLOWED_MAXIMUM, Messages.getString(\"Validator.Exception.HigherThanMaximumValue\", field.getName(), valueMeta.getString(valueData), validatorMeta.getString(data.minimumValue)), field.getName());\r\n            \t}\r\n            \t\r\n            \t// In list?\r\n            \t//\r\n            \tboolean found = data.listValues.length==0;\r\n            \tfor (Object object : data.listValues[i]) {\r\n                \tif (object!=null && valueMeta.compare(valueData, validatorMeta, object)==0) {\r\n                    \tfound=true;\r\n                \t}\r\n            \t}\r\n            \tif (!found) {\r\n            \t\tthrow new KettleValidatorException(KettleValidatorException.ERROR_VALUE_NOT_IN_LIST, Messages.getString(\"Validator.Exception.NotInList\", field.getName(), valueMeta.getString(valueData)), field.getName());\r\n            \t}\r\n            }\r\n        }\n    }","id":74542,"modified_method":"/**\n\t * @param inputRowMeta the input row metadata\n\t * @param r the input row (data)\n\t * @throws KettleValidatorException in case there is a validation error, details are stored in the exception.\n\t */\n    private void validateFields(RowMetaInterface inputRowMeta, Object[] r) throws KettleValidatorException, KettleValueException\n    {\n        for (int i=0;i<meta.getValidatorField().length;i++)\n        {\n            ValidatorField field = meta.getValidatorField()[i];\r\n            \r\n            int valueIndex = data.fieldIndexes[i];\r\n            ValueMetaInterface validatorMeta = data.constantsMeta[i];\r\n            \r\n            ValueMetaInterface valueMeta = inputRowMeta.getValueMeta(valueIndex);\r\n            Object valueData = r[valueIndex];\r\n\r\n            // Check for null\r\n            //\r\n            boolean isNull = valueMeta.isNull(valueData);\r\n            if (!field.isNullAllowed() && isNull) {\r\n            \tthrow new KettleValidatorException(KettleValidatorException.ERROR_NULL_VALUE_NOT_ALLOWED, Messages.getString(\"Validator.Exception.NullNotAllowed\", field.getName(), inputRowMeta.getString(r)), field.getName());\r\n            }\r\n            \r\n            // Check the data type!\r\n            //\r\n            if (field.isDataTypeVerified() && field.getDataType()!=ValueMetaInterface.TYPE_NONE) {\r\n            \t\r\n            \t// Same data type?\r\n            \t//\r\n            \tif (field.getDataType() != valueMeta.getType()) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_UNEXPECTED_DATA_TYPE, Messages.getString(\"Validator.Exception.UnexpectedDataType\", field.getName(), valueMeta.toStringMeta(), validatorMeta.toStringMeta()), field.getName());\r\n            \t}\r\n            }\r\n            \r\n            // Check various things if the value is not null..\r\n            //\r\n            if (!isNull) {\r\n            \t\r\n            \tString stringValue = valueMeta.getString(valueData);\r\n            \t\r\n            \t// Minimum length\r\n            \t//\r\n            \tif (field.getMinimumLength()>=0 && stringValue.length()<field.getMinimumLength() ) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_SHORTER_THAN_MINIMUM_LENGTH, Messages.getString(\"Validator.Exception.ShorterThanMininumLength\", field.getName(), valueMeta.getString(valueData), Integer.toString(stringValue.length()), Integer.toString(field.getMinimumLength())), field.getName());\r\n            \t}\r\n            \t\r\n            \t// Maximum length\r\n            \t//\r\n            \tif (field.getMaximumLength()>=0 && stringValue.length()>field.getMaximumLength() ) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_LONGER_THAN_MAXIMUM_LENGTH, Messages.getString(\"Validator.Exception.LongerThanMaximumLength\", field.getName(), valueMeta.getString(valueData), Integer.toString(stringValue.length()), Integer.toString(field.getMaximumLength())), field.getName());\r\n            \t}\r\n            \t\r\n            \t// Minimal value\r\n            \t//\r\n            \tif (data.minimumValue[i]!=null && valueMeta.compare(valueData, validatorMeta, data.minimumValue[i])<0) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_LOWER_THAN_ALLOWED_MINIMUM, Messages.getString(\"Validator.Exception.LowerThanMinimumValue\", field.getName(), valueMeta.getString(valueData), data.constantsMeta[i].getString(data.minimumValue[i])), field.getName());\r\n            \t}\r\n\r\n            \t// Maximum value\r\n            \t//\r\n            \tif (data.maximumValue[i]!=null && valueMeta.compare(valueData, validatorMeta, data.maximumValue[i])>0) {\r\n                \tthrow new KettleValidatorException(KettleValidatorException.ERROR_HIGHER_THAN_ALLOWED_MAXIMUM, Messages.getString(\"Validator.Exception.HigherThanMaximumValue\", field.getName(), valueMeta.getString(valueData), data.constantsMeta[i].getString(data.maximumValue[i])), field.getName());\r\n            \t}\r\n            \t\r\n            \t// In list?\r\n            \t//\r\n            \tboolean found = data.listValues[i].length==0;\r\n            \tfor (Object object : data.listValues[i]) {\r\n                \tif (object!=null && data.listValues[i]!=null && valueMeta.compare(valueData, validatorMeta, object)==0) {\r\n                    \tfound=true;\r\n                \t}\r\n            \t}\r\n            \tif (!found) {\r\n            \t\tthrow new KettleValidatorException(KettleValidatorException.ERROR_VALUE_NOT_IN_LIST, Messages.getString(\"Validator.Exception.NotInList\", field.getName(), valueMeta.getString(valueData)), field.getName());\r\n            \t}\r\n            }\r\n        }\n    }","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(ValidatorMeta)smi;\n\t\tdata=(ValidatorData)sdi;\n\t\t\n\t\tif (super.init(smi, sdi))\n\t\t{\r\n\t\t\tdata.constantsMeta = new ValueMetaInterface[meta.getValidatorField().length];\r\n\t\t\tfor (int i=0;i<data.constantsMeta.length;i++) {\r\n\t\t\t\tValidatorField field = meta.getValidatorField()[i];\r\n\t\t\t\tdata.constantsMeta[i] = new ValueMeta(field.getName(), field.getDataType());\r\n\t\t\t\tdata.constantsMeta[i].setConversionMask(field.getConversionMask());\r\n\t\t\t\tdata.constantsMeta[i].setDecimalSymbol(field.getDecimalSymbol());\r\n\t\t\t\tdata.constantsMeta[i].setGroupingSymbol(field.getGroupingSymbol());\r\n\t\t\t\t\r\n\t\t\t\tValueMetaInterface stringMeta = data.constantsMeta[i].clone();\r\n\t\t\t\tstringMeta.setType(ValueMetaInterface.TYPE_STRING);\r\n\t\t\t\t\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdata.minimumValue[i] = data.constantsMeta[i].convertData(stringMeta, field.getMinimumValue());\r\n\t\t\t\t\tdata.maximumValue[i] = data.constantsMeta[i].convertData(stringMeta, field.getMaximumValue());\r\n\t\t\t\t\tint listSize = field.getAllowedValues()!=null ? field.getAllowedValues().length : 0;\r\n\t\t\t\t\tdata.listValues[i] = new Object[listSize];\r\n\t\t\t\t\tfor (int s=0;s<listSize;s++) {\r\n\t\t\t\t\t\tdata.listValues[i][s] = data.constantsMeta[i].convertData(stringMeta, field.getAllowedValues()[s]);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (KettleValueException e) {\r\n\t\t\t\t\tlogError(Messages.getString(\"Validator.Exception.DataConversionErrorEncountered\"), e);\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t    return true;\n\t\t}\n\t\treturn false;\n\t}","id":74543,"modified_method":"public boolean init(StepMetaInterface smi, StepDataInterface sdi)\n\t{\n\t\tmeta=(ValidatorMeta)smi;\n\t\tdata=(ValidatorData)sdi;\n\t\t\n\t\tif (super.init(smi, sdi))\n\t\t{\r\n\t\t\tdata.constantsMeta = new ValueMetaInterface[meta.getValidatorField().length];\r\n\t\t\tdata.minimumValue = new Object[meta.getValidatorField().length];\r\n\t\t\tdata.maximumValue = new Object[meta.getValidatorField().length];\r\n\t\t\tdata.listValues = new Object[meta.getValidatorField().length][];\r\n\r\n\t\t\tfor (int i=0;i<data.constantsMeta.length;i++) {\r\n\t\t\t\tValidatorField field = meta.getValidatorField()[i];\r\n\t\t\t\tdata.constantsMeta[i] = new ValueMeta(field.getName(), field.getDataType());\r\n\t\t\t\tdata.constantsMeta[i].setConversionMask(field.getConversionMask());\r\n\t\t\t\tdata.constantsMeta[i].setDecimalSymbol(field.getDecimalSymbol());\r\n\t\t\t\tdata.constantsMeta[i].setGroupingSymbol(field.getGroupingSymbol());\r\n\t\t\t\t\r\n\t\t\t\tValueMetaInterface stringMeta = data.constantsMeta[i].clone();\r\n\t\t\t\tstringMeta.setType(ValueMetaInterface.TYPE_STRING);\r\n\t\t\t\t\r\n\t\t\t\ttry {\r\n\t\t\t\t\tdata.minimumValue[i] = Const.isEmpty(field.getMinimumValue()) ? null : data.constantsMeta[i].convertData(stringMeta, field.getMinimumValue());\r\n\t\t\t\t\tdata.maximumValue[i] = Const.isEmpty(field.getMaximumValue()) ? null : data.constantsMeta[i].convertData(stringMeta, field.getMaximumValue());\r\n\t\t\t\t\tint listSize = field.getAllowedValues()!=null ? field.getAllowedValues().length : 0;\r\n\t\t\t\t\tdata.listValues[i] = new Object[listSize];\r\n\t\t\t\t\tfor (int s=0;s<listSize;s++) {\r\n\t\t\t\t\t\tdata.listValues[i][s] = Const.isEmpty(field.getAllowedValues()[s]) ? null : data.constantsMeta[i].convertData(stringMeta, field.getAllowedValues()[s]);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (KettleValueException e) {\r\n\t\t\t\t\tif (field.getDataType()==ValueMetaInterface.TYPE_NONE) {\r\n\t\t\t\t\t\tlogError(Messages.getString(\"Validator.Exception.SpecifyDataType\"), e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tlogError(Messages.getString(\"Validator.Exception.DataConversionErrorEncountered\"), e);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t    return true;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void getValidatorFieldData(ValidatorField field) {\r\n\t\twNullAllowed.setSelection(field.isNullAllowed());\r\n\t\tif (field.getMaximumLength()>=0) wMaxLength.setText(Integer.toString(field.getMaximumLength())); else wMaxLength.setText(\"\"); \r\n\t\tif (field.getMinimumLength()>=0) wMinLength.setText(Integer.toString(field.getMinimumLength())); else wMinLength.setText(\"\"); \r\n\t}","id":74544,"modified_method":"private void getValidatorFieldData(ValidatorField field) {\r\n\t\twDataTypeVerified.setSelection(field.isDataTypeVerified());\r\n\t\twDataType.setText(ValueMeta.getTypeDesc(field.getDataType()));\r\n\t\twConversionMask.setText(Const.NVL(field.getConversionMask(), \"\"));\r\n\t\twGroupingSymbol.setText(Const.NVL(field.getGroupingSymbol(), \"\"));\r\n\t\twDecimalSymbol.setText(Const.NVL(field.getDecimalSymbol(), \"\"));\r\n\t\t\r\n\t\twNullAllowed.setSelection(field.isNullAllowed());\r\n\t\tif (field.getMaximumLength()>=0) wMaxLength.setText(Integer.toString(field.getMaximumLength())); else wMaxLength.setText(\"\"); \r\n\t\tif (field.getMinimumLength()>=0) wMinLength.setText(Integer.toString(field.getMinimumLength())); else wMinLength.setText(\"\"); \r\n\t\twMaxValue.setText(Const.NVL(field.getMaximumValue(), \"\"));\r\n\t\twMinValue.setText(Const.NVL(field.getMinimumValue(), \"\"));\r\n\t\t\r\n\t\twAllowedValues.removeAll();\r\n\t\tif (field.getAllowedValues()!=null) {\r\n\t\t\tfor (String allowedValue : field.getAllowedValues()) {\r\n\t\t\t\twAllowedValues.add(Const.NVL(allowedValue, \"\"));\r\n\t\t\t}\r\n\t\t}\r\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void saveChanges() {\r\n\t\tif (selectedField!=null) {\r\n\t\t\t// First grab the info from the dialog...\r\n\t\t\t// \r\n\t\t\tselectedField.setNullAllowed(wNullAllowed.getSelection());\r\n\t\t\tselectedField.setMaximumLength(Const.toInt(wMaxLength.getText(), -1));\r\n\t\t\tselectedField.setMinimumLength(Const.toInt(wMinLength.getText(), -1));\r\n\r\n\t\t\t// Save the old info in the map\r\n\t\t\t// \r\n\t\t\tselectionMap.put(selectedField.getName(), selectedField);\r\n\t\t}\r\n\t}","id":74545,"modified_method":"private void saveChanges() {\r\n\t\tif (selectedField!=null) {\r\n\t\t\t// First grab the info from the dialog...\r\n\t\t\t// \r\n\t\t\tselectedField.setDataTypeVerified(wDataTypeVerified.getSelection());\r\n\t\t\tselectedField.setDataType(ValueMeta.getType(wDataType.getText()));\r\n\t\t\t\r\n\t\t\tselectedField.setNullAllowed(wNullAllowed.getSelection());\r\n\t\t\tselectedField.setMaximumLength(Const.toInt(wMaxLength.getText(), -1));\r\n\t\t\tselectedField.setMinimumLength(Const.toInt(wMinLength.getText(), -1));\r\n\t\t\tselectedField.setMaximumValue(wMaxValue.getText());\r\n\t\t\tselectedField.setMinimumValue(wMinValue.getText());\r\n\t\t\t\r\n\t\t\tselectedField.setAllowedValues(wAllowedValues.getItems());\r\n\r\n\t\t\t// Save the old info in the map\r\n\t\t\t// \r\n\t\t\tselectionMap.put(selectedField.getName(), selectedField);\r\n\t\t}\r\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\twStepname.selectAll();\n\t}","id":74546,"modified_method":"/**\n\t * Copy information from the meta-data input to the dialog fields.\n\t */ \n\tpublic void getData()\n\t{\n\t\twStepname.selectAll();\r\n\t\tenableFields();\r\n\t\t\r\n\t\t// Select the first available field...\r\n\t\t//\r\n\t\tif (input.getValidatorField().length>0) {\r\n\t\t\tValidatorField validatorField = input.getValidatorField()[0];\r\n\t\t\tString name = validatorField.getName();\r\n\t\t\tint index = wFieldList.indexOf(name);\r\n\t\t\tif (index>=0) {\r\n\t\t\t\twFieldList.select(index);\r\n\t\t\t\tshowSelectedValidatorField(name);\r\n\t\t\t}\r\n\t\t}\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void showSelectedValidatorField(String selection) {\r\n\t\t// Someone hit a field...\r\n\t\t//\r\n\t\tsaveChanges();\r\n\t\t\r\n\t\tValidatorField field = selectionMap.get(selection);\r\n\t\tif (field==null) {\r\n\t\t\tfield = new ValidatorField(selection);\r\n\t\t}\r\n\t\t\r\n\t\tselectedField = field;\r\n\t\t\r\n\t\tgetValidatorFieldData(selectedField);\r\n\t}","id":74547,"modified_method":"private void showSelectedValidatorField(String selection) {\r\n\t\t// Someone hit a field...\r\n\t\t//\r\n\t\tsaveChanges();\r\n\t\t\r\n\t\tValidatorField field = selectionMap.get(selection);\r\n\t\tif (field==null) {\r\n\t\t\tfield = new ValidatorField(selection);\r\n\t\t}\r\n\t\t\r\n\t\tselectedField = field;\r\n\t\t\r\n\t\tgetValidatorFieldData(selectedField);\r\n\t\t\r\n\t\tenableFields();\r\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, input);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"ValidatorDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\r\n\t\t//\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"ValidatorDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\r\n\t\t\r\n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\r\n\r\n\t\t// List of fields to the left...\r\n\t\t//\r\n\t\tLabel wlFieldList = new Label(shell, SWT.RIGHT);\r\n\t\twlFieldList.setText(Messages.getString(\"ValidatorDialog.FieldList.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlFieldList);\r\n\t\tFormData fdlFieldList = new FormData();\r\n\t\tfdlFieldList.left = new FormAttachment(0, 0);\r\n\t\tfdlFieldList.right= new FormAttachment(middle, -margin);\r\n\t\tfdlFieldList.top  = new FormAttachment(wStepname, margin);\r\n\t\twlFieldList.setLayoutData(fdlFieldList);\r\n\t\twFieldList=new List(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\t\r\n\t\t// TODO: grab field list in thread in the background...\r\n\t\t//\r\n\t\ttry {\r\n\t\t\tinputFields = transMeta.getPrevStepFields(stepMeta);\r\n\t\t\twFieldList.setItems(inputFields.getFieldNames());\r\n\t\t} catch (KettleStepException ex) {\r\n\t\t\tnew ErrorDialog(shell, Messages.getString(\"ValidatorDialog.Exception.CantGetFieldsFromPreviousSteps.Title\"), Messages.getString(\"ValidatorDialog.Exception.CantGetFieldsFromPreviousSteps.Message\"), ex);\r\n\t\t}\r\n\t\t\r\n \t\tprops.setLook(wFieldList);\r\n \t\twFieldList.addSelectionListener(new SelectionAdapter() { \r\n\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\n\t\t\t\tshowSelectedValidatorField(wFieldList.getSelection()[0]);\r\n\t\t\t}\r\n\t\t\r\n\t\t});\r\n\t\tFormData fdFieldList = new FormData();\r\n\t\tfdFieldList.left   = new FormAttachment(0, 0);\r\n\t\tfdFieldList.top    = new FormAttachment(wlFieldList, margin);\r\n\t\tfdFieldList.right  = new FormAttachment(middle, -margin);\r\n\t\tfdFieldList.bottom = new FormAttachment(wOK, -margin*2);\r\n\t\twFieldList.setLayoutData(fdFieldList);\r\n\t\t\r\n\t\tint middle2 = middle + ( 100 - middle ) / 2;\r\n\t\t\r\n\t\t// Check for null?\r\n\t\t//\r\n\t\twlNullAllowed=new Label(shell, SWT.RIGHT);\r\n\t\twlNullAllowed.setText(Messages.getString(\"ValidatorDialog.NullAllowed.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlNullAllowed);\r\n\t\tFormData fdlNullAllowed = new FormData();\r\n\t\tfdlNullAllowed.left = new FormAttachment(middle, 0);\r\n\t\tfdlNullAllowed.right= new FormAttachment(middle2, -margin);\r\n\t\tfdlNullAllowed.top  = new FormAttachment(wlFieldList, margin);\r\n\t\twlNullAllowed.setLayoutData(fdlNullAllowed);\r\n\t\twNullAllowed=new Button(shell, SWT.CHECK);\r\n \t\tprops.setLook(wNullAllowed);\r\n\t\tFormData fdNullAllowed = new FormData();\r\n\t\tfdNullAllowed.left = new FormAttachment(middle2, margin);\r\n\t\tfdNullAllowed.right= new FormAttachment(100, 0);\r\n\t\tfdNullAllowed.top  = new FormAttachment(wlFieldList, margin);\r\n\t\twNullAllowed.setLayoutData(fdNullAllowed);\r\n\r\n\t\t// Maximum length\r\n\t\t//\r\n\t\twlMaxLength=new Label(shell, SWT.RIGHT);\r\n\t\twlMaxLength.setText(Messages.getString(\"ValidatorDialog.MaxLength.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlMaxLength);\r\n\t\tFormData fdlMaxLength = new FormData();\r\n\t\tfdlMaxLength.left = new FormAttachment(middle, 0);\r\n\t\tfdlMaxLength.right= new FormAttachment(middle2, -margin);\r\n\t\tfdlMaxLength.top  = new FormAttachment(wNullAllowed, margin);\r\n\t\twlMaxLength.setLayoutData(fdlMaxLength);\r\n\t\twMaxLength=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wMaxLength);\r\n\t\tFormData fdMaxLength = new FormData();\r\n\t\tfdMaxLength.left = new FormAttachment(middle2, margin);\r\n\t\tfdMaxLength.right= new FormAttachment(100, 0);\r\n\t\tfdMaxLength.top  = new FormAttachment(wNullAllowed, margin);\r\n\t\twMaxLength.setLayoutData(fdMaxLength);\r\n\t\t\r\n\t\t// Minimum length\r\n\t\t//\r\n\t\twlMinLength=new Label(shell, SWT.RIGHT);\r\n\t\twlMinLength.setText(Messages.getString(\"ValidatorDialog.MinLength.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlMinLength);\r\n\t\tFormData fdlMinLength = new FormData();\r\n\t\tfdlMinLength.left = new FormAttachment(middle, 0);\r\n\t\tfdlMinLength.right= new FormAttachment(middle2, -margin);\r\n\t\tfdlMinLength.top  = new FormAttachment(wMaxLength, margin);\r\n\t\twlMinLength.setLayoutData(fdlMinLength);\r\n\t\twMinLength=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wMinLength);\r\n\t\tFormData fdMinLength = new FormData();\r\n\t\tfdMinLength.left = new FormAttachment(middle2, margin);\r\n\t\tfdMinLength.right= new FormAttachment(100, 0);\r\n\t\tfdMinLength.top  = new FormAttachment(wMaxLength, margin);\r\n\t\twMinLength.setLayoutData(fdMinLength);\r\n\r\n\t\t\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\t\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","id":74548,"modified_method":"public String open()\n\t{\n\t\tShell parent = getParent();\n\t\tDisplay display = parent.getDisplay();\n\n\t\tshell = new Shell(parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX);\n \t\tprops.setLook(shell);\n \t\tsetShellImage(shell, input);\n        \n\t\tModifyListener lsMod = new ModifyListener() \n\t\t{\n\t\t\tpublic void modifyText(ModifyEvent e) \n\t\t\t{\n\t\t\t\tinput.setChanged();\n\t\t\t}\n\t\t};\n\t\tchanged = input.hasChanged();\n\n\t\tFormLayout formLayout = new FormLayout ();\n\t\tformLayout.marginWidth  = Const.FORM_MARGIN;\n\t\tformLayout.marginHeight = Const.FORM_MARGIN;\n\n\t\tshell.setLayout(formLayout);\n\t\tshell.setText(Messages.getString(\"ValidatorDialog.Shell.Title\")); //$NON-NLS-1$\n\t\t\n\t\tint middle = props.getMiddlePct();\n\t\tint margin = Const.MARGIN;\n\n\t\t// Stepname line\r\n\t\t//\n\t\twlStepname=new Label(shell, SWT.RIGHT);\n\t\twlStepname.setText(Messages.getString(\"ValidatorDialog.Stepname.Label\")); //$NON-NLS-1$\n \t\tprops.setLook(wlStepname);\n\t\tfdlStepname=new FormData();\n\t\tfdlStepname.left = new FormAttachment(0, 0);\n\t\tfdlStepname.right= new FormAttachment(middle, -margin);\n\t\tfdlStepname.top  = new FormAttachment(0, margin);\n\t\twlStepname.setLayoutData(fdlStepname);\n\t\twStepname=new Text(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\n\t\twStepname.setText(stepname);\n \t\tprops.setLook(wStepname);\n\t\twStepname.addModifyListener(lsMod);\n\t\tfdStepname=new FormData();\n\t\tfdStepname.left = new FormAttachment(middle, 0);\n\t\tfdStepname.top  = new FormAttachment(0, margin);\n\t\tfdStepname.right= new FormAttachment(100, 0);\n\t\twStepname.setLayoutData(fdStepname);\r\n\t\t\r\n\t\t// Some buttons\n\t\twOK=new Button(shell, SWT.PUSH);\n\t\twOK.setText(Messages.getString(\"System.Button.OK\")); //$NON-NLS-1$\n\t\twCancel=new Button(shell, SWT.PUSH);\n\t\twCancel.setText(Messages.getString(\"System.Button.Cancel\")); //$NON-NLS-1$\n\t\t\n\t\tsetButtonPositions(new Button[] { wOK, wCancel }, margin, null);\r\n\r\n\t\t// List of fields to the left...\r\n\t\t//\r\n\t\tLabel wlFieldList = new Label(shell, SWT.LEFT);\r\n\t\twlFieldList.setText(Messages.getString(\"ValidatorDialog.FieldList.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlFieldList);\r\n\t\tFormData fdlFieldList = new FormData();\r\n\t\tfdlFieldList.left = new FormAttachment(0, 0);\r\n\t\tfdlFieldList.right= new FormAttachment(100, 0);\r\n\t\tfdlFieldList.top  = new FormAttachment(wStepname, margin);\r\n\t\twlFieldList.setLayoutData(fdlFieldList);\r\n\t\twFieldList=new List(shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER | SWT.V_SCROLL | SWT.H_SCROLL);\r\n\t\t\r\n\t\t// TODO: grab field list in thread in the background...\r\n\t\t//\r\n\t\ttry {\r\n\t\t\tinputFields = transMeta.getPrevStepFields(stepMeta);\r\n\t\t\twFieldList.setItems(inputFields.getFieldNames());\r\n\t\t} catch (KettleStepException ex) {\r\n\t\t\tnew ErrorDialog(shell, Messages.getString(\"ValidatorDialog.Exception.CantGetFieldsFromPreviousSteps.Title\"), Messages.getString(\"ValidatorDialog.Exception.CantGetFieldsFromPreviousSteps.Message\"), ex);\r\n\t\t}\r\n\t\t\r\n \t\tprops.setLook(wFieldList);\r\n \t\twFieldList.addSelectionListener(new SelectionAdapter() { \r\n\t\t\tpublic void widgetSelected(SelectionEvent event) {\r\n\t\t\t\tshowSelectedValidatorField(wFieldList.getSelection()[0]);\r\n\t\t\t}\r\n\t\t\r\n\t\t});\r\n\t\tFormData fdFieldList = new FormData();\r\n\t\tfdFieldList.left   = new FormAttachment(0, 0);\r\n\t\tfdFieldList.top    = new FormAttachment(wlFieldList, margin);\r\n\t\tfdFieldList.right  = new FormAttachment(middle, -margin);\r\n\t\tfdFieldList.bottom = new FormAttachment(wOK, -margin*2);\r\n\t\twFieldList.setLayoutData(fdFieldList);\r\n\t\t\r\n\t\t// Create a scrolled composite on the right side...\r\n\t\t//\r\n\t\tScrolledComposite wSComp = new ScrolledComposite(shell, SWT.H_SCROLL | SWT.V_SCROLL);\r\n\t\tprops.setLook(wSComp);\r\n\t\twSComp.setLayout(new FillLayout());\r\n\t\tFormData fdComp = new FormData();\r\n\t\tfdComp.left   = new FormAttachment(middle, 0);\r\n\t\tfdComp.top    = new FormAttachment(wlFieldList, margin);\r\n\t\tfdComp.right  = new FormAttachment(100, 0);\r\n\t\tfdComp.bottom = new FormAttachment(wOK, -margin*2);\r\n\t\twSComp.setLayoutData(fdComp);\r\n\t\t\r\n\t\tComposite wComp = new Composite(wSComp, SWT.NONE);\r\n\t\tprops.setLook(wComp);\r\n        FormLayout compLayout = new FormLayout();\r\n        compLayout.marginWidth  = 3;\r\n        compLayout.marginHeight = 3;\r\n        wComp.setLayout(compLayout);\r\n\t\t\r\n\t\t\r\n\t\t// Data type validations & constants masks...\r\n\t\t// \r\n\t\twgType = new Group(wComp, SWT.NONE);\r\n\t\tprops.setLook(wgType);\r\n\t\twgType.setText(Messages.getString(\"ValidatorDialog.TypeGroup.Label\"));\r\n\t\tFormLayout typeGroupLayout = new FormLayout();\r\n\t\ttypeGroupLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\ttypeGroupLayout.marginWidth = Const.FORM_MARGIN;\r\n\t\twgType.setLayout(typeGroupLayout);\r\n\t\tFormData fdType = new FormData();\r\n\t\tfdType.left = new FormAttachment(0, 0);\r\n\t\tfdType.right= new FormAttachment(100, 0);\r\n\t\tfdType.top  = new FormAttachment(0, 0);\r\n\t\twgType.setLayoutData(fdType);\r\n\t\t\r\n\t\t// Check for data type correctness?\r\n\t\t//\r\n\t\twlDataTypeVerified=new Label(wgType, SWT.RIGHT);\r\n\t\twlDataTypeVerified.setText(Messages.getString(\"ValidatorDialog.DataTypeVerified.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlDataTypeVerified);\r\n\t\tFormData fdldataTypeVerified = new FormData();\r\n\t\tfdldataTypeVerified.left = new FormAttachment(0, 0);\r\n\t\tfdldataTypeVerified.right= new FormAttachment(middle, -margin);\r\n\t\tfdldataTypeVerified.top  = new FormAttachment(wlFieldList, margin);\r\n\t\twlDataTypeVerified.setLayoutData(fdldataTypeVerified);\r\n\t\twDataTypeVerified=new Button(wgType, SWT.CHECK);\r\n \t\tprops.setLook(wDataTypeVerified);\r\n\t\tFormData fddataTypeVerified = new FormData();\r\n\t\tfddataTypeVerified.left = new FormAttachment(middle, margin);\r\n\t\tfddataTypeVerified.right= new FormAttachment(100, 0);\r\n\t\tfddataTypeVerified.top  = new FormAttachment(wlFieldList, margin);\r\n\t\twDataTypeVerified.setLayoutData(fddataTypeVerified);\r\n\r\n\t\t// Data type\r\n\t\t//\r\n\t\twlDataType=new Label(wgType, SWT.RIGHT);\r\n\t\twlDataType.setText(Messages.getString(\"ValidatorDialog.DataType.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlDataType);\r\n\t\tFormData fdlDataType = new FormData();\r\n\t\tfdlDataType.left = new FormAttachment(0, 0);\r\n\t\tfdlDataType.right= new FormAttachment(middle, -margin);\r\n\t\tfdlDataType.top  = new FormAttachment(wDataTypeVerified, margin);\r\n\t\twlDataType.setLayoutData(fdlDataType);\r\n\t\twDataType=new Combo(wgType, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n\t\twDataType.setItems(ValueMeta.getTypes());\r\n \t\tprops.setLook(wDataType);\r\n\t\tFormData fdDataType = new FormData();\r\n\t\tfdDataType.left = new FormAttachment(middle, margin);\r\n\t\tfdDataType.right= new FormAttachment(100, 0);\r\n\t\tfdDataType.top  = new FormAttachment(wDataTypeVerified, margin);\r\n\t\twDataType.setLayoutData(fdDataType);\r\n\t\t\r\n\t\t// Conversion mask\r\n\t\t//\r\n\t\twlConversionMask=new Label(wgType, SWT.RIGHT);\r\n\t\twlConversionMask.setText(Messages.getString(\"ValidatorDialog.ConversionMask.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlConversionMask);\r\n\t\tFormData fdlConversionMask = new FormData();\r\n\t\tfdlConversionMask.left = new FormAttachment(0, 0);\r\n\t\tfdlConversionMask.right= new FormAttachment(middle, -margin);\r\n\t\tfdlConversionMask.top  = new FormAttachment(wDataType, margin);\r\n\t\twlConversionMask.setLayoutData(fdlConversionMask);\r\n\t\twConversionMask=new Text(wgType, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wConversionMask);\r\n\t\tFormData fdConversionMask = new FormData();\r\n\t\tfdConversionMask.left = new FormAttachment(middle, margin);\r\n\t\tfdConversionMask.right= new FormAttachment(100, 0);\r\n\t\tfdConversionMask.top  = new FormAttachment(wDataType, margin);\r\n\t\twConversionMask.setLayoutData(fdConversionMask);\r\n\r\n\t\t\r\n\t\t// Decimal Symbol\r\n\t\t//\r\n\t\twlDecimalSymbol=new Label(wgType, SWT.RIGHT);\r\n\t\twlDecimalSymbol.setText(Messages.getString(\"ValidatorDialog.DecimalSymbol.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlDecimalSymbol);\r\n\t\tFormData fdlDecimalSymbol = new FormData();\r\n\t\tfdlDecimalSymbol.left = new FormAttachment(0, 0);\r\n\t\tfdlDecimalSymbol.right= new FormAttachment(middle, -margin);\r\n\t\tfdlDecimalSymbol.top  = new FormAttachment(wConversionMask, margin);\r\n\t\twlDecimalSymbol.setLayoutData(fdlDecimalSymbol);\r\n\t\twDecimalSymbol=new Text(wgType, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wDecimalSymbol);\r\n\t\tFormData fdDecimalSymbol = new FormData();\r\n\t\tfdDecimalSymbol.left = new FormAttachment(middle, margin);\r\n\t\tfdDecimalSymbol.right= new FormAttachment(100, 0);\r\n\t\tfdDecimalSymbol.top  = new FormAttachment(wConversionMask, margin);\r\n\t\twDecimalSymbol.setLayoutData(fdDecimalSymbol);\r\n\t\t\r\n\t\t// Grouping Symbol\r\n\t\t//\r\n\t\twlGroupingSymbol=new Label(wgType, SWT.RIGHT);\r\n\t\twlGroupingSymbol.setText(Messages.getString(\"ValidatorDialog.GroupingSymbol.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlGroupingSymbol);\r\n\t\tFormData fdlGroupingSymbol = new FormData();\r\n\t\tfdlGroupingSymbol.left = new FormAttachment(0, 0);\r\n\t\tfdlGroupingSymbol.right= new FormAttachment(middle, -margin);\r\n\t\tfdlGroupingSymbol.top  = new FormAttachment(wDecimalSymbol, margin);\r\n\t\twlGroupingSymbol.setLayoutData(fdlGroupingSymbol);\r\n\t\twGroupingSymbol=new Text(wgType, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wGroupingSymbol);\r\n\t\tFormData fdGroupingSymbol = new FormData();\r\n\t\tfdGroupingSymbol.left = new FormAttachment(middle, margin);\r\n\t\tfdGroupingSymbol.right= new FormAttachment(100, 0);\r\n\t\tfdGroupingSymbol.top  = new FormAttachment(wDecimalSymbol, margin);\r\n\t\twGroupingSymbol.setLayoutData(fdGroupingSymbol);\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t///////////////////////////////////////////////////////////////////////////////////////////////////\r\n\t\t//\r\n\t\t// The data group...\r\n\t\t//\r\n\t\t//\r\n\t\twgData = new Group(wComp, SWT.NONE);\r\n\t\tprops.setLook(wgData);\r\n\t\twgData.setText(Messages.getString(\"ValidatorDialog.DataGroup.Label\"));\r\n\t\tFormLayout dataGroupLayout = new FormLayout();\r\n\t\tdataGroupLayout.marginHeight = Const.FORM_MARGIN;\r\n\t\tdataGroupLayout.marginWidth = Const.FORM_MARGIN;\r\n\t\twgData.setLayout(dataGroupLayout);\r\n\t\tFormData fdData = new FormData();\r\n\t\tfdData.left = new FormAttachment(0, 0);\r\n\t\tfdData.right= new FormAttachment(100, 0);\r\n\t\tfdData.top  = new FormAttachment(wgType, margin);\r\n\t\twgData.setLayoutData(fdData);\r\n\t\t\r\n\t\t// Check for null?\r\n\t\t//\r\n\t\twlNullAllowed=new Label(wgData, SWT.RIGHT);\r\n\t\twlNullAllowed.setText(Messages.getString(\"ValidatorDialog.NullAllowed.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlNullAllowed);\r\n\t\tFormData fdlNullAllowed = new FormData();\r\n\t\tfdlNullAllowed.left = new FormAttachment(0, 0);\r\n\t\tfdlNullAllowed.right= new FormAttachment(middle, -margin);\r\n\t\tfdlNullAllowed.top  = new FormAttachment(wlFieldList, margin);\r\n\t\twlNullAllowed.setLayoutData(fdlNullAllowed);\r\n\t\twNullAllowed=new Button(wgData, SWT.CHECK);\r\n \t\tprops.setLook(wNullAllowed);\r\n\t\tFormData fdNullAllowed = new FormData();\r\n\t\tfdNullAllowed.left = new FormAttachment(middle, margin);\r\n\t\tfdNullAllowed.right= new FormAttachment(100, 0);\r\n\t\tfdNullAllowed.top  = new FormAttachment(wlFieldList, margin);\r\n\t\twNullAllowed.setLayoutData(fdNullAllowed);\r\n\r\n\t\t// Maximum length\r\n\t\t//\r\n\t\twlMaxLength=new Label(wgData, SWT.RIGHT);\r\n\t\twlMaxLength.setText(Messages.getString(\"ValidatorDialog.MaxLength.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlMaxLength);\r\n\t\tFormData fdlMaxLength = new FormData();\r\n\t\tfdlMaxLength.left = new FormAttachment(0, 0);\r\n\t\tfdlMaxLength.right= new FormAttachment(middle, -margin);\r\n\t\tfdlMaxLength.top  = new FormAttachment(wNullAllowed, margin);\r\n\t\twlMaxLength.setLayoutData(fdlMaxLength);\r\n\t\twMaxLength=new Text(wgData, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wMaxLength);\r\n\t\tFormData fdMaxLength = new FormData();\r\n\t\tfdMaxLength.left = new FormAttachment(middle, margin);\r\n\t\tfdMaxLength.right= new FormAttachment(100, 0);\r\n\t\tfdMaxLength.top  = new FormAttachment(wNullAllowed, margin);\r\n\t\twMaxLength.setLayoutData(fdMaxLength);\r\n\t\t\r\n\t\t// Minimum length\r\n\t\t//\r\n\t\twlMinLength=new Label(wgData, SWT.RIGHT);\r\n\t\twlMinLength.setText(Messages.getString(\"ValidatorDialog.MinLength.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlMinLength);\r\n\t\tFormData fdlMinLength = new FormData();\r\n\t\tfdlMinLength.left = new FormAttachment(0, 0);\r\n\t\tfdlMinLength.right= new FormAttachment(middle, -margin);\r\n\t\tfdlMinLength.top  = new FormAttachment(wMaxLength, margin);\r\n\t\twlMinLength.setLayoutData(fdlMinLength);\r\n\t\twMinLength=new Text(wgData, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wMinLength);\r\n\t\tFormData fdMinLength = new FormData();\r\n\t\tfdMinLength.left = new FormAttachment(middle, margin);\r\n\t\tfdMinLength.right= new FormAttachment(100, 0);\r\n\t\tfdMinLength.top  = new FormAttachment(wMaxLength, margin);\r\n\t\twMinLength.setLayoutData(fdMinLength);\r\n\r\n\t\t// Maximum value\r\n\t\t//\r\n\t\twlMaxValue=new Label(wgData, SWT.RIGHT);\r\n\t\twlMaxValue.setText(Messages.getString(\"ValidatorDialog.MaxValue.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlMaxValue);\r\n\t\tFormData fdlMaxValue = new FormData();\r\n\t\tfdlMaxValue.left = new FormAttachment(0, 0);\r\n\t\tfdlMaxValue.right= new FormAttachment(middle, -margin);\r\n\t\tfdlMaxValue.top  = new FormAttachment(wMinLength, margin);\r\n\t\twlMaxValue.setLayoutData(fdlMaxValue);\r\n\t\twMaxValue=new Text(wgData, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wMaxValue);\r\n\t\tFormData fdMaxValue = new FormData();\r\n\t\tfdMaxValue.left = new FormAttachment(middle, margin);\r\n\t\tfdMaxValue.right= new FormAttachment(100, 0);\r\n\t\tfdMaxValue.top  = new FormAttachment(wMinLength, margin);\r\n\t\twMaxValue.setLayoutData(fdMaxValue);\r\n\t\t\r\n\t\t// Minimum value\r\n\t\t//\r\n\t\twlMinValue=new Label(wgData, SWT.RIGHT);\r\n\t\twlMinValue.setText(Messages.getString(\"ValidatorDialog.MinValue.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlMinValue);\r\n\t\tFormData fdlMinValue = new FormData();\r\n\t\tfdlMinValue.left = new FormAttachment(0, 0);\r\n\t\tfdlMinValue.right= new FormAttachment(middle, -margin);\r\n\t\tfdlMinValue.top  = new FormAttachment(wMaxValue, margin);\r\n\t\twlMinValue.setLayoutData(fdlMinValue);\r\n\t\twMinValue=new Text(wgData, SWT.SINGLE | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wMinValue);\r\n\t\tFormData fdMinValue = new FormData();\r\n\t\tfdMinValue.left = new FormAttachment(middle, margin);\r\n\t\tfdMinValue.right= new FormAttachment(100, 0);\r\n\t\tfdMinValue.top  = new FormAttachment(wMaxValue, margin);\r\n\t\twMinValue.setLayoutData(fdMinValue);\r\n\t\t\r\n\t\t// Allowed values: a list box.\r\n\t\t//\r\n\t\t// Add an entry\r\n\t\twbAddAllowed = new Button(wgData, SWT.PUSH);\r\n\t\t// props.setLook(wbAddAllowed);\r\n\t\twbAddAllowed.setText(Messages.getString(\"ValidatorDialog.ButtonAddAllowed.Label\")); //$NON-NLS-1$\r\n\t\tFormData fdbAddAllowed = new FormData();\r\n\t\tfdbAddAllowed.right  = new FormAttachment(100, 0);\r\n\t\tfdbAddAllowed.top    = new FormAttachment(wMinValue, margin);\r\n\t\twbAddAllowed.setLayoutData(fdbAddAllowed);\r\n\t\twbAddAllowed.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { addAllowedValue(); } });\r\n\r\n\t\t// Remove an entry\r\n\t\twbRemoveAllowed = new Button(wgData, SWT.PUSH);\r\n\t\t// props.setLook(wbRemoveAllowed);\r\n\t\twbRemoveAllowed.setText(Messages.getString(\"ValidatorDialog.ButtonRemoveAllowed.Label\")); //$NON-NLS-1$\r\n\t\tFormData fdbRemoveAllowed = new FormData();\r\n\t\tfdbRemoveAllowed.right  = new FormAttachment(100, 0);\r\n\t\tfdbRemoveAllowed.top    = new FormAttachment(wbAddAllowed, margin);\r\n\t\twbRemoveAllowed.setLayoutData(fdbRemoveAllowed);\r\n\t\twbRemoveAllowed.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { removeAllowedValue(); } });\r\n\r\n\t\t\r\n\t\twlAllowedValues=new Label(wgData, SWT.RIGHT);\r\n\t\twlAllowedValues.setText(Messages.getString(\"ValidatorDialog.AllowedValues.Label\")); //$NON-NLS-1$\r\n \t\tprops.setLook(wlAllowedValues);\r\n\t\tFormData fdlAllowedValues = new FormData();\r\n\t\tfdlAllowedValues.left = new FormAttachment(0, 0);\r\n\t\tfdlAllowedValues.right= new FormAttachment(middle, -margin);\r\n\t\tfdlAllowedValues.top  = new FormAttachment(wMinValue, margin);\r\n\t\twlAllowedValues.setLayoutData(fdlAllowedValues);\r\n\t\twAllowedValues=new List(wgData, SWT.MULTI | SWT.LEFT | SWT.BORDER);\r\n \t\tprops.setLook(wAllowedValues);\r\n \t\tFormData fdAllowedValues = new FormData();\r\n \t\tfdAllowedValues.left   = new FormAttachment(middle, margin);\r\n \t\tfdAllowedValues.right  = new FormAttachment(wbRemoveAllowed, -margin);\r\n \t\tfdAllowedValues.top    = new FormAttachment(wMinValue, margin);\r\n \t\tfdAllowedValues.bottom = new FormAttachment(wMinValue, 200);\r\n \t\twAllowedValues.setLayoutData(fdAllowedValues);\r\n\r\n\r\n\r\n\t\t\r\n        wComp.pack();\r\n        Rectangle bounds = wComp.getBounds();\r\n\t\t\r\n        wSComp.setContent(wComp);\r\n        wSComp.setExpandHorizontal(true);\r\n        wSComp.setExpandVertical(true);\r\n        wSComp.setMinWidth(bounds.width);\r\n        wSComp.setMinHeight(bounds.height);\r\n\n\n\t\t// Add listeners\n\t\tlsCancel   = new Listener() { public void handleEvent(Event e) { cancel(); } };\n\t\tlsOK       = new Listener() { public void handleEvent(Event e) { ok();     } };\n\t\t\n\t\twCancel.addListener(SWT.Selection, lsCancel);\n\t\twOK.addListener    (SWT.Selection, lsOK    );\n\t\t\n\t\tlsDef=new SelectionAdapter() { public void widgetDefaultSelected(SelectionEvent e) { ok(); } };\n\t\t\n\t\twStepname.addSelectionListener( lsDef );\n\t\t\n\t\t// Detect X or ALT-F4 or something that kills this window...\n\t\tshell.addShellListener(\tnew ShellAdapter() { public void shellClosed(ShellEvent e) { cancel(); } } );\n\n\n\t\t// Set the shell size, based upon previous time...\n\t\tsetSize();\n\t\t\n\t\tgetData();\n\t\tinput.setChanged(changed);\n\t\n\t\tshell.open();\n\t\twhile (!shell.isDisposed())\n\t\t{\n\t\t\t\tif (!display.readAndDispatch()) display.sleep();\n\t\t}\n\t\treturn stepname;\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String getXML() {\n\t\treturn null; // TODO FIXME\n\t}","id":74549,"modified_method":"public String getXML() {\n\t\tStringBuffer xml = new StringBuffer();\n\t\t\n\t\txml.append(XMLHandler.openTag(XML_TAG));\n\t\t\n\t\txml.append(XMLHandler.addTagValue(\"name\", name));\n\t\txml.append(XMLHandler.addTagValue(\"max_length\", maximumLength));\n\t\txml.append(XMLHandler.addTagValue(\"max_limit\", limitingToMaximum));\n\t\txml.append(XMLHandler.addTagValue(\"min_length\", minimumLength));\n\t\txml.append(XMLHandler.addTagValue(\"min_pad\", paddedToMinimum));\n\t\txml.append(XMLHandler.addTagValue(\"pad_string\", paddingString));\n\n\t\txml.append(XMLHandler.addTagValue(\"null_allowed\", nullAllowed));\n\n\t\txml.append(XMLHandler.addTagValue(\"data_type\", ValueMeta.getTypeDesc(dataType)));\n\t\txml.append(XMLHandler.addTagValue(\"data_type_verified\", dataTypeVerified));\n\t\txml.append(XMLHandler.addTagValue(\"conversion_mask\", conversionMask));\n\t\txml.append(XMLHandler.addTagValue(\"decimal_symbol\", decimalSymbol));\n\t\txml.append(XMLHandler.addTagValue(\"grouping_symbol\", groupingSymbol));\n\n\t\txml.append(XMLHandler.addTagValue(\"max_value\", maximumValue));\n\t\txml.append(XMLHandler.addTagValue(\"min_value\", minimumValue));\n\t\t\n\t\tif (allowedValues!=null) {\n\t\t\txml.append(XMLHandler.openTag(XML_TAG_ALLOWED));\n\t\t\t\t\n\t\t\tfor (String allowedValue : allowedValues) {\n\t\t\t\txml.append(XMLHandler.addTagValue(\"value\", allowedValue));\n\t\t\t}\n\t\t\txml.append(XMLHandler.closeTag(XML_TAG_ALLOWED));\n\t\t}\n\n\t\txml.append(XMLHandler.closeTag(XML_TAG));\n\t\t\n\t\treturn xml.toString();\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public ValidatorField(Node calcnode) {\n\t\tthis();\n\t\t// TODO FIXME\n\t}","id":74550,"modified_method":"public ValidatorField(Node calcnode) {\n\t\tthis();\n\n\t\tname = XMLHandler.getTagValue(calcnode, \"name\");\n\t\tmaximumLength = Const.toInt(XMLHandler.getTagValue(calcnode, \"max_length\"), -1);\n\t\tlimitingToMaximum = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(calcnode, \"max_limit\"));\n\t\tminimumLength = Const.toInt(XMLHandler.getTagValue(calcnode, \"min_length\"), -1);\n\t\tpaddedToMinimum = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(calcnode, \"min_pad\"));\n\t\tpaddingString = XMLHandler.getTagValue(calcnode, \"pad_string\");\n\n\t\tnullAllowed = \"Y\".equalsIgnoreCase(XMLHandler.getTagValue(calcnode, \"null_allowed\"));\n\n\t\tdataType = ValueMeta.getType( XMLHandler.getTagValue(calcnode, \"data_type\") );\n\t\tdataTypeVerified = \"Y\".equalsIgnoreCase( XMLHandler.getTagValue(calcnode, \"data_type_verified\"));\n\t\tconversionMask = XMLHandler.getTagValue(calcnode, \"conversion_mask\");\n\t\tdecimalSymbol = XMLHandler.getTagValue(calcnode, \"decimal_symbol\");\n\t\tgroupingSymbol = XMLHandler.getTagValue(calcnode, \"grouping_symbol\");\n\n\t\tminimumValue = XMLHandler.getTagValue(calcnode, \"min_value\");\n\t\tmaximumValue = XMLHandler.getTagValue(calcnode, \"max_value\");\n\n\t\tNode allowedValuesNode = XMLHandler.getSubNode(calcnode, XML_TAG_ALLOWED);\n\t\tint nrValues = XMLHandler.countNodes(calcnode, \"value\");\n\t\tallowedValues = new String[nrValues];\n\t\tfor (int i=0;i<nrValues;i++) {\n\t\t\tNode allowedNode = XMLHandler.getSubNodeByNr(allowedValuesNode, \"value\", i);\n\t\t\tallowedValues[i] = XMLHandler.getNodeValue(allowedNode);\n\t\t}\n\t}","commit_id":"eeef00f00758a843ab89d1fcde6a527d5e259323","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public MapPaintAction(StyleSource style) {\n            super(style.getDisplayString(), style.icon,\n                    tr(\"Select the map painting styles\"), null, style.icon != null);\n            if (style.icon == null) {\n                putValue(\"toolbar\", \"mappaint/\" + style.getDisplayString());\n                Main.toolbar.register(this);\n            }\n            this.button = new JCheckBoxMenuItem(this);\n            this.style = style;\n            updateButton();\n        }","id":74551,"modified_method":"public MapPaintAction(StyleSource style) {\n            super(style.getDisplayString(), style.icon,\n                    tr(\"Select the map painting styles\"), null, style.icon != null);\n            if (style.icon == null) {\n                putValue(\"toolbar\", \"mappaint/\" + style.getDisplayString());\n                Main.toolbar.register(this);\n            }\n            this.button = new StayOpenCheckBoxMenuItem(this);\n            this.style = style;\n            updateButton();\n        }","commit_id":"37de90cba9ca4e5f01ae85283d48f6398e584cad","url":"https://github.com/openstreetmap/josm"},{"original_method":"@Override\n    public void mapPaintStylesUpdated() {\n        final Set<String> actionsToRemove = new HashSet<String>(actions.keySet());\n        for (StyleSource style : MapPaintStyles.getStyles().getStyleSources()) {\n            final String k = style.getDisplayString();\n            MapPaintAction a = actions.get(k);\n            if (a == null) {\n                a = new MapPaintAction(style);\n                add(a.getButton());\n                actions.put(k, a);\n            } else {\n                a.updateButton();\n                actionsToRemove.remove(k);\n            }\n        }\n        for (String k : actionsToRemove) {\n            final MapPaintAction a = actions.get(k);\n            if (a != null) {\n                remove(a.getButton());\n                actions.remove(k);\n            }\n        }\n    }","id":74552,"modified_method":"@Override\n    public void mapPaintStylesUpdated() {\n        removeAll();\n        for (StyleSource style : MapPaintStyles.getStyles().getStyleSources()) {\n            final String k = style.getDisplayString();\n            MapPaintAction a = actions.get(k);\n            if (a == null) {\n                actions.put(k, a = new MapPaintAction(style));\n                add(a.getButton());\n            } else {\n                add(a.getButton());\n                a.updateButton();\n            }\n        }\n        addSeparator();\n        add(mapPaintPreferencesAction);\n    }","commit_id":"37de90cba9ca4e5f01ae85283d48f6398e584cad","url":"https://github.com/openstreetmap/josm"},{"original_method":"private K primCacheObject(K canonic, K toCache) {\n      if (transitionalCache.putIfAbsent(canonic, canonic) == null) {\n        K cached;\n        cached = firstLevelCache.putIfAbsent(canonic, canonic);\n        if (cached != null) {\n          return cached;\n        }\n\n        // current thread has a mutex on 'canonic'\n        firstLevelQueue.add(canonic);\n\n        if (roomLeftFirstLevel.decrementAndGet() <= 0) {\n\n          K toRemove = firstLevelQueue.peek();\n          assert toRemove != null;\n\n          if (transitionalCache.putIfAbsent(toRemove, toRemove) == null) {\n            if (firstLevelQueue.remove(toRemove)) {\n              boolean removed = firstLevelCache.remove(toRemove, toRemove);\n              assert removed;\n              roomLeftFirstLevel.incrementAndGet();\n            }\n            assert !firstLevelCache.containsKey(toRemove);\n\n            boolean removed = transitionalCache.remove(toRemove, toRemove);\n            assert removed;\n          }\n\n        }\n\n        boolean removed = transitionalCache.remove(canonic, canonic);\n        assert removed;\n      }\n\n      return canonic;\n    }","id":74553,"modified_method":"private K primCacheObject(K canonic, K toCache) {\n      if (transitionalCache.putIfAbsent(canonic, canonic) == null) {\n        K alreadyCached = firstLevelCache.putIfAbsent(canonic, canonic);\n\n        if (alreadyCached != null) {\n          boolean removed = transitionalCache.remove(canonic, toCache);\n          assert removed;\n\n          return alreadyCached;\n        }\n\n        // current thread has a mutex on 'canonic'\n        firstLevelQueue.add(canonic);\n\n        if (roomLeftFirstLevel.decrementAndGet() <= 0) {\n          K toRemove = firstLevelQueue.poll();\n          assert toRemove != null;\n\n          if (transitionalCache.putIfAbsent(toRemove, toRemove) == null) {\n            if (firstLevelCache.remove(toRemove, toRemove)) {\n              roomLeftFirstLevel.incrementAndGet();\n            }\n            transitionalCache.remove(toRemove, toRemove);\n          }\n          else {\n            firstLevelQueue.add(toRemove);\n          }\n        }\n\n        transitionalCache.remove(canonic, canonic);\n      }\n\n      return canonic;\n    }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private K primPromote(K toCache, K cached) {\n      K transit = transitionalCache.putIfAbsent(cached, cached);\n      if (transit != null) {\n        return transit;\n      }\n\n      // current thread has a mutex on 'cached'\n      K alreadyPromoted = secondLevelCache.putIfAbsent(cached, cached);\n      if (alreadyPromoted != null) {\n        boolean removed = transitionalCache.remove(cached, toCache);\n        assert removed;\n\n        return alreadyPromoted;\n      }\n      assert !secondLevelQueue.contains(cached);\n      secondLevelQueue.add(cached);\n\n      if (firstLevelQueue.remove(cached)) {\n        boolean removed = firstLevelCache.remove(cached, toCache);\n        assert removed;\n        int roomLeft = roomLeftFirstLevel.incrementAndGet();\n//        assert roomLeft >= 0;\n      }\n      assert !firstLevelCache.containsKey(cached);\n\n      if (roomLeftSecondLevel.decrementAndGet() <= 0) {\n\n        K toRemove = secondLevelQueue.peek();\n        assert toRemove != null;\n\n        if (transitionalCache.putIfAbsent(toRemove, toRemove) == null) {\n\n          if (secondLevelQueue.remove(toRemove)) {\n            boolean removed = secondLevelCache.remove(toRemove, toRemove);\n            assert removed;\n            roomLeftSecondLevel.incrementAndGet();\n          }\n          assert !secondLevelCache.containsKey(toRemove);\n\n          boolean removed = transitionalCache.remove(toRemove, toRemove);\n          assert removed;\n        }\n\n        if (!secondLevelCache.containsKey(toRemove)) {\n          primCacheObject(toRemove, toCache);\n        }\n      }\n\n      boolean removed = transitionalCache.remove(cached, toCache);\n      assert removed;\n\n      return cached;\n    }","id":74554,"modified_method":"private K primPromote(K toCache, K cached) {\n      K transit = transitionalCache.putIfAbsent(cached, cached);\n      if (transit != null) {\n        return transit;\n      }\n\n      // current thread has a mutex on 'cached'\n      K alreadyPromoted = secondLevelCache.putIfAbsent(cached, cached);\n      if (alreadyPromoted != null) {\n        boolean removed = transitionalCache.remove(cached, toCache);\n        assert removed;\n\n        return alreadyPromoted;\n      }\n      secondLevelQueue.add(cached);\n\n      if (firstLevelCache.remove(cached, toCache)) {\n        roomLeftFirstLevel.incrementAndGet();\n      }\n\n      if (roomLeftSecondLevel.decrementAndGet() <= 0) {\n        K toDemote = secondLevelQueue.poll();\n        assert toDemote != null;\n\n        primCacheObject(toDemote, toDemote);\n\n        if (transitionalCache.putIfAbsent(toDemote, toDemote) == null) {\n          if (secondLevelCache.remove(toDemote, toDemote)) {\n            roomLeftSecondLevel.incrementAndGet();\n          }\n          transitionalCache.remove(toDemote, toDemote);\n        }\n        else {\n          secondLevelQueue.add(toDemote);\n        }\n      }\n\n      transitionalCache.remove(cached, toCache);\n      return cached;\n    }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private void runInParallel (int maxThreads, final Runnable runnable) {\n    int threads = maxThreads;\n    final RuntimeException[] rex = new RuntimeException[maxThreads];\n    final CyclicBarrier cbstart = new CyclicBarrier(threads);\n    final CyclicBarrier cbend = new CyclicBarrier(threads+1);\n\n    while (--threads>=0) {\n      final int reidx = threads;\n      new Thread (new Runnable() {\n        @Override\n        public void run() {\n          try {\n            cbstart.await();\n          }\n          catch (InterruptedException ignore) {}\n          catch (BrokenBarrierException ignore) {}\n\n          try {\n            runnable.run();\n          }\n          catch (RuntimeException re) {\n            rex[reidx] = re;\n          }\n          catch (Error er) {\n            rex[reidx] = new RuntimeException(er);\n          }\n\n          try {\n            cbend.await();\n          }\n          catch (InterruptedException ignore) {}\n          catch (BrokenBarrierException ignore) {}\n        }\n      }).start ();\n    }\n\n    try {\n      cbend.await();\n    }\n    catch (InterruptedException ignore) {}\n    catch (BrokenBarrierException ignore) {}\n\n    // propagate exceptions\n    List<RuntimeException> rexlist = new ArrayList<RuntimeException>();\n    for (int i=rex.length-1; i>=0; --i) {\n      if (rex[i] != null) {\n        rexlist.add(rex[i]);\n      }\n    }\n    if (rexlist.size() == 1) {\n      throw rexlist.get(0);\n    }\n    if (rexlist.size() > 1) {\n      for(RuntimeException re: rexlist) {\n        re.printStackTrace();\n      }\n      throw new CompositeRuntimeException(rexlist);\n    }\n  }","id":74555,"modified_method":"private void runInParallel (int maxThreads, final Runnable runnable) {\n    int threads = maxThreads;\n    final RuntimeException[] rex = new RuntimeException[maxThreads];\n    final CyclicBarrier cbstart = new CyclicBarrier(threads);\n    final CyclicBarrier cbend = new CyclicBarrier(threads+1);\n\n    while (--threads>=0) {\n      final int reidx = threads;\n      new Thread (new Runnable() {\n        public void run() {\n          try {\n            cbstart.await();\n          }\n          catch (InterruptedException ignore) {}\n          catch (BrokenBarrierException ignore) {}\n\n          try {\n            runnable.run();\n          }\n          catch (RuntimeException re) {\n            rex[reidx] = re;\n          }\n          catch (Error er) {\n            rex[reidx] = new RuntimeException(er);\n          }\n\n          try {\n            cbend.await();\n          }\n          catch (InterruptedException ignore) {}\n          catch (BrokenBarrierException ignore) {}\n        }\n      }).start ();\n    }\n\n    try {\n      cbend.await();\n    }\n    catch (InterruptedException ignore) {}\n    catch (BrokenBarrierException ignore) {}\n\n    // propagate exceptions\n    List<RuntimeException> rexlist = new ArrayList<RuntimeException>();\n    for (int i=rex.length-1; i>=0; --i) {\n      if (rex[i] != null) {\n        rexlist.add(rex[i]);\n      }\n    }\n    if (rexlist.size() == 1) {\n      throw rexlist.get(0);\n    }\n    if (rexlist.size() > 1) {\n      for(RuntimeException re: rexlist) {\n        re.printStackTrace();\n      }\n      throw new CompositeRuntimeException(rexlist);\n    }\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void stressTestWithSimilarStrings() {\n    final int maxObjects = 5000;\n    final int maxThreads = Runtime.getRuntime().availableProcessors() * 20;\n    final int maxRepetitions = 100000;\n\n    long refTime = computeMedian(new LongProducer() {\n      @Override\n      public long produce() {\n        return computePerformanceBenchmark(maxThreads);\n      }\n    });\n\n    long time = computeMedian(new LongProducer() {\n      @Override\n      public long produce() {\n        return loadTestWithSimilarStrings(maxObjects, maxThreads, maxRepetitions);\n      }\n    });\n\n    double ratio = time / (double) refTime;\n\n    Assert.assertTrue(\"Interner perfomance is not within bounds: \" + ratio, 0.45 < ratio && ratio < 1.95);\n  }","id":74556,"modified_method":"@Test\n  public void stressTestWithSimilarStrings() {\n    final int maxObjects = 5000;\n    final int maxThreads = Runtime.getRuntime().availableProcessors() * 20;\n    final int maxRepetitions = 100000;\n\n    long[] refTime = computeMedian(new LongProducer() {\n      public long[] produce() {\n        return new long []{computePerformanceBenchmark(maxThreads)};\n      }\n    });\n\n    long[] stats = computeMedian(new LongProducer() {\n      public long[] produce() {\n        long baseLine = computeUsedHeap();\n        final Interner interner = new Interner(maxObjects);\n        final List<List<String>> listOfLists = new ArrayList<List<String>>();\n        long time = loadTestWithSimilarStrings(Collections.synchronizedList(listOfLists), interner, maxObjects, maxThreads, maxRepetitions);\n\n        long used = computeUsedHeap() - baseLine;\n        int totalSize = 0;\n        for (int idx = listOfLists.size()-1; idx >= 0; --idx) {\n          totalSize += listOfLists.get(idx).size();\n        }\n        return new long[] {time, interner.size(), used, totalSize};\n      }\n    });\n\n    double perfRatio = stats[0] / (double) refTime[0];\n    Assert.assertTrue(\"Interner perfomance is not within bounds: \"+perfRatio,  0.45 < perfRatio && perfRatio < 1.95);\n\n    double memRatio = stats[2] / (double) stats[3] / 4. / 50.;\n    Assert.assertTrue(\"Interner memory consumption is not within bounds: \"+memRatio,  0.65 < memRatio && memRatio < 1.35);\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private long computeMedian (LongProducer lp) {\n    List<Long> times = new ArrayList<Long>();\n    for (int count=8; count>0; --count) {\n      times.add(lp.produce());\n    }\n    Collections.sort(times);\n    int middle = times.size()/2;\n    return (long) (times.get(middle-1)+times.get(middle))/2;\n  }","id":74557,"modified_method":"private long[] computeMedian (LongProducer lp) {\n    List<long[]> data = new ArrayList<long[]>();\n    for (int count=8; count>0; --count) {\n      data.add(lp.produce());\n    }\n\n    List<Long> medians = new ArrayList<Long>();\nwith_samples:\n    for (int i=0; ;++i) {\n      List<Long> samples = new ArrayList<Long>();\n      for (long[] smpl: data) {\n        if (smpl.length <= i) { break with_samples; }\n        samples.add(smpl[i]);\n      }\n      Collections.sort(samples);\n      int middle = samples.size()/2;\n      medians.add((samples.get(middle-1)+samples.get(middle))/2);\n    }\n    long[] retVal = new long[medians.size()];\n    for (int i=0; i<medians.size();i++) {\n      retVal[i] = medians.get(i);\n    }\n    return retVal;\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private long loadTestWithOverflow(final int maxObjects, final int maxThreads, final int maxRepetitions) {\n    final Interner interner = new Interner(maxObjects);\n    final long start = System.currentTimeMillis();\n\n    runInParallel(maxThreads, new Runnable (){\n        @Override\n        public void run() {\n          Random rnd = new Random ();\n          StringBuilder sb = new StringBuilder();\n          List<String> list = new ArrayList<String>();\n          for (int count=maxObjects*2; count > 0; --count) {\n            sb.setLength(0);\n            for (int size = Math.max (5, Math.min(200, (int) (rnd.nextGaussian() * 30 + 50))); size > 0; --size) {\n              sb.append ((char)(rnd.nextInt(127-32)+32));\n            }\n            list.add (interner.intern(sb.toString()));\n          }\n\n          for (int count= maxRepetitions; count > 0; --count) {\n            String s = list.get(rnd.nextInt(list.size()));\n            Assert.assertEquals(s, interner.intern(s));\n          }\n\n        }\n      });\n\n    return System.currentTimeMillis() - start;\n  }","id":74558,"modified_method":"private long loadTestWithOverflow(final List<List<String>> listOfLists, final Interner interner, final int maxObjects, final int maxThreads, final int maxRepetitions) {\n    final long start = System.currentTimeMillis();\n\n    runInParallel(maxThreads, new Runnable (){\n        public void run() {\n          Random rnd = new Random ();\n          StringBuilder sb = new StringBuilder();\n          List<String> list = new ArrayList<String>();\n          listOfLists.add(list);\n          for (int count=maxObjects*2; count > 0; --count) {\n            sb.setLength(0);\n            for (int size = Math.max (5, Math.min(200, (int) (rnd.nextGaussian() * 30 + 50))); size > 0; --size) {\n              sb.append ((char)(rnd.nextInt(127-32)+32));\n            }\n            list.add (interner.intern(sb.toString()));\n          }\n\n          for (int count= maxRepetitions; count > 0; --count) {\n            String s = list.get(rnd.nextInt(list.size()));\n            Assert.assertEquals(s, interner.intern(s));\n          }\n\n        }\n      });\n\n    return System.currentTimeMillis() - start;\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void cacheRandomStrings() {\n    final int maxObjects = 20000;\n    final int maxThreads = Runtime.getRuntime().availableProcessors()*3;\n    final int maxRepetitions = 1000000;\n\n    long refTime = computeMedian(new LongProducer() {\n      @Override\n      public long produce() {\n        return computePerformanceBenchmark(maxThreads);\n      }\n    });\n\n    long time = computeMedian(new LongProducer() {\n      @Override\n      public long produce() {\n        return loadTestNoOverflow(maxObjects, maxThreads, maxRepetitions);\n      }\n    });\n\n    double ratio = time / (double) refTime;\n\n    Assert.assertTrue(\"Interner perfomance is not within bounds: \"+ratio,  0.45 < ratio && ratio < 1.95);\n  }","id":74559,"modified_method":"@Test\n  public void cacheRandomStrings() {\n    final int maxObjects = 20000;\n    final int maxThreads = Runtime.getRuntime().availableProcessors()*3;\n    final int maxRepetitions = 2000000;\n\n    long[] refTime = computeMedian(new LongProducer() {\n      public long[] produce() {\n        return new long[] {computePerformanceBenchmark(maxThreads)};\n      }\n    });\n\n    long[] stats = computeMedian(new LongProducer() {\n      public long[] produce() {\n        long baseLine = computeUsedHeap();\n        final Interner interner = new Interner(maxObjects);\n        final List<List<String>> listOfLists = new ArrayList<List<String>>();\n\n        long time = loadTestNoOverflow(Collections.synchronizedList(listOfLists), interner, maxObjects, maxThreads, maxRepetitions);\n\n        long used = computeUsedHeap() - baseLine;\n        int totalSize = 0;\n        for (int idx = listOfLists.size()-1; idx >= 0; --idx) {\n          totalSize += listOfLists.get(idx).size();\n        }\n        return new long[] {time, interner.size(), used, totalSize};\n      }\n    });\n\n    double perfRatio = stats[0] / (double) refTime[0];\n    Assert.assertTrue(\"Interner perfomance is not within bounds: \"+perfRatio,  0.45 < perfRatio && perfRatio < 1.95);\n\n    double memRatio = stats[2] / (double) stats[3] / 4. / 50.;\n    Assert.assertTrue(\"Interner memory consumption is not within bounds: \"+memRatio,  0.65 < memRatio && memRatio < 1.35);\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private long loadTestWithSimilarStrings(final int maxObjects, final int maxThreads, final int maxRepetitions) {\n    final Interner interner = new Interner(maxObjects);\n    final long start = System.currentTimeMillis();\n\n    final long seed = System.currentTimeMillis();\n    runInParallel(maxThreads, new Runnable (){\n        @Override\n        public void run() {\n          Random rnd = new Random (seed);\n          StringBuilder sb = new StringBuilder();\n          List<String> list = new ArrayList<String>();\n          for (int count=maxObjects*2; count > 0; --count) {\n            sb.setLength(0);\n            for (int size = Math.max (5, Math.min(200, (int) (rnd.nextGaussian() * 30 + 50))); size > 0; --size) {\n              sb.append ((char)(rnd.nextInt(127-32)+32));\n            }\n            list.add (/*interner.intern*/(sb.toString()));\n          }\n\n          rnd = new Random ();\n          for (int count= maxRepetitions; count > 0; --count) {\n            String s = list.get(rnd.nextInt(list.size()));\n            Assert.assertEquals(s, interner.intern(s));\n          }\n\n        }\n      });\n\n    return System.currentTimeMillis() - start;\n  }","id":74560,"modified_method":"private long loadTestWithSimilarStrings(final List<List<String>> listOfLists, final Interner interner, final int maxObjects, final int maxThreads, final int maxRepetitions) {\n    final long start = System.currentTimeMillis();\n\n    final long seed = System.currentTimeMillis();\n    runInParallel(maxThreads, new Runnable (){\n        public void run() {\n          Random rnd = new Random (seed);\n          StringBuilder sb = new StringBuilder();\n          List<String> list = new ArrayList<String>();\n          listOfLists.add(list);\n          for (int count=maxObjects*2; count > 0; --count) {\n            sb.setLength(0);\n            for (int size = Math.max (5, Math.min(200, (int) (rnd.nextGaussian() * 30 + 50))); size > 0; --size) {\n              sb.append ((char)(rnd.nextInt(127-32)+32));\n            }\n            list.add (/*interner.intern*/(sb.toString()));\n          }\n\n          rnd = new Random ();\n          for (int count= maxRepetitions; count > 0; --count) {\n            String s = list.get(rnd.nextInt(list.size()));\n            Assert.assertEquals(s, interner.intern(s));\n          }\n\n        }\n      });\n\n    return System.currentTimeMillis() - start;\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Test\n  public void stressTestWithRandomStrings() {\n    final int maxObjects = 2000;\n    final int maxThreads = Runtime.getRuntime().availableProcessors()*3;\n    final int maxRepetitions = 1000;\n\n    long refTime = computeMedian(new LongProducer() {\n      @Override\n      public long produce() {\n        return computePerformanceBenchmark(maxThreads);\n      }\n    });\n\n    long time = computeMedian(new LongProducer() {\n      @Override\n      public long produce() {\n        return loadTestWithOverflow(maxObjects, maxThreads, maxRepetitions);\n      }\n    });\n\n    double ratio = time / (double) refTime;\n\n    Assert.assertTrue(\"Interner perfomance is not within bounds: \"+ratio,  0.45 < ratio && ratio < 1.95);\n  }","id":74561,"modified_method":"@Test\n  public void stressTestWithRandomStrings() {\n    final int maxObjects = 10000;\n    final int maxThreads = Runtime.getRuntime().availableProcessors()*3;\n    final int maxRepetitions = 100000;\n\n    final int k = Runtime.getRuntime().availableProcessors() > 4 ? 5 : 1;\n\n    long [] refTime = computeMedian(new LongProducer() {\n      public long [] produce() {\n        return new long [] {k *computePerformanceBenchmark(maxThreads)};\n      }\n    });\n\n    long[] stats = computeMedian(new LongProducer() {\n      public long [] produce() {\n        long baseLine = computeUsedHeap();\n        final Interner interner = new Interner(maxObjects);\n        final List<List<String>> listOfLists = new ArrayList<List<String>>();\n        long time = loadTestWithOverflow(Collections.synchronizedList(listOfLists), interner, maxObjects, maxThreads, maxRepetitions);\n\n        long used = computeUsedHeap() - baseLine;\n        int totalSize = 0;\n        for (int idx = listOfLists.size()-1; idx >= 0; --idx) {\n          totalSize += listOfLists.get(idx).size();\n        }\n        return new long[] {time, interner.size(), used, totalSize};\n      }\n    });\n\n    double perfRatio = stats[0] / (double) refTime[0];\n    Assert.assertTrue(\"Interner perfomance is not within bounds: \"+perfRatio,  0.45 < perfRatio && perfRatio < 1.95);\n\n    double memRatio = stats[2] / (double) stats[3] / 4. / 50.;\n    Assert.assertTrue(\"Interner memory consumption is not within bounds: \"+memRatio,  0.65 < memRatio && memRatio < 1.35);\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private long loadTestNoOverflow(final int maxObjects, final int maxThreads, final int maxRepetitions) {\n    final Interner interner = new Interner(maxObjects);\n    final long start = System.currentTimeMillis();\n\n    runInParallel(maxThreads, new Runnable (){\n        @Override\n        public void run() {\n          Random rnd = new Random ();\n          StringBuilder sb = new StringBuilder();\n          List<String> list = new ArrayList<String>();\n          for (int count=maxObjects/maxThreads/3; count > 0; --count) {\n            sb.setLength(0);\n            for (int size = Math.max (5, Math.min(200, (int) (rnd.nextGaussian() * 30 + 50))); size > 0; --size) {\n              sb.append ((char)(rnd.nextInt(127-32)+32));\n            }\n            list.add (interner.intern(sb.toString()));\n          }\n\n          for (int count= maxRepetitions; count > 0; --count) {\n            String s = list.get(rnd.nextInt(list.size()));\n            Assert.assertSame(s, interner.intern(s));\n          }\n\n        }\n      });\n\n    return System.currentTimeMillis() - start;\n  }","id":74562,"modified_method":"private long loadTestNoOverflow(final List<List<String>> listOfLists, final Interner interner, final int maxObjects, final int maxThreads, final int maxRepetitions) {\n    final long start = System.currentTimeMillis();\n\n    runInParallel(maxThreads, new Runnable (){\n        public void run() {\n          Random rnd = new Random ();\n          StringBuilder sb = new StringBuilder();\n          List<String> list = new ArrayList<String>();\n          listOfLists.add(list);\n          for (int count=maxObjects/maxThreads/3; count > 0; --count) {\n            sb.setLength(0);\n            for (int size = Math.max (5, Math.min(200, (int) (rnd.nextGaussian() * 30 + 50))); size > 0; --size) {\n              sb.append ((char)(rnd.nextInt(127-32)+32));\n            }\n            list.add (interner.intern(sb.toString()));\n          }\n\n          for (int count= maxRepetitions; count > 0; --count) {\n            String s = list.get(rnd.nextInt(list.size()));\n            Assert.assertSame(s, interner.intern(s));\n          }\n\n        }\n      });\n\n    return System.currentTimeMillis() - start;\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"private long computePerformanceBenchmark (int maxThreads) {\n    long start = System.currentTimeMillis();\n    final int reps = 150000/maxThreads;\n\n    final List<int[]> list = Collections.synchronizedList(new ArrayList<int[]>());\n\n    runInParallel(maxThreads, new Runnable() {\n      @Override\n      public void run() {\n        Random rnd = new Random();\n        for (int count = reps; count > 0; --count) {\n          int size = Math.max (20, Math.min(70, (int) (rnd.nextGaussian() * 10. + 50)));\n          list.add(new int[size]);\n        }\n      }\n    });\n\n    long alloc = -start + (start = System.currentTimeMillis());\n\n    runInParallel(maxThreads, new Runnable() {\n      @Override\n      public void run() {\n        Random rnd = new Random();\n        for (int[] iarr: list) {\n          for (int i=0; i<iarr.length; ++i) {\n            iarr[i] = rnd.nextInt();\n          }\n        }\n      }\n    });\n\n    long filled = -start + (start = System.currentTimeMillis());\n\n    list.clear();\n    System.gc();\n    System.gc();\n    try {\n      Thread.sleep(100);\n    } catch (InterruptedException e) {}\n    System.gc();\n\n    return alloc + filled;\n  }","id":74563,"modified_method":"private long computePerformanceBenchmark (int maxThreads) {\n    long start = System.currentTimeMillis();\n    final int reps = 150000/maxThreads;\n\n    final List<int[]> list = Collections.synchronizedList(new ArrayList<int[]>());\n\n    runInParallel(maxThreads, new Runnable() {\n      public void run() {\n        Random rnd = new Random();\n        for (int count = reps; count > 0; --count) {\n          int size = Math.max (20, Math.min(70, (int) (rnd.nextGaussian() * 10. + 50)));\n          list.add(new int[size]);\n        }\n      }\n    });\n\n    long alloc = -start + (start = System.currentTimeMillis());\n\n    runInParallel(maxThreads, new Runnable() {\n      public void run() {\n        Random rnd = new Random();\n        for (int[] iarr: list) {\n          for (int i=0; i<iarr.length; ++i) {\n            iarr[i] = rnd.nextInt();\n          }\n        }\n      }\n    });\n\n    long filled = -start + (start = System.currentTimeMillis());\n\n    list.clear();\n    System.gc();\n    System.gc();\n    try {\n      Thread.sleep(100);\n    } catch (InterruptedException e) {}\n    System.gc();\n\n    return alloc + filled;\n  }","commit_id":"0d87707e8245dd6629b8fa204ec3994ba763f5bd","url":"https://github.com/JetBrains/MPS"},{"original_method":"/**\n     * @param dest IP address + ':' + port, e.g. \"192.168.1.5:8787\"\n     */\n    public StompConnection(String dest) {\n        server_destinations.add(dest);\n    }","id":74564,"modified_method":"/**\n     * @param dest IP address + ':' + port, e.g. \"192.168.1.5:8787\"\n     */\n    public StompConnection(String dest) {\n        this(dest, null, null, false);\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"protected void connect(String dest) throws IOException {\n        SocketAddress saddr=parse(dest);\n        sock=new Socket();\n        sock.connect(saddr);\n        in=new DataInputStream(sock.getInputStream());\n        out=new DataOutputStream(sock.getOutputStream());\n        startRunner();\n    }","id":74565,"modified_method":"protected void connectToDestination(String dest) throws IOException {\n        // parse destination\n        int index=dest.lastIndexOf(\":\");\n        String host=dest.substring(0, index);\n        int port=Integer.parseInt(dest.substring(index+1));\n\n        sock=socket_factory.createSocket(host, port);\n\n        in=new DataInputStream(sock.getInputStream());\n        out=new DataOutputStream(sock.getOutputStream());\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"protected synchronized void startRunner() {\n        if(runner == null || !runner.isAlive()) {\n            runner=new Thread(this, \"StompConnection receiver\");\n            runner.start();\n        }\n    }","id":74566,"modified_method":"protected synchronized void startRunner() {\n        if(runner == null || !runner.isAlive()) {\n            running = true;\n            runner=new Thread(this, \"StompConnection receiver\");\n            runner.start();\n        }\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void removeListener(Listener listener) {\n        if(listener != null)\n            listeners.add(listener);\n    }","id":74567,"modified_method":"public void removeListener(Listener listener) {\n        if(listener != null)\n            listeners.remove(listener);\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void send(String destination, byte[] buf, int offset, int length, String ... headers) {\n        StringBuilder sb=new StringBuilder();\n        sb.append(STOMP.ClientVerb.SEND.name()).append(\"\\n\");\n        if(destination != null)\n            sb.append(\"destination: \").append(destination).append(\"\\n\");\n        if(buf != null)\n            sb.append(\"content-length: \").append(length).append(\"\\n\");\n        if(headers != null && headers.length % 2 == 0) { // must be even\n            for(int i=0; i < headers.length; i++)\n                sb.append(headers[i]).append(\": \").append(headers[++i]).append(\"\\n\");\n        }\n        sb.append(\"\\n\");\n\n        try {\n            out.write(sb.toString().getBytes());\n            if(buf != null)\n                out.write(buf, offset, length);\n            out.write(STOMP.NULL_BYTE);\n            out.flush();\n        }\n        catch(IOException ex) {\n            log.error(\"failed sending message to server: \" + ex);\n        }\n    }","id":74568,"modified_method":"public void send(String destination, byte[] buf, int offset, int length, String ... headers) {\n        if(!isConnected())\n            return;\n\n        StringBuilder sb=new StringBuilder();\n        sb.append(STOMP.ClientVerb.SEND.name()).append(\"\\n\");\n        if(destination != null)\n            sb.append(\"destination: \").append(destination).append(\"\\n\");\n        if(buf != null)\n            sb.append(\"content-length: \").append(length).append(\"\\n\");\n        if(headers != null && headers.length % 2 == 0) { // must be even\n            for(int i=0; i < headers.length; i++)\n                sb.append(headers[i]).append(\": \").append(headers[++i]).append(\"\\n\");\n        }\n        sb.append(\"\\n\");\n\n        try {\n            out.write(sb.toString().getBytes());\n            if(buf != null)\n                out.write(buf, offset, length);\n            out.write(STOMP.NULL_BYTE);\n            out.flush();\n        }\n        catch(IOException ex) {\n            log.error(\"failed sending message to server: \" + ex);\n        }\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void run() {\n        while(isConnected() && running) {\n            try {\n                STOMP.Frame frame=STOMP.readFrame(in);\n                if(frame != null) {\n                    STOMP.ServerVerb verb=STOMP.ServerVerb.valueOf(frame.getVerb());\n                    if(log.isTraceEnabled())\n                        log.trace(\"frame: \" + frame);\n                    switch(verb) {\n                        case MESSAGE:\n                            byte[] buf=frame.getBody();\n                            notifyListeners(frame.getHeaders(), buf, 0, buf != null? buf.length : 0);\n                            break;\n                        case CONNECTED:\n                            String sess_id=frame.getHeaders().get(\"session-id\");\n                            if(sess_id != null) {\n                                this.session_id=sess_id;\n                            }\n                            break;\n                        case ERROR:\n                            break;\n                        case INFO:\n                            notifyListeners(frame.getHeaders());\n                            String endpoints=frame.getHeaders().get(\"endpoints\");\n                            if(endpoints != null) {\n                                List<String> list=Util.parseCommaDelimitedStrings(endpoints);\n                                if(list != null) {\n                                    boolean changed=server_destinations.addAll(list);\n                                    if(changed && log.isDebugEnabled())\n                                        log.debug(\"INFO: new server target list: \" + server_destinations);\n                                }\n                            }\n                            break;\n                        case RECEIPT:\n                            break;\n                        default:\n                            throw new IllegalArgumentException(\"verb \" + verb + \" is not known\");\n                    }\n                }\n            }\n            catch(IOException e) {\n                close();\n                try {\n                    reconnect();\n                }\n                catch(IOException e1) {\n                    log.warn(\"failed to reconnect; runner thread terminated, cause: \" + e1);\n                }\n            }\n            catch(Throwable t) {\n                log.error(\"failure reading frame\", t);\n            }\n        }\n    }","id":74569,"modified_method":"public void run() {\n        int timeout = 1;\n        while(running) {\n            try {\n                if(!isConnected()) {\n                    setupConnection();\n                }\n\n                // reset the connection backoff when we successfully connect.\n                timeout = 1;\n\n                STOMP.Frame frame=STOMP.readFrame(in);\n                if(frame != null) {\n                    STOMP.ServerVerb verb=STOMP.ServerVerb.valueOf(frame.getVerb());\n                    if(log.isTraceEnabled())\n                        log.trace(\"frame: \" + frame);\n                    switch(verb) {\n                        case MESSAGE:\n                            byte[] buf=frame.getBody();\n                            notifyListeners(frame.getHeaders(), buf, 0, buf != null? buf.length : 0);\n                            break;\n                        case CONNECTED:\n                            String sess_id=frame.getHeaders().get(\"session-id\");\n                            if(sess_id != null) {\n                                this.session_id=sess_id;\n                            }\n                            break;\n                        case ERROR:\n                            break;\n                        case INFO:\n                            notifyListeners(frame.getHeaders());\n                            String endpoints=frame.getHeaders().get(\"endpoints\");\n                            if(endpoints != null) {\n                                List<String> list=Util.parseCommaDelimitedStrings(endpoints);\n                                if(list != null) {\n                                    boolean changed=server_destinations.addAll(list);\n                                    if(changed && log.isDebugEnabled())\n                                        log.debug(\"INFO: new server target list: \" + server_destinations);\n                                }\n                            }\n                            break;\n                        case RECEIPT:\n                            break;\n                        default:\n                            throw new IllegalArgumentException(\"verb \" + verb + \" is not known\");\n                    }\n                }\n            }\n            catch(IOException e) {\n                log.error(\"Connection closed unexpectedly, will attempt reconnect in \"+timeout+\"s.\", e);\n                close();\n                try {\n                    Thread.sleep(timeout * 1000);\n                }\n                catch (InterruptedException e1) {\n                    // pass\n                }\n                timeout = timeout*2 > 60 ? 60 : timeout*2;\n            }\n            catch(Throwable t) {\n                log.error(\"failure reading frame\", t);\n            }\n        }\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void connect() throws IOException {\n        connect(null, null);\n    }","id":74570,"modified_method":"public void connect() {\n        startRunner();\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void subscribe(String destination) {\n        if(destination == null)\n            return;\n        subscriptions.add(destination);\n\n        StringBuilder sb=new StringBuilder();\n        sb.append(STOMP.ClientVerb.SUBSCRIBE.name()).append(\"\\n\");\n        sb.append(\"destination: \").append(destination).append(\"\\n\");\n        sb.append(\"\\n\");\n\n        try {\n            out.write(sb.toString().getBytes());\n            out.write(STOMP.NULL_BYTE);\n            out.flush();\n        }\n        catch(IOException ex) {\n            log.error(\"failed subscribing to \" + destination + \": \" + ex);\n        }\n    }","id":74571,"modified_method":"public void subscribe(String destination) {\n        if(destination == null)\n            return;\n        subscriptions.add(destination);\n\n        if(isConnected()) {\n            sendSubscribe(destination);\n        }\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void reconnect() throws IOException {\n        if(!running)\n            return;\n        connect();\n        for(String subscription: subscriptions)\n            subscribe(subscription);\n        if(log.isDebugEnabled()) {\n            log.debug(\"reconnected to \" + sock.getInetAddress().getHostAddress() + \":\" + sock.getPort());\n            if(!subscriptions.isEmpty())\n                log.debug(\"re-subscribed to \" + subscriptions);\n        }\n\n    }","id":74572,"modified_method":"protected void sendConnect() {\n        StringBuilder sb=new StringBuilder();\n        sb.append(STOMP.ClientVerb.CONNECT.name()).append(\"\\n\");\n        if(userid != null)\n            sb.append(\"login: \").append(userid).append(\"\\n\");\n        if(password != null)\n            sb.append(\"passcode: \").append(password).append(\"\\n\");\n        sb.append(\"\\n\");\n\n        try{\n            out.write(sb.toString().getBytes());\n            out.write(STOMP.NULL_BYTE);\n            out.flush();\n        }\n        catch(IOException ex) {\n            log.error(\"failed to send connect message: \" + ex);\n        }\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void unsubscribe(String destination) {\n        if(destination == null)\n            return;\n        subscriptions.remove(destination);\n\n        StringBuilder sb=new StringBuilder();\n        sb.append(STOMP.ClientVerb.UNSUBSCRIBE.name()).append(\"\\n\");\n        sb.append(\"destination: \").append(destination).append(\"\\n\");\n        sb.append(\"\\n\");\n\n        try {\n            out.write(sb.toString().getBytes());\n            out.write(STOMP.NULL_BYTE);\n            out.flush();\n        }\n        catch(IOException ex) {\n            log.error(\"failed unsubscribing from \" + destination + \": \" + ex);\n        }\n    }","id":74573,"modified_method":"public void unsubscribe(String destination) {\n        if(destination == null)\n            return;\n        subscriptions.remove(destination);\n\n        if(isConnected()) {\n            sendUnsubscribe(destination);\n        }\n    }","commit_id":"786c89724f68ec5fbb08782bee913f3ced3b13c2","url":"https://github.com/belaban/JGroups"},{"original_method":"public void addMainArtifact(String artifactId, String packaging) {\n        if (\"pom\".equals(packaging)) {\n            // no artifact defined! Add the default artifact only if it exists\n            DependencyResolver resolver = parserSettings.getResolver(mrid);\n\n            if (resolver != null) {\n                DefaultArtifact artifact = new DefaultArtifact(mrid, new Date(), artifactId, \"jar\", \"jar\");\n\n                if (!ArtifactOrigin.isUnknown(resolver.locate(artifact))) {\n                    mainArtifact = artifact;\n                    ivyModuleDescriptor.addArtifact(\"master\", mainArtifact);\n                }\n            }\n\n            return;\n        }\n\n        if (!isKnownJarPackaging(packaging)) {\n            // Look for an artifact with extension = packaging. This is deprecated.\n            DependencyResolver resolver = parserSettings.getResolver(mrid);\n\n            if (resolver != null) {\n                DefaultArtifact artifact = new DefaultArtifact(mrid, new Date(), artifactId, packaging, packaging);\n\n                if (!ArtifactOrigin.isUnknown(resolver.locate(artifact))) {\n                    mainArtifact = artifact;\n                    ivyModuleDescriptor.addArtifact(\"master\", mainArtifact);\n\n                    DeprecationLogger.nagUserOfDeprecated(\"Relying on packaging to define the extension of the main artifact\");\n\n                    return;\n                }\n            }\n        }\n\n        mainArtifact = new DefaultArtifact(mrid, new Date(), artifactId, packaging, \"jar\");\n        ivyModuleDescriptor.addArtifact(\"master\", mainArtifact);\n    }","id":74574,"modified_method":"public void addMainArtifact(String artifactId, String packaging) {\n        if (\"pom\".equals(packaging)) {\n            // no artifact defined! Add the default artifact only if it exists\n            DependencyResolver resolver = parserSettings.getResolver(mrid);\n\n            if (resolver != null) {\n                DefaultArtifact artifact = new DefaultArtifact(mrid, new Date(), artifactId, \"jar\", \"jar\");\n\n                if (!ArtifactOrigin.isUnknown(resolver.locate(artifact))) {\n                    ivyModuleDescriptor.addArtifact(\"master\", artifact);\n                }\n            }\n\n            return;\n        }\n\n        if (!isKnownJarPackaging(packaging)) {\n            // Look for an artifact with extension = packaging. This is deprecated.\n            DependencyResolver resolver = parserSettings.getResolver(mrid);\n\n            if (resolver != null) {\n                DefaultArtifact artifact = new DefaultArtifact(mrid, new Date(), artifactId, packaging, packaging);\n\n                if (!ArtifactOrigin.isUnknown(resolver.locate(artifact))) {\n                    ivyModuleDescriptor.addArtifact(\"master\", artifact);\n\n                    DeprecationLogger.nagUserOfDeprecated(\"Relying on packaging to define the extension of the main artifact\");\n\n                    return;\n                }\n            }\n        }\n\n        ivyModuleDescriptor.addArtifact(\"master\", new DefaultArtifact(mrid, new Date(), artifactId, packaging, \"jar\"));\n    }","commit_id":"c746047c67f4bf30ca6da3b0f62ded1241537b31","url":"https://github.com/gradle/gradle"},{"original_method":"private ResolvedModuleRevision parseOtherPom(ParserSettings ivySettings,\n                                                 ModuleRevisionId parentModRevID) throws ParseException {\n        DependencyDescriptor dd = new DefaultDependencyDescriptor(parentModRevID, true);\n        ResolveData data = IvyContext.getContext().getResolveData();\n        if (data == null) {\n            ResolveEngine engine = IvyContext.getContext().getIvy().getResolveEngine();\n            ResolveOptions options = new ResolveOptions();\n            options.setDownload(false);\n            data = new ResolveData(engine, options);\n        }\n\n        DependencyResolver resolver = ivySettings.getResolver(parentModRevID);\n        if (resolver == null) {\n            // TODO: Throw exception here?\n            return null;\n        } else {\n            dd = NameSpaceHelper.toSystem(dd, ivySettings.getContextNamespace());\n            ResolvedModuleRevision otherModule = resolver.getDependency(dd, data);\n            return otherModule;\n        }\n    }","id":74575,"modified_method":"private ResolvedModuleRevision parseOtherPom(ParserSettings ivySettings,\n                                                 ModuleRevisionId parentModRevID) throws ParseException {\n        DependencyDescriptor dd = new DefaultDependencyDescriptor(parentModRevID, true);\n        ResolveData data = IvyContext.getContext().getResolveData();\n        if (data == null) {\n            ResolveEngine engine = IvyContext.getContext().getIvy().getResolveEngine();\n            ResolveOptions options = new ResolveOptions();\n            options.setDownload(false);\n            data = new ResolveData(engine, options);\n        }\n\n        DependencyResolver resolver = ivySettings.getResolver(parentModRevID);\n        if (resolver == null) {\n            // TODO: Throw exception here?\n            return null;\n        } else {\n            dd = NameSpaceHelper.toSystem(dd, ivySettings.getContextNamespace());\n            return resolver.getDependency(dd, data);\n        }\n    }","commit_id":"c746047c67f4bf30ca6da3b0f62ded1241537b31","url":"https://github.com/gradle/gradle"},{"original_method":"public ModuleDescriptor parseDescriptor(ParserSettings ivySettings, URL descriptorURL,\n                                            Resource res, boolean validate) throws ParseException, IOException {\n\n        GradlePomModuleDescriptorBuilder mdBuilder = new GradlePomModuleDescriptorBuilder(this, res, ivySettings);\n\n        try {\n            PomReader domReader = new PomReader(descriptorURL, res);\n            domReader.setProperty(\"parent.version\", domReader.getParentVersion());\n            domReader.setProperty(\"parent.groupId\", domReader.getParentGroupId());\n            domReader.setProperty(\"project.parent.version\", domReader.getParentVersion());\n            domReader.setProperty(\"project.parent.groupId\", domReader.getParentGroupId());\n\n            Map pomProperties = domReader.getPomProperties();\n            for (Object o : pomProperties.entrySet()) {\n                Map.Entry prop = (Map.Entry) o;\n                domReader.setProperty((String) prop.getKey(), (String) prop.getValue());\n                mdBuilder.addProperty((String) prop.getKey(), (String) prop.getValue());\n            }\n\n            ModuleDescriptor parentDescr = null;\n            if (domReader.hasParent()) {\n                //Is there any other parent properties?\n\n                ModuleRevisionId parentModRevID = ModuleRevisionId.newInstance(\n                        domReader.getParentGroupId(),\n                        domReader.getParentArtifactId(),\n                        domReader.getParentVersion());\n                ResolvedModuleRevision parentModule = parseOtherPom(ivySettings,\n                        parentModRevID);\n                if (parentModule != null) {\n                    parentDescr = parentModule.getDescriptor();\n                } else {\n                    throw new IOException(\"Impossible to load parent for \" + res.getName() + \".\"\n                            + \" Parent=\" + parentModRevID);\n                }\n                if (parentDescr != null) {\n                    Map parentPomProps = GradlePomModuleDescriptorBuilder.extractPomProperties(\n                            parentDescr.getExtraInfo());\n                    for (Object o : parentPomProps.entrySet()) {\n                        Map.Entry prop = (Map.Entry) o;\n                        domReader.setProperty((String) prop.getKey(), (String) prop.getValue());\n                    }\n                }\n            }\n\n            String groupId = domReader.getGroupId();\n            String artifactId = domReader.getArtifactId();\n            String version = domReader.getVersion();\n            ModuleScopedParserSettings scopedSettings = (ModuleScopedParserSettings) ivySettings;\n            mdBuilder.setModuleRevId(scopedSettings.getCurrentRevisionId(), groupId, artifactId, version);\n\n            mdBuilder.setHomePage(domReader.getHomePage());\n            mdBuilder.setDescription(domReader.getDescription());\n            mdBuilder.setLicenses(domReader.getLicenses());\n\n            ModuleRevisionId relocation = domReader.getRelocation();\n\n            if (relocation != null) {\n                if (groupId != null && artifactId != null\n                        && artifactId.equals(relocation.getName())\n                        && groupId.equals(relocation.getOrganisation())) {\n                    Message.error(\"Relocation to an other version number not supported in ivy : \"\n                            + mdBuilder.getModuleDescriptor().getModuleRevisionId()\n                            + \" relocated to \" + relocation\n                            + \". Please update your dependency to directly use the right version.\");\n                    Message.warn(\"Resolution will only pick dependencies of the relocated element.\"\n                            + \"  Artefact and other metadata will be ignored.\");\n                    ResolvedModuleRevision relocatedModule = parseOtherPom(ivySettings, relocation);\n                    if (relocatedModule == null) {\n                        throw new ParseException(\"impossible to load module \"\n                                + relocation + \" to which \"\n                                + mdBuilder.getModuleDescriptor().getModuleRevisionId()\n                                + \" has been relocated\", 0);\n                    }\n                    DependencyDescriptor[] dds = relocatedModule.getDescriptor().getDependencies();\n                    for (DependencyDescriptor dd : dds) {\n                        mdBuilder.addDependency(dd);\n                    }\n                } else {\n                    Message.info(mdBuilder.getModuleDescriptor().getModuleRevisionId()\n                            + \" is relocated to \" + relocation\n                            + \". Please update your dependencies.\");\n                    Message.verbose(\"Relocated module will be considered as a dependency\");\n                    DefaultDependencyDescriptor dd = new DefaultDependencyDescriptor(mdBuilder\n                            .getModuleDescriptor(), relocation, true, false, true);\n                    /* Map all public dependencies */\n                    Configuration[] m2Confs = GradlePomModuleDescriptorBuilder.MAVEN2_CONFIGURATIONS;\n                    for (Configuration m2Conf : m2Confs) {\n                        if (Visibility.PUBLIC.equals(m2Conf.getVisibility())) {\n                            dd.addDependencyConfiguration(m2Conf.getName(), m2Conf.getName());\n                        }\n                    }\n                    mdBuilder.addDependency(dd);\n                }\n            } else {\n                domReader.setProperty(\"project.groupId\", groupId);\n                domReader.setProperty(\"pom.groupId\", groupId);\n                domReader.setProperty(\"groupId\", groupId);\n                domReader.setProperty(\"project.artifactId\", artifactId);\n                domReader.setProperty(\"pom.artifactId\", artifactId);\n                domReader.setProperty(\"artifactId\", artifactId);\n                domReader.setProperty(\"project.version\", version);\n                domReader.setProperty(\"pom.version\", version);\n                domReader.setProperty(\"version\", version);\n\n                if (parentDescr != null) {\n                    mdBuilder.addExtraInfos(parentDescr.getExtraInfo());\n\n                    // add dependency management info from parent\n                    List depMgt = GradlePomModuleDescriptorBuilder.getDependencyManagements(parentDescr);\n                    for (Object aDepMgt : depMgt) {\n                        mdBuilder.addDependencyMgt((PomDependencyMgt) aDepMgt);\n                    }\n\n                    // add plugins from parent\n                    List /*<PomDependencyMgt>*/ plugins =\n                            GradlePomModuleDescriptorBuilder.getPlugins(parentDescr);\n                    for (Object plugin : plugins) {\n                        mdBuilder.addPlugin((PomDependencyMgt) plugin);\n                    }\n                }\n\n                for (Object o : domReader.getDependencyMgt()) {\n                    PomDependencyMgt dep = (PomDependencyMgt) o;\n                    if (\"import\".equals(dep.getScope())) {\n                        ModuleRevisionId importModRevID = ModuleRevisionId.newInstance(\n                                dep.getGroupId(),\n                                dep.getArtifactId(),\n                                dep.getVersion());\n                        ResolvedModuleRevision importModule = parseOtherPom(ivySettings,\n                                importModRevID);\n                        if (importModule != null) {\n                            ModuleDescriptor importDescr = importModule.getDescriptor();\n\n                            // add dependency management info from imported module\n                            List depMgt = GradlePomModuleDescriptorBuilder.getDependencyManagements(importDescr);\n                            for (Object aDepMgt : depMgt) {\n                                mdBuilder.addDependencyMgt((PomDependencyMgt) aDepMgt);\n                            }\n                        } else {\n                            throw new IOException(\"Impossible to import module for \" + res.getName() + \".\"\n                                    + \" Import=\" + importModRevID);\n                        }\n\n                    } else {\n                        mdBuilder.addDependencyMgt(dep);\n                    }\n                }\n\n                for (Object o : domReader.getDependencies()) {\n                    PomReader.PomDependencyData dep = (PomReader.PomDependencyData) o;\n                    mdBuilder.addDependency(dep);\n                }\n\n                if (parentDescr != null) {\n                    for (int i = 0; i < parentDescr.getDependencies().length; i++) {\n                        mdBuilder.addDependency(parentDescr.getDependencies()[i]);\n                    }\n                }\n\n                for (Object o : domReader.getPlugins()) {\n                    PomReader.PomPluginElement plugin = (PomReader.PomPluginElement) o;\n                    mdBuilder.addPlugin(plugin);\n                }\n\n                mdBuilder.addMainArtifact(artifactId, domReader.getPackaging());\n            }\n        } catch (SAXException e) {\n            throw newParserException(e);\n        }\n\n        return mdBuilder.getModuleDescriptor();\n    }","id":74576,"modified_method":"public ModuleDescriptor parseDescriptor(ParserSettings ivySettings, URL descriptorURL,\n                                            Resource resource, boolean validate) throws ParseException, IOException {\n\n        Resource res = encodedUrlResource(resource, descriptorURL);\n        GradlePomModuleDescriptorBuilder mdBuilder = new GradlePomModuleDescriptorBuilder(this, res, ivySettings);\n\n        try {\n            PomReader domReader = new PomReader(descriptorURL, res);\n            domReader.setProperty(\"parent.version\", domReader.getParentVersion());\n            domReader.setProperty(\"parent.groupId\", domReader.getParentGroupId());\n            domReader.setProperty(\"project.parent.version\", domReader.getParentVersion());\n            domReader.setProperty(\"project.parent.groupId\", domReader.getParentGroupId());\n\n            Map pomProperties = domReader.getPomProperties();\n            for (Object o : pomProperties.entrySet()) {\n                Map.Entry prop = (Map.Entry) o;\n                domReader.setProperty((String) prop.getKey(), (String) prop.getValue());\n                mdBuilder.addProperty((String) prop.getKey(), (String) prop.getValue());\n            }\n\n            ModuleDescriptor parentDescr = null;\n            if (domReader.hasParent()) {\n                //Is there any other parent properties?\n\n                ModuleRevisionId parentModRevID = ModuleRevisionId.newInstance(\n                        domReader.getParentGroupId(),\n                        domReader.getParentArtifactId(),\n                        domReader.getParentVersion());\n                ResolvedModuleRevision parentModule = parseOtherPom(ivySettings, parentModRevID);\n                if (parentModule != null) {\n                    parentDescr = parentModule.getDescriptor();\n                } else {\n                    throw new IOException(\"Impossible to load parent for \" + res.getName() + \". Parent=\" + parentModRevID);\n                }\n                if (parentDescr != null) {\n                    Map parentPomProps = GradlePomModuleDescriptorBuilder.extractPomProperties(parentDescr.getExtraInfo());\n                    for (Object o : parentPomProps.entrySet()) {\n                        Map.Entry prop = (Map.Entry) o;\n                        domReader.setProperty((String) prop.getKey(), (String) prop.getValue());\n                    }\n                }\n            }\n\n            String groupId = domReader.getGroupId();\n            String artifactId = domReader.getArtifactId();\n            String version = domReader.getVersion();\n            ModuleScopedParserSettings scopedSettings = (ModuleScopedParserSettings) ivySettings;\n            mdBuilder.setModuleRevId(scopedSettings.getCurrentRevisionId(), groupId, artifactId, version);\n\n            mdBuilder.setHomePage(domReader.getHomePage());\n            mdBuilder.setDescription(domReader.getDescription());\n            mdBuilder.setLicenses(domReader.getLicenses());\n\n            ModuleRevisionId relocation = domReader.getRelocation();\n\n            if (relocation != null) {\n                if (groupId != null && artifactId != null\n                        && artifactId.equals(relocation.getName())\n                        && groupId.equals(relocation.getOrganisation())) {\n                    Message.error(\"Relocation to an other version number not supported in ivy : \"\n                            + mdBuilder.getModuleDescriptor().getModuleRevisionId()\n                            + \" relocated to \" + relocation\n                            + \". Please update your dependency to directly use the right version.\");\n                    Message.warn(\"Resolution will only pick dependencies of the relocated element.\"\n                            + \"  Artefact and other metadata will be ignored.\");\n                    ResolvedModuleRevision relocatedModule = parseOtherPom(ivySettings, relocation);\n                    if (relocatedModule == null) {\n                        throw new ParseException(\"impossible to load module \"\n                                + relocation + \" to which \"\n                                + mdBuilder.getModuleDescriptor().getModuleRevisionId()\n                                + \" has been relocated\", 0);\n                    }\n                    DependencyDescriptor[] dds = relocatedModule.getDescriptor().getDependencies();\n                    for (DependencyDescriptor dd : dds) {\n                        mdBuilder.addDependency(dd);\n                    }\n                } else {\n                    Message.info(mdBuilder.getModuleDescriptor().getModuleRevisionId()\n                            + \" is relocated to \" + relocation\n                            + \". Please update your dependencies.\");\n                    Message.verbose(\"Relocated module will be considered as a dependency\");\n                    DefaultDependencyDescriptor dd = new DefaultDependencyDescriptor(mdBuilder.getModuleDescriptor(), relocation, true, false, true);\n                    /* Map all public dependencies */\n                    Configuration[] m2Confs = GradlePomModuleDescriptorBuilder.MAVEN2_CONFIGURATIONS;\n                    for (Configuration m2Conf : m2Confs) {\n                        if (Visibility.PUBLIC.equals(m2Conf.getVisibility())) {\n                            dd.addDependencyConfiguration(m2Conf.getName(), m2Conf.getName());\n                        }\n                    }\n                    mdBuilder.addDependency(dd);\n                }\n            } else {\n                domReader.setProperty(\"project.groupId\", groupId);\n                domReader.setProperty(\"pom.groupId\", groupId);\n                domReader.setProperty(\"groupId\", groupId);\n                domReader.setProperty(\"project.artifactId\", artifactId);\n                domReader.setProperty(\"pom.artifactId\", artifactId);\n                domReader.setProperty(\"artifactId\", artifactId);\n                domReader.setProperty(\"project.version\", version);\n                domReader.setProperty(\"pom.version\", version);\n                domReader.setProperty(\"version\", version);\n\n                if (parentDescr != null) {\n                    mdBuilder.addExtraInfos(parentDescr.getExtraInfo());\n\n                    // add dependency management info from parent\n                    List depMgt = GradlePomModuleDescriptorBuilder.getDependencyManagements(parentDescr);\n                    for (Object aDepMgt : depMgt) {\n                        mdBuilder.addDependencyMgt((PomDependencyMgt) aDepMgt);\n                    }\n\n                    // add plugins from parent\n                    List /*<PomDependencyMgt>*/ plugins = GradlePomModuleDescriptorBuilder.getPlugins(parentDescr);\n                    for (Object plugin : plugins) {\n                        mdBuilder.addPlugin((PomDependencyMgt) plugin);\n                    }\n                }\n\n                for (Object o : domReader.getDependencyMgt()) {\n                    PomDependencyMgt dep = (PomDependencyMgt) o;\n                    if (\"import\".equals(dep.getScope())) {\n                        ModuleRevisionId importModRevID = ModuleRevisionId.newInstance(\n                                dep.getGroupId(),\n                                dep.getArtifactId(),\n                                dep.getVersion());\n                        ResolvedModuleRevision importModule = parseOtherPom(ivySettings, importModRevID);\n                        if (importModule != null) {\n                            ModuleDescriptor importDescr = importModule.getDescriptor();\n\n                            // add dependency management info from imported module\n                            List depMgt = GradlePomModuleDescriptorBuilder.getDependencyManagements(importDescr);\n                            for (Object aDepMgt : depMgt) {\n                                mdBuilder.addDependencyMgt((PomDependencyMgt) aDepMgt);\n                            }\n                        } else {\n                            throw new IOException(\"Impossible to import module for \" + res.getName() + \".\"\n                                    + \" Import=\" + importModRevID);\n                        }\n\n                    } else {\n                        mdBuilder.addDependencyMgt(dep);\n                    }\n                }\n\n                for (Object o : domReader.getDependencies()) {\n                    PomReader.PomDependencyData dep = (PomReader.PomDependencyData) o;\n                    mdBuilder.addDependency(dep);\n                }\n\n                if (parentDescr != null) {\n                    for (int i = 0; i < parentDescr.getDependencies().length; i++) {\n                        mdBuilder.addDependency(parentDescr.getDependencies()[i]);\n                    }\n                }\n\n                for (Object o : domReader.getPlugins()) {\n                    PomReader.PomPluginElement plugin = (PomReader.PomPluginElement) o;\n                    mdBuilder.addPlugin(plugin);\n                }\n\n                mdBuilder.addMainArtifact(artifactId, domReader.getPackaging());\n            }\n        } catch (SAXException e) {\n            throw newParserException(e);\n        }\n\n        return mdBuilder.getModuleDescriptor();\n    }","commit_id":"c746047c67f4bf30ca6da3b0f62ded1241537b31","url":"https://github.com/gradle/gradle"},{"original_method":"public IvySettings convertForResolve(List<DependencyResolver> dependencyResolvers, Map<String, ModuleDescriptor> clientModuleRegistry) {\n        if (resolveSettings == null) {\n            resolveSettings = settingsFactory.create();\n            userResolverChain = createUserResolverChain();\n            DependencyResolver clientModuleResolver = createClientModuleResolver(clientModuleRegistry, userResolverChain);\n            DependencyResolver outerChain = createOuterChain(WrapUtil.toLinkedSet(clientModuleResolver, userResolverChain));\n            entryPointResolver = new EntryPointResolver(outerChain);\n            entryPointResolver.setName(ENTRY_POINT_RESOLVER);\n            entryPointResolver.setRepositoryCacheManager(new NoOpRepositoryCacheManager(entryPointResolver.getName()));\n            initializeResolvers(resolveSettings, WrapUtil.toList(userResolverChain, clientModuleResolver, outerChain, entryPointResolver));\n        }\n\n        replaceResolvers(dependencyResolvers, userResolverChain);\n        resolveSettings.setDefaultResolver(entryPointResolver.getName());\n        return resolveSettings;\n    }","id":74577,"modified_method":"public IvySettings convertForResolve(List<DependencyResolver> dependencyResolvers, Map<String, ModuleDescriptor> clientModuleRegistry) {\n        if (resolveSettings == null) {\n            resolveSettings = settingsFactory.create();\n            userResolverChain = createUserResolverChain();\n            DependencyResolver clientModuleResolver = createClientModuleResolver(clientModuleRegistry, userResolverChain);\n            DependencyResolver outerChain = createOuterChain(WrapUtil.toLinkedSet(clientModuleResolver, userResolverChain));\n            entryPointResolver = new EntryPointResolver(outerChain);\n            entryPointResolver.setName(ENTRY_POINT_RESOLVER);\n            initializeResolvers(resolveSettings, WrapUtil.toList(userResolverChain, clientModuleResolver, outerChain, entryPointResolver));\n        }\n\n        replaceResolvers(dependencyResolvers, userResolverChain);\n        resolveSettings.setDefaultResolver(entryPointResolver.getName());\n        return resolveSettings;\n    }","commit_id":"199fa5b42a41dea2a84864f73964d5167f949535","url":"https://github.com/gradle/gradle"},{"original_method":"public ResolvedModuleRevision getDependency(DependencyDescriptor dd, ResolveData data) throws ParseException {\n        //TODO SF - this resolver needs to be more generic, for now doing the work here...\n        if (forcedVersions != null) {\n            for (Dependency forced : forcedVersions) {\n                if (ModuleId.newInstance(forced.getGroup(), forced.getName()).equals(dd.getDependencyId())) {\n//                    ModuleRevisionId newRevId = ModuleRevisionId.newInstance(forced.getGroup(), forced.getName(), forced.getVersion());\n//                    DependencyDescriptor forcedVersion = dd.clone(newRevId);\n                    updateFieldValue(dd.getDependencyRevisionId(), \"revision\", forced.getVersion());\n                    ((Map) getFieldValue(UnmodifiableExtendableItem.class, dd.getDependencyRevisionId(), \"attributes\"))\n                            .put(IvyPatternHelper.REVISION_KEY, forced.getVersion());\n                    ResolvedModuleRevision ret = delegate.getDependency(dd, data);\n                    return ret;\n                }\n            }\n        }\n\n        ResolvedModuleRevision out = delegate.getDependency(dd, data);\n        return out;\n    }","id":74578,"modified_method":"public ResolvedModuleRevision getDependency(DependencyDescriptor dd, ResolveData data) throws ParseException {\n        //TODO SF - this resolver needs to be more generic, for now doing the work here...\n        if (forcedVersions != null) {\n            for (Dependency forced : forcedVersions) {\n                if (ModuleId.newInstance(forced.getGroup(), forced.getName()).equals(dd.getDependencyId())) {\n//                    ModuleRevisionId newRevId = ModuleRevisionId.newInstance(forced.getGroup(), forced.getName(), forced.getVersion());\n//                    DependencyDescriptor forcedVersion = dd.clone(newRevId);\n                    updateFieldValue(dd.getDependencyRevisionId(), \"revision\", forced.getVersion());\n                    ((Map) getFieldValue(UnmodifiableExtendableItem.class, dd.getDependencyRevisionId(), \"attributes\"))\n                            .put(IvyPatternHelper.REVISION_KEY, forced.getVersion());\n                    return delegate.getDependency(dd, data);\n                }\n            }\n        }\n\n        return delegate.getDependency(dd, data);\n    }","commit_id":"199fa5b42a41dea2a84864f73964d5167f949535","url":"https://github.com/gradle/gradle"},{"original_method":"public void publish(Artifact artifact, File src, boolean overwrite) throws IOException {\n        delegate.publish(artifact, src, overwrite);\n    }","id":74579,"modified_method":"public void publish(Artifact artifact, File src, boolean overwrite) throws IOException {\n        throw new UnsupportedOperationException();\n    }","commit_id":"199fa5b42a41dea2a84864f73964d5167f949535","url":"https://github.com/gradle/gradle"},{"original_method":"public void add(Issue issue) {\n    for (String severity : Severity.ALL) {\n      if (severity.equals(issue.severity())) {\n        issuesBySeverity.put(severity, issue);\n      }\n    }\n  }","id":74580,"modified_method":"public void add(Issue issue) {\n    issuesBySeverity.put(issue.severity(), issue);\n  }","commit_id":"af218419066f763121bc7cec47a2a8f957eb7110","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"/** Service to create a order header note. */\n    public static Map createOrderNote(DispatchContext dctx, Map context) {\n        Map result = new HashMap();\n        GenericDelegator delegator = dctx.getDelegator();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        String noteString = (String) context.get(\"note\");\n        String orderId = (String) context.get(\"orderId\");\n        String internalNote = (String) context.get(\"internalNote\");\n        Map noteCtx = UtilMisc.toMap(\"note\", noteString, \"userLogin\", userLogin);\n        Locale locale = (Locale) context.get(\"locale\");\n\n        // Store the note.\n        Map noteRes = org.ofbiz.common.CommonServices.createNote(dctx, noteCtx);\n\n        if (noteRes.get(ModelService.RESPONSE_MESSAGE).equals(ModelService.RESPOND_ERROR))\n            return noteRes;\n\n        String noteId = (String) noteRes.get(\"noteId\");\n\n        if (noteId == null || noteId.length() == 0) {\n            return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,\"OrderProblemCreatingTheNoteNoNoteIdReturned\", locale));\n        }\n\n        // Set the order info\n        try {\n            Map fields = UtilMisc.toMap(\"orderId\", orderId, \"noteId\", noteId, \"internalNote\", internalNote);\n            GenericValue v = delegator.makeValue(\"OrderHeaderNote\", fields);\n\n            delegator.create(v);\n        } catch (GenericEntityException ee) {\n            Debug.logError(ee, module);\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_ERROR);\n            result.put(ModelService.ERROR_MESSAGE, \"Problem associating note with order (\" + ee.getMessage() + \").\");\n        }\n\n        return result;\n    }","id":74581,"modified_method":"/** Service to create a order header note. */\n    public static Map createOrderNote(DispatchContext dctx, Map context) {\n        Map result = new HashMap();\n        GenericDelegator delegator = dctx.getDelegator();\n        LocalDispatcher dispatcher = dctx.getDispatcher();\n        GenericValue userLogin = (GenericValue) context.get(\"userLogin\");\n        String noteString = (String) context.get(\"note\");\n        String orderId = (String) context.get(\"orderId\");\n        String internalNote = (String) context.get(\"internalNote\");\n        Map noteCtx = UtilMisc.toMap(\"note\", noteString, \"userLogin\", userLogin);\n        Locale locale = (Locale) context.get(\"locale\");\n\n        try {\n            // Store the note.\n            Map noteRes = dispatcher.runSync(\"createNote\", noteCtx);\n\n            if (ServiceUtil.isError(noteRes))\n                return noteRes;\n\n            String noteId = (String) noteRes.get(\"noteId\");\n\n            if (noteId == null || noteId.length() == 0) {\n                return ServiceUtil.returnError(UtilProperties.getMessage(resource_error,\"OrderProblemCreatingTheNoteNoNoteIdReturned\", locale));\n            }\n\n            // Set the order info\n            Map fields = UtilMisc.toMap(\"orderId\", orderId, \"noteId\", noteId, \"internalNote\", internalNote);\n            GenericValue v = delegator.makeValue(\"OrderHeaderNote\", fields);\n\n            delegator.create(v);\n        } catch (GenericEntityException ee) {\n            Debug.logError(ee, module);\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_ERROR);\n            result.put(ModelService.ERROR_MESSAGE, \"Problem associating note with order (\" + ee.getMessage() + \").\");\n        } catch (GenericServiceException se) {\n            Debug.logError(se, module);\n            result.put(ModelService.RESPONSE_MESSAGE, ModelService.RESPOND_ERROR);\n            result.put(ModelService.ERROR_MESSAGE, \"Problem associating note with order (\" + se.getMessage() + \").\");\n        }\n                \n        return result;\n    }","commit_id":"777f604a2b5c03584bbda571afc3e2595a2f0eb6","url":"https://github.com/apache/ofbiz"},{"original_method":"protected void removeMember(Address address) {\n        logger.log(Level.FINEST, \"removing  \" + address);\n        MemberImpl member = mapMembers.remove(address);\n        if (member != null) {\n            lsMembers.remove(member);\n        }\n    }","id":74582,"modified_method":"protected void removeMember(MemberImpl member) {\n        logger.log(Level.FINEST, \"removing  \" + member);\n        mapMembers.remove(member.getAddress());\n        lsMembers.remove(member);\n    }","commit_id":"fd99386c33508fa937fb7d686594ba1169dee413","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public Member addMember(MemberImpl member) {\n        logger.log(Level.FINEST, \"ClusterManager adding \" + member);\n        if (lsMembers.contains(member)) {\n            for (MemberImpl m : lsMembers) {\n                if (m.equals(member)) {\n                    member = m;\n                }\n            }\n        } else {\n            if (!member.getAddress().equals(thisAddress)) {\n                node.connectionManager.getConnection(member.getAddress());\n            }\n            lsMembers.add(member);\n            mapMembers.put(member.getAddress(), member);\n        }\n        return member;\n    }","id":74583,"modified_method":"private Member addMember(MemberImpl member) {\n        logger.log(Level.FINEST, \"ClusterManager adding \" + member);\n        if (lsMembers.contains(member)) {\n            for (MemberImpl m : lsMembers) {\n                if (m.equals(member)) {\n                    member = m;\n                }\n            }\n            mapMembers.put(member.getAddress(),  member);\n        } else {\n            lsMembers.add(member);\n            mapMembers.put(member.getAddress(), member);\n        }\n        return member;\n    }","commit_id":"fd99386c33508fa937fb7d686594ba1169dee413","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"void doRemoveAddress(Address deadAddress) {\n        logger.log(Level.FINEST, \"Removing Address \" + deadAddress);\n        if (!node.joined()) {\n            node.failedConnection(deadAddress);\n            return;\n        }\n        if (deadAddress.equals(thisAddress))\n            return;\n        if (deadAddress.equals(getMasterAddress())) {\n            if (node.joined()) {\n                MemberImpl newMaster = getNextMemberAfter(deadAddress, false, 1);\n                if (newMaster != null)\n                    node.setMasterAddress(newMaster.getAddress());\n                else\n                    node.setMasterAddress(null);\n            } else {\n                node.setMasterAddress(null);\n            }\n            logger.log(Level.FINEST, \"Now Master \" + node.getMasterAddress());\n        }\n        if (isMaster()) {\n            setJoins.remove(new MemberInfo(deadAddress));\n        }\n        Connection conn = node.connectionManager.getConnection(deadAddress);\n        if (conn != null) {\n            node.connectionManager.remove(conn);\n        }\n        MemberImpl deadMember = getMember(deadAddress);\n        if (deadMember != null) {\n            lsMembersBefore.clear();\n            for (MemberImpl memberBefore : lsMembers) {\n                lsMembersBefore.add(memberBefore);\n            }\n            removeMember(deadAddress);\n            node.blockingQueueManager.syncForDead(deadAddress);\n            node.concurrentMapManager.syncForDead(deadMember);\n            node.listenerManager.syncForDead(deadAddress);\n            node.topicManager.syncForDead(deadAddress);\n            node.getClusterImpl().setMembers(lsMembers);\n            // toArray will avoid CME as onDisconnect does remove the calls\n            Object[] calls = mapCalls.values().toArray();\n            for (Object call : calls) {\n                ((Call) call).onDisconnect(deadAddress);\n            }\n            logger.log(Level.INFO, this.toString());\n        }\n    }","id":74584,"modified_method":"void doRemoveAddress(Address deadAddress) {\n        logger.log(Level.FINEST, \"Removing Address \" + deadAddress);\n        if (!node.joined()) {\n            node.failedConnection(deadAddress);\n            return;\n        }\n        if (deadAddress.equals(thisAddress))\n            return;\n        if (deadAddress.equals(getMasterAddress())) {\n            if (node.joined()) {\n                MemberImpl newMaster = getNextMemberAfter(deadAddress, false, 1);\n                if (newMaster != null)\n                    node.setMasterAddress(newMaster.getAddress());\n                else\n                    node.setMasterAddress(null);\n            } else {\n                node.setMasterAddress(null);\n            }\n            logger.log(Level.FINEST, \"Now Master \" + node.getMasterAddress());\n        }\n        if (isMaster()) {\n            setJoins.remove(new MemberInfo(deadAddress));\n        }\n        Connection conn = node.connectionManager.getConnection(deadAddress);\n        if (conn != null) {\n            node.connectionManager.remove(conn);\n        }\n        MemberImpl deadMember = getMember(deadAddress);\n        if (deadMember != null) {\n            lsMembersBefore.clear();\n            for (MemberImpl memberBefore : lsMembers) {\n                lsMembersBefore.add(memberBefore);\n            }\n            removeMember(deadMember);\n            node.blockingQueueManager.syncForDead(deadAddress);\n            node.concurrentMapManager.syncForDead(deadMember);\n            node.listenerManager.syncForDead(deadAddress);\n            node.topicManager.syncForDead(deadAddress);\n            node.getClusterImpl().setMembers(lsMembers);\n            // toArray will avoid CME as onDisconnect does remove the calls\n            Object[] calls = mapCalls.values().toArray();\n            for (Object call : calls) {\n                ((Call) call).onDisconnect(deadAddress);\n            }\n            logger.log(Level.INFO, this.toString());\n        }\n    }","commit_id":"fd99386c33508fa937fb7d686594ba1169dee413","url":"https://github.com/hazelcast/hazelcast"},{"original_method":"public CreateTestDialog(@NotNull Project project,\n                          @NotNull String title,\n                          PsiClass targetClass,\n                          PsiPackage targetPackage,\n                          Module targetModule) {\n    super(project, true);\n    myProject = project;\n\n    myTargetClass = targetClass;\n    myTargetModule = targetModule;\n\n    initControls(targetClass, targetPackage);\n    setTitle(title);\n    init();\n\n    if (myDefaultLibraryButton == null) {\n      myDefaultLibraryButton = myLibraryButtons.get(0);\n    }\n    myDefaultLibraryButton.doClick();\n  }","id":74585,"modified_method":"public CreateTestDialog(@NotNull Project project,\n                          @NotNull String title,\n                          PsiClass targetClass,\n                          PsiPackage targetPackage,\n                          Module targetModule) {\n    super(project, true);\n    myProject = project;\n\n    myTargetClass = targetClass;\n    myTargetModule = targetModule;\n\n    initControls(targetClass, targetPackage);\n    setTitle(title);\n    init();\n\n    myDefaultLibraryButton.doClick();\n  }","commit_id":"550a161f1f62ce1ddd800051c41ec224deacc267","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void initControls(PsiClass targetClass, PsiPackage targetPackage) {\n    ButtonGroup group = new ButtonGroup();\n    String defaultLibrary = getDefaultLibraryName();\n    for (final TestFrameworkDescriptor descriptor : Extensions.getExtensions(TestFrameworkDescriptor.EXTENSION_NAME)) {\n      final JRadioButton b = new JRadioButton(descriptor.getName());\n      myLibraryButtons.add(b);\n      group.add(b);\n\n      if (descriptor.getName().equals(defaultLibrary)) {\n        myDefaultLibraryButton = b;\n      }\n\n      b.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          if (b.isSelected()) onLibrarySelected(descriptor);\n        }\n      });\n    }\n\n    myFixLibraryButton = new JButton(CodeInsightBundle.message(\"intention.create.test.dialog.fix.library\"));\n    myFixLibraryButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            OrderEntryFix.addJarToRoots(mySelectedTestDescriptor.getLibraryPath(), myTargetModule);\n          }\n        });\n        myFixLibraryPanel.setVisible(false);\n      }\n    });\n\n    myTargetClassNameField = new JTextField(targetClass.getName() + \"Test\");\n    setPreferredSize(myTargetClassNameField);\n    myTargetClassNameField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        getOKAction().setEnabled(JavaPsiFacade.getInstance(myProject).getNameHelper().isIdentifier(getClassName()));\n      }\n    });\n\n    mySuperClassField = JavaReferenceEditorUtil\n        .createReferenceEditorWithBrowseButton(new MyChooseSuperClassAction(), \"\", PsiManager.getInstance(myProject), true);\n    mySuperClassField.setMinimumSize(mySuperClassField.getPreferredSize());\n\n    String targetPackageName = targetPackage != null ? targetPackage.getQualifiedName() : \"\";\n    myTargetPackageField = new ReferenceEditorComboWithBrowseButton(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        doSelectPackage();\n      }\n    }, targetPackageName, PsiManager.getInstance(myProject), false, RECENTS_KEY);\n\n    new AnAction() {\n      public void actionPerformed(AnActionEvent e) {\n        myTargetPackageField.getButton().doClick();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.SHIFT_DOWN_MASK)),\n                                myTargetPackageField.getChildComponent());\n\n    myGenerateBeforeBox = new JCheckBox(\"setUp/@Before\");\n    myGenerateAfterBox = new JCheckBox(\"tearDown/@After\");\n\n    myShowInheritedMethodsBox = new JCheckBox(CodeInsightBundle.message(\"intention.create.test.dialog.show.inherited\"));\n    myShowInheritedMethodsBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateMethodsTable();\n      }\n    });\n    restoreShowInheritedMembersStatus();\n    myMethodsTable = new MemberSelectionTable(new MemberInfo[0], null);\n    updateMethodsTable();\n  }","id":74586,"modified_method":"private void initControls(PsiClass targetClass, PsiPackage targetPackage) {\n    ButtonGroup group = new ButtonGroup();\n\n    Map<String, JRadioButton> nameToButtonMap = new HashMap<String, JRadioButton>();\n    List<Pair<String, JRadioButton>> attachedLibraries = new ArrayList<Pair<String, JRadioButton>>();\n\n    for (final TestFrameworkDescriptor descriptor : Extensions.getExtensions(TestFrameworkDescriptor.EXTENSION_NAME)) {\n      final JRadioButton b = new JRadioButton(descriptor.getName());\n      myLibraryButtons.add(b);\n      group.add(b);\n\n      nameToButtonMap.put(descriptor.getName(), b);\n      if (descriptor.isLibraryAttached(myTargetModule)) {\n        attachedLibraries.add(Pair.create(descriptor.getName(), b));\n      }\n\n      b.addActionListener(new ActionListener() {\n        public void actionPerformed(ActionEvent e) {\n          if (b.isSelected()) onLibrarySelected(descriptor);\n        }\n      });\n    }\n\n    String defaultLibrary = getDefaultLibraryName();\n    if (attachedLibraries.isEmpty()) {\n      if (defaultLibrary != null) {\n        myDefaultLibraryButton = nameToButtonMap.get(defaultLibrary);\n      }\n    }\n    else {\n      if (defaultLibrary != null) {\n        for (Pair<String, JRadioButton> each : attachedLibraries) {\n          if (each.first.equals(defaultLibrary)) {\n            myDefaultLibraryButton = each.second;\n          }\n        }\n      }\n      myDefaultLibraryButton = attachedLibraries.get(0).second;\n    }\n    if (myDefaultLibraryButton == null) {\n      myDefaultLibraryButton = myLibraryButtons.get(0);\n    }\n\n    myFixLibraryButton = new JButton(CodeInsightBundle.message(\"intention.create.test.dialog.fix.library\"));\n    myFixLibraryButton.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        ApplicationManager.getApplication().runWriteAction(new Runnable() {\n          public void run() {\n            OrderEntryFix.addJarToRoots(mySelectedTestDescriptor.getLibraryPath(), myTargetModule);\n          }\n        });\n        myFixLibraryPanel.setVisible(false);\n      }\n    });\n\n    myTargetClassNameField = new JTextField(targetClass.getName() + \"Test\");\n    setPreferredSize(myTargetClassNameField);\n    myTargetClassNameField.getDocument().addDocumentListener(new DocumentAdapter() {\n      protected void textChanged(DocumentEvent e) {\n        getOKAction().setEnabled(JavaPsiFacade.getInstance(myProject).getNameHelper().isIdentifier(getClassName()));\n      }\n    });\n\n    mySuperClassField = JavaReferenceEditorUtil\n      .createReferenceEditorWithBrowseButton(new MyChooseSuperClassAction(), \"\", PsiManager.getInstance(myProject), true);\n    mySuperClassField.setMinimumSize(mySuperClassField.getPreferredSize());\n\n    String targetPackageName = targetPackage != null ? targetPackage.getQualifiedName() : \"\";\n    myTargetPackageField = new ReferenceEditorComboWithBrowseButton(new ActionListener() {\n      public void actionPerformed(final ActionEvent e) {\n        doSelectPackage();\n      }\n    }, targetPackageName, PsiManager.getInstance(myProject), false, RECENTS_KEY);\n\n    new AnAction() {\n      public void actionPerformed(AnActionEvent e) {\n        myTargetPackageField.getButton().doClick();\n      }\n    }.registerCustomShortcutSet(new CustomShortcutSet(KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, InputEvent.SHIFT_DOWN_MASK)),\n                                myTargetPackageField.getChildComponent());\n\n    myGenerateBeforeBox = new JCheckBox(\"setUp/@Before\");\n    myGenerateAfterBox = new JCheckBox(\"tearDown/@After\");\n\n    myShowInheritedMethodsBox = new JCheckBox(CodeInsightBundle.message(\"intention.create.test.dialog.show.inherited\"));\n    myShowInheritedMethodsBox.addActionListener(new ActionListener() {\n      public void actionPerformed(ActionEvent e) {\n        updateMethodsTable();\n      }\n    });\n    restoreShowInheritedMembersStatus();\n    myMethodsTable = new MemberSelectionTable(new MemberInfo[0], null);\n    updateMethodsTable();\n  }","commit_id":"550a161f1f62ce1ddd800051c41ec224deacc267","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n        public <T> void mutateAllLinks(final MutationType type, final ModelMutator<T> mutator) {\n            if (mutator.getSubject().getPath() != null) {\n                throw new IllegalArgumentException(\"Mutator must have null path.\");\n            }\n\n            registerListener(new ModelCreationListener() {\n                @Override\n                public boolean onCreate(ModelCreation registration) {\n                    if (node.getPath().equals(registration.getPath().getParent())) {\n                        bind(ModelReference.of(registration.getPath(), mutator.getSubject().getType()), type, mutator);\n                    }\n                    return false;\n                }\n            });\n        }","id":74587,"modified_method":"@Override\n        public <T> void mutateAllLinks(final MutationType type, final ModelMutator<T> mutator) {\n            if (mutator.getSubject().getPath() != null) {\n                throw new IllegalArgumentException(\"Mutator reference must have null path.\");\n            }\n\n            registerListener(new ModelCreationListener() {\n                @Override\n                public boolean onCreate(ModelCreation registration) {\n                    if (node.getPath().equals(registration.getPath().getParent())) {\n                        bind(ModelReference.of(registration.getPath(), mutator.getSubject().getType()), type, mutator);\n                    }\n                    return false;\n                }\n            });\n        }","commit_id":"55801062f98dcb5c0d8c074e29b365741409e915","url":"https://github.com/gradle/gradle"},{"original_method":"private void close(ModelNode node) {\n        if (node.getState() == ModelNode.State.GraphClosed) {\n            return;\n        }\n\n        ModelPath path = node.getPath();\n        LOGGER.debug(\"Closing {}\", path);\n\n        if (node.getState() == ModelNode.State.Known) {\n            BoundModelCreator creator = creators.remove(path);\n            if (creator == null) {\n                // Unbound creator - should give better error message here\n                throw new IllegalStateException(\"Don't know how to create model element at '\" + path + \"'\");\n            }\n            doCreate(node, creator);\n            node.setState(ModelNode.State.Created);\n        }\n        if (node.getState() == ModelNode.State.Created) {\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Mutate)), usedMutators);\n            node.setState(ModelNode.State.Mutated);\n        }\n        if (node.getState() == ModelNode.State.Mutated) {\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Finalize)), usedMutators);\n            node.setState(ModelNode.State.SelfClosed);\n        }\n        if (node.getState() == ModelNode.State.SelfClosed) {\n            for (ModelNode child : node.getLinks().values()) {\n                close(child);\n            }\n            node.setState(ModelNode.State.GraphClosed);\n        }\n        LOGGER.debug(\"Finished closing {}\", path);\n    }","id":74588,"modified_method":"private void close(ModelNode node) {\n        if (node.getState() == ModelNode.State.GraphClosed) {\n            return;\n        }\n\n        ModelPath path = node.getPath();\n        LOGGER.debug(\"Closing {}\", path);\n\n        if (node.getState() == ModelNode.State.Known) {\n            BoundModelCreator creator = creators.remove(path);\n            if (creator == null) {\n                // Unbound creator - should give better error message here\n                throw new IllegalStateException(\"Don't know how to create model element at '\" + path + \"'\");\n            }\n            doCreate(node, creator);\n            node.setState(ModelNode.State.Created);\n        }\n        if (node.getState() == ModelNode.State.Created) {\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Defaults)), usedMutators);\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Initialize)), usedMutators);\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Mutate)), usedMutators);\n            fireMutations(node, path, mutators.removeAll(new MutationKey(path, MutationType.Finalize)), usedMutators);\n            node.setState(ModelNode.State.SelfClosed);\n        }\n        if (node.getState() == ModelNode.State.SelfClosed) {\n            for (ModelNode child : node.getLinks().values()) {\n                close(child);\n            }\n            node.setState(ModelNode.State.GraphClosed);\n        }\n        LOGGER.debug(\"Finished closing {}\", path);\n    }","commit_id":"55801062f98dcb5c0d8c074e29b365741409e915","url":"https://github.com/gradle/gradle"},{"original_method":"public ModelRegistrySearchResult search(ModelPath path) {\n        return modelGraph.search(path);\n    }","id":74589,"modified_method":"public ModelSearchResult search(ModelPath path) {\n        return modelGraph.search(path);\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"public void validate() throws UnboundModelRulesException {\n        if (!binders.isEmpty()) {\n            ModelPathSuggestionProvider suggestionsProvider = new ModelPathSuggestionProvider(Iterables.concat(modelGraph.flattened.keySet(), creations.keySet()));\n            List<? extends UnboundRule> unboundRules = new UnboundRulesProcessor(binders, suggestionsProvider).process();\n            throw new UnboundModelRulesException(unboundRules);\n        }\n    }","id":74590,"modified_method":"public void validate() throws UnboundModelRulesException {\n        if (!binders.isEmpty()) {\n            ModelPathSuggestionProvider suggestionsProvider = new ModelPathSuggestionProvider(Iterables.concat(modelGraph.getFlattened().keySet(), creations.keySet()));\n            List<? extends UnboundRule> unboundRules = new UnboundRulesProcessor(binders, suggestionsProvider).process();\n            throw new UnboundModelRulesException(unboundRules);\n        }\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"private ModelNode createAndClose(BoundModelCreator creation) {\n        ModelNodeImpl node = doCreate(creation);\n        close(node);\n        return node;\n    }","id":74591,"modified_method":"private ModelNode createAndClose(BoundModelCreator creation) {\n        ModelNode node = doCreate(creation);\n        close(node);\n        return node;\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"private ModelNode get(ModelPath path) {\n        ModelRegistrySearchResult searchResult = modelGraph.search(path);\n        ModelNode targetNode = searchResult.getTargetNode();\n        if (targetNode != null) {\n            close((ModelNodeImpl) targetNode);\n            return targetNode;\n        }\n\n        inCreation = creations.remove(path);\n        if (inCreation == null) {\n            return null;\n        } else {\n            try {\n                return createAndClose(inCreation);\n            } finally {\n                inCreation = null;\n            }\n        }\n    }","id":74592,"modified_method":"private ModelNode get(ModelPath path) {\n        ModelSearchResult searchResult = modelGraph.search(path);\n        ModelNode targetNode = searchResult.getTargetNode();\n        if (targetNode != null) {\n            close(targetNode);\n            return targetNode;\n        }\n\n        inCreation = creations.remove(path);\n        if (inCreation == null) {\n            return null;\n        } else {\n            try {\n                return createAndClose(inCreation);\n            } finally {\n                inCreation = null;\n            }\n        }\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"private void close(ModelNodeImpl node) {\n        List<ModelPath> paths = modelGraph.getPaths(node);\n        for (ModelPath path : paths) {\n            fireMutations(node, path, mutators.removeAll(path), usedMutators);\n        }\n        for (ModelPath path : paths) {\n            fireMutations(node, path, finalizers.removeAll(path), usedFinalizers);\n        }\n\n        for (ModelNodeImpl modelNode : node.getLinks().values()) {\n            close(modelNode);\n        }\n    }","id":74593,"modified_method":"private void close(ModelNode node) {\n        ModelPath path = node.getCreationPath();\n        fireMutations(node, path, mutators.removeAll(path), usedMutators);\n        fireMutations(node, path, finalizers.removeAll(path), usedFinalizers);\n\n        for (ModelNode child : node.getLinks().values()) {\n            close(child);\n        }\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"private ModelNodeImpl doCreate(BoundModelCreator boundCreator) {\n        ModelCreator creator = boundCreator.getCreator();\n        ModelPath path = creator.getPath();\n        Inputs inputs = toInputs(boundCreator.getInputs());\n\n        ModelCreationContext creationContext;\n        try {\n            creationContext = creator.create(inputs);\n        } catch (Exception e) {\n            // TODO some representation of state of the inputs\n            throw new ModelRuleExecutionException(creator.getDescriptor(), e);\n        }\n\n        ModelAdapter adapter = creationContext.getAdapter();\n        ModelNodeImpl node = modelGraph.addEntryPoint(path.getName(), creator.getDescriptor(), creator.getPromise(), adapter);\n\n        try {\n            creationContext.getInitiatiser().execute(node);\n        } catch (Exception e) {\n            throw new ModelRuleExecutionException(creator.getDescriptor(), e);\n        }\n\n        return node;\n    }","id":74594,"modified_method":"private ModelNode doCreate(BoundModelCreator boundCreator) {\n        ModelCreator creator = boundCreator.getCreator();\n        ModelPath path = creator.getPath();\n        Inputs inputs = toInputs(boundCreator.getInputs());\n\n        ModelCreationContext creationContext;\n        try {\n            creationContext = creator.create(inputs);\n        } catch (Exception e) {\n            // TODO some representation of state of the inputs\n            throw new ModelRuleExecutionException(creator.getDescriptor(), e);\n        }\n\n        ModelAdapter adapter = creationContext.getAdapter();\n        ModelNode node = modelGraph.addEntryPoint(path.getName(), creator.getDescriptor(), creator.getPromise(), adapter);\n\n        try {\n            creationContext.getInitiatiser().execute(node);\n        } catch (Exception e) {\n            throw new ModelRuleExecutionException(creator.getDescriptor(), e);\n        }\n\n        return node;\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"public void create(ModelCreator creator) {\n        ModelPath path = creator.getPath();\n        if (path.getDepth() > 1) {\n            throw new IllegalStateException(\"Creator at path \" + path + \" not supported, must be top level\");\n        }\n\n        BoundModelCreator existingCreation = creations.get(path);\n\n        if (existingCreation != null) {\n            throw new DuplicateModelException(\n                    String.format(\n                            \"Cannot register model creation rule '%s' for path '%s' as the rule '%s' is already registered to create a model element at this path\",\n                            toString(creator.getDescriptor()),\n                            path,\n                            toString(existingCreation.getCreator().getDescriptor())\n                    )\n            );\n        }\n\n        ModelNode existing = modelGraph.entryNodes.get(path.getComponents().get(0));\n        if (existing != null) {\n            throw new DuplicateModelException(\n                    String.format(\n                            \"Cannot register model creation rule '%s' for path '%s' as the rule '%s' is already registered (and the model element has been created)\",\n                            toString(creator.getDescriptor()),\n                            path,\n                            toString(existing.getCreationDescriptor())\n                    )\n            );\n        }\n\n        notifyCreationListeners(creator.getDescriptor(), creator.getPath(), creator.getPromise());\n        bind(creator);\n    }","id":74595,"modified_method":"public void create(ModelCreator creator) {\n        ModelPath path = creator.getPath();\n        if (path.getDepth() > 1) {\n            throw new IllegalStateException(\"Creator at path \" + path + \" not supported, must be top level\");\n        }\n\n        BoundModelCreator existingCreation = creations.get(path);\n\n        if (existingCreation != null) {\n            throw new DuplicateModelException(\n                    String.format(\n                            \"Cannot register model creation rule '%s' for path '%s' as the rule '%s' is already registered to create a model element at this path\",\n                            toString(creator.getDescriptor()),\n                            path,\n                            toString(existingCreation.getCreator().getDescriptor())\n                    )\n            );\n        }\n\n        ModelSearchResult searchResult = modelGraph.search(path);\n        if (searchResult.getTargetNode() != null) {\n            throw new DuplicateModelException(\n                    String.format(\n                            \"Cannot register model creation rule '%s' for path '%s' as the rule '%s' is already registered (and the model element has been created)\",\n                            toString(creator.getDescriptor()),\n                            path,\n                            toString(searchResult.getTargetNode().getCreationDescriptor())\n                    )\n            );\n        }\n\n        notifyCreationListeners(creator.getDescriptor(), creator.getPath(), creator.getPromise());\n        bind(creator);\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"public void remove(ModelPath path) {\n        ModelRegistrySearchResult searchResult = modelGraph.search(path);\n        if (creations.remove(path) == null && searchResult.getTargetNode() == null) {\n            throw new RuntimeException(\"Tried to remove model \" + path + \" but it is not registered\");\n        }\n        if (isDependedOn(path)) {\n            throw new RuntimeException(\"Tried to remove model \" + path + \" but it is depended on by other model elements\");\n        }\n    }","id":74596,"modified_method":"public void remove(ModelPath path) {\n        ModelSearchResult searchResult = modelGraph.search(path);\n        if (creations.remove(path) == null && searchResult.getTargetNode() == null) {\n            throw new RuntimeException(\"Tried to remove model \" + path + \" but it is not registered\");\n        }\n        if (isDependedOn(path)) {\n            throw new RuntimeException(\"Tried to remove model \" + path + \" but it is depended on by other model elements\");\n        }\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"public void registerListener(ModelCreationListener listener) {\n        boolean remove;\n\n        // Copy the creations we know about now because a listener may add creations, causing a CME.\n        // This can happen when a listener is listening in order to bind a type-only reference, and the\n        // reference binding causing the rule to fully bind and register a new creation.\n        List<ModelPath> creationKeys = new ArrayList<ModelPath>(creations.keySet());\n\n        for (ModelPath key : creationKeys) {\n            BoundModelCreator boundCreator = creations.get(key);\n            ModelCreator creator = boundCreator.getCreator();\n            remove = listener.onCreate(creator.getDescriptor(), creator.getPath(), creator.getPromise());\n            if (remove) {\n                return;\n            }\n        }\n\n        for (Map.Entry<ModelPath, ModelNodeImpl> entry : modelGraph.flattened.entrySet()) {\n            ModelNodeImpl node = entry.getValue();\n            remove = listener.onCreate(node.getCreationDescriptor(), entry.getKey(), node.getPromise());\n            if (remove) {\n                return;\n            }\n        }\n\n        modelCreationListeners.add(listener);\n    }","id":74597,"modified_method":"public void registerListener(ModelCreationListener listener) {\n        boolean remove;\n\n        // Copy the creations we know about now because a listener may add creations, causing a CME.\n        // This can happen when a listener is listening in order to bind a type-only reference, and the\n        // reference binding causing the rule to fully bind and register a new creation.\n        List<ModelPath> creationKeys = new ArrayList<ModelPath>(creations.keySet());\n\n        for (ModelPath key : creationKeys) {\n            BoundModelCreator boundCreator = creations.get(key);\n            ModelCreator creator = boundCreator.getCreator();\n            remove = listener.onCreate(creator.getDescriptor(), creator.getPath(), creator.getPromise());\n            if (remove) {\n                return;\n            }\n        }\n\n        for (Map.Entry<ModelPath, ModelNode> entry : modelGraph.getFlattened().entrySet()) {\n            ModelNode node = entry.getValue();\n            remove = listener.onCreate(node.getCreationDescriptor(), entry.getKey(), node.getPromise());\n            if (remove) {\n                return;\n            }\n        }\n\n        modelCreationListeners.add(listener);\n    }","commit_id":"033ba3cb27b8e84de5d2e4f510d3ba3bb2bbc030","url":"https://github.com/gradle/gradle"},{"original_method":"protected void checkFunctionCorrectness(JetNamedFunction function, FunctionDescriptor functionDescriptor, DeclarationDescriptor containingDescriptor) {\n        if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) containingDescriptor;\n            if (functionDescriptor.getModifiers().isAbstract() && !classDescriptor.isAbstract()) {\n                trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                     \"Abstract method \" + function.getName() + \" in non-abstract class \" + classDescriptor.getName());\n            }\n            if (function.getBodyExpression() == null && !functionDescriptor.getModifiers().isAbstract()) {\n                trace.getErrorHandler().genericError(function.getNameIdentifier().getNode(), \"Method without body must be abstract\");\n            }\n            return;\n        }\n        if (functionDescriptor.getModifiers().isAbstract()) {\n            trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                 \"Global function \" + function.getName() + \" can not be abstract\");\n        }\n        if (function.getBodyExpression() == null && !functionDescriptor.getModifiers().isAbstract()) {\n            trace.getErrorHandler().genericError(function.getNameIdentifier().getNode(), \"Global function must have body\");\n        }\n    }","id":74598,"modified_method":"protected void checkFunctionCorrectness(JetNamedFunction function, FunctionDescriptor functionDescriptor, DeclarationDescriptor containingDescriptor) {\n        PsiElement nameIdentifier = function.getNameIdentifier();\n        if (containingDescriptor instanceof ClassDescriptor) {\n            ClassDescriptor classDescriptor = (ClassDescriptor) containingDescriptor;\n            if (functionDescriptor.getModifiers().isAbstract() && !classDescriptor.isAbstract()) {\n                trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                     \"Abstract method \" + function.getName() + \" in non-abstract class \" + classDescriptor.getName());\n            }\n            if (function.getBodyExpression() == null && !functionDescriptor.getModifiers().isAbstract() && nameIdentifier != null) {\n                trace.getErrorHandler().genericError(nameIdentifier.getNode(), \"Method \" + function.getName() + \" without body must be abstract\");\n            }\n            return;\n        }\n        if (functionDescriptor.getModifiers().isAbstract()) {\n            trace.getErrorHandler().genericError(function.getModifierList().getModifierNode(JetTokens.ABSTRACT_KEYWORD),\n                                                 \"Global function \" + function.getName() + \" can not be abstract\");\n        }\n        if (function.getBodyExpression() == null && !functionDescriptor.getModifiers().isAbstract() && nameIdentifier != null) {\n            trace.getErrorHandler().genericError(nameIdentifier.getNode(), \"Global function \" + function.getName() + \" must have body\");\n        }\n    }","commit_id":"d9137f18cc3fd2430b7f2596284a7b13dea995d1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void resolveAnnotationStubsOnClassesAndConstructors() {\n        for (Map.Entry<JetClass, MutableClassDescriptor> entry : classes.entrySet()) {\n            JetClass jetClass = entry.getKey();\n            MutableClassDescriptor mutableClassDescriptor = entry.getValue();\n\n            JetModifierList modifierList = jetClass.getModifierList();\n            if (modifierList != null) {\n                List<JetAnnotationEntry> annotationEntries = modifierList.getAnnotationEntries();\n                for (JetAnnotationEntry annotationEntry : annotationEntries) {\n                    AnnotationDescriptor annotationDescriptor = trace.get(ANNOTATION, annotationEntry);\n                    annotationResolver.resolveAnnotationStub(mutableClassDescriptor.getScopeForSupertypeResolution(), annotationEntry, annotationDescriptor);\n                }\n            }\n        }\n    }","id":74599,"modified_method":"private void resolveAnnotationStubsOnClassesAndConstructors() {\n        for (Map.Entry<JetClass, MutableClassDescriptor> entry : classes.entrySet()) {\n            JetClass jetClass = entry.getKey();\n            MutableClassDescriptor mutableClassDescriptor = entry.getValue();\n\n            JetModifierList modifierList = jetClass.getModifierList();\n            if (modifierList != null) {\n                List<JetAnnotationEntry> annotationEntries = modifierList.getAnnotationEntries();\n                for (JetAnnotationEntry annotationEntry : annotationEntries) {\n                    AnnotationDescriptor annotationDescriptor = trace.get(ANNOTATION, annotationEntry);\n                    if (annotationDescriptor != null) {\n                        annotationResolver.resolveAnnotationStub(mutableClassDescriptor.getScopeForSupertypeResolution(), annotationEntry, annotationDescriptor);\n                    }\n                }\n            }\n        }\n    }","commit_id":"d9137f18cc3fd2430b7f2596284a7b13dea995d1","url":"https://github.com/JetBrains/kotlin"},{"original_method":"private void analyzeCodeBlock(final PsiCodeBlock body, ProblemsHolder holder) {\n    if (body == null) return;\n    final StandardDataFlowRunner dfaRunner = new StandardDataFlowRunner(SUGGEST_NULLABLE_ANNOTATIONS);\n    final RunnerResult rc = dfaRunner.analyzeMethod(body);\n    if (rc == RunnerResult.OK) {\n      if (dfaRunner.problemsDetected()) {\n        createDescription(dfaRunner, holder);\n      }\n    }\n    else if (rc == RunnerResult.TOO_COMPLEX) {\n      if (body.getParent() instanceof PsiMethod) {\n        PsiMethod method = (PsiMethod)body.getParent();\n        holder.registerProblem(method.getNameIdentifier(), InspectionsBundle.message(\"dataflow.too.complex\"), ProblemHighlightType.INFO);\n      }\n    }\n  }","id":74600,"modified_method":"private void analyzeCodeBlock(final PsiCodeBlock body, ProblemsHolder holder) {\n    if (body == null) return;\n    final StandardDataFlowRunner dfaRunner = new StandardDataFlowRunner(SUGGEST_NULLABLE_ANNOTATIONS);\n    final RunnerResult rc = dfaRunner.analyzeMethod(body);\n    if (rc == RunnerResult.OK) {\n      if (dfaRunner.problemsDetected()) {\n        createDescription(dfaRunner, holder);\n      }\n    }\n    else if (rc == RunnerResult.TOO_COMPLEX) {\n      if (body.getParent() instanceof PsiMethod) {\n        PsiMethod method = (PsiMethod)body.getParent();\n        final PsiIdentifier name = method.getNameIdentifier();\n        if (name != null) { // Might be null for synthetic methods like JSP page.\n          holder.registerProblem(name, InspectionsBundle.message(\"dataflow.too.complex\"), ProblemHighlightType.INFO);\n        }\n      }\n    }\n  }","commit_id":"a5ad0703307406269ca1ad34371f321ed4746bf7","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public String getName() {\n    String name = myCachedName;\n    if (name == null){\n      if (getTreeElement() != null){\n        name = getNameIdentifier().getText();\n      }\n      else{\n        name = getRepositoryManager().getMethodView().getName(getRepositoryId());\n      }\n      myCachedName = name;\n    }\n    return name;\n  }","id":74601,"modified_method":"@NotNull\n  public String getName() {\n    String name = myCachedName;\n    if (name == null){\n      if (getTreeElement() != null){\n        final PsiIdentifier nameIdentifier = getNameIdentifier();\n        name = nameIdentifier != null ? nameIdentifier.getText() : \"<unnamed>\";\n      }\n      else{\n        name = getRepositoryManager().getMethodView().getName(getRepositoryId());\n      }\n      myCachedName = name;\n    }\n    return name;\n  }","commit_id":"92c2ca60977509a56020199d14b13c420d61d0af","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public ProblemDescriptor[] checkCodeBlock(final PsiCodeBlock body, InspectionManager manager, boolean isOnTheFly) {\n    if (body == null) return null;\n    final ControlFlow flow;\n    try {\n      ControlFlowPolicy policy = new ControlFlowPolicy() {\n        public PsiVariable getUsedVariable(PsiReferenceExpression refExpr) {\n          if (refExpr.isQualified()) return null;\n\n          PsiElement refElement = refExpr.resolve();\n          if (refElement instanceof PsiLocalVariable || refElement instanceof PsiParameter) {\n            if (!isVariableDeclaredInMethod((PsiVariable)refElement)) return null;\n            return (PsiVariable)refElement;\n          }\n\n          return null;\n        }\n\n        public boolean isParameterAccepted(PsiParameter psiParameter) {\n          return isVariableDeclaredInMethod(psiParameter);\n        }\n\n        public boolean isLocalVariableAccepted(PsiLocalVariable psiVariable) {\n          return isVariableDeclaredInMethod(psiVariable);\n        }\n\n        private boolean isVariableDeclaredInMethod(PsiVariable psiVariable) {\n          return PsiTreeUtil.getParentOfType(psiVariable, PsiClass.class) == PsiTreeUtil.getParentOfType(body, PsiClass.class);\n        }\n      };\n      flow = ControlFlowFactory.getControlFlow(body, policy, false);\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n\n    int start = flow.getStartOffset(body);\n    int end = flow.getEndOffset(body);\n\n    PsiVariable[] writtenVariables = ControlFlowUtil.getWrittenVariables(flow, start, end, false);\n    final HashSet<PsiVariable> ssaVarsSet = new HashSet<PsiVariable>();\n    body.accept(new PsiRecursiveElementVisitor() {\n      public void visitCodeBlock(PsiCodeBlock block) {\n        super.visitCodeBlock(block);\n        PsiElement anchor = block;\n        if (block.getParent() instanceof PsiSwitchStatement) {\n          anchor = block.getParent();\n        }\n        int from = flow.getStartOffset(anchor);\n        int end = flow.getEndOffset(anchor);\n        PsiVariable[] ssa = ControlFlowUtil.getSSAVariables(flow, from, end, true);\n        HashSet<PsiElement> declared = getDeclaredVariables(block);\n        for (PsiVariable psiVariable : ssa) {\n          if (declared.contains(psiVariable)) {\n            ssaVarsSet.add(psiVariable);\n          }\n        }\n      }\n\n      private HashSet<PsiElement> getDeclaredVariables(PsiCodeBlock block) {\n        final HashSet<PsiElement> result = new HashSet<PsiElement>();\n        PsiElement[] children = block.getChildren();\n        for (PsiElement child : children) {\n          child.accept(new PsiElementVisitor() {\n            public void visitReferenceExpression(PsiReferenceExpression expression) {\n              visitReferenceElement(expression);\n            }\n\n            public void visitDeclarationStatement(PsiDeclarationStatement statement) {\n              PsiElement[] declaredElements = statement.getDeclaredElements();\n              for (PsiElement declaredElement : declaredElements) {\n                if (declaredElement instanceof PsiVariable) result.add(declaredElement);\n              }\n            }\n          });\n        }\n\n        return result;\n      }\n\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n      }\n    });\n\n    ArrayList<PsiVariable> result = new ArrayList<PsiVariable>(ssaVarsSet);\n\n    if (body.getParent() instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)body.getParent();\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (PsiParameter parameter : parameters) {\n        if (!result.contains(parameter)) result.add(parameter);\n      }\n    }\n\n    PsiVariable[] psiVariables = result.toArray(new PsiVariable[result.size()]);\n    for (PsiVariable psiVariable : psiVariables) {\n      if (!isReportParameters() && psiVariable instanceof PsiParameter || !isReportVariables() && psiVariable instanceof PsiLocalVariable ||\n          psiVariable.hasModifierProperty(PsiModifier.FINAL)) {\n        result.remove(psiVariable);\n      }\n\n      if (psiVariable instanceof PsiLocalVariable) {\n        PsiDeclarationStatement decl = (PsiDeclarationStatement)psiVariable.getParent();\n        if (decl != null && decl.getParent() instanceof PsiForStatement) {\n          result.remove(psiVariable);\n        }\n      }\n    }\n\n    for (PsiVariable writtenVariable : writtenVariables) {\n      if (writtenVariable instanceof PsiParameter) {\n        result.remove(writtenVariable);\n      }\n    }\n\n    if (result.size() == 0) return null;\n    for (Iterator<PsiVariable> iterator = result.iterator(); iterator.hasNext();) {\n      final PsiVariable variable = iterator.next();\n      if (!variable.isPhysical()){\n        iterator.remove();\n      }\n    }\n    ProblemDescriptor[] problems = new ProblemDescriptor[result.size()];\n    for (int i = 0; i < problems.length; i++) {\n      PsiVariable problemVariable = result.get(i);\n      if (problemVariable instanceof PsiParameter){\n      problems[i] = manager.createProblemDescriptor(problemVariable.getNameIdentifier(),\n                                                    InspectionsBundle.message(\"inspection.can.be.local.parameter.problem.descriptor\"),\n                                                    myQuickFix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      } else {\n        problems[i] = manager.createProblemDescriptor(problemVariable.getNameIdentifier(),\n                                                      InspectionsBundle.message(\"inspection.can.be.local.variable.problem.descriptor\"),\n                                                      myQuickFix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      }\n    }\n\n    return problems;\n  }","id":74602,"modified_method":"@Nullable\n  public ProblemDescriptor[] checkCodeBlock(final PsiCodeBlock body, InspectionManager manager, boolean isOnTheFly) {\n    if (body == null) return null;\n    final ControlFlow flow;\n    try {\n      ControlFlowPolicy policy = new ControlFlowPolicy() {\n        public PsiVariable getUsedVariable(PsiReferenceExpression refExpr) {\n          if (refExpr.isQualified()) return null;\n\n          PsiElement refElement = refExpr.resolve();\n          if (refElement instanceof PsiLocalVariable || refElement instanceof PsiParameter) {\n            if (!isVariableDeclaredInMethod((PsiVariable)refElement)) return null;\n            return (PsiVariable)refElement;\n          }\n\n          return null;\n        }\n\n        public boolean isParameterAccepted(PsiParameter psiParameter) {\n          return isVariableDeclaredInMethod(psiParameter);\n        }\n\n        public boolean isLocalVariableAccepted(PsiLocalVariable psiVariable) {\n          return isVariableDeclaredInMethod(psiVariable);\n        }\n\n        private boolean isVariableDeclaredInMethod(PsiVariable psiVariable) {\n          return PsiTreeUtil.getParentOfType(psiVariable, PsiClass.class) == PsiTreeUtil.getParentOfType(body, PsiClass.class);\n        }\n      };\n      flow = ControlFlowFactory.getControlFlow(body, policy, false);\n    }\n    catch (AnalysisCanceledException e) {\n      return null;\n    }\n\n    int start = flow.getStartOffset(body);\n    int end = flow.getEndOffset(body);\n\n    PsiVariable[] writtenVariables = ControlFlowUtil.getWrittenVariables(flow, start, end, false);\n    final HashSet<PsiVariable> ssaVarsSet = new HashSet<PsiVariable>();\n    body.accept(new PsiRecursiveElementVisitor() {\n      public void visitCodeBlock(PsiCodeBlock block) {\n        super.visitCodeBlock(block);\n        PsiElement anchor = block;\n        if (block.getParent() instanceof PsiSwitchStatement) {\n          anchor = block.getParent();\n        }\n        int from = flow.getStartOffset(anchor);\n        int end = flow.getEndOffset(anchor);\n        PsiVariable[] ssa = ControlFlowUtil.getSSAVariables(flow, from, end, true);\n        HashSet<PsiElement> declared = getDeclaredVariables(block);\n        for (PsiVariable psiVariable : ssa) {\n          if (declared.contains(psiVariable)) {\n            ssaVarsSet.add(psiVariable);\n          }\n        }\n      }\n\n      private HashSet<PsiElement> getDeclaredVariables(PsiCodeBlock block) {\n        final HashSet<PsiElement> result = new HashSet<PsiElement>();\n        PsiElement[] children = block.getChildren();\n        for (PsiElement child : children) {\n          child.accept(new PsiElementVisitor() {\n            public void visitReferenceExpression(PsiReferenceExpression expression) {\n              visitReferenceElement(expression);\n            }\n\n            public void visitDeclarationStatement(PsiDeclarationStatement statement) {\n              PsiElement[] declaredElements = statement.getDeclaredElements();\n              for (PsiElement declaredElement : declaredElements) {\n                if (declaredElement instanceof PsiVariable) result.add(declaredElement);\n              }\n            }\n          });\n        }\n\n        return result;\n      }\n\n      public void visitReferenceExpression(PsiReferenceExpression expression) {\n      }\n    });\n\n    ArrayList<PsiVariable> result = new ArrayList<PsiVariable>(ssaVarsSet);\n\n    if (body.getParent() instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod)body.getParent();\n      PsiParameter[] parameters = method.getParameterList().getParameters();\n      for (PsiParameter parameter : parameters) {\n        if (!result.contains(parameter)) result.add(parameter);\n      }\n    }\n\n    PsiVariable[] psiVariables = result.toArray(new PsiVariable[result.size()]);\n    for (PsiVariable psiVariable : psiVariables) {\n      if (!isReportParameters() && psiVariable instanceof PsiParameter || !isReportVariables() && psiVariable instanceof PsiLocalVariable ||\n          psiVariable.hasModifierProperty(PsiModifier.FINAL)) {\n        result.remove(psiVariable);\n      }\n\n      if (psiVariable instanceof PsiLocalVariable) {\n        PsiDeclarationStatement decl = (PsiDeclarationStatement)psiVariable.getParent();\n        if (decl != null && decl.getParent() instanceof PsiForStatement) {\n          result.remove(psiVariable);\n        }\n      }\n    }\n\n    for (PsiVariable writtenVariable : writtenVariables) {\n      if (writtenVariable instanceof PsiParameter) {\n        result.remove(writtenVariable);\n      }\n    }\n\n    if (result.size() == 0) return null;\n    for (Iterator<PsiVariable> iterator = result.iterator(); iterator.hasNext();) {\n      final PsiVariable variable = iterator.next();\n      if (!variable.isPhysical()){\n        iterator.remove();\n      }\n    }\n    ProblemDescriptor[] problems = new ProblemDescriptor[result.size()];\n    for (int i = 0; i < problems.length; i++) {\n      PsiVariable problemVariable = result.get(i);\n      final PsiIdentifier nameIdenitier = problemVariable.getNameIdentifier();\n      PsiElement problemElement = nameIdenitier != null ? nameIdenitier : problemVariable;\n      if (problemVariable instanceof PsiParameter){\n        problems[i] = manager.createProblemDescriptor(problemElement,\n                                                      InspectionsBundle.message(\"inspection.can.be.local.parameter.problem.descriptor\"),\n                                                      myQuickFix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      } else {\n        problems[i] = manager.createProblemDescriptor(problemElement,\n                                                      InspectionsBundle.message(\"inspection.can.be.local.variable.problem.descriptor\"),\n                                                      myQuickFix, ProblemHighlightType.GENERIC_ERROR_OR_WARNING);\n      }\n    }\n\n    return problems;\n  }","commit_id":"9066de55ee3b35246203b06ebb056f47c7dd9da8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitImportStaticReferenceElement(@NotNull PsiImportStaticReferenceElement ref) {\n    final String refName = ref.getReferenceName();\n    final JavaResolveResult[] results = ref.multiResolve(false);\n\n    final PsiElement referenceNameElement = ref.getReferenceNameElement();\n    if (results.length == 0) {\n      final String description = JavaErrorMessages.message(\"cannot.resolve.symbol\", refName);\n      assert referenceNameElement != null : ref;\n      final HighlightInfo info =\n        HighlightInfo.newHighlightInfo(HighlightInfoType.WRONG_REF).range(referenceNameElement).descriptionAndTooltip(description).create();\n      QuickFixAction.registerQuickFixAction(info, QuickFixFactory.getInstance().createSetupJDKFix());\n      myHolder.add(info);\n    }\n    else {\n      final PsiManager manager = ref.getManager();\n      for (JavaResolveResult result : results) {\n        final PsiElement element = result.getElement();\n\n        String description = null;\n        if (element instanceof PsiClass) {\n          final Pair<PsiImportStaticReferenceElement, PsiClass> imported = mySingleImportedClasses.get(refName);\n          final PsiClass aClass = imported == null ? null : imported.getSecond();\n          if (aClass != null && !manager.areElementsEquivalent(aClass, element)) {\n            description = imported.first == null\n                          ? JavaErrorMessages.message(\"single.import.class.conflict\", refName)\n                          : imported.first.equals(ref)\n                            ? JavaErrorMessages.message(\"class.is.ambiguous.in.single.static.import\", refName)\n                            : JavaErrorMessages.message(\"class.is.already.defined.in.single.static.import\", refName);\n          }\n          mySingleImportedClasses.put(refName, Pair.create(ref, (PsiClass)element));\n        }\n        else if (element instanceof PsiField) {\n          final Pair<PsiImportStaticReferenceElement, PsiField> imported = mySingleImportedFields.get(refName);\n          final PsiField field = imported == null ? null : imported.getSecond();\n          if (field != null && !manager.areElementsEquivalent(field, element)) {\n            description = imported.first.equals(ref)\n                          ? JavaErrorMessages.message(\"field.is.ambiguous.in.single.static.import\", refName)\n                          : JavaErrorMessages.message(\"field.is.already.defined.in.single.static.import\", refName);\n          }\n          mySingleImportedFields.put(refName, Pair.create(ref, (PsiField)element));\n        }\n\n        if (description != null) {\n          myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(ref).descriptionAndTooltip(description).create());\n        }\n      }\n    }\n    if (!myHolder.hasErrorResults()) {\n      final PsiElement resolved = results.length == 1 ? results[0].getElement() : null;\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (resolved instanceof PsiClass) {\n        myHolder.add(HighlightNamesUtil.highlightClassName((PsiClass)resolved, ref, colorsScheme));\n      }\n      else{\n        myHolder.add(HighlightNamesUtil.highlightClassNameInQualifier(ref, colorsScheme));\n        if (resolved instanceof PsiVariable) {\n          myHolder.add(HighlightNamesUtil.highlightVariableName((PsiVariable)resolved, referenceNameElement, colorsScheme));\n        }\n        else if (resolved instanceof PsiMethod) {\n          myHolder.add(HighlightNamesUtil.highlightMethodName((PsiMethod)resolved, referenceNameElement, false, colorsScheme));\n        }\n      }\n    }\n  }","id":74603,"modified_method":"@Override\n  public void visitImportStaticReferenceElement(@NotNull PsiImportStaticReferenceElement ref) {\n    final String refName = ref.getReferenceName();\n    final JavaResolveResult[] results = ref.multiResolve(false);\n\n    final PsiElement referenceNameElement = ref.getReferenceNameElement();\n    if (results.length == 0) {\n      final String description = JavaErrorMessages.message(\"cannot.resolve.symbol\", refName);\n      assert referenceNameElement != null : ref;\n      final HighlightInfo info =\n        HighlightInfo.newHighlightInfo(HighlightInfoType.WRONG_REF).range(referenceNameElement).descriptionAndTooltip(description).create();\n      QuickFixAction.registerQuickFixAction(info, QuickFixFactory.getInstance().createSetupJDKFix());\n      myHolder.add(info);\n    }\n    else {\n      final PsiManager manager = ref.getManager();\n      for (JavaResolveResult result : results) {\n        final PsiElement element = result.getElement();\n\n        String description = null;\n        if (element instanceof PsiClass) {\n          final Pair<PsiImportStaticReferenceElement, PsiClass> imported = mySingleImportedClasses.get(refName);\n          final PsiClass aClass = imported == null ? null : imported.getSecond();\n          if (aClass != null && !manager.areElementsEquivalent(aClass, element)) {\n            //noinspection ConditionalExpressionWithIdenticalBranches\n            description = imported.first == null\n                          ? JavaErrorMessages.message(\"single.import.class.conflict\", refName)\n                          : imported.first.equals(ref)\n                            ? JavaErrorMessages.message(\"class.is.ambiguous.in.single.static.import\", refName)\n                            : JavaErrorMessages.message(\"class.is.already.defined.in.single.static.import\", refName);\n          }\n          mySingleImportedClasses.put(refName, Pair.create(ref, (PsiClass)element));\n        }\n        else if (element instanceof PsiField) {\n          final Pair<PsiImportStaticReferenceElement, PsiField> imported = mySingleImportedFields.get(refName);\n          final PsiField field = imported == null ? null : imported.getSecond();\n          if (field != null && !manager.areElementsEquivalent(field, element)) {\n            //noinspection ConditionalExpressionWithIdenticalBranches\n            description = imported.first.equals(ref)\n                          ? JavaErrorMessages.message(\"field.is.ambiguous.in.single.static.import\", refName)\n                          : JavaErrorMessages.message(\"field.is.already.defined.in.single.static.import\", refName);\n          }\n          mySingleImportedFields.put(refName, Pair.create(ref, (PsiField)element));\n        }\n\n        if (description != null) {\n          myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(ref).descriptionAndTooltip(description).create());\n        }\n      }\n    }\n    if (!myHolder.hasErrorResults()) {\n      final PsiElement resolved = results.length == 1 ? results[0].getElement() : null;\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (resolved instanceof PsiClass) {\n        myHolder.add(HighlightNamesUtil.highlightClassName((PsiClass)resolved, ref, colorsScheme));\n      }\n      else {\n        myHolder.add(HighlightNamesUtil.highlightClassNameInQualifier(ref, colorsScheme));\n        if (referenceNameElement != null) {\n          if (resolved instanceof PsiVariable) {\n            myHolder.add(HighlightNamesUtil.highlightVariableName((PsiVariable)resolved, referenceNameElement, colorsScheme));\n          }\n          else if (resolved instanceof PsiMethod) {\n            myHolder.add(HighlightNamesUtil.highlightMethodName((PsiMethod)resolved, referenceNameElement, false, colorsScheme));\n          }\n        }\n      }\n    }\n  }","commit_id":"3e63cb800a90d9a0e4df450b1cc6e31067251ecf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitMethod(PsiMethod method) {\n    super.visitMethod(method);\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightControlFlowUtil.checkUnreachableStatement(method.getBody()));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightMethodUtil.checkConstructorHandleSuperClassExceptions(method));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightMethodUtil.checkRecursiveConstructorInvocation(method));\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkSafeVarargsAnnotation(method, myLanguageLevel));\n\n    PsiClass aClass = method.getContainingClass();\n    if (!myHolder.hasErrorResults() && method.isConstructor()) {\n      myHolder.add(HighlightClassUtil.checkThingNotAllowedInInterface(method, aClass));\n    }\n    if (!myHolder.hasErrorResults() && method.hasModifierProperty(PsiModifier.DEFAULT)) {\n      myHolder.add(checkFeature(method, Feature.EXTENSION_METHODS));\n    }\n    if (!myHolder.hasErrorResults() && aClass != null && aClass.isInterface() && method.hasModifierProperty(PsiModifier.STATIC)) {\n      myHolder.add(checkFeature(method, Feature.EXTENSION_METHODS));\n    }\n    if (!myHolder.hasErrorResults() && aClass != null) {\n      myHolder.add(HighlightMethodUtil.checkDuplicateMethod(aClass, method, getDuplicateMethods(aClass)));\n    }\n\n    // method params are highlighted in visitMethod since we should make sure the method body was visited before\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n\n    for (PsiParameter parameter : parameters) {\n      int info = myReassignedParameters.get(parameter);\n      if (info == 0) continue; // out of this file\n      if (info == 2) {// reassigned\n        myHolder.add(HighlightNamesUtil.highlightReassignedVariable(parameter, parameter.getNameIdentifier()));\n      }\n      else {\n        myHolder.add(HighlightNamesUtil.highlightVariableName(parameter, parameter.getNameIdentifier(), colorsScheme));\n      }\n    }\n  }","id":74604,"modified_method":"@Override\n  public void visitMethod(PsiMethod method) {\n    super.visitMethod(method);\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightControlFlowUtil.checkUnreachableStatement(method.getBody()));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightMethodUtil.checkConstructorHandleSuperClassExceptions(method));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightMethodUtil.checkRecursiveConstructorInvocation(method));\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkSafeVarargsAnnotation(method, myLanguageLevel));\n\n    PsiClass aClass = method.getContainingClass();\n    if (!myHolder.hasErrorResults() && method.isConstructor()) {\n      myHolder.add(HighlightClassUtil.checkThingNotAllowedInInterface(method, aClass));\n    }\n    if (!myHolder.hasErrorResults() && method.hasModifierProperty(PsiModifier.DEFAULT)) {\n      myHolder.add(checkFeature(method, Feature.EXTENSION_METHODS));\n    }\n    if (!myHolder.hasErrorResults() && aClass != null && aClass.isInterface() && method.hasModifierProperty(PsiModifier.STATIC)) {\n      myHolder.add(checkFeature(method, Feature.EXTENSION_METHODS));\n    }\n    if (!myHolder.hasErrorResults() && aClass != null) {\n      myHolder.add(HighlightMethodUtil.checkDuplicateMethod(aClass, method, getDuplicateMethods(aClass)));\n    }\n\n    // method params are highlighted in visitMethod since we should make sure the method body was visited before\n    PsiParameter[] parameters = method.getParameterList().getParameters();\n    final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n\n    for (PsiParameter parameter : parameters) {\n      int info = myReassignedParameters.get(parameter);\n      if (info == 0) continue; // out of this file\n\n      PsiIdentifier nameIdentifier = parameter.getNameIdentifier();\n      if (nameIdentifier != null) {\n        if (info == 2) { // reassigned\n          myHolder.add(HighlightNamesUtil.highlightReassignedVariable(parameter, nameIdentifier));\n        }\n        else {\n          myHolder.add(HighlightNamesUtil.highlightVariableName(parameter, nameIdentifier, colorsScheme));\n        }\n      }\n    }\n  }","commit_id":"3e63cb800a90d9a0e4df450b1cc6e31067251ecf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitMethodReferenceExpression(PsiMethodReferenceExpression expression) {\n    myHolder.add(checkFeature(expression, Feature.METHOD_REFERENCES));\n\n    final JavaResolveResult result;\n    final JavaResolveResult[] results;\n    try {\n      results = expression.multiResolve(true);\n      result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n    }\n    catch (IndexNotReadyException e) {\n      return;\n    }\n    if (myRefCountHolder != null) {\n      myRefCountHolder.registerReference(expression, result);\n    }\n    final PsiElement method = result.getElement();\n    if (method != null && !result.isAccessible()) {\n      final String accessProblem = HighlightUtil.buildProblemWithAccessDescription(expression, result);\n      HighlightInfo info = HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(accessProblem).create();\n      myHolder.add(info);\n    } else {\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (method instanceof PsiMethod && !expression.isConstructor()) {\n        final PsiElement methodNameElement = expression.getReferenceNameElement();\n        myHolder.add(HighlightNamesUtil.highlightMethodName((PsiMethod)method, methodNameElement, false, colorsScheme));\n      }\n      myHolder.add(HighlightNamesUtil.highlightClassNameInQualifier(expression, colorsScheme));\n    }\n\n    if (!LambdaUtil.isValidLambdaContext(expression.getParent())) {\n      myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression)\n        .descriptionAndTooltip(\"Method reference expression is not expected here\").create());\n    }\n\n    final PsiType functionalInterfaceType = expression.getFunctionalInterfaceType();\n    if (!myHolder.hasErrorResults()) {\n      if (functionalInterfaceType != null) {\n        final boolean notFunctional = !LambdaUtil.isFunctionalType(functionalInterfaceType);\n        if (notFunctional) {\n          myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression)\n                         .descriptionAndTooltip(functionalInterfaceType.getPresentableText() + \" is not a functional interface\").create());\n        }\n      }\n    }\n      if (!myHolder.hasErrorResults()) {\n        final PsiElement referenceNameElement = expression.getReferenceNameElement();\n        if (referenceNameElement instanceof PsiKeyword) {\n          if (!PsiMethodReferenceUtil.isValidQualifier(expression)) {\n            final PsiElement qualifier = expression.getQualifier();\n            String description = \"Cannot find class \" + qualifier.getText();\n            HighlightInfo result1 =\n              HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(qualifier).descriptionAndTooltip(description).create();\n            myHolder.add(result1);\n          }\n        }\n      }\n    if (!myHolder.hasErrorResults()) {\n      checkFunctionalInterfaceTypeAccessible(expression, functionalInterfaceType);\n    }\n\n    if (!myHolder.hasErrorResults() && functionalInterfaceType != null) {\n      final String errorMessage = PsiMethodReferenceUtil.checkMethodReferenceContext(expression);\n      if (errorMessage != null) {\n        myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(errorMessage).create());\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      PsiElement qualifier = expression.getQualifier();\n      if (qualifier instanceof PsiTypeElement) {\n        final PsiType psiType = ((PsiTypeElement)qualifier).getType();\n        final HighlightInfo genericArrayCreationInfo = GenericsHighlightUtil.checkGenericArrayCreation(qualifier, psiType);\n        if (genericArrayCreationInfo != null) {\n          myHolder.add(genericArrayCreationInfo);\n        } else {\n          final String wildcardMessage = PsiMethodReferenceUtil.checkTypeArguments((PsiTypeElement)qualifier, psiType);\n          if (wildcardMessage != null) {\n            myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(qualifier).descriptionAndTooltip(wildcardMessage).create());\n          }\n        }\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      myHolder.add(PsiMethodReferenceHighlightingUtil.checkRawConstructorReference(expression));\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      myHolder.add(HighlightUtil.checkUnhandledExceptions(expression, expression.getTextRange()));\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      final String badReturnTypeMessage = PsiMethodReferenceUtil.checkReturnType(expression, result, functionalInterfaceType);\n      if (badReturnTypeMessage != null) {\n        myHolder.add(\n          HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(badReturnTypeMessage).create());\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      if (results.length == 0 || results[0] instanceof MethodCandidateInfo &&\n                                 !((MethodCandidateInfo)results[0]).isApplicable() &&\n                                 functionalInterfaceType != null) {\n        String description = null;\n        if (results.length == 1) {\n          description = ((MethodCandidateInfo)results[0]).getInferenceErrorMessage();\n        }\n        if (expression.isConstructor()) {\n          final PsiClass containingClass = PsiMethodReferenceUtil.getQualifierResolveResult(expression).getContainingClass();\n\n          if (containingClass != null) {\n            if (!myHolder.add(HighlightClassUtil.checkInstantiationOfAbstractClass(containingClass, expression)) &&\n                !myHolder.add(GenericsHighlightUtil.checkEnumInstantiation(expression, containingClass)) &&\n                containingClass.isPhysical() &&\n                description == null) {\n              description = JavaErrorMessages.message(\"cannot.resolve.constructor\", containingClass.getName());\n            }\n          }\n        }\n        else if (description == null){\n          description = JavaErrorMessages.message(\"cannot.resolve.method\", expression.getReferenceName());\n        }\n\n        if (description != null) {\n          final PsiElement referenceNameElement = expression.getReferenceNameElement();\n          final HighlightInfo highlightInfo =\n            HighlightInfo.newHighlightInfo(results.length == 0 ? HighlightInfoType.WRONG_REF : HighlightInfoType.ERROR)\n              .descriptionAndTooltip(description).range(referenceNameElement).create();\n          myHolder.add(highlightInfo);\n          final TextRange fixRange = HighlightMethodUtil.getFixRange(referenceNameElement);\n          QuickFixAction.registerQuickFixAction(highlightInfo, fixRange, QuickFixFactory.getInstance().createCreateMethodFromUsageFix(expression));\n        }\n      }\n    }\n  }","id":74605,"modified_method":"@Override\n  public void visitMethodReferenceExpression(PsiMethodReferenceExpression expression) {\n    myHolder.add(checkFeature(expression, Feature.METHOD_REFERENCES));\n\n    final JavaResolveResult result;\n    final JavaResolveResult[] results;\n    try {\n      results = expression.multiResolve(true);\n      result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n    }\n    catch (IndexNotReadyException e) {\n      return;\n    }\n    if (myRefCountHolder != null) {\n      myRefCountHolder.registerReference(expression, result);\n    }\n    final PsiElement method = result.getElement();\n    if (method != null && !result.isAccessible()) {\n      final String accessProblem = HighlightUtil.buildProblemWithAccessDescription(expression, result);\n      HighlightInfo info = HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(accessProblem).create();\n      myHolder.add(info);\n    }\n    else {\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (method instanceof PsiMethod && !expression.isConstructor()) {\n        PsiElement methodNameElement = expression.getReferenceNameElement();\n        if (methodNameElement != null) {\n          myHolder.add(HighlightNamesUtil.highlightMethodName((PsiMethod)method, methodNameElement, false, colorsScheme));\n        }\n      }\n      myHolder.add(HighlightNamesUtil.highlightClassNameInQualifier(expression, colorsScheme));\n    }\n\n    if (!LambdaUtil.isValidLambdaContext(expression.getParent())) {\n      String description = \"Method reference expression is not expected here\";\n      myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(description).create());\n    }\n\n    final PsiType functionalInterfaceType = expression.getFunctionalInterfaceType();\n    if (!myHolder.hasErrorResults()) {\n      if (functionalInterfaceType != null) {\n        final boolean notFunctional = !LambdaUtil.isFunctionalType(functionalInterfaceType);\n        if (notFunctional) {\n          String description = functionalInterfaceType.getPresentableText() + \" is not a functional interface\";\n          myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(description).create());\n        }\n      }\n    }\n      if (!myHolder.hasErrorResults()) {\n        final PsiElement referenceNameElement = expression.getReferenceNameElement();\n        if (referenceNameElement instanceof PsiKeyword) {\n          if (!PsiMethodReferenceUtil.isValidQualifier(expression)) {\n            PsiElement qualifier = expression.getQualifier();\n            if (qualifier != null) {\n              String description = \"Cannot find class \" + qualifier.getText();\n              myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(qualifier).descriptionAndTooltip(description).create());\n            }\n          }\n        }\n      }\n    if (!myHolder.hasErrorResults()) {\n      checkFunctionalInterfaceTypeAccessible(expression, functionalInterfaceType);\n    }\n\n    if (!myHolder.hasErrorResults() && functionalInterfaceType != null) {\n      final String errorMessage = PsiMethodReferenceUtil.checkMethodReferenceContext(expression);\n      if (errorMessage != null) {\n        myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(errorMessage).create());\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      PsiElement qualifier = expression.getQualifier();\n      if (qualifier instanceof PsiTypeElement) {\n        final PsiType psiType = ((PsiTypeElement)qualifier).getType();\n        final HighlightInfo genericArrayCreationInfo = GenericsHighlightUtil.checkGenericArrayCreation(qualifier, psiType);\n        if (genericArrayCreationInfo != null) {\n          myHolder.add(genericArrayCreationInfo);\n        }\n        else {\n          final String wildcardMessage = PsiMethodReferenceUtil.checkTypeArguments((PsiTypeElement)qualifier, psiType);\n          if (wildcardMessage != null) {\n            myHolder.add(HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(qualifier).descriptionAndTooltip(wildcardMessage).create());\n          }\n        }\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      myHolder.add(PsiMethodReferenceHighlightingUtil.checkRawConstructorReference(expression));\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      myHolder.add(HighlightUtil.checkUnhandledExceptions(expression, expression.getTextRange()));\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      final String badReturnTypeMessage = PsiMethodReferenceUtil.checkReturnType(expression, result, functionalInterfaceType);\n      if (badReturnTypeMessage != null) {\n        myHolder.add(\n          HighlightInfo.newHighlightInfo(HighlightInfoType.ERROR).range(expression).descriptionAndTooltip(badReturnTypeMessage).create());\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) {\n      if (results.length == 0 || results[0] instanceof MethodCandidateInfo &&\n                                 !((MethodCandidateInfo)results[0]).isApplicable() &&\n                                 functionalInterfaceType != null) {\n        String description = null;\n        if (results.length == 1) {\n          description = ((MethodCandidateInfo)results[0]).getInferenceErrorMessage();\n        }\n        if (expression.isConstructor()) {\n          final PsiClass containingClass = PsiMethodReferenceUtil.getQualifierResolveResult(expression).getContainingClass();\n\n          if (containingClass != null) {\n            if (!myHolder.add(HighlightClassUtil.checkInstantiationOfAbstractClass(containingClass, expression)) &&\n                !myHolder.add(GenericsHighlightUtil.checkEnumInstantiation(expression, containingClass)) &&\n                containingClass.isPhysical() &&\n                description == null) {\n              description = JavaErrorMessages.message(\"cannot.resolve.constructor\", containingClass.getName());\n            }\n          }\n        }\n        else if (description == null){\n          description = JavaErrorMessages.message(\"cannot.resolve.method\", expression.getReferenceName());\n        }\n\n        if (description != null) {\n          final PsiElement referenceNameElement = expression.getReferenceNameElement();\n          final HighlightInfo highlightInfo =\n            HighlightInfo.newHighlightInfo(results.length == 0 ? HighlightInfoType.WRONG_REF : HighlightInfoType.ERROR)\n              .descriptionAndTooltip(description).range(referenceNameElement).create();\n          myHolder.add(highlightInfo);\n          final TextRange fixRange = HighlightMethodUtil.getFixRange(referenceNameElement);\n          QuickFixAction.registerQuickFixAction(highlightInfo, fixRange, QuickFixFactory.getInstance().createCreateMethodFromUsageFix(expression));\n        }\n      }\n    }\n  }","commit_id":"3e63cb800a90d9a0e4df450b1cc6e31067251ecf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitReferenceExpression(PsiReferenceExpression expression) {\n    JavaResolveResult resultForIncompleteCode = doVisitReferenceElement(expression);\n    if (!myHolder.hasErrorResults()) {\n      visitExpression(expression);\n      if (myHolder.hasErrorResults()) return;\n    }\n    JavaResolveResult result;\n    JavaResolveResult[] results;\n    try {\n      results = resolveOptimised(expression);\n      result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n    }\n    catch (IndexNotReadyException e) {\n      return;\n    }\n    PsiElement resolved = result.getElement();\n    if (resolved instanceof PsiVariable && resolved.getContainingFile() == expression.getContainingFile()) {\n      if (!myHolder.hasErrorResults()) {\n        try {\n          myHolder.add(HighlightControlFlowUtil.checkVariableInitializedBeforeUsage(expression, (PsiVariable)resolved, myUninitializedVarProblems,myFile));\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n      PsiVariable variable = (PsiVariable)resolved;\n      boolean isFinal = variable.hasModifierProperty(PsiModifier.FINAL);\n      if (isFinal && !variable.hasInitializer()) {\n        if (!myHolder.hasErrorResults()) {\n          myHolder.add(HighlightControlFlowUtil.checkFinalVariableMightAlreadyHaveBeenAssignedTo(variable, expression, myFinalVarProblems));\n        }\n        if (!myHolder.hasErrorResults()) myHolder.add(HighlightControlFlowUtil.checkFinalVariableInitializedInLoop(expression, resolved));\n      }\n    }\n\n    PsiElement parent = expression.getParent();\n    if (parent instanceof PsiMethodCallExpression && ((PsiMethodCallExpression)parent).getMethodExpression() == expression && (!result.isAccessible() || !result.isStaticsScopeCorrect())) {\n      PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)parent;\n      PsiExpressionList list = methodCallExpression.getArgumentList();\n      if (!HighlightMethodUtil.isDummyConstructorCall(methodCallExpression, myResolveHelper, list, expression)) {\n        try {\n          myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallIdentifier(expression, results, list, resolved, result, methodCallExpression, myResolveHelper));\n\n          if (!PsiTreeUtil.findChildrenOfType(methodCallExpression.getArgumentList(), PsiLambdaExpression.class).isEmpty()) {\n            myHolder.add(HighlightMethodUtil\n              .checkAmbiguousMethodCallArguments(expression, results, list, resolved, result, methodCallExpression, myResolveHelper, expression.getReferenceNameElement()));\n          }\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n    }\n\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightUtil.checkExpressionRequired(expression, resultForIncompleteCode));\n    if (!myHolder.hasErrorResults() && resolved instanceof PsiField) {\n      try {\n        myHolder.add(HighlightUtil.checkIllegalForwardReferenceToField(expression, (PsiField)resolved));\n      }\n      catch (IndexNotReadyException ignored) { }\n    }\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkAccessStaticFieldFromEnumConstructor(expression, result));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightUtil.checkClassReferenceAfterQualifier(expression, resolved));\n    final PsiExpression qualifierExpression = expression.getQualifierExpression();\n    myHolder.add(HighlightUtil.checkUnqualifiedSuperInDefaultMethod(myLanguageLevel, expression, qualifierExpression));\n    if (!myHolder.hasErrorResults() && qualifierExpression != null) {\n      PsiType type = qualifierExpression.getType();\n      if (type instanceof PsiCapturedWildcardType) {\n        type = ((PsiCapturedWildcardType)type).getUpperBound();\n      }\n      final PsiClass psiClass = PsiUtil.resolveClassInType(type);\n      if (psiClass != null) {\n        myHolder.add(GenericsHighlightUtil.areSupersAccessible(psiClass, expression));\n      }\n    }\n  }","id":74606,"modified_method":"@Override\n  public void visitReferenceExpression(PsiReferenceExpression expression) {\n    JavaResolveResult resultForIncompleteCode = doVisitReferenceElement(expression);\n\n    if (!myHolder.hasErrorResults()) {\n      visitExpression(expression);\n      if (myHolder.hasErrorResults()) return;\n    }\n\n    JavaResolveResult result;\n    JavaResolveResult[] results;\n    try {\n      results = resolveOptimised(expression);\n      result = results.length == 1 ? results[0] : JavaResolveResult.EMPTY;\n    }\n    catch (IndexNotReadyException e) {\n      return;\n    }\n\n    PsiElement resolved = result.getElement();\n    if (resolved instanceof PsiVariable && resolved.getContainingFile() == expression.getContainingFile()) {\n      if (!myHolder.hasErrorResults()) {\n        try {\n          myHolder.add(HighlightControlFlowUtil.checkVariableInitializedBeforeUsage(expression, (PsiVariable)resolved, myUninitializedVarProblems,myFile));\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n      PsiVariable variable = (PsiVariable)resolved;\n      boolean isFinal = variable.hasModifierProperty(PsiModifier.FINAL);\n      if (isFinal && !variable.hasInitializer()) {\n        if (!myHolder.hasErrorResults()) {\n          myHolder.add(HighlightControlFlowUtil.checkFinalVariableMightAlreadyHaveBeenAssignedTo(variable, expression, myFinalVarProblems));\n        }\n        if (!myHolder.hasErrorResults()) myHolder.add(HighlightControlFlowUtil.checkFinalVariableInitializedInLoop(expression, resolved));\n      }\n    }\n\n    PsiElement parent = expression.getParent();\n    if (parent instanceof PsiMethodCallExpression &&\n        ((PsiMethodCallExpression)parent).getMethodExpression() == expression &&\n        (!result.isAccessible() || !result.isStaticsScopeCorrect())) {\n      PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)parent;\n      PsiExpressionList list = methodCallExpression.getArgumentList();\n      if (!HighlightMethodUtil.isDummyConstructorCall(methodCallExpression, myResolveHelper, list, expression)) {\n        try {\n          myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallIdentifier(\n            expression, results, list, resolved, result, methodCallExpression, myResolveHelper));\n\n          if (!PsiTreeUtil.findChildrenOfType(methodCallExpression.getArgumentList(), PsiLambdaExpression.class).isEmpty()) {\n            PsiElement nameElement = expression.getReferenceNameElement();\n            if (nameElement != null) {\n              myHolder.add(HighlightMethodUtil.checkAmbiguousMethodCallArguments(\n                expression, results, list, resolved, result, methodCallExpression, myResolveHelper, nameElement));\n            }\n          }\n        }\n        catch (IndexNotReadyException ignored) { }\n      }\n    }\n\n    if (!myHolder.hasErrorResults() && resultForIncompleteCode != null) {\n      myHolder.add(HighlightUtil.checkExpressionRequired(expression, resultForIncompleteCode));\n    }\n\n    if (!myHolder.hasErrorResults() && resolved instanceof PsiField) {\n      try {\n        myHolder.add(HighlightUtil.checkIllegalForwardReferenceToField(expression, (PsiField)resolved));\n      }\n      catch (IndexNotReadyException ignored) { }\n    }\n    if (!myHolder.hasErrorResults()) myHolder.add(GenericsHighlightUtil.checkAccessStaticFieldFromEnumConstructor(expression, result));\n    if (!myHolder.hasErrorResults()) myHolder.add(HighlightUtil.checkClassReferenceAfterQualifier(expression, resolved));\n    final PsiExpression qualifierExpression = expression.getQualifierExpression();\n    myHolder.add(HighlightUtil.checkUnqualifiedSuperInDefaultMethod(myLanguageLevel, expression, qualifierExpression));\n    if (!myHolder.hasErrorResults() && qualifierExpression != null) {\n      PsiType type = qualifierExpression.getType();\n      if (type instanceof PsiCapturedWildcardType) {\n        type = ((PsiCapturedWildcardType)type).getUpperBound();\n      }\n      final PsiClass psiClass = PsiUtil.resolveClassInType(type);\n      if (psiClass != null) {\n        myHolder.add(GenericsHighlightUtil.areSupersAccessible(psiClass, expression));\n      }\n    }\n  }","commit_id":"3e63cb800a90d9a0e4df450b1cc6e31067251ecf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean analyze(@NotNull final PsiFile file,\n                         final boolean updateWholeFile,\n                         @NotNull final HighlightInfoHolder holder,\n                         @NotNull final Runnable highlight) {\n    myFile = file;\n    myHolder = Holder.CHECK_ELEMENT_LEVEL ? new CheckLevelHighlightInfoHolder(file, holder) : holder;\n    boolean success = true;\n    try {\n      myLanguageLevel = PsiUtil.getLanguageLevel(file);\n      myJavaSdkVersion = ObjectUtils.notNull(JavaVersionService.getInstance().getJavaSdkVersion(file), JavaSdkVersion.fromLanguageLevel(myLanguageLevel));\n      if (updateWholeFile) {\n        final Project project = file.getProject();\n        DaemonCodeAnalyzerEx daemonCodeAnalyzer = DaemonCodeAnalyzerEx.getInstanceEx(project);\n        final FileStatusMap fileStatusMap = daemonCodeAnalyzer.getFileStatusMap();\n        final ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n        if (progress == null) throw new IllegalStateException(\"Must be run under progress\");\n        final RefCountHolder refCountHolder = RefCountHolder.get(file);\n        myRefCountHolder = refCountHolder;\n        final Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n        TextRange dirtyScope = ObjectUtils.notNull(document == null ? null : fileStatusMap.getFileDirtyScope(document, Pass.UPDATE_ALL), file.getTextRange());\n        success = refCountHolder.analyze(file, dirtyScope, progress, () -> {\n          highlight.run();\n          progress.checkCanceled();\n          PostHighlightingVisitor highlightingVisitor = new PostHighlightingVisitor(file, document, refCountHolder);\n          highlightingVisitor.collectHighlights(holder, progress);\n        });\n      }\n      else {\n        myRefCountHolder = null;\n        highlight.run();\n      }\n    }\n    finally {\n      myUninitializedVarProblems.clear();\n      myFinalVarProblems.clear();\n      mySingleImportedClasses.clear();\n      mySingleImportedFields.clear();\n      myReassignedParameters.clear();\n\n      myRefCountHolder = null;\n      myFile = null;\n      myHolder = null;\n      myDuplicateMethods.clear();\n      myOverrideEquivalentMethodsVisitedClasses.clear();\n    }\n\n    return success;\n  }","id":74607,"modified_method":"@Override\n  public boolean analyze(@NotNull PsiFile file, boolean updateWholeFile, @NotNull HighlightInfoHolder holder, @NotNull Runnable highlight) {\n    myFile = file;\n    myHolder = Holder.CHECK_ELEMENT_LEVEL ? new CheckLevelHighlightInfoHolder(file, holder) : holder;\n\n    boolean success = true;\n    try {\n      myLanguageLevel = PsiUtil.getLanguageLevel(file);\n      myJavaSdkVersion = notNull(JavaVersionService.getInstance().getJavaSdkVersion(file), JavaSdkVersion.fromLanguageLevel(myLanguageLevel));\n      if (updateWholeFile) {\n        Project project = file.getProject();\n        DaemonCodeAnalyzerEx daemonCodeAnalyzer = DaemonCodeAnalyzerEx.getInstanceEx(project);\n        FileStatusMap fileStatusMap = daemonCodeAnalyzer.getFileStatusMap();\n        ProgressIndicator progress = ProgressManager.getInstance().getProgressIndicator();\n        if (progress == null) throw new IllegalStateException(\"Must be run under progress\");\n        RefCountHolder refCountHolder = RefCountHolder.get(file);\n        myRefCountHolder = refCountHolder;\n        Document document = PsiDocumentManager.getInstance(project).getDocument(file);\n        TextRange dirtyScope = notNull(document == null ? null : fileStatusMap.getFileDirtyScope(document, Pass.UPDATE_ALL), file.getTextRange());\n        success = refCountHolder.analyze(file, dirtyScope, progress, () -> {\n          highlight.run();\n          progress.checkCanceled();\n          if (document != null) {\n            new PostHighlightingVisitor(file, document, refCountHolder).collectHighlights(holder, progress);\n          }\n        });\n      }\n      else {\n        myRefCountHolder = null;\n        highlight.run();\n      }\n    }\n    finally {\n      myUninitializedVarProblems.clear();\n      myFinalVarProblems.clear();\n      mySingleImportedClasses.clear();\n      mySingleImportedFields.clear();\n      myReassignedParameters.clear();\n\n      myRefCountHolder = null;\n      myFile = null;\n      myHolder = null;\n      myDuplicateMethods.clear();\n      myOverrideEquivalentMethodsVisitedClasses.clear();\n    }\n\n    return success;\n  }","commit_id":"3e63cb800a90d9a0e4df450b1cc6e31067251ecf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitDocTagValue(PsiDocTagValue value) {\n    PsiReference reference = value.getReference();\n    if (reference != null) {\n      PsiElement element = reference.resolve();\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (element instanceof PsiMethod) {\n        myHolder.add(HighlightNamesUtil.highlightMethodName((PsiMethod)element, ((PsiDocMethodOrFieldRef)value).getNameElement(), false,\n                                                            colorsScheme));\n      }\n      else if (element instanceof PsiParameter) {\n        myHolder.add(HighlightNamesUtil.highlightVariableName((PsiVariable)element, value.getNavigationElement(), colorsScheme));\n      }\n    }\n  }","id":74608,"modified_method":"@Override\n  public void visitDocTagValue(PsiDocTagValue value) {\n    PsiReference reference = value.getReference();\n    if (reference != null) {\n      PsiElement element = reference.resolve();\n      final TextAttributesScheme colorsScheme = myHolder.getColorsScheme();\n      if (element instanceof PsiMethod) {\n        PsiElement nameElement = ((PsiDocMethodOrFieldRef)value).getNameElement();\n        if (nameElement != null) {\n          myHolder.add(HighlightNamesUtil.highlightMethodName((PsiMethod)element, nameElement, false, colorsScheme));\n        }\n      }\n      else if (element instanceof PsiParameter) {\n        myHolder.add(HighlightNamesUtil.highlightVariableName((PsiVariable)element, value.getNavigationElement(), colorsScheme));\n      }\n    }\n  }","commit_id":"3e63cb800a90d9a0e4df450b1cc6e31067251ecf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitAnnotationArrayInitializer(PsiArrayInitializerMemberValue initializer) {\n    PsiMethod method = null;\n    PsiElement parent = initializer.getParent();\n    if (parent instanceof PsiNameValuePair) {\n      method = (PsiMethod)parent.getReference().resolve();\n    }\n    else if (PsiUtil.isAnnotationMethod(parent)) {\n      method = (PsiMethod)parent;\n    }\n    if (method != null) {\n      PsiType type = method.getReturnType();\n      if (type instanceof PsiArrayType) {\n        type = ((PsiArrayType)type).getComponentType();\n        PsiAnnotationMemberValue[] initializers = initializer.getInitializers();\n        for (PsiAnnotationMemberValue initializer1 : initializers) {\n          myHolder.add(AnnotationsHighlightUtil.checkMemberValueType(initializer1, type));\n        }\n      }\n    }\n  }","id":74609,"modified_method":"@Override\n  public void visitAnnotationArrayInitializer(PsiArrayInitializerMemberValue initializer) {\n    PsiMethod method = null;\n\n    PsiElement parent = initializer.getParent();\n    if (parent instanceof PsiNameValuePair) {\n      PsiReference reference = parent.getReference();\n      if (reference != null) {\n        method = (PsiMethod)reference.resolve();\n      }\n    }\n    else if (PsiUtil.isAnnotationMethod(parent)) {\n      method = (PsiMethod)parent;\n    }\n\n    if (method != null) {\n      PsiType type = method.getReturnType();\n      if (type instanceof PsiArrayType) {\n        type = ((PsiArrayType)type).getComponentType();\n        PsiAnnotationMemberValue[] initializers = initializer.getInitializers();\n        for (PsiAnnotationMemberValue initializer1 : initializers) {\n          myHolder.add(AnnotationsHighlightUtil.checkMemberValueType(initializer1, type));\n        }\n      }\n    }\n  }","commit_id":"3e63cb800a90d9a0e4df450b1cc6e31067251ecf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiMethodCallExpression generateMethodCall(PsiExpression instanceQualifier) throws IncorrectOperationException {\n    @NonNls StringBuffer buffer = new StringBuffer();\n\n    final boolean skipInstanceQualifier = instanceQualifier == null || instanceQualifier instanceof PsiThisExpression;\n    if (skipInstanceQualifier) {\n      if (myNeedChangeContext) {\n        boolean needsThisQualifier = false;\n        PsiElement parent = myCodeFragementMember;\n        while (!myTargetClass.equals(parent)) {\n          if (parent instanceof PsiMethod) {\n            String methodName = ((PsiMethod)parent).getName();\n            if (methodName.equals(myMethodName)) {\n              needsThisQualifier = true;\n              break;\n            }\n          }\n          parent = parent.getParent();\n        }\n        if (needsThisQualifier) {\n          buffer.append(myTargetClass.getName());\n          buffer.append(\".this.\");\n        }\n      }\n    }\n    else {\n      buffer.append(\"qqq.\");\n    }\n\n    buffer.append(myMethodName);\n    buffer.append(\"(\");\n    int count = 0;\n    for (ParameterTablePanel.VariableData data : myVariableDatum) {\n      if (data.passAsParameter) {\n        if (count > 0) {\n          buffer.append(\",\");\n        }\n        buffer.append(data.variable.getName());\n        count++;\n      }\n    }\n    buffer.append(\")\");\n    String text = buffer.toString();\n\n    PsiMethodCallExpression expr = (PsiMethodCallExpression)myElementFactory.createExpressionFromText(text, null);\n    expr = (PsiMethodCallExpression)myStyleManager.reformat(expr);\n    if (!skipInstanceQualifier) {\n      expr.getMethodExpression().getQualifierExpression().replace(instanceQualifier);\n    }\n    return expr;\n  }","id":74610,"modified_method":"private PsiMethodCallExpression generateMethodCall(PsiExpression instanceQualifier) throws IncorrectOperationException {\n    @NonNls StringBuffer buffer = new StringBuffer();\n\n    final boolean skipInstanceQualifier = instanceQualifier == null || instanceQualifier instanceof PsiThisExpression;\n    if (skipInstanceQualifier) {\n      if (myNeedChangeContext) {\n        boolean needsThisQualifier = false;\n        PsiElement parent = myCodeFragementMember;\n        while (!myTargetClass.equals(parent)) {\n          if (parent instanceof PsiMethod) {\n            String methodName = ((PsiMethod)parent).getName();\n            if (methodName.equals(myMethodName)) {\n              needsThisQualifier = true;\n              break;\n            }\n          }\n          parent = parent.getParent();\n        }\n        if (needsThisQualifier) {\n          buffer.append(myTargetClass.getName());\n          buffer.append(\".this.\");\n        }\n      }\n    }\n    else {\n      buffer.append(\"qqq.\");\n    }\n\n    buffer.append(myMethodName);\n    buffer.append(\"(\");\n    int count = 0;\n    for (ParameterTablePanel.VariableData data : myVariableDatum) {\n      if (data.passAsParameter) {\n        if (count > 0) {\n          buffer.append(\",\");\n        }\n        buffer.append(data.variable.getName());\n        count++;\n      }\n    }\n    buffer.append(\")\");\n    String text = buffer.toString();\n\n    PsiMethodCallExpression expr = (PsiMethodCallExpression)myElementFactory.createExpressionFromText(text, null);\n    expr = (PsiMethodCallExpression)myStyleManager.reformat(expr);\n    if (!skipInstanceQualifier) {\n      PsiExpression qualifierExpression = expr.getMethodExpression().getQualifierExpression();\n      LOG.assertTrue(qualifierExpression != null);\n      qualifierExpression.replace(instanceQualifier);\n    }\n    return expr;\n  }","commit_id":"999bc2873c4814abf9c66c63f95bf9e885d39bdb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean isDeclaredInside(PsiVariable variable) {\n    if (variable instanceof ImplicitVariable) return false;\n    int startOffset = myElements[0].getTextRange().getStartOffset();\n    int endOffset = myElements[myElements.length - 1].getTextRange().getEndOffset();\n    final TextRange range = variable.getNameIdentifier().getTextRange();\n    if (range == null) return false;\n    int offset = range.getStartOffset();\n    return startOffset <= offset && offset <= endOffset;\n  }","id":74611,"modified_method":"private boolean isDeclaredInside(PsiVariable variable) {\n    if (variable instanceof ImplicitVariable) return false;\n    int startOffset = myElements[0].getTextRange().getStartOffset();\n    int endOffset = myElements[myElements.length - 1].getTextRange().getEndOffset();\n    PsiIdentifier nameIdentifier = variable.getNameIdentifier();\n    if (nameIdentifier == null) return false;\n    final TextRange range = nameIdentifier.getTextRange();\n    if (range == null) return false;\n    int offset = range.getStartOffset();\n    return startOffset <= offset && offset <= endOffset;\n  }","commit_id":"999bc2873c4814abf9c66c63f95bf9e885d39bdb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private PsiMethod generateEmptyMethod(PsiClassType[] exceptions, boolean isStatic) throws IncorrectOperationException {\n\n    PsiMethod newMethod = myElementFactory.createMethod(myMethodName, myReturnType);\n    newMethod.getModifierList().setModifierProperty(myMethodVisibility, true);\n    newMethod.getModifierList().setModifierProperty(PsiModifier.STATIC, isStatic);\n    if (myTypeParameterList != null) {\n      newMethod.getTypeParameterList().replace(myTypeParameterList);\n    }\n    PsiCodeBlock body = newMethod.getBody();\n\n    boolean isFinal = CodeStyleSettingsManager.getSettings(myProject).GENERATE_FINAL_PARAMETERS;\n    PsiParameterList list = newMethod.getParameterList();\n    for (ParameterTablePanel.VariableData data : myVariableDatum) {\n      if (data.passAsParameter) {\n        PsiParameter parm = myElementFactory.createParameter(data.name, data.type);\n        if (isFinal) {\n          parm.getModifierList().setModifierProperty(PsiModifier.FINAL, true);\n        }\n        list.add(parm);\n      }\n      else {\n        @NonNls StringBuffer buffer = new StringBuffer();\n        if (isFinal) {\n          buffer.append(\"final \");\n        }\n        buffer.append(\"int \");\n        buffer.append(data.name);\n        buffer.append(\"=x;\");\n        String text = buffer.toString();\n\n        PsiDeclarationStatement declaration = (PsiDeclarationStatement)myElementFactory.createStatementFromText(text, null);\n        declaration = (PsiDeclarationStatement)myStyleManager.reformat(declaration);\n        final PsiTypeElement typeElement = myElementFactory.createTypeElement(data.type);\n        ((PsiVariable)declaration.getDeclaredElements()[0]).getTypeElement().replace(typeElement);\n        declaration = (PsiDeclarationStatement)body.add(declaration);\n\n        PsiExpression initializer = ((PsiVariable)declaration.getDeclaredElements()[0]).getInitializer();\n        TextRange range = initializer.getTextRange();\n        BlockSupport blockSupport = myProject.getComponent(BlockSupport.class);\n        blockSupport.reparseRange(body.getContainingFile(), range.getStartOffset(), range.getEndOffset(), \"...\");\n      }\n    }\n\n    PsiReferenceList throwsList = newMethod.getThrowsList();\n    for (PsiClassType exception : exceptions) {\n      throwsList.add(myManager.getElementFactory().createReferenceElementByType(exception));\n    }\n\n    return (PsiMethod)myStyleManager.reformat(newMethod);\n  }","id":74612,"modified_method":"private PsiMethod generateEmptyMethod(PsiClassType[] exceptions, boolean isStatic) throws IncorrectOperationException {\n\n    PsiMethod newMethod = myElementFactory.createMethod(myMethodName, myReturnType);\n    newMethod.getModifierList().setModifierProperty(myMethodVisibility, true);\n    newMethod.getModifierList().setModifierProperty(PsiModifier.STATIC, isStatic);\n    if (myTypeParameterList != null) {\n      newMethod.getTypeParameterList().replace(myTypeParameterList);\n    }\n    PsiCodeBlock body = newMethod.getBody();\n    LOG.assertTrue(body != null);\n\n    boolean isFinal = CodeStyleSettingsManager.getSettings(myProject).GENERATE_FINAL_PARAMETERS;\n    PsiParameterList list = newMethod.getParameterList();\n    for (ParameterTablePanel.VariableData data : myVariableDatum) {\n      if (data.passAsParameter) {\n        PsiParameter parm = myElementFactory.createParameter(data.name, data.type);\n        if (isFinal) {\n          parm.getModifierList().setModifierProperty(PsiModifier.FINAL, true);\n        }\n        list.add(parm);\n      }\n      else {\n        @NonNls StringBuffer buffer = new StringBuffer();\n        if (isFinal) {\n          buffer.append(\"final \");\n        }\n        buffer.append(\"int \");\n        buffer.append(data.name);\n        buffer.append(\"=x;\");\n        String text = buffer.toString();\n\n        PsiDeclarationStatement declaration = (PsiDeclarationStatement)myElementFactory.createStatementFromText(text, null);\n        declaration = (PsiDeclarationStatement)myStyleManager.reformat(declaration);\n        final PsiTypeElement typeElement = myElementFactory.createTypeElement(data.type);\n        ((PsiVariable)declaration.getDeclaredElements()[0]).getTypeElement().replace(typeElement);\n        declaration = (PsiDeclarationStatement)body.add(declaration);\n\n        PsiExpression initializer = ((PsiVariable)declaration.getDeclaredElements()[0]).getInitializer();\n        LOG.assertTrue(initializer != null);\n        TextRange range = initializer.getTextRange();\n        BlockSupport blockSupport = myProject.getComponent(BlockSupport.class);\n        blockSupport.reparseRange(body.getContainingFile(), range.getStartOffset(), range.getEndOffset(), \"...\");\n      }\n    }\n\n    PsiReferenceList throwsList = newMethod.getThrowsList();\n    for (PsiClassType exception : exceptions) {\n      throwsList.add(myManager.getElementFactory().createReferenceElementByType(exception));\n    }\n\n    return (PsiMethod)myStyleManager.reformat(newMethod);\n  }","commit_id":"999bc2873c4814abf9c66c63f95bf9e885d39bdb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean showDialog() {\n    ExtractMethodDialog dialog = new ExtractMethodDialog(myProject, myTargetClass, myInputVariables, myReturnType, myTypeParameterList,\n                                                         myThrownExceptions, myStatic, myCanBeStatic, myInitialMethodName,\n                                                         myRefactoringName, myHelpId);\n    dialog.show();\n    if (!dialog.isOK()) return false;\n    myMethodName = dialog.getChoosenMethodName();\n    myVariableDatum = dialog.getChoosenParameters();\n    myStatic = myStatic || dialog.isMakeStatic();\n    myMethodVisibility = dialog.getVisibility();\n\n    return true;\n  }","id":74613,"modified_method":"public boolean showDialog() {\n    ExtractMethodDialog dialog = new ExtractMethodDialog(myProject, myTargetClass, myInputVariables, myReturnType, myTypeParameterList,\n                                                         myThrownExceptions, myStatic, myCanBeStatic, myInitialMethodName,\n                                                         myRefactoringName, myHelpId);\n    dialog.show();\n    if (!dialog.isOK()) return false;\n    myMethodName = dialog.getChoosenMethodName();\n    myVariableDatum = dialog.getChoosenParameters();\n    myStatic |= dialog.isMakeStatic();\n    myMethodVisibility = dialog.getVisibility();\n\n    return true;\n  }","commit_id":"999bc2873c4814abf9c66c63f95bf9e885d39bdb","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"void registerProblems() {\n    final UnusedLocalFilter[] filters = Extensions.getExtensions(UnusedLocalFilter.EP_NAME);\n    // Register problems\n\n    Set<PyFunction> functionsWithInheritors = new  HashSet<PyFunction>();\n\n    for (PsiElement element : myUnusedElements) {\n      boolean ignoreUnused = false;\n      for (UnusedLocalFilter filter : filters) {\n        if (filter.ignoreUnused(element)) {\n          ignoreUnused = true;\n        }\n      }\n      if (ignoreUnused) continue;\n\n      // Local function\n      if (element instanceof PyFunction){\n        registerWarning(((PyFunction)element).getNameIdentifier(),\n                        PyBundle.message(\"INSP.unused.locals.local.function.isnot.used\",\n                        ((PyFunction)element).getName()));\n      } \n      // Local variable or parameter\n      else {\n        String name = element.getText();\n        if (element instanceof PyNamedParameter || element.getParent() instanceof PyNamedParameter) {\n          PyNamedParameter namedParameter = element instanceof PyNamedParameter\n                                            ? (PyNamedParameter) element\n                                            : (PyNamedParameter) element.getParent();\n          name = namedParameter.getName();\n          // Ignore unused self parameters as obligatory\n          if (\"self\".equals(name) && PyPsiUtils.isMethodContext(element)) {\n            continue;\n          }\n          // cls for @classmethod decorated methods\n          if (\"cls\".equals(name)) {\n            final Set<PyFunction.Flag> flagSet = PyUtil.detectDecorationsAndWrappersOf(PsiTreeUtil.getParentOfType(element, PyFunction.class));\n            if (flagSet.contains(PyFunction.Flag.CLASSMETHOD)) {\n              continue;\n            }\n          }\n          boolean isInitMethod = false;\n          PyClass containingClass = null;\n          PyParameterList paramList = PsiTreeUtil.getParentOfType(element, PyParameterList.class);\n          if (paramList != null && paramList.getParent() instanceof PyFunction) {\n            PyFunction func = (PyFunction) paramList.getParent();\n            containingClass = func.getContainingClass();\n            if (PyNames.INIT.equals(func.getName()) && containingClass != null) {\n              isInitMethod = true;\n            }\n            else if (ignoreUnusedParameters(func, functionsWithInheritors)) {\n              continue;\n            }\n          }\n          LocalQuickFix[] fixes = isInitMethod\n                                  ? new LocalQuickFix[] { new AddFieldQuickFix(name, containingClass, name) }\n                                  : LocalQuickFix.EMPTY_ARRAY;\n          registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name), fixes);\n        }\n        else {\n          if (myIgnoreTupleUnpacking && isTupleUnpacking(element)) {\n            continue;\n          }\n          if (PyForStatementNavigator.getPyForStatementByIterable(element) != null) {\n            registerProblem(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name),\n                            ProblemHighlightType.LIKE_UNUSED_SYMBOL, null, new ReplaceWithWildCard());\n          }\n          else {\n            registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n          }\n        }\n      }\n    }\n  }","id":74614,"modified_method":"void registerProblems() {\n    final UnusedLocalFilter[] filters = Extensions.getExtensions(UnusedLocalFilter.EP_NAME);\n    // Register problems\n\n    Set<PyFunction> functionsWithInheritors = new  HashSet<PyFunction>();\n\n    for (PsiElement element : myUnusedElements) {\n      boolean ignoreUnused = false;\n      for (UnusedLocalFilter filter : filters) {\n        if (filter.ignoreUnused(element)) {\n          ignoreUnused = true;\n        }\n      }\n      if (ignoreUnused) continue;\n\n      // Local function\n      if (element instanceof PyFunction){\n        final PsiElement nameIdentifier = ((PyFunction)element).getNameIdentifier();\n        registerWarning(nameIdentifier == null ? element : nameIdentifier,\n                        PyBundle.message(\"INSP.unused.locals.local.function.isnot.used\",\n                        ((PyFunction)element).getName()));\n      } \n      // Local variable or parameter\n      else {\n        String name = element.getText();\n        if (element instanceof PyNamedParameter || element.getParent() instanceof PyNamedParameter) {\n          PyNamedParameter namedParameter = element instanceof PyNamedParameter\n                                            ? (PyNamedParameter) element\n                                            : (PyNamedParameter) element.getParent();\n          name = namedParameter.getName();\n          // Ignore unused self parameters as obligatory\n          if (\"self\".equals(name) && PyPsiUtils.isMethodContext(element)) {\n            continue;\n          }\n          // cls for @classmethod decorated methods\n          if (\"cls\".equals(name)) {\n            final Set<PyFunction.Flag> flagSet = PyUtil.detectDecorationsAndWrappersOf(PsiTreeUtil.getParentOfType(element, PyFunction.class));\n            if (flagSet.contains(PyFunction.Flag.CLASSMETHOD)) {\n              continue;\n            }\n          }\n          boolean isInitMethod = false;\n          PyClass containingClass = null;\n          PyParameterList paramList = PsiTreeUtil.getParentOfType(element, PyParameterList.class);\n          if (paramList != null && paramList.getParent() instanceof PyFunction) {\n            PyFunction func = (PyFunction) paramList.getParent();\n            containingClass = func.getContainingClass();\n            if (PyNames.INIT.equals(func.getName()) && containingClass != null) {\n              isInitMethod = true;\n            }\n            else if (ignoreUnusedParameters(func, functionsWithInheritors)) {\n              continue;\n            }\n          }\n          LocalQuickFix[] fixes = isInitMethod\n                                  ? new LocalQuickFix[] { new AddFieldQuickFix(name, containingClass, name) }\n                                  : LocalQuickFix.EMPTY_ARRAY;\n          registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name), fixes);\n        }\n        else {\n          if (myIgnoreTupleUnpacking && isTupleUnpacking(element)) {\n            continue;\n          }\n          if (PyForStatementNavigator.getPyForStatementByIterable(element) != null) {\n            registerProblem(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name),\n                            ProblemHighlightType.LIKE_UNUSED_SYMBOL, null, new ReplaceWithWildCard());\n          }\n          else {\n            registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n          }\n        }\n      }\n    }\n  }","commit_id":"082af605e262d15dcf663a9af9430278c0f9d9df","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement restoreElement() {\n      if (myVar.getNameIdentifier() == null) return myVar;\n      if (myVar.getNameIdentifier().isValid()) return myVar;\n      return null;\n    }","id":74615,"modified_method":"public PsiElement restoreElement() {\n      PsiIdentifier psiIdentifier = myVar.getNameIdentifier();\n      if (psiIdentifier == null || psiIdentifier.isValid()) return myVar;\n      return null;\n    }","commit_id":"28438b826496e51c898ad00e4c9bffcbff4e15c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public PsiElement setName(@NonNls @NotNull String name) throws IncorrectOperationException {\n        return getNameIdentifier().replace(JetPsiFactory(this).createNameIdentifier(name));\n    }","id":74616,"modified_method":"@Override\n    public PsiElement setName(@NonNls @NotNull String name) throws IncorrectOperationException {\n        PsiElement identifier = getNameIdentifier();\n        return identifier != null ? identifier.replace(JetPsiFactory(this).createNameIdentifier(name)) : null;\n    }","commit_id":"dd7ef4d89f075241433679b75743a2505846e705","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n  public void computeUsages(final List<PsiClass> classes) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.highlight.implements\");\n    for (PsiMethod method : myClass.getMethods()) {\n      List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n      for (HierarchicalMethodSignature superSignature : superSignatures) {\n        PsiClass containingClass = superSignature.getMethod().getContainingClass();\n        if (containingClass == null) continue;\n        for (PsiClass classToAnalyze : classes) {\n          if (InheritanceUtil.isInheritorOrSelf(classToAnalyze, containingClass, true)) {\n            addOccurrence(method.getNameIdentifier());\n            break;\n          }\n        }\n      }\n    }\n    if (myReadUsages.isEmpty()) {\n      if (ApplicationManager.getApplication().isUnitTestMode()) return;\n      String name;\n      if (classes.size() == 1) {\n        final ItemPresentation presentation = classes.get(0).getPresentation();\n        name = presentation != null ? presentation.getPresentableText() : \"\";\n      }\n      else {\n        name = \"\";\n      }\n      myHintText = CodeInsightBundle.message(\"no.methods.overriding.0.are.found\", classes.size(), name);\n    }\n    else {\n      addOccurrence(myTarget);\n      final int methodCount = myReadUsages.size()-1;  // exclude 'target' keyword\n      myStatusText = CodeInsightBundle.message(\"status.bar.overridden.methods.highlighted.message\", methodCount,\n                                                                        HighlightUsagesHandler.getShortcutText());\n    }\n  }","id":74617,"modified_method":"@Override\n  public void computeUsages(final List<PsiClass> classes) {\n    FeatureUsageTracker.getInstance().triggerFeatureUsed(\"codeassists.highlight.implements\");\n    for (PsiMethod method : myClass.getMethods()) {\n      List<HierarchicalMethodSignature> superSignatures = method.getHierarchicalMethodSignature().getSuperSignatures();\n      for (HierarchicalMethodSignature superSignature : superSignatures) {\n        PsiClass containingClass = superSignature.getMethod().getContainingClass();\n        if (containingClass == null) continue;\n        for (PsiClass classToAnalyze : classes) {\n          if (InheritanceUtil.isInheritorOrSelf(classToAnalyze, containingClass, true)) {\n            PsiIdentifier identifier = method.getNameIdentifier();\n            if (identifier != null) {\n              addOccurrence(identifier);\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (myReadUsages.isEmpty()) {\n      if (ApplicationManager.getApplication().isUnitTestMode()) return;\n      String name;\n      if (classes.size() == 1) {\n        final ItemPresentation presentation = classes.get(0).getPresentation();\n        name = presentation != null ? presentation.getPresentableText() : \"\";\n      }\n      else {\n        name = \"\";\n      }\n      myHintText = CodeInsightBundle.message(\"no.methods.overriding.0.are.found\", classes.size(), name);\n    }\n    else {\n      addOccurrence(myTarget);\n      final int methodCount = myReadUsages.size()-1;  // exclude 'target' keyword\n      myStatusText = CodeInsightBundle.message(\"status.bar.overridden.methods.highlighted.message\", methodCount,\n                                                                        HighlightUsagesHandler.getShortcutText());\n    }\n  }","commit_id":"421c5772c1076fc8b32ed798cc4041f114101874","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected AbstractLayoutCodeProcessor(Project project,\n                                        PsiFile file,\n                                        String progressText,\n                                        String commandName,\n                                        boolean processChangedTextOnly)\n  {\n    myProject = project;\n    myModule = null;\n    myFile = file;\n    myProgressText = progressText;\n    myCommandName = commandName;\n    myPostRunnable = null;\n    myProcessChangedTextOnly = processChangedTextOnly;\n    myNotificationInfo = new LayoutCodeNotification();\n  }","id":74618,"modified_method":"protected AbstractLayoutCodeProcessor(Project project,\n                                        PsiFile file,\n                                        String progressText,\n                                        String commandName,\n                                        boolean processChangedTextOnly)\n  {\n    myProject = project;\n    myModule = null;\n    myFile = file;\n    myProgressText = progressText;\n    myCommandName = commandName;\n    myPostRunnable = null;\n    myProcessChangedTextOnly = processChangedTextOnly;\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected AbstractLayoutCodeProcessor(@NotNull AbstractLayoutCodeProcessor previous,\n                                        @NotNull String commandName,\n                                        @NotNull String progressText)\n  {\n    myProject = previous.myProject;\n    myModule = previous.myModule;\n    myDirectory = previous.myDirectory;\n    myFile = previous.myFile;\n    myFiles = previous.myFiles;\n    myIncludeSubdirs = previous.myIncludeSubdirs;\n    myProcessChangedTextOnly = previous.myProcessChangedTextOnly;\n\n    myPostRunnable = null;\n    myProgressText = progressText;\n    myCommandName = commandName;\n    myPreviousCodeProcessor = previous;\n    myFilters = previous.myFilters;\n    myNotificationInfo = previous.myNotificationInfo;\n  }","id":74619,"modified_method":"protected AbstractLayoutCodeProcessor(@NotNull AbstractLayoutCodeProcessor previous,\n                                        @NotNull String commandName,\n                                        @NotNull String progressText)\n  {\n    myProject = previous.myProject;\n    myModule = previous.myModule;\n    myDirectory = previous.myDirectory;\n    myFile = previous.myFile;\n    myFiles = previous.myFiles;\n    myIncludeSubdirs = previous.myIncludeSubdirs;\n    myProcessChangedTextOnly = previous.myProcessChangedTextOnly;\n\n    myPostRunnable = null;\n    myProgressText = progressText;\n    myCommandName = commandName;\n    myPreviousCodeProcessor = previous;\n    myFilters = previous.myFilters;\n    myInfoCollector = previous.myInfoCollector;\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private String prepareMessage() {\n    StringBuilder builder = new StringBuilder(\"<html>\");\n    LayoutCodeNotification notifications = myProcessor.getNotificationInfo();\n    LOG.assertTrue(notifications != null);\n\n    if (notifications.isEmpty() && !myNoChangesDetected) {\n      if (myProcessChangesTextOnly) {\n        builder.append(\"Changes since last revision: processed, nothing modified\").append(\"<br>\");\n      }\n      else {\n        builder.append(\"Code processed, nothing modified\").append(\"<br>\");\n      }\n    }\n    else {\n      if (notifications.hasReformatOrRearrangeNotification()) {\n        String reformatInfo = notifications.getReformatCodeNotification();\n        String rearrangeInfo = notifications.getRearrangeCodeNotification();\n\n        String firstNotificationLine = joinWithCommaAndCapitalize(reformatInfo, rearrangeInfo);\n        if (myProcessChangesTextOnly) {\n          builder.append(\"Changes since last revision: \");\n          firstNotificationLine = StringUtil.decapitalize(firstNotificationLine);\n        }\n\n        builder.append(firstNotificationLine).append(\"<br>\");\n      }\n      else if (myNoChangesDetected) {\n        builder.append(\"Nothing to format\");\n        if (myShouldRearrangeCode) {\n          builder.append(\" and rearrange\");\n        }\n        builder.append(\", no changes since last revision\").append(\"<br>\");\n      }\n\n      String optimizeImportsNotification = notifications.getOptimizeImportsNotification();\n      if (optimizeImportsNotification != null) {\n        builder.append(StringUtil.capitalize(optimizeImportsNotification)).append(\"<br>\");\n      }\n    }\n\n    String shortcutText = KeymapUtil.getFirstKeyboardShortcutText(ActionManager.getInstance().getAction(\"ReformatFile\"));\n    builder.append(\"<span style='color:\").append(COLOR).append(\"'>\")\n           .append(\"Show reformat dialog: \")\n           .append(shortcutText)\n           .append(\"<\/span>\")\n           .append(\"<\/html>\");\n\n    return builder.toString();\n  }","id":74620,"modified_method":"@NotNull\n  private String prepareMessage() {\n    StringBuilder builder = new StringBuilder(\"<html>\");\n    LayoutCodeInfoCollector notifications = myProcessor.getInfoCollector();\n    LOG.assertTrue(notifications != null);\n\n    if (notifications.isEmpty() && !myNoChangesDetected) {\n      if (myProcessChangesTextOnly) {\n        builder.append(\"Changes since last revision: processed, nothing modified\").append(\"<br>\");\n      }\n      else {\n        builder.append(\"Code processed, nothing modified\").append(\"<br>\");\n      }\n    }\n    else {\n      if (notifications.hasReformatOrRearrangeNotification()) {\n        String reformatInfo = notifications.getReformatCodeNotification();\n        String rearrangeInfo = notifications.getRearrangeCodeNotification();\n\n        String firstNotificationLine = joinWithCommaAndCapitalize(reformatInfo, rearrangeInfo);\n        if (myProcessChangesTextOnly) {\n          builder.append(\"Changes since last revision: \");\n          firstNotificationLine = StringUtil.decapitalize(firstNotificationLine);\n        }\n\n        builder.append(firstNotificationLine).append(\"<br>\");\n      }\n      else if (myNoChangesDetected) {\n        builder.append(\"Nothing to format\");\n        if (myShouldRearrangeCode) {\n          builder.append(\" and rearrange\");\n        }\n        builder.append(\", no changes since last revision\").append(\"<br>\");\n      }\n\n      String optimizeImportsNotification = notifications.getOptimizeImportsNotification();\n      if (optimizeImportsNotification != null) {\n        builder.append(StringUtil.capitalize(optimizeImportsNotification)).append(\"<br>\");\n      }\n    }\n\n    String shortcutText = KeymapUtil.getFirstKeyboardShortcutText(ActionManager.getInstance().getAction(\"ReformatFile\"));\n    builder.append(\"<span style='color:\").append(SHORTCUT_TEXT_COLOR).append(\"'>\")\n           .append(\"Show reformat dialog: \").append(shortcutText).append(\"<\/span>\")\n           .append(\"<\/html>\");\n\n    return builder.toString();\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void processCode() {\n    if (myShouldOptimizeImports) {\n      myProcessor = new OptimizeImportsProcessor(myProject, myFile);\n    }\n\n    if (myProcessChangesTextOnly && !FormatChangedTextUtil.hasChanges(myFile)) {\n      myNoChangesDetected = true;\n    }\n\n    myProcessor = mixWithReformatProcessor(myProcessor);\n    if (myShouldRearrangeCode) {\n      myProcessor = mixWithRearrangeProcessor(myProcessor);\n    }\n\n    if (myShouldNotify) {\n      myProcessor.setPostRunnable(new Runnable() {\n        @Override\n        public void run() {\n          String message = prepareMessage();\n          if (!myEditor.isDisposed() && myEditor.getComponent().isShowing()) {\n            showHint(myEditor, message);\n          }\n        }\n      });\n    }\n\n    myProcessor.run();\n  }","id":74621,"modified_method":"public void processCode() {\n    if (myShouldOptimizeImports) {\n      myProcessor = new OptimizeImportsProcessor(myProject, myFile);\n    }\n\n    if (myProcessChangesTextOnly && !FormatChangedTextUtil.hasChanges(myFile)) {\n      myNoChangesDetected = true;\n    }\n\n    myProcessor = mixWithReformatProcessor(myProcessor);\n    if (myShouldRearrangeCode) {\n      myProcessor = mixWithRearrangeProcessor(myProcessor);\n    }\n\n    if (myShouldNotify) {\n      myProcessor.setCollectInfo(true);\n      myProcessor.setPostRunnable(new Runnable() {\n        @Override\n        public void run() {\n          String message = prepareMessage();\n          if (!myEditor.isDisposed() && myEditor.getComponent().isShowing()) {\n            showHint(myEditor, message);\n          }\n        }\n      });\n    }\n\n    myProcessor.run();\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void prepareUserInfoMessage(Set<ImportOptimizer> optimizers) {\n    if (optimizers.size() == 1) {\n      ImportOptimizer optimizer = optimizers.iterator().next();\n      if (optimizer instanceof UserNotificationInfoProvider) {\n        String info = ((UserNotificationInfoProvider)optimizer).getUserNotificationInfo();\n        if (info != null && getNotificationInfo() != null) {\n          getNotificationInfo().setOptimizeImportsNotification(info);\n        }\n        return;\n      }\n    }\n\n    if (getNotificationInfo() != null) {\n      getNotificationInfo().setOptimizeImportsNotification(\"imports optimized\");\n    }\n  }","id":74622,"modified_method":"private void prepareUserInfoMessage(Set<ImportOptimizer> optimizers) {\n    if (getInfoCollector() == null) return;\n\n    if (optimizers.size() == 1) {\n      ImportOptimizer optimizer = optimizers.iterator().next();\n      if (optimizer instanceof UserNotificationInfoProvider) {\n        String info = ((UserNotificationInfoProvider)optimizer).getUserNotificationInfo();\n        getInfoCollector().setOptimizeImportsNotification(info);\n        return;\n      }\n    }\n\n    getInfoCollector().setOptimizeImportsNotification(\"imports optimized\");\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Runnable prepareRearrangeCommand(@NotNull final PsiFile file, @NotNull final Collection<TextRange> ranges) {\n    final ArrangementEngine engine = ServiceManager.getService(myProject, ArrangementEngine.class);\n    return new Runnable() {\n      @Override\n      public void run() {\n        engine.arrange(file, ranges);\n        String info = engine.getUserNotificationInfo();\n        if (info != null && getNotificationInfo() != null) {\n          getNotificationInfo().setRearrangeCodeNotification(info);\n        }\n      }\n    };\n  }","id":74623,"modified_method":"@NotNull\n  private Runnable prepareRearrangeCommand(@NotNull final PsiFile file, @NotNull final Collection<TextRange> ranges) {\n    final ArrangementEngine engine = ServiceManager.getService(myProject, ArrangementEngine.class);\n    return new Runnable() {\n      @Override\n      public void run() {\n        engine.arrange(file, ranges);\n        if (getInfoCollector() != null) {\n          String info = engine.getUserNotificationInfo();\n          getInfoCollector().setRearrangeCodeNotification(info);\n        }\n      }\n    };\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void prepareUserNotificationMessage(@NotNull Document document, @NotNull CharSequence before) {\n    int number = getProcessedLinesNumber(document, before);\n    if (number > 0 && getNotificationInfo() != null) {\n      String message = \"formatted \" + number + \" line\" + (number > 1 ? \"s\" : \"\");\n      getNotificationInfo().setReformatCodeNotification(message);\n    }\n  }","id":74624,"modified_method":"private void prepareUserNotificationMessage(@NotNull Document document, @NotNull CharSequence before) {\n    LOG.assertTrue(getInfoCollector() != null);\n    int number = getProcessedLinesNumber(document, before);\n    if (number > 0) {\n      String message = \"formatted \" + number + \" line\" + (number > 1 ? \"s\" : \"\");\n      getInfoCollector().setReformatCodeNotification(message);\n    }\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  protected FutureTask<Boolean> prepareTask(@NotNull final PsiFile file, final boolean processChangedTextOnly)\n    throws IncorrectOperationException\n  {\n    return new FutureTask<Boolean>(new Callable<Boolean>() {\n      private Document myDocument;\n\n      @Override\n      public Boolean call() throws Exception {\n        FormattingProgressTask.FORMATTING_CANCELLED_FLAG.set(false);\n        try {\n          Collection<TextRange> ranges = getRangesToFormat(processChangedTextOnly, file);\n\n          CharSequence before = null;\n          if (isSingleFileProcessed()) {\n            myDocument = PsiDocumentManager.getInstance(myProject).getDocument(file);\n            LOG.assertTrue(myDocument != null);\n            before = myDocument.getImmutableCharSequence();\n          }\n\n          CodeStyleManager.getInstance(myProject).reformatText(file, ranges);\n\n          if (before != null) {\n            prepareUserNotificationMessage(myDocument, before);\n          }\n\n          return !FormattingProgressTask.FORMATTING_CANCELLED_FLAG.get();\n        }\n        catch (FilesTooBigForDiffException e) {\n          handleFileTooBigException(LOG, e, file);\n          return false;\n        } \n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n          return false;\n        }\n        finally {\n          myRanges.clear();\n        }\n      }\n    });\n  }","id":74625,"modified_method":"@Override\n  @NotNull\n  protected FutureTask<Boolean> prepareTask(@NotNull final PsiFile file, final boolean processChangedTextOnly)\n    throws IncorrectOperationException\n  {\n    return new FutureTask<Boolean>(new Callable<Boolean>() {\n      private Document myDocument;\n\n      @Override\n      public Boolean call() throws Exception {\n        FormattingProgressTask.FORMATTING_CANCELLED_FLAG.set(false);\n        try {\n          Collection<TextRange> ranges = getRangesToFormat(processChangedTextOnly, file);\n\n          CharSequence before = null;\n          if (getInfoCollector() != null) {\n            myDocument = PsiDocumentManager.getInstance(myProject).getDocument(file);\n            LOG.assertTrue(myDocument != null);\n            before = myDocument.getImmutableCharSequence();\n          }\n\n          CodeStyleManager.getInstance(myProject).reformatText(file, ranges);\n\n          if (before != null) {\n            prepareUserNotificationMessage(myDocument, before);\n          }\n\n          return !FormattingProgressTask.FORMATTING_CANCELLED_FLAG.get();\n        }\n        catch (FilesTooBigForDiffException e) {\n          handleFileTooBigException(LOG, e, file);\n          return false;\n        } \n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n          return false;\n        }\n        finally {\n          myRanges.clear();\n        }\n      }\n    });\n  }","commit_id":"275867f90a259a46ccc847fa14d6c17b12b070e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void retrieveAndStoreNotificationInfo(@NotNull Runnable runnable) {\n    if (runnable instanceof ImportOptimizer.CollectingInfoRunnable) {\n      String info = ((ImportOptimizer.CollectingInfoRunnable)runnable).getUserNotificationInfo();\n      if (info != null) {\n        myOptimizersMessages.add(info);\n      }\n    }\n  }","id":74626,"modified_method":"private void retrieveAndStoreNotificationInfo(@NotNull Runnable runnable) {\n    if (runnable instanceof ImportOptimizer.CollectingInfoRunnable) {\n      String optimizerMessage = ((ImportOptimizer.CollectingInfoRunnable)runnable).getUserNotificationInfo();\n      myOptimizerNotifications.add(optimizerMessage != null ? new NotificationInfo(optimizerMessage) : NOTHING_CHANGED_NOTIFICATION);\n    }\n    else if (runnable == EmptyRunnable.getInstance()) {\n      myOptimizerNotifications.add(NOTHING_CHANGED_NOTIFICATION);\n    }\n    else {\n      myOptimizerNotifications.add(SOMETHING_CHANGED_WITHOUT_MESSAGE_NOTIFICATION);\n    }\n  }","commit_id":"84750ba9d97be528cc822b00fd9f66a321ba9eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void putNotificationInfoIntoCollector() {\n    LayoutCodeInfoCollector collector = getInfoCollector();\n    if (collector == null) {\n      return;\n    }\n\n    String info = \"imports optimized\";\n    if (myOptimizersMessages.size() == 1) {\n      info = myOptimizersMessages.get(0);\n    }\n    collector.setOptimizeImportsNotification(info);\n  }","id":74627,"modified_method":"private void putNotificationInfoIntoCollector() {\n    LayoutCodeInfoCollector collector = getInfoCollector();\n    if (collector == null) {\n      return;\n    }\n\n    boolean atLeastOneOptimizerChangedSomething = false;\n    for (NotificationInfo info : myOptimizerNotifications) {\n      atLeastOneOptimizerChangedSomething |= info.isSomethingChanged();\n      if (info.getMessage() != null) {\n        collector.setOptimizeImportsNotification(info.getMessage());\n        return;\n      }\n    }\n\n    collector.setOptimizeImportsNotification(atLeastOneOptimizerChangedSomething ? \"imports optimized\" : null);\n  }","commit_id":"84750ba9d97be528cc822b00fd9f66a321ba9eb0","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitFile(DetailAST ast) {\n    SourceFile file = (SourceFile) peekSourceCode();\n    file.addNoSonarTagLines(getSource().getNoSonarTagLines());\n    file.setMeasure(Metric.HEADER_COMMENT_LINES, getSource().getMeasure(Metric.HEADER_COMMENT_LINES));\n    file.setMeasure(Metric.COMMENTED_OUT_CODE_LINES, getSource().getMeasure(Metric.COMMENTED_OUT_CODE_LINES));\n    file.setMeasure(Metric.COMMENT_LINES, getSource().getMeasure(Metric.COMMENT_LINES));\n    file.setMeasure(Metric.COMMENT_BLANK_LINES, getSource().getMeasure(Metric.COMMENT_BLANK_LINES));\n  }","id":74628,"modified_method":"@Override\n  public void visitFile(DetailAST ast) {\n    SourceFile file = (SourceFile) peekSourceCode();\n    file.addNoSonarTagLines(getSource().getNoSonarTagLines());\n    file.setMeasure(Metric.HEADER_COMMENT_LINES, getSource().getMeasure(Metric.HEADER_COMMENT_LINES));\n    int commentedOutCodeLines = getSource().getMeasure(Metric.COMMENTED_OUT_CODE_LINES);\n    int commentLines = getSource().getMeasure(Metric.COMMENT_LINES);\n    file.setMeasure(Metric.COMMENTED_OUT_CODE_LINES, commentedOutCodeLines);\n    file.setMeasure(Metric.COMMENT_LINES, commentLines + commentedOutCodeLines);\n    file.setMeasure(Metric.COMMENT_BLANK_LINES, getSource().getMeasure(Metric.COMMENT_BLANK_LINES));\n  }","commit_id":"ed06cc4b81f5f127688320259a7b1434a100aded","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n  public void visitToken(DetailAST ast) {\n    int startAtLine = peekSourceCode().getStartAtLine();\n    int endAtLine = peekSourceCode().getEndAtLine();\n    peekSourceCode().setMeasure(Metric.COMMENTED_OUT_CODE_LINES,\n        getSource().getMeasure(Metric.COMMENTED_OUT_CODE_LINES, startAtLine, endAtLine));\n    peekSourceCode().setMeasure(Metric.COMMENT_LINES, getSource().getMeasure(Metric.COMMENT_LINES, startAtLine, endAtLine));\n    peekSourceCode().setMeasure(Metric.COMMENT_BLANK_LINES, getSource().getMeasure(Metric.COMMENT_BLANK_LINES, startAtLine, endAtLine));\n  }","id":74629,"modified_method":"@Override\n  public void visitToken(DetailAST ast) {\n    int startAtLine = peekSourceCode().getStartAtLine();\n    int endAtLine = peekSourceCode().getEndAtLine();\n    int commentedOutCodeLines = getSource().getMeasure(Metric.COMMENTED_OUT_CODE_LINES, startAtLine, endAtLine);\n    int commentLines = getSource().getMeasure(Metric.COMMENT_LINES, startAtLine, endAtLine);\n    peekSourceCode().setMeasure(Metric.COMMENTED_OUT_CODE_LINES, commentedOutCodeLines);\n    peekSourceCode().setMeasure(Metric.COMMENT_LINES, commentLines + commentedOutCodeLines);\n    peekSourceCode().setMeasure(Metric.COMMENT_BLANK_LINES, getSource().getMeasure(Metric.COMMENT_BLANK_LINES, startAtLine, endAtLine));\n  }","commit_id":"ed06cc4b81f5f127688320259a7b1434a100aded","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testCommentedCode() {\n    SourceProject res = scan(\"/metrics/commentedCode/CommentedCode.java\");\n    assertEquals(4, res.getInt(Metric.COMMENT_LINES));\n    assertEquals(4, res.getInt(Metric.COMMENTED_OUT_CODE_LINES));\n    assertEquals(25, res.getInt(Metric.LINES));\n    assertEquals(7, res.getInt(Metric.LINES_OF_CODE));\n\n    SourceCode method = squid.search(\"CommentedCode#analyse()V\");\n    assertEquals(3, method.getInt(Metric.COMMENTED_OUT_CODE_LINES));\n    assertEquals(2, method.getInt(Metric.COMMENT_BLANK_LINES));\n  }","id":74630,"modified_method":"@Test\n  public void testCommentedCode() {\n    SourceProject res = scan(\"/metrics/commentedCode/CommentedCode.java\");\n    assertEquals(8, res.getInt(Metric.COMMENT_LINES));\n    assertEquals(4, res.getInt(Metric.COMMENTED_OUT_CODE_LINES));\n    assertEquals(25, res.getInt(Metric.LINES));\n    assertEquals(7, res.getInt(Metric.LINES_OF_CODE));\n\n    SourceCode method = squid.search(\"CommentedCode#analyse()V\");\n    assertEquals(3, method.getInt(Metric.COMMENTED_OUT_CODE_LINES));\n    assertEquals(2, method.getInt(Metric.COMMENT_BLANK_LINES));\n  }","commit_id":"ed06cc4b81f5f127688320259a7b1434a100aded","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void testDetection() {\n    CheckMessages checkMessages = new CheckMessages((SourceFile) squid.search(\"CommentedCode.java\"));\n\n    checkMessages.assertNext().atLine(26).withMessage(\"It's better to remove commented-out line of code.\");\n    checkMessages.assertNext().atLine(27);\n    checkMessages.assertNext().atLine(28);\n\n    checkMessages.assertNext().atLine(32);\n\n    checkMessages.assertNext().atLine(38);\n    checkMessages.assertNext().atLine(39);\n    checkMessages.assertNext().atLine(40);\n\n    checkMessages.assertNext().atLine(44);\n\n    checkMessages.assertNext().atLine(60);\n\n    checkMessages.assertNext().atLine(69);\n\n    checkMessages.assertNoMore();\n  }","id":74631,"modified_method":"@Test\n  public void testDetection() {\n    SourceFile sourceFile = (SourceFile) squid.search(\"CommentedCode.java\");\n    CheckMessages checkMessages = new CheckMessages(sourceFile);\n\n    checkMessages.assertNext().atLine(26).withMessage(\"It's better to remove commented-out line of code.\");\n    checkMessages.assertNext().atLine(27);\n    checkMessages.assertNext().atLine(28);\n\n    checkMessages.assertNext().atLine(32);\n\n    checkMessages.assertNext().atLine(38);\n    checkMessages.assertNext().atLine(39);\n    checkMessages.assertNext().atLine(40);\n\n    checkMessages.assertNext().atLine(44);\n\n    checkMessages.assertNext().atLine(60);\n\n    checkMessages.assertNext().atLine(69);\n\n    checkMessages.assertNoMore();\n\n    assertThat(sourceFile.getInt(Metric.COMMENT_LINES), is(40)); // TODO but in fact 46, so without fake-JSNI\n    assertThat(sourceFile.getInt(Metric.COMMENT_BLANK_LINES), is(16));\n  }","commit_id":"ed06cc4b81f5f127688320259a7b1434a100aded","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"private void copyStandard(SourceCode squidCode, Resource sonarResource) {\n    copy(squidCode, sonarResource, Metric.LINES_OF_CODE, CoreMetrics.NCLOC);\n    copy(squidCode, sonarResource, Metric.LINES, CoreMetrics.LINES);\n    copy(squidCode, sonarResource, Metric.COMMENT_LINES_WITHOUT_HEADER, CoreMetrics.COMMENT_LINES);\n    copy(squidCode, sonarResource, Metric.PUBLIC_API, CoreMetrics.PUBLIC_API);\n    copy(squidCode, sonarResource, Metric.COMPLEXITY, CoreMetrics.COMPLEXITY);\n    copy(squidCode, sonarResource, Metric.STATEMENTS, CoreMetrics.STATEMENTS);\n    copy(squidCode, sonarResource, Metric.COMMENTED_OUT_CODE_LINES, CoreMetrics.COMMENTED_OUT_CODE_LINES);\n  }","id":74632,"modified_method":"private void copyStandard(SourceCode squidCode, Resource sonarResource) {\n    copy(squidCode, sonarResource, Metric.LINES_OF_CODE, CoreMetrics.NCLOC);\n    copy(squidCode, sonarResource, Metric.LINES, CoreMetrics.LINES);\n    copy(squidCode, sonarResource, Metric.COMMENT_LINES_WITHOUT_HEADER, CoreMetrics.COMMENT_LINES);\n    copy(squidCode, sonarResource, Metric.PUBLIC_API, CoreMetrics.PUBLIC_API);\n    copy(squidCode, sonarResource, Metric.COMPLEXITY, CoreMetrics.COMPLEXITY);\n    copy(squidCode, sonarResource, Metric.STATEMENTS, CoreMetrics.STATEMENTS);\n  }","commit_id":"ed06cc4b81f5f127688320259a7b1434a100aded","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void getMeasuresOnProject() {\n    assertEquals(12, project.getInt(Metric.PACKAGES));\n    assertEquals(273, project.getInt(Metric.FILES));\n    assertEquals(37, project.getInt(Metric.ANONYMOUS_INNER_CLASSES));\n    assertEquals(412, project.getInt(Metric.CLASSES));\n    assertEquals(27, project.getInt(Metric.INTERFACES));\n    assertEquals(33, project.getInt(Metric.ABSTRACT_CLASSES));\n    assertEquals(3805, project.getInt(Metric.METHODS));\n    assertEquals(3805, squid.search(new QueryByType(SourceMethod.class), new QueryByMeasure(Metric.ACCESSORS, Operator.EQUALS, 0)).size());\n    assertEquals(69, project.getInt(Metric.ACCESSORS));\n    assertEquals(63852, project.getInt(Metric.LINES));\n    assertEquals(26323, project.getInt(Metric.LINES_OF_CODE));\n    assertEquals(6426, project.getInt(Metric.BLANK_LINES));\n    assertEquals(12268, project.getInt(Metric.STATEMENTS));\n    assertEquals(8475, project.getInt(Metric.COMPLEXITY));\n    assertEquals(4668, project.getInt(Metric.BRANCHES));\n    assertEquals(21114, project.getInt(Metric.COMMENT_LINES));\n    assertEquals(9995, project.getInt(Metric.COMMENT_BLANK_LINES));\n    assertEquals(17838, project.getInt(Metric.COMMENT_LINES_WITHOUT_HEADER));\n    assertEquals(0.40, project.getDouble(Metric.COMMENT_LINES_DENSITY), 0.01);\n\n  }","id":74633,"modified_method":"@Test\n  public void getMeasuresOnProject() {\n    assertEquals(12, project.getInt(Metric.PACKAGES));\n    assertEquals(273, project.getInt(Metric.FILES));\n    assertEquals(37, project.getInt(Metric.ANONYMOUS_INNER_CLASSES));\n    assertEquals(412, project.getInt(Metric.CLASSES));\n    assertEquals(27, project.getInt(Metric.INTERFACES));\n    assertEquals(33, project.getInt(Metric.ABSTRACT_CLASSES));\n    assertEquals(3805, project.getInt(Metric.METHODS));\n    assertEquals(3805, squid.search(new QueryByType(SourceMethod.class), new QueryByMeasure(Metric.ACCESSORS, Operator.EQUALS, 0)).size());\n    assertEquals(69, project.getInt(Metric.ACCESSORS));\n    assertEquals(63852, project.getInt(Metric.LINES));\n    assertEquals(26323, project.getInt(Metric.LINES_OF_CODE));\n    assertEquals(6426, project.getInt(Metric.BLANK_LINES));\n    assertEquals(12268, project.getInt(Metric.STATEMENTS));\n    assertEquals(8475, project.getInt(Metric.COMPLEXITY));\n    assertEquals(4668, project.getInt(Metric.BRANCHES));\n    assertEquals(21184, project.getInt(Metric.COMMENT_LINES));\n    assertEquals(9995, project.getInt(Metric.COMMENT_BLANK_LINES));\n    assertEquals(17908, project.getInt(Metric.COMMENT_LINES_WITHOUT_HEADER));\n    assertEquals(0.40, project.getDouble(Metric.COMMENT_LINES_DENSITY), 0.01);\n\n  }","commit_id":"ed06cc4b81f5f127688320259a7b1434a100aded","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static JVMElementFactory getFactory(Language language, Project project) {\n    final JVMElementFactoryProvider provider = INSTANCE.forLanguage(language);\n    return provider.getFactory(project);\n  }","id":74634,"modified_method":"@Nullable\n  public static JVMElementFactory getFactory(Language language, Project project) {\n    final JVMElementFactoryProvider provider = INSTANCE.forLanguage(language);\n    return provider != null? provider.getFactory(project) : null;\n  }","commit_id":"b9da3085718cb324a2d367b306279002d4c9eaba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Trinity<PsiElement, TextRange, Value> getSelectedExpression(final Project project, final Editor editor, final Point point, final ValueHintType type) {\n    final Ref<PsiElement> selectedExpression = Ref.create(null);\n    final Ref<TextRange> currentRange = Ref.create(null);\n    final Ref<Value> preCalculatedValue = Ref.create(null);\n\n    PsiDocumentManager.getInstance(project).commitAndRunReadAction(new Runnable() {\n      public void run() {\n        // Point -> offset\n        final int offset = calculateOffset(editor, point);\n\n\n        PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n\n        if(psiFile == null || !psiFile.isValid()) return;\n\n        int selectionStart = editor.getSelectionModel().getSelectionStart();\n        int selectionEnd   = editor.getSelectionModel().getSelectionEnd();\n\n        if((type == ValueHintType.MOUSE_CLICK_HINT || type == ValueHintType.MOUSE_ALT_OVER_HINT) && (selectionStart <= offset && offset <= selectionEnd)) {\n          PsiElement ctx = (selectionStart > 0) ? psiFile.findElementAt(selectionStart - 1) : psiFile.findElementAt(selectionStart);\n          try {\n            String text = editor.getSelectionModel().getSelectedText();\n            if(text != null && ctx != null) {\n              selectedExpression.set(JVMElementFactories.getFactory(ctx.getLanguage(), project).createExpressionFromText(text, ctx));\n              currentRange.set(new TextRange(editor.getSelectionModel().getSelectionStart(), editor.getSelectionModel().getSelectionEnd()));\n            }\n          }\n          catch (IncorrectOperationException ignored) { }\n        }\n\n        if(currentRange.get() == null) {\n          PsiElement elementAtCursor = psiFile.findElementAt(offset);\n          if (elementAtCursor == null) {\n            return;\n          }\n          Pair<PsiElement, TextRange> pair = findExpression(elementAtCursor, type == ValueHintType.MOUSE_CLICK_HINT || type == ValueHintType.MOUSE_ALT_OVER_HINT);\n          if (pair == null) {\n            if (type == ValueHintType.MOUSE_OVER_HINT) {\n              final DebuggerSession debuggerSession = DebuggerManagerEx.getInstanceEx(project).getContext().getDebuggerSession();\n              if(debuggerSession != null && debuggerSession.isPaused()) {\n                final Pair<Method, Value> lastExecuted = debuggerSession.getProcess().getLastExecutedMethod();\n                if (lastExecuted != null) {\n                  final Method method = lastExecuted.getFirst();\n                  if (method != null) {\n                    final Pair<PsiElement, TextRange> expressionPair = findExpression(elementAtCursor, true);\n                    if (expressionPair != null && expressionPair.getFirst() instanceof PsiMethodCallExpression) {\n                      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expressionPair.getFirst();\n                      final PsiMethod psiMethod = methodCallExpression.resolveMethod();\n                      if (psiMethod != null) {\n                        final JVMName jvmSignature = JVMNameUtil.getJVMSignature(psiMethod);\n                        try {\n                          if (method.name().equals(psiMethod.getName()) && method.signature().equals(jvmSignature.getName(debuggerSession.getProcess()))) {\n                            pair = expressionPair;\n                            preCalculatedValue.set(lastExecuted.getSecond());\n                          }\n                        }\n                        catch (EvaluateException ignored) {\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (pair == null) {\n            return;\n          }\n          selectedExpression.set(pair.getFirst());\n          currentRange.set(pair.getSecond());\n        }\n      }\n    });\n    return Trinity.create(selectedExpression.get(), currentRange.get(), preCalculatedValue.get());\n  }","id":74635,"modified_method":"private static Trinity<PsiElement, TextRange, Value> getSelectedExpression(final Project project, final Editor editor, final Point point, final ValueHintType type) {\n    final Ref<PsiElement> selectedExpression = Ref.create(null);\n    final Ref<TextRange> currentRange = Ref.create(null);\n    final Ref<Value> preCalculatedValue = Ref.create(null);\n\n    PsiDocumentManager.getInstance(project).commitAndRunReadAction(new Runnable() {\n      public void run() {\n        // Point -> offset\n        final int offset = calculateOffset(editor, point);\n\n\n        PsiFile psiFile = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());\n\n        if(psiFile == null || !psiFile.isValid()) {\n          return;\n        }\n\n        int selectionStart = editor.getSelectionModel().getSelectionStart();\n        int selectionEnd   = editor.getSelectionModel().getSelectionEnd();\n\n        if((type == ValueHintType.MOUSE_CLICK_HINT || type == ValueHintType.MOUSE_ALT_OVER_HINT) && (selectionStart <= offset && offset <= selectionEnd)) {\n          PsiElement ctx = (selectionStart > 0) ? psiFile.findElementAt(selectionStart - 1) : psiFile.findElementAt(selectionStart);\n          try {\n            String text = editor.getSelectionModel().getSelectedText();\n            if(text != null && ctx != null) {\n              final JVMElementFactory factory = JVMElementFactories.getFactory(ctx.getLanguage(), project);\n              if (factory == null) {\n                return;\n              }\n              selectedExpression.set(factory.createExpressionFromText(text, ctx));\n              currentRange.set(new TextRange(editor.getSelectionModel().getSelectionStart(), editor.getSelectionModel().getSelectionEnd()));\n            }\n          }\n          catch (IncorrectOperationException ignored) {\n          }\n        }\n\n        if(currentRange.get() == null) {\n          PsiElement elementAtCursor = psiFile.findElementAt(offset);\n          if (elementAtCursor == null) {\n            return;\n          }\n          Pair<PsiElement, TextRange> pair = findExpression(elementAtCursor, type == ValueHintType.MOUSE_CLICK_HINT || type == ValueHintType.MOUSE_ALT_OVER_HINT);\n          if (pair == null) {\n            if (type == ValueHintType.MOUSE_OVER_HINT) {\n              final DebuggerSession debuggerSession = DebuggerManagerEx.getInstanceEx(project).getContext().getDebuggerSession();\n              if(debuggerSession != null && debuggerSession.isPaused()) {\n                final Pair<Method, Value> lastExecuted = debuggerSession.getProcess().getLastExecutedMethod();\n                if (lastExecuted != null) {\n                  final Method method = lastExecuted.getFirst();\n                  if (method != null) {\n                    final Pair<PsiElement, TextRange> expressionPair = findExpression(elementAtCursor, true);\n                    if (expressionPair != null && expressionPair.getFirst() instanceof PsiMethodCallExpression) {\n                      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expressionPair.getFirst();\n                      final PsiMethod psiMethod = methodCallExpression.resolveMethod();\n                      if (psiMethod != null) {\n                        final JVMName jvmSignature = JVMNameUtil.getJVMSignature(psiMethod);\n                        try {\n                          if (method.name().equals(psiMethod.getName()) && method.signature().equals(jvmSignature.getName(debuggerSession.getProcess()))) {\n                            pair = expressionPair;\n                            preCalculatedValue.set(lastExecuted.getSecond());\n                          }\n                        }\n                        catch (EvaluateException ignored) {\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n          if (pair == null) {\n            return;\n          }\n          selectedExpression.set(pair.getFirst());\n          currentRange.set(pair.getSecond());\n        }\n      }\n    });\n    return Trinity.create(selectedExpression.get(), currentRange.get(), preCalculatedValue.get());\n  }","commit_id":"b9da3085718cb324a2d367b306279002d4c9eaba","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void executeResult(StepProcessorContext stepProcessorContext, final String controllerContext, ASTWhen when,\n                               final Map pageIdToXFormsModel, final Map pageIdToPathInfo, final Map pageIdToParamsDocument,\n                               final ASTOutput[] paramedInstance, final Element resultElement,\n                               final ASTOutput actionData, final ASTOutput redirect, final ASTOutput xupdatedInstance,\n                               String instancePassing) {\n\n        // Instance to update: either current, or instance from other page\n        final String resultPageId = resultElement == null ? null : resultElement.attributeValue(\"page\");\n        Attribute instancePassingAttribute = resultElement == null ? null : resultElement.attribute(\"instance-passing\");\n        final String _instancePassing = instancePassingAttribute == null ? instancePassing : instancePassingAttribute.getValue();\n        final String otherXForms = (String) pageIdToXFormsModel.get(resultPageId);\n        final boolean useCurrentPageInstance = resultPageId == null || otherXForms == null;\n        final ASTOutput instanceToUpdate = useCurrentPageInstance ? paramedInstance[0]\n                : new ASTOutput(\"data\", \"other-page-instance\");\n        if (!useCurrentPageInstance) {\n            final ASTOutput otherPageXFormsModel = new ASTOutput(\"data\", \"other-page-model\");\n            when.addStatement(new StepProcessorCall(stepProcessorContext, controllerContext, otherXForms) {{\n                addInput(new ASTInput(\"data\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"instance\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"xforms-model\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"matcher\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"can-be-serializer\", FALSE_DOCUMENT));\n                addOutput(new ASTOutput(\"data\", otherPageXFormsModel));\n            }});\n            when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                addInput(new ASTInput(\"data\", new ASTHrefXPointer(new ASTHrefId(otherPageXFormsModel), EXTRACT_INSTANCE_XPATH)));\n                addOutput(new ASTOutput(\"data\", instanceToUpdate));\n            }});\n        }\n\n        // XUpdate the instance\n        final ASTOutput internalXUpdatedInstance = resultElement == null || resultElement.elements().isEmpty()\n                ? instanceToUpdate : new ASTOutput(\"data\", \"internal-xupdated-instance\");\n        if (resultElement != null && !resultElement.elements().isEmpty()) {\n\n            // Create XUpdate config\n\n            final NonLazyUserDataElement modificationsElement \n                = new NonLazyUserDataElement( \"modifications\", Constants.XUPDATE_NAMESPACE );\n            final Map namespacesOnResult = Dom4jUtils.getNamespaceContext(resultElement);\n            for (Iterator i = namespacesOnResult.keySet().iterator(); i.hasNext();) {\n                String prefix = (String) i.next();\n                if (prefix.length() > 0)\n                    modificationsElement.add(new Namespace(prefix, (String) namespacesOnResult.get(prefix)));\n            }\n            final Document xuCfg = new NonLazyUserDataDocument( modificationsElement );\n\n            for (Iterator l = resultElement.elements().iterator(); l.hasNext();) {\n                Element xupdateElement = (Element) l.next();\n                modificationsElement.add(xupdateElement.createCopy());\n            }\n\n            // Run XUpdate\n            when.addStatement(new ASTProcessorCall(XMLConstants.XUPDATE_PROCESSOR_QNAME) {{\n                addInput(new ASTInput(\"config\", xuCfg));\n                addInput(new ASTInput(\"data\", new ASTHrefId(instanceToUpdate)));\n                addInput(new ASTInput(\"instance\", new ASTHrefId(paramedInstance[0])));\n                if (actionData != null)\n                    addInput(new ASTInput(\"action\", new ASTHrefId(actionData)));\n                addOutput(new ASTOutput(\"data\", internalXUpdatedInstance));\n            }});\n        }\n\n        // Do redirect\n        if (resultPageId != null) {\n            final String forwardPathInfo = (String) pageIdToPathInfo.get(resultPageId);\n            if (forwardPathInfo == null)\n                throw new OXFException(\"Cannot find page with id '\" + resultPageId + \"'\");\n\n            final Document paramsDocument = (Document) pageIdToParamsDocument.get(resultPageId);\n            final boolean doServerSideRedirect = _instancePassing != null && _instancePassing.equals(INSTANCE_PASSING_FORWARD);\n            final boolean doRedirectExitPortal = _instancePassing != null && _instancePassing.equals(INSTANCE_PASSING_REDIRECT_PORTAL);\n\n            {\n                // Do redirect passing parameters from internalXUpdatedInstance without modifying URL\n                final ASTOutput parametersOutput = (otherXForms != null) ? new ASTOutput(null, \"parameters\") : null;\n                if (otherXForms != null) {\n                    // Pass parameters only if needed\n                    when.addStatement(new ASTProcessorCall(XMLConstants.INSTANCE_TO_PARAMETERS_PROCESSOR_QNAME) {{\n                        addInput(new ASTInput(\"instance\", new ASTHrefId(internalXUpdatedInstance)));\n                        addInput(new ASTInput(\"filter\", (paramsDocument != null) ? paramsDocument : Dom4jUtils.NULL_DOCUMENT));\n                        addOutput(new ASTOutput(\"data\", parametersOutput));\n                    }});\n                }\n                // Handle path info\n                final ASTOutput forwardPathInfoOutput = new ASTOutput(null, \"forward-path-info\");\n                when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", new NonLazyUserDataDocument\n                            (new NonLazyUserDataElement(\"path-info\") {{ setText(forwardPathInfo); }} )));\n                    addOutput(new ASTOutput(\"data\", forwardPathInfoOutput));\n                }});\n                // Handle server-side redirect and exit portal redirect\n                final ASTOutput isServerSideRedirectOutput = new ASTOutput(null, \"is-server-side-redirect\");\n                when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", new NonLazyUserDataDocument\n                            (new NonLazyUserDataElement(\"server-side\") {{ setText(Boolean.toString(doServerSideRedirect)); }} )));\n                    addOutput(new ASTOutput(\"data\", isServerSideRedirectOutput));\n                }});\n                final ASTOutput isRedirectExitPortal = new ASTOutput(null, \"is-redirect-exit-portal\");\n                when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", new NonLazyUserDataDocument\n                            (new NonLazyUserDataElement(\"exit-portal\") {{ setText(Boolean.toString(doRedirectExitPortal)); }} )));\n                    addOutput(new ASTOutput(\"data\", isRedirectExitPortal));\n                }});\n                // Serialize the instance into the request if we are doing a server-side redirect\n                if (doServerSideRedirect) {\n                    when.addStatement(new ASTProcessorCall(XMLConstants.SCOPE_SERIALIZER_PROCESSOR_QNAME) {{\n                        Document config = null;\n                        try {\n                            config = Dom4jUtils.parseText\n                                    (\"<config><key>\" + Instance.REQUEST_INSTANCE_DOCUMENT + \"<\/key><scope>request<\/scope><\/config>\");\n                        } catch (DocumentException e) {\n                            throw new OXFException(e);\n                        } catch ( final SAXException e ) {\n                            throw new OXFException( e );\n                        }\n                        addInput(new ASTInput(\"data\", new ASTHrefId(internalXUpdatedInstance)));\n                        addInput(new ASTInput(\"config\", config));\n                    }});\n                }\n                // Aggregate redirect-url config\n                final ASTHref redirectURLData;\n                if (paramsDocument != null) {\n                    // Params document - things are little more complicated, so we delegate\n                    final ASTOutput redirectDataOutput = new ASTOutput(null, \"redirect-data\");\n\n                    final ASTHrefAggregate redirectDataAggregate = new ASTHrefAggregate(\"redirect-url\", new ASTHrefId(forwardPathInfoOutput),\n                            new ASTHrefId(isServerSideRedirectOutput), new ASTHrefId(isRedirectExitPortal));\n                    redirectDataAggregate.getHrefs().add(new ASTHrefId(parametersOutput));\n\n                    when.addStatement(new ASTProcessorCall(XMLConstants.XSLT_PROCESSOR_QNAME) {{\n                        addInput(new ASTInput(\"config\", new ASTHrefURL(\"oxf:/oxf/private/page-flow/reverse-params.xsl\")));\n                        addInput(new ASTInput(\"data\", redirectDataAggregate));\n                        addInput(new ASTInput(\"instance\", new ASTHrefId(internalXUpdatedInstance)));\n                        addInput(new ASTInput(\"params\", paramsDocument));\n                        addOutput(new ASTOutput(\"data\", redirectDataOutput));\n                    }});\n                    redirectURLData = new ASTHrefId(redirectDataOutput);\n                } else {\n                    // No params document, we can simply aggregate with XPL\n                    final ASTHrefAggregate redirectDataAggregate = new ASTHrefAggregate(\"redirect-url\", new ASTHrefId(forwardPathInfoOutput),\n                            new ASTHrefId(isServerSideRedirectOutput), new ASTHrefId(isRedirectExitPortal));\n                    if (otherXForms != null) // Pass parameters only if needed\n                        redirectDataAggregate.getHrefs().add(new ASTHrefId(parametersOutput));\n                    redirectURLData = redirectDataAggregate;\n                }\n                // Execute the redirect\n                when.addStatement(new ASTProcessorCall(XMLConstants.REDIRECT_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", redirectURLData));// {{setDebug(\"redirect 2\");}}\n                }});\n            }\n        }\n\n        // Signal if we did a redirect\n        when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n            addInput(new ASTInput(\"data\", new NonLazyUserDataDocument(new NonLazyUserDataElement\n                    (\"is-redirect\") {{ setText(Boolean.toString(resultPageId != null)); }})));\n            addOutput(new ASTOutput(\"data\", redirect));\n        }});\n\n        // Export XUpdated instance from this branch\n        when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n            addInput(new ASTInput(\"data\", new ASTHrefId(internalXUpdatedInstance)));\n            addOutput(new ASTOutput(\"data\", xupdatedInstance));\n        }});\n    }","id":74636,"modified_method":"private void executeResult(StepProcessorContext stepProcessorContext, final String controllerContext, ASTWhen when,\n                               final Map pageIdToXFormsModel, final Map pageIdToPathInfo, final Map pageIdToParamsDocument,\n                               final ASTOutput[] paramedInstance, final Element resultElement,\n                               final ASTOutput actionData, final ASTOutput redirect, final ASTOutput xupdatedInstance,\n                               String instancePassing) {\n\n        // Instance to update: either current, or instance from other page\n        final String resultPageId = resultElement == null ? null : resultElement.attributeValue(\"page\");\n        Attribute instancePassingAttribute = resultElement == null ? null : resultElement.attribute(\"instance-passing\");\n        final String _instancePassing = instancePassingAttribute == null ? instancePassing : instancePassingAttribute.getValue();\n        final String otherXForms = (String) pageIdToXFormsModel.get(resultPageId);\n        final boolean useCurrentPageInstance = resultPageId == null || otherXForms == null;\n        final ASTOutput instanceToUpdate = useCurrentPageInstance ? paramedInstance[0]\n                : new ASTOutput(\"data\", \"other-page-instance\");\n        if (!useCurrentPageInstance) {\n            final ASTOutput otherPageXFormsModel = new ASTOutput(\"data\", \"other-page-model\");\n            when.addStatement(new StepProcessorCall(stepProcessorContext, controllerContext, otherXForms) {{\n                addInput(new ASTInput(\"data\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"instance\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"xforms-model\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"matcher\", Dom4jUtils.NULL_DOCUMENT));\n                addInput(new ASTInput(\"can-be-serializer\", FALSE_DOCUMENT));\n                addOutput(new ASTOutput(\"data\", otherPageXFormsModel));\n            }});\n            when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                addInput(new ASTInput(\"data\", new ASTHrefXPointer(new ASTHrefId(otherPageXFormsModel), EXTRACT_INSTANCE_XPATH)));\n                addOutput(new ASTOutput(\"data\", instanceToUpdate));\n            }});\n        }\n\n        // XUpdate the instance\n        final ASTOutput internalXUpdatedInstance = resultElement == null || resultElement.elements().isEmpty()\n                ? instanceToUpdate : new ASTOutput(\"data\", \"internal-xupdated-instance\");\n        if (resultElement != null && !resultElement.elements().isEmpty()) {\n\n            // Create XUpdate config\n\n            final NonLazyUserDataElement modificationsElement \n                = new NonLazyUserDataElement( \"modifications\", Constants.XUPDATE_NAMESPACE );\n            final Map namespacesOnResult = Dom4jUtils.getNamespaceContext(resultElement);\n            for (Iterator i = namespacesOnResult.keySet().iterator(); i.hasNext();) {\n                String prefix = (String) i.next();\n                if (prefix.length() > 0)\n                    modificationsElement.add(new Namespace(prefix, (String) namespacesOnResult.get(prefix)));\n            }\n            final Document xuCfg = new NonLazyUserDataDocument( modificationsElement );\n\n            for (Iterator l = resultElement.elements().iterator(); l.hasNext();) {\n                Element xupdateElement = (Element) l.next();\n                modificationsElement.add(xupdateElement.createCopy());\n            }\n\n            // Run XUpdate\n            when.addStatement(new ASTProcessorCall(XMLConstants.XUPDATE_PROCESSOR_QNAME) {{\n                addInput(new ASTInput(\"config\", xuCfg));\n                addInput(new ASTInput(\"data\", new ASTHrefId(instanceToUpdate)));\n                addInput(new ASTInput(\"instance\", new ASTHrefId(paramedInstance[0])));\n                if (actionData != null)\n                    addInput(new ASTInput(\"action\", new ASTHrefId(actionData)));\n                addOutput(new ASTOutput(\"data\", internalXUpdatedInstance));\n            }});\n        }\n\n        // Do redirect\n        if (resultPageId != null) {\n            final String forwardPathInfo = (String) pageIdToPathInfo.get(resultPageId);\n            if (forwardPathInfo == null)\n                throw new OXFException(\"Cannot find page with id '\" + resultPageId + \"'\");\n\n            final Document paramsDocument = (Document) pageIdToParamsDocument.get(resultPageId);\n            final boolean doServerSideRedirect = _instancePassing != null && _instancePassing.equals(INSTANCE_PASSING_FORWARD);\n            final boolean doRedirectExitPortal = _instancePassing != null && _instancePassing.equals(INSTANCE_PASSING_REDIRECT_PORTAL);\n\n            {\n                // Do redirect passing parameters from internalXUpdatedInstance without modifying URL\n                final ASTOutput parametersOutput = (otherXForms != null) ? new ASTOutput(null, \"parameters\") : null;\n                if (otherXForms != null) {\n                    // Pass parameters only if needed\n                    when.addStatement(new ASTProcessorCall(XMLConstants.INSTANCE_TO_PARAMETERS_PROCESSOR_QNAME) {{\n                        addInput(new ASTInput(\"instance\", new ASTHrefId(internalXUpdatedInstance)));\n                        addInput(new ASTInput(\"filter\", (paramsDocument != null) ? paramsDocument : Dom4jUtils.NULL_DOCUMENT));\n                        addOutput(new ASTOutput(\"data\", parametersOutput));\n                    }});\n                }\n                // Handle path info\n                final ASTOutput forwardPathInfoOutput = new ASTOutput(null, \"forward-path-info\");\n                when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", new NonLazyUserDataDocument\n                            (new NonLazyUserDataElement(\"path-info\") {{ setText(forwardPathInfo); }} )));\n                    addOutput(new ASTOutput(\"data\", forwardPathInfoOutput));\n                }});\n                // Handle server-side redirect and exit portal redirect\n                final ASTOutput isServerSideRedirectOutput = new ASTOutput(null, \"is-server-side-redirect\");\n                when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", new NonLazyUserDataDocument\n                            (new NonLazyUserDataElement(\"server-side\") {{ setText(Boolean.toString(doServerSideRedirect)); }} )));\n                    addOutput(new ASTOutput(\"data\", isServerSideRedirectOutput));\n                }});\n                final ASTOutput isRedirectExitPortal = new ASTOutput(null, \"is-redirect-exit-portal\");\n                when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", new NonLazyUserDataDocument\n                            (new NonLazyUserDataElement(\"exit-portal\") {{ setText(Boolean.toString(doRedirectExitPortal)); }} )));\n                    addOutput(new ASTOutput(\"data\", isRedirectExitPortal));\n                }});\n                // Serialize the instance into the request if we are doing a server-side redirect\n                if (doServerSideRedirect) {\n                    when.addStatement(new ASTProcessorCall(XMLConstants.SCOPE_SERIALIZER_PROCESSOR_QNAME) {{\n                        Document config = null;\n                        try {\n                            config = Dom4jUtils.parseText\n                                    (\"<config><key>\" + Instance.REQUEST_INSTANCE_DOCUMENT + \"<\/key><scope>request<\/scope><\/config>\");\n                        } catch (DocumentException e) {\n                            throw new OXFException(e);\n                        } catch ( final SAXException e ) {\n                            throw new OXFException( e );\n                        }\n                        addInput(new ASTInput(\"data\", new ASTHrefId(internalXUpdatedInstance)));\n                        addInput(new ASTInput(\"config\", config));\n                    }});\n                }\n                // Aggregate redirect-url config\n                final ASTHref redirectURLData;\n                if (paramsDocument != null) {\n                    // Params document - things are little more complicated, so we delegate\n                    final ASTOutput redirectDataOutput = new ASTOutput(null, \"redirect-data\");\n\n                    final ASTHrefAggregate redirectDataAggregate = new ASTHrefAggregate(\"redirect-url\", new ASTHrefId(forwardPathInfoOutput),\n                            new ASTHrefId(isServerSideRedirectOutput), new ASTHrefId(isRedirectExitPortal));\n                    redirectDataAggregate.getHrefs().add(new ASTHrefId(parametersOutput));\n\n                    when.addStatement(new ASTProcessorCall(XMLConstants.UNSAFE_XSLT_PROCESSOR_QNAME) {{\n                        addInput(new ASTInput(\"config\", new ASTHrefURL(\"oxf:/oxf/private/page-flow/reverse-params.xsl\")));\n                        addInput(new ASTInput(\"data\", redirectDataAggregate));\n                        addInput(new ASTInput(\"instance\", new ASTHrefId(internalXUpdatedInstance)));\n                        addInput(new ASTInput(\"params\", paramsDocument));\n                        addOutput(new ASTOutput(\"data\", redirectDataOutput));\n                    }});\n                    redirectURLData = new ASTHrefId(redirectDataOutput);\n                } else {\n                    // No params document, we can simply aggregate with XPL\n                    final ASTHrefAggregate redirectDataAggregate = new ASTHrefAggregate(\"redirect-url\", new ASTHrefId(forwardPathInfoOutput),\n                            new ASTHrefId(isServerSideRedirectOutput), new ASTHrefId(isRedirectExitPortal));\n                    if (otherXForms != null) // Pass parameters only if needed\n                        redirectDataAggregate.getHrefs().add(new ASTHrefId(parametersOutput));\n                    redirectURLData = redirectDataAggregate;\n                }\n                // Execute the redirect\n                when.addStatement(new ASTProcessorCall(XMLConstants.REDIRECT_PROCESSOR_QNAME) {{\n                    addInput(new ASTInput(\"data\", redirectURLData));// {{setDebug(\"redirect 2\");}}\n                }});\n            }\n        }\n\n        // Signal if we did a redirect\n        when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n            addInput(new ASTInput(\"data\", new NonLazyUserDataDocument(new NonLazyUserDataElement\n                    (\"is-redirect\") {{ setText(Boolean.toString(resultPageId != null)); }})));\n            addOutput(new ASTOutput(\"data\", redirect));\n        }});\n\n        // Export XUpdated instance from this branch\n        when.addStatement(new ASTProcessorCall(XMLConstants.IDENTITY_PROCESSOR_QNAME) {{\n            addInput(new ASTInput(\"data\", new ASTHrefId(internalXUpdatedInstance)));\n            addOutput(new ASTOutput(\"data\", xupdatedInstance));\n        }});\n    }","commit_id":"70ff3a269eb2b4b08341081652d8fe7e7a7b5210","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static TransformerHandler getTransformerHandler(Templates templates, String clazz, Map attributes) throws TransformerConfigurationException {\n        return getFactory(clazz, attributes).newTransformerHandler(templates);\n    }","id":74637,"modified_method":"public static TransformerHandler getTransformerHandler(Templates templates, String clazz, Map attributes) throws TransformerConfigurationException {\n        return ((attributes != null) ? getFactory(clazz, attributes) : getFactory(clazz)).newTransformerHandler(templates);\n    }","commit_id":"70ff3a269eb2b4b08341081652d8fe7e7a7b5210","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static SAXTransformerFactory getFactory(String clazz) {\n        try {\n            if (XALAN_BUILTIN_TRANSFORMER_TYPE.equals(clazz)) {\n                // Special case for Xalan\n                if (transformerFactories.get(XALAN_BUILTIN_TRANSFORMER_TYPE) == null) {\n\n                    // HACK\n                    //\n                    // When we create a Templates (object representing\n                    // the stylesheet) based on an JAXP Source, we call the\n                    // TransformerFactoryImpl.newTemplates(Source source) method\n                    // of Xalan.\n                    //\n                    // This method has a \"bug\": if the sytemId is not set on the\n                    // Source (and it's not in the case of a SAXSource since the\n                    // SAXSource is based on am XMLReader and the XMLReader will\n                    // set the Locator on which is based the systemId when the\n                    // parse() method is called), the\n                    // TransformerFactoryImpl.newTemplates(Source) method will\n                    // set the systemId on the StylesheetHandler to the\n                    // home directory.\n                    //\n                    // We prevent this to overriding the\n                    // StylesheetHandler.setSystemId below.\n\n                    SAXTransformerFactory factory = new orbeon.apache.xalan.processor.TransformerFactoryImpl() {\n                        public TemplatesHandler newTemplatesHandler()\n                                throws TransformerConfigurationException {\n                            return new StylesheetHandler(this) {\n                                public void setSystemId(String baseID) {\n                                    // Do nothing.\n                                }\n                            };\n                        }\n                    };\n                    factory.setAttribute(\"http://xml.apache.org/xalan/features/incremental\", Boolean.FALSE);\n                    transformerFactories.put(XALAN_BUILTIN_TRANSFORMER_TYPE, factory);\n                }\n                return (SAXTransformerFactory) transformerFactories.get(XALAN_BUILTIN_TRANSFORMER_TYPE);\n            } else {\n                // Any other factory\n//                if (transformerFactories.get(clazz) == null) {\n                    SAXTransformerFactory factory = (SAXTransformerFactory) Class.forName(clazz).newInstance();\n                    return factory;\n//                }\n//                return (SAXTransformerFactory) transformerFactories.get(clazz);\n            }\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","id":74638,"modified_method":"public static SAXTransformerFactory getFactory(String clazz) {\n        try {\n            if (XALAN_BUILTIN_TRANSFORMER_TYPE.equals(clazz)) {\n                // Special case for Xalan\n                if (transformerFactories.get(XALAN_BUILTIN_TRANSFORMER_TYPE) == null) {\n\n                    // HACK\n                    //\n                    // When we create a Templates (object representing\n                    // the stylesheet) based on an JAXP Source, we call the\n                    // TransformerFactoryImpl.newTemplates(Source source) method\n                    // of Xalan.\n                    //\n                    // This method has a \"bug\": if the sytemId is not set on the\n                    // Source (and it's not in the case of a SAXSource since the\n                    // SAXSource is based on am XMLReader and the XMLReader will\n                    // set the Locator on which is based the systemId when the\n                    // parse() method is called), the\n                    // TransformerFactoryImpl.newTemplates(Source) method will\n                    // set the systemId on the StylesheetHandler to the\n                    // home directory.\n                    //\n                    // We prevent this to overriding the\n                    // StylesheetHandler.setSystemId below.\n\n                    SAXTransformerFactory factory = new orbeon.apache.xalan.processor.TransformerFactoryImpl() {\n                        public TemplatesHandler newTemplatesHandler()\n                                throws TransformerConfigurationException {\n                            return new StylesheetHandler(this) {\n                                public void setSystemId(String baseID) {\n                                    // Do nothing.\n                                }\n                            };\n                        }\n                    };\n                    transformerFactories.put(XALAN_BUILTIN_TRANSFORMER_TYPE, factory);\n                }\n                return (SAXTransformerFactory) transformerFactories.get(XALAN_BUILTIN_TRANSFORMER_TYPE);\n            } else {\n                // Any other factory\n//                if (transformerFactories.get(clazz) == null) {\n                    SAXTransformerFactory factory = (SAXTransformerFactory) Class.forName(clazz).newInstance();\n                    return factory;\n//                }\n//                return (SAXTransformerFactory) transformerFactories.get(clazz);\n            }\n        } catch (Exception e) {\n            throw new OXFException(e);\n        }\n    }","commit_id":"70ff3a269eb2b4b08341081652d8fe7e7a7b5210","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public static Templates getTemplates(Source source, String clazz, Map attributes, ErrorListener errorListener, URIResolver uriResolver)\n            throws TransformerConfigurationException {\n        SAXTransformerFactory factory = getFactory(clazz, attributes);\n        factory.setErrorListener(errorListener);\n        factory.setURIResolver(uriResolver);\n        return factory.newTemplates(source);\n    }","id":74639,"modified_method":"public static Templates getTemplates(Source source, String clazz, Map attributes, ErrorListener errorListener, URIResolver uriResolver)\n            throws TransformerConfigurationException {\n        SAXTransformerFactory factory = (attributes != null) ? getFactory(clazz, attributes) : getFactory(clazz);\n        factory.setErrorListener(errorListener);\n        factory.setURIResolver(uriResolver);\n        return factory.newTemplates(source);\n    }","commit_id":"70ff3a269eb2b4b08341081652d8fe7e7a7b5210","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.CacheableTransformerOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext pipelineContext, ContentHandler contentHandler) {\n                Transformer transformer = null;\n                TransformerHandler transformerHandler = null;\n                try {\n                    // Get URI references from cache\n                    KeyValidity configKeyValidity = getInputKeyValidity(pipelineContext, INPUT_CONFIG);\n                    URIReferences uriReferences = getURIReferences(pipelineContext, configKeyValidity);\n\n                    // Get transformer from cache\n                    if (uriReferences != null) {\n                        // FIXME: this won't depend on the transformer input.\n                        KeyValidity stylesheetKeyValidity = createStyleSheetKeyValidity(pipelineContext, configKeyValidity, uriReferences);\n                        if (stylesheetKeyValidity != null)\n                            transformer = (Transformer) ObjectCache.instance()\n                                    .findValid(pipelineContext, stylesheetKeyValidity.key, stylesheetKeyValidity.validity);\n                    }\n\n                    // Get transformer attributes if any\n                    Map attributes = null;\n                    {\n                        // Read preferences input only if connected\n                        if (getConnectedInputs().get(INPUT_ATTRIBUTES) != null) {\n                            // Read input as an attribute Map and cache it\n                            attributes = (Map) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_ATTRIBUTES), new CacheableInputReader() {\n                                public Object read(PipelineContext context, ProcessorInput input) {\n                                    Document preferencesDocument = readInputAsDOM4J(context, input);\n                                    OXFPropertiesSerializer.PropertyStore propertyStore = OXFPropertiesSerializer.createPropertyStore(preferencesDocument);\n                                    OXFProperties.PropertySet propertySet = propertyStore.getGlobalPropertySet();\n                                    if (propertySet.size() > 0) {\n                                        Map result = new HashMap();\n                                        for (Iterator i = propertySet.keySet().iterator(); i.hasNext();) {\n                                            String key = (String) i.next();\n                                            result.put(key, propertySet.getObject(key));\n                                        }\n                                        return result;\n                                    } else {\n                                        return null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n\n                    // Create transformer if we did not find one in cache\n                    if (transformer == null) {\n                        // Get transformer configuration\n                        Node config = readCacheInputAsDOM4J(pipelineContext, INPUT_TRANSFORMER);\n                        String transformerClass = XPathUtils.selectStringValueNormalize(config, \"/config/class\");\n                        // Create transformer\n                        transformer = createTransformer(pipelineContext, transformerClass, attributes);\n                    }\n\n                    // Create transformer handler and set output writer for Saxon\n                    StringWriter saxonStringWriter = null;\n                    StringErrorListener errorListener = new StringErrorListener(logger);\n                    if (attributes == null)\n                        transformerHandler = TransformerUtils.getTransformerHandler(transformer.templates, transformer.transformerType);\n                    else\n                        transformerHandler = TransformerUtils.getTransformerHandler(transformer.templates, transformer.transformerType, attributes);\n\n                    transformerHandler.getTransformer().setURIResolver(new TransformerURIResolver(XSLTTransformer.this, pipelineContext));\n                    transformerHandler.getTransformer().setErrorListener(errorListener);\n                    String transformerClassName = transformerHandler.getTransformer().getClass().getName();\n                    if (transformerClassName.equals(\"net.sf.saxon.Controller\") || transformerClassName.equals(\"org.orbeon.saxon.Controller\")) {\n                        saxonStringWriter = new StringWriter();\n                        Object saxonTransformer = transformerHandler.getTransformer();\n                        Method getMessageEmitter = saxonTransformer.getClass().getMethod(\"getMessageEmitter\", new Class[] {});\n                        Object messageEmitter = getMessageEmitter.invoke(saxonTransformer, new Object[] {});\n                        if (messageEmitter == null) {\n                            Method makeMessageEmitter = saxonTransformer.getClass().getMethod(\"makeMessageEmitter\", new Class[] {});\n                            messageEmitter = makeMessageEmitter.invoke(saxonTransformer, new Object[] {});\n                        }\n                        Method setWriter = messageEmitter.getClass().getMethod(\"setWriter\", new Class[] {Writer.class});\n                        setWriter.invoke(messageEmitter, new Object[] {saxonStringWriter});\n                    }\n\n                    transformerHandler.setResult(new SAXResult(new SimpleForwardingContentHandler(contentHandler) {\n                        // Saxon happens to issue such prefix mappings from time to time. Those\n                        // cause issues later down the chain, and anyway serialize to incorrect XML\n                        // if xmlns:xmlns=\"...\" gets generated. This appears to happen when Saxon\n                        // uses the Copy() instruction. It may be that the source is then\n                        // incorrect, but we haven't traced this further. It may also simply be a\n                        // bug in Saxon.\n                        public void startPrefixMapping(String s, String s1) throws SAXException {\n                            if (\"xmlns\".equals(s)) {\n                                return;\n                            }\n                            super.startPrefixMapping(s, s1);\n                        }\n                    }));\n\n                    // Execute transformation\n                    try {\n                        if (XSLTTransformer.this.getConnectedInputs().size() > 3) {\n                            // When other inputs are connected, they can be read\n                            // with the doc() function in XSLT. Reading those\n                            // documents might happen before the whole input\n                            // document is read, which is not compatible with\n                            // our processing model. So in this case, we first\n                            // read the data in a SAX store.\n                            SAXStore dataSaxStore = new SAXStore();\n                            readInputAsSAX(pipelineContext, INPUT_DATA, dataSaxStore);\n                            dataSaxStore.replay(transformerHandler);\n                        } else {\n                            readInputAsSAX(pipelineContext, INPUT_DATA, transformerHandler);\n                        }\n                    } finally {\n                        // Log message from Saxon\n                        if (saxonStringWriter != null) {\n                            String message =  saxonStringWriter.toString();\n                            if (message.length() > 0)\n                                logger.info(message);\n                        }\n                    }\n                } catch (ValidationException e) {\n                    throw e;\n                } catch (Exception e) {\n                    if (transformer != null && transformer.systemId != null) {\n                        throw new ValidationException(e, new LocationData(transformer.systemId, 0, 0));\n                    } else {\n                        throw new OXFException(e);\n                    }\n                }\n            }\n\n            protected boolean supportsLocalKeyValidity() {\n                return true;\n            }\n\n            protected CacheKey getLocalKey(PipelineContext context) {\n                try {\n                    KeyValidity configKeyValidity = getInputKeyValidity(context, INPUT_CONFIG);\n                    URIReferences uriReferences = getURIReferences(context, configKeyValidity);\n                    if (uriReferences == null || uriReferences.hasDynamicDocumentReferences)\n                        return null;\n                    List keys = new ArrayList();\n                    keys.add(configKeyValidity.key);\n                    List allURIReferences = new ArrayList();\n                    allURIReferences.addAll(uriReferences.stylesheetReferences);\n                    allURIReferences.addAll(uriReferences.documentReferences);\n                    for (Iterator i = allURIReferences.iterator(); i.hasNext();) {\n                        URIReference uriReference = (URIReference) i.next();\n                        keys.add(new InternalCacheKey(XSLTTransformer.this, \"xsltURLReference\", URLFactory.createURL(uriReference.context, uriReference.spec).toExternalForm()));\n                    }\n                    return new InternalCacheKey(XSLTTransformer.this, keys);\n                } catch (MalformedURLException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            protected Object getLocalValidity(PipelineContext context) {\n                try {\n                    KeyValidity configKeyValidity = getInputKeyValidity(context, INPUT_CONFIG);\n                    URIReferences uriReferences = getURIReferences(context, configKeyValidity);\n                    if (uriReferences == null || uriReferences.hasDynamicDocumentReferences)\n                        return null;\n                    List validities = new ArrayList();\n                    validities.add(configKeyValidity.validity);\n                    List allURIReferences = new ArrayList();\n                    allURIReferences.addAll(uriReferences.stylesheetReferences);\n                    allURIReferences.addAll(uriReferences.documentReferences);\n                    for (Iterator i = allURIReferences.iterator(); i.hasNext();) {\n                        URIReference uriReference = (URIReference) i.next();\n                        Processor urlGenerator = new URLGenerator(URLFactory.createURL(uriReference.context, uriReference.spec));\n                        validities.add(((ProcessorOutputImpl)urlGenerator.createOutput(OUTPUT_DATA)).getValidity(context));\n                    }\n                    return validities;\n                } catch (IOException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            private URIReferences getURIReferences(PipelineContext context, KeyValidity configKeyValidity) {\n                if (configKeyValidity == null)\n                    return null;\n                return (URIReferences) ObjectCache.instance().findValid(context, configKeyValidity.key, configKeyValidity.validity);\n            }\n\n            private KeyValidity createStyleSheetKeyValidity(PipelineContext context, KeyValidity configKeyValidity, URIReferences uriReferences) {\n                try {\n                    if (configKeyValidity == null)\n                        return null;\n\n                    List keys = new ArrayList();\n                    List validities = new ArrayList();\n                    keys.add(configKeyValidity.key);\n                    validities.add(configKeyValidity.validity);\n                    for (Iterator i = uriReferences.stylesheetReferences.iterator(); i.hasNext();) {\n                        URIReference uriReference = (URIReference) i.next();\n                        URL url = URLFactory.createURL(uriReference.context, uriReference.spec);\n                        keys.add(new InternalCacheKey(XSLTTransformer.this, \"xsltURLReference\", url.toExternalForm()));\n                        Processor urlGenerator = new URLGenerator(url);\n                        validities.add(((ProcessorOutputImpl) urlGenerator.createOutput(OUTPUT_DATA)).getValidity(context));//FIXME: can we do better? See URL generator.\n                    }\n\n                    return new KeyValidity(new InternalCacheKey(XSLTTransformer.this, keys), validities);\n                } catch (MalformedURLException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            /**\n             * Reads the input and creates the JAXP Templates object (wrapped in a\n             * Transformer object). While reading the input, figures out the direct\n             * dependencies on other files (URIReferences object), and stores\n             * these two mappings in cache:\n             *\n             * <pre>\n             * configKey        -> uriReferences\n             * uriReferencesKey -> transformer\n             * <\/pre>\n             */\n            private Transformer createTransformer(PipelineContext context, String transformerClass, Map attributes) {\n                StringErrorListener errorListener = new StringErrorListener(logger);\n                final StylesheetForwardingContentHandler topStylesheetContentHandler = new StylesheetForwardingContentHandler();\n                try {\n                    // Create transformer\n                    final Transformer transformer = new Transformer();\n                    final List xsltContentHandlers = new ArrayList();\n                    {\n                        // Transformer type\n                        final String transformerType;\n                        {\n                            if (DEFAULT_TRANSFORMER_CLASS_STRING.equals(transformerClass)) {\n                                // Default is requested, try property\n                                String defaultTransformerType = getPropertySet().getString(TRANSFORMER_PROPERTY);\n                                // For backward compatibility, we accept the string \"interpreter\" in addition to class names\n                                if (defaultTransformerType == null || \"interpreter\".equals(defaultTransformerType))\n                                    transformerType = TransformerUtils.DEFAULT_TYPE;\n                                else\n                                    transformerType = defaultTransformerType;\n                            } else {\n                                // This must be a class name\n                                transformerType = transformerClass;\n                            }\n                        }\n\n                        // Create SAXSource adding our forwarding content handler\n                        final SAXSource stylesheetSAXSource;\n                        {\n                            xsltContentHandlers.add(topStylesheetContentHandler);\n                            XMLReader xmlReader = new ProcessorOutputXMLReader(context, getInputByName(INPUT_CONFIG).getOutput()) {\n                                public void setContentHandler(ContentHandler handler) {\n                                    super.setContentHandler(new TeeContentHandler(Arrays.asList(new Object[]{\n                                        topStylesheetContentHandler, handler})));\n                                }\n                            };\n                            stylesheetSAXSource = new SAXSource(xmlReader, new InputSource());\n                        }\n\n                        // Put listener in context that will be called by URI resolved\n                        context.setAttribute(PipelineContext.XSLT_STYLESHEET_URI_LISTENER, new URIResolverListener() {\n                            public ContentHandler getContentHandler() {\n                                StylesheetForwardingContentHandler contentHandler = new StylesheetForwardingContentHandler();\n                                xsltContentHandlers.add(contentHandler);\n                                return contentHandler;\n                            }\n                        });\n                        transformer.templates = TransformerUtils.getTemplates(stylesheetSAXSource, transformerType, attributes, errorListener,\n                                new TransformerURIResolver(XSLTTransformer.this, context));\n                        TransformerUtils.removeURIResolverListener();\n                        transformer.transformerType = transformerType;\n                        transformer.systemId = topStylesheetContentHandler.getSystemId();\n                    }\n\n                    // Update cache\n                    {\n                        // Create uriReferences\n                        URIReferences uriReferences = new URIReferences();\n                        for (Iterator i = xsltContentHandlers.iterator(); i.hasNext();) {\n                            StylesheetForwardingContentHandler contentHandler = (StylesheetForwardingContentHandler) i.next();\n                            uriReferences.hasDynamicDocumentReferences = uriReferences.hasDynamicDocumentReferences\n                                    || contentHandler.getURIReferences().hasDynamicDocumentReferences;\n                            uriReferences.stylesheetReferences.addAll\n                                    (contentHandler.getURIReferences().stylesheetReferences);\n                            uriReferences.documentReferences.addAll\n                                    (contentHandler.getURIReferences().documentReferences);\n                        }\n\n                        // Put in cache: configKey -> uriReferences\n                        KeyValidity configKeyValidty = getInputKeyValidity(context, INPUT_CONFIG);\n                        if (configKeyValidty != null)\n                            ObjectCache.instance().add(context, configKeyValidty.key, configKeyValidty.validity, uriReferences);\n\n                        // Put in cache: (configKey, uriReferences.stylesheetReferences) -> transformer\n                        KeyValidity stylesheetKeyValidity = createStyleSheetKeyValidity(context, configKeyValidty, uriReferences);\n                        if (stylesheetKeyValidity != null)\n                            ObjectCache.instance().add(context, stylesheetKeyValidity.key, stylesheetKeyValidity.validity, transformer);\n                    }\n\n                    return transformer;\n\n                } catch (Exception e) {\n                    if (topStylesheetContentHandler.getSystemId() != null) {\n                        if (errorListener.hasErrors()) {\n                            throw new ValidationException(errorListener.getMessages(),\n                                    new LocationData(topStylesheetContentHandler.getSystemId(), 0, 0));\n                        } else {\n                            throw new ValidationException(e,\n                                    new LocationData(topStylesheetContentHandler.getSystemId(), 0, 0));\n                        }\n                    } else {\n                        if (errorListener.hasErrors()) {\n                            throw new OXFException(errorListener.getMessages());\n                        } else {\n                            throw new OXFException(e);\n                        }\n                    }\n                }\n            }\n\n        };\n        addOutput(name, output);\n        return output;\n    }","id":74640,"modified_method":"public ProcessorOutput createOutput(String name) {\n        ProcessorOutput output = new ProcessorImpl.CacheableTransformerOutputImpl(getClass(), name) {\n            public void readImpl(PipelineContext pipelineContext, ContentHandler contentHandler) {\n                Transformer transformer = null;\n                TransformerHandler transformerHandler = null;\n                try {\n                    // Get URI references from cache\n                    KeyValidity configKeyValidity = getInputKeyValidity(pipelineContext, INPUT_CONFIG);\n                    URIReferences uriReferences = getURIReferences(pipelineContext, configKeyValidity);\n\n                    // Get transformer from cache\n                    if (uriReferences != null) {\n                        // FIXME: this won't depend on the transformer input.\n                        KeyValidity stylesheetKeyValidity = createStyleSheetKeyValidity(pipelineContext, configKeyValidity, uriReferences);\n                        if (stylesheetKeyValidity != null)\n                            transformer = (Transformer) ObjectCache.instance()\n                                    .findValid(pipelineContext, stylesheetKeyValidity.key, stylesheetKeyValidity.validity);\n                    }\n\n                    // Get transformer attributes if any\n                    Map attributes = null;\n                    {\n                        // Read preferences input only if connected\n                        if (getConnectedInputs().get(INPUT_ATTRIBUTES) != null) {\n                            // Read input as an attribute Map and cache it\n                            attributes = (Map) readCacheInputAsObject(pipelineContext, getInputByName(INPUT_ATTRIBUTES), new CacheableInputReader() {\n                                public Object read(PipelineContext context, ProcessorInput input) {\n                                    Document preferencesDocument = readInputAsDOM4J(context, input);\n                                    OXFPropertiesSerializer.PropertyStore propertyStore = OXFPropertiesSerializer.createPropertyStore(preferencesDocument);\n                                    OXFProperties.PropertySet propertySet = propertyStore.getGlobalPropertySet();\n                                    if (propertySet.size() > 0) {\n                                        Map result = new HashMap();\n                                        for (Iterator i = propertySet.keySet().iterator(); i.hasNext();) {\n                                            String key = (String) i.next();\n                                            result.put(key, propertySet.getObject(key));\n                                        }\n                                        return result;\n                                    } else {\n                                        return null;\n                                    }\n                                }\n                            });\n                        }\n                    }\n\n                    // Create transformer if we did not find one in cache\n                    if (transformer == null) {\n                        // Get transformer configuration\n                        Node config = readCacheInputAsDOM4J(pipelineContext, INPUT_TRANSFORMER);\n                        String transformerClass = XPathUtils.selectStringValueNormalize(config, \"/config/class\");\n                        // Create transformer\n                        transformer = createTransformer(pipelineContext, transformerClass, attributes);\n                    }\n\n                    // Create transformer handler and set output writer for Saxon\n                    StringWriter saxonStringWriter = null;\n                    StringErrorListener errorListener = new StringErrorListener(logger);\n                    transformerHandler = TransformerUtils.getTransformerHandler(transformer.templates, transformer.transformerType, attributes);\n\n                    transformerHandler.getTransformer().setURIResolver(new TransformerURIResolver(XSLTTransformer.this, pipelineContext));\n                    transformerHandler.getTransformer().setErrorListener(errorListener);\n                    String transformerClassName = transformerHandler.getTransformer().getClass().getName();\n                    if (transformerClassName.equals(\"net.sf.saxon.Controller\") || transformerClassName.equals(\"org.orbeon.saxon.Controller\")) {\n                        saxonStringWriter = new StringWriter();\n                        Object saxonTransformer = transformerHandler.getTransformer();\n                        Method getMessageEmitter = saxonTransformer.getClass().getMethod(\"getMessageEmitter\", new Class[] {});\n                        Object messageEmitter = getMessageEmitter.invoke(saxonTransformer, new Object[] {});\n                        if (messageEmitter == null) {\n                            Method makeMessageEmitter = saxonTransformer.getClass().getMethod(\"makeMessageEmitter\", new Class[] {});\n                            messageEmitter = makeMessageEmitter.invoke(saxonTransformer, new Object[] {});\n                        }\n                        Method setWriter = messageEmitter.getClass().getMethod(\"setWriter\", new Class[] {Writer.class});\n                        setWriter.invoke(messageEmitter, new Object[] {saxonStringWriter});\n                    }\n\n                    transformerHandler.setResult(new SAXResult(new SimpleForwardingContentHandler(contentHandler) {\n                        // Saxon happens to issue such prefix mappings from time to time. Those\n                        // cause issues later down the chain, and anyway serialize to incorrect XML\n                        // if xmlns:xmlns=\"...\" gets generated. This appears to happen when Saxon\n                        // uses the Copy() instruction. It may be that the source is then\n                        // incorrect, but we haven't traced this further. It may also simply be a\n                        // bug in Saxon.\n                        public void startPrefixMapping(String s, String s1) throws SAXException {\n                            if (\"xmlns\".equals(s)) {\n                                return;\n                            }\n                            super.startPrefixMapping(s, s1);\n                        }\n                    }));\n\n                    // Execute transformation\n                    try {\n                        if (XSLTTransformer.this.getConnectedInputs().size() > 3) {\n                            // When other inputs are connected, they can be read\n                            // with the doc() function in XSLT. Reading those\n                            // documents might happen before the whole input\n                            // document is read, which is not compatible with\n                            // our processing model. So in this case, we first\n                            // read the data in a SAX store.\n                            SAXStore dataSaxStore = new SAXStore();\n                            readInputAsSAX(pipelineContext, INPUT_DATA, dataSaxStore);\n                            dataSaxStore.replay(transformerHandler);\n                        } else {\n                            readInputAsSAX(pipelineContext, INPUT_DATA, transformerHandler);\n                        }\n                    } finally {\n                        // Log message from Saxon\n                        if (saxonStringWriter != null) {\n                            String message =  saxonStringWriter.toString();\n                            if (message.length() > 0)\n                                logger.info(message);\n                        }\n                    }\n                } catch (ValidationException e) {\n                    throw e;\n                } catch (Exception e) {\n                    if (transformer != null && transformer.systemId != null) {\n                        throw new ValidationException(e, new LocationData(transformer.systemId, 0, 0));\n                    } else {\n                        throw new OXFException(e);\n                    }\n                }\n            }\n\n            protected boolean supportsLocalKeyValidity() {\n                return true;\n            }\n\n            protected CacheKey getLocalKey(PipelineContext context) {\n                try {\n                    KeyValidity configKeyValidity = getInputKeyValidity(context, INPUT_CONFIG);\n                    URIReferences uriReferences = getURIReferences(context, configKeyValidity);\n                    if (uriReferences == null || uriReferences.hasDynamicDocumentReferences)\n                        return null;\n                    List keys = new ArrayList();\n                    keys.add(configKeyValidity.key);\n                    List allURIReferences = new ArrayList();\n                    allURIReferences.addAll(uriReferences.stylesheetReferences);\n                    allURIReferences.addAll(uriReferences.documentReferences);\n                    for (Iterator i = allURIReferences.iterator(); i.hasNext();) {\n                        URIReference uriReference = (URIReference) i.next();\n                        keys.add(new InternalCacheKey(XSLTTransformer.this, \"xsltURLReference\", URLFactory.createURL(uriReference.context, uriReference.spec).toExternalForm()));\n                    }\n                    return new InternalCacheKey(XSLTTransformer.this, keys);\n                } catch (MalformedURLException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            protected Object getLocalValidity(PipelineContext context) {\n                try {\n                    KeyValidity configKeyValidity = getInputKeyValidity(context, INPUT_CONFIG);\n                    URIReferences uriReferences = getURIReferences(context, configKeyValidity);\n                    if (uriReferences == null || uriReferences.hasDynamicDocumentReferences)\n                        return null;\n                    List validities = new ArrayList();\n                    validities.add(configKeyValidity.validity);\n                    List allURIReferences = new ArrayList();\n                    allURIReferences.addAll(uriReferences.stylesheetReferences);\n                    allURIReferences.addAll(uriReferences.documentReferences);\n                    for (Iterator i = allURIReferences.iterator(); i.hasNext();) {\n                        URIReference uriReference = (URIReference) i.next();\n                        Processor urlGenerator = new URLGenerator(URLFactory.createURL(uriReference.context, uriReference.spec));\n                        validities.add(((ProcessorOutputImpl)urlGenerator.createOutput(OUTPUT_DATA)).getValidity(context));\n                    }\n                    return validities;\n                } catch (IOException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            private URIReferences getURIReferences(PipelineContext context, KeyValidity configKeyValidity) {\n                if (configKeyValidity == null)\n                    return null;\n                return (URIReferences) ObjectCache.instance().findValid(context, configKeyValidity.key, configKeyValidity.validity);\n            }\n\n            private KeyValidity createStyleSheetKeyValidity(PipelineContext context, KeyValidity configKeyValidity, URIReferences uriReferences) {\n                try {\n                    if (configKeyValidity == null)\n                        return null;\n\n                    List keys = new ArrayList();\n                    List validities = new ArrayList();\n                    keys.add(configKeyValidity.key);\n                    validities.add(configKeyValidity.validity);\n                    for (Iterator i = uriReferences.stylesheetReferences.iterator(); i.hasNext();) {\n                        URIReference uriReference = (URIReference) i.next();\n                        URL url = URLFactory.createURL(uriReference.context, uriReference.spec);\n                        keys.add(new InternalCacheKey(XSLTTransformer.this, \"xsltURLReference\", url.toExternalForm()));\n                        Processor urlGenerator = new URLGenerator(url);\n                        validities.add(((ProcessorOutputImpl) urlGenerator.createOutput(OUTPUT_DATA)).getValidity(context));//FIXME: can we do better? See URL generator.\n                    }\n\n                    return new KeyValidity(new InternalCacheKey(XSLTTransformer.this, keys), validities);\n                } catch (MalformedURLException e) {\n                    throw new OXFException(e);\n                }\n            }\n\n            /**\n             * Reads the input and creates the JAXP Templates object (wrapped in a\n             * Transformer object). While reading the input, figures out the direct\n             * dependencies on other files (URIReferences object), and stores\n             * these two mappings in cache:\n             *\n             * <pre>\n             * configKey        -> uriReferences\n             * uriReferencesKey -> transformer\n             * <\/pre>\n             */\n            private Transformer createTransformer(PipelineContext context, String transformerClass, Map attributes) {\n                StringErrorListener errorListener = new StringErrorListener(logger);\n                final StylesheetForwardingContentHandler topStylesheetContentHandler = new StylesheetForwardingContentHandler();\n                try {\n                    // Create transformer\n                    final Transformer transformer = new Transformer();\n                    final List xsltContentHandlers = new ArrayList();\n                    {\n                        // Transformer type\n                        final String transformerType;\n                        {\n                            if (DEFAULT_TRANSFORMER_CLASS_STRING.equals(transformerClass)) {\n                                // Default is requested, try property\n                                String defaultTransformerType = getPropertySet().getString(TRANSFORMER_PROPERTY);\n                                // For backward compatibility, we accept the string \"interpreter\" in addition to class names\n                                if (defaultTransformerType == null || \"interpreter\".equals(defaultTransformerType))\n                                    transformerType = TransformerUtils.DEFAULT_TYPE;\n                                else\n                                    transformerType = defaultTransformerType;\n                            } else {\n                                // This must be a class name\n                                transformerType = transformerClass;\n                            }\n                        }\n\n                        // Create SAXSource adding our forwarding content handler\n                        final SAXSource stylesheetSAXSource;\n                        {\n                            xsltContentHandlers.add(topStylesheetContentHandler);\n                            XMLReader xmlReader = new ProcessorOutputXMLReader(context, getInputByName(INPUT_CONFIG).getOutput()) {\n                                public void setContentHandler(ContentHandler handler) {\n                                    super.setContentHandler(new TeeContentHandler(Arrays.asList(new Object[]{\n                                        topStylesheetContentHandler, handler})));\n                                }\n                            };\n                            stylesheetSAXSource = new SAXSource(xmlReader, new InputSource());\n                        }\n\n                        // Put listener in context that will be called by URI resolved\n                        context.setAttribute(PipelineContext.XSLT_STYLESHEET_URI_LISTENER, new URIResolverListener() {\n                            public ContentHandler getContentHandler() {\n                                StylesheetForwardingContentHandler contentHandler = new StylesheetForwardingContentHandler();\n                                xsltContentHandlers.add(contentHandler);\n                                return contentHandler;\n                            }\n                        });\n                        transformer.templates = TransformerUtils.getTemplates(stylesheetSAXSource, transformerType, attributes, errorListener,\n                                new TransformerURIResolver(XSLTTransformer.this, context));\n                        TransformerUtils.removeURIResolverListener();\n                        transformer.transformerType = transformerType;\n                        transformer.systemId = topStylesheetContentHandler.getSystemId();\n                    }\n\n                    // Update cache\n                    {\n                        // Create uriReferences\n                        URIReferences uriReferences = new URIReferences();\n                        for (Iterator i = xsltContentHandlers.iterator(); i.hasNext();) {\n                            StylesheetForwardingContentHandler contentHandler = (StylesheetForwardingContentHandler) i.next();\n                            uriReferences.hasDynamicDocumentReferences = uriReferences.hasDynamicDocumentReferences\n                                    || contentHandler.getURIReferences().hasDynamicDocumentReferences;\n                            uriReferences.stylesheetReferences.addAll\n                                    (contentHandler.getURIReferences().stylesheetReferences);\n                            uriReferences.documentReferences.addAll\n                                    (contentHandler.getURIReferences().documentReferences);\n                        }\n\n                        // Put in cache: configKey -> uriReferences\n                        KeyValidity configKeyValidty = getInputKeyValidity(context, INPUT_CONFIG);\n                        if (configKeyValidty != null)\n                            ObjectCache.instance().add(context, configKeyValidty.key, configKeyValidty.validity, uriReferences);\n\n                        // Put in cache: (configKey, uriReferences.stylesheetReferences) -> transformer\n                        KeyValidity stylesheetKeyValidity = createStyleSheetKeyValidity(context, configKeyValidty, uriReferences);\n                        if (stylesheetKeyValidity != null)\n                            ObjectCache.instance().add(context, stylesheetKeyValidity.key, stylesheetKeyValidity.validity, transformer);\n                    }\n\n                    return transformer;\n\n                } catch (Exception e) {\n                    if (topStylesheetContentHandler.getSystemId() != null) {\n                        if (errorListener.hasErrors()) {\n                            throw new ValidationException(errorListener.getMessages(),\n                                    new LocationData(topStylesheetContentHandler.getSystemId(), 0, 0));\n                        } else {\n                            throw new ValidationException(e,\n                                    new LocationData(topStylesheetContentHandler.getSystemId(), 0, 0));\n                        }\n                    } else {\n                        if (errorListener.hasErrors()) {\n                            throw new OXFException(errorListener.getMessages());\n                        } else {\n                            throw new OXFException(e);\n                        }\n                    }\n                }\n            }\n\n        };\n        addOutput(name, output);\n        return output;\n    }","commit_id":"70ff3a269eb2b4b08341081652d8fe7e7a7b5210","url":"https://github.com/orbeon/orbeon-forms"},{"original_method":"@Override\n    public Map<String, String> createNamedParameterMap() {\n        final Map<String, String> map = new HashMap<String, String>();\n\n        map.put(Constants.COMPONENT_NAME, emptyToNull(this.annotation.name()));\n        map.put(Constants.COMPONENT_LABEL, emptyToNull(this.annotation.label()));\n        map.put(Constants.COMPONENT_DESCRIPTION, emptyToNull(this.annotation.description()));\n        map.put(Constants.COMPONENT_ENABLED, String.valueOf(this.annotation.enabled()));\n        map.put(Constants.COMPONENT_FACTORY, emptyToNull(this.annotation.factory()));\n        // FELIX-593: immediate attribute does not default to true all the\n        // times hence we only set it if declared in the tag\n        if ( this.sourceAnnotation.getNamedParameter(\"immediate\") != null) {\n            map.put(Constants.COMPONENT_IMMEDIATE, this.sourceAnnotation.getNamedParameter(\"immediate\").toString());\n        }\n        map.put(Constants.COMPONENT_INHERIT, String.valueOf(this.annotation.inherit()));\n        map.put(Constants.COMPONENT_METATYPE, String.valueOf(this.annotation.metatype()));\n        map.put(Constants.COMPONENT_ABSTRACT, String.valueOf(this.annotation.componentAbstract()));\n        map.put(Constants.COMPONENT_DS, String.valueOf(this.annotation.ds()));\n        map.put(Constants.COMPONENT_CREATE_PID, String.valueOf(this.annotation.createPid()));\n\n        // version 1.1\n        if ( this.annotation.policy() != null ) {\n            map.put(Constants.COMPONENT_CONFIG_POLICY, this.annotation.policy().getPolicyString());\n        }\n        final JavaMethod[] jms = this.sourceAnnotation.getContext().getParent().getParentSource().getClasses()[0].getMethods();\n        for(final JavaMethod jm : jms) {\n            final Annotation[] annotations = jm.getAnnotations();\n            for(final Annotation a : annotations) {\n                if ( a.getType().getJavaClass().getFullyQualifiedName().equals(Activate.class.getName()) ) {\n                    map.put(Constants.COMPONENT_ACTIVATE, jm.getName());\n                }\n                if ( a.getType().getJavaClass().getFullyQualifiedName().equals(Deactivate.class.getName()) ) {\n                    map.put(Constants.COMPONENT_DEACTIVATE, jm.getName());\n                }\n                if ( a.getType().getJavaClass().getFullyQualifiedName().equals(Modified.class.getName()) ) {\n                    map.put(Constants.COMPONENT_MODIFIED, jm.getName());\n                }\n            }\n        }\n\n        return map;\n    }","id":74641,"modified_method":"@Override\n    public Map<String, String> createNamedParameterMap() {\n        final Map<String, String> map = new HashMap<String, String>();\n\n        map.put(Constants.COMPONENT_NAME, emptyToNull(this.annotation.name()));\n        map.put(Constants.COMPONENT_LABEL, emptyToNull(this.annotation.label()));\n        map.put(Constants.COMPONENT_DESCRIPTION, emptyToNull(this.annotation.description()));\n        map.put(Constants.COMPONENT_ENABLED, String.valueOf(this.annotation.enabled()));\n        map.put(Constants.COMPONENT_FACTORY, emptyToNull(this.annotation.factory()));\n        map.put(Constants.COMPONENT_SET_METATYPE_FACTORY_PID, String.valueOf(this.annotation.getMetatypeFactoryPid()));\n\n        // FELIX-593: immediate attribute does not default to true all the\n        // times hence we only set it if declared in the tag\n        if ( this.sourceAnnotation.getNamedParameter(\"immediate\") != null) {\n            map.put(Constants.COMPONENT_IMMEDIATE, this.sourceAnnotation.getNamedParameter(\"immediate\").toString());\n        }\n        map.put(Constants.COMPONENT_INHERIT, String.valueOf(this.annotation.inherit()));\n        map.put(Constants.COMPONENT_METATYPE, String.valueOf(this.annotation.metatype()));\n        map.put(Constants.COMPONENT_ABSTRACT, String.valueOf(this.annotation.componentAbstract()));\n        map.put(Constants.COMPONENT_DS, String.valueOf(this.annotation.ds()));\n        map.put(Constants.COMPONENT_CREATE_PID, String.valueOf(this.annotation.createPid()));\n\n        // version 1.1\n        if ( this.annotation.policy() != null ) {\n            map.put(Constants.COMPONENT_CONFIG_POLICY, this.annotation.policy().getPolicyString());\n        }\n        final JavaMethod[] jms = this.sourceAnnotation.getContext().getParent().getParentSource().getClasses()[0].getMethods();\n        for(final JavaMethod jm : jms) {\n            final Annotation[] annotations = jm.getAnnotations();\n            for(final Annotation a : annotations) {\n                if ( a.getType().getJavaClass().getFullyQualifiedName().equals(Activate.class.getName()) ) {\n                    map.put(Constants.COMPONENT_ACTIVATE, jm.getName());\n                }\n                if ( a.getType().getJavaClass().getFullyQualifiedName().equals(Deactivate.class.getName()) ) {\n                    map.put(Constants.COMPONENT_DEACTIVATE, jm.getName());\n                }\n                if ( a.getType().getJavaClass().getFullyQualifiedName().equals(Modified.class.getName()) ) {\n                    map.put(Constants.COMPONENT_MODIFIED, jm.getName());\n                }\n            }\n        }\n\n        return map;\n    }","commit_id":"c9d594575fd6960fbf68873cb69ee66d055fefe0","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * @param annotation Annotation\n     * @param desc Description\n     */\n    public ComponentTag(final Annotation annotation, final JavaClassDescription desc) {\n        super(desc, null);\n        this.sourceAnnotation = annotation;\n        this.annotation = new Component() {\n\n            public boolean componentAbstract() {\n                return Util.getBooleanValue(annotation, \"componentAbstract\", Component.class);\n            }\n\n            public boolean createPid() {\n                return Util.getBooleanValue(annotation, \"createPid\", Component.class);\n            }\n\n            public String description() {\n                return Util.getStringValue(annotation, desc, \"description\", Component.class);\n            }\n\n            public boolean ds() {\n                return Util.getBooleanValue(annotation, \"ds\", Component.class);\n            }\n\n            public boolean enabled() {\n                return Util.getBooleanValue(annotation, \"enabled\", Component.class);\n            }\n\n            public String factory() {\n                return Util.getStringValue(annotation, desc, \"factory\", Component.class);\n            }\n\n            public boolean immediate() {\n                return Util.getBooleanValue(annotation, \"immediate\", Component.class);\n            }\n\n            public boolean inherit() {\n                return Util.getBooleanValue(annotation, \"inherit\", Component.class);\n            }\n\n            public String label() {\n                return Util.getStringValue(annotation, desc, \"label\", Component.class);\n            }\n\n            public boolean metatype() {\n                return Util.getBooleanValue(annotation, \"metatype\", Component.class);\n            }\n\n            public String name() {\n                return Util.getStringValue(annotation, desc, \"name\", Component.class);\n            }\n\n            public ConfigurationPolicy policy() {\n                return Util.getEnumValue(annotation, \"policy\", ConfigurationPolicy.class, Component.class, false);\n            }\n\n            public Class<? extends java.lang.annotation.Annotation> annotationType() {\n                return null;\n            }\n        };\n    }","id":74642,"modified_method":"/**\n     * @param annotation Annotation\n     * @param desc Description\n     */\n    public ComponentTag(final Annotation annotation, final JavaClassDescription desc) {\n        super(desc, null);\n        this.sourceAnnotation = annotation;\n        this.annotation = new Component() {\n\n            public boolean componentAbstract() {\n                return Util.getBooleanValue(annotation, \"componentAbstract\", Component.class);\n            }\n\n            public boolean createPid() {\n                return Util.getBooleanValue(annotation, \"createPid\", Component.class);\n            }\n\n            public String description() {\n                return Util.getStringValue(annotation, desc, \"description\", Component.class);\n            }\n\n            public boolean ds() {\n                return Util.getBooleanValue(annotation, \"ds\", Component.class);\n            }\n\n            public boolean enabled() {\n                return Util.getBooleanValue(annotation, \"enabled\", Component.class);\n            }\n\n            public String factory() {\n                return Util.getStringValue(annotation, desc, \"factory\", Component.class);\n            }\n\n            public boolean immediate() {\n                return Util.getBooleanValue(annotation, \"immediate\", Component.class);\n            }\n\n            public boolean inherit() {\n                return Util.getBooleanValue(annotation, \"inherit\", Component.class);\n            }\n\n            public String label() {\n                return Util.getStringValue(annotation, desc, \"label\", Component.class);\n            }\n\n            public boolean metatype() {\n                return Util.getBooleanValue(annotation, \"metatype\", Component.class);\n            }\n\n            public String name() {\n                return Util.getStringValue(annotation, desc, \"name\", Component.class);\n            }\n\n            public ConfigurationPolicy policy() {\n                return Util.getEnumValue(annotation, \"policy\", ConfigurationPolicy.class, Component.class, false);\n            }\n\n            public boolean getMetatypeFactoryPid() {\n                return Util.getBooleanValue(annotation, \"getMetatypeFactoryPid\", Component.class);\n            }\n\n            public Class<? extends java.lang.annotation.Annotation> annotationType() {\n                return null;\n            }\n        };\n    }","commit_id":"c9d594575fd6960fbf68873cb69ee66d055fefe0","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Fill the component object with the information from the tag.\n     * @param tag\n     * @param component\n     */\n    protected OCD doComponent(JavaTag tag, Component component, MetaData metaData) {\n\n        // check if this is an abstract definition\n        final String abstractType = tag.getNamedParameter(Constants.COMPONENT_ABSTRACT);\n        if (abstractType != null) {\n            component.setAbstract(\"yes\".equalsIgnoreCase(abstractType) || \"true\".equalsIgnoreCase(abstractType));\n        } else {\n            // default true for abstract classes, false otherwise\n            component.setAbstract(tag.getJavaClassDescription().isAbstract());\n        }\n\n        // check if this is a definition to ignore\n        final String ds = tag.getNamedParameter(Constants.COMPONENT_DS);\n        component.setDs((ds == null) ? true : (\"yes\".equalsIgnoreCase(ds) || \"true\".equalsIgnoreCase(ds)));\n\n        String name = tag.getNamedParameter(Constants.COMPONENT_NAME);\n        component.setName(StringUtils.isEmpty(name) ? component.getImplementation().getClassame() : name);\n\n        component.setEnabled(Boolean.valueOf(getBoolean(tag, Constants.COMPONENT_ENABLED, true)));\n        component.setFactory(tag.getNamedParameter(Constants.COMPONENT_FACTORY));\n\n        // FELIX-593: immediate attribute does not default to true all the\n        // times hence we only set it if declared in the tag\n        if (tag.getNamedParameter(Constants.COMPONENT_IMMEDIATE) != null) {\n            component.setImmediate(Boolean.valueOf(getBoolean(tag,\n                Constants.COMPONENT_IMMEDIATE, true)));\n        }\n\n        // check for V1.1 attributes: configuration policy\n        if ( tag.getNamedParameter(Constants.COMPONENT_CONFIG_POLICY) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setConfigurationPolicy(tag.getNamedParameter(Constants.COMPONENT_CONFIG_POLICY));\n        }\n        // check for V1.1 attributes: activate, deactivate\n        if ( tag.getNamedParameter(Constants.COMPONENT_ACTIVATE) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setActivate(tag.getNamedParameter(Constants.COMPONENT_ACTIVATE));\n        }\n        if ( tag.getNamedParameter(Constants.COMPONENT_DEACTIVATE) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setDeactivate(tag.getNamedParameter(Constants.COMPONENT_DEACTIVATE));\n        }\n        if ( tag.getNamedParameter(Constants.COMPONENT_MODIFIED) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setModified(tag.getNamedParameter(Constants.COMPONENT_MODIFIED));\n        }\n\n        // whether metatype information is to generated for the component\n        final String metaType = tag.getNamedParameter(Constants.COMPONENT_METATYPE);\n        final boolean hasMetaType = metaType == null || \"yes\".equalsIgnoreCase(metaType)\n            || \"true\".equalsIgnoreCase(metaType);\n        if ( hasMetaType ) {\n            // ocd\n            final OCD ocd = new OCD();\n            metaData.addOCD(ocd);\n            ocd.setId(component.getName());\n            String ocdName = tag.getNamedParameter(Constants.COMPONENT_LABEL);\n            if ( ocdName == null ) {\n                ocdName = \"%\" + component.getName() + \".name\";\n            }\n            ocd.setName(ocdName);\n            String ocdDescription = tag.getNamedParameter(Constants.COMPONENT_DESCRIPTION);\n            if ( ocdDescription == null ) {\n                ocdDescription = \"%\" + component.getName() + \".description\";\n            }\n            ocd.setDescription(ocdDescription);\n            // designate\n            final Designate designate = new Designate();\n            metaData.addDesignate(designate);\n            designate.setPid(component.getName());\n            if (component.getFactory() != null) {\n                designate.setFactoryPid( component.getFactory() );\n            }\n            // designate.object\n            final MTObject mtobject = new MTObject();\n            designate.setObject(mtobject);\n            mtobject.setOcdref(component.getName());\n            return ocd;\n        }\n        return null;\n    }","id":74643,"modified_method":"/**\n     * Fill the component object with the information from the tag.\n     * @param tag\n     * @param component\n     */\n    protected OCD doComponent(JavaTag tag, Component component, MetaData metaData,\n            final IssueLog iLog) {\n\n        // check if this is an abstract definition\n        final String abstractType = tag.getNamedParameter(Constants.COMPONENT_ABSTRACT);\n        if (abstractType != null) {\n            component.setAbstract(\"yes\".equalsIgnoreCase(abstractType) || \"true\".equalsIgnoreCase(abstractType));\n        } else {\n            // default true for abstract classes, false otherwise\n            component.setAbstract(tag.getJavaClassDescription().isAbstract());\n        }\n\n        // check if this is a definition to ignore\n        final String ds = tag.getNamedParameter(Constants.COMPONENT_DS);\n        component.setDs((ds == null) ? true : (\"yes\".equalsIgnoreCase(ds) || \"true\".equalsIgnoreCase(ds)));\n\n        String name = tag.getNamedParameter(Constants.COMPONENT_NAME);\n        component.setName(StringUtils.isEmpty(name) ? component.getImplementation().getClassame() : name);\n\n        component.setEnabled(Boolean.valueOf(getBoolean(tag, Constants.COMPONENT_ENABLED, true)));\n        component.setFactory(tag.getNamedParameter(Constants.COMPONENT_FACTORY));\n\n        // FELIX-593: immediate attribute does not default to true all the\n        // times hence we only set it if declared in the tag\n        if (tag.getNamedParameter(Constants.COMPONENT_IMMEDIATE) != null) {\n            component.setImmediate(Boolean.valueOf(getBoolean(tag,\n                Constants.COMPONENT_IMMEDIATE, true)));\n        }\n\n        // check for V1.1 attributes: configuration policy\n        if ( tag.getNamedParameter(Constants.COMPONENT_CONFIG_POLICY) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setConfigurationPolicy(tag.getNamedParameter(Constants.COMPONENT_CONFIG_POLICY));\n        }\n        // check for V1.1 attributes: activate, deactivate\n        if ( tag.getNamedParameter(Constants.COMPONENT_ACTIVATE) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setActivate(tag.getNamedParameter(Constants.COMPONENT_ACTIVATE));\n        }\n        if ( tag.getNamedParameter(Constants.COMPONENT_DEACTIVATE) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setDeactivate(tag.getNamedParameter(Constants.COMPONENT_DEACTIVATE));\n        }\n        if ( tag.getNamedParameter(Constants.COMPONENT_MODIFIED) != null ) {\n            component.setSpecVersion(Constants.VERSION_1_1);\n            component.setModified(tag.getNamedParameter(Constants.COMPONENT_MODIFIED));\n        }\n\n        // whether metatype information is to generated for the component\n        final String metaType = tag.getNamedParameter(Constants.COMPONENT_METATYPE);\n        final boolean hasMetaType = metaType == null || \"yes\".equalsIgnoreCase(metaType)\n            || \"true\".equalsIgnoreCase(metaType);\n        if ( hasMetaType ) {\n            // ocd\n            final OCD ocd = new OCD();\n            metaData.addOCD(ocd);\n            ocd.setId(component.getName());\n            String ocdName = tag.getNamedParameter(Constants.COMPONENT_LABEL);\n            if ( ocdName == null ) {\n                ocdName = \"%\" + component.getName() + \".name\";\n            }\n            ocd.setName(ocdName);\n            String ocdDescription = tag.getNamedParameter(Constants.COMPONENT_DESCRIPTION);\n            if ( ocdDescription == null ) {\n                ocdDescription = \"%\" + component.getName() + \".description\";\n            }\n            ocd.setDescription(ocdDescription);\n            // designate\n            final Designate designate = new Designate();\n            metaData.addDesignate(designate);\n            designate.setPid(component.getName());\n\n            // factory pid\n            final String setFactoryPidValue = tag.getNamedParameter(Constants.COMPONENT_SET_METATYPE_FACTORY_PID);\n            final boolean setFactoryPid = setFactoryPidValue != null &&\n                (\"yes\".equalsIgnoreCase(setFactoryPidValue) || \"true\".equalsIgnoreCase(setFactoryPidValue));\n            if ( setFactoryPid ) {\n                if ( component.getFactory() == null ) {\n                    designate.setFactoryPid( component.getName() );\n                } else {\n                    iLog.addWarning(\"Component factory \" + component.getName() + \" should not set metatype factory pid.\");\n                }\n            }\n            // designate.object\n            final MTObject mtobject = new MTObject();\n            designate.setObject(mtobject);\n            mtobject.setOcdref(component.getName());\n            return ocd;\n        }\n        return null;\n    }","commit_id":"c9d594575fd6960fbf68873cb69ee66d055fefe0","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Create a component for the java class description.\n     * @param description\n     * @return The generated component descriptor or null if any error occurs.\n     * @throws MojoExecutionException\n     */\n    protected Component createComponent(JavaClassDescription description,\n                                        JavaTag componentTag,\n                                        MetaData metaData,\n                                        final IssueLog iLog)\n    throws MojoExecutionException {\n        // create a new component\n        final Component component = new Component(componentTag);\n\n        // set implementation\n        component.setImplementation(new Implementation(description.getName()));\n\n        final OCD ocd = this.doComponent(componentTag, component, metaData);\n\n        boolean inherited = getBoolean(componentTag, Constants.COMPONENT_INHERIT, true);\n        this.doServices(description.getTagsByName(Constants.SERVICE, inherited), component, description);\n\n        // collect references from class tags and fields\n        final Map<String, Object[]> references = new HashMap<String, Object[]>();\n        // Utility handler for propertie\n        final PropertyHandler propertyHandler = new PropertyHandler(component, ocd);\n\n        JavaClassDescription currentDescription = description;\n        do {\n            // properties\n            final JavaTag[] props = currentDescription.getTagsByName(Constants.PROPERTY, false);\n            for (int i=0; i < props.length; i++) {\n                propertyHandler.testProperty(props[i], null, description == currentDescription);\n            }\n\n            // references\n            final JavaTag[] refs = currentDescription.getTagsByName(Constants.REFERENCE, false);\n            for (int i=0; i < refs.length; i++) {\n                this.testReference(references, refs[i], null, description == currentDescription);\n            }\n\n            // fields\n            final JavaField[] fields = currentDescription.getFields();\n            for (int i=0; i < fields.length; i++) {\n                JavaTag tag = fields[i].getTagByName(Constants.REFERENCE);\n                if (tag != null) {\n                    this.testReference(references, tag, fields[i].getName(), description == currentDescription);\n                }\n\n                propertyHandler.handleField(fields[i], description == currentDescription);\n            }\n\n            currentDescription = currentDescription.getSuperClass();\n        } while (inherited && currentDescription != null);\n\n        // process properties\n        propertyHandler.processProperties(this.properties, iLog);\n\n        // process references\n        final Iterator<Map.Entry<String, Object[]>> refIter = references.entrySet().iterator();\n        while ( refIter.hasNext() ) {\n            final Map.Entry<String, Object[]> entry = refIter.next();\n            final String refName = entry.getKey();\n            final Object[] values = entry.getValue();\n            final JavaTag tag = (JavaTag)values[0];\n            this.doReference(tag, refName, component, values[1].toString());\n        }\n\n        // pid handling\n        final boolean createPid = getBoolean(componentTag, Constants.COMPONENT_CREATE_PID, true);\n        if ( createPid ) {\n            // check for an existing pid first\n            boolean found = false;\n            final Iterator<Property> iter = component.getProperties().iterator();\n            while ( !found && iter.hasNext() ) {\n                final Property prop = iter.next();\n                found = org.osgi.framework.Constants.SERVICE_PID.equals( prop.getName() );\n            }\n            if ( !found ) {\n                final Property pid = new Property();\n                component.addProperty(pid);\n                pid.setName(org.osgi.framework.Constants.SERVICE_PID);\n                pid.setValue(component.getName());\n            }\n        }\n        return component;\n    }","id":74644,"modified_method":"/**\n     * Create a component for the java class description.\n     * @param description\n     * @return The generated component descriptor or null if any error occurs.\n     * @throws MojoExecutionException\n     */\n    protected Component createComponent(JavaClassDescription description,\n                                        JavaTag componentTag,\n                                        MetaData metaData,\n                                        final IssueLog iLog)\n    throws MojoExecutionException {\n        // create a new component\n        final Component component = new Component(componentTag);\n\n        // set implementation\n        component.setImplementation(new Implementation(description.getName()));\n\n        final OCD ocd = this.doComponent(componentTag, component, metaData, iLog);\n\n        boolean inherited = getBoolean(componentTag, Constants.COMPONENT_INHERIT, true);\n        this.doServices(description.getTagsByName(Constants.SERVICE, inherited), component, description);\n\n        // collect references from class tags and fields\n        final Map<String, Object[]> references = new HashMap<String, Object[]>();\n        // Utility handler for propertie\n        final PropertyHandler propertyHandler = new PropertyHandler(component, ocd);\n\n        JavaClassDescription currentDescription = description;\n        do {\n            // properties\n            final JavaTag[] props = currentDescription.getTagsByName(Constants.PROPERTY, false);\n            for (int i=0; i < props.length; i++) {\n                propertyHandler.testProperty(props[i], null, description == currentDescription);\n            }\n\n            // references\n            final JavaTag[] refs = currentDescription.getTagsByName(Constants.REFERENCE, false);\n            for (int i=0; i < refs.length; i++) {\n                this.testReference(references, refs[i], null, description == currentDescription);\n            }\n\n            // fields\n            final JavaField[] fields = currentDescription.getFields();\n            for (int i=0; i < fields.length; i++) {\n                JavaTag tag = fields[i].getTagByName(Constants.REFERENCE);\n                if (tag != null) {\n                    this.testReference(references, tag, fields[i].getName(), description == currentDescription);\n                }\n\n                propertyHandler.handleField(fields[i], description == currentDescription);\n            }\n\n            currentDescription = currentDescription.getSuperClass();\n        } while (inherited && currentDescription != null);\n\n        // process properties\n        propertyHandler.processProperties(this.properties, iLog);\n\n        // process references\n        final Iterator<Map.Entry<String, Object[]>> refIter = references.entrySet().iterator();\n        while ( refIter.hasNext() ) {\n            final Map.Entry<String, Object[]> entry = refIter.next();\n            final String refName = entry.getKey();\n            final Object[] values = entry.getValue();\n            final JavaTag tag = (JavaTag)values[0];\n            this.doReference(tag, refName, component, values[1].toString());\n        }\n\n        // pid handling\n        final boolean createPid = getBoolean(componentTag, Constants.COMPONENT_CREATE_PID, true);\n        if ( createPid ) {\n            // check for an existing pid first\n            boolean found = false;\n            final Iterator<Property> iter = component.getProperties().iterator();\n            while ( !found && iter.hasNext() ) {\n                final Property prop = iter.next();\n                found = org.osgi.framework.Constants.SERVICE_PID.equals( prop.getName() );\n            }\n            if ( !found ) {\n                final Property pid = new Property();\n                component.addProperty(pid);\n                pid.setName(org.osgi.framework.Constants.SERVICE_PID);\n                pid.setValue(component.getName());\n            }\n        }\n        return component;\n    }","commit_id":"c9d594575fd6960fbf68873cb69ee66d055fefe0","url":"https://github.com/apache/felix"},{"original_method":"public synchronized ConfigurableEntityFactory<WebAppService> getFactory() {\n        if (cachedWebServerFactory!=null) return (ConfigurableEntityFactory<WebAppService>) cachedWebServerFactory;\n        cachedWebServerFactory = getConfig(FACTORY);\n        if (cachedWebServerFactory!=null) return (ConfigurableEntityFactory<WebAppService>) cachedWebServerFactory;\n        \n        log.debug(\"creating default web server factory for {}\", this);\n        cachedWebServerFactory = new JBoss7ServerFactory();\n        return (ConfigurableEntityFactory<WebAppService>) cachedWebServerFactory;\n    }","id":74645,"modified_method":"public synchronized ConfigurableEntityFactory<WebAppService> getFactory() {\n        ConfigurableEntityFactory<? extends WebAppService> result = getFactoryOrNull();\n        if (result != null) return (ConfigurableEntityFactory<WebAppService>) result;\n        \n        log.debug(\"creating default web server factory for {}\", this);\n        cachedWebServerFactory = new JBoss7ServerFactory();\n        return (ConfigurableEntityFactory<WebAppService>) cachedWebServerFactory;\n    }","commit_id":"759e7a8a807b537750c65d495ef50fc855660b24","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public synchronized DynamicWebAppCluster getCluster() {\n        if (cachedCluster!=null) return cachedCluster;\n        cachedCluster = (DynamicWebAppCluster) findChildOrNull(Predicates.instanceOf(DynamicWebAppCluster.class));\n        if (cachedCluster!=null) return cachedCluster;\n        \n        log.debug(\"creating cluster child for {}\", this);\n        // Note relies on initial_size being inherited by DynamicWebAppCluster, because key id is identical\n        cachedCluster = new DynamicWebAppClusterImpl(\n                MutableMap.builder()\n                        .put(\"factory\", getFactory())\n                        .build(),\n                this);\n        if (Entities.isManaged(this)) Entities.manage(cachedCluster);\n        return cachedCluster;\n    }","id":74646,"modified_method":"public synchronized DynamicWebAppCluster getCluster() {\n        if (cachedCluster!=null) return cachedCluster;\n        cachedCluster = (DynamicWebAppCluster) findChildOrNull(Predicates.instanceOf(DynamicWebAppCluster.class));\n        if (cachedCluster!=null) return cachedCluster;\n        \n        log.debug(\"creating cluster child for {}\", this);\n        // Note relies on initial_size being inherited by DynamicWebAppCluster, because key id is identical\n        Map<String,Object> flags;\n        if (getMemberSpecOrNull() != null) {\n            flags = MutableMap.<String,Object>of(\"memberSpec\", getMemberSpecOrNull());\n        } else {\n            flags = MutableMap.<String,Object>of(\"factory\", getFactory());\n        }\n        cachedCluster = new DynamicWebAppClusterImpl(flags, this);\n        if (Entities.isManaged(this)) Entities.manage(cachedCluster);\n        return cachedCluster;\n    }","commit_id":"759e7a8a807b537750c65d495ef50fc855660b24","url":"https://github.com/apache/incubator-brooklyn"},{"original_method":"public static final void initDefaultPath() {\n        // create default files array\n        defaultFiles = CommonPattern.COMMA.split(switchboard.getConfig(SwitchboardConstants.BROWSER_DEFAULT,\"index.html\"));\n        if (defaultFiles.length == 0) defaultFiles = new String[] {\"index.html\"};\n        indexForward = switchboard.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\n        if (indexForward.startsWith(\"/\")) indexForward = indexForward.substring(1);\n    }","id":74647,"modified_method":"public static final void initDefaultPath() {\n        // create default files array\n        defaultFiles = switchboard.getConfigArray(SwitchboardConstants.BROWSER_DEFAULT, \"index.html\");\n        if (defaultFiles.length == 0) defaultFiles = new String[] {\"index.html\"};\n        indexForward = switchboard.getConfig(SwitchboardConstants.INDEX_FORWARD, \"\");\n        if (indexForward.startsWith(\"/\")) indexForward = indexForward.substring(1);\n    }","commit_id":"efbc9a35611e9ab9abc059da3cf0f24aafe79fc7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"/**\r\n\t * Retrieve text data (e. g. config file) from file file may be an url or a\r\n\t * filename with path relative to rootPath parameter\r\n\t * \r\n\t * @param file\r\n\t *            url or filename\r\n\t * @param rootPath\r\n\t *            searchpath for file\r\n\t * @param file\r\n\t *            file to use when remote fetching fails (null if unused)\r\n\t */\r\n\tpublic Reader getConfigFileFromWebOrLocally(final String uri,\r\n\t\t\tfinal String rootPath, final File file) throws IOException,\r\n\t\t\tFileNotFoundException {\r\n\t\tif (uri.startsWith(\"http://\") || uri.startsWith(\"https://\")) {\r\n\t\t\tfinal String[] uris = uri.split(\",\");\r\n\t\t\tfor (String netdef : uris) {\r\n\t\t\t\tnetdef = netdef.trim();\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfinal RequestHeader reqHeader = new RequestHeader();\r\n\t\t\t\t\treqHeader\r\n\t\t\t\t\t\t\t.put(HeaderFramework.USER_AGENT,\r\n\t\t\t\t\t\t\t\t\tClientIdentification.yacyInternetCrawlerAgent.userAgent);\r\n\t\t\t\t\tfinal HTTPClient client = new HTTPClient(\r\n\t\t\t\t\t\t\tClientIdentification.yacyInternetCrawlerAgent);\r\n\t\t\t\t\tclient.setHeader(reqHeader.entrySet());\r\n\t\t\t\t\tbyte[] data = client\r\n\t\t\t\t\t\t\t.GETbytes(\r\n\t\t\t\t\t\t\t\t\turi,\r\n\t\t\t\t\t\t\t\t\tgetConfig(\r\n\t\t\t\t\t\t\t\t\t\t\tSwitchboardConstants.ADMIN_ACCOUNT_USER_NAME,\r\n\t\t\t\t\t\t\t\t\t\t\t\"admin\"),\r\n\t\t\t\t\t\t\t\t\tgetConfig(\r\n\t\t\t\t\t\t\t\t\t\t\tSwitchboardConstants.ADMIN_ACCOUNT_B64MD5,\r\n\t\t\t\t\t\t\t\t\t\t\t\"\"), false);\r\n\t\t\t\t\tif (data == null || data.length == 0) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// save locally in case next fetch fails\r\n\t\t\t\t\tif (file != null) {\r\n\t\t\t\t\t\tFileOutputStream f = new FileOutputStream(file);\r\n\t\t\t\t\t\tf.write(data);\r\n\t\t\t\t\t\tf.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn new InputStreamReader(new BufferedInputStream(\r\n\t\t\t\t\t\t\tnew ByteArrayInputStream(data)));\r\n\t\t\t\t} catch (final Exception e) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (file != null && file.exists()) {\r\n\t\t\t\treturn new FileReader(file);\r\n\t\t\t}\r\n\t\t\tthrow new FileNotFoundException();\r\n\t\t}\r\n\t\tfinal File f = (uri.length() > 0 && uri.startsWith(\"/\")) ? new File(uri)\r\n\t\t\t\t: new File(rootPath, uri);\r\n\t\tif (f.exists())\r\n\t\t\treturn new FileReader(f);\r\n\t\tthrow new FileNotFoundException(f.toString());\r\n\t}","id":74648,"modified_method":"/**\r\n\t * Retrieve text data (e. g. config file) from file file may be an url or a\r\n\t * filename with path relative to rootPath parameter\r\n\t * \r\n\t * @param file\r\n\t *            url or filename\r\n\t * @param rootPath\r\n\t *            searchpath for file\r\n\t * @param file\r\n\t *            file to use when remote fetching fails (null if unused)\r\n\t */\r\n\tpublic Reader getConfigFileFromWebOrLocally(final String uri,\r\n\t\t\tfinal String rootPath, final File file) throws IOException,\r\n\t\t\tFileNotFoundException {\r\n\t\tif (uri.startsWith(\"http://\") || uri.startsWith(\"https://\")) {\r\n\t\t\tfinal String[] uris = CommonPattern.COMMA.split(uri);\r\n\t\t\tfor (String netdef : uris) {\r\n\t\t\t\tnetdef = netdef.trim();\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfinal RequestHeader reqHeader = new RequestHeader();\r\n\t\t\t\t\treqHeader\r\n\t\t\t\t\t\t\t.put(HeaderFramework.USER_AGENT,\r\n\t\t\t\t\t\t\t\t\tClientIdentification.yacyInternetCrawlerAgent.userAgent);\r\n\t\t\t\t\tfinal HTTPClient client = new HTTPClient(\r\n\t\t\t\t\t\t\tClientIdentification.yacyInternetCrawlerAgent);\r\n\t\t\t\t\tclient.setHeader(reqHeader.entrySet());\r\n\t\t\t\t\tbyte[] data = client\r\n\t\t\t\t\t\t\t.GETbytes(\r\n\t\t\t\t\t\t\t\t\turi,\r\n\t\t\t\t\t\t\t\t\tgetConfig(\r\n\t\t\t\t\t\t\t\t\t\t\tSwitchboardConstants.ADMIN_ACCOUNT_USER_NAME,\r\n\t\t\t\t\t\t\t\t\t\t\t\"admin\"),\r\n\t\t\t\t\t\t\t\t\tgetConfig(\r\n\t\t\t\t\t\t\t\t\t\t\tSwitchboardConstants.ADMIN_ACCOUNT_B64MD5,\r\n\t\t\t\t\t\t\t\t\t\t\t\"\"), false);\r\n\t\t\t\t\tif (data == null || data.length == 0) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// save locally in case next fetch fails\r\n\t\t\t\t\tif (file != null) {\r\n\t\t\t\t\t\tFileOutputStream f = new FileOutputStream(file);\r\n\t\t\t\t\t\tf.write(data);\r\n\t\t\t\t\t\tf.close();\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn new InputStreamReader(new BufferedInputStream(\r\n\t\t\t\t\t\t\tnew ByteArrayInputStream(data)));\r\n\t\t\t\t} catch (final Exception e) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (file != null && file.exists()) {\r\n\t\t\t\treturn new FileReader(file);\r\n\t\t\t}\r\n\t\t\tthrow new FileNotFoundException();\r\n\t\t}\r\n\t\tfinal File f = (uri.length() > 0 && uri.startsWith(\"/\")) ? new File(uri)\r\n\t\t\t\t: new File(rootPath, uri);\r\n\t\tif (f.exists())\r\n\t\t\treturn new FileReader(f);\r\n\t\tthrow new FileNotFoundException(f.toString());\r\n\t}","commit_id":"efbc9a35611e9ab9abc059da3cf0f24aafe79fc7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"public static serverObjects respond(\n        final RequestHeader header,\n        final serverObjects post,\n        final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        final boolean authorized = sb.verifyAuthentication(header);\n        final boolean searchAllowed = sb.getConfigBool(SwitchboardConstants.PUBLIC_SEARCHPAGE, true) || authorized;\n\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        if ( !authenticated ) {\n            final UserDB.Entry user = sb.userDB.getUser(header);\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\n        }\n        final boolean localhostAccess = header.accessFromLocalhost();\n        final String promoteSearchPageGreeting =\n            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                \"network.unit.description\",\n                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\n        \n        // in case that the crawler is running and the search user is the peer admin, we expect that the user wants to check recently crawled document\n        // to ensure that recent crawl results are inside the search results, we do a soft commit here. This is also important for live demos!\n        if (authenticated && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 0) {\n            sb.index.fulltext().commit(true);\n        }\n        final boolean focus  = (post == null) ? true : post.get(\"focus\", \"1\").equals(\"1\");\n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\n        String querystring = originalquerystring.replace('+', ' ').trim();\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", sb.getConfig(\"search.verify\", \"\")));\n        \n        final servletProperties prop = new servletProperties();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n\n        // produce vocabulary navigation sidebars\n        Collection<Tagging> vocabularies = LibraryProvider.autotagging.getVocabularies();\n        int j = 0;\n        for (Tagging v: vocabularies) {\n            prop.put(\"sidebarVocabulary_\" + j + \"_vocabulary\", v.getName());\n            j++;\n        }\n        prop.put(\"sidebarVocabulary\", j);\n\n        // get segment\n        Segment indexSegment = sb.index;\n\n        final String EXT = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\");\n        final boolean rss = \"rss.atom\".contains(EXT);\n        final boolean json = EXT.equals(\"json\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        \n        // adding some additional properties needed for the rss feed\n        String hostName = header.get(\"Host\", Domains.LOCALHOST);\n        if ( hostName.indexOf(':', 0) == -1 ) {\n            hostName += \":\" + env.getLocalPort(\"port\", 8090);\n        }\n        prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\n        prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.png\");\n        prop.put(\"thisaddress\", hostName);\n        final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n        boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n        boolean global = post == null || (!post.get(\"resource-switch\", post.get(\"resource\", \"global\")).equals(\"local\") && p2pmode);\n        boolean stealthmode = p2pmode && !global;\n        \n        if ( post == null || indexSegment == null || env == null || !searchAllowed ) {\n            if (indexSegment == null) ConcurrentLog.info(\"yacysearch\", \"indexSegment == null\");\n            // we create empty entries for template strings\n            prop.put(\"searchagain\", \"0\");\n            prop.put(\"former\", \"\");\n            prop.put(\"count\", \"10\");\n            prop.put(\"offset\", \"0\");\n            prop.put(\"resource\", \"global\");\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\n            prop.put(\"indexof\", \"off\");\n            prop.put(\"constraint\", \"\");\n            prop.put(\"depth\", \"0\");\n            prop.put(\n                \"search.verify\",\n                (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\n            prop.put(\n                \"search.navigation\",\n                (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n            prop.put(\"contentdom\", \"text\");\n            prop.put(\"contentdomCheckText\", \"1\");\n            prop.put(\"contentdomCheckAudio\", \"0\");\n            prop.put(\"contentdomCheckVideo\", \"0\");\n            prop.put(\"contentdomCheckImage\", \"0\");\n            prop.put(\"contentdomCheckApp\", \"0\");\n            prop.put(\"excluded\", \"0\");\n            prop.put(\"results\", \"\");\n            prop.put(\"resultTable\", \"0\");\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\n            prop.put(\"num-results_totalcount\", 0);\n            prop.put(\"num-results_offset\", 0);\n            prop.put(\"num-results_itemsPerPage\", 10);\n            prop.put(\"geoinfo\", \"0\");\n            prop.put(\"rss_queryenc\", \"\");\n            prop.put(\"meanCount\", 5);\n            return prop;\n        }\n\n        // check for JSONP\n        if ( post.containsKey(\"callback\") ) {\n            final String jsonp = post.get(\"callback\") + \"([\";\n            prop.put(\"jsonp-start\", jsonp);\n            prop.put(\"jsonp-end\", \"])\");\n        } else {\n            prop.put(\"jsonp-start\", \"\");\n            prop.put(\"jsonp-end\", \"\");\n        }\n\n        // Adding CORS Access header for yacysearch.rss output\n        if ( rss ) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // collect search attributes\n\n        int itemsPerPage =\n            Math.min(\n                (authenticated)\n                    ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()\n                        ? 100\n                        : 5000) : (snippetFetchStrategy != null\n                        && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000),\n                post.getInt(\"maximumRecords\", post.getInt(\"count\", post.getInt(\"rows\", sb.getConfigInt(SwitchboardConstants.SEARCH_ITEMS, 10))))); // SRU syntax with old property as alternative\n        int startRecord = post.getInt(\"startRecord\", post.getInt(\"offset\", post.getInt(\"start\", 0)));\n\n        final boolean indexof = (post != null && post.get(\"indexof\", \"\").equals(\"on\"));\n\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\n        if ( !prefermask.isEmpty() && prefermask.indexOf(\".*\", 0) < 0 ) {\n            prefermask = \".*\" + prefermask + \".*\";\n        }\n\n        Bitfield constraint =\n            (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty())\n                ? new Bitfield(4, post.get(\"constraint\", \"______\"))\n                : null;\n        if ( indexof ) {\n            constraint = new Bitfield(4);\n            constraint.set(Condenser.flag_cat_indexof, true);\n        }\n\n        // SEARCH\n        final boolean intranetMode = sb.isIntranetMode() || sb.isAllIPMode();\n\n        // increase search statistic counter\n        if ( !global ) {\n            // we count only searches on the local peer here, because global searches\n            // are counted on the target peer to preserve privacy of the searcher\n            if ( authenticated ) {\n                // local or authenticated search requests are counted separately\n                // because they are not part of a public available peer statistic\n                sb.searchQueriesRobinsonFromLocal++;\n            } else {\n                // robinson-searches from non-authenticated requests are public\n                // and may be part of the public available statistic\n                sb.searchQueriesRobinsonFromRemote++;\n            }\n        }\n\n        // find search domain\n        final Classification.ContentDomain contentdom = post == null || !post.containsKey(\"contentdom\") ? ContentDomain.ALL : ContentDomain.contentdomParser(post.get(\"contentdom\", \"all\"));\n\n        // patch until better search profiles are available\n        if (contentdom == ContentDomain.IMAGE && (itemsPerPage == 10 || itemsPerPage == 100)) {\n            itemsPerPage = 64;\n        } else if ( contentdom != ContentDomain.IMAGE && itemsPerPage > 50 && itemsPerPage < 100 ) {\n            itemsPerPage = 10;\n        }\n\n        // check the search tracker\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\n        if ( trackerHandles == null ) {\n            trackerHandles = new TreeSet<Long>();\n        }\n        boolean block = false;\n        if ( Domains.matchesList(client, sb.networkWhitelist) ) {\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \"\n                + client\n                + \" gets no search restrictions\");\n        } else if ( Domains.matchesList(client, sb.networkBlacklist) ) {\n            global = false;\n            if ( snippetFetchStrategy != null ) {\n                snippetFetchStrategy = null;\n            }\n            block = true;\n            ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \"\n                + client\n                + \" gets no permission to search\");\n        } else if ( !authenticated && !localhostAccess && !intranetMode ) {\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\n            synchronized ( trackerHandles ) {\n                final int accInThreeSeconds =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\n                final int accInOneMinute =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\n                final int accInTenMinutes =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\n                // protections against too strong YaCy network load, reduces remote search\n                if ( global ) {\n                    if ( accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1 ) {\n                        global = false;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed global search\");\n                    }\n                }\n                // protection against too many remote server snippet loads (protects traffic on server)\n                if ( snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ) {\n                    if ( accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1 ) {\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed remote snippet loading\");\n                    }\n                }\n                // general load protection\n                if ( accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60 ) {\n                    block = true;\n                    ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                        + client\n                        + \": \"\n                        + accInThreeSeconds\n                        + \"/3s, \"\n                        + accInOneMinute\n                        + \"/60s, \"\n                        + accInTenMinutes\n                        + \"/600s, \"\n                        + \" requests, disallowed search\");\n                }\n            }\n        }\n\n        if ( !block ) {\n            String urlmask = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"); // the expression must be a subset of the java Match syntax described in http://lucene.apache.org/core/4_4_0/core/org/apache/lucene/util/automaton/RegExp.html\n            String tld = null;\n            String inlink = null;\n\n            // check available memory and clean up if necessary\n            if ( !MemoryControl.request(8000000L, false) ) {\n                indexSegment.clearCaches();\n                SearchEventCache.cleanupEvents(false);\n            }\n\n            final RankingProfile ranking = sb.getRanking();\n            final QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n            if (modifier.sitehost != null && modifier.sitehost.length() > 0 && querystring.length() == 0) querystring = \"*\"; // allow to search for all documents on a host\n\n            // read collection\n            modifier.collection = post.get(\"collection\", modifier.collection); // post arguments may overrule parsed collection values\n            \n            int stp = querystring.indexOf('*');\n            if (stp >= 0) {\n                // if the star appears as a single entry, use the catchallstring\n                if (querystring.length() == 1) {\n                    querystring = Segment.catchallString;\n                } else {\n                    querystring = querystring.replaceAll(\"\\\\* \", Segment.catchallString + \" \").replace(\" \\\\*\", \" \" + Segment.catchallString);\n                }\n            }\n            if ( querystring.indexOf(\"/near\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/near\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_worddistance = RankingProfile.COEFF_MAX;\n                modifier.add(\"/near\");\n            }\n            if ( querystring.indexOf(\"/date\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/date\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\n                modifier.add(\"/date\");\n            }\n\n            if ( querystring.indexOf(\"/location\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/location\", \"\");\n                if ( constraint == null ) {\n                    constraint = new Bitfield(4);\n                }\n                constraint.set(Condenser.flag_cat_haslocation, true);\n                modifier.add(\"/location\");\n            }\n\n            final int inurlp = querystring.indexOf(\"inurl:\", 0);\n            if ( inurlp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inurlp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                final String urlstr = querystring.substring(inurlp + 6, ftb);\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\n                if ( !urlstr.isEmpty() ) {\n                    urlmask = urlmask == null || urlmask.equals(\".*\") ? \".*\" + urlstr + \".*\" : urlmask; // we cannot join the conditions; if an urlmask is already given then stay with that\n                }\n                modifier.add(\"inurl:\" + urlstr);\n            }\n\n            final int inlinkp = querystring.indexOf(\"inlink:\", 0);\n            if ( inlinkp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inlinkp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                inlink = querystring.substring(inlinkp + 7, ftb);\n                querystring = querystring.replace(\"inlink:\" + inlink, \"\");\n                modifier.add(\"inlink:\" + inlink);\n            }\n\n            int voc = 0;\n            Collection<Tagging.Metatag> metatags = new ArrayList<Tagging.Metatag>(1);\n            while ((voc = querystring.indexOf(\"/vocabulary/\", 0)) >= 0) {\n                String vocabulary = \"\";\n                int ve = querystring.indexOf(' ', voc + 12);\n                if (ve < 0) {\n                    vocabulary = querystring.substring(voc);\n                    querystring = querystring.substring(0, voc).trim();\n                } else {\n                    vocabulary = querystring.substring(voc, ve);\n                    querystring = querystring.substring(0, voc) + querystring.substring(ve);\n                }\n                modifier.add(vocabulary);\n                vocabulary = vocabulary.substring(12);\n                int p = vocabulary.indexOf('/');\n                if (p > 0) {\n                    String k = vocabulary.substring(0, p);\n                    String v = vocabulary.substring(p + 1);\n                    metatags.add(LibraryProvider.autotagging.metatag(k, v));\n                }\n            }\n\n            int radius = 0;\n            double lon = 0.0d, lat = 0.0d, rad = 0.0d;\n            if ((radius = querystring.indexOf(\"/radius/\")) >= 0) {\n                int ve = querystring.indexOf(' ', radius + 8);\n                String geo = \"\";\n                if (ve < 0) {\n                    geo = querystring.substring(radius);\n                    querystring = querystring.substring(0, radius).trim();\n                } else {\n                    geo = querystring.substring(radius, ve);\n                    querystring = querystring.substring(0, radius) + querystring.substring(ve);\n                }\n                geo = geo.substring(8);\n                String[] sp = geo.split(\"/\");\n                if (sp.length == 3) try {\n                    lat = Double.parseDouble(sp[0]);\n                    lon = Double.parseDouble(sp[1]);\n                    rad = Double.parseDouble(sp[2]);\n                } catch (final NumberFormatException e) {\n                    lon = 0.0d; lat = 0.0d; rad = 0.0d;\n                }\n            }\n\n            final int heuristicBlekko = querystring.indexOf(\"/heuristic\", 0);\n            if ( heuristicBlekko >= 0 ) {\n                querystring = querystring.replace(\"/heuristic\", \"\");\n                modifier.add(\"/heuristic\");\n            }\n            \n            final int tldp = querystring.indexOf(\"tld:\", 0);\n            if (tldp >= 0) {\n                int ftb = querystring.indexOf(' ', tldp);\n                if (ftb == -1) ftb = querystring.length();\n                tld = querystring.substring(tldp + 4, ftb);\n                querystring = querystring.replace(\"tld:\" + tld, \"\");\n                modifier.add(\"tld:\" + tld);\n                while ( tld.length() > 0 && tld.charAt(0) == '.' ) {\n                    tld = tld.substring(1);\n                }\n                if (tld.length() == 0) tld = null;\n            }\n            if (urlmask == null || urlmask.isEmpty()) urlmask = \".*\"; //if no urlmask was given\n\n            // read the language from the language-restrict option 'lr'\n            // if no one is given, use the user agent or the system language as default\n            String language = (post == null) ? null : post.get(\"lr\");\n            if (language != null && language.startsWith(\"lang_\") ) {\n                language = language.substring(5);\n                if (modifier.language == null) modifier.language = language;\n            }\n            if (language == null || !ISO639.exists(language) ) {\n                // find out language of the user by reading of the user-agent string\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\n                if ( agent == null ) {\n                    agent = System.getProperty(\"user.language\");\n                }\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\n                if ( language == null ) {\n                    language = \"en\";\n                }\n            }\n\n            // the query\n            final QueryGoal qg = new QueryGoal(querystring.trim());\n            final int maxDistance = (querystring.indexOf('\"', 0) >= 0) ? qg.getIncludeHashes().size() - 1 : Integer.MAX_VALUE;\n\n            // filter out stopwords\n            final SortedSet<String> filtered = SetTools.joinConstructiveByTest(qg.getIncludeWords(), Switchboard.stopwords); //find matching stopwords\n            qg.removeIncludeWords(filtered);\n            \n            // if a minus-button was hit, remove a special reference first\n            if ( post != null && post.containsKey(\"deleteref\") ) {\n                try {\n                    if ( !sb.verifyAuthentication(header) ) {\n                    \tprop.authenticationRequired();\n                        return prop;\n                    }\n\n                    // delete the index entry locally\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\n                    if (indexSegment.termIndex() != null) indexSegment.termIndex().remove(qg.getIncludeHashes(), delHash.getBytes());\n\n                    // make new news message with negative voting\n                    if ( !sb.isRobinsonMode() ) {\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"urlhash\", delHash);\n                        map.put(\"vote\", \"negative\");\n                        map.put(\"refid\", \"\");\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_VOTE_ADD,\n                            map);\n                    }\n\n                    // delete the search history since this still shows the entry\n                    SearchEventCache.delete(delHash);\n                } catch (final IOException e ) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n\n            // if a plus-button was hit, create new voting message\n            if ( post != null && post.containsKey(\"recommendref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\n                final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(recommendHash));\n                if ( urlentry != null ) {\n                    Document[] documents = null;\n                    try {\n                        documents =\n                            sb.loader.loadDocuments(\n                                sb.loader.request(urlentry.url(), true, false),\n                                CacheStrategy.IFEXIST,\n                                Integer.MAX_VALUE, BlacklistType.SEARCH, ClientIdentification.yacyIntranetCrawlerAgent);\n                    } catch (final IOException e ) {\n                    } catch (final Parser.Failure e ) {\n                    }\n                    if ( documents != null ) {\n                        // create a news message\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"url\", urlentry.url().toNormalform(true).replace(',', '|'));\n                        map.put(\"title\", urlentry.dc_title().replace(',', ' '));\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\n                        map.put(\"author\", documents[0].dc_creator());\n                        map.put(\"tags\", documents[0].dc_subject(' '));\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_ADD,\n                            map);\n                        documents[0].close();\n                    }\n                }\n            }\n\n            // if a bookmarks-button was hit, create new bookmark entry\n            if ( post != null && post.containsKey(\"bookmarkref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                //final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\n                final String urlstr = crypt.simpleDecode(post.get(\"bookmarkurl\"));\n                if (urlstr != null) {\n                    try {\n                        final Bookmark bmk = sb.bookmarksDB.createBookmark(urlstr, YMarkTables.USER_ADMIN);\n                        bmk.setProperty(Bookmark.BOOKMARK_DESCRIPTION, \"query=\"+querystring);\n                        //bmk.setProperty(Bookmark.BOOKMARK_QUERY, originalquerystring);\n                        bmk.addTag(\"/search\"); // add to bookmark folder\n                        bmk.addTag(\"searchresult\"); // add tag\n                        String urlhash = post.get(\"bookmarkref\");\n                        final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(urlhash));\n                        if (urlentry != null && !urlentry.dc_title().isEmpty()) \n                            bmk.setProperty(Bookmark.BOOKMARK_TITLE,urlentry.dc_title());\n                        sb.bookmarksDB.saveBookmark(bmk);\n\n                        // do the same for YMarks ?\n                        sb.tables.bookmarks.createBookmark(\n                                sb.loader,\n                                urlstr,\n                                ClientIdentification.yacyInternetCrawlerAgent,\n                                YMarkTables.USER_ADMIN,\n                                true,\n                                \"searchresult\",\n                                \"/search\");\n                    } catch (final Throwable e) { }\n                }\n            }\n\n            // check filters\n            try {\n                Pattern.compile(urlmask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal URL mask, not a valid regex: \" + urlmask);\n                prop.put(\"urlmaskerror\", 1);\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\n                urlmask = \".*\";\n            }\n\n            try {\n                Pattern.compile(prefermask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal prefer mask, not a valid regex: \" + prefermask);\n                prop.put(\"prefermaskerror\", 1);\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\n                prefermask = \"\";\n            }\n\n            // do the search\n            final QueryParams theQuery =\n                new QueryParams(\n                    qg,\n                    modifier,\n                    maxDistance,\n                    prefermask,\n                    contentdom,\n                    language,\n                    metatags,\n                    snippetFetchStrategy,\n                    itemsPerPage,\n                    startRecord,\n                    urlmask, tld, inlink,\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER : (global && indexReceiveGranted ? QueryParams.Searchdom.GLOBAL : QueryParams.Searchdom.LOCAL),\n                    constraint,\n                    true,\n                    DigestURL.hosthashess(sb.getConfig(\"search.excludehosth\", \"\")),\n                    MultiProtocolURL.TLD_any_zone_filter,\n                    client,\n                    authenticated,\n                    indexSegment,\n                    ranking,\n                    header.get(HeaderFramework.USER_AGENT, \"\"),\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false)\n                        && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                        && sb.peers.mySeed().getFlagAcceptRemoteIndex(),\n                    false,\n                    lat, lon, rad,\n                    CommonPattern.COMMA.split(sb.getConfig(\"search.navigation\",\"\")));\n            EventTracker.delete(EventTracker.EClass.SEARCH);\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(\n                theQuery.id(true),\n                SearchEventType.INITIALIZATION,\n                \"\",\n                0,\n                0), false);\n\n            // tell all threads to do nothing for a specific time\n            sb.intermissionAllThreads(3000);\n\n            // filter out words that appear in bluelist\n            theQuery.getQueryGoal().filterOut(Switchboard.blueList);\n\n            // log\n            ConcurrentLog.info(\n                \"LOCAL_SEARCH\",\n                \"INIT WORD SEARCH: \"\n                    + theQuery.getQueryGoal().getQueryString(false)\n                    + \":\"\n                    + QueryParams.hashSet2hashString(theQuery.getQueryGoal().getIncludeHashes())\n                    + \" - \"\n                    + theQuery.neededResults()\n                    + \" links to be computed, \"\n                    + theQuery.itemsPerPage()\n                    + \" lines to be displayed\");\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(\n                new RSSMessage(\"Local Search Request\", theQuery.getQueryGoal().getQueryString(false), \"\"));\n            final long timestamp = System.currentTimeMillis();\n\n            // create a new search event\n            if ( SearchEventCache.getEvent(theQuery.id(false)) == null ) {\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\n                startRecord = 0;\n            }\n            final SearchEvent theSearch =\n                SearchEventCache.getEvent(\n                    theQuery,\n                    sb.peers,\n                    sb.tables,\n                    (sb.isRobinsonMode()) ? sb.clusterhashes : null,\n                    false,\n                    sb.loader,\n                    (int) sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\n                    sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXTIME_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)));\n\n            if ( startRecord == 0 ) {\n                if ( modifier.sitehost != null && sb.getConfigBool(SwitchboardConstants.HEURISTIC_SITE, false) && authenticated && !stealthmode) {\n                    sb.heuristicSite(theSearch, modifier.sitehost);\n                }\n                if ( heuristicBlekko >= 0  && authenticated && !stealthmode ) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n                if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, false) && authenticated && !stealthmode) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n            }\n\n            // log\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \"\n                + theQuery.getQueryGoal().getQueryString(false)\n                + \" - \"\n                + \"local_rwi_available(\" + theSearch.local_rwi_available.get() + \"), \"\n                + \"local_rwi_stored(\" + theSearch.local_rwi_stored.get() + \"), \"\n                + \"remote_rwi_available(\" + theSearch.remote_rwi_available.get() + \"), \"\n                + \"remote_rwi_stored(\" + theSearch.remote_rwi_stored.get() + \"), \"\n                + \"remote_rwi_peerCount(\" + theSearch.remote_rwi_peerCount.get() + \"), \"\n                + \"local_solr_available(\" + theSearch.local_solr_available.get() + \"), \"\n                + \"local_solr_stored(\" + theSearch.local_solr_stored.get() + \"), \"\n                + \"remote_solr_available(\" + theSearch.remote_solr_available.get() + \"), \"\n                + \"remote_solr_stored(\" + theSearch.remote_solr_stored.get() + \"), \"\n                + \"remote_solr_peerCount(\" + theSearch.remote_solr_peerCount.get() + \"), \"\n                + (System.currentTimeMillis() - timestamp)\n                + \" ms\");\n\n            // prepare search statistics\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\n            AccessTracker.add(AccessTracker.Location.local, theQuery, theSearch.getResultCount());\n\n            // check suggestions\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\n\n            prop.put(\"meanCount\", meanMax);\n            if ( meanMax > 0 && !json && !rss && sb.index.connectedRWI()) {\n                final DidYouMean didYouMean = new DidYouMean(indexSegment, new StringBuilder(querystring));\n                final Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\n                int meanCount = 0;\n                String suggestion;\n                try {\n                    meanCollect: while ( meanCount < meanMax && meanIt.hasNext() ) {\n                        try {\n                            suggestion = meanIt.next().toString();\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_word\", suggestion);\n                            prop.put(\n                                \"didYouMean_suggestions_\" + meanCount + \"_url\",\n                                QueryParams.navurl(\n                                    RequestHeader.FileType.HTML,\n                                    0,\n                                    theQuery,\n                                    suggestion, true).toString());\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_sep\", \"|\");\n                            meanCount++;\n                        } catch (final ConcurrentModificationException e) {\n                            ConcurrentLog.logException(e);\n                            break meanCollect;\n                        }\n                    }\n                } catch (final ConcurrentModificationException e) {\n                    ConcurrentLog.logException(e);\n                }\n                prop.put(\"didYouMean_suggestions_\" + (meanCount - 1) + \"_sep\", \"\");\n                prop.put(\"didYouMean\", meanCount > 0 ? 1 : 0);\n                prop.put(\"didYouMean_suggestions\", meanCount);\n            } else {\n                prop.put(\"didYouMean\", 0);\n            }\n\n            // find geographic info\n            final SortedSet<GeoLocation> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\n            if ( coordinates == null || coordinates.isEmpty() || startRecord > 0 ) {\n                prop.put(\"geoinfo\", \"0\");\n            } else {\n                int i = 0;\n                for ( final GeoLocation c : coordinates ) {\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\n                    i++;\n                    if ( i >= 10 ) {\n                        break;\n                    }\n                }\n                prop.put(\"geoinfo_loc\", i);\n                prop.put(\"geoinfo\", \"1\");\n            }\n\n            // update the search tracker\n            try {\n                synchronized ( trackerHandles ) {\n                    trackerHandles.add(theQuery.starttime);\n                    while ( trackerHandles.size() > 600 ) {\n                        if ( !trackerHandles.remove(trackerHandles.first()) ) {\n                            break;\n                        }\n                    }\n                }\n                sb.localSearchTracker.put(client, trackerHandles);\n                if ( sb.localSearchTracker.size() > 100 ) {\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\n                }\n                if ( MemoryControl.shortStatus() ) {\n                    sb.localSearchTracker.clear();\n                }\n            } catch (final Exception e ) {\n                ConcurrentLog.logException(e);\n            }\n\n            prop.put(\"num-results_offset\", startRecord);\n            prop.put(\"num-results_itemscount\", Formatter.number(startRecord + theSearch.query.itemsPerPage > theSearch.getResultCount() ? startRecord + theSearch.getResultCount() % theSearch.query.itemsPerPage : startRecord + theSearch.query.itemsPerPage, true));\n            prop.put(\"num-results_itemsPerPage\", Formatter.number(itemsPerPage));\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getResultCount())); // also in yacyserchtrailer (hint: timing in p2p search )\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n\n            // generate the search result lines; the content will be produced by another servlet\n            for ( int i = 0; i < theQuery.itemsPerPage(); i++ ) {\n                prop.put(\"results_\" + i + \"_item\", startRecord + i);\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\n            }\n            prop.put(\"results\", theQuery.itemsPerPage());\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\n\n            // process result of search\n            if ( !filtered.isEmpty() ) {\n                prop.put(\"excluded\", \"1\");\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\n            } else {\n                prop.put(\"excluded\", \"0\");\n            }\n\n            if (prop.isEmpty() || querystring.length() == 0) {\n                if ( querystring.length() == 0 ) { // querystring is trimmed originalquerystring\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\n                } else {\n                    prop.put(\"num-results\", \"1\"); // no results\n                }\n            } else {\n                prop.put(\"num-results\", \"3\");\n            }\n\n            prop.put(\"depth\", \"0\");\n\n        }\n        prop.put(\"focus\", focus ? 1 : 0); // focus search field\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\n        prop.putHTML(\"former\", originalquerystring.replaceAll(Segment.catchallString, \"*\"));\n        prop.put(\"count\", itemsPerPage);\n        prop.put(\"offset\", startRecord);\n        prop.put(\"resource\", global ? \"global\" : \"local\");\n        prop.putHTML(\"prefermaskfilter\", prefermask);\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n        prop.putHTML(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\n\n        // for RSS: don't HTML encode some elements\n        prop.putXML(\"rss_query\", originalquerystring);\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\n\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        // hostname and port (assume locahost if nothing helps)\n        final String hostIP = sb.peers.mySeed().getIP();\n        prop.put(\"myhost\", hostIP != null ? hostIP : Domains.LOCALHOST);\n        prop.put(\"myport\", Domains.LOCALHOST.equals(hostIP) ? sb.getLocalPort(\"port\", 8090) : sb.getPublicPort(\"port\", 8090));\n\n        // return rewrite properties\n        return prop;\n    }","id":74649,"modified_method":"public static serverObjects respond(\n        final RequestHeader header,\n        final serverObjects post,\n        final serverSwitch env) {\n        final Switchboard sb = (Switchboard) env;\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        final boolean authorized = sb.verifyAuthentication(header);\n        final boolean searchAllowed = sb.getConfigBool(SwitchboardConstants.PUBLIC_SEARCHPAGE, true) || authorized;\n\n        boolean authenticated = sb.adminAuthenticated(header) >= 2;\n        if ( !authenticated ) {\n            final UserDB.Entry user = sb.userDB.getUser(header);\n            authenticated = (user != null && user.hasRight(UserDB.AccessRight.EXTENDED_SEARCH_RIGHT));\n        }\n        final boolean localhostAccess = header.accessFromLocalhost();\n        final String promoteSearchPageGreeting =\n            (env.getConfigBool(SwitchboardConstants.GREETING_NETWORK_NAME, false)) ? env.getConfig(\n                \"network.unit.description\",\n                \"\") : env.getConfig(SwitchboardConstants.GREETING, \"\");\n        final String client = header.get(HeaderFramework.CONNECTION_PROP_CLIENTIP); // the search client who initiated the search\n        \n        // in case that the crawler is running and the search user is the peer admin, we expect that the user wants to check recently crawled document\n        // to ensure that recent crawl results are inside the search results, we do a soft commit here. This is also important for live demos!\n        if (authenticated && sb.getThread(SwitchboardConstants.CRAWLJOB_LOCAL_CRAWL).getJobCount() > 0) {\n            sb.index.fulltext().commit(true);\n        }\n        final boolean focus  = (post == null) ? true : post.get(\"focus\", \"1\").equals(\"1\");\n        // get query\n        final String originalquerystring = (post == null) ? \"\" : post.get(\"query\", post.get(\"search\", \"\")).trim();\n        String querystring = originalquerystring.replace('+', ' ').trim();\n        CacheStrategy snippetFetchStrategy = (post == null) ? null : CacheStrategy.parse(post.get(\"verify\", sb.getConfig(\"search.verify\", \"\")));\n        \n        final servletProperties prop = new servletProperties();\n        prop.put(\"topmenu\", sb.getConfigBool(\"publicTopmenu\", true) ? 1 : 0);\n\n        // produce vocabulary navigation sidebars\n        Collection<Tagging> vocabularies = LibraryProvider.autotagging.getVocabularies();\n        int j = 0;\n        for (Tagging v: vocabularies) {\n            prop.put(\"sidebarVocabulary_\" + j + \"_vocabulary\", v.getName());\n            j++;\n        }\n        prop.put(\"sidebarVocabulary\", j);\n\n        // get segment\n        Segment indexSegment = sb.index;\n\n        final String EXT = header.get(HeaderFramework.CONNECTION_PROP_EXT, \"\");\n        final boolean rss = \"rss.atom\".contains(EXT);\n        final boolean json = EXT.equals(\"json\");\n        prop.put(\"promoteSearchPageGreeting\", promoteSearchPageGreeting);\n        \n        // adding some additional properties needed for the rss feed\n        String hostName = header.get(\"Host\", Domains.LOCALHOST);\n        if ( hostName.indexOf(':', 0) == -1 ) {\n            hostName += \":\" + env.getLocalPort(\"port\", 8090);\n        }\n        prop.put(\"searchBaseURL\", \"http://\" + hostName + \"/yacysearch.html\");\n        prop.put(\"rssYacyImageURL\", \"http://\" + hostName + \"/env/grafics/yacy.png\");\n        prop.put(\"thisaddress\", hostName);\n        final boolean clustersearch = sb.isRobinsonMode() && sb.getConfig(SwitchboardConstants.CLUSTER_MODE, \"\").equals(SwitchboardConstants.CLUSTER_MODE_PUBLIC_CLUSTER);\n        final boolean indexReceiveGranted = sb.getConfigBool(SwitchboardConstants.INDEX_RECEIVE_ALLOW_SEARCH, true) || clustersearch;\n        boolean p2pmode = sb.peers != null && sb.peers.sizeConnected() > 0 && indexReceiveGranted;\n        boolean global = post == null || (!post.get(\"resource-switch\", post.get(\"resource\", \"global\")).equals(\"local\") && p2pmode);\n        boolean stealthmode = p2pmode && !global;\n        \n        if ( post == null || indexSegment == null || env == null || !searchAllowed ) {\n            if (indexSegment == null) ConcurrentLog.info(\"yacysearch\", \"indexSegment == null\");\n            // we create empty entries for template strings\n            prop.put(\"searchagain\", \"0\");\n            prop.put(\"former\", \"\");\n            prop.put(\"count\", \"10\");\n            prop.put(\"offset\", \"0\");\n            prop.put(\"resource\", \"global\");\n            prop.put(\"urlmaskfilter\", (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"));\n            prop.put(\"prefermaskfilter\", (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\"));\n            prop.put(\"indexof\", \"off\");\n            prop.put(\"constraint\", \"\");\n            prop.put(\"depth\", \"0\");\n            prop.put(\n                \"search.verify\",\n                (post == null) ? sb.getConfig(\"search.verify\", \"iffresh\") : post.get(\"verify\", \"iffresh\"));\n            prop.put(\n                \"search.navigation\",\n                (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n            prop.put(\"contentdom\", \"text\");\n            prop.put(\"contentdomCheckText\", \"1\");\n            prop.put(\"contentdomCheckAudio\", \"0\");\n            prop.put(\"contentdomCheckVideo\", \"0\");\n            prop.put(\"contentdomCheckImage\", \"0\");\n            prop.put(\"contentdomCheckApp\", \"0\");\n            prop.put(\"excluded\", \"0\");\n            prop.put(\"results\", \"\");\n            prop.put(\"resultTable\", \"0\");\n            prop.put(\"num-results\", searchAllowed ? \"0\" : \"4\");\n            prop.put(\"num-results_totalcount\", 0);\n            prop.put(\"num-results_offset\", 0);\n            prop.put(\"num-results_itemsPerPage\", 10);\n            prop.put(\"geoinfo\", \"0\");\n            prop.put(\"rss_queryenc\", \"\");\n            prop.put(\"meanCount\", 5);\n            return prop;\n        }\n\n        // check for JSONP\n        if ( post.containsKey(\"callback\") ) {\n            final String jsonp = post.get(\"callback\") + \"([\";\n            prop.put(\"jsonp-start\", jsonp);\n            prop.put(\"jsonp-end\", \"])\");\n        } else {\n            prop.put(\"jsonp-start\", \"\");\n            prop.put(\"jsonp-end\", \"\");\n        }\n\n        // Adding CORS Access header for yacysearch.rss output\n        if ( rss ) {\n            final ResponseHeader outgoingHeader = new ResponseHeader(200);\n            outgoingHeader.put(HeaderFramework.CORS_ALLOW_ORIGIN, \"*\");\n            prop.setOutgoingHeader(outgoingHeader);\n        }\n\n        // collect search attributes\n\n        int itemsPerPage =\n            Math.min(\n                (authenticated)\n                    ? (snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline()\n                        ? 100\n                        : 5000) : (snippetFetchStrategy != null\n                        && snippetFetchStrategy.isAllowedToFetchOnline() ? 20 : 1000),\n                post.getInt(\"maximumRecords\", post.getInt(\"count\", post.getInt(\"rows\", sb.getConfigInt(SwitchboardConstants.SEARCH_ITEMS, 10))))); // SRU syntax with old property as alternative\n        int startRecord = post.getInt(\"startRecord\", post.getInt(\"offset\", post.getInt(\"start\", 0)));\n\n        final boolean indexof = (post != null && post.get(\"indexof\", \"\").equals(\"on\"));\n\n        String prefermask = (post == null) ? \"\" : post.get(\"prefermaskfilter\", \"\");\n        if ( !prefermask.isEmpty() && prefermask.indexOf(\".*\", 0) < 0 ) {\n            prefermask = \".*\" + prefermask + \".*\";\n        }\n\n        Bitfield constraint =\n            (post != null && post.containsKey(\"constraint\") && !post.get(\"constraint\", \"\").isEmpty())\n                ? new Bitfield(4, post.get(\"constraint\", \"______\"))\n                : null;\n        if ( indexof ) {\n            constraint = new Bitfield(4);\n            constraint.set(Condenser.flag_cat_indexof, true);\n        }\n\n        // SEARCH\n        final boolean intranetMode = sb.isIntranetMode() || sb.isAllIPMode();\n\n        // increase search statistic counter\n        if ( !global ) {\n            // we count only searches on the local peer here, because global searches\n            // are counted on the target peer to preserve privacy of the searcher\n            if ( authenticated ) {\n                // local or authenticated search requests are counted separately\n                // because they are not part of a public available peer statistic\n                sb.searchQueriesRobinsonFromLocal++;\n            } else {\n                // robinson-searches from non-authenticated requests are public\n                // and may be part of the public available statistic\n                sb.searchQueriesRobinsonFromRemote++;\n            }\n        }\n\n        // find search domain\n        final Classification.ContentDomain contentdom = post == null || !post.containsKey(\"contentdom\") ? ContentDomain.ALL : ContentDomain.contentdomParser(post.get(\"contentdom\", \"all\"));\n\n        // patch until better search profiles are available\n        if (contentdom == ContentDomain.IMAGE && (itemsPerPage == 10 || itemsPerPage == 100)) {\n            itemsPerPage = 64;\n        } else if ( contentdom != ContentDomain.IMAGE && itemsPerPage > 50 && itemsPerPage < 100 ) {\n            itemsPerPage = 10;\n        }\n\n        // check the search tracker\n        TreeSet<Long> trackerHandles = sb.localSearchTracker.get(client);\n        if ( trackerHandles == null ) {\n            trackerHandles = new TreeSet<Long>();\n        }\n        boolean block = false;\n        if ( Domains.matchesList(client, sb.networkWhitelist) ) {\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"ACCESS CONTROL: WHITELISTED CLIENT FROM \"\n                + client\n                + \" gets no search restrictions\");\n        } else if ( Domains.matchesList(client, sb.networkBlacklist) ) {\n            global = false;\n            if ( snippetFetchStrategy != null ) {\n                snippetFetchStrategy = null;\n            }\n            block = true;\n            ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: BLACKLISTED CLIENT FROM \"\n                + client\n                + \" gets no permission to search\");\n        } else if ( !authenticated && !localhostAccess && !intranetMode ) {\n            // in case that we do a global search or we want to fetch snippets, we check for DoS cases\n            synchronized ( trackerHandles ) {\n                final int accInThreeSeconds =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 3000)).size();\n                final int accInOneMinute =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 60000)).size();\n                final int accInTenMinutes =\n                    trackerHandles.tailSet(Long.valueOf(System.currentTimeMillis() - 600000)).size();\n                // protections against too strong YaCy network load, reduces remote search\n                if ( global ) {\n                    if ( accInTenMinutes >= 60 || accInOneMinute >= 6 || accInThreeSeconds >= 1 ) {\n                        global = false;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed global search\");\n                    }\n                }\n                // protection against too many remote server snippet loads (protects traffic on server)\n                if ( snippetFetchStrategy != null && snippetFetchStrategy.isAllowedToFetchOnline() ) {\n                    if ( accInTenMinutes >= 20 || accInOneMinute >= 4 || accInThreeSeconds >= 1 ) {\n                        snippetFetchStrategy = CacheStrategy.CACHEONLY;\n                        ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                            + client\n                            + \": \"\n                            + accInThreeSeconds\n                            + \"/3s, \"\n                            + accInOneMinute\n                            + \"/60s, \"\n                            + accInTenMinutes\n                            + \"/600s, \"\n                            + \" requests, disallowed remote snippet loading\");\n                    }\n                }\n                // general load protection\n                if ( accInTenMinutes >= 3000 || accInOneMinute >= 600 || accInThreeSeconds >= 60 ) {\n                    block = true;\n                    ConcurrentLog.warn(\"LOCAL_SEARCH\", \"ACCESS CONTROL: CLIENT FROM \"\n                        + client\n                        + \": \"\n                        + accInThreeSeconds\n                        + \"/3s, \"\n                        + accInOneMinute\n                        + \"/60s, \"\n                        + accInTenMinutes\n                        + \"/600s, \"\n                        + \" requests, disallowed search\");\n                }\n            }\n        }\n\n        if ( !block ) {\n            String urlmask = (post == null) ? \".*\" : post.get(\"urlmaskfilter\", \".*\"); // the expression must be a subset of the java Match syntax described in http://lucene.apache.org/core/4_4_0/core/org/apache/lucene/util/automaton/RegExp.html\n            String tld = null;\n            String inlink = null;\n\n            // check available memory and clean up if necessary\n            if ( !MemoryControl.request(8000000L, false) ) {\n                indexSegment.clearCaches();\n                SearchEventCache.cleanupEvents(false);\n            }\n\n            final RankingProfile ranking = sb.getRanking();\n            final QueryModifier modifier = new QueryModifier();\n            querystring = modifier.parse(querystring);\n            if (modifier.sitehost != null && modifier.sitehost.length() > 0 && querystring.length() == 0) querystring = \"*\"; // allow to search for all documents on a host\n\n            // read collection\n            modifier.collection = post.get(\"collection\", modifier.collection); // post arguments may overrule parsed collection values\n            \n            int stp = querystring.indexOf('*');\n            if (stp >= 0) {\n                // if the star appears as a single entry, use the catchallstring\n                if (querystring.length() == 1) {\n                    querystring = Segment.catchallString;\n                } else {\n                    querystring = querystring.replaceAll(\"\\\\* \", Segment.catchallString + \" \").replace(\" \\\\*\", \" \" + Segment.catchallString);\n                }\n            }\n            if ( querystring.indexOf(\"/near\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/near\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_worddistance = RankingProfile.COEFF_MAX;\n                modifier.add(\"/near\");\n            }\n            if ( querystring.indexOf(\"/date\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/date\", \"\");\n                ranking.allZero(); // switch off all attributes\n                ranking.coeff_date = RankingProfile.COEFF_MAX;\n                modifier.add(\"/date\");\n            }\n\n            if ( querystring.indexOf(\"/location\", 0) >= 0 ) {\n                querystring = querystring.replace(\"/location\", \"\");\n                if ( constraint == null ) {\n                    constraint = new Bitfield(4);\n                }\n                constraint.set(Condenser.flag_cat_haslocation, true);\n                modifier.add(\"/location\");\n            }\n\n            final int inurlp = querystring.indexOf(\"inurl:\", 0);\n            if ( inurlp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inurlp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                final String urlstr = querystring.substring(inurlp + 6, ftb);\n                querystring = querystring.replace(\"inurl:\" + urlstr, \"\");\n                if ( !urlstr.isEmpty() ) {\n                    urlmask = urlmask == null || urlmask.equals(\".*\") ? \".*\" + urlstr + \".*\" : urlmask; // we cannot join the conditions; if an urlmask is already given then stay with that\n                }\n                modifier.add(\"inurl:\" + urlstr);\n            }\n\n            final int inlinkp = querystring.indexOf(\"inlink:\", 0);\n            if ( inlinkp >= 0 ) {\n                int ftb = querystring.indexOf(' ', inlinkp);\n                if ( ftb == -1 ) {\n                    ftb = querystring.length();\n                }\n                inlink = querystring.substring(inlinkp + 7, ftb);\n                querystring = querystring.replace(\"inlink:\" + inlink, \"\");\n                modifier.add(\"inlink:\" + inlink);\n            }\n\n            int voc = 0;\n            Collection<Tagging.Metatag> metatags = new ArrayList<Tagging.Metatag>(1);\n            while ((voc = querystring.indexOf(\"/vocabulary/\", 0)) >= 0) {\n                String vocabulary = \"\";\n                int ve = querystring.indexOf(' ', voc + 12);\n                if (ve < 0) {\n                    vocabulary = querystring.substring(voc);\n                    querystring = querystring.substring(0, voc).trim();\n                } else {\n                    vocabulary = querystring.substring(voc, ve);\n                    querystring = querystring.substring(0, voc) + querystring.substring(ve);\n                }\n                modifier.add(vocabulary);\n                vocabulary = vocabulary.substring(12);\n                int p = vocabulary.indexOf('/');\n                if (p > 0) {\n                    String k = vocabulary.substring(0, p);\n                    String v = vocabulary.substring(p + 1);\n                    metatags.add(LibraryProvider.autotagging.metatag(k, v));\n                }\n            }\n\n            int radius = 0;\n            double lon = 0.0d, lat = 0.0d, rad = 0.0d;\n            if ((radius = querystring.indexOf(\"/radius/\")) >= 0) {\n                int ve = querystring.indexOf(' ', radius + 8);\n                String geo = \"\";\n                if (ve < 0) {\n                    geo = querystring.substring(radius);\n                    querystring = querystring.substring(0, radius).trim();\n                } else {\n                    geo = querystring.substring(radius, ve);\n                    querystring = querystring.substring(0, radius) + querystring.substring(ve);\n                }\n                geo = geo.substring(8);\n                String[] sp = geo.split(\"/\");\n                if (sp.length == 3) try {\n                    lat = Double.parseDouble(sp[0]);\n                    lon = Double.parseDouble(sp[1]);\n                    rad = Double.parseDouble(sp[2]);\n                } catch (final NumberFormatException e) {\n                    lon = 0.0d; lat = 0.0d; rad = 0.0d;\n                }\n            }\n\n            final int heuristicBlekko = querystring.indexOf(\"/heuristic\", 0);\n            if ( heuristicBlekko >= 0 ) {\n                querystring = querystring.replace(\"/heuristic\", \"\");\n                modifier.add(\"/heuristic\");\n            }\n            \n            final int tldp = querystring.indexOf(\"tld:\", 0);\n            if (tldp >= 0) {\n                int ftb = querystring.indexOf(' ', tldp);\n                if (ftb == -1) ftb = querystring.length();\n                tld = querystring.substring(tldp + 4, ftb);\n                querystring = querystring.replace(\"tld:\" + tld, \"\");\n                modifier.add(\"tld:\" + tld);\n                while ( tld.length() > 0 && tld.charAt(0) == '.' ) {\n                    tld = tld.substring(1);\n                }\n                if (tld.length() == 0) tld = null;\n            }\n            if (urlmask == null || urlmask.isEmpty()) urlmask = \".*\"; //if no urlmask was given\n\n            // read the language from the language-restrict option 'lr'\n            // if no one is given, use the user agent or the system language as default\n            String language = (post == null) ? null : post.get(\"lr\");\n            if (language != null && language.startsWith(\"lang_\") ) {\n                language = language.substring(5);\n                if (modifier.language == null) modifier.language = language;\n            }\n            if (language == null || !ISO639.exists(language) ) {\n                // find out language of the user by reading of the user-agent string\n                String agent = header.get(HeaderFramework.ACCEPT_LANGUAGE);\n                if ( agent == null ) {\n                    agent = System.getProperty(\"user.language\");\n                }\n                language = (agent == null) ? \"en\" : ISO639.userAgentLanguageDetection(agent);\n                if ( language == null ) {\n                    language = \"en\";\n                }\n            }\n\n            // the query\n            final QueryGoal qg = new QueryGoal(querystring.trim());\n            final int maxDistance = (querystring.indexOf('\"', 0) >= 0) ? qg.getIncludeHashes().size() - 1 : Integer.MAX_VALUE;\n\n            // filter out stopwords\n            final SortedSet<String> filtered = SetTools.joinConstructiveByTest(qg.getIncludeWords(), Switchboard.stopwords); //find matching stopwords\n            qg.removeIncludeWords(filtered);\n            \n            // if a minus-button was hit, remove a special reference first\n            if ( post != null && post.containsKey(\"deleteref\") ) {\n                try {\n                    if ( !sb.verifyAuthentication(header) ) {\n                    \tprop.authenticationRequired();\n                        return prop;\n                    }\n\n                    // delete the index entry locally\n                    final String delHash = post.get(\"deleteref\", \"\"); // urlhash\n                    if (indexSegment.termIndex() != null) indexSegment.termIndex().remove(qg.getIncludeHashes(), delHash.getBytes());\n\n                    // make new news message with negative voting\n                    if ( !sb.isRobinsonMode() ) {\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"urlhash\", delHash);\n                        map.put(\"vote\", \"negative\");\n                        map.put(\"refid\", \"\");\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_VOTE_ADD,\n                            map);\n                    }\n\n                    // delete the search history since this still shows the entry\n                    SearchEventCache.delete(delHash);\n                } catch (final IOException e ) {\n                    ConcurrentLog.logException(e);\n                }\n            }\n\n            // if a plus-button was hit, create new voting message\n            if ( post != null && post.containsKey(\"recommendref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                final String recommendHash = post.get(\"recommendref\", \"\"); // urlhash\n                final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(recommendHash));\n                if ( urlentry != null ) {\n                    Document[] documents = null;\n                    try {\n                        documents =\n                            sb.loader.loadDocuments(\n                                sb.loader.request(urlentry.url(), true, false),\n                                CacheStrategy.IFEXIST,\n                                Integer.MAX_VALUE, BlacklistType.SEARCH, ClientIdentification.yacyIntranetCrawlerAgent);\n                    } catch (final IOException e ) {\n                    } catch (final Parser.Failure e ) {\n                    }\n                    if ( documents != null ) {\n                        // create a news message\n                        final Map<String, String> map = new HashMap<String, String>();\n                        map.put(\"url\", urlentry.url().toNormalform(true).replace(',', '|'));\n                        map.put(\"title\", urlentry.dc_title().replace(',', ' '));\n                        map.put(\"description\", documents[0].dc_title().replace(',', ' '));\n                        map.put(\"author\", documents[0].dc_creator());\n                        map.put(\"tags\", documents[0].dc_subject(' '));\n                        sb.peers.newsPool.publishMyNews(\n                            sb.peers.mySeed(),\n                            NewsPool.CATEGORY_SURFTIPP_ADD,\n                            map);\n                        documents[0].close();\n                    }\n                }\n            }\n\n            // if a bookmarks-button was hit, create new bookmark entry\n            if ( post != null && post.containsKey(\"bookmarkref\") ) {\n                if ( !sb.verifyAuthentication(header) ) {\n                \tprop.authenticationRequired();\n                    return prop;\n                }\n                //final String bookmarkHash = post.get(\"bookmarkref\", \"\"); // urlhash\n                final String urlstr = crypt.simpleDecode(post.get(\"bookmarkurl\"));\n                if (urlstr != null) {\n                    try {\n                        final Bookmark bmk = sb.bookmarksDB.createBookmark(urlstr, YMarkTables.USER_ADMIN);\n                        bmk.setProperty(Bookmark.BOOKMARK_DESCRIPTION, \"query=\"+querystring);\n                        //bmk.setProperty(Bookmark.BOOKMARK_QUERY, originalquerystring);\n                        bmk.addTag(\"/search\"); // add to bookmark folder\n                        bmk.addTag(\"searchresult\"); // add tag\n                        String urlhash = post.get(\"bookmarkref\");\n                        final URIMetadataNode urlentry = indexSegment.fulltext().getMetadata(UTF8.getBytes(urlhash));\n                        if (urlentry != null && !urlentry.dc_title().isEmpty()) \n                            bmk.setProperty(Bookmark.BOOKMARK_TITLE,urlentry.dc_title());\n                        sb.bookmarksDB.saveBookmark(bmk);\n\n                        // do the same for YMarks ?\n                        sb.tables.bookmarks.createBookmark(\n                                sb.loader,\n                                urlstr,\n                                ClientIdentification.yacyInternetCrawlerAgent,\n                                YMarkTables.USER_ADMIN,\n                                true,\n                                \"searchresult\",\n                                \"/search\");\n                    } catch (final Throwable e) { }\n                }\n            }\n\n            // check filters\n            try {\n                Pattern.compile(urlmask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal URL mask, not a valid regex: \" + urlmask);\n                prop.put(\"urlmaskerror\", 1);\n                prop.putHTML(\"urlmaskerror_urlmask\", urlmask);\n                urlmask = \".*\";\n            }\n\n            try {\n                Pattern.compile(prefermask);\n            } catch (final PatternSyntaxException ex ) {\n                SearchEvent.log.warn(\"Illegal prefer mask, not a valid regex: \" + prefermask);\n                prop.put(\"prefermaskerror\", 1);\n                prop.putHTML(\"prefermaskerror_prefermask\", prefermask);\n                prefermask = \"\";\n            }\n\n            // do the search\n            final QueryParams theQuery =\n                new QueryParams(\n                    qg,\n                    modifier,\n                    maxDistance,\n                    prefermask,\n                    contentdom,\n                    language,\n                    metatags,\n                    snippetFetchStrategy,\n                    itemsPerPage,\n                    startRecord,\n                    urlmask, tld, inlink,\n                    clustersearch && global ? QueryParams.Searchdom.CLUSTER : (global && indexReceiveGranted ? QueryParams.Searchdom.GLOBAL : QueryParams.Searchdom.LOCAL),\n                    constraint,\n                    true,\n                    DigestURL.hosthashess(sb.getConfig(\"search.excludehosth\", \"\")),\n                    MultiProtocolURL.TLD_any_zone_filter,\n                    client,\n                    authenticated,\n                    indexSegment,\n                    ranking,\n                    header.get(HeaderFramework.USER_AGENT, \"\"),\n                    sb.getConfigBool(SwitchboardConstants.SEARCH_VERIFY_DELETE, false)\n                        && sb.getConfigBool(SwitchboardConstants.NETWORK_SEARCHVERIFY, false)\n                        && sb.peers.mySeed().getFlagAcceptRemoteIndex(),\n                    false,\n                    lat, lon, rad,\n                    sb.getConfigArray(\"search.navigation\", \"\"));\n            EventTracker.delete(EventTracker.EClass.SEARCH);\n            EventTracker.update(EventTracker.EClass.SEARCH, new ProfilingGraph.EventSearch(\n                theQuery.id(true),\n                SearchEventType.INITIALIZATION,\n                \"\",\n                0,\n                0), false);\n\n            // tell all threads to do nothing for a specific time\n            sb.intermissionAllThreads(3000);\n\n            // filter out words that appear in bluelist\n            theQuery.getQueryGoal().filterOut(Switchboard.blueList);\n\n            // log\n            ConcurrentLog.info(\n                \"LOCAL_SEARCH\",\n                \"INIT WORD SEARCH: \"\n                    + theQuery.getQueryGoal().getQueryString(false)\n                    + \":\"\n                    + QueryParams.hashSet2hashString(theQuery.getQueryGoal().getIncludeHashes())\n                    + \" - \"\n                    + theQuery.neededResults()\n                    + \" links to be computed, \"\n                    + theQuery.itemsPerPage()\n                    + \" lines to be displayed\");\n            EventChannel.channels(EventChannel.LOCALSEARCH).addMessage(\n                new RSSMessage(\"Local Search Request\", theQuery.getQueryGoal().getQueryString(false), \"\"));\n            final long timestamp = System.currentTimeMillis();\n\n            // create a new search event\n            if ( SearchEventCache.getEvent(theQuery.id(false)) == null ) {\n                theQuery.setOffset(0); // in case that this is a new search, always start without a offset\n                startRecord = 0;\n            }\n            final SearchEvent theSearch =\n                SearchEventCache.getEvent(\n                    theQuery,\n                    sb.peers,\n                    sb.tables,\n                    (sb.isRobinsonMode()) ? sb.clusterhashes : null,\n                    false,\n                    sb.loader,\n                    (int) sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXCOUNT_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXCOUNT_DEFAULT, 10)),\n                    sb.getConfigLong(\n                        SwitchboardConstants.REMOTESEARCH_MAXTIME_USER,\n                        sb.getConfigLong(SwitchboardConstants.REMOTESEARCH_MAXTIME_DEFAULT, 3000)));\n\n            if ( startRecord == 0 ) {\n                if ( modifier.sitehost != null && sb.getConfigBool(SwitchboardConstants.HEURISTIC_SITE, false) && authenticated && !stealthmode) {\n                    sb.heuristicSite(theSearch, modifier.sitehost);\n                }\n                if ( heuristicBlekko >= 0  && authenticated && !stealthmode ) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n                if (sb.getConfigBool(SwitchboardConstants.HEURISTIC_OPENSEARCH, false) && authenticated && !stealthmode) {\n                    FederateSearchManager.getManager().search(theSearch);\n                }\n            }\n\n            // log\n            ConcurrentLog.info(\"LOCAL_SEARCH\", \"EXIT WORD SEARCH: \"\n                + theQuery.getQueryGoal().getQueryString(false)\n                + \" - \"\n                + \"local_rwi_available(\" + theSearch.local_rwi_available.get() + \"), \"\n                + \"local_rwi_stored(\" + theSearch.local_rwi_stored.get() + \"), \"\n                + \"remote_rwi_available(\" + theSearch.remote_rwi_available.get() + \"), \"\n                + \"remote_rwi_stored(\" + theSearch.remote_rwi_stored.get() + \"), \"\n                + \"remote_rwi_peerCount(\" + theSearch.remote_rwi_peerCount.get() + \"), \"\n                + \"local_solr_available(\" + theSearch.local_solr_available.get() + \"), \"\n                + \"local_solr_stored(\" + theSearch.local_solr_stored.get() + \"), \"\n                + \"remote_solr_available(\" + theSearch.remote_solr_available.get() + \"), \"\n                + \"remote_solr_stored(\" + theSearch.remote_solr_stored.get() + \"), \"\n                + \"remote_solr_peerCount(\" + theSearch.remote_solr_peerCount.get() + \"), \"\n                + (System.currentTimeMillis() - timestamp)\n                + \" ms\");\n\n            // prepare search statistics\n            theQuery.searchtime = System.currentTimeMillis() - timestamp;\n            theQuery.urlretrievaltime = theSearch.getURLRetrievalTime();\n            theQuery.snippetcomputationtime = theSearch.getSnippetComputationTime();\n            AccessTracker.add(AccessTracker.Location.local, theQuery, theSearch.getResultCount());\n\n            // check suggestions\n            final int meanMax = (post != null) ? post.getInt(\"meanCount\", 0) : 0;\n\n            prop.put(\"meanCount\", meanMax);\n            if ( meanMax > 0 && !json && !rss && sb.index.connectedRWI()) {\n                final DidYouMean didYouMean = new DidYouMean(indexSegment, new StringBuilder(querystring));\n                final Iterator<StringBuilder> meanIt = didYouMean.getSuggestions(100, 5).iterator();\n                int meanCount = 0;\n                String suggestion;\n                try {\n                    meanCollect: while ( meanCount < meanMax && meanIt.hasNext() ) {\n                        try {\n                            suggestion = meanIt.next().toString();\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_word\", suggestion);\n                            prop.put(\n                                \"didYouMean_suggestions_\" + meanCount + \"_url\",\n                                QueryParams.navurl(\n                                    RequestHeader.FileType.HTML,\n                                    0,\n                                    theQuery,\n                                    suggestion, true).toString());\n                            prop.put(\"didYouMean_suggestions_\" + meanCount + \"_sep\", \"|\");\n                            meanCount++;\n                        } catch (final ConcurrentModificationException e) {\n                            ConcurrentLog.logException(e);\n                            break meanCollect;\n                        }\n                    }\n                } catch (final ConcurrentModificationException e) {\n                    ConcurrentLog.logException(e);\n                }\n                prop.put(\"didYouMean_suggestions_\" + (meanCount - 1) + \"_sep\", \"\");\n                prop.put(\"didYouMean\", meanCount > 0 ? 1 : 0);\n                prop.put(\"didYouMean_suggestions\", meanCount);\n            } else {\n                prop.put(\"didYouMean\", 0);\n            }\n\n            // find geographic info\n            final SortedSet<GeoLocation> coordinates = LibraryProvider.geoLoc.find(originalquerystring, false);\n            if ( coordinates == null || coordinates.isEmpty() || startRecord > 0 ) {\n                prop.put(\"geoinfo\", \"0\");\n            } else {\n                int i = 0;\n                for ( final GeoLocation c : coordinates ) {\n                    prop.put(\"geoinfo_loc_\" + i + \"_lon\", Math.round(c.lon() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_lat\", Math.round(c.lat() * 10000.0f) / 10000.0f);\n                    prop.put(\"geoinfo_loc_\" + i + \"_name\", c.getName());\n                    i++;\n                    if ( i >= 10 ) {\n                        break;\n                    }\n                }\n                prop.put(\"geoinfo_loc\", i);\n                prop.put(\"geoinfo\", \"1\");\n            }\n\n            // update the search tracker\n            try {\n                synchronized ( trackerHandles ) {\n                    trackerHandles.add(theQuery.starttime);\n                    while ( trackerHandles.size() > 600 ) {\n                        if ( !trackerHandles.remove(trackerHandles.first()) ) {\n                            break;\n                        }\n                    }\n                }\n                sb.localSearchTracker.put(client, trackerHandles);\n                if ( sb.localSearchTracker.size() > 100 ) {\n                    sb.localSearchTracker.remove(sb.localSearchTracker.keys().nextElement());\n                }\n                if ( MemoryControl.shortStatus() ) {\n                    sb.localSearchTracker.clear();\n                }\n            } catch (final Exception e ) {\n                ConcurrentLog.logException(e);\n            }\n\n            prop.put(\"num-results_offset\", startRecord);\n            prop.put(\"num-results_itemscount\", Formatter.number(startRecord + theSearch.query.itemsPerPage > theSearch.getResultCount() ? startRecord + theSearch.getResultCount() % theSearch.query.itemsPerPage : startRecord + theSearch.query.itemsPerPage, true));\n            prop.put(\"num-results_itemsPerPage\", Formatter.number(itemsPerPage));\n            prop.put(\"num-results_totalcount\", Formatter.number(theSearch.getResultCount())); // also in yacyserchtrailer (hint: timing in p2p search )\n            prop.put(\"num-results_globalresults\", global && (indexReceiveGranted || clustersearch) ? \"1\" : \"0\");\n            prop.put(\"num-results_globalresults_localResourceSize\", Formatter.number(theSearch.local_rwi_stored.get() + theSearch.local_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteResourceSize\", Formatter.number(theSearch.remote_rwi_stored.get() + theSearch.remote_solr_stored.get(), true));\n            prop.put(\"num-results_globalresults_remoteIndexCount\", Formatter.number(theSearch.remote_rwi_available.get() + theSearch.remote_solr_available.get(), true));\n            prop.put(\"num-results_globalresults_remotePeerCount\", Formatter.number(theSearch.remote_rwi_peerCount.get() + theSearch.remote_solr_peerCount.get(), true));\n\n            // generate the search result lines; the content will be produced by another servlet\n            for ( int i = 0; i < theQuery.itemsPerPage(); i++ ) {\n                prop.put(\"results_\" + i + \"_item\", startRecord + i);\n                prop.put(\"results_\" + i + \"_eventID\", theQuery.id(false));\n            }\n            prop.put(\"results\", theQuery.itemsPerPage());\n            prop.put(\"resultTable\", (contentdom == ContentDomain.APP || contentdom == ContentDomain.AUDIO || contentdom == ContentDomain.VIDEO) ? 1 : 0);\n            prop.put(\"eventID\", theQuery.id(false)); // for bottomline\n\n            // process result of search\n            if ( !filtered.isEmpty() ) {\n                prop.put(\"excluded\", \"1\");\n                prop.putHTML(\"excluded_stopwords\", filtered.toString());\n            } else {\n                prop.put(\"excluded\", \"0\");\n            }\n\n            if (prop.isEmpty() || querystring.length() == 0) {\n                if ( querystring.length() == 0 ) { // querystring is trimmed originalquerystring\n                    prop.put(\"num-results\", \"2\"); // no results - at least 2 chars\n                } else {\n                    prop.put(\"num-results\", \"1\"); // no results\n                }\n            } else {\n                prop.put(\"num-results\", \"3\");\n            }\n\n            prop.put(\"depth\", \"0\");\n\n        }\n        prop.put(\"focus\", focus ? 1 : 0); // focus search field\n        prop.put(\"searchagain\", global ? \"1\" : \"0\");\n        prop.putHTML(\"former\", originalquerystring.replaceAll(Segment.catchallString, \"*\"));\n        prop.put(\"count\", itemsPerPage);\n        prop.put(\"offset\", startRecord);\n        prop.put(\"resource\", global ? \"global\" : \"local\");\n        prop.putHTML(\"prefermaskfilter\", prefermask);\n        prop.put(\"indexof\", (indexof) ? \"on\" : \"off\");\n        prop.put(\"constraint\", (constraint == null) ? \"\" : constraint.exportB64());\n        prop.put(\"search.verify\", snippetFetchStrategy == null ? sb.getConfig(\"search.verify\", \"iffresh\") : snippetFetchStrategy.toName());\n        prop.put(\"search.navigation\", (post == null) ? sb.getConfig(\"search.navigation\", \"all\") : post.get(\"nav\", \"all\"));\n        prop.putHTML(\"contentdom\", (post == null ? \"text\" : post.get(\"contentdom\", \"text\")));\n\n        // for RSS: don't HTML encode some elements\n        prop.putXML(\"rss_query\", originalquerystring);\n        prop.putXML(\"rss_queryenc\", originalquerystring.replace(' ', '+'));\n\n        sb.localSearchLastAccess = System.currentTimeMillis();\n\n        // hostname and port (assume locahost if nothing helps)\n        final String hostIP = sb.peers.mySeed().getIP();\n        prop.put(\"myhost\", hostIP != null ? hostIP : Domains.LOCALHOST);\n        prop.put(\"myport\", Domains.LOCALHOST.equals(hostIP) ? sb.getLocalPort(\"port\", 8090) : sb.getPublicPort(\"port\", 8090));\n\n        // return rewrite properties\n        return prop;\n    }","commit_id":"efbc9a35611e9ab9abc059da3cf0f24aafe79fc7","url":"https://github.com/yacy/yacy_search_server"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());\r\n        if (controller != null && sourcePermanent != null) {\r\n            UUID exileId = CardUtil.getCardExileZoneId(game, source);\r\n            int numberOfCards = 0;\r\n            for (Card card:  game.getExile().getExileZone(exileId).getCards(game)) {\r\n                if (card.getOwnerId().equals(controller.getId())) {\r\n                    numberOfCards++;\r\n                    card.setFaceDown(false);\r\n                    card.moveToZone(Zone.HAND, source.getSourceId(), game, true);\r\n                }\r\n            }\r\n            if (numberOfCards > 0) {\r\n                game.informPlayers(sourcePermanent.getName() + \": \" + controller.getName() + \" returns \"+ numberOfCards + \" card\" + (numberOfCards > 1 ?\"s\":\"\") + \" from exile to hand\");\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":74650,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        Permanent sourcePermanent = game.getPermanentOrLKIBattlefield(source.getSourceId());\r\n        if (controller != null && sourcePermanent != null) {\r\n            UUID exileId = CardUtil.getCardExileZoneId(game, source);\r\n            int numberOfCards = 0;\r\n            ExileZone exileZone = game.getExile().getExileZone(exileId);\r\n            if (exileZone != null) {\r\n                for (Card card:  exileZone.getCards(game)) {\r\n                    if (card.getOwnerId().equals(controller.getId())) {\r\n                        numberOfCards++;\r\n                        card.setFaceDown(false);\r\n                        card.moveToZone(Zone.HAND, source.getSourceId(), game, true);\r\n                    }\r\n                }\r\n            }\r\n            if (numberOfCards > 0) {\r\n                game.informPlayers(sourcePermanent.getLogName() + \": \" + controller.getName() + \" returns \"+ numberOfCards + \" card\" + (numberOfCards > 1 ?\"s\":\"\") + \" from exile to hand\");\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"c794dab8d1a5349e26868068fd5f2e7548ad8e11","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {\r\n        return sourceId.equals(cardId) && game.getState().getExile().getExileZone(exileId).contains(cardId);\r\n    }","id":74651,"modified_method":"@Override\r\n    public boolean applies(UUID sourceId, Ability source, UUID affectedControllerId, Game game) {\r\n        if (sourceId.equals(cardId)) {\r\n            ExileZone exileZone = game.getState().getExile().getExileZone(exileId);\r\n            return exileZone != null && exileZone.contains(cardId);\r\n        }\r\n        return false;\r\n    }","commit_id":"b828cce8fe3b0bc3441ba2f9a2ef2bdc770868e6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            // move creature cards from graveyard to exile\r\n            for (UUID playerId: controller.getInRange()){\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    for (Card card :player.getGraveyard().getCards(new FilterCreatureCard(), game)) {\r\n                        card.moveToExile(source.getSourceId(), \"Living End\", source.getSourceId(), game);\r\n                    }\r\n                }\r\n            }\r\n            // sacrifice all creatures\r\n            for (Permanent permanent :game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                permanent.sacrifice(source.getSourceId(), game);\r\n            }\r\n            // put exiled cards to battlefield\r\n            for (Card card : game.getState().getExile().getExileZone(source.getSourceId()).getCards(game)) {\r\n                card.putOntoBattlefield(game, Zone.EXILED, source.getSourceId(), card.getOwnerId());\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":74652,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (controller != null && sourceObject != null) {\r\n            // move creature cards from graveyard to exile\r\n            for (UUID playerId: controller.getInRange()){\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    for (Card card :player.getGraveyard().getCards(new FilterCreatureCard(), game)) {\r\n                        controller.moveCardToExileWithInfo(card, source.getSourceId(), sourceObject.getLogName(), source.getSourceId(), game, Zone.GRAVEYARD);\r\n                    }\r\n                }\r\n            }\r\n            // sacrifice all creatures\r\n            for (Permanent permanent :game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                permanent.sacrifice(source.getSourceId(), game);\r\n            }\r\n            // put exiled cards to battlefield\r\n            ExileZone exileZone = game.getState().getExile().getExileZone(source.getSourceId());\r\n            if (exileZone != null) {\r\n                for (Card card : exileZone.getCards(game)) {\r\n                    controller.putOntoBattlefieldWithInfo(card, game, Zone.EXILED, source.getSourceId());\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"b828cce8fe3b0bc3441ba2f9a2ef2bdc770868e6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            // move creature cards from graveyard to exile\r\n            for (UUID playerId: controller.getInRange()){\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    for (Card card :player.getGraveyard().getCards(new FilterCreatureCard(), game)) {\r\n                        card.moveToExile(source.getSourceId(), \"Living End\", source.getSourceId(), game);\r\n                    }\r\n                }\r\n            }\r\n            // sacrifice all creatures\r\n            for (Permanent permanent :game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                permanent.sacrifice(source.getSourceId(), game);\r\n            }\r\n            // put exiled cards to battlefield\r\n            ExileZone exileZone = game.getState().getExile().getExileZone(source.getSourceId());\r\n            if (exileZone != null) {\r\n                for (Card card : exileZone.getCards(game)) {\r\n                    card.putOntoBattlefield(game, Zone.EXILED, source.getSourceId(), card.getOwnerId());\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":74653,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        MageObject sourceObject = game.getObject(source.getSourceId());\r\n        if (controller != null && sourceObject != null) {\r\n            // move creature cards from graveyard to exile\r\n            for (UUID playerId: controller.getInRange()){\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    for (Card card :player.getGraveyard().getCards(new FilterCreatureCard(), game)) {\r\n                        controller.moveCardToExileWithInfo(card, source.getSourceId(), sourceObject.getLogName(), source.getSourceId(), game, Zone.GRAVEYARD);\r\n                    }\r\n                }\r\n            }\r\n            // sacrifice all creatures\r\n            for (Permanent permanent :game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                permanent.sacrifice(source.getSourceId(), game);\r\n            }\r\n            // put exiled cards to battlefield\r\n            ExileZone exileZone = game.getState().getExile().getExileZone(source.getSourceId());\r\n            if (exileZone != null) {\r\n                for (Card card : exileZone.getCards(game)) {\r\n                    controller.putOntoBattlefieldWithInfo(card, game, Zone.EXILED, source.getSourceId());\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"b828cce8fe3b0bc3441ba2f9a2ef2bdc770868e6","url":"https://github.com/magefree/mage"},{"original_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            // move creature cards from graveyard to exile\r\n            for (UUID playerId: controller.getInRange()){\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    for (Card card :player.getGraveyard().getCards(new FilterCreatureCard(), game)) {\r\n                        card.moveToExile(source.getSourceId(), \"Living End\", source.getSourceId(), game);\r\n                    }\r\n                }\r\n            }\r\n            // sacrifice all creatures\r\n            for (Permanent permanent :game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                permanent.sacrifice(source.getSourceId(), game);\r\n            }\r\n            // put exiled cards to battlefield\r\n            for (Card card : game.getState().getExile().getExileZone(source.getSourceId()).getCards(game)) {\r\n                card.putOntoBattlefield(game, Zone.EXILED, source.getSourceId(), card.getOwnerId());\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","id":74654,"modified_method":"@Override\r\n    public boolean apply(Game game, Ability source) {\r\n        Player controller = game.getPlayer(source.getControllerId());\r\n        if (controller != null) {\r\n            // move creature cards from graveyard to exile\r\n            for (UUID playerId: controller.getInRange()){\r\n                Player player = game.getPlayer(playerId);\r\n                if (player != null) {\r\n                    for (Card card :player.getGraveyard().getCards(new FilterCreatureCard(), game)) {\r\n                        card.moveToExile(source.getSourceId(), \"Living End\", source.getSourceId(), game);\r\n                    }\r\n                }\r\n            }\r\n            // sacrifice all creatures\r\n            for (Permanent permanent :game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(), source.getControllerId(), game)) {\r\n                permanent.sacrifice(source.getSourceId(), game);\r\n            }\r\n            // put exiled cards to battlefield\r\n            ExileZone exileZone = game.getState().getExile().getExileZone(source.getSourceId());\r\n            if (exileZone != null) {\r\n                for (Card card : exileZone.getCards(game)) {\r\n                    card.putOntoBattlefield(game, Zone.EXILED, source.getSourceId(), card.getOwnerId());\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }","commit_id":"f6f178c390fb114c61d1b5ce4037f25b9dc927c1","url":"https://github.com/magefree/mage"},{"original_method":"public void execute(InternalRequest request, ServletResponse response,\n                      String controllerPath, String actionKey) {\n    try {\n      WebService.Action action = getAction(controllerPath, actionKey);\n      request.setAction(action);\n      verifyRequest(action, request);\n      action.handler().handle(request, response);\n\n    } catch (IllegalArgumentException e) {\n      // TODO replace by BadRequestException in Request#mandatoryParam()\n      sendError(400, e.getMessage(), response);\n    } catch (BadRequestException e) {\n      sendError(e, response);\n    } catch (ServerException e) {\n      sendError(e.httpCode(), message(e.getMessage(), e.l10nKey(), e.l10nParams()), response);\n    } catch (Exception e) {\n      // TODO implement Request.toString()\n      LoggerFactory.getLogger(getClass()).error(\"Fail to process request \" + request, e);\n      sendError(500, e.getMessage(), response);\n    }\n  }","id":74655,"modified_method":"public void execute(InternalRequest request, ServletResponse response,\n                      String controllerPath, String actionKey) {\n    try {\n      WebService.Action action = getAction(controllerPath, actionKey);\n      request.setAction(action);\n      verifyRequest(action, request);\n      InternalRequest wrapped = wrapWithDefaults(action, request);\n      action.handler().handle(wrapped, response);\n\n    } catch (IllegalArgumentException e) {\n      // TODO replace by BadRequestException in Request#mandatoryParam()\n      sendError(400, e.getMessage(), response);\n    } catch (BadRequestException e) {\n      sendError(e, response);\n    } catch (ServerException e) {\n      sendError(e.httpCode(), message(e.getMessage(), e.l10nKey(), e.l10nParams()), response);\n    } catch (Exception e) {\n      // TODO implement Request.toString()\n      LoggerFactory.getLogger(getClass()).error(\"Fail to process request \" + request, e);\n      sendError(500, e.getMessage(), response);\n    }\n  }","commit_id":"dd38eb3d057eb1eb37a1be1567960906c85f10be","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Override\n    public void define(Context context) {\n      NewController newController = context.createController(\"api/system\");\n      newController.createAction(\"health\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            try {\n              response.stream().output().write(\"good\".getBytes());\n            } catch (IOException e) {\n              throw new IllegalStateException(e);\n            }\n          }\n        });\n      newController.createAction(\"ping\")\n        .setPost(true)\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            try {\n              response.stream().output().write(\"pong\".getBytes());\n            } catch (IOException e) {\n              throw new IllegalStateException(e);\n            }\n          }\n        });\n      newController.createAction(\"fail\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            throw new IllegalStateException(\"Unexpected\");\n          }\n        });\n      newController.createAction(\"fail_with_i18n_message\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            throw BadRequestException.ofL10n(\"bad.request.reason\", 0);\n          }\n        });\n      newController.createAction(\"fail_with_multiple_messages\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            List<BadRequestException.Message> errors = Lists.newArrayList();\n            for (int count = 0; count < Integer.valueOf(request.param(\"count\")); count++) {\n              errors.add(Message.of(\"Bad request reason #\" + count));\n            }\n            throw BadRequestException.of(errors);\n          }\n        });\n      newController.createAction(\"fail_with_multiple_i18n_messages\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            List<BadRequestException.Message> errors = Lists.newArrayList();\n            for (int count = 0; count < Integer.valueOf(request.param(\"count\")); count++) {\n              errors.add(Message.ofL10n(\"bad.request.reason\", count));\n            }\n            throw BadRequestException.of(errors);\n          }\n        });\n      newController.createAction(\"server_exception_with_i18n_message\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            throw new ServerException(404, null, \"not.found\", null);\n          }\n        });\n      newController.createAction(\"alive\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            response.noContent();\n          }\n        });\n\n      // parameter \"message\" is required but not \"author\"\n      newController.createAction(\"print\")\n        .createParam(\"message\", \"required message\")\n        .createParam(\"author\", \"optional author\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            try {\n              IOUtils.write(\n                request.mandatoryParam(\"message\") + \" by \" + request.param(\"author\", \"-\"), response.stream().output());\n            } catch (IOException e) {\n              throw new IllegalStateException(e);\n            }\n          }\n        });\n      newController.done();\n    }","id":74656,"modified_method":"@Override\n    public void define(Context context) {\n      NewController newController = context.createController(\"api/system\");\n      newController.createAction(\"health\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            try {\n              response.stream().output().write(\"good\".getBytes());\n            } catch (IOException e) {\n              throw new IllegalStateException(e);\n            }\n          }\n        });\n      newController.createAction(\"ping\")\n        .setPost(true)\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            try {\n              response.stream().output().write(\"pong\".getBytes());\n            } catch (IOException e) {\n              throw new IllegalStateException(e);\n            }\n          }\n        });\n      newController.createAction(\"fail\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            throw new IllegalStateException(\"Unexpected\");\n          }\n        });\n      newController.createAction(\"fail_with_i18n_message\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            throw BadRequestException.ofL10n(\"bad.request.reason\", 0);\n          }\n        });\n      newController.createAction(\"fail_with_multiple_messages\")\n        .createParam(\"count\", \"Number of error messages to generate\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            List<BadRequestException.Message> errors = Lists.newArrayList();\n            for (int count = 0; count < Integer.valueOf(request.param(\"count\")); count++) {\n              errors.add(Message.of(\"Bad request reason #\" + count));\n            }\n            throw BadRequestException.of(errors);\n          }\n        });\n      newController.createAction(\"fail_with_multiple_i18n_messages\")\n        .createParam(\"count\", \"Number of error messages to generate\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            List<BadRequestException.Message> errors = Lists.newArrayList();\n            for (int count = 0; count < Integer.valueOf(request.param(\"count\")); count++) {\n              errors.add(Message.ofL10n(\"bad.request.reason\", count));\n            }\n            throw BadRequestException.of(errors);\n          }\n        });\n      newController.createAction(\"server_exception_with_i18n_message\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            throw new ServerException(404, null, \"not.found\", null);\n          }\n        });\n      newController.createAction(\"alive\")\n        .setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            response.noContent();\n          }\n        });\n\n      newController.createAction(\"fail_with_undeclared_parameter\")\n      .setHandler(new RequestHandler() {\n        @Override\n        public void handle(Request request, Response response) {\n          response.newJsonWriter().prop(\"unknown\", request.param(\"unknown\"));\n        }\n      });\n\n      // parameter \"message\" is required but not \"author\"\n      NewAction print = newController.createAction(\"print\");\n      print.createParam(\"message\").setDescription(\"required message\").setRequired(true);\n      print.createParam(\"author\").setDescription(\"optional author\").setDefaultValue(\"-\");\n      print.setHandler(new RequestHandler() {\n          @Override\n          public void handle(Request request, Response response) {\n            try {\n              IOUtils.write(\n                request.mandatoryParam(\"message\") + \" by \" + request.param(\"author\", \"nobody\"), response.stream().output());\n            } catch (IOException e) {\n              throw new IllegalStateException(e);\n            }\n          }\n        });\n      newController.done();\n    }","commit_id":"dd38eb3d057eb1eb37a1be1567960906c85f10be","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"@Test\n  public void action_parameters() {\n    new WebService() {\n      @Override\n      public void define(Context context) {\n        NewController newController = context.createController(\"api/rule\");\n        NewAction create = newController.createAction(\"create\").setHandler(mock(RequestHandler.class));\n        create.createParam(\"key\").setDescription(\"Key of the new rule\");\n        create.createParam(\"severity\");\n        newController.done();\n      }\n    }.define(context);\n\n    WebService.Action action = context.controller(\"api/rule\").action(\"create\");\n    assertThat(action.params()).hasSize(2);\n\n    assertThat(action.param(\"key\").key()).isEqualTo(\"key\");\n    assertThat(action.param(\"key\").description()).isEqualTo(\"Key of the new rule\");\n    assertThat(action.param(\"key\").toString()).isEqualTo(\"key\");\n\n    assertThat(action.param(\"severity\").key()).isEqualTo(\"severity\");\n    assertThat(action.param(\"severity\").description()).isNull();\n  }","id":74657,"modified_method":"@Test\n  public void action_parameters() {\n    new WebService() {\n      @Override\n      public void define(Context context) {\n        NewController newController = context.createController(\"api/rule\");\n        NewAction create = newController.createAction(\"create\").setHandler(mock(RequestHandler.class));\n        create.createParam(\"key\").setDescription(\"Key of the new rule\");\n        create.createParam(\"severity\").setDefaultValue(\"MAJOR\");\n        newController.done();\n      }\n    }.define(context);\n\n    WebService.Action action = context.controller(\"api/rule\").action(\"create\");\n    assertThat(action.params()).hasSize(2);\n\n    assertThat(action.param(\"key\").key()).isEqualTo(\"key\");\n    assertThat(action.param(\"key\").description()).isEqualTo(\"Key of the new rule\");\n    assertThat(action.param(\"key\").toString()).isEqualTo(\"key\");\n\n    assertThat(action.param(\"severity\").key()).isEqualTo(\"severity\");\n    assertThat(action.param(\"severity\").description()).isNull();\n    assertThat(action.param(\"severity\").defaultValue()).isEqualTo(\"MAJOR\");\n  }","commit_id":"dd38eb3d057eb1eb37a1be1567960906c85f10be","url":"https://github.com/SonarSource/sonarqube"},{"original_method":"public static void buildText(@NotNull XValuePresentation valuePresenter, @NotNull ColoredTextContainer text) {\n    XValuePresentationUtil.appendSeparator(text, valuePresenter.getSeparator());\n    String type = valuePresenter.getType();\n    if (type != null) {\n      text.append(\"{\" + type + \"} \", XDebuggerUIConstants.TYPE_ATTRIBUTES);\n    }\n    valuePresenter.renderValue(new XValueTextRendererImpl(text));\n  }","id":74658,"modified_method":"public static void buildText(@NotNull XValuePresentation valuePresenter, @NotNull ColoredTextContainer text) {\n    buildText(valuePresenter, text, true);\n  }","commit_id":"01d6f6b19de55ea948189e7e49b1144a33fe6265","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"protected void buildTreeAndRestoreState(@NotNull XStackFrame stackFrame) {\n    XDebuggerTree tree = myDebuggerTreePanel.getTree();\n    tree.setSourcePosition(stackFrame.getSourcePosition());\n    tree.setRoot(new XStackFrameNode(tree, stackFrame), false);\n    tree.getProject().putUserData(XVariablesView.DEBUG_VARIABLES, new HashMap<Pair<VirtualFile, Integer>, Set<XValueNodeImpl>>());\n    tree.getProject().putUserData(XVariablesView.DEBUG_VARIABLES_TIMESTAMPS, new HashMap<VirtualFile, Long>());\n    Object newEqualityObject = stackFrame.getEqualityObject();\n    if (myFrameEqualityObject != null && newEqualityObject != null && myFrameEqualityObject.equals(newEqualityObject)\n        && myTreeState != null) {\n      disposeTreeRestorer();\n      myTreeRestorer = myTreeState.restoreState(tree);\n    }\n  }","id":74659,"modified_method":"protected void buildTreeAndRestoreState(@NotNull final XStackFrame stackFrame) {\n    XDebuggerTree tree = myDebuggerTreePanel.getTree();\n    final XSourcePosition position = stackFrame.getSourcePosition();\n    tree.setSourcePosition(position);\n    tree.setRoot(new XStackFrameNode(tree, stackFrame), false);\n    final Project project = tree.getProject();\n    project.putUserData(XVariablesView.DEBUG_VARIABLES, new HashMap<Pair<VirtualFile, Integer>, Set<XValueNodeImpl>>());\n    project.putUserData(XVariablesView.DEBUG_VARIABLES_TIMESTAMPS, new HashMap<VirtualFile, Long>());\n    Object newEqualityObject = stackFrame.getEqualityObject();\n    if (myFrameEqualityObject != null && newEqualityObject != null && myFrameEqualityObject.equals(newEqualityObject)\n        && myTreeState != null) {\n      disposeTreeRestorer();\n      myTreeRestorer = myTreeState.restoreState(tree);\n    }\n    if (position != null && Registry.is(\"ide.debugger.inline\")) {\n      final VirtualFile file = position.getFile();\n      final FileEditor fileEditor = FileEditorManagerEx.getInstanceEx(project).getSelectedEditor(file);\n      if (fileEditor instanceof PsiAwareTextEditorImpl) {\n        final Editor editor = ((PsiAwareTextEditorImpl)fileEditor).getEditor();\n        final SelectionListener listener = new SelectionListener() {\n          @Override\n          public void selectionChanged(SelectionEvent e) {\n            final String text = editor.getDocument().getText(e.getNewRange());\n            final XDebuggerEvaluator evaluator = stackFrame.getEvaluator();\n            if (evaluator != null) {\n              evaluator.evaluate(text, new XEvaluationCallbackBase() {\n                @Override\n                public void evaluated(@NotNull XValue result) {\n                  result.computePresentation(new XValueNodePresentationConfigurator.ConfigurableXValueNodeImpl() {\n                    @Override\n                    public void applyPresentation(@Nullable Icon icon,\n                                                  @NotNull XValuePresentation valuePresenter,\n                                                  boolean hasChildren) {\n                      SimpleColoredText text = new SimpleColoredText();\n                      XValueNodeImpl.buildText(valuePresenter, text, false);\n                      SimpleColoredComponent component = HintUtil.createInformationComponent();\n                      text.appendToComponent(component);\n                      HintManager.getInstance().hideAllHints();\n                      HintManager.getInstance().showInformationHint(editor, component);\n                    }\n\n                    @Override\n                    public void setFullValueEvaluator(@NotNull XFullValueEvaluator fullValueEvaluator) {\n                    }\n\n                    @Override\n                    public boolean isObsolete() {\n                      return true;\n                    }\n                  }, XValuePlace.TOOLTIP);\n                }\n\n                @Override\n                public void errorOccurred(@NotNull String errorMessage) {\n                  System.out.println(errorMessage);\n                }\n              }, position);\n            }\n          }\n        };\n        editor.getSelectionModel().addSelectionListener(listener);\n        Disposer.register(tree, new Disposable() {\n          @Override\n          public void dispose() {\n            final FileEditor fileEditor = FileEditorManagerEx.getInstanceEx(project).getSelectedEditor(file);\n            if (fileEditor instanceof PsiAwareTextEditorImpl) {\n              ((PsiAwareTextEditorImpl)fileEditor).getEditor().getSelectionModel().removeSelectionListener(listener);\n            }\n          }\n        });\n      }\n    }\n  }","commit_id":"01d6f6b19de55ea948189e7e49b1144a33fe6265","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public int getLineIndex() {\n    return getSourcePosition().getLine();\n  }","id":74660,"modified_method":"public int getLineIndex() {\n    final SourcePosition sourcePosition = getSourcePosition();\n    return (sourcePosition != null) ? sourcePosition.getLine() : -1;\n  }","commit_id":"f1dbbdd9f2df20e28ce20de7a5708f97c602ac51","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void createRequest(@NotNull DebugProcessImpl debugProcess) {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    // check is this breakpoint is enabled, vm reference is valid and there're no requests created yet\n    if (!isEnabled() ||\n        !debugProcess.isAttached() ||\n        isMuted(debugProcess) ||\n        !debugProcess.getRequestsManager().findRequests(this).isEmpty()) {\n      return;\n    }\n\n    if (!isValid()) {\n      return;\n    }\n\n    createOrWaitPrepare(debugProcess, getSourcePosition());\n    updateUI();\n  }","id":74661,"modified_method":"@Override\n  public void createRequest(@NotNull DebugProcessImpl debugProcess) {\n    DebuggerManagerThreadImpl.assertIsManagerThread();\n    // check is this breakpoint is enabled, vm reference is valid and there're no requests created yet\n    if (!isEnabled() ||\n        !debugProcess.isAttached() ||\n        isMuted(debugProcess) ||\n        !debugProcess.getRequestsManager().findRequests(this).isEmpty()) {\n      return;\n    }\n\n    if (!isValid()) {\n      return;\n    }\n\n    SourcePosition position = getSourcePosition();\n    if (position != null) {\n      createOrWaitPrepare(debugProcess, position);\n    }\n    else {\n      LOG.error(\"Unable to create request for breakpoint with null position: \" + getDisplayName() + \" at \" + myXBreakpoint.getSourcePosition());\n    }\n    updateUI();\n  }","commit_id":"5c114911f3d9ebe7ef90f196895a272b83997c84","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public ProblemDescriptor[] getDescriptions(PsiElement where, InspectionManager manager, boolean isOnTheFly) {\n    List<PsiTypeCastExpression> redundantCasts = RedundantCastUtil.getRedundantCastsInside(where);\n    if (redundantCasts.isEmpty()) return null;\n    ProblemDescriptor[] descriptions = new ProblemDescriptor[redundantCasts.size()];\n    for (int i = 0; i < redundantCasts.size(); i++) {\n      descriptions[i] = createDescription(redundantCasts.get(i), manager, isOnTheFly);\n    }\n    return descriptions;\n  }","id":74662,"modified_method":"public ProblemDescriptor[] getDescriptions(PsiElement where, InspectionManager manager, boolean isOnTheFly) {\n    List<PsiTypeCastExpression> redundantCasts = RedundantCastUtil.getRedundantCastsInside(where);\n    if (redundantCasts.isEmpty()) return null;\n    List<ProblemDescriptor> descriptions = new ArrayList<ProblemDescriptor>(redundantCasts.size());\n    for (PsiTypeCastExpression redundantCast : redundantCasts) {\n      ProblemDescriptor descriptor = createDescription(redundantCast, manager, isOnTheFly);\n      if (descriptor != null) {\n        descriptions.add(descriptor);\n      }\n    }\n    if (descriptions.isEmpty()) return null;\n    return descriptions.toArray(new ProblemDescriptor[descriptions.size()]);\n  }","commit_id":"51775c31a8e9859d1ffc8d6b8072e3fae85f471b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      if (ReadonlyStatusHandler.getInstance(project)\n        .ensureFilesWritable(PsiUtilBase.getVirtualFile(descriptor.getPsiElement())).hasReadonlyFiles()) return;\n      PsiElement castTypeElement = descriptor.getPsiElement();\n      PsiTypeCastExpression cast = castTypeElement == null ? null : (PsiTypeCastExpression)castTypeElement.getParent();\n      if (cast != null) {\n        removeCast(cast);\n      }\n    }","id":74663,"modified_method":"public void applyFix(@NotNull Project project, @NotNull ProblemDescriptor descriptor) {\n      if (!CodeInsightUtilBase.preparePsiElementForWrite(descriptor.getPsiElement())) return;\n      PsiElement castTypeElement = descriptor.getPsiElement();\n      PsiTypeCastExpression cast = castTypeElement == null ? null : (PsiTypeCastExpression)castTypeElement.getParent();\n      if (cast != null) {\n        removeCast(cast);\n      }\n    }","commit_id":"51775c31a8e9859d1ffc8d6b8072e3fae85f471b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private ProblemDescriptor createDescription(PsiTypeCastExpression cast, InspectionManager manager, boolean onTheFly) {\n    String message = InspectionsBundle.message(\"inspection.redundant.cast.problem.descriptor\",\n                                               \"<code>\" + cast.getOperand().getText() + \"<\/code>\", \"<code>#ref<\/code> #loc\");\n    return manager.createProblemDescriptor(cast.getCastType(), message, myQuickFixAction, ProblemHighlightType.LIKE_UNUSED_SYMBOL, onTheFly);\n  }","id":74664,"modified_method":"private ProblemDescriptor createDescription(@NotNull PsiTypeCastExpression cast, @NotNull InspectionManager manager, boolean onTheFly) {\n    PsiExpression operand = cast.getOperand();\n    PsiTypeElement castType = cast.getCastType();\n    if (operand == null || castType == null) return null;\n    String message = InspectionsBundle.message(\"inspection.redundant.cast.problem.descriptor\",\n                                               \"<code>\" + operand.getText() + \"<\/code>\", \"<code>#ref<\/code> #loc\");\n    return manager.createProblemDescriptor(castType, message, myQuickFixAction, ProblemHighlightType.LIKE_UNUSED_SYMBOL, onTheFly);\n  }","commit_id":"51775c31a8e9859d1ffc8d6b8072e3fae85f471b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPostfixExpression(PsiPostfixExpression expression) {\n      expression.getOperand().accept(this);\n      PsiType type = expression.getType();\n      if(type == null) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil\n          .createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", expression.getText())));\n      }\n      myResult = new PostfixOperationEvaluator(myResult, expression.getOperationSign().getTokenType(), type.getCanonicalText());\n    }","id":74665,"modified_method":"@Override\n    public void visitPostfixExpression(PsiPostfixExpression expression) {\n      if(expression.getType() == null) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n          DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", expression.getText()))\n        );\n      }\n\n      final PsiExpression operandExpression = expression.getOperand();\n      operandExpression.accept(this);\n\n      final Evaluator operandEvaluator = myResult;\n\n      final IElementType operation = expression.getOperationSign().getTokenType();\n      final PsiType operandType = operandExpression.getType();\n      final @Nullable PsiType unboxedOperandType = PsiPrimitiveType.getUnboxedType(operandType);\n\n      Evaluator incrementImpl = createBinaryEvaluator(\n        operandEvaluator, operandType,\n        new LiteralEvaluator(Integer.valueOf(1), \"int\"), PsiType.INT,\n        operation == JavaTokenType.PLUSPLUS ? JavaTokenType.PLUS : JavaTokenType.MINUS,\n        unboxedOperandType!= null? unboxedOperandType : operandType\n      );\n      if (unboxedOperandType != null) {\n        incrementImpl = new BoxingEvaluator(incrementImpl);\n      }\n      myResult = new PostfixOperationEvaluator(operandEvaluator, incrementImpl);\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitDeclarationStatement(PsiDeclarationStatement statement) {\n      List<Evaluator> evaluators = new ArrayList<Evaluator>();\n\n      PsiElement[] declaredElements = statement.getDeclaredElements();\n      for (PsiElement declaredElement : declaredElements) {\n        if (declaredElement instanceof PsiLocalVariable) {\n          if (myCurrentFragmentEvaluator != null) {\n            final PsiLocalVariable localVariable = ((PsiLocalVariable)declaredElement);\n\n            final PsiType lType = localVariable.getType();\n\n            PsiElementFactory elementFactory = JavaPsiFacade.getInstance(localVariable.getProject()).getElementFactory();\n            try {\n              PsiExpression initialValue = elementFactory.createExpressionFromText(PsiTypesUtil.getDefaultValueOfType(lType), null);\n              Object value = JavaConstantExpressionEvaluator.computeConstantExpression(initialValue, true);\n              myCurrentFragmentEvaluator.setInitialValue(localVariable.getName(), value);\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n            catch (EvaluateException e) {\n              throw new EvaluateRuntimeException(e);\n            }\n\n            PsiExpression initializer = localVariable.getInitializer();\n            if (initializer != null) {\n              try {\n                if (!TypeConversionUtil.areTypesAssignmentCompatible(localVariable.getType(), initializer)) {\n                  throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n                    DebuggerBundle.message(\"evaluation.error.incompatible.variable.initializer.type\", localVariable.getName())));\n                }\n                final PsiType rType = initializer.getType();\n                initializer.accept(this);\n                Evaluator rEvaluator = myResult;\n\n                PsiExpression localVarReference = elementFactory.createExpressionFromText(localVariable.getName(), initializer);\n\n                localVarReference.accept(this);\n                Evaluator lEvaluator = myResult;\n\n                Evaluator assignment = new AssignmentEvaluator(lEvaluator, rEvaluator);\n                if (TypeConversionUtil.boxingConversionApplicable(lType, rType)) {\n                  if (lType instanceof PsiPrimitiveType) {\n                    assignment = new UnBoxingEvaluator(assignment);\n                  }\n                  else {\n                    assignment = new BoxingEvaluator(assignment);\n                  }\n                }\n                evaluators.add(assignment);\n              }\n              catch (IncorrectOperationException e) {\n                LOG.error(e);\n              }\n            }\n          }\n          else {\n            throw new EvaluateRuntimeException(new EvaluateException(\n              DebuggerBundle.message(\"evaluation.error.local.variable.declarations.not.supported\"), null));\n          }\n        }\n        else {\n          throw new EvaluateRuntimeException(new EvaluateException(\n            DebuggerBundle.message(\"evaluation.error.unsupported.declaration\", declaredElement.getText()), null));\n        }\n      }\n\n      if(evaluators.size() > 0) {\n        CodeFragmentEvaluator codeFragmentEvaluator = new CodeFragmentEvaluator(myCurrentFragmentEvaluator);\n        codeFragmentEvaluator.setStatements(evaluators.toArray(new Evaluator[0]));\n        myResult = codeFragmentEvaluator;\n      } else {\n        myResult = null;\n      }\n    }","id":74666,"modified_method":"@Override\n    public void visitDeclarationStatement(PsiDeclarationStatement statement) {\n      List<Evaluator> evaluators = new ArrayList<Evaluator>();\n\n      PsiElement[] declaredElements = statement.getDeclaredElements();\n      for (PsiElement declaredElement : declaredElements) {\n        if (declaredElement instanceof PsiLocalVariable) {\n          if (myCurrentFragmentEvaluator != null) {\n            final PsiLocalVariable localVariable = ((PsiLocalVariable)declaredElement);\n\n            final PsiType lType = localVariable.getType();\n\n            PsiElementFactory elementFactory = JavaPsiFacade.getInstance(localVariable.getProject()).getElementFactory();\n            try {\n              PsiExpression initialValue = elementFactory.createExpressionFromText(PsiTypesUtil.getDefaultValueOfType(lType), null);\n              Object value = JavaConstantExpressionEvaluator.computeConstantExpression(initialValue, true);\n              myCurrentFragmentEvaluator.setInitialValue(localVariable.getName(), value);\n            }\n            catch (IncorrectOperationException e) {\n              LOG.error(e);\n            }\n            catch (EvaluateException e) {\n              throw new EvaluateRuntimeException(e);\n            }\n\n            PsiExpression initializer = localVariable.getInitializer();\n            if (initializer != null) {\n              try {\n                if (!TypeConversionUtil.areTypesAssignmentCompatible(localVariable.getType(), initializer)) {\n                  throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n                    DebuggerBundle.message(\"evaluation.error.incompatible.variable.initializer.type\", localVariable.getName())));\n                }\n                final PsiType rType = initializer.getType();\n                initializer.accept(this);\n                Evaluator rEvaluator = myResult;\n\n                PsiExpression localVarReference = elementFactory.createExpressionFromText(localVariable.getName(), initializer);\n\n                localVarReference.accept(this);\n                Evaluator lEvaluator = myResult;\n                rEvaluator = handleAssignmentBoxingAndPrimitiveTypeConversions(localVarReference.getType(), rType, rEvaluator);\n\n                Evaluator assignment = new AssignmentEvaluator(lEvaluator, rEvaluator);\n                evaluators.add(assignment);\n              }\n              catch (IncorrectOperationException e) {\n                LOG.error(e);\n              }\n            }\n          }\n          else {\n            throw new EvaluateRuntimeException(new EvaluateException(\n              DebuggerBundle.message(\"evaluation.error.local.variable.declarations.not.supported\"), null));\n          }\n        }\n        else {\n          throw new EvaluateRuntimeException(new EvaluateException(\n            DebuggerBundle.message(\"evaluation.error.unsupported.declaration\", declaredElement.getText()), null));\n        }\n      }\n\n      if(evaluators.size() > 0) {\n        CodeFragmentEvaluator codeFragmentEvaluator = new CodeFragmentEvaluator(myCurrentFragmentEvaluator);\n        codeFragmentEvaluator.setStatements(evaluators.toArray(new Evaluator[0]));\n        myResult = codeFragmentEvaluator;\n      } else {\n        myResult = null;\n      }\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitArrayInitializerExpression(PsiArrayInitializerExpression expression) {\n      PsiExpression[] initializers = expression.getInitializers();\n      Evaluator[] evaluators = new Evaluator[initializers.length];\n      for (int idx = 0; idx < initializers.length; idx++) {\n        PsiExpression initializer = initializers[idx];\n        initializer.accept(this);\n        if (myResult != null) {\n          evaluators[idx] = myResult;\n        }\n        else {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil\n            .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", initializer.getText())));\n        }\n      }\n      myResult = new ArrayInitializerEvaluator(evaluators);\n    }","id":74667,"modified_method":"@Override\n    public void visitArrayInitializerExpression(PsiArrayInitializerExpression expression) {\n      PsiExpression[] initializers = expression.getInitializers();\n      Evaluator[] evaluators = new Evaluator[initializers.length];\n      for (int idx = 0; idx < initializers.length; idx++) {\n        PsiExpression initializer = initializers[idx];\n        initializer.accept(this);\n        if (myResult != null) {\n          evaluators[idx] = handleUnaryNumericPromotion(initializer.getType(), myResult);\n        }\n        else {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil\n            .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", initializer.getText())));\n        }\n      }\n      myResult = new ArrayInitializerEvaluator(evaluators);\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitNewExpression(PsiNewExpression expression) {\n      PsiType expressionPsiType = expression.getType();\n      if (expressionPsiType instanceof PsiArrayType) {\n        Evaluator dimensionEvaluator = null;\n        PsiExpression[] dimensions = expression.getArrayDimensions();\n        if (dimensions.length == 1){\n          PsiExpression dimensionExpression = dimensions[0];\n          dimensionExpression.accept(this);\n          if (myResult != null) {\n            dimensionEvaluator = myResult;\n          }\n          else {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n              DebuggerBundle.message(\"evaluation.error.invalid.array.dimension.expression\", dimensionExpression.getText())));\n          }\n        }\n        else if (dimensions.length > 1){\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.multi.dimensional.arrays.creation.not.supported\"))\n          );\n        }\n\n        Evaluator initializerEvaluator = null;\n        PsiArrayInitializerExpression arrayInitializer = expression.getArrayInitializer();\n        if (arrayInitializer != null) {\n          if (dimensionEvaluator != null) { // initializer already exists\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil\n              .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n          }\n          arrayInitializer.accept(this);\n          if (myResult != null) {\n            initializerEvaluator = myResult;\n          }\n          else {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil\n              .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", arrayInitializer.getText())));\n          }\n          /*\n          PsiExpression[] initializers = arrayInitializer.getInitializers();\n          initializerEvaluators = new Evaluator[initializers.length];\n          for (int idx = 0; idx < initializers.length; idx++) {\n            PsiExpression initializer = initializers[idx];\n            initializer.accept(this);\n            if (myResult instanceof Evaluator) {\n              initializerEvaluators[idx] = myResult;\n            }\n            else {\n              throw new EvaluateException(\"Invalid expression for array initializer: \" + initializer.getText(), true);\n            }\n          }\n          */\n        }\n        if (dimensionEvaluator == null && initializerEvaluator == null) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil\n            .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n        }\n        myResult = new NewArrayInstanceEvaluator(\n          new TypeEvaluator(JVMNameUtil.getJVMQualifiedName(expressionPsiType)),\n          dimensionEvaluator,\n          initializerEvaluator\n        );\n      }\n      else { // must be a class ref\n        LOG.assertTrue(expressionPsiType instanceof PsiClassType);\n        PsiClass aClass = ((PsiClassType)expressionPsiType).resolve();\n        if(aClass instanceof PsiAnonymousClass) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.anonymous.class.evaluation.not.supported\"))\n          );\n        }\n        PsiExpressionList argumentList = expression.getArgumentList();\n        if (argumentList == null) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil\n            .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n        }\n        PsiExpression[] argExpressions = argumentList.getExpressions();\n        PsiMethod constructor = expression.resolveConstructor();\n        if (constructor == null && argExpressions.length > 0) {\n          throw new EvaluateRuntimeException(new EvaluateException(\n            DebuggerBundle.message(\"evaluation.error.cannot.resolve.constructor\", expression.getText()), null));\n        }\n        Evaluator[] argumentEvaluators = new Evaluator[argExpressions.length];\n        // evaluate arguments\n        for (int idx = 0; idx < argExpressions.length; idx++) {\n          PsiExpression argExpression = argExpressions[idx];\n          argExpression.accept(this);\n          if (myResult != null) {\n            argumentEvaluators[idx] = myResult;\n          }\n          else {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil\n              .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", argExpression.getText())));\n          }\n        }\n        //noinspection HardCodedStringLiteral\n        JVMName signature = (constructor != null)? JVMNameUtil.getJVMSignature(constructor) : JVMNameUtil.getJVMRawText(\"()V\");\n        myResult = new NewClassInstanceEvaluator(\n          new TypeEvaluator(JVMNameUtil.getJVMQualifiedName(expressionPsiType)),\n          signature,\n          argumentEvaluators\n        );\n      }\n    }","id":74668,"modified_method":"@Override\n    public void visitNewExpression(PsiNewExpression expression) {\n      PsiType expressionPsiType = expression.getType();\n      if (expressionPsiType instanceof PsiArrayType) {\n        Evaluator dimensionEvaluator = null;\n        PsiExpression[] dimensions = expression.getArrayDimensions();\n        if (dimensions.length == 1){\n          PsiExpression dimensionExpression = dimensions[0];\n          dimensionExpression.accept(this);\n          if (myResult != null) {\n            dimensionEvaluator = handleUnaryNumericPromotion(dimensionExpression.getType(), myResult);\n          }\n          else {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n              DebuggerBundle.message(\"evaluation.error.invalid.array.dimension.expression\", dimensionExpression.getText())));\n          }\n        }\n        else if (dimensions.length > 1){\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.multi.dimensional.arrays.creation.not.supported\"))\n          );\n        }\n\n        Evaluator initializerEvaluator = null;\n        PsiArrayInitializerExpression arrayInitializer = expression.getArrayInitializer();\n        if (arrayInitializer != null) {\n          if (dimensionEvaluator != null) { // initializer already exists\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil\n              .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n          }\n          arrayInitializer.accept(this);\n          if (myResult != null) {\n            initializerEvaluator = handleUnaryNumericPromotion(arrayInitializer.getType(), myResult);\n          }\n          else {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil\n              .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", arrayInitializer.getText())));\n          }\n          /*\n          PsiExpression[] initializers = arrayInitializer.getInitializers();\n          initializerEvaluators = new Evaluator[initializers.length];\n          for (int idx = 0; idx < initializers.length; idx++) {\n            PsiExpression initializer = initializers[idx];\n            initializer.accept(this);\n            if (myResult instanceof Evaluator) {\n              initializerEvaluators[idx] = myResult;\n            }\n            else {\n              throw new EvaluateException(\"Invalid expression for array initializer: \" + initializer.getText(), true);\n            }\n          }\n          */\n        }\n        if (dimensionEvaluator == null && initializerEvaluator == null) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil\n            .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n        }\n        myResult = new NewArrayInstanceEvaluator(\n          new TypeEvaluator(JVMNameUtil.getJVMQualifiedName(expressionPsiType)),\n          dimensionEvaluator,\n          initializerEvaluator\n        );\n      }\n      else { // must be a class ref\n        LOG.assertTrue(expressionPsiType instanceof PsiClassType);\n        PsiClass aClass = ((PsiClassType)expressionPsiType).resolve();\n        if(aClass instanceof PsiAnonymousClass) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(\n            DebuggerBundle.message(\"evaluation.error.anonymous.class.evaluation.not.supported\"))\n          );\n        }\n        PsiExpressionList argumentList = expression.getArgumentList();\n        if (argumentList == null) {\n          throw new EvaluateRuntimeException(EvaluateExceptionUtil\n            .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n        }\n        PsiExpression[] argExpressions = argumentList.getExpressions();\n        PsiMethod constructor = expression.resolveConstructor();\n        if (constructor == null && argExpressions.length > 0) {\n          throw new EvaluateRuntimeException(new EvaluateException(\n            DebuggerBundle.message(\"evaluation.error.cannot.resolve.constructor\", expression.getText()), null));\n        }\n        Evaluator[] argumentEvaluators = new Evaluator[argExpressions.length];\n        // evaluate arguments\n        for (int idx = 0; idx < argExpressions.length; idx++) {\n          PsiExpression argExpression = argExpressions[idx];\n          argExpression.accept(this);\n          if (myResult != null) {\n            argumentEvaluators[idx] = myResult;\n          }\n          else {\n            throw new EvaluateRuntimeException(EvaluateExceptionUtil\n              .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", argExpression.getText())));\n          }\n        }\n        //noinspection HardCodedStringLiteral\n        JVMName signature = (constructor != null)? JVMNameUtil.getJVMSignature(constructor) : JVMNameUtil.getJVMRawText(\"()V\");\n        myResult = new NewClassInstanceEvaluator(\n          new TypeEvaluator(JVMNameUtil.getJVMQualifiedName(expressionPsiType)),\n          signature,\n          argumentEvaluators\n        );\n      }\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitBinaryExpression(PsiBinaryExpression expression) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"visitBinaryExpression \" + expression);\n      }\n      final PsiExpression lOperand = expression.getLOperand();\n      lOperand.accept(this);\n      Evaluator lResult = myResult;\n      final PsiExpression rOperand = expression.getROperand();\n      if(rOperand == null) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil\n          .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n      }\n      rOperand.accept(this);\n      IElementType opType = expression.getOperationSign().getTokenType();\n      PsiType type = expression.getType();\n      if (type == null) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil\n          .createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", expression.getText())));\n      }\n      // handle unboxing if neccesary\n      final PsiType lType = lOperand.getType();\n      final PsiType rType = rOperand.getType();\n      if (TypeConversionUtil.boxingConversionApplicable(lType, rType)) {\n        if (lType instanceof PsiPrimitiveType) {\n          myResult = new UnBoxingEvaluator(myResult);\n        }\n        else if (rType instanceof PsiPrimitiveType) {\n          lResult = new UnBoxingEvaluator(lResult);\n        }\n      }\n\n      myResult = new BinaryExpressionEvaluator(lResult, myResult, opType, type.getCanonicalText());\n    }","id":74669,"modified_method":"@Override\n    public void visitBinaryExpression(PsiBinaryExpression expression) {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"visitBinaryExpression \" + expression);\n      }\n      final PsiExpression lOperand = expression.getLOperand();\n      lOperand.accept(this);\n      Evaluator lResult = myResult;\n      final PsiExpression rOperand = expression.getROperand();\n      if(rOperand == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText()))\n        );\n      }\n      rOperand.accept(this);\n      Evaluator rResult = myResult;\n      IElementType opType = expression.getOperationSign().getTokenType();\n      PsiType expressionExpectedType = expression.getType();\n      if (expressionExpectedType == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", expression.getText()))\n        );\n      }\n      myResult = createBinaryEvaluator(lResult, lOperand.getType(), rResult, rOperand.getType(), opType, expressionExpectedType);\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitArrayAccessExpression(PsiArrayAccessExpression expression) {\n      final PsiExpression indexExpression = expression.getIndexExpression();\n      if(indexExpression == null) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil\n          .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n      }\n      indexExpression.accept(this);\n      Evaluator indexEvaluator = myResult;\n      expression.getArrayExpression().accept(this);\n      Evaluator arrayEvaluator = myResult;\n      myResult = new ArrayAccessEvaluator(arrayEvaluator, indexEvaluator);\n    }","id":74670,"modified_method":"@Override\n    public void visitArrayAccessExpression(PsiArrayAccessExpression expression) {\n      final PsiExpression indexExpression = expression.getIndexExpression();\n      if(indexExpression == null) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil\n          .createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText())));\n      }\n      indexExpression.accept(this);\n      final Evaluator indexEvaluator = handleUnaryNumericPromotion(indexExpression.getType(), myResult); \n\n      expression.getArrayExpression().accept(this);\n      Evaluator arrayEvaluator = myResult;\n      myResult = new ArrayAccessEvaluator(arrayEvaluator, indexEvaluator);\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitPrefixExpression(final PsiPrefixExpression expression) {\n      final PsiType expressionType = expression.getType();\n      if(expressionType == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", expression.getText()))\n        );\n      }\n\n      final PsiExpression operandExpression = expression.getOperand();\n      if (operandExpression == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.operand\", expression.getText()))\n        );\n      }\n      \n      final PsiType operandExpressionType = operandExpression.getType();\n\n      operandExpression.accept(this);\n      final Evaluator operand = myResult;\n\n      final IElementType opType = expression.getOperationSign().getTokenType();\n\n      if(opType == JavaTokenType.PLUSPLUS || opType == JavaTokenType.MINUSMINUS) {\n        final boolean isPlus = opType == JavaTokenType.PLUSPLUS;\n\n        try {\n          PsiElementFactory elementFactory = JavaPsiFacade.getInstance(expression.getProject()).getElementFactory();\n          PsiExpression one = elementFactory.createExpressionFromText(\"1\", null);\n          one.accept(this);\n          // handle unboxing issues\n          Evaluator left = operand;\n          if (!(operandExpressionType instanceof PsiPrimitiveType)) {\n            left = new UnBoxingEvaluator(left);\n          }\n\n          PsiType expected = expressionType;\n          final PsiPrimitiveType unboxedExpectedType = PsiPrimitiveType.getUnboxedType(expected);\n          if (unboxedExpectedType != null) {\n            expected = unboxedExpectedType;\n          }\n          final BinaryExpressionEvaluator rightEval = new BinaryExpressionEvaluator(\n            left, myResult, isPlus ? JavaTokenType.PLUS : JavaTokenType.MINUS, expected.getCanonicalText()\n          );\n          myResult = new AssignmentEvaluator(\n            operand, unboxedExpectedType != null? new BoxingEvaluator(rightEval) : rightEval\n          );\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n      else {\n        PsiType expected = expressionType;\n        final PsiPrimitiveType unboxedExpectedType = PsiPrimitiveType.getUnboxedType(expected);\n        if (unboxedExpectedType != null) {\n          expected = unboxedExpectedType;\n        }\n        final UnaryExpressionEvaluator unaryEvaluator =\n          new UnaryExpressionEvaluator(opType, expected.getCanonicalText(), new UnBoxingEvaluator(operand),\n                                       expression.getOperationSign().getText());\n        myResult = unboxedExpectedType != null? new BoxingEvaluator(unaryEvaluator) : unaryEvaluator;\n      }\n    }","id":74671,"modified_method":"@Override\n    public void visitPrefixExpression(final PsiPrefixExpression expression) {\n      final PsiType expressionType = expression.getType();\n      if(expressionType == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", expression.getText()))\n        );\n      }\n\n      final PsiExpression operandExpression = expression.getOperand();\n      if (operandExpression == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.operand\", expression.getText()))\n        );\n      }\n      \n      operandExpression.accept(this);\n      Evaluator operandEvaluator = myResult;\n\n      // handle unboxing issues\n      final PsiType operandType = operandExpression.getType();\n      @Nullable\n      final PsiType unboxedOperandType = PsiPrimitiveType.getUnboxedType(operandType);\n\n      final IElementType operation = expression.getOperationSign().getTokenType();\n\n      if(operation == JavaTokenType.PLUSPLUS || operation == JavaTokenType.MINUSMINUS) {\n        try {\n          final BinaryExpressionEvaluator rightEval = createBinaryEvaluator(\n            operandEvaluator, operandType,\n            new LiteralEvaluator(Integer.valueOf(1), \"int\"), PsiType.INT,\n            operation == JavaTokenType.PLUSPLUS ? JavaTokenType.PLUS : JavaTokenType.MINUS,\n            unboxedOperandType!= null? unboxedOperandType : operandType\n          );\n          myResult = new AssignmentEvaluator(operandEvaluator, unboxedOperandType != null? new BoxingEvaluator(rightEval) : rightEval);\n        }\n        catch (IncorrectOperationException e) {\n          LOG.error(e);\n        }\n      }\n      else {\n        if (JavaTokenType.PLUS.equals(operation) || JavaTokenType.MINUS.equals(operation)|| JavaTokenType.TILDE.equals(operation)) {\n          operandEvaluator = handleUnaryNumericPromotion(operandType, operandEvaluator);\n        }\n        else {\n          if (unboxedOperandType != null) {\n            operandEvaluator = new UnBoxingEvaluator(operandEvaluator);\n          }\n        }\n        myResult = new UnaryExpressionEvaluator(operation, expressionType.getCanonicalText(), operandEvaluator, expression.getOperationSign().getText());\n      }\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n      final PsiExpression rExpression = expression.getRExpression();\n      if(rExpression == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText()))\n        );\n      }\n\n      rExpression.accept(this);\n      Evaluator rEvaluator = myResult;\n\n      if(expression.getOperationSign().getTokenType() != JavaTokenType.EQ) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.operation.not.supported\", expression.getOperationSign().getText()))\n        );\n      }\n\n      final PsiExpression lExpression = expression.getLExpression();\n\n      final PsiType lType = lExpression.getType();\n      if(lType == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", lExpression.getText()))\n        );\n      }\n\n      if(!TypeConversionUtil.areTypesAssignmentCompatible(lType, rExpression)) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.incompatible.types\", expression.getOperationSign().getText())));\n      }\n      lExpression.accept(this);\n      Evaluator lEvaluator = myResult;\n\n      if (TypeConversionUtil.boxingConversionApplicable(lType, rExpression.getType())) {\n        rEvaluator = (lType instanceof PsiPrimitiveType)? new UnBoxingEvaluator(rEvaluator) : new BoxingEvaluator(rEvaluator);\n      }\n      myResult = new AssignmentEvaluator(lEvaluator, rEvaluator);\n    }","id":74672,"modified_method":"@Override\n    public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n      final PsiExpression rExpression = expression.getRExpression();\n      if(rExpression == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.invalid.expression\", expression.getText()))\n        );\n      }\n\n      rExpression.accept(this);\n      Evaluator rEvaluator = myResult;\n\n      if(expression.getOperationSign().getTokenType() != JavaTokenType.EQ) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.operation.not.supported\", expression.getOperationSign().getText()))\n        );\n      }\n\n      final PsiExpression lExpression = expression.getLExpression();\n\n      final PsiType lType = lExpression.getType();\n      if(lType == null) {\n        throw new EvaluateRuntimeException(\n          EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.unknown.expression.type\", lExpression.getText()))\n        );\n      }\n\n      if(!TypeConversionUtil.areTypesAssignmentCompatible(lType, rExpression)) {\n        throw new EvaluateRuntimeException(EvaluateExceptionUtil.createEvaluateException(DebuggerBundle.message(\"evaluation.error.incompatible.types\", expression.getOperationSign().getText())));\n      }\n      lExpression.accept(this);\n      Evaluator lEvaluator = myResult;\n\n      rEvaluator = handleAssignmentBoxingAndPrimitiveTypeConversions(lType, rExpression.getType(), rEvaluator);\n      \n      myResult = new AssignmentEvaluator(lEvaluator, rEvaluator);\n    }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    final Object value = myOperandEvaluator.evaluate(context);\n    myModifier = myOperandEvaluator.getModifier();\n    IElementType opType = myOpType == TokenTypeEx.PLUSPLUS ? TokenTypeEx.PLUS : TokenTypeEx.MINUS;\n    Object operationResult = BinaryExpressionEvaluator.evaluateOperation((Value)value, opType, myRightEvaluator, myExpectedType, context);\n    AssignmentEvaluator.assign(myModifier, operationResult, context);\n    return value;\n  }","id":74673,"modified_method":"public Object evaluate(EvaluationContextImpl context) throws EvaluateException {\n    final Object value = myOperandEvaluator.evaluate(context);\n    myModifier = myOperandEvaluator.getModifier();\n    Object operationResult = myIncrementImpl.evaluate(context);\n    AssignmentEvaluator.assign(myModifier, operationResult, context);\n    return value;\n  }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PostfixOperationEvaluator(Evaluator operandEvaluator, IElementType opType, String expectedType) {\n    myOperandEvaluator = operandEvaluator;\n    myOpType = opType;\n    myExpectedType = expectedType;\n  }","id":74674,"modified_method":"public PostfixOperationEvaluator(Evaluator operandEvaluator, Evaluator incrementImpl) {\n    myOperandEvaluator = operandEvaluator;\n    myIncrementImpl = incrementImpl;\n  }","commit_id":"27d8200bb61c25f73b5c474da459ecb263856dd2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static GrExpression stripParenthesis(GrExpression operand) {\n    while (operand instanceof GrParenthesizedExpression) {\n      operand = ((GrParenthesizedExpression) operand).getOperand();\n    }\n    return operand;\n  }","id":74675,"modified_method":"@NotNull\n  private static GrExpression stripParenthesis(GrExpression operand) {\n    while (operand instanceof GrParenthesizedExpression) {\n      GrExpression innerExpression = ((GrParenthesizedExpression)operand).getOperand();\n      if (innerExpression == null) {\n        break;\n      }\n      operand = innerExpression;\n    }\n    return operand;\n  }","commit_id":"2dd7d094673b4f2cb5df6fe2f02e5363ca70903a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  protected void processIntention(@NotNull PsiElement element, Project project, Editor editor) throws IncorrectOperationException {\n    PsiElement parent = element.getParent();\n\n    if (!\"if\".equals(element.getText()) || !(parent instanceof GrIfStatement)) {\n      throw new IncorrectOperationException(\"Not invoked on an if\");\n    }\n    GrIfStatement parentIf = (GrIfStatement)parent;\n    GroovyPsiElementFactory groovyPsiElementFactory = GroovyPsiElementFactory.getInstance(project);\n\n    GrStatement thenBranch = parentIf.getThenBranch();\n    GrStatement elseBranch = parentIf.getElseBranch();\n\n    GrExpression condition = parentIf.getCondition();\n    if (condition == null) {\n      throw new IncorrectOperationException(\"Invoked on an if with empty condition\");\n    }\n\n    GrExpression negatedCondition = null;\n    if (condition instanceof GrUnaryExpression) {\n      GrUnaryExpression unaryCondition = (GrUnaryExpression)condition;\n      if (\"!\".equals(unaryCondition.getOperationToken().getText())) {\n        negatedCondition = stripParenthesis(unaryCondition.getOperand());\n      }\n    }\n\n    if (negatedCondition==null) {\n      // Now check whether this is a simple expression\n      condition = stripParenthesis(condition);\n      String negatedExpressionText;\n      if (condition instanceof GrCallExpression || condition instanceof GrReferenceExpression) {\n        negatedExpressionText = \"!\" + condition.getText();\n      } else {\n        negatedExpressionText = \"!(\" + condition.getText() + \")\";\n      }\n      negatedCondition = groovyPsiElementFactory.createExpressionFromText(negatedExpressionText, parentIf);\n    }\n\n    GrIfStatement newIf = (GrIfStatement)groovyPsiElementFactory.createStatementFromText(\n      \"if (\" + negatedCondition.getText() + \") \" +\n      (elseBranch != null ? elseBranch.getText() : \"{}\") + \" else \" +\n      (thenBranch != null ? thenBranch.getText() : \"{}\"), parentIf.getContext()\n    );\n\n    parentIf.replace(newIf);\n  }","id":74676,"modified_method":"@Override\n  protected void processIntention(@NotNull PsiElement element, Project project, Editor editor) throws IncorrectOperationException {\n    PsiElement parent = element.getParent();\n\n    if (!\"if\".equals(element.getText()) || !(parent instanceof GrIfStatement)) {\n      throw new IncorrectOperationException(\"Not invoked on an if\");\n    }\n    GrIfStatement parentIf = (GrIfStatement)parent;\n    GroovyPsiElementFactory groovyPsiElementFactory = GroovyPsiElementFactory.getInstance(project);\n\n\n    GrExpression condition = parentIf.getCondition();\n    if (condition == null) {\n      throw new IncorrectOperationException(\"Invoked on an if with empty condition\");\n    }\n\n    GrExpression negatedCondition = null;\n    if (condition instanceof GrUnaryExpression) {\n      GrUnaryExpression unaryCondition = (GrUnaryExpression)condition;\n      if (\"!\".equals(unaryCondition.getOperationToken().getText())) {\n        negatedCondition = stripParenthesis(unaryCondition.getOperand());\n      }\n    }\n\n    if (negatedCondition == null) {\n      // Now check whether this is a simple expression\n      condition = stripParenthesis(condition);\n      String negatedExpressionText;\n      if (condition instanceof GrCallExpression || condition instanceof GrReferenceExpression) {\n        negatedExpressionText = \"!\" + condition.getText();\n      }\n      else {\n        negatedExpressionText = \"!(\" + condition.getText() + \")\";\n      }\n      negatedCondition = groovyPsiElementFactory.createExpressionFromText(negatedExpressionText, parentIf);\n    }\n\n\n    GrStatement thenBranch = parentIf.getThenBranch();\n    GrStatement elseBranch = parentIf.getElseBranch();\n    String newIfText = \"if (\" + negatedCondition.getText() + \") \" + (elseBranch != null ? elseBranch.getText() : \"{}\");\n\n    boolean isThenEmpty = thenBranch == null || (thenBranch instanceof GrBlockStatement) && ((GrBlockStatement)thenBranch).getBlock().getStatements().length == 0;\n    if (!isThenEmpty) {\n      newIfText += \" else \" + thenBranch.getText();\n    }\n\n\n    GrIfStatement newIf = (GrIfStatement)groovyPsiElementFactory.createStatementFromText(newIfText, parentIf.getContext());\n\n    parentIf.replace(newIf);\n  }","commit_id":"2dd7d094673b4f2cb5df6fe2f02e5363ca70903a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!myPrefixExpression.isValid()) return false;\n\n    PsiElement parent = myPrefixExpression.getParent();\n    if (parent instanceof PsiInstanceOfExpression && ((PsiInstanceOfExpression)parent).getOperand() == myPrefixExpression) {\n      return true;\n    }\n    if (!(parent instanceof PsiBinaryExpression)) return false;\n    PsiBinaryExpression binaryExpression = (PsiBinaryExpression)parent;\n    return binaryExpression.getLOperand() == myPrefixExpression && TypeConversionUtil.isBooleanType(binaryExpression.getType());\n  }","id":74677,"modified_method":"@Override\n  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {\n    if (!myPrefixExpression.isValid() || myPrefixExpression.getOperand() == null) return false;\n\n    PsiElement parent = myPrefixExpression.getParent();\n    if (parent instanceof PsiInstanceOfExpression && ((PsiInstanceOfExpression)parent).getOperand() == myPrefixExpression) {\n      return true;\n    }\n    if (!(parent instanceof PsiBinaryExpression)) return false;\n    PsiBinaryExpression binaryExpression = (PsiBinaryExpression)parent;\n    return binaryExpression.getLOperand() == myPrefixExpression && TypeConversionUtil.isBooleanType(binaryExpression.getType());\n  }","commit_id":"be8accbcf0847d81db5b0440b1a0178ccb1d9291","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @NotNull\n  public String getText() {\n    String text = myPrefixExpression.getOperand().getText();\n    text += \" \";\n    PsiElement parent = myPrefixExpression.getParent();\n    String operation = parent instanceof PsiInstanceOfExpression\n                       ? PsiKeyword.INSTANCEOF\n                       : ((PsiBinaryExpression)parent).getOperationSign().getText();\n    text += operation + \" \";\n\n    String rop;\n    if (parent instanceof PsiInstanceOfExpression) {\n      final PsiTypeElement type = ((PsiInstanceOfExpression)parent).getCheckType();\n      rop = type == null ? \"\" : type.getText();\n    }\n    else {\n      final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();\n      rop = rOperand == null ? \"\" : rOperand.getText();\n    }\n\n    text += rop;\n    return QuickFixBundle.message(\"negation.broader.scope.text\", text);\n  }","id":74678,"modified_method":"@Override\n  @NotNull\n  public String getText() {\n    PsiExpression operand = myPrefixExpression.getOperand();\n    String text = operand == null ? \"\" : operand.getText() + \" \";\n    PsiElement parent = myPrefixExpression.getParent();\n\n    String rop;\n    if (parent instanceof PsiInstanceOfExpression) {\n      text += PsiKeyword.INSTANCEOF + \" \";\n      final PsiTypeElement type = ((PsiInstanceOfExpression)parent).getCheckType();\n      rop = type == null ? \"\" : type.getText();\n    }\n    else if (parent instanceof PsiBinaryExpression) {\n      text += ((PsiBinaryExpression)parent).getOperationSign().getText() + \" \";\n      final PsiExpression rOperand = ((PsiBinaryExpression)parent).getROperand();\n      rop = rOperand == null ? \"\" : rOperand.getText();\n    }\n    else {\n      rop = \"<expr>\";\n    }\n\n    text += rop;\n    return QuickFixBundle.message(\"negation.broader.scope.text\", text);\n  }","commit_id":"be8accbcf0847d81db5b0440b1a0178ccb1d9291","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    if (!FileModificationService.getInstance().preparePsiElementForWrite(myPrefixExpression)) return;\n    PsiExpression operand = myPrefixExpression.getOperand();\n    PsiElement unnegated = myPrefixExpression.replace(operand);\n    PsiElement parent = unnegated.getParent();\n    PsiElementFactory factory = JavaPsiFacade.getInstance(file.getProject()).getElementFactory();\n\n    PsiPrefixExpression negated = (PsiPrefixExpression)factory.createExpressionFromText(\"!(xxx)\", parent);\n    PsiParenthesizedExpression parentheses = (PsiParenthesizedExpression)negated.getOperand();\n    parentheses.getExpression().replace(parent.copy());\n    parent.replace(negated);\n  }","id":74679,"modified_method":"@Override\n  public void invoke(@NotNull Project project, Editor editor, PsiFile file) throws IncorrectOperationException {\n    if (!isAvailable(project, editor, file) || !FileModificationService.getInstance().preparePsiElementForWrite(myPrefixExpression)) return;\n    PsiExpression operand = myPrefixExpression.getOperand();\n    PsiElement unnegated = myPrefixExpression.replace(operand);\n    PsiElement parent = unnegated.getParent();\n    PsiElementFactory factory = JavaPsiFacade.getInstance(file.getProject()).getElementFactory();\n\n    PsiPrefixExpression negated = (PsiPrefixExpression)factory.createExpressionFromText(\"!(xxx)\", parent);\n    PsiParenthesizedExpression parentheses = (PsiParenthesizedExpression)negated.getOperand();\n    parentheses.getExpression().replace(parent.copy());\n    parent.replace(negated);\n  }","commit_id":"be8accbcf0847d81db5b0440b1a0178ccb1d9291","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    myNegate = !myNegate;\n    expression.getOperand().accept(this);\n    myNegate = !myNegate;\n  }","id":74680,"modified_method":"@Override\n  public void visitUnaryExpression(GrUnaryExpression expression) {\n    final GrExpression operand = expression.getOperand();\n    if (operand != null) {\n      myNegate = !myNegate;\n      operand.accept(this);\n      myNegate = !myNegate;\n    }\n  }","commit_id":"08096371f38462b03f3e6dcb83f422ec62099634","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isGoodExpression(@NotNull PsiExpression e,\n                                          @NotNull AllowedValues allowedValues,\n                                          @NotNull PsiElement scope,\n                                          @NotNull PsiManager manager,\n                                          @Nullable Set<PsiExpression> visited) {\n    PsiExpression expression = PsiUtil.deparenthesizeExpression(e);\n    if (expression == null) return true;\n    if (visited == null) visited = new THashSet<>();\n    if (!visited.add(expression)) return true;\n    if (expression instanceof PsiConditionalExpression) {\n      PsiExpression thenExpression = ((PsiConditionalExpression)expression).getThenExpression();\n      boolean thenAllowed = thenExpression == null || isAllowed(scope, thenExpression, allowedValues, manager, visited);\n      if (!thenAllowed) return false;\n      PsiExpression elseExpression = ((PsiConditionalExpression)expression).getElseExpression();\n      return elseExpression == null || isAllowed(scope, elseExpression, allowedValues, manager, visited);\n    }\n\n    if (isOneOf(expression, allowedValues, manager)) return true;\n\n    if (allowedValues.canBeOred) {\n      PsiExpression zero = getLiteralExpression(expression, manager, \"0\");\n      if (same(expression, zero, manager)) return true;\n      PsiExpression mOne = getLiteralExpression(expression, manager, \"-1\");\n      if (same(expression, mOne, manager)) return true;\n      if (expression instanceof PsiPolyadicExpression) {\n        IElementType tokenType = ((PsiPolyadicExpression)expression).getOperationTokenType();\n        if (JavaTokenType.OR.equals(tokenType) || JavaTokenType.AND.equals(tokenType) || JavaTokenType.PLUS.equals(tokenType)) {\n          for (PsiExpression operand : ((PsiPolyadicExpression)expression).getOperands()) {\n            if (!isAllowed(scope, operand, allowedValues, manager, visited)) return false;\n          }\n          return true;\n        }\n      }\n      if (expression instanceof PsiPrefixExpression &&\n          JavaTokenType.TILDE.equals(((PsiPrefixExpression)expression).getOperationTokenType())) {\n        PsiExpression operand = ((PsiPrefixExpression)expression).getOperand();\n        return operand == null || isAllowed(scope, operand, allowedValues, manager, visited);\n      }\n    }\n\n    PsiElement resolved = null;\n    if (expression instanceof PsiReference) {\n      resolved = ((PsiReference)expression).resolve();\n    }\n    else if (expression instanceof PsiCallExpression) {\n      resolved = ((PsiCallExpression)expression).resolveMethod();\n    }\n\n    AllowedValues allowedForRef;\n    if (resolved instanceof PsiModifierListOwner &&\n        (allowedForRef = getAllowedValues((PsiModifierListOwner)resolved, getType((PsiModifierListOwner)resolved), null)) != null &&\n        allowedForRef.isSubsetOf(allowedValues, manager)) return true;\n\n    return PsiType.NULL.equals(expression.getType());\n  }","id":74681,"modified_method":"private static boolean isGoodExpression(@NotNull PsiExpression e,\n                                          @NotNull AllowedValues allowedValues,\n                                          @NotNull PsiElement scope,\n                                          @NotNull PsiManager manager,\n                                          @Nullable Set<PsiExpression> visited) {\n    PsiExpression expression = PsiUtil.deparenthesizeExpression(e);\n    if (expression == null) return true;\n    if (visited == null) visited = new THashSet<>();\n    if (!visited.add(expression)) return true;\n    if (expression instanceof PsiConditionalExpression) {\n      PsiExpression thenExpression = ((PsiConditionalExpression)expression).getThenExpression();\n      boolean thenAllowed = thenExpression == null || isAllowed(scope, thenExpression, allowedValues, manager, visited);\n      if (!thenAllowed) return false;\n      PsiExpression elseExpression = ((PsiConditionalExpression)expression).getElseExpression();\n      return elseExpression == null || isAllowed(scope, elseExpression, allowedValues, manager, visited);\n    }\n\n    if (isOneOf(expression, allowedValues, manager)) return true;\n\n    if (allowedValues.canBeOred) {\n      PsiExpression zero = getLiteralExpression(expression, manager, \"0\");\n      if (same(expression, zero, manager)) return true;\n      PsiExpression minusOne = getLiteralExpression(expression, manager, \"-1\");\n      if (same(expression, minusOne, manager)) return true;\n      if (expression instanceof PsiPolyadicExpression) {\n        IElementType tokenType = ((PsiPolyadicExpression)expression).getOperationTokenType();\n        if (JavaTokenType.OR.equals(tokenType) || JavaTokenType.AND.equals(tokenType) || JavaTokenType.PLUS.equals(tokenType)) {\n          for (PsiExpression operand : ((PsiPolyadicExpression)expression).getOperands()) {\n            if (!isAllowed(scope, operand, allowedValues, manager, visited)) return false;\n          }\n          return true;\n        }\n      }\n      if (expression instanceof PsiPrefixExpression &&\n          JavaTokenType.TILDE.equals(((PsiPrefixExpression)expression).getOperationTokenType())) {\n        PsiExpression operand = ((PsiPrefixExpression)expression).getOperand();\n        return operand == null || isAllowed(scope, operand, allowedValues, manager, visited);\n      }\n    }\n\n    PsiElement resolved = null;\n    if (expression instanceof PsiReference) {\n      resolved = ((PsiReference)expression).resolve();\n    }\n    else if (expression instanceof PsiCallExpression) {\n      resolved = ((PsiCallExpression)expression).resolveMethod();\n    }\n\n    AllowedValues allowedForRef;\n    if (resolved instanceof PsiModifierListOwner &&\n        (allowedForRef = getAllowedValues((PsiModifierListOwner)resolved, getType((PsiModifierListOwner)resolved), null)) != null &&\n        allowedForRef.isSubsetOf(allowedValues, manager)) return true;\n\n    return PsiType.NULL.equals(expression.getType());\n  }","commit_id":"e99f80a35d99d43525ac65f3c84785553773517c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean same(PsiElement e1, PsiElement e2, @NotNull PsiManager manager) {\n    if (e1 instanceof PsiLiteralExpression && e2 instanceof PsiLiteralExpression) {\n      return Comparing.equal(((PsiLiteralExpression)e1).getValue(), ((PsiLiteralExpression)e2).getValue());\n    }\n    if (e1 instanceof PsiPrefixExpression && e2 instanceof PsiPrefixExpression && ((PsiPrefixExpression)e1).getOperationTokenType() == ((PsiPrefixExpression)e2).getOperationTokenType()) {\n      return same(((PsiPrefixExpression)e1).getOperand(), ((PsiPrefixExpression)e2).getOperand(), manager);\n    }\n    if (e1 instanceof PsiReference && e2 instanceof PsiReference) {\n      e1 = ((PsiReference)e1).resolve();\n      e2 = ((PsiReference)e2).resolve();\n    }\n    return manager.areElementsEquivalent(e2, e1);\n  }","id":74682,"modified_method":"private static boolean same(@NotNull PsiElement e1, @NotNull PsiElement e2, @NotNull PsiManager manager) {\n    if (e1 instanceof PsiLiteralExpression && e2 instanceof PsiLiteralExpression) {\n      return Comparing.equal(((PsiLiteralExpression)e1).getValue(), ((PsiLiteralExpression)e2).getValue());\n    }\n    if (e1 instanceof PsiPrefixExpression && e2 instanceof PsiPrefixExpression && ((PsiPrefixExpression)e1).getOperationTokenType() == ((PsiPrefixExpression)e2).getOperationTokenType()) {\n      PsiExpression loperand = ((PsiPrefixExpression)e1).getOperand();\n      PsiExpression roperand = ((PsiPrefixExpression)e2).getOperand();\n      return loperand != null && roperand != null && same(loperand, roperand, manager);\n    }\n    if (e1 instanceof PsiReference && e2 instanceof PsiReference) {\n      e1 = ((PsiReference)e1).resolve();\n      e2 = ((PsiReference)e2).resolve();\n    }\n    return manager.areElementsEquivalent(e2, e1);\n  }","commit_id":"e99f80a35d99d43525ac65f3c84785553773517c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static AllowedValues parseBeanInfo(@NotNull PsiModifierListOwner owner, @NotNull PsiManager manager) {\n    PsiMethod method = null;\n    if (owner instanceof PsiParameter) {\n      PsiParameter parameter = (PsiParameter)owner;\n      PsiElement scope = parameter.getDeclarationScope();\n      if (!(scope instanceof PsiMethod)) return null;\n      PsiElement nav = scope.getNavigationElement();\n      if (!(nav instanceof PsiMethod)) return null;\n      method = (PsiMethod)nav;\n      if (method.isConstructor()) {\n        // not a property, try the @ConstructorProperties({\"prop\"})\n        PsiAnnotation annotation = AnnotationUtil.findAnnotation(method, \"java.beans.ConstructorProperties\");\n        if (annotation == null) return null;\n        PsiAnnotationMemberValue value = annotation.findAttributeValue(\"value\");\n        if (!(value instanceof PsiArrayInitializerMemberValue)) return null;\n        PsiAnnotationMemberValue[] initializers = ((PsiArrayInitializerMemberValue)value).getInitializers();\n        PsiElement parent = parameter.getParent();\n        if (!(parent instanceof PsiParameterList)) return null;\n        int index = ((PsiParameterList)parent).getParameterIndex(parameter);\n        if (index >= initializers.length) return null;\n        PsiAnnotationMemberValue initializer = initializers[index];\n        if (!(initializer instanceof PsiLiteralExpression)) return null;\n        Object val = ((PsiLiteralExpression)initializer).getValue();\n        if (!(val instanceof String)) return null;\n        PsiMethod setter = PropertyUtil.findPropertySetter(method.getContainingClass(), (String)val, false, false);\n        if (setter == null) return null;\n        // try the @beaninfo of the corresponding setter\n        PsiElement navigationElement = setter.getNavigationElement();\n        if (!(navigationElement instanceof PsiMethod)) return null;\n        method = (PsiMethod)navigationElement;\n      }\n    }\n    else if (owner instanceof PsiMethod) {\n      PsiElement nav = owner.getNavigationElement();\n      if (!(nav instanceof PsiMethod)) return null;\n      method = (PsiMethod)nav;\n    }\n    if (method == null) return null;\n\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null) return null;\n    if (PropertyUtil.isSimplePropertyGetter(method)) {\n      List<PsiMethod> setters = PropertyUtil.getSetters(aClass, PropertyUtil.getPropertyNameByGetter(method));\n      if (setters.size() != 1) return null;\n      method = setters.get(0);\n    }\n    if (!PropertyUtil.isSimplePropertySetter(method)) return null;\n    PsiDocComment doc = method.getDocComment();\n    if (doc == null) return null;\n    PsiDocTag beaninfo = doc.findTagByName(\"beaninfo\");\n    if (beaninfo == null) return null;\n    String data = StringUtil.join(beaninfo.getDataElements(), PsiElement::getText, \"\\n\");\n    int enumIndex = StringUtil.indexOfSubstringEnd(data, \"enum:\");\n    if (enumIndex == -1) return null;\n    data = data.substring(enumIndex);\n    int colon = data.indexOf(\":\");\n    int last = colon == -1 ? data.length() : data.substring(0,colon).lastIndexOf(\"\\n\");\n    data = data.substring(0, last);\n\n    List<PsiAnnotationMemberValue> values = new ArrayList<>();\n    for (String line : StringUtil.splitByLines(data)) {\n      List<String> words = StringUtil.split(line, \" \", true, true);\n      if (words.size() != 2) continue;\n      String ref = words.get(1);\n      PsiExpression constRef = JavaPsiFacade.getElementFactory(manager.getProject()).createExpressionFromText(ref, aClass);\n      if (!(constRef instanceof PsiReferenceExpression)) continue;\n      PsiReferenceExpression expr = (PsiReferenceExpression)constRef;\n      values.add(expr);\n    }\n    if (values.isEmpty()) return null;\n    PsiAnnotationMemberValue[] array = values.toArray(new PsiAnnotationMemberValue[values.size()]);\n    return new AllowedValues(array, false);\n  }","id":74683,"modified_method":"private static AllowedValues parseBeanInfo(@NotNull PsiModifierListOwner owner, @NotNull PsiManager manager) {\n    PsiMethod method = null;\n    if (owner instanceof PsiParameter) {\n      PsiParameter parameter = (PsiParameter)owner;\n      PsiElement scope = parameter.getDeclarationScope();\n      if (!(scope instanceof PsiMethod)) return null;\n      PsiElement nav = scope.getNavigationElement();\n      if (!(nav instanceof PsiMethod)) return null;\n      method = (PsiMethod)nav;\n      if (method.isConstructor()) {\n        // not a property, try the @ConstructorProperties({\"prop\"})\n        PsiAnnotation annotation = AnnotationUtil.findAnnotation(method, \"java.beans.ConstructorProperties\");\n        if (annotation == null) return null;\n        PsiAnnotationMemberValue value = annotation.findAttributeValue(\"value\");\n        if (!(value instanceof PsiArrayInitializerMemberValue)) return null;\n        PsiAnnotationMemberValue[] initializers = ((PsiArrayInitializerMemberValue)value).getInitializers();\n        PsiElement parent = parameter.getParent();\n        if (!(parent instanceof PsiParameterList)) return null;\n        int index = ((PsiParameterList)parent).getParameterIndex(parameter);\n        if (index >= initializers.length) return null;\n        PsiAnnotationMemberValue initializer = initializers[index];\n        if (!(initializer instanceof PsiLiteralExpression)) return null;\n        Object val = ((PsiLiteralExpression)initializer).getValue();\n        if (!(val instanceof String)) return null;\n        PsiMethod setter = PropertyUtil.findPropertySetter(method.getContainingClass(), (String)val, false, false);\n        if (setter == null) return null;\n        // try the @beaninfo of the corresponding setter\n        PsiElement navigationElement = setter.getNavigationElement();\n        if (!(navigationElement instanceof PsiMethod)) return null;\n        method = (PsiMethod)navigationElement;\n      }\n    }\n    else if (owner instanceof PsiMethod) {\n      PsiElement nav = owner.getNavigationElement();\n      if (!(nav instanceof PsiMethod)) return null;\n      method = (PsiMethod)nav;\n    }\n    if (method == null) return null;\n\n    PsiClass aClass = method.getContainingClass();\n    if (aClass == null) return null;\n    if (PropertyUtil.isSimplePropertyGetter(method)) {\n      List<PsiMethod> setters = PropertyUtil.getSetters(aClass, PropertyUtil.getPropertyNameByGetter(method));\n      if (setters.size() != 1) return null;\n      method = setters.get(0);\n    }\n    if (!PropertyUtil.isSimplePropertySetter(method)) return null;\n    PsiDocComment doc = method.getDocComment();\n    if (doc == null) return null;\n    PsiDocTag beaninfo = doc.findTagByName(\"beaninfo\");\n    if (beaninfo == null) return null;\n    String data = StringUtil.join(beaninfo.getDataElements(), PsiElement::getText, \"\\n\");\n    int enumIndex = StringUtil.indexOfSubstringEnd(data, \"enum:\");\n    if (enumIndex == -1) return null;\n    data = data.substring(enumIndex);\n    int colon = data.indexOf(':');\n    int last = colon == -1 ? data.length() : data.substring(0,colon).lastIndexOf('\\n');\n    data = data.substring(0, last);\n\n    List<PsiAnnotationMemberValue> values = new ArrayList<>();\n    for (String line : StringUtil.splitByLines(data)) {\n      List<String> words = StringUtil.split(line, \" \", true, true);\n      if (words.size() != 2) continue;\n      String ref = words.get(1);\n      PsiExpression constRef = JavaPsiFacade.getElementFactory(manager.getProject()).createExpressionFromText(ref, aClass);\n      if (!(constRef instanceof PsiReferenceExpression)) continue;\n      PsiReferenceExpression expr = (PsiReferenceExpression)constRef;\n      values.add(expr);\n    }\n    if (values.isEmpty()) return null;\n    PsiAnnotationMemberValue[] array = values.toArray(new PsiAnnotationMemberValue[values.size()]);\n    return new AllowedValues(array, false);\n  }","commit_id":"e99f80a35d99d43525ac65f3c84785553773517c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static AllowedValues getAllowedValues(@NotNull PsiModifierListOwner element, PsiType type, Set<PsiClass> visited) {\n    PsiAnnotation[] annotations = getAllAnnotations(element);\n    PsiManager manager = element.getManager();\n    for (PsiAnnotation annotation : annotations) {\n      AllowedValues values;\n      if (type != null && MagicConstant.class.getName().equals(annotation.getQualifiedName())) {\n        //PsiAnnotation magic = AnnotationUtil.findAnnotationInHierarchy(element, Collections.singleton(MagicConstant.class.getName()));\n        values = getAllowedValuesFromMagic(element, type, annotation, manager);\n        if (values != null) return values;\n      }\n\n      PsiJavaCodeReferenceElement ref = annotation.getNameReferenceElement();\n      PsiElement resolved = ref == null ? null : ref.resolve();\n      if (!(resolved instanceof PsiClass) || !((PsiClass)resolved).isAnnotationType()) continue;\n      PsiClass aClass = (PsiClass)resolved;\n      if (visited == null) visited = new THashSet<>();\n      if (!visited.add(aClass)) continue;\n      values = getAllowedValues(aClass, type, visited);\n      if (values != null) return values;\n    }\n\n    return parseBeanInfo(element, manager);\n  }","id":74684,"modified_method":"static AllowedValues getAllowedValues(@NotNull PsiModifierListOwner element, @Nullable PsiType type, @Nullable Set<PsiClass> visited) {\n    PsiAnnotation[] annotations = getAllAnnotations(element);\n    PsiManager manager = element.getManager();\n    for (PsiAnnotation annotation : annotations) {\n      AllowedValues values;\n      if (type != null && MagicConstant.class.getName().equals(annotation.getQualifiedName())) {\n        //PsiAnnotation magic = AnnotationUtil.findAnnotationInHierarchy(element, Collections.singleton(MagicConstant.class.getName()));\n        values = getAllowedValuesFromMagic(type, annotation, manager);\n        if (values != null) return values;\n      }\n\n      PsiJavaCodeReferenceElement ref = annotation.getNameReferenceElement();\n      PsiElement resolved = ref == null ? null : ref.resolve();\n      if (!(resolved instanceof PsiClass) || !((PsiClass)resolved).isAnnotationType()) continue;\n      PsiClass aClass = (PsiClass)resolved;\n      if (visited == null) visited = new THashSet<>();\n      if (!visited.add(aClass)) continue;\n      values = getAllowedValues(aClass, type, visited);\n      if (values != null) return values;\n    }\n\n    return parseBeanInfo(element, manager);\n  }","commit_id":"e99f80a35d99d43525ac65f3c84785553773517c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder,\n                                        boolean isOnTheFly,\n                                        @NotNull LocalInspectionToolSession session) {\n    return new JavaElementVisitor() {\n      @Override\n      public void visitJavaFile(PsiJavaFile file) {\n        checkAnnotationsJarAttached(file, holder);\n      }\n\n      @Override\n      public void visitCallExpression(PsiCallExpression callExpression) {\n        checkCall(callExpression, holder);\n      }\n\n      @Override\n      public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n        PsiExpression r = expression.getRExpression();\n        if (r == null) return;\n        PsiExpression l = expression.getLExpression();\n        if (!(l instanceof PsiReferenceExpression)) return;\n        PsiElement resolved = ((PsiReferenceExpression)l).resolve();\n        if (!(resolved instanceof PsiModifierListOwner)) return;\n        PsiModifierListOwner owner = (PsiModifierListOwner)resolved;\n        PsiType type = expression.getType();\n        checkExpression(r, owner, type, holder);\n      }\n\n      @Override\n      public void visitReturnStatement(PsiReturnStatement statement) {\n        PsiExpression value = statement.getReturnValue();\n        if (value == null) return;\n        PsiElement element = PsiTreeUtil.getParentOfType(statement, PsiMethod.class, PsiLambdaExpression.class);\n        PsiMethod method = element instanceof PsiMethod ? (PsiMethod)element : LambdaUtil.getFunctionalInterfaceMethod(element);\n        if (method == null) return;\n        checkExpression(value, method, value.getType(), holder);\n      }\n\n      @Override\n      public void visitNameValuePair(PsiNameValuePair pair) {\n        PsiAnnotationMemberValue value = pair.getValue();\n        if (!(value instanceof PsiExpression)) return;\n        PsiReference ref = pair.getReference();\n        if (ref == null) return;\n        PsiMethod method = (PsiMethod)ref.resolve();\n        if (method == null) return;\n        checkExpression((PsiExpression)value, method, method.getReturnType(), holder);\n      }\n\n      @Override\n      public void visitBinaryExpression(PsiBinaryExpression expression) {\n        IElementType tokenType = expression.getOperationTokenType();\n        if (tokenType != JavaTokenType.EQEQ && tokenType != JavaTokenType.NE) return;\n        PsiExpression l = expression.getLOperand();\n        PsiExpression r = expression.getROperand();\n        if (r == null) return;\n        checkBinary(l, r);\n        checkBinary(r, l);\n      }\n\n      private void checkBinary(PsiExpression l, PsiExpression r) {\n        if (l instanceof PsiReference) {\n          PsiElement resolved = ((PsiReference)l).resolve();\n          if (resolved instanceof PsiModifierListOwner) {\n            checkExpression(r, (PsiModifierListOwner)resolved, getType((PsiModifierListOwner)resolved), holder);\n          }\n        }\n        else if (l instanceof PsiMethodCallExpression) {\n          PsiMethod method = ((PsiMethodCallExpression)l).resolveMethod();\n          if (method != null) {\n            checkExpression(r, method, method.getReturnType(), holder);\n          }\n        }\n      }\n    };\n  }","id":74685,"modified_method":"@NotNull\n  @Override\n  public PsiElementVisitor buildVisitor(@NotNull final ProblemsHolder holder,\n                                        boolean isOnTheFly,\n                                        @NotNull LocalInspectionToolSession session) {\n    return new JavaElementVisitor() {\n      @Override\n      public void visitJavaFile(PsiJavaFile file) {\n        checkAnnotationsJarAttached(file, holder);\n      }\n\n      @Override\n      public void visitCallExpression(PsiCallExpression callExpression) {\n        checkCall(callExpression, holder);\n      }\n\n      @Override\n      public void visitAssignmentExpression(PsiAssignmentExpression expression) {\n        PsiExpression r = expression.getRExpression();\n        if (r == null) return;\n        PsiExpression l = expression.getLExpression();\n        if (!(l instanceof PsiReferenceExpression)) return;\n        PsiElement resolved = ((PsiReferenceExpression)l).resolve();\n        if (!(resolved instanceof PsiModifierListOwner)) return;\n        PsiModifierListOwner owner = (PsiModifierListOwner)resolved;\n        PsiType type = expression.getType();\n        checkExpression(r, owner, type, holder);\n      }\n\n      @Override\n      public void visitReturnStatement(PsiReturnStatement statement) {\n        PsiExpression value = statement.getReturnValue();\n        if (value == null) return;\n        PsiElement element = PsiTreeUtil.getParentOfType(statement, PsiMethod.class, PsiLambdaExpression.class);\n        PsiMethod method = element instanceof PsiMethod ? (PsiMethod)element : LambdaUtil.getFunctionalInterfaceMethod(element);\n        if (method == null) return;\n        checkExpression(value, method, value.getType(), holder);\n      }\n\n      @Override\n      public void visitNameValuePair(PsiNameValuePair pair) {\n        PsiAnnotationMemberValue value = pair.getValue();\n        if (!(value instanceof PsiExpression)) return;\n        PsiReference ref = pair.getReference();\n        if (ref == null) return;\n        PsiMethod method = (PsiMethod)ref.resolve();\n        if (method == null) return;\n        checkExpression((PsiExpression)value, method, method.getReturnType(), holder);\n      }\n\n      @Override\n      public void visitBinaryExpression(PsiBinaryExpression expression) {\n        IElementType tokenType = expression.getOperationTokenType();\n        if (tokenType != JavaTokenType.EQEQ && tokenType != JavaTokenType.NE) return;\n        PsiExpression l = expression.getLOperand();\n        PsiExpression r = expression.getROperand();\n        if (r == null) return;\n        checkBinary(l, r);\n        checkBinary(r, l);\n      }\n\n      private void checkBinary(@NotNull PsiExpression l, @NotNull PsiExpression r) {\n        if (l instanceof PsiReference) {\n          PsiElement resolved = ((PsiReference)l).resolve();\n          if (resolved instanceof PsiModifierListOwner) {\n            checkExpression(r, (PsiModifierListOwner)resolved, getType((PsiModifierListOwner)resolved), holder);\n          }\n        }\n        else if (l instanceof PsiMethodCallExpression) {\n          PsiMethod method = ((PsiMethodCallExpression)l).resolveMethod();\n          if (method != null) {\n            checkExpression(r, method, method.getReturnType(), holder);\n          }\n        }\n      }\n    };\n  }","commit_id":"e99f80a35d99d43525ac65f3c84785553773517c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static AllowedValues getAllowedValuesFromMagic(@NotNull PsiModifierListOwner element,\n                                                         @NotNull PsiType type,\n                                                         @NotNull PsiAnnotation magic,\n                                                         @NotNull PsiManager manager) {\n    PsiAnnotationMemberValue[] allowedValues;\n    final boolean canBeOred;\n    if (TypeConversionUtil.getTypeRank(type) <= TypeConversionUtil.LONG_RANK) {\n      PsiAnnotationMemberValue intValues = magic.findAttributeValue(\"intValues\");\n      allowedValues = intValues instanceof PsiArrayInitializerMemberValue ? ((PsiArrayInitializerMemberValue)intValues).getInitializers() : PsiAnnotationMemberValue.EMPTY_ARRAY;\n      if (allowedValues.length == 0) {\n        PsiAnnotationMemberValue orValue = magic.findAttributeValue(\"flags\");\n        allowedValues = orValue instanceof PsiArrayInitializerMemberValue ? ((PsiArrayInitializerMemberValue)orValue).getInitializers() : PsiAnnotationMemberValue.EMPTY_ARRAY;\n        canBeOred = true;\n      }\n      else {\n        canBeOred = false;\n      }\n    }\n    else if (type.equals(PsiType.getJavaLangString(manager, GlobalSearchScope.allScope(manager.getProject())))) {\n      PsiAnnotationMemberValue strValuesAttr = magic.findAttributeValue(\"stringValues\");\n      allowedValues = strValuesAttr instanceof PsiArrayInitializerMemberValue ? ((PsiArrayInitializerMemberValue)strValuesAttr).getInitializers() : PsiAnnotationMemberValue.EMPTY_ARRAY;\n      canBeOred = false;\n    }\n    else {\n      return null; //other types not supported\n    }\n\n    if (allowedValues.length != 0) {\n      return new AllowedValues(allowedValues, canBeOred);\n    }\n\n    // last resort: try valuesFromClass\n    PsiAnnotationMemberValue[] values = readFromClass(\"valuesFromClass\", magic, type, manager);\n    boolean ored = false;\n    if (values == null) {\n      values = readFromClass(\"flagsFromClass\", magic, type, manager);\n      ored = true;\n    }\n    if (values == null) return null;\n    return new AllowedValues(values, ored);\n  }","id":74686,"modified_method":"private static AllowedValues getAllowedValuesFromMagic(@NotNull PsiType type,\n                                                         @NotNull PsiAnnotation magic,\n                                                         @NotNull PsiManager manager) {\n    PsiAnnotationMemberValue[] allowedValues;\n    final boolean canBeOred;\n    if (TypeConversionUtil.getTypeRank(type) <= TypeConversionUtil.LONG_RANK) {\n      PsiAnnotationMemberValue intValues = magic.findAttributeValue(\"intValues\");\n      allowedValues = intValues instanceof PsiArrayInitializerMemberValue ? ((PsiArrayInitializerMemberValue)intValues).getInitializers() : PsiAnnotationMemberValue.EMPTY_ARRAY;\n      if (allowedValues.length == 0) {\n        PsiAnnotationMemberValue orValue = magic.findAttributeValue(\"flags\");\n        allowedValues = orValue instanceof PsiArrayInitializerMemberValue ? ((PsiArrayInitializerMemberValue)orValue).getInitializers() : PsiAnnotationMemberValue.EMPTY_ARRAY;\n        canBeOred = true;\n      }\n      else {\n        canBeOred = false;\n      }\n    }\n    else if (type.equals(PsiType.getJavaLangString(manager, GlobalSearchScope.allScope(manager.getProject())))) {\n      PsiAnnotationMemberValue strValuesAttr = magic.findAttributeValue(\"stringValues\");\n      allowedValues = strValuesAttr instanceof PsiArrayInitializerMemberValue ? ((PsiArrayInitializerMemberValue)strValuesAttr).getInitializers() : PsiAnnotationMemberValue.EMPTY_ARRAY;\n      canBeOred = false;\n    }\n    else {\n      return null; //other types not supported\n    }\n\n    if (allowedValues.length != 0) {\n      return new AllowedValues(allowedValues, canBeOred);\n    }\n\n    // last resort: try valuesFromClass\n    PsiAnnotationMemberValue[] values = readFromClass(\"valuesFromClass\", magic, type, manager);\n    boolean ored = false;\n    if (values == null) {\n      values = readFromClass(\"flagsFromClass\", magic, type, manager);\n      ored = true;\n    }\n    if (values == null) return null;\n    return new AllowedValues(values, ored);\n  }","commit_id":"e99f80a35d99d43525ac65f3c84785553773517c","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     */\n    private void scheduleNoticesForEvent(Event event) {\n        Category log = ThreadCategory.getInstance(getClass());\n\n        boolean mapsToNotice = false;\n\n        try {\n            mapsToNotice = getNotificationManager().hasUei(event.getUei());\n        } catch (Exception e) {\n            log.error(\"Couldn't map uei \" + event.getUei() + \" to a notification entry, not scheduling notice.\", e);\n            return;\n        }\n\n        if (mapsToNotice) {\n            // check to see if notices are turned on for the interface/service\n            // in the event\n            if (continueWithNotice(event)) {\n                Notification[] notifications = null;\n\n                try {\n                    notifications = getNotificationManager().getNotifForEvent(event);\n                } catch (Exception e) {\n                    log.error(\"Couldn't get notification mapping for event \" + event.getUei() + \", not scheduling notice.\", e);\n                    return;\n                }\n\n                if (notifications != null) {\n                    for (int i = 0; i < notifications.length; i++) {\n\n                        Notification notification = notifications[i];\n\n                        boolean parmsmatched = matchNotificationParameters(event, notification);\n\n                        if (!parmsmatched) {\n                            log.debug(\"Event \" + event.getUei() + \" did not match parameters for notice \" + notification.getName());\n                            return;\n                        }\n\n                        log.debug(\"Event \" + event.getUei() + \" matched notice \" + notification.getName());\n\n                        int noticeId = 0;\n\n                        try {\n                            noticeId = getNotificationManager().getNoticeId();\n                        } catch (Exception e) {\n                            log.error(\"Failed to get a unique id # for notification, exiting this notification\", e);\n                            return;\n                        }\n\n                        Map paramMap = buildParameterMap(notification, event, noticeId);\n                        String queueID = (notification.getNoticeQueue() != null ? notification.getNoticeQueue() : \"default\");\n\n                        log.debug(\"destination : \" + notification.getDestinationPath());\n                        log.debug(\"text message: \" + (String) paramMap.get(NotificationManager.PARAM_TEXT_MSG));\n                        log.debug(\"num message : \" + (String) paramMap.get(NotificationManager.PARAM_NUM_MSG));\n                        log.debug(\"subject     : \" + (String) paramMap.get(NotificationManager.PARAM_SUBJECT));\n                        log.debug(\"node        : \" + (String) paramMap.get(NotificationManager.PARAM_NODE));\n                        log.debug(\"interface   : \" + (String) paramMap.get(NotificationManager.PARAM_INTERFACE));\n                        log.debug(\"service     : \" + (String) paramMap.get(NotificationManager.PARAM_SERVICE));\n\n                        // get the target and escalation information\n                        Path path = null;\n                        try {\n                            path = m_notifd.getDestinationPathManager().getPath(notification.getDestinationPath());\n                            if (path == null) {\n                                log.warn(\"Unknown destination path \" + notification.getDestinationPath() + \". Please check the <destinationPath> tag for the notification \" + notification.getName() + \" in the notification.xml file.\");\n                                return;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Could not get destination path for \" + notification.getDestinationPath() + \", please check the destinationPath.xml for errors.\", e);\n                            return;\n                        }\n                        String initialDelay = (path.getInitialDelay() == null ? \"0s\" : path.getInitialDelay());\n                        Target[] targets = path.getTarget();\n                        Escalate[] escalations = path.getEscalate();\n\n                        // now check to see if any users are to receive the\n                        // notification, if none then generate an event a exit\n                        try {\n                            if (getUserCount(targets, escalations) == 0) {\n                                log.warn(\"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified, not sending notice.\");\n                                sendNotifEvent(EventConstants.NOTIFICATION_WITHOUT_USERS, \"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified.\", \"The message of the notification is as follows: \" + (String) paramMap.get(NotificationManager.PARAM_TEXT_MSG));\n                                return;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Failed to get count of users in destination path \" + notification.getDestinationPath() + \", exiting notification.\", e);\n                            return;\n                        }\n\n                        try {\n                            getNotificationManager().insertNotice(noticeId, paramMap);\n                        } catch (SQLException e) {\n                            log.error(\"Failed to enter notification into database, exiting this notification\", e);\n                            return;\n                        }\n\n                        long startTime = System.currentTimeMillis() + TimeConverter.convertToMillis(initialDelay);\n                        List targetSiblings = new ArrayList();\n\n                        try {\n                            NoticeQueue noticeQueue = (NoticeQueue) m_noticeQueues.get(queueID);\n                            processTargets(targets, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                            processEscalations(escalations, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                        } catch (Exception e) {\n                            log.error(\"notice not scheduled due to error: \", e);\n                        }\n\n                    }\n                } else {\n                    log.debug(\"Event doesn't match a notice: \" + event.getUei() + \" : \" + event.getNodeid() + \" : \" + event.getInterface() + \" : \" + event.getService());\n                }\n            }\n        } else {\n            log.debug(\"No notice match for uei: \" + event.getUei());\n        }\n    }","id":74687,"modified_method":"/**\n     */\n    private void scheduleNoticesForEvent(Event event) {\n\n        Category log = ThreadCategory.getInstance(getClass());\n        boolean mapsToNotice = false;\n\n        try {\n            mapsToNotice = getNotificationManager().hasUei(event.getUei());\n        } catch (Exception e) {\n            log.error(\"Couldn't map uei \" + event.getUei() + \" to a notification entry, not scheduling notice.\", e);\n            return;\n        }\n\n        if (mapsToNotice) {\n            // check to see if notices are turned on for the interface/service\n            // in the event\n            if (continueWithNotice(event)) {\n                Notification[] notifications = null;\n\n                try {\n                    notifications = getNotificationManager().getNotifForEvent(event);\n                } catch (Exception e) {\n                    log.error(\"Couldn't get notification mapping for event \" + event.getUei() + \", not scheduling notice.\", e);\n                    return;\n                }\n\n                if (notifications != null) {\n                    for (int i = 0; i < notifications.length; i++) {\n\n                        Notification notification = notifications[i];\n                        int noticeId = 0;\n\n                        try {\n                            noticeId = getNotificationManager().getNoticeId();\n                        } catch (Exception e) {\n                            log.error(\"Failed to get a unique id # for notification, exiting this notification\", e);\n                            continue;\n                        }\n\n                        Map paramMap = buildParameterMap(notification, event, noticeId);\n                        String queueID = (notification.getNoticeQueue() != null ? notification.getNoticeQueue() : \"default\");\n\n                        log.debug(\"destination : \" + notification.getDestinationPath());\n                        log.debug(\"text message: \" + (String) paramMap.get(NotificationManager.PARAM_TEXT_MSG));\n                        log.debug(\"num message : \" + (String) paramMap.get(NotificationManager.PARAM_NUM_MSG));\n                        log.debug(\"subject     : \" + (String) paramMap.get(NotificationManager.PARAM_SUBJECT));\n                        log.debug(\"node        : \" + (String) paramMap.get(NotificationManager.PARAM_NODE));\n                        log.debug(\"interface   : \" + (String) paramMap.get(NotificationManager.PARAM_INTERFACE));\n                        log.debug(\"service     : \" + (String) paramMap.get(NotificationManager.PARAM_SERVICE));\n\n                        // get the target and escalation information\n                        Path path = null;\n                        try {\n                            path = m_notifd.getDestinationPathManager().getPath(notification.getDestinationPath());\n                            if (path == null) {\n                                log.warn(\"Unknown destination path \" + notification.getDestinationPath() + \". Please check the <destinationPath> tag for the notification \" + notification.getName() + \" in the notification.xml file.\");\n                                \n                                //changing posted by Wiktor Wodecki\n                                //return;\n                                continue;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Could not get destination path for \" + notification.getDestinationPath() + \", please check the destinationPath.xml for errors.\", e);\n                            return;\n                        }\n                        String initialDelay = (path.getInitialDelay() == null ? \"0s\" : path.getInitialDelay());\n                        Target[] targets = path.getTarget();\n                        Escalate[] escalations = path.getEscalate();\n\n                        // now check to see if any users are to receive the\n                        // notification, if none then generate an event a exit\n                        try {\n                            if (getUserCount(targets, escalations) == 0) {\n                                log.warn(\"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified, not sending notice.\");\n                                sendNotifEvent(EventConstants.NOTIFICATION_WITHOUT_USERS, \"The path \" + notification.getDestinationPath() + \" assigned to notification \" + notification.getName() + \" has no targets or escalations specified.\", \"The message of the notification is as follows: \" + (String) paramMap.get(NotificationManager.PARAM_TEXT_MSG));\n                                return;\n                            }\n                        } catch (Exception e) {\n                            log.error(\"Failed to get count of users in destination path \" + notification.getDestinationPath() + \", exiting notification.\", e);\n                            return;\n                        }\n\n                        try {\n                            getNotificationManager().insertNotice(noticeId, paramMap);\n                        } catch (SQLException e) {\n                            log.error(\"Failed to enter notification into database, exiting this notification\", e);\n                            return;\n                        }\n\n                        long startTime = System.currentTimeMillis() + TimeConverter.convertToMillis(initialDelay);\n                        List targetSiblings = new ArrayList();\n\n                        try {\n                            NoticeQueue noticeQueue = (NoticeQueue) m_noticeQueues.get(queueID);\n                            processTargets(targets, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                            processEscalations(escalations, targetSiblings, noticeQueue, startTime, paramMap, noticeId);\n                        } catch (Exception e) {\n                            log.error(\"notice not scheduled due to error: \", e);\n                        }\n\n                    }\n                } else {\n                    log.debug(\"Event doesn't match a notice: \" + event.getUei() + \" : \" + event.getNodeid() + \" : \" + event.getInterface() + \" : \" + event.getService());\n                }\n            }\n        } else {\n            log.debug(\"No notice match for uei: \" + event.getUei());\n        }\n    }","commit_id":"acd9f3285ecdc4e0e9424b89d8a97348cd0a8ae4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void setUp() throws Exception {\n        super.setUp();\n\n        MockUtil.setupLogging();\n        MockUtil.resetLogLevel();\n        \n        m_network = new MockNetwork();\n        m_network.setCriticalService(\"ICMP\");\n        m_network.addNode(1, \"Router\");\n        m_network.addInterface(\"192.168.1.1\");\n        m_network.addService(\"ICMP\");\n        m_network.addService(\"SMTP\");\n        m_network.addInterface(\"192.168.1.2\");\n        m_network.addService(\"ICMP\");\n        m_network.addService(\"SMTP\");\n        m_network.addNode(2, \"Server\");\n        m_network.addInterface(\"192.168.1.3\");\n        m_network.addService(\"ICMP\");\n        m_network.addService(\"HTTP\");\n        \n        m_db = new MockDatabase();\n        m_db.populate(m_network);\n\n        m_eventMgr = new MockEventIpcManager();\n        m_eventMgr.setEventWriter(m_db);\n        m_notifdConfig = new MockNotifdConfigManager(NOTIFD_CONFIG_MANAGER);\n        m_notifdConfig.setNextNotifIdSql(m_db.getNextNotifIdSql());\n        m_groupManager = new MockGroupManager(GROUP_MANAGER);\n        m_userManager = new MockUserManager(m_groupManager, USER_MANAGER);\n        m_destinationPathManager = new MockDestinationPathManager(PATH_MANAGER);        \n        m_notificationCommandManger = new MockNotificationCommandManager(CMD_MANAGER);\n        m_notificationManager = new MockNotificationManager(m_notifdConfig, m_db, NOTIFICATION_MANAGER);\n        \n        m_notifd = new Notifd();\n        m_notifd.setEventManager(m_eventMgr);\n        m_notifd.setConfigManager(m_notifdConfig);\n        m_notifd.setGroupManager(m_groupManager);\n        m_notifd.setUserManager(m_userManager);\n        m_notifd.setDestinationPathManager(m_destinationPathManager);\n        m_notifd.setNotificationCommandManager(m_notificationCommandManger);\n        m_notifd.setNotificationManager(m_notificationManager);\n        \n        m_notifd.setNotificationManager(m_notificationManager);\n        \n        m_notifd.init();\n        m_notifd.start();\n    }","id":74688,"modified_method":"protected void setUp() throws Exception {\n        super.setUp();\n\n        MockUtil.setupLogging();\n        MockUtil.resetLogLevel();\n        \n        m_network = new MockNetwork();\n        m_network.setCriticalService(\"ICMP\");\n        m_network.addNode(1, \"Router\");\n        m_network.addInterface(\"192.168.1.1\");\n        m_network.addService(\"ICMP\");\n        m_network.addService(\"SMTP\");\n        m_network.addInterface(\"192.168.1.2\");\n        m_network.addService(\"ICMP\");\n        m_network.addService(\"SMTP\");\n        m_network.addNode(2, \"Server\");\n        m_network.addInterface(\"192.168.1.3\");\n        m_network.addService(\"ICMP\");\n        m_network.addService(\"HTTP\");\n        \n        m_db = new MockDatabase();\n        m_db.populate(m_network);\n\n        m_eventMgr = new MockEventIpcManager();\n        m_eventMgr.setEventWriter(m_db);\n        m_notifdConfig = new MockNotifdConfigManager(NOTIFD_CONFIG_MANAGER);\n        m_notifdConfig.setNextNotifIdSql(m_db.getNextNotifIdSql());\n        m_groupManager = new MockGroupManager(GROUP_MANAGER);\n        m_userManager = new MockUserManager(m_groupManager, USER_MANAGER);\n        m_destinationPathManager = new MockDestinationPathManager(PATH_MANAGER);        \n        m_notificationCommandManger = new MockNotificationCommandManager(CMD_MANAGER);\n        m_notificationManager = new MockNotificationManager(m_notifdConfig, m_db, NOTIFICATION_MANAGER);\n        \n        m_notifd = new Notifd();\n        m_notifd.setEventManager(m_eventMgr);\n        m_notifd.setConfigManager(m_notifdConfig);\n        m_notifd.setGroupManager(m_groupManager);\n        m_notifd.setUserManager(m_userManager);\n        m_notifd.setDestinationPathManager(m_destinationPathManager);\n        m_notifd.setNotificationCommandManager(m_notificationCommandManger);\n        m_notifd.setNotificationManager(m_notificationManager);\n                \n        m_anticipator = new NotificationAnticipator();\n        MockNotificationStrategy.setAnticpator(m_anticipator);\n\n        m_notifd.init();\n        m_notifd.start();\n        \n        \n    }","commit_id":"acd9f3285ecdc4e0e9424b89d8a97348cd0a8ae4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"protected void tearDown() throws Exception {\n        super.tearDown();\n        m_notifd.stop();\n        m_db.drop();\n        assertTrue(MockUtil.noWarningsOrHigherLogged());\n    }","id":74689,"modified_method":"protected void tearDown() throws Exception {\n        super.tearDown();\n        m_notifd.stop();\n        m_db.drop();\n        MockNotificationStrategy.setAnticpator(null);\n        assertTrue(MockUtil.noWarningsOrHigherLogged());\n    }","commit_id":"acd9f3285ecdc4e0e9424b89d8a97348cd0a8ae4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n     * see http://bugzilla.opennms.org/cgi-bin/bugzilla/show_bug.cgi?id=1022\n     * @throws Exception\n     */\n    public void testWicktorBug() throws Exception {\n        \n        //setup the notifications that Wicktor discussed\n        String notifications = \"<?xml version=\\\\\\\"1.0\\\\\\\"?>\\\\n\\\" + \\n\" + \n                \"            \\\"<notifications xmlns=\\\\\\\"http://xmlns.opennms.org/xsd/notifications\\\\\\\">\\\\n\\\" + \\n\" + \n                \"            \\\"    <header>\\\\n\\\" + \\n\" + \n                \"            \\\"        <rev>1.2<\/rev>\\\\n\\\" + \\n\" + \n                \"            \\\"        <created>Wednesday, February 6, 2002 10:10:00 AM EST<\/created>\\\\n\\\" + \\n\" + \n                \"            \\\"        <mstation>localhost<\/mstation>\\\\n\\\" + \\n\" + \n                \"            \\\"    <\/header>\\\\n\" +\n                \"     <notification name=\\\"SNMP High disk Threshold Exceeded\\\" status=\\\"on\\\">\\n\" + \n                \"        <uei>uei.opennms.org/threshold/highThresholdExceeded<\/uei>\\n\" + \n                \"        <description>high disk threshold exceeded on snmp\\n\" + \n                \"interface<\/description>\\n\" + \n                \"        <rule>(IPADDR IPLIKE *.*.*.*) &amp; (isSNMP )<\/rule>\\n\" + \n                \"        <destinationPath>Email-Network/Systems<\/destinationPath>\\n\" + \n                \"        <text-message>High disk Threshold exceeded on %interface%, %parm[ds]%\\n\" + \n                \"with %parm[value]%%%<\/text-message>\\n\" + \n                \"        <subject>Notice #%noticeid%, High disk Threshold exceeded<\/subject>\\n\" + \n                \"        <varbind>\\n\" + \n                \"            <vbname>ds<\/vbname>\\n\" + \n                \"            <vbvalue>dsk-usr-pcent<\/vbvalue>\\n\" + \n                \"        <\/varbind>\\n\" + \n                \"    <\/notification>\\n\" + \n                \"    <notification name=\\\"SNMP High loadavg5 Threshold Exceeded\\\" status=\\\"on\\\">\\n\" + \n                \"        <uei>uei.opennms.org/threshold/highThresholdExceeded<\/uei>\\n\" + \n                \"        <description>high loadavg5 threshold exceeded on snmp\\n\" + \n                \"interface<\/description>\\n\" + \n                \"        <rule>(IPADDR IPLIKE *.*.*.*) &amp; (isSNMP )<\/rule>\\n\" + \n                \"        <destinationPath>Email-Network/Systems<\/destinationPath>\\n\" + \n                \"        <text-message>High loadavg5 Threshold exceeded on %interface%,\\n\" + \n                \"%parm[ds]% with %parm[value]%%%<\/text-message>\\n\" + \n                \"        <subject>Notice #%noticeid%, High loadavg5 Threshold\\n\" + \n                \"exceeded<\/subject>\\n\" + \n                \"        <varbind>\\n\" + \n                \"            <vbname>ds<\/vbname>\\n\" + \n                \"            <vbvalue>loadavg5<\/vbvalue>\\n\" + \n                \"        <\/varbind>\\n\" + \n                \"    <\/notification>\" +\n                \"<\/notifications>\";\n        \n        m_notificationManager = new MockNotificationManager(m_notifdConfig, m_db, NOTIFICATION_MANAGER);\n        m_notifd.setNotificationManager(m_notificationManager);\n        \n    }","id":74690,"modified_method":"/**\n     * see http://bugzilla.opennms.org/cgi-bin/bugzilla/show_bug.cgi?id=1022\n     * @throws Exception\n     */\n    public void testWicktorBug() throws Exception {\n\n        m_anticipator.anticipateNotification(createMockNotification(\"High loadavg5 Threshold exceeded\", \"dhustace@nc.rr.com\"));\n        m_anticipator.anticipateNotification(createMockNotification(\"High loadavg5 Threshold exceeded\", \"matt@opennms.org\"));\n\n        MockInterface iface = m_network.getInterface(1, \"192.168.1.1\");\n        Event e = MockUtil.createInterfaceEvent(\"test\", \"uei.opennms.org/threshold/highThresholdExceeded\", iface);\n        MockUtil.addEventParm(e, \"ds\", \"loadavg5\");\n        m_eventMgr.sendNow(e);\n        \n        /*\n         * This is the notification config that Wicktor sent when reporting this bug.\n         * \n         * We need to create and Threshold Exceeded event for loadavg5 to match his\n         * notification name = \"SNMP High loadavg5 Threshold Exceeded\" correctly parsing the varbind.\n         * \n         * What happens (he sent us a patch for this) is that the code does a return instead of a continue\n         * when going through the notification names.\n         */\n        \n        verifyAnticipated(3000);\n        \n        \n    }","commit_id":"acd9f3285ecdc4e0e9424b89d8a97348cd0a8ae4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMockNotificationBasic() throws Exception {\n\n        MockNode node = m_network.getNode(1);\n        NotificationAnticipator na = new NotificationAnticipator();\n        MockNotificationStrategy.setAnticpator(na);\n\n        String subject;\n        String email;\n        MockNotification notification;\n\n        notification = createMockNotification(\"node 1 down.\", \"dhustace@nc.rr.com\");\n        na.anticipateNotification(notification);\n\n        notification = createMockNotification(\"node 1 down.\", \"matt@opennms.org\");\n        na.anticipateNotification(notification);\n\n        //bring node down now\n        m_eventMgr.sendNow(node.createDownEvent());\n\n        assertEquals(\"Expected notifications not forthcoming.\", 0, na.waitForAnticipated(3000).size());\n        sleep(1000);\n        assertEquals(\"Unexpected notifications forthcoming.\", 0, na.getUnanticipated().size());\n        \n        na.reset();\n        \n        notification = createMockNotification(\"node 1 up.\", \"dhustace@nc.rr.com\");\n        na.anticipateNotification(notification);\n\n        notification = createMockNotification(\"node 1 up.\", \"matt@opennms.org\");\n        na.anticipateNotification(notification);\n        \n        //bring node back up now\n        m_eventMgr.sendNow(node.createUpEvent());\n\n        assertEquals(\"Expected notifications not forthcoming.\", 0, na.waitForAnticipated(3000).size());\n        sleep(1000);\n        assertEquals(\"Unexpected notifications forthcoming.\", 0, na.getUnanticipated().size());\n\n    }","id":74691,"modified_method":"public void testMockNotificationBasic() throws Exception {\n\n        MockNode node = m_network.getNode(1);\n\n        String subject;\n        String email;\n        MockNotification notification;\n\n        notification = createMockNotification(\"node 1 down.\", \"dhustace@nc.rr.com\");\n        m_anticipator.anticipateNotification(notification);\n\n        notification = createMockNotification(\"node 1 down.\", \"matt@opennms.org\");\n        m_anticipator.anticipateNotification(notification);\n\n        //bring node down now\n        m_eventMgr.sendNow(node.createDownEvent());\n\n        verifyAnticipated(3000);\n        \n        m_anticipator.reset();\n        \n        notification = createMockNotification(\"node 1 up.\", \"dhustace@nc.rr.com\");\n        m_anticipator.anticipateNotification(notification);\n\n        notification = createMockNotification(\"node 1 up.\", \"matt@opennms.org\");\n        m_anticipator.anticipateNotification(notification);\n        \n        //bring node back up now\n        m_eventMgr.sendNow(node.createUpEvent());\n\n        verifyAnticipated(3000);\n\n    }","commit_id":"acd9f3285ecdc4e0e9424b89d8a97348cd0a8ae4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public void testMockNotificationInitialDelay() throws Exception {\n\n        m_destinationPathManager.getPath(\"Email-Mock\").setInitialDelay(\"10s\");\n        \n        MockNode node = m_network.getNode(1);\n        NotificationAnticipator na = new NotificationAnticipator();\n        MockNotificationStrategy.setAnticpator(na);\n\n        MockNotification notification = new MockNotification();\n        \n        notification = createMockNotification(\"node 1 down.\", \"dhustace@nc.rr.com\");\n        na.anticipateNotification(notification);\n\n        notification = createMockNotification(\"node 1 down.\", \"matt@opennms.org\");\n        na.anticipateNotification(notification);\n\n        m_eventMgr.sendNow(node.createDownEvent());\n\n        assertEquals(\"Expected notifications not forthcoming.\", 2, na.waitForAnticipated(3000).size());\n        sleep(1000);\n        assertEquals(\"Unexpected notifications forthcoming.\", 0, na.getUnanticipated().size());\n\n        assertEquals(\"Expected notifications not forthcoming.\", 0, na.waitForAnticipated(10000).size());\n        sleep(1000);\n        assertEquals(\"Unexpected notifications forthcoming.\", 0, na.getUnanticipated().size());\n\n    }","id":74692,"modified_method":"public void testMockNotificationInitialDelay() throws Exception {\n\n        m_destinationPathManager.getPath(\"Email-Mock\").setInitialDelay(\"10s\");\n        \n        MockNode node = m_network.getNode(1);\n        MockNotification notification = new MockNotification();\n        \n        notification = createMockNotification(\"node 1 down.\", \"dhustace@nc.rr.com\");\n        m_anticipator.anticipateNotification(notification);\n\n        notification = createMockNotification(\"node 1 down.\", \"matt@opennms.org\");\n        m_anticipator.anticipateNotification(notification);\n\n        m_eventMgr.sendNow(node.createDownEvent());\n\n        assertEquals(\"Expected notifications not forthcoming.\", 2, m_anticipator.waitForAnticipated(3000).size());\n        sleep(1000);\n        assertEquals(\"Unexpected notifications forthcoming.\", 0, m_anticipator.getUnanticipated().size());\n\n        verifyAnticipated(10000);\n\n    }","commit_id":"acd9f3285ecdc4e0e9424b89d8a97348cd0a8ae4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"public Notification[] getNotifForEvent(Event event) throws IOException, MarshalException, ValidationException {\n        update();\n    \n        ArrayList notifList = new ArrayList();\n        Notification[] notif = null;\n        // boolean matchAll =\n        // NotifdConfigFactory.getInstance().getConfiguration().getNextNotifId()\n        boolean matchAll = getConfigManager().getNotificationMatch();\n        // ThreadCategory.getInstance(getClass()).debug(\"Notification Event\n        // Match All = \" + matchAll);\n    \n        for (Enumeration e = m_notifications.enumerateNotification(); e.hasMoreElements();) {\n            Notification curNotif = (Notification) e.nextElement();\n    \n            if (curNotif.getStatus().equals(\"on\") && event.getUei().equals(curNotif.getUei()) && nodeInterfaceServiceValid(curNotif, event)) {\n                notifList.add(curNotif);\n                if (!matchAll)\n                    break;\n            }\n        }\n    \n        if (!notifList.isEmpty()) {\n            notif = (Notification[]) notifList.toArray(new Notification[0]);\n        }\n        return notif;\n    }","id":74693,"modified_method":"public Notification[] getNotifForEvent(Event event) throws IOException, MarshalException, ValidationException {\n\n        update();\n        Category log = ThreadCategory.getInstance(getClass());\n    \n        ArrayList notifList = new ArrayList();\n        Notification[] notif = null;\n        boolean matchAll = getConfigManager().getNotificationMatch();\n    \n        for (Enumeration e = m_notifications.enumerateNotification(); e.hasMoreElements();) {\n            Notification curNotif = (Notification) e.nextElement();\n    \n            if (curNotif.getStatus().equals(\"on\") && event.getUei().equals(curNotif.getUei()) && nodeInterfaceServiceValid(curNotif, event)) {\n\n                boolean parmsmatched = getConfigManager().matchNotificationParameters(event, curNotif);\n\n                if (!parmsmatched) {\n                    log.debug(\"Event \" + event.getUei() + \" did not match parameters for notice \" + curNotif.getName());\n                    continue;\n                }\n                notifList.add(curNotif);\n\n                log.debug(\"Event \" + event.getUei() + \" matched notice \" + curNotif.getName());\n                \n                if (!matchAll)\n                    break;\n            }\n        }\n    \n        if (!notifList.isEmpty()) {\n            notif = (Notification[]) notifList.toArray(new Notification[0]);\n        }\n        return notif;\n    }","commit_id":"acd9f3285ecdc4e0e9424b89d8a97348cd0a8ae4","url":"https://github.com/OpenNMS/opennms"},{"original_method":"/**\n   * Cleans up the temp block meta data of a specific user.\n   *\n   * @param userId the ID of the user to cleanup\n   * @return A list of temp blocks removed from this dir\n   */\n  public List<TempBlockMeta> cleanupUser(long userId) {\n    List<TempBlockMeta> blocksToRemove = new ArrayList<TempBlockMeta>();\n    Set<Long> userTempBlocks = mUserIdToTempBlockIdsMap.get(userId);\n    if (userTempBlocks != null) {\n      for (long blockId : userTempBlocks) {\n        TempBlockMeta tempBlock = mBlockIdToTempBlockMap.remove(blockId);\n        if (tempBlock != null) {\n          blocksToRemove.add(tempBlock);\n          reclaimSpace(tempBlock.getBlockSize(), false);\n        } else {\n          LOG.error(\"Cannot find blockId {} when cleanup userId {}\", blockId, userId);\n        }\n      }\n      mUserIdToTempBlockIdsMap.remove(userId);\n    }\n    return blocksToRemove;\n  }","id":74694,"modified_method":"/**\n   * Cleans up the temp block meta data of a specific user.\n   *\n   * @param userId the ID of the user to cleanup\n   * @return A list of temp blocks removed from this dir\n   */\n  public void cleanupUser(long userId) {\n    Set<Long> userTempBlocks = mUserIdToTempBlockIdsMap.get(userId);\n    if (userTempBlocks != null) {\n      for (long blockId : userTempBlocks) {\n        TempBlockMeta tempBlock = mBlockIdToTempBlockMap.remove(blockId);\n        if (tempBlock != null) {\n          reclaimSpace(tempBlock.getBlockSize(), false);\n        } else {\n          LOG.error(\"Cannot find blockId {} when cleanup userId {}\", blockId, userId);\n        }\n      }\n      mUserIdToTempBlockIdsMap.remove(userId);\n    }\n  }","commit_id":"9251e73ef60ff3a6a1eea54c593eb86ce28c1cd0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void cleanupUserTest() throws Exception {\n    // Create blocks under TEST_USER_ID\n    mDir.addBlockMeta(mBlockMeta);\n\n    // Create temp blocks under TEST_USER_ID\n    long tempBlockId1 = TEST_TEMP_BLOCK_ID + 1;\n    long tempBlockId2 = TEST_TEMP_BLOCK_ID + 2;\n    long tempBlockId3 = TEST_TEMP_BLOCK_ID + 3;\n    long otherUserId = TEST_USER_ID + 1;\n\n    TempBlockMeta tempBlockMeta1 =\n        new TempBlockMeta(TEST_USER_ID, tempBlockId1, TEST_TEMP_BLOCK_SIZE, mDir);\n    TempBlockMeta tempBlockMeta2 =\n        new TempBlockMeta(TEST_USER_ID, tempBlockId2, TEST_TEMP_BLOCK_SIZE, mDir);\n    TempBlockMeta tempBlockMeta3 =\n        new TempBlockMeta(otherUserId, tempBlockId3, TEST_TEMP_BLOCK_SIZE, mDir);\n    mDir.addTempBlockMeta(tempBlockMeta1);\n    mDir.addTempBlockMeta(tempBlockMeta2);\n    mDir.addTempBlockMeta(tempBlockMeta3);\n\n    List<TempBlockMeta> actual = mDir.cleanupUser(TEST_USER_ID);\n    Assert.assertEquals(Sets.newHashSet(tempBlockMeta1, tempBlockMeta2),\n        new HashSet<TempBlockMeta>(actual));\n    // Two temp blocks created by TEST_USER_ID are expected to be removed\n    Assert.assertFalse(mDir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(mDir.hasTempBlockMeta(tempBlockId2));\n    // Temp block created by otherUserId is expected to stay\n    Assert.assertTrue(mDir.hasTempBlockMeta(tempBlockId3));\n    // Block created by TEST_USER_ID is expected to stay\n    Assert.assertTrue(mDir.hasBlockMeta(TEST_BLOCK_ID));\n  }","id":74695,"modified_method":"@Test\n  public void cleanupUserTest() throws Exception {\n    // Create blocks under TEST_USER_ID\n    mDir.addBlockMeta(mBlockMeta);\n\n    // Create temp blocks under TEST_USER_ID\n    long tempBlockId1 = TEST_TEMP_BLOCK_ID + 1;\n    long tempBlockId2 = TEST_TEMP_BLOCK_ID + 2;\n    long tempBlockId3 = TEST_TEMP_BLOCK_ID + 3;\n    long otherUserId = TEST_USER_ID + 1;\n\n    TempBlockMeta tempBlockMeta1 =\n        new TempBlockMeta(TEST_USER_ID, tempBlockId1, TEST_TEMP_BLOCK_SIZE, mDir);\n    TempBlockMeta tempBlockMeta2 =\n        new TempBlockMeta(TEST_USER_ID, tempBlockId2, TEST_TEMP_BLOCK_SIZE, mDir);\n    TempBlockMeta tempBlockMeta3 =\n        new TempBlockMeta(otherUserId, tempBlockId3, TEST_TEMP_BLOCK_SIZE, mDir);\n    mDir.addTempBlockMeta(tempBlockMeta1);\n    mDir.addTempBlockMeta(tempBlockMeta2);\n    mDir.addTempBlockMeta(tempBlockMeta3);\n\n    // Check the temporary blocks belonging to TEST_USER_ID\n    List<TempBlockMeta> actual = mDir.getUserTempBlocks(TEST_USER_ID);\n    Assert.assertEquals(Sets.newHashSet(tempBlockMeta1, tempBlockMeta2),\n        new HashSet<TempBlockMeta>(actual));\n    Assert.assertTrue(mDir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertTrue(mDir.hasTempBlockMeta(tempBlockId2));\n\n    // Two temp blocks created by TEST_USER_ID are expected to be removed\n    mDir.cleanupUser(TEST_USER_ID);\n    Assert.assertFalse(mDir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(mDir.hasTempBlockMeta(tempBlockId2));\n    // Temp block created by otherUserId is expected to stay\n    Assert.assertTrue(mDir.hasTempBlockMeta(tempBlockId3));\n    // Block created by TEST_USER_ID is expected to stay\n    Assert.assertTrue(mDir.hasBlockMeta(TEST_BLOCK_ID));\n  }","commit_id":"9251e73ef60ff3a6a1eea54c593eb86ce28c1cd0","url":"https://github.com/amplab/tachyon"},{"original_method":"public synchronized List<TempBlockMeta> getUserTempBlocks(long userId) {\n    List<TempBlockMeta> userTempBlocks = new ArrayList<TempBlockMeta>();\n    for (StorageTier tier : mTiers) {\n      for (StorageDir dir : tier.getStorageDirs()) {\n        userTempBlocks.addAll(dir.getUserTempBlocks(userId));\n      }\n    }\n    return userTempBlocks;\n  }","id":74696,"modified_method":"/**\n   * Gets all the temporary blocks associated with a user, empty list is returned if the user has\n   * no temporary blocks.\n   *\n   * @param userId the ID of the user\n   * @return A list of temp blocks associated with the user\n   */\n  public synchronized List<TempBlockMeta> getUserTempBlocks(long userId) {\n    List<TempBlockMeta> userTempBlocks = new ArrayList<TempBlockMeta>();\n    for (StorageTier tier : mTiers) {\n      for (StorageDir dir : tier.getStorageDirs()) {\n        userTempBlocks.addAll(dir.getUserTempBlocks(userId));\n      }\n    }\n    return userTempBlocks;\n  }","commit_id":"b3238415726c3de0768fc85f765e04a47d3ba9a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Test\n  public void cleanupUserTest() throws Exception {\n    StorageDir dir = mMetaManager.getTier(1).getDir(0);\n    final long tempBlockId1 = 1;\n    final long tempBlockId2 = 2;\n    final long tempBlockId3 = 3;\n    final long userId1 = 100;\n    final long userId2 = 200;\n    TempBlockMeta tempBlockMeta1 = new TempBlockMeta(userId1, tempBlockId1, TEST_BLOCK_SIZE, dir);\n    TempBlockMeta tempBlockMeta2 = new TempBlockMeta(userId1, tempBlockId2, TEST_BLOCK_SIZE, dir);\n    TempBlockMeta tempBlockMeta3 = new TempBlockMeta(userId2, tempBlockId3, TEST_BLOCK_SIZE, dir);\n    BlockMeta blockMeta = new BlockMeta(TEST_BLOCK_ID, TEST_BLOCK_SIZE, dir);\n    dir.addTempBlockMeta(tempBlockMeta1);\n    dir.addTempBlockMeta(tempBlockMeta2);\n    dir.addTempBlockMeta(tempBlockMeta3);\n    dir.addBlockMeta(blockMeta);\n\n    // Cleanup userId1, expect to remove tempBlock1 and tempBlock2\n    List<TempBlockMeta> toRemove = mMetaManager.cleanupUser(userId1);\n    Assert.assertEquals(Sets.newHashSet(tempBlockMeta1, tempBlockMeta2),\n        new HashSet<TempBlockMeta>(toRemove));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId2));\n    Assert.assertTrue(dir.hasTempBlockMeta(tempBlockId3));\n    Assert.assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));\n\n    // Cleanup userId1 again, expect to remove nothing\n    toRemove = mMetaManager.cleanupUser(userId1);\n    Assert.assertEquals(Sets.newHashSet(), new HashSet<TempBlockMeta>(toRemove));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId2));\n    Assert.assertTrue(dir.hasTempBlockMeta(tempBlockId3));\n    Assert.assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));\n\n    // Cleanup userId2, expect to remove tempBlock3\n    toRemove = mMetaManager.cleanupUser(userId2);\n    Assert.assertEquals(Sets.newHashSet(tempBlockMeta3), new HashSet<TempBlockMeta>(toRemove));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId2));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId3));\n    Assert.assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));\n  }","id":74697,"modified_method":"@Test\n  public void cleanupUserTest() throws Exception {\n    StorageDir dir = mMetaManager.getTier(1).getDir(0);\n    final long tempBlockId1 = 1;\n    final long tempBlockId2 = 2;\n    final long tempBlockId3 = 3;\n    final long userId1 = 100;\n    final long userId2 = 200;\n    TempBlockMeta tempBlockMeta1 = new TempBlockMeta(userId1, tempBlockId1, TEST_BLOCK_SIZE, dir);\n    TempBlockMeta tempBlockMeta2 = new TempBlockMeta(userId1, tempBlockId2, TEST_BLOCK_SIZE, dir);\n    TempBlockMeta tempBlockMeta3 = new TempBlockMeta(userId2, tempBlockId3, TEST_BLOCK_SIZE, dir);\n    BlockMeta blockMeta = new BlockMeta(TEST_BLOCK_ID, TEST_BLOCK_SIZE, dir);\n    dir.addTempBlockMeta(tempBlockMeta1);\n    dir.addTempBlockMeta(tempBlockMeta2);\n    dir.addTempBlockMeta(tempBlockMeta3);\n    dir.addBlockMeta(blockMeta);\n\n    // Get temp blocks for userId1, expect to get tempBlock1 and tempBlock2\n    List<TempBlockMeta> toRemove = mMetaManager.getUserTempBlocks(userId1);\n    Assert.assertEquals(Sets.newHashSet(tempBlockMeta1, tempBlockMeta2),\n        new HashSet<TempBlockMeta>(toRemove));\n    Assert.assertTrue(dir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertTrue(dir.hasTempBlockMeta(tempBlockId2));\n\n    // Clean up userId1, expect tempBlock1 and tempBlock2 to be removed.\n    mMetaManager.cleanupUser(userId1);\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId2));\n    Assert.assertTrue(dir.hasTempBlockMeta(tempBlockId3));\n    Assert.assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));\n\n    // Get temp blocks for userId1 again, expect to get nothing\n    toRemove = mMetaManager.getUserTempBlocks(userId1);\n    Assert.assertEquals(Sets.<TempBlockMeta>newHashSet(), new HashSet<TempBlockMeta>(toRemove));\n\n    // Clean up userId1 again, expect nothing to happen\n    mMetaManager.cleanupUser(userId1);\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId2));\n    Assert.assertTrue(dir.hasTempBlockMeta(tempBlockId3));\n    Assert.assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));\n\n    // Get temp blocks for userId2, expect to get tempBlock3\n    toRemove = mMetaManager.getUserTempBlocks(userId2);\n    Assert.assertEquals(Sets.newHashSet(tempBlockMeta3), new HashSet<TempBlockMeta>(toRemove));\n    Assert.assertTrue(dir.hasTempBlockMeta(tempBlockId3));\n\n    // Clean up userId2, expect tempBlock3 to be removed\n    mMetaManager.cleanupUser(userId2);\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId1));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId2));\n    Assert.assertFalse(dir.hasTempBlockMeta(tempBlockId3));\n    Assert.assertTrue(dir.hasBlockMeta(TEST_BLOCK_ID));\n  }","commit_id":"b3238415726c3de0768fc85f765e04a47d3ba9a0","url":"https://github.com/amplab/tachyon"},{"original_method":"@Override\n  public void cleanupUser(long userId) throws IOException {\n    mEvictionLock.readLock().lock();\n    List<TempBlockMeta> tempBlocksToRemove = mMetaManager.cleanupUser(userId);\n    mLockManager.cleanupUser(userId);\n    mEvictionLock.readLock().unlock();\n\n    // TODO: fix the block removing below, there is possible risk condition when the client which\n    // is considered \"dead\" may still be using or committing this block.\n    // A user may have multiple temporary directories for temp blocks, in diffrent StorageTier\n    // and StorageDir.\n    Set<String> dirs = new HashSet<String>(tempBlocksToRemove.size());\n    for (TempBlockMeta tempBlockMeta : tempBlocksToRemove) {\n      String fileName = tempBlockMeta.getPath();\n      try {\n        String dirName = CommonUtils.getParent(fileName);\n        dirs.add(dirName);\n      } catch (InvalidPathException e) {\n        LOG.error(\"Error in cleanup userId {}: cannot parse parent dir of {}\", userId, fileName);\n      }\n      if (!new File(fileName).delete()) {\n        LOG.error(\"Error in cleanup userId {}: cannot delete file {}\", userId, fileName);\n      }\n    }\n    // TODO: Cleanup the user folder across tiered storage.\n    for (String dirName : dirs) {\n      if (!new File(dirName).delete()) {\n        LOG.error(\"Error in cleanup userId {}: cannot delete directory \", userId, dirName);\n      }\n    }\n  }","id":74698,"modified_method":"@Override\n  public void cleanupUser(long userId) throws IOException {\n    List<TempBlockMeta> tempBlocksToRemove = mMetaManager.getUserTempBlocks(userId);\n    // TODO: fix the block removing below, there is possible risk condition when the client which\n    // is considered \"dead\" may still be using or committing this block.\n    // A user may have multiple temporary directories for temp blocks, in diffrent StorageTier\n    // and StorageDir.\n    Set<String> dirs = new HashSet<String>(tempBlocksToRemove.size());\n    for (TempBlockMeta tempBlockMeta : tempBlocksToRemove) {\n      String fileName = tempBlockMeta.getPath();\n      try {\n        String dirName = CommonUtils.getParent(fileName);\n        dirs.add(dirName);\n      } catch (InvalidPathException e) {\n        LOG.error(\"Error in cleanup userId {}: cannot parse parent dir of {}\", userId, fileName);\n      }\n      if (!new File(fileName).delete()) {\n        LOG.error(\"Error in cleanup userId {}: cannot delete file {}\", userId, fileName);\n      }\n    }\n    // TODO: Cleanup the user folder across tiered storage.\n    for (String dirName : dirs) {\n      if (!new File(dirName).delete()) {\n        LOG.error(\"Error in cleanup userId {}: cannot delete directory \", userId, dirName);\n      }\n    }\n\n    mEvictionLock.readLock().lock();\n    mMetaManager.cleanupUser(userId);\n    mLockManager.cleanupUser(userId);\n    mEvictionLock.readLock().unlock();\n  }","commit_id":"1dca9c50671a2a3af4d6fba91ffce3d38e4bce4d","url":"https://github.com/amplab/tachyon"},{"original_method":"@Inject\n   public EditingPreferencesPane(UIPrefs prefs,\n                                 PreferencesDialogResources res)\n   {\n      prefs_ = prefs;\n      PreferencesDialogBaseResources baseRes = PreferencesDialogBaseResources.INSTANCE;\n      \n      VerticalPanel editingPanel = new VerticalPanel();\n      editingPanel.add(headerLabel(\"General\"));\n      editingPanel.add(tight(spacesForTab_ = checkboxPref(\"Insert spaces for tab\", prefs.useSpacesForTab())));\n      editingPanel.add(indent(tabWidth_ = numericPref(\"Tab width\", prefs.numSpacesForTab())));   \n      editingPanel.add(checkboxPref(\"Insert matching parens/quotes\", prefs_.insertMatching()));\n      editingPanel.add(checkboxPref(\"Auto-indent code after paste\", prefs_.reindentOnPaste()));\n      editingPanel.add(checkboxPref(\"Vertically align arguments in auto-indent\", prefs_.verticallyAlignArgumentIndent()));\n      editingPanel.add(checkboxPref(\"Soft-wrap R source files\", prefs_.softWrapRFiles()));\n      editingPanel.add(checkboxPref(\"Ensure that source files end with newline\", prefs_.autoAppendNewline()));\n      editingPanel.add(checkboxPref(\"Strip trailing horizontal whitespace when saving\", prefs_.stripTrailingWhitespace()));\n      editingPanel.add(checkboxPref(\"Focus console after executing from source\", prefs_.focusConsoleAfterExec()));\n      editingPanel.add(checkboxPref(\n            \"Continue comment when inserting new line\",\n            prefs_.continueCommentsOnNewline(),\n            \"When enabled, pressing enter will continue comments on new lines. Press Shift + Enter to exit a comment.\"));\n      editingPanel.add(spaced(checkboxPref(\"Enable vim editing mode\", prefs_.useVimMode())));\n      \n      Label snippetsLabel = headerLabel(\"Snippets\");\n      snippetsLabel.getElement().getStyle().setMarginTop(8, Unit.PX);\n      editingPanel.add(snippetsLabel);\n      editingPanel.add(checkboxPref(\"Enable code snippets\", prefs_.enableSnippets(), null, \"code_snippets\"));\n      \n      \n      VerticalPanel displayPanel = new VerticalPanel();\n      displayPanel.add(checkboxPref(\"Highlight selected word\", prefs.highlightSelectedWord()));\n      displayPanel.add(checkboxPref(\"Highlight selected line\", prefs.highlightSelectedLine()));\n      displayPanel.add(checkboxPref(\"Show line numbers\", prefs.showLineNumbers()));\n      displayPanel.add(tight(showMargin_ = checkboxPref(\"Show margin\", prefs.showMargin())));\n      displayPanel.add(indent(marginCol_ = numericPref(\"Margin column\", prefs.printMarginColumn())));\n      displayPanel.add(checkboxPref(\"Show whitespace characters\", prefs_.showInvisibles()));\n      displayPanel.add(checkboxPref(\"Show indent guides\", prefs_.showIndentGuides()));\n      displayPanel.add(checkboxPref(\"Blinking cursor\", prefs_.blinkingCursor()));\n      displayPanel.add(checkboxPref(\"Show syntax highlighting in console input\", prefs_.syntaxColorConsole()));\n      \n      VerticalPanel completionPanel = new VerticalPanel();\n      \n      completionPanel.add(headerLabel(\"R and C/C++\"));\n     \n      showCompletions_ = new SelectWidget(\n            \"Show code completions:\",\n            new String[] {\n                  \"Automatically\",\n                  \"When Triggered ($, ::)\",\n                  \"Manually (Tab)\"\n            },\n            new String[] {\n                  UIPrefsAccessor.COMPLETION_ALWAYS,\n                  UIPrefsAccessor.COMPLETION_WHEN_TRIGGERED,\n                  UIPrefsAccessor.COMPLETION_MANUAL\n            },\n            false, \n            true, \n            false);\n      \n      spaced(showCompletions_);\n      completionPanel.add(showCompletions_);    \n      \n      final CheckBox alwaysCompleteInConsole = checkboxPref(\n            \"Allow automatic completions in console\",\n            prefs.alwaysCompleteInConsole());\n      completionPanel.add(alwaysCompleteInConsole);\n      \n      showCompletions_.addChangeHandler(new ChangeHandler()\n      {\n         @Override\n         public void onChange(ChangeEvent event)\n         {\n            alwaysCompleteInConsole.setVisible(\n                   showCompletions_.getValue().equals(\n                                        UIPrefsAccessor.COMPLETION_ALWAYS));\n            \n         }\n      });\n    \n      final CheckBox insertParensAfterFunctionCompletionsCheckbox =\n           checkboxPref(\"Insert parentheses after function completions\",\n                 prefs.insertParensAfterFunctionCompletion());\n      \n      final CheckBox showSignatureTooltipsCheckbox =\n           checkboxPref(\"Show help tooltip after function completions\",\n                 prefs.showSignatureTooltips());\n      \n      addEnabledDependency(\n            insertParensAfterFunctionCompletionsCheckbox,\n            showSignatureTooltipsCheckbox);\n      \n      completionPanel.add(insertParensAfterFunctionCompletionsCheckbox);\n      completionPanel.add(showSignatureTooltipsCheckbox);\n      \n      completionPanel.add(checkboxPref(\"Insert spaces around equals for argument completions\", prefs.insertSpacesAroundEquals()));\n      completionPanel.add(checkboxPref(\"Use tab for multiline autocompletions\", prefs.allowTabMultilineCompletion()));\n      \n      \n      Label otherLabel = headerLabel(\"Other Languages\");\n      otherLabel.getElement().getStyle().setMarginTop(8, Unit.PX);\n      completionPanel.add(otherLabel);\n      \n      showCompletionsOther_ = new SelectWidget(\n            \"Show code completions:\",\n            new String[] {\n                  \"Automatically\",\n                  \"Manually (Ctrl+Space) \"\n            },\n            new String[] {\n                  UIPrefsAccessor.COMPLETION_ALWAYS,\n                  UIPrefsAccessor.COMPLETION_MANUAL\n            },\n            false, \n            true, \n            false);\n      completionPanel.add(showCompletionsOther_);\n      \n      Label otherTip = new Label(\n        \"Keyword and text-based completions are supported for several other \" +\n        \"languages including JavaScript, HTML, CSS, Python, and SQL.\");\n      otherTip.addStyleName(baseRes.styles().infoLabel());\n      completionPanel.add(nudgeRightPlus(otherTip));\n      \n      \n      Label delayLabel = headerLabel(\"Completion Delay\");\n      delayLabel.getElement().getStyle().setMarginTop(14, Unit.PX);\n      completionPanel.add(delayLabel);\n      \n      completionPanel.add(nudgeRightPlus(alwaysCompleteChars_ =\n          numericPref(\"Show completions after characters entered:\",\n                      prefs.alwaysCompleteCharacters())));\n      completionPanel.add(nudgeRightPlus(alwaysCompleteDelayMs_ = \n          numericPref(\"Show completions after keyboard idle (ms):\",\n                      prefs.alwaysCompleteDelayMs())));\n        \n      \n      VerticalPanel diagnosticsPanel = new VerticalPanel();\n      \n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics for R\", prefs.showDiagnosticsR()));\n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics for C/C++\", prefs.showDiagnosticsCpp()));\n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics for JavaScript, HTML, and CSS\", prefs.showDiagnosticsOther()));\n    \n      diagnosticsPanel.add(checkboxPref(\"Provide R style diagnostics (e.g. whitespace)\", prefs.enableStyleDiagnostics()));\n      diagnosticsPanel.add(checkboxPref(\"Enable diagnostics within R function calls\", prefs.diagnosticsInRFunctionCalls()));\n      \n\n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics whenever source files are saved\", prefs.diagnosticsOnSave()));\n      diagnosticsPanel.add(tight(checkboxPref(\"Show diagnostics after keyboard is idle for a period of time\", prefs.enableBackgroundDiagnostics())));\n      diagnosticsPanel.add(indent(backgroundDiagnosticsDelayMs_ =\n            numericPref(\"Keyboard idle time (ms):\", prefs.backgroundDiagnosticsDelayMs())));\n      \n      \n      DialogTabLayoutPanel tabPanel = new DialogTabLayoutPanel();\n      tabPanel.setSize(\"435px\", \"498px\");\n      tabPanel.add(editingPanel, \"Editing\");\n      tabPanel.add(displayPanel, \"Display\");\n      tabPanel.add(completionPanel, \"Completion\");\n      tabPanel.add(diagnosticsPanel, \"Diagnostics\");\n      tabPanel.selectTab(0);\n      add(tabPanel);\n   }","id":74699,"modified_method":"@Inject\n   public EditingPreferencesPane(UIPrefs prefs,\n                                 PreferencesDialogResources res)\n   {\n      prefs_ = prefs;\n      PreferencesDialogBaseResources baseRes = PreferencesDialogBaseResources.INSTANCE;\n      \n      VerticalPanel editingPanel = new VerticalPanel();\n      editingPanel.add(headerLabel(\"General\"));\n      editingPanel.add(tight(spacesForTab_ = checkboxPref(\"Insert spaces for tab\", prefs.useSpacesForTab())));\n      editingPanel.add(indent(tabWidth_ = numericPref(\"Tab width\", prefs.numSpacesForTab())));   \n      editingPanel.add(checkboxPref(\"Insert matching parens/quotes\", prefs_.insertMatching()));\n      editingPanel.add(checkboxPref(\"Auto-indent code after paste\", prefs_.reindentOnPaste()));\n      editingPanel.add(checkboxPref(\"Vertically align arguments in auto-indent\", prefs_.verticallyAlignArgumentIndent()));\n      editingPanel.add(checkboxPref(\"Soft-wrap R source files\", prefs_.softWrapRFiles()));\n      editingPanel.add(checkboxPref(\"Ensure that source files end with newline\", prefs_.autoAppendNewline()));\n      editingPanel.add(checkboxPref(\"Strip trailing horizontal whitespace when saving\", prefs_.stripTrailingWhitespace()));\n      editingPanel.add(checkboxPref(\"Focus console after executing from source\", prefs_.focusConsoleAfterExec()));\n      editingPanel.add(checkboxPref(\n            \"Continue comment when inserting new line\",\n            prefs_.continueCommentsOnNewline(),\n            \"When enabled, pressing enter will continue comments on new lines. Press Shift + Enter to exit a comment.\"));\n      editingPanel.add(checkboxPref(\"Enable vim editing mode\", prefs_.useVimMode()));\n     \n      \n    \n      \n      Label snippetsLabel = headerLabel(\"Snippets\");\n      snippetsLabel.getElement().getStyle().setMarginTop(8, Unit.PX);\n      editingPanel.add(snippetsLabel);\n      \n      HorizontalPanel panel = new HorizontalPanel();\n      CheckBox enableSnippets = checkboxPref(\"Enable code snippets\", prefs_.enableSnippets());\n      panel.add(enableSnippets);\n     \n      SmallButton editSnippets = new SmallButton(\"Edit Snippets...\");\n      editSnippets.getElement().getStyle().setMarginTop(1, Unit.PX);\n      editSnippets.getElement().getStyle().setMarginLeft(5, Unit.PX);\n      editSnippets.addClickHandler(new ClickHandler() {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            new EditSnippetsPanel().center();\n         }\n      });\n      panel.add(editSnippets);\n      \n      HelpButton snippetHelp = new HelpButton(\"code_snippets\");\n      snippetHelp.getElement().getStyle().setMarginTop(2, Unit.PX);\n      snippetHelp.getElement().getStyle().setMarginLeft(6, Unit.PX);\n      panel.add(snippetHelp);\n      \n      editingPanel.add(panel);\n      \n      \n      \n      VerticalPanel displayPanel = new VerticalPanel();\n      displayPanel.add(checkboxPref(\"Highlight selected word\", prefs.highlightSelectedWord()));\n      displayPanel.add(checkboxPref(\"Highlight selected line\", prefs.highlightSelectedLine()));\n      displayPanel.add(checkboxPref(\"Show line numbers\", prefs.showLineNumbers()));\n      displayPanel.add(tight(showMargin_ = checkboxPref(\"Show margin\", prefs.showMargin())));\n      displayPanel.add(indent(marginCol_ = numericPref(\"Margin column\", prefs.printMarginColumn())));\n      displayPanel.add(checkboxPref(\"Show whitespace characters\", prefs_.showInvisibles()));\n      displayPanel.add(checkboxPref(\"Show indent guides\", prefs_.showIndentGuides()));\n      displayPanel.add(checkboxPref(\"Blinking cursor\", prefs_.blinkingCursor()));\n      displayPanel.add(checkboxPref(\"Show syntax highlighting in console input\", prefs_.syntaxColorConsole()));\n      \n      VerticalPanel completionPanel = new VerticalPanel();\n      \n      completionPanel.add(headerLabel(\"R and C/C++\"));\n     \n      showCompletions_ = new SelectWidget(\n            \"Show code completions:\",\n            new String[] {\n                  \"Automatically\",\n                  \"When Triggered ($, ::)\",\n                  \"Manually (Tab)\"\n            },\n            new String[] {\n                  UIPrefsAccessor.COMPLETION_ALWAYS,\n                  UIPrefsAccessor.COMPLETION_WHEN_TRIGGERED,\n                  UIPrefsAccessor.COMPLETION_MANUAL\n            },\n            false, \n            true, \n            false);\n      \n      spaced(showCompletions_);\n      completionPanel.add(showCompletions_);    \n      \n      final CheckBox alwaysCompleteInConsole = checkboxPref(\n            \"Allow automatic completions in console\",\n            prefs.alwaysCompleteInConsole());\n      completionPanel.add(alwaysCompleteInConsole);\n      \n      showCompletions_.addChangeHandler(new ChangeHandler()\n      {\n         @Override\n         public void onChange(ChangeEvent event)\n         {\n            alwaysCompleteInConsole.setVisible(\n                   showCompletions_.getValue().equals(\n                                        UIPrefsAccessor.COMPLETION_ALWAYS));\n            \n         }\n      });\n    \n      final CheckBox insertParensAfterFunctionCompletionsCheckbox =\n           checkboxPref(\"Insert parentheses after function completions\",\n                 prefs.insertParensAfterFunctionCompletion());\n      \n      final CheckBox showSignatureTooltipsCheckbox =\n           checkboxPref(\"Show help tooltip after function completions\",\n                 prefs.showSignatureTooltips());\n      \n      addEnabledDependency(\n            insertParensAfterFunctionCompletionsCheckbox,\n            showSignatureTooltipsCheckbox);\n      \n      completionPanel.add(insertParensAfterFunctionCompletionsCheckbox);\n      completionPanel.add(showSignatureTooltipsCheckbox);\n      \n      completionPanel.add(checkboxPref(\"Insert spaces around equals for argument completions\", prefs.insertSpacesAroundEquals()));\n      completionPanel.add(checkboxPref(\"Use tab for multiline autocompletions\", prefs.allowTabMultilineCompletion()));\n      \n      \n      Label otherLabel = headerLabel(\"Other Languages\");\n      otherLabel.getElement().getStyle().setMarginTop(8, Unit.PX);\n      completionPanel.add(otherLabel);\n      \n      showCompletionsOther_ = new SelectWidget(\n            \"Show code completions:\",\n            new String[] {\n                  \"Automatically\",\n                  \"Manually (Ctrl+Space) \"\n            },\n            new String[] {\n                  UIPrefsAccessor.COMPLETION_ALWAYS,\n                  UIPrefsAccessor.COMPLETION_MANUAL\n            },\n            false, \n            true, \n            false);\n      completionPanel.add(showCompletionsOther_);\n      \n      Label otherTip = new Label(\n        \"Keyword and text-based completions are supported for several other \" +\n        \"languages including JavaScript, HTML, CSS, Python, and SQL.\");\n      otherTip.addStyleName(baseRes.styles().infoLabel());\n      completionPanel.add(nudgeRightPlus(otherTip));\n      \n      \n      Label delayLabel = headerLabel(\"Completion Delay\");\n      delayLabel.getElement().getStyle().setMarginTop(14, Unit.PX);\n      completionPanel.add(delayLabel);\n      \n      completionPanel.add(nudgeRightPlus(alwaysCompleteChars_ =\n          numericPref(\"Show completions after characters entered:\",\n                      prefs.alwaysCompleteCharacters())));\n      completionPanel.add(nudgeRightPlus(alwaysCompleteDelayMs_ = \n          numericPref(\"Show completions after keyboard idle (ms):\",\n                      prefs.alwaysCompleteDelayMs())));\n        \n      \n      VerticalPanel diagnosticsPanel = new VerticalPanel();\n      \n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics for R\", prefs.showDiagnosticsR()));\n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics for C/C++\", prefs.showDiagnosticsCpp()));\n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics for JavaScript, HTML, and CSS\", prefs.showDiagnosticsOther()));\n    \n      diagnosticsPanel.add(checkboxPref(\"Provide R style diagnostics (e.g. whitespace)\", prefs.enableStyleDiagnostics()));\n      diagnosticsPanel.add(checkboxPref(\"Enable diagnostics within R function calls\", prefs.diagnosticsInRFunctionCalls()));\n      \n\n      diagnosticsPanel.add(checkboxPref(\"Show diagnostics whenever source files are saved\", prefs.diagnosticsOnSave()));\n      diagnosticsPanel.add(tight(checkboxPref(\"Show diagnostics after keyboard is idle for a period of time\", prefs.enableBackgroundDiagnostics())));\n      diagnosticsPanel.add(indent(backgroundDiagnosticsDelayMs_ =\n            numericPref(\"Keyboard idle time (ms):\", prefs.backgroundDiagnosticsDelayMs())));\n      \n      \n      DialogTabLayoutPanel tabPanel = new DialogTabLayoutPanel();\n      tabPanel.setSize(\"435px\", \"498px\");\n      tabPanel.add(editingPanel, \"Editing\");\n      tabPanel.add(displayPanel, \"Display\");\n      tabPanel.add(completionPanel, \"Completion\");\n      tabPanel.add(diagnosticsPanel, \"Diagnostics\");\n      tabPanel.selectTab(0);\n      add(tabPanel);\n   }","commit_id":"f30de68a858094bc099fb6321cc0572956f9c58b","url":"https://github.com/rstudio/rstudio"},{"original_method":"public FullscreenPopupPanel(Widget titleWidget, \n                               Widget mainWidget,\n                               boolean closeOnEscape)\n   {\n      super(false, false, closeOnEscape);\n      \n      NineUpBorder border = new NineUpBorder(RES, 32, 20, 17, 20);\n      if (titleWidget != null)\n         addTitleWidget(border, titleWidget);\n      addCloseButton(border);\n      border.setSize(\"100%\", \"100%\");\n      border.setFillColor(\"white\");\n      border.setWidget(mainWidget);\n      setWidget(border);\n      setGlassEnabled(true);\n\n      Style popupStyle = getElement().getStyle();\n      popupStyle.setZIndex(1001);\n      popupStyle.setPosition(Style.Position.ABSOLUTE);\n      popupStyle.setTop(0, Unit.PX);\n      popupStyle.setBottom(0, Unit.PX);\n      popupStyle.setLeft(0, Unit.PX);\n      popupStyle.setRight(0, Unit.PX);\n\n      Style contentStyle =\n            ((Element) getElement().getFirstChild()).getStyle();\n      contentStyle.setWidth(100, Unit.PCT);\n      contentStyle.setHeight(100, Unit.PCT);\n   }","id":74700,"modified_method":"public FullscreenPopupPanel(Widget titleWidget, \n                               Widget mainWidget,\n                               boolean closeOnEscape)\n   {\n      this(titleWidget, mainWidget, 0, closeOnEscape);\n   }","commit_id":"f30de68a858094bc099fb6321cc0572956f9c58b","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public HTMLPreviewPresenter(Display view,\n                               Binder binder,\n                               final Commands commands,\n                               GlobalDisplay globalDisplay,\n                               EventBus eventBus,\n                               Satellite satellite,\n                               Session session,\n                               FileDialogs fileDialogs,\n                               RemoteFileSystemContext fileSystemContext,\n                               HTMLPreviewServerOperations server,\n                               RPubsPresenter rpubsPresenter,\n                               Provider<FileExport> pFileExport)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      server_ = server;\n      session_ = session;\n      fileDialogs_ = fileDialogs;\n      fileSystemContext_ = fileSystemContext;\n      pFileExport_ = pFileExport;\n      \n      rpubsPresenter.setContext(this);\n      \n      binder.bind(commands, this);  \n      \n      // disable rpubs if requested\n      if (!session.getSessionInfo().getAllowRpubsPublish())\n      {\n         commands.publishHTML().remove();\n      }\n      \n      // map Ctrl-R to our internal refresh handler\n      Event.addNativePreviewHandler(new NativePreviewHandler() {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            if (event.getTypeInt() == Event.ONKEYDOWN)\n            {\n               NativeEvent ne = event.getNativeEvent();\n               int mod = KeyboardShortcut.getModifierValue(ne);\n               if ((mod == KeyboardShortcut.META || \n                   (mod == KeyboardShortcut.CTRL && !BrowseCap.hasMetaKey()))\n                   && ne.getKeyCode() == 'R')\n               {\n                  ne.preventDefault();\n                  ne.stopPropagation();\n                  commands.refreshHtmlPreview().execute();\n               }\n            }\n         }\n      });\n      \n      satellite.addCloseHandler(new CloseHandler<Satellite>()\n      {\n         @Override\n         public void onClose(CloseEvent<Satellite> event)\n         {\n            if (previewRunning_)\n               terminateRunningPreview();\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewStartedEvent.TYPE,\n                          new HTMLPreviewStartedEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewStarted(HTMLPreviewStartedEvent event)\n         {\n            previewRunning_ = true;\n            lastPreviewOutput_ = new StringBuilder();\n            view_.showProgress(\"Knitting...\");\n            view_.addProgressClickHandler(new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (previewRunning_)\n                     terminateRunningPreview();\n                  else\n                     view_.closeProgress();\n               }\n               \n            });\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewOutputEvent.TYPE, \n                          new HTMLPreviewOutputEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewOutput(HTMLPreviewOutputEvent event)\n         {\n            String output = event.getOutput();\n            view_.showProgressOutput(output);\n            lastPreviewOutput_.append(output);\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewCompletedEvent.TYPE, \n                          new HTMLPreviewCompletedEvent.Handler()\n      { \n         @Override\n         public void onHTMLPreviewCompleted(HTMLPreviewCompletedEvent event)\n         {\n            previewRunning_ = false;\n            \n            HTMLPreviewResult result = event.getResult();           \n            if (result.getSucceeded())\n            {\n               lastSuccessfulPreview_ = result;\n               view_.closeProgress();\n               view_.showPreview(\n                  server_.getApplicationURL(result.getPreviewURL()),\n                  result.getHtmlFile(),\n                  result.getEnableSaveAs(),\n                  isMarkdownFile(result.getSourceFile()) &&\n                  session_.getSessionInfo().getAllowRpubsPublish(),\n                  result.getEnableRefresh(),\n                  lastPreviewOutput_.length() > 0);\n\n               isPublished_ = result.getPreviouslyPublished();\n               if (isPublished_)\n                  view_.setPublishButtonLabel(\"Republish\");\n            }\n            else\n            {\n               view_.setProgressCaption(\"Preview failed\");\n               view_.stopProgress();\n            }\n         }\n      });\n\n      eventBus.addHandler(RPubsUploadStatusEvent.TYPE,\n                          new org.rstudio.studio.client.common.rpubs.events.RPubsUploadStatusEvent.Handler()\n      {\n         @Override\n         public void onRPubsPublishStatus(\n               RPubsUploadStatusEvent event)\n         {\n            // make sure it applies to our context\n            RPubsUploadStatusEvent.Status status = event.getStatus();\n            if (!status.getContextId().equals(getContextId()))\n               return;\n            \n            if (StringUtil.isNullOrEmpty(status.getError())\n                && !isPublished_)\n            {\n               isPublished_ = true;\n               view_.setPublishButtonLabel(\"Republish\");\n            }\n         }\n      });\n      \n      new StringStateValue(\n            MODULE_HTML_PREVIEW,\n            KEY_SAVEAS_DIR,\n            ClientState.PERSISTENT,\n            session_.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(String value)\n         {\n            savePreviewDir_ = value;\n         }\n\n         @Override\n         protected String getValue()\n         {\n            return savePreviewDir_;\n         }\n      };\n   }","id":74701,"modified_method":"@Inject\n   public HTMLPreviewPresenter(Display view,\n                               Binder binder,\n                               final Commands commands,\n                               GlobalDisplay globalDisplay,\n                               EventBus eventBus,\n                               Satellite satellite,\n                               Session session,\n                               FileDialogs fileDialogs,\n                               RemoteFileSystemContext fileSystemContext,\n                               HTMLPreviewServerOperations server,\n                               RPubsPresenter rpubsPresenter,\n                               UIPrefs prefs,\n                               Provider<FileExport> pFileExport)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      server_ = server;\n      session_ = session;\n      fileDialogs_ = fileDialogs;\n      fileSystemContext_ = fileSystemContext;\n      pFileExport_ = pFileExport;\n      prefs_ = prefs;\n      \n      rpubsPresenter.setContext(this);\n      \n      binder.bind(commands, this);  \n      \n      // disable rpubs if requested\n      if (!session.getSessionInfo().getAllowRpubsPublish())\n      {\n         commands.publishHTML().remove();\n      }\n      \n      // map Ctrl-R to our internal refresh handler\n      Event.addNativePreviewHandler(new NativePreviewHandler() {\n         @Override\n         public void onPreviewNativeEvent(NativePreviewEvent event)\n         {\n            if (event.getTypeInt() == Event.ONKEYDOWN)\n            {\n               NativeEvent ne = event.getNativeEvent();\n               int mod = KeyboardShortcut.getModifierValue(ne);\n               if ((mod == KeyboardShortcut.META || \n                   (mod == KeyboardShortcut.CTRL && !BrowseCap.hasMetaKey()))\n                   && ne.getKeyCode() == 'R')\n               {\n                  ne.preventDefault();\n                  ne.stopPropagation();\n                  commands.refreshHtmlPreview().execute();\n               }\n            }\n         }\n      });\n      \n      satellite.addCloseHandler(new CloseHandler<Satellite>()\n      {\n         @Override\n         public void onClose(CloseEvent<Satellite> event)\n         {\n            if (previewRunning_)\n               terminateRunningPreview();\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewStartedEvent.TYPE,\n                          new HTMLPreviewStartedEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewStarted(HTMLPreviewStartedEvent event)\n         {\n            previewRunning_ = true;\n            lastPreviewOutput_ = new StringBuilder();\n            view_.showProgress(\"Knitting...\");\n            view_.addProgressClickHandler(new ClickHandler() {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (previewRunning_)\n                     terminateRunningPreview();\n                  else\n                     view_.closeProgress();\n               }\n               \n            });\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewOutputEvent.TYPE, \n                          new HTMLPreviewOutputEvent.Handler()\n      {\n         @Override\n         public void onHTMLPreviewOutput(HTMLPreviewOutputEvent event)\n         {\n            String output = event.getOutput();\n            view_.showProgressOutput(output);\n            lastPreviewOutput_.append(output);\n         }\n      });\n      \n      eventBus.addHandler(HTMLPreviewCompletedEvent.TYPE, \n                          new HTMLPreviewCompletedEvent.Handler()\n      { \n         @Override\n         public void onHTMLPreviewCompleted(HTMLPreviewCompletedEvent event)\n         {\n            previewRunning_ = false;\n            \n            HTMLPreviewResult result = event.getResult();           \n            if (result.getSucceeded())\n            {\n               lastSuccessfulPreview_ = result;\n               view_.closeProgress();\n               view_.showPreview(\n                  server_.getApplicationURL(result.getPreviewURL()),\n                  result.getHtmlFile(),\n                  result.getEnableSaveAs(),\n                  isMarkdownFile(result.getSourceFile()) &&\n                  SessionUtils.showPublishUi(session_, prefs_),\n                  result.getEnableRefresh(),\n                  lastPreviewOutput_.length() > 0);\n\n               isPublished_ = result.getPreviouslyPublished();\n               if (isPublished_)\n                  view_.setPublishButtonLabel(\"Republish\");\n            }\n            else\n            {\n               view_.setProgressCaption(\"Preview failed\");\n               view_.stopProgress();\n            }\n         }\n      });\n\n      eventBus.addHandler(RPubsUploadStatusEvent.TYPE,\n                          new org.rstudio.studio.client.common.rpubs.events.RPubsUploadStatusEvent.Handler()\n      {\n         @Override\n         public void onRPubsPublishStatus(\n               RPubsUploadStatusEvent event)\n         {\n            // make sure it applies to our context\n            RPubsUploadStatusEvent.Status status = event.getStatus();\n            if (!status.getContextId().equals(getContextId()))\n               return;\n            \n            if (StringUtil.isNullOrEmpty(status.getError())\n                && !isPublished_)\n            {\n               isPublished_ = true;\n               view_.setPublishButtonLabel(\"Republish\");\n            }\n         }\n      });\n      \n      new StringStateValue(\n            MODULE_HTML_PREVIEW,\n            KEY_SAVEAS_DIR,\n            ClientState.PERSISTENT,\n            session_.getSessionInfo().getClientState())\n      {\n         @Override\n         protected void onInit(String value)\n         {\n            savePreviewDir_ = value;\n         }\n\n         @Override\n         protected String getValue()\n         {\n            return savePreviewDir_;\n         }\n      };\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public PublishingPreferencesPane(GlobalDisplay globalDisplay,\n                                    RSConnectServerOperations server,\n                                    RSAccountConnector connector,\n                                    UIPrefs prefs,\n                                    PreferencesDialogResources res)\n   {\n      display_ = globalDisplay;\n      uiPrefs_ = prefs;\n      server_ = server;\n      connector_ = connector;\n      \n      HorizontalPanel hpanel = new HorizontalPanel();\n      \n      Label accountLabel = new Label(\"Connected Accounts\");\n      accountLabel.setStyleName(\n            PreferencesDialogBaseResources.INSTANCE.styles().headerLabel());\n      nudgeRight(accountLabel);\n      add(accountLabel);\n      \n      accountList_ = new RSConnectAccountList(server, globalDisplay);\n      accountList_.setHeight(\"200px\");\n      accountList_.setWidth(\"300px\");\n      accountList_.getElement().getStyle().setMarginBottom(15, Unit.PX);\n      accountList_.getElement().getStyle().setMarginLeft(3, Unit.PX);\n      hpanel.add(accountList_);\n      \n      accountList_.setOnRefreshCompleted(new Operation() \n      {\n         @Override\n         public void execute()\n         {\n            setDisconnectButtonEnabledState();\n         }\n      });\n      \n      VerticalPanel vpanel = new VerticalPanel();\n      hpanel.add(vpanel);\n      connectButton_ = new ThemedButton(\"Connect...\");\n      connectButton_.getElement().getStyle().setMarginBottom(5, Unit.PX);\n      connectButton_.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            onConnect();\n         }\n      });\n      vpanel.add(connectButton_);\n      disconnectButton_ = new ThemedButton(\"Disconnect\");\n      disconnectButton_.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            onDisconnect();\n         }\n      });\n      vpanel.add(disconnectButton_);\n      setDisconnectButtonEnabledState();\n\n      add(hpanel);\n\n      Label settingsLabel = new Label(\"Settings\");\n      settingsLabel.setStyleName(\n            PreferencesDialogBaseResources.INSTANCE.styles().headerLabel());\n      nudgeRight(settingsLabel);\n      add(settingsLabel);\n      add(checkboxPref(\"Enable publishing apps and documents\",\n                       uiPrefs_.showPublishUi()));\n   }","id":74702,"modified_method":"@Inject\n   public PublishingPreferencesPane(GlobalDisplay globalDisplay,\n                                    RSConnectServerOperations server,\n                                    RSAccountConnector connector,\n                                    UIPrefs prefs)\n   {\n      reloadRequired_ = false;\n      display_ = globalDisplay;\n      uiPrefs_ = prefs;\n      server_ = server;\n      connector_ = connector;\n      \n      HorizontalPanel hpanel = new HorizontalPanel();\n      \n      Label accountLabel = new Label(\"Connected Accounts\");\n      accountLabel.setStyleName(\n            PreferencesDialogBaseResources.INSTANCE.styles().headerLabel());\n      nudgeRight(accountLabel);\n      add(accountLabel);\n      \n      accountList_ = new RSConnectAccountList(server, globalDisplay);\n      accountList_.setHeight(\"200px\");\n      accountList_.setWidth(\"300px\");\n      accountList_.getElement().getStyle().setMarginBottom(15, Unit.PX);\n      accountList_.getElement().getStyle().setMarginLeft(3, Unit.PX);\n      hpanel.add(accountList_);\n      \n      accountList_.setOnRefreshCompleted(new Operation() \n      {\n         @Override\n         public void execute()\n         {\n            setDisconnectButtonEnabledState();\n         }\n      });\n      \n      VerticalPanel vpanel = new VerticalPanel();\n      hpanel.add(vpanel);\n      connectButton_ = new ThemedButton(\"Connect...\");\n      connectButton_.getElement().getStyle().setMarginBottom(5, Unit.PX);\n      connectButton_.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            onConnect();\n         }\n      });\n      vpanel.add(connectButton_);\n      disconnectButton_ = new ThemedButton(\"Disconnect\");\n      disconnectButton_.addClickHandler(new ClickHandler()\n      {\n         @Override\n         public void onClick(ClickEvent event)\n         {\n            onDisconnect();\n         }\n      });\n      vpanel.add(disconnectButton_);\n      setDisconnectButtonEnabledState();\n\n      add(hpanel);\n\n      Label settingsLabel = new Label(\"Settings\");\n      settingsLabel.setStyleName(\n            PreferencesDialogBaseResources.INSTANCE.styles().headerLabel());\n      nudgeRight(settingsLabel);\n      add(settingsLabel);\n      CheckBox chkEnablePublishing = checkboxPref(\"Enable publishing apps and documents\", \n            uiPrefs_.showPublishUi());\n      chkEnablePublishing.addValueChangeHandler(new ValueChangeHandler<Boolean>(){\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            reloadRequired_ = true;\n         }\n      });\n      add(chkEnablePublishing);\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public boolean onApply(RPrefs rPrefs)\n   {\n      return super.onApply(rPrefs);\n   }","id":74703,"modified_method":"@Override\n   public boolean onApply(RPrefs rPrefs)\n   {\n      boolean reload = super.onApply(rPrefs);\n\n      return reload || reloadRequired_;\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void showOutput(RmdPreviewParams params) \n   {\n      // detect whether we're really doing a refresh\n      boolean refresh = params_ != null && \n            params_.getResult().equals(params.getResult());\n      params_ = params;\n      view_.showOutput(params, session_.getSessionInfo().getAllowRpubsPublish(), \n                       session_.getSessionInfo().getRSConnectAvailable(), refresh);\n   }","id":74704,"modified_method":"public void showOutput(RmdPreviewParams params) \n   {\n      // detect whether we're really doing a refresh\n      boolean refresh = params_ != null && \n            params_.getResult().equals(params.getResult());\n      params_ = params;\n      view_.showOutput(params, SessionUtils.showPublishUi(session_, prefs_), \n                       session_.getSessionInfo().getRSConnectAvailable(), refresh);\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public RmdOutputPresenter(Display view,\n                             Binder binder,\n                             GlobalDisplay globalDisplay,\n                             RPubsPresenter rpubsPresenter,\n                             Session session,\n                             Commands commands,\n                             EventBus eventBus,\n                             Satellite satellite)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      session_ = session;\n      \n      rpubsPresenter.setContext(this);\n      slideNavigationPresenter_ = new SlideNavigationPresenter(view_);\n      disconnectNotifier_ = new ShinyDisconnectNotifier(this);\n      \n      satellite.addCloseHandler(new CloseHandler<Satellite>()\n      {\n         @Override\n         public void onClose(CloseEvent<Satellite> event)\n         {\n            // don't process a close if we're being closed for reactivate \n            if (event.getTarget().isReactivatePending())\n               return;\n\n            // record scroll position and anchor (but try/catch because sometimes \n            // the document is null at this point)\n            try\n            {\n               params_.setScrollPosition(getScrollPosition());\n               params_.setAnchor(getAnchor());\n            }\n            catch (Exception e)\n            {\n            }\n            \n            // notify closed\n            notifyRmdOutputClosed(params_);\n         }\n      });\n   \n      binder.bind(commands, this);  \n      \n      initializeEvents();\n   }","id":74705,"modified_method":"@Inject\n   public RmdOutputPresenter(Display view,\n                             Binder binder,\n                             GlobalDisplay globalDisplay,\n                             RPubsPresenter rpubsPresenter,\n                             Session session,\n                             Commands commands,\n                             EventBus eventBus,\n                             Satellite satellite,\n                             UIPrefs prefs)\n   {\n      view_ = view;\n      globalDisplay_ = globalDisplay;\n      session_ = session;\n      prefs_ = prefs;\n      \n      rpubsPresenter.setContext(this);\n      slideNavigationPresenter_ = new SlideNavigationPresenter(view_);\n      disconnectNotifier_ = new ShinyDisconnectNotifier(this);\n      \n      satellite.addCloseHandler(new CloseHandler<Satellite>()\n      {\n         @Override\n         public void onClose(CloseEvent<Satellite> event)\n         {\n            // don't process a close if we're being closed for reactivate \n            if (event.getTarget().isReactivatePending())\n               return;\n\n            // record scroll position and anchor (but try/catch because sometimes \n            // the document is null at this point)\n            try\n            {\n               params_.setScrollPosition(getScrollPosition());\n               params_.setAnchor(getAnchor());\n            }\n            catch (Exception e)\n            {\n            }\n            \n            // notify closed\n            notifyRmdOutputClosed(params_);\n         }\n      });\n   \n      binder.bind(commands, this);  \n      \n      initializeEvents();\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"public void loadApp(ShinyApplicationParams params) \n   {\n      params_ = params;\n      view_.showApp(params, session_.getSessionInfo().getRSConnectAvailable());\n   }","id":74706,"modified_method":"public void loadApp(ShinyApplicationParams params) \n   {\n      params_ = params;\n      view_.showApp(params, SessionUtils.showShinyPublishUi(session_, prefs_));\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public ShinyApplicationPresenter(Display view,\n                               GlobalDisplay globalDisplay,\n                               Binder binder,\n                               final Commands commands,\n                               EventBus eventBus,\n                               Satellite satellite,\n                               Session session)\n   {\n      view_ = view;\n      satellite_ = satellite;\n      events_ = eventBus;\n      globalDisplay_ = globalDisplay;\n      disconnect_ = new ShinyDisconnectNotifier(this);\n      session_ = session;\n      \n      binder.bind(commands, this);  \n      \n      initializeEvents();\n   }","id":74707,"modified_method":"@Inject\n   public ShinyApplicationPresenter(Display view,\n                               GlobalDisplay globalDisplay,\n                               Binder binder,\n                               final Commands commands,\n                               EventBus eventBus,\n                               Satellite satellite,\n                               Session session,\n                               UIPrefs prefs)\n   {\n      view_ = view;\n      satellite_ = satellite;\n      events_ = eventBus;\n      globalDisplay_ = globalDisplay;\n      disconnect_ = new ShinyDisconnectNotifier(this);\n      session_ = session;\n      prefs_ = prefs;\n      \n      binder.bind(commands, this);  \n      \n      initializeEvents();\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"private Toolbar createToolbar(TextFileType fileType)\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n       \n      toolbar.addLeftWidget(commands_.saveSourceDoc().createToolbarButton());\n      sourceOnSave_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(sourceOnSave_);\n      srcOnSaveLabel_.getElement().getStyle().setMarginRight(9, Unit.PX);\n      toolbar.addLeftWidget(srcOnSaveLabel_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.checkSpelling().createToolbarButton());\n      \n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n      toolbar.addLeftWidget(createCodeTransformMenuButton());\n      \n      notebookSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(notebookToolbarButton_ = \n            commands_.compileNotebook().createToolbarButton());\n      \n      int mod = BrowseCap.hasMetaKey() ? KeyboardShortcut.META : \n         KeyboardShortcut.CTRL;\n      String cmdText = \n        new KeyboardShortcut(mod + KeyboardShortcut.SHIFT, 'K').toString(true);\n      cmdText = DomUtils.htmlToText(cmdText);\n      notebookToolbarButton_.setTitle(\"Compile Notebook (\" + cmdText + \")\");\n      \n      texSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(texToolbarButton_ = createLatexFormatButton());\n      \n      ToolbarPopupMenu helpMenu = new ToolbarPopupMenu();\n      helpMenu.addItem(commands_.usingRMarkdownHelp().createMenuItem(false));\n      helpMenu.addItem(commands_.authoringRPresentationsHelp().createMenuItem(false));\n      helpMenu.addSeparator();\n      helpMenu.addItem(commands_.markdownHelp().createMenuItem(false));\n      helpMenuButton_ = new ToolbarButton(null, \n                                          StandardIcons.INSTANCE.help(), \n                                          helpMenu);\n      toolbar.addLeftWidget(helpMenuButton_);\n      toolbar.addLeftWidget(rcppHelpButton_ = commands_.rcppHelp().createToolbarButton());\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(previewHTMLButton_ = commands_.previewHTML().createToolbarButton());\n      knitDocumentButton_ = commands_.knitDocument().createToolbarButton(false);\n      knitDocumentButton_.getElement().getStyle().setMarginRight(2, Unit.PX);\n      toolbar.addLeftWidget(knitDocumentButton_);\n      toolbar.addLeftWidget(compilePdfButton_ = commands_.compilePDF().createToolbarButton());\n      rmdFormatButton_ = new ToolbarPopupMenuButton(false, true);\n      toolbar.addLeftWidget(rmdFormatButton_);\n      toolbar.addLeftWidget(editRmdFormatButton_ = commands_.editRmdFormatOptions().createToolbarButton(false));\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.synctexSearch().createToolbarButton());\n\n      toolbar.addRightWidget(runButton_ = commands_.executeCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(runLastButton_ = commands_.executeLastCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      final String SOURCE_BUTTON_TITLE = \"Source the active document\"; \n      \n      sourceButton_ = new ToolbarButton(\n            \"Source\", \n            commands_.sourceActiveDocument().getImageResource(), \n            new ClickHandler() \n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (uiPrefs_.sourceWithEcho().getValue())\n                     commands_.sourceActiveDocumentWithEcho().execute();\n                  else\n                     commands_.sourceActiveDocument().execute();\n               }\n            });\n      \n      sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n      toolbar.addRightWidget(sourceButton_);\n      \n      uiPrefs_.sourceWithEcho().addValueChangeHandler(\n                                       new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            if (event.getValue())\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE + \" (with echo)\");\n            else\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n         }\n      });\n            \n      ToolbarPopupMenu sourceMenu = new ToolbarPopupMenu();\n      sourceMenu.addItem(commands_.sourceActiveDocument().createMenuItem(false));\n      sourceMenu.addItem(commands_.sourceActiveDocumentWithEcho().createMenuItem(false));\n         \n      sourceMenuButton_ = new ToolbarButton(sourceMenu, true);\n      toolbar.addRightWidget(sourceMenuButton_);  \n\n      //toolbar.addRightSeparator();\n     \n      ToolbarPopupMenu chunksMenu = new ToolbarPopupMenu();\n      chunksMenu.addItem(commands_.insertChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.jumpTo().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executePreviousChunks().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeCurrentChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeNextChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeAllCode().createMenuItem(false));\n      chunksButton_ = new ToolbarButton(\n                       \"Chunks\",  \n                       StandardIcons.INSTANCE.chunk_menu(), \n                       chunksMenu, \n                       true);\n      toolbar.addRightWidget(chunksButton_);\n      \n      ToolbarPopupMenu shinyLaunchMenu = shinyViewerMenu_;\n      shinyLaunchButton_ = new ToolbarButton(\n                       shinyLaunchMenu, \n                       true);\n      shinyLaunchButton_.setVisible(false);\n      toolbar.addRightWidget(shinyLaunchButton_);\n      \n      if (session_.getSessionInfo().getRSConnectAvailable())\n      {\n         toolbar.addRightSeparator();\n         RSConnectUtils.addPublishCommands(toolbar, null, false);\n      }\n      \n      \n      return toolbar;\n   }","id":74708,"modified_method":"private Toolbar createToolbar(TextFileType fileType)\n   {\n      Toolbar toolbar = new EditingTargetToolbar(commands_);\n       \n      toolbar.addLeftWidget(commands_.saveSourceDoc().createToolbarButton());\n      sourceOnSave_.getElement().getStyle().setMarginRight(0, Unit.PX);\n      toolbar.addLeftWidget(sourceOnSave_);\n      srcOnSaveLabel_.getElement().getStyle().setMarginRight(9, Unit.PX);\n      toolbar.addLeftWidget(srcOnSaveLabel_);\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.checkSpelling().createToolbarButton());\n      \n      toolbar.addLeftWidget(findReplace_.createFindReplaceButton());\n      toolbar.addLeftWidget(createCodeTransformMenuButton());\n      \n      notebookSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(notebookToolbarButton_ = \n            commands_.compileNotebook().createToolbarButton());\n      \n      int mod = BrowseCap.hasMetaKey() ? KeyboardShortcut.META : \n         KeyboardShortcut.CTRL;\n      String cmdText = \n        new KeyboardShortcut(mod + KeyboardShortcut.SHIFT, 'K').toString(true);\n      cmdText = DomUtils.htmlToText(cmdText);\n      notebookToolbarButton_.setTitle(\"Compile Notebook (\" + cmdText + \")\");\n      \n      texSeparatorWidget_ = toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(texToolbarButton_ = createLatexFormatButton());\n      \n      ToolbarPopupMenu helpMenu = new ToolbarPopupMenu();\n      helpMenu.addItem(commands_.usingRMarkdownHelp().createMenuItem(false));\n      helpMenu.addItem(commands_.authoringRPresentationsHelp().createMenuItem(false));\n      helpMenu.addSeparator();\n      helpMenu.addItem(commands_.markdownHelp().createMenuItem(false));\n      helpMenuButton_ = new ToolbarButton(null, \n                                          StandardIcons.INSTANCE.help(), \n                                          helpMenu);\n      toolbar.addLeftWidget(helpMenuButton_);\n      toolbar.addLeftWidget(rcppHelpButton_ = commands_.rcppHelp().createToolbarButton());\n      \n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(previewHTMLButton_ = commands_.previewHTML().createToolbarButton());\n      knitDocumentButton_ = commands_.knitDocument().createToolbarButton(false);\n      knitDocumentButton_.getElement().getStyle().setMarginRight(2, Unit.PX);\n      toolbar.addLeftWidget(knitDocumentButton_);\n      toolbar.addLeftWidget(compilePdfButton_ = commands_.compilePDF().createToolbarButton());\n      rmdFormatButton_ = new ToolbarPopupMenuButton(false, true);\n      toolbar.addLeftWidget(rmdFormatButton_);\n      toolbar.addLeftWidget(editRmdFormatButton_ = commands_.editRmdFormatOptions().createToolbarButton(false));\n\n      toolbar.addLeftSeparator();\n      toolbar.addLeftWidget(commands_.synctexSearch().createToolbarButton());\n\n      toolbar.addRightWidget(runButton_ = commands_.executeCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      toolbar.addRightWidget(runLastButton_ = commands_.executeLastCode().createToolbarButton(false));\n      toolbar.addRightSeparator();\n      final String SOURCE_BUTTON_TITLE = \"Source the active document\"; \n      \n      sourceButton_ = new ToolbarButton(\n            \"Source\", \n            commands_.sourceActiveDocument().getImageResource(), \n            new ClickHandler() \n            {\n               @Override\n               public void onClick(ClickEvent event)\n               {\n                  if (uiPrefs_.sourceWithEcho().getValue())\n                     commands_.sourceActiveDocumentWithEcho().execute();\n                  else\n                     commands_.sourceActiveDocument().execute();\n               }\n            });\n      \n      sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n      toolbar.addRightWidget(sourceButton_);\n      \n      uiPrefs_.sourceWithEcho().addValueChangeHandler(\n                                       new ValueChangeHandler<Boolean>() {\n         @Override\n         public void onValueChange(ValueChangeEvent<Boolean> event)\n         {\n            if (event.getValue())\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE + \" (with echo)\");\n            else\n               sourceButton_.setTitle(SOURCE_BUTTON_TITLE);\n         }\n      });\n            \n      ToolbarPopupMenu sourceMenu = new ToolbarPopupMenu();\n      sourceMenu.addItem(commands_.sourceActiveDocument().createMenuItem(false));\n      sourceMenu.addItem(commands_.sourceActiveDocumentWithEcho().createMenuItem(false));\n         \n      sourceMenuButton_ = new ToolbarButton(sourceMenu, true);\n      toolbar.addRightWidget(sourceMenuButton_);  \n\n      //toolbar.addRightSeparator();\n     \n      ToolbarPopupMenu chunksMenu = new ToolbarPopupMenu();\n      chunksMenu.addItem(commands_.insertChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.jumpTo().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executePreviousChunks().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeCurrentChunk().createMenuItem(false));\n      chunksMenu.addItem(commands_.executeNextChunk().createMenuItem(false));\n      chunksMenu.addSeparator();\n      chunksMenu.addItem(commands_.executeAllCode().createMenuItem(false));\n      chunksButton_ = new ToolbarButton(\n                       \"Chunks\",  \n                       StandardIcons.INSTANCE.chunk_menu(), \n                       chunksMenu, \n                       true);\n      toolbar.addRightWidget(chunksButton_);\n      \n      ToolbarPopupMenu shinyLaunchMenu = shinyViewerMenu_;\n      shinyLaunchButton_ = new ToolbarButton(\n                       shinyLaunchMenu, \n                       true);\n      shinyLaunchButton_.setVisible(false);\n      toolbar.addRightWidget(shinyLaunchButton_);\n      \n      if (SessionUtils.showShinyPublishUi(session_, uiPrefs_))\n      {\n         toolbar.addRightSeparator();\n         RSConnectUtils.addPublishCommands(toolbar, null, false);\n      }\n      \n      \n      return toolbar;\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Override\n   public void onUiPrefsChanged(UiPrefsChangedEvent e)\n   {        \n      if (e.getType().equals(UiPrefsChangedEvent.GLOBAL_TYPE))\n      {\n         // get prefs accessor\n         UIPrefsAccessor newUiPrefs = new UIPrefsAccessor(\n                                                   e.getUIPrefs(), \n                                                   JsObject.createJsObject());\n         \n         // show line numbers\n         showLineNumbers().setGlobalValue(\n                                 newUiPrefs.showLineNumbers().getGlobalValue());\n         \n         // highlight selected word\n         highlightSelectedWord().setGlobalValue(\n                           newUiPrefs.highlightSelectedWord().getGlobalValue());\n         \n         // highlight selected line\n         highlightSelectedLine().setGlobalValue(\n                          newUiPrefs.highlightSelectedLine().getGlobalValue());\n       \n         // pane config\n         if (!newUiPrefs.paneConfig().getGlobalValue().isEqualTo(\n                                 paneConfig().getGlobalValue()))\n         {\n            paneConfig().setGlobalValue(\n                              newUiPrefs.paneConfig().getGlobalValue());\n         }\n         \n         // use spaces for tab\n         useSpacesForTab().setGlobalValue(\n                          newUiPrefs.useSpacesForTab().getGlobalValue());\n           \n         // num spacers for tab\n         numSpacesForTab().setGlobalValue(\n               newUiPrefs.numSpacesForTab().getGlobalValue());\n   \n         // blinking cursor\n         blinkingCursor().setGlobalValue(\n               newUiPrefs.blinkingCursor().getGlobalValue());\n         \n         // show margin\n         showMargin().setGlobalValue(\n                                 newUiPrefs.showMargin().getGlobalValue());\n         \n         // print margin column\n         printMarginColumn().setGlobalValue(\n                              newUiPrefs.printMarginColumn().getGlobalValue());\n      \n         // show invisibles\n         showInvisibles().setGlobalValue(\n                              newUiPrefs.showInvisibles().getGlobalValue());\n         \n         // show indent guides\n         showIndentGuides().setGlobalValue(\n                              newUiPrefs.showIndentGuides().getGlobalValue());\n         \n         // use vim mode\n         useVimMode().setGlobalValue(\n                              newUiPrefs.useVimMode().getGlobalValue());\n         \n         continueCommentsOnNewline().setGlobalValue(\n                              newUiPrefs.continueCommentsOnNewline().getGlobalValue());\n         \n         // insert matching\n         insertMatching().setGlobalValue(\n                                 newUiPrefs.insertMatching().getGlobalValue());\n              \n         codeComplete().setGlobalValue(\n                                 newUiPrefs.codeComplete().getGlobalValue());\n         \n         alwaysCompleteInConsole().setGlobalValue(\n                                 newUiPrefs.alwaysCompleteInConsole().getGlobalValue());\n         \n         insertParensAfterFunctionCompletion().setGlobalValue(\n                                 newUiPrefs.insertParensAfterFunctionCompletion().getGlobalValue());\n         \n         allowTabMultilineCompletion().setGlobalValue(\n                                 newUiPrefs.allowTabMultilineCompletion().getGlobalValue());\n         \n         insertSpacesAroundEquals().setGlobalValue(\n                                 newUiPrefs.insertSpacesAroundEquals().getGlobalValue());\n         \n         showSignatureTooltips().setGlobalValue(\n                                 newUiPrefs.showSignatureTooltips().getGlobalValue());\n         \n         autoAppendNewline().setGlobalValue(\n                                 newUiPrefs.autoAppendNewline().getGlobalValue());\n         \n         stripTrailingWhitespace().setGlobalValue(\n                       newUiPrefs.stripTrailingWhitespace().getGlobalValue());\n      \n         // soft wrap R files\n         softWrapRFiles().setGlobalValue(\n                                 newUiPrefs.softWrapRFiles().getGlobalValue());\n         \n         // focus console after exec\n         focusConsoleAfterExec().setGlobalValue(\n                         newUiPrefs.focusConsoleAfterExec().getGlobalValue());\n         \n         // syntax color console\n         syntaxColorConsole().setGlobalValue(\n                             newUiPrefs.syntaxColorConsole().getGlobalValue());\n         \n         // save all before build\n         saveAllBeforeBuild().setGlobalValue(\n                             newUiPrefs.saveAllBeforeBuild().getGlobalValue());\n      \n         // font size\n         fontSize().setGlobalValue(\n                             newUiPrefs.fontSize().getGlobalValue());\n      \n         // theme\n         theme().setGlobalValue(newUiPrefs.theme().getGlobalValue());\n      \n         // default encoding\n         defaultEncoding().setGlobalValue(\n                                 newUiPrefs.defaultEncoding().getGlobalValue());\n         \n         // default project location\n         defaultProjectLocation().setGlobalValue(\n                        newUiPrefs.defaultProjectLocation().getGlobalValue());\n      \n         // toolbar visible\n         toolbarVisible().setGlobalValue(\n                                 newUiPrefs.toolbarVisible().getGlobalValue());\n         \n         // source with echo\n         sourceWithEcho().setGlobalValue(\n                                 newUiPrefs.sourceWithEcho().getGlobalValue());\n         \n         // clear hidden values in workspace\n         clearHidden().setGlobalValue(\n                                 newUiPrefs.clearHidden().getGlobalValue());\n         \n         // export plot options\n         if (!ExportPlotOptions.areEqual(\n               newUiPrefs.exportPlotOptions().getGlobalValue(),\n               exportPlotOptions().getGlobalValue()))\n         {\n            exportPlotOptions().setGlobalValue(\n                              newUiPrefs.exportPlotOptions().getGlobalValue());\n         }\n         \n         // save plot as pdf options\n         if (!SavePlotAsPdfOptions.areEqual(\n               newUiPrefs.savePlotAsPdfOptions().getGlobalValue(),\n               savePlotAsPdfOptions().getGlobalValue()))\n         {\n            savePlotAsPdfOptions().setGlobalValue(\n                         newUiPrefs.savePlotAsPdfOptions().getGlobalValue());\n         }\n         \n         // export viewer options\n         if (!ExportPlotOptions.areEqual(\n               newUiPrefs.exportViewerOptions().getGlobalValue(),\n               exportViewerOptions().getGlobalValue()))\n         {\n            exportViewerOptions().setGlobalValue(\n                          newUiPrefs.exportViewerOptions().getGlobalValue());\n         }\n         \n         \n         // compile notebook options\n         if (!CompileNotebookPrefs.areEqual(\n               newUiPrefs.compileNotebookOptions().getGlobalValue(),\n               compileNotebookOptions().getGlobalValue()))\n         {\n            compileNotebookOptions().setGlobalValue(\n                        newUiPrefs.compileNotebookOptions().getGlobalValue());\n         }\n         if (!CompileNotebookv2Prefs.areEqual(\n               newUiPrefs.compileNotebookv2Options().getGlobalValue(),\n               compileNotebookv2Options().getGlobalValue()))\n         {\n            compileNotebookv2Options().setGlobalValue(\n                        newUiPrefs.compileNotebookv2Options().getGlobalValue());\n         }\n         \n         // default sweave engine\n         defaultSweaveEngine().setGlobalValue(\n                           newUiPrefs.defaultSweaveEngine().getGlobalValue());\n         \n         // default latex program\n         defaultLatexProgram().setGlobalValue(\n                           newUiPrefs.defaultLatexProgram().getGlobalValue());\n         \n         // root document\n         rootDocument().setGlobalValue(\n                           newUiPrefs.rootDocument().getGlobalValue());\n         \n         // use roxygen\n         useRoxygen().setGlobalValue(\n                           newUiPrefs.useRoxygen().getGlobalValue());\n        \n         // pdf preview\n         pdfPreview().setGlobalValue(\n                           newUiPrefs.pdfPreview().getGlobalValue());\n         \n         // always enable rnw concordance\n         alwaysEnableRnwConcordance().setGlobalValue(\n                    newUiPrefs.alwaysEnableRnwConcordance().getGlobalValue());\n         \n         // insert numbered latex sections\n         insertNumberedLatexSections().setGlobalValue(\n                    newUiPrefs.insertNumberedLatexSections().getGlobalValue());\n         \n         // spelling dictionary language\n         spellingDictionaryLanguage().setGlobalValue(\n                    newUiPrefs.spellingDictionaryLanguage().getGlobalValue());\n         \n         // spelling custom dictionaries\n         if (!JsUtil.areEqual(\n                     spellingCustomDictionaries().getGlobalValue(),\n                     newUiPrefs.spellingCustomDictionaries().getGlobalValue()))\n         {\n            spellingCustomDictionaries().setGlobalValue(\n                     newUiPrefs.spellingCustomDictionaries().getGlobalValue());\n         }\n            \n         // ignore words in uppercase\n         ignoreWordsInUppercase().setGlobalValue(\n                    newUiPrefs.ignoreWordsInUppercase().getGlobalValue());\n         \n         // ignore words with numbers\n         ignoreWordsWithNumbers().setGlobalValue(\n                    newUiPrefs.ignoreWordsWithNumbers().getGlobalValue());\n         \n         // navigate to build error\n         navigateToBuildError().setGlobalValue(\n                    newUiPrefs.navigateToBuildError().getGlobalValue());\n         \n         // enable packages pane\n         packagesPaneEnabled().setGlobalValue(\n                    newUiPrefs.packagesPaneEnabled().getGlobalValue());\n         \n         // use rcpp template\n         useRcppTemplate().setGlobalValue(\n                    newUiPrefs.useRcppTemplate().getGlobalValue());\n         \n         // restore source documents\n         restoreSourceDocuments().setGlobalValue(\n                    newUiPrefs.restoreSourceDocuments().getGlobalValue());\n         \n         // break in user code only on unhandled errors\n         handleErrorsInUserCodeOnly().setGlobalValue(\n                    newUiPrefs.handleErrorsInUserCodeOnly().getGlobalValue());\n                    \n         // auto expand error tracebacks\n         autoExpandErrorTracebacks().setGlobalValue(\n                    newUiPrefs.autoExpandErrorTracebacks().getGlobalValue());\n         \n         // preferred R Markdown template\n         rmdPreferredTemplatePath().setGlobalValue(\n               newUiPrefs.rmdPreferredTemplatePath().getGlobalValue());\n      }\n      else if (e.getType().equals(UiPrefsChangedEvent.PROJECT_TYPE))\n      {\n         // get prefs accessor\n         UIPrefsAccessor newUiPrefs = new UIPrefsAccessor(\n                                                   JsObject.createJsObject(),\n                                                   e.getUIPrefs());\n         \n         // use spaces for tab\n         useSpacesForTab().setProjectValue(\n                          newUiPrefs.useSpacesForTab().getValue());\n           \n         // num spaces for tab\n         numSpacesForTab().setProjectValue(\n               newUiPrefs.numSpacesForTab().getValue());\n         \n         // auto-append newline\n         autoAppendNewline().setProjectValue(\n               newUiPrefs.autoAppendNewline().getValue());\n         \n         // strip trailing whitespace\n         stripTrailingWhitespace().setProjectValue(\n               newUiPrefs.stripTrailingWhitespace().getValue());\n   \n         // default encoding\n         defaultEncoding().setProjectValue(\n                                 newUiPrefs.defaultEncoding().getValue());\n         \n         // default sweave engine\n         defaultSweaveEngine().setProjectValue(\n                                 newUiPrefs.defaultSweaveEngine().getValue());\n         \n         // default latex program\n         defaultLatexProgram().setProjectValue(\n                            newUiPrefs.defaultLatexProgram().getValue());\n         \n         // root document\n         rootDocument().setProjectValue(newUiPrefs.rootDocument().getValue());\n         \n         // use roxygen\n         useRoxygen().setProjectValue(newUiPrefs.useRoxygen().getValue());\n      }\n      else\n      {\n         Debug.log(\"Unexpected uiPrefs type: \" + e.getType());\n      }\n   }","id":74709,"modified_method":"@Override\n   public void onUiPrefsChanged(UiPrefsChangedEvent e)\n   {        \n      if (e.getType().equals(UiPrefsChangedEvent.GLOBAL_TYPE))\n      {\n         // get prefs accessor\n         UIPrefsAccessor newUiPrefs = new UIPrefsAccessor(\n                                                   e.getUIPrefs(), \n                                                   JsObject.createJsObject());\n         \n         // show line numbers\n         showLineNumbers().setGlobalValue(\n                                 newUiPrefs.showLineNumbers().getGlobalValue());\n         \n         // highlight selected word\n         highlightSelectedWord().setGlobalValue(\n                           newUiPrefs.highlightSelectedWord().getGlobalValue());\n         \n         // highlight selected line\n         highlightSelectedLine().setGlobalValue(\n                          newUiPrefs.highlightSelectedLine().getGlobalValue());\n       \n         // pane config\n         if (!newUiPrefs.paneConfig().getGlobalValue().isEqualTo(\n                                 paneConfig().getGlobalValue()))\n         {\n            paneConfig().setGlobalValue(\n                              newUiPrefs.paneConfig().getGlobalValue());\n         }\n         \n         // use spaces for tab\n         useSpacesForTab().setGlobalValue(\n                          newUiPrefs.useSpacesForTab().getGlobalValue());\n           \n         // num spacers for tab\n         numSpacesForTab().setGlobalValue(\n               newUiPrefs.numSpacesForTab().getGlobalValue());\n   \n         // blinking cursor\n         blinkingCursor().setGlobalValue(\n               newUiPrefs.blinkingCursor().getGlobalValue());\n         \n         // show margin\n         showMargin().setGlobalValue(\n                                 newUiPrefs.showMargin().getGlobalValue());\n         \n         // print margin column\n         printMarginColumn().setGlobalValue(\n                              newUiPrefs.printMarginColumn().getGlobalValue());\n      \n         // show invisibles\n         showInvisibles().setGlobalValue(\n                              newUiPrefs.showInvisibles().getGlobalValue());\n         \n         // show indent guides\n         showIndentGuides().setGlobalValue(\n                              newUiPrefs.showIndentGuides().getGlobalValue());\n         \n         // use vim mode\n         useVimMode().setGlobalValue(\n                              newUiPrefs.useVimMode().getGlobalValue());\n         \n         continueCommentsOnNewline().setGlobalValue(\n                              newUiPrefs.continueCommentsOnNewline().getGlobalValue());\n         \n         // insert matching\n         insertMatching().setGlobalValue(\n                                 newUiPrefs.insertMatching().getGlobalValue());\n              \n         codeComplete().setGlobalValue(\n                                 newUiPrefs.codeComplete().getGlobalValue());\n         \n         alwaysCompleteInConsole().setGlobalValue(\n                                 newUiPrefs.alwaysCompleteInConsole().getGlobalValue());\n         \n         insertParensAfterFunctionCompletion().setGlobalValue(\n                                 newUiPrefs.insertParensAfterFunctionCompletion().getGlobalValue());\n         \n         allowTabMultilineCompletion().setGlobalValue(\n                                 newUiPrefs.allowTabMultilineCompletion().getGlobalValue());\n         \n         insertSpacesAroundEquals().setGlobalValue(\n                                 newUiPrefs.insertSpacesAroundEquals().getGlobalValue());\n         \n         showSignatureTooltips().setGlobalValue(\n                                 newUiPrefs.showSignatureTooltips().getGlobalValue());\n         \n         autoAppendNewline().setGlobalValue(\n                                 newUiPrefs.autoAppendNewline().getGlobalValue());\n         \n         stripTrailingWhitespace().setGlobalValue(\n                       newUiPrefs.stripTrailingWhitespace().getGlobalValue());\n      \n         // soft wrap R files\n         softWrapRFiles().setGlobalValue(\n                                 newUiPrefs.softWrapRFiles().getGlobalValue());\n         \n         // focus console after exec\n         focusConsoleAfterExec().setGlobalValue(\n                         newUiPrefs.focusConsoleAfterExec().getGlobalValue());\n         \n         // syntax color console\n         syntaxColorConsole().setGlobalValue(\n                             newUiPrefs.syntaxColorConsole().getGlobalValue());\n         \n         // save all before build\n         saveAllBeforeBuild().setGlobalValue(\n                             newUiPrefs.saveAllBeforeBuild().getGlobalValue());\n      \n         // font size\n         fontSize().setGlobalValue(\n                             newUiPrefs.fontSize().getGlobalValue());\n      \n         // theme\n         theme().setGlobalValue(newUiPrefs.theme().getGlobalValue());\n      \n         // default encoding\n         defaultEncoding().setGlobalValue(\n                                 newUiPrefs.defaultEncoding().getGlobalValue());\n         \n         // default project location\n         defaultProjectLocation().setGlobalValue(\n                        newUiPrefs.defaultProjectLocation().getGlobalValue());\n      \n         // toolbar visible\n         toolbarVisible().setGlobalValue(\n                                 newUiPrefs.toolbarVisible().getGlobalValue());\n         \n         // source with echo\n         sourceWithEcho().setGlobalValue(\n                                 newUiPrefs.sourceWithEcho().getGlobalValue());\n         \n         // clear hidden values in workspace\n         clearHidden().setGlobalValue(\n                                 newUiPrefs.clearHidden().getGlobalValue());\n         \n         // export plot options\n         if (!ExportPlotOptions.areEqual(\n               newUiPrefs.exportPlotOptions().getGlobalValue(),\n               exportPlotOptions().getGlobalValue()))\n         {\n            exportPlotOptions().setGlobalValue(\n                              newUiPrefs.exportPlotOptions().getGlobalValue());\n         }\n         \n         // save plot as pdf options\n         if (!SavePlotAsPdfOptions.areEqual(\n               newUiPrefs.savePlotAsPdfOptions().getGlobalValue(),\n               savePlotAsPdfOptions().getGlobalValue()))\n         {\n            savePlotAsPdfOptions().setGlobalValue(\n                         newUiPrefs.savePlotAsPdfOptions().getGlobalValue());\n         }\n         \n         // export viewer options\n         if (!ExportPlotOptions.areEqual(\n               newUiPrefs.exportViewerOptions().getGlobalValue(),\n               exportViewerOptions().getGlobalValue()))\n         {\n            exportViewerOptions().setGlobalValue(\n                          newUiPrefs.exportViewerOptions().getGlobalValue());\n         }\n         \n         \n         // compile notebook options\n         if (!CompileNotebookPrefs.areEqual(\n               newUiPrefs.compileNotebookOptions().getGlobalValue(),\n               compileNotebookOptions().getGlobalValue()))\n         {\n            compileNotebookOptions().setGlobalValue(\n                        newUiPrefs.compileNotebookOptions().getGlobalValue());\n         }\n         if (!CompileNotebookv2Prefs.areEqual(\n               newUiPrefs.compileNotebookv2Options().getGlobalValue(),\n               compileNotebookv2Options().getGlobalValue()))\n         {\n            compileNotebookv2Options().setGlobalValue(\n                        newUiPrefs.compileNotebookv2Options().getGlobalValue());\n         }\n         \n         // default sweave engine\n         defaultSweaveEngine().setGlobalValue(\n                           newUiPrefs.defaultSweaveEngine().getGlobalValue());\n         \n         // default latex program\n         defaultLatexProgram().setGlobalValue(\n                           newUiPrefs.defaultLatexProgram().getGlobalValue());\n         \n         // root document\n         rootDocument().setGlobalValue(\n                           newUiPrefs.rootDocument().getGlobalValue());\n         \n         // use roxygen\n         useRoxygen().setGlobalValue(\n                           newUiPrefs.useRoxygen().getGlobalValue());\n        \n         // pdf preview\n         pdfPreview().setGlobalValue(\n                           newUiPrefs.pdfPreview().getGlobalValue());\n         \n         // always enable rnw concordance\n         alwaysEnableRnwConcordance().setGlobalValue(\n                    newUiPrefs.alwaysEnableRnwConcordance().getGlobalValue());\n         \n         // insert numbered latex sections\n         insertNumberedLatexSections().setGlobalValue(\n                    newUiPrefs.insertNumberedLatexSections().getGlobalValue());\n         \n         // spelling dictionary language\n         spellingDictionaryLanguage().setGlobalValue(\n                    newUiPrefs.spellingDictionaryLanguage().getGlobalValue());\n         \n         // spelling custom dictionaries\n         if (!JsUtil.areEqual(\n                     spellingCustomDictionaries().getGlobalValue(),\n                     newUiPrefs.spellingCustomDictionaries().getGlobalValue()))\n         {\n            spellingCustomDictionaries().setGlobalValue(\n                     newUiPrefs.spellingCustomDictionaries().getGlobalValue());\n         }\n            \n         // ignore words in uppercase\n         ignoreWordsInUppercase().setGlobalValue(\n                    newUiPrefs.ignoreWordsInUppercase().getGlobalValue());\n         \n         // ignore words with numbers\n         ignoreWordsWithNumbers().setGlobalValue(\n                    newUiPrefs.ignoreWordsWithNumbers().getGlobalValue());\n         \n         // navigate to build error\n         navigateToBuildError().setGlobalValue(\n                    newUiPrefs.navigateToBuildError().getGlobalValue());\n         \n         // enable packages pane\n         packagesPaneEnabled().setGlobalValue(\n                    newUiPrefs.packagesPaneEnabled().getGlobalValue());\n         \n         // use rcpp template\n         useRcppTemplate().setGlobalValue(\n                    newUiPrefs.useRcppTemplate().getGlobalValue());\n         \n         // restore source documents\n         restoreSourceDocuments().setGlobalValue(\n                    newUiPrefs.restoreSourceDocuments().getGlobalValue());\n         \n         // break in user code only on unhandled errors\n         handleErrorsInUserCodeOnly().setGlobalValue(\n                    newUiPrefs.handleErrorsInUserCodeOnly().getGlobalValue());\n                    \n         // auto expand error tracebacks\n         autoExpandErrorTracebacks().setGlobalValue(\n                    newUiPrefs.autoExpandErrorTracebacks().getGlobalValue());\n         \n         // preferred R Markdown template\n         rmdPreferredTemplatePath().setGlobalValue(\n               newUiPrefs.rmdPreferredTemplatePath().getGlobalValue());\n\n         // whether to show publish UI \n         showPublishUi().setGlobalValue(\n               newUiPrefs.showPublishUi().getGlobalValue());\n      }\n      else if (e.getType().equals(UiPrefsChangedEvent.PROJECT_TYPE))\n      {\n         // get prefs accessor\n         UIPrefsAccessor newUiPrefs = new UIPrefsAccessor(\n                                                   JsObject.createJsObject(),\n                                                   e.getUIPrefs());\n         \n         // use spaces for tab\n         useSpacesForTab().setProjectValue(\n                          newUiPrefs.useSpacesForTab().getValue());\n           \n         // num spaces for tab\n         numSpacesForTab().setProjectValue(\n               newUiPrefs.numSpacesForTab().getValue());\n         \n         // auto-append newline\n         autoAppendNewline().setProjectValue(\n               newUiPrefs.autoAppendNewline().getValue());\n         \n         // strip trailing whitespace\n         stripTrailingWhitespace().setProjectValue(\n               newUiPrefs.stripTrailingWhitespace().getValue());\n   \n         // default encoding\n         defaultEncoding().setProjectValue(\n                                 newUiPrefs.defaultEncoding().getValue());\n         \n         // default sweave engine\n         defaultSweaveEngine().setProjectValue(\n                                 newUiPrefs.defaultSweaveEngine().getValue());\n         \n         // default latex program\n         defaultLatexProgram().setProjectValue(\n                            newUiPrefs.defaultLatexProgram().getValue());\n         \n         // root document\n         rootDocument().setProjectValue(newUiPrefs.rootDocument().getValue());\n         \n         // use roxygen\n         useRoxygen().setProjectValue(newUiPrefs.useRoxygen().getValue());\n      }\n      else\n      {\n         Debug.log(\"Unexpected uiPrefs type: \" + e.getType());\n      }\n   }","commit_id":"be25fe2fd37512b9f368b9538117c30873bac6cb","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public GeneralPreferencesPane(RemoteFileSystemContext fsContext,\n                                 FileDialogs fileDialogs,\n                                 UIPrefs prefs,\n                                 final GlobalDisplay globalDisplay,\n                                 SourceServerOperations server)\n   {\n      fsContext_ = fsContext;\n      fileDialogs_ = fileDialogs;\n      prefs_ = prefs;\n      server_ = server;\n\n      if (Desktop.isDesktop())\n      {\n         if (Desktop.getFrame().canChooseRVersion())\n         {\n            rVersion_ = new TextBoxWithButton(\n                  \"R version:\",\n                  \"Change...\",\n                  new ClickHandler()\n                  {\n                     public void onClick(ClickEvent event)\n                     {\n                        String ver = Desktop.getFrame().chooseRVersion();\n                        if (!StringUtil.isNullOrEmpty(ver))\n                        {\n                           rVersion_.setText(ver);\n\n                           globalDisplay.showMessage(MessageDialog.INFO,\n                                 \"Change R Version\",\n                                 \"You need to quit and re-open RStudio \" +\n                                 \"in order for this change to take effect.\");\n                        }\n                     }\n                  });\n            rVersion_.setWidth(\"100%\");\n            rVersion_.setText(Desktop.getFrame().getRVersion());\n            spaced(rVersion_);\n            add(rVersion_);\n         }\n      }\n\n      Label defaultLabel = new Label(\"Default working directory (when not in a project):\");\n      nudgeRight(defaultLabel);\n      add(tight(defaultLabel));\n      add(dirChooser_ = new DirectoryChooserTextBox(null, \n                                                    null,\n                                                    fileDialogs_, \n                                                    fsContext_));  \n      spaced(dirChooser_);\n      nudgeRight(dirChooser_);\n      textBoxWithChooser(dirChooser_);\n\n      restoreLastProject_ = new CheckBox(\"Restore most recently opened project at startup\");\n      lessSpaced(restoreLastProject_);\n      add(restoreLastProject_);\n      \n      add(checkboxPref(\"Restore previously open source documents at startup\", prefs_.restoreSourceDocuments()));\n        \n      add(loadRData_ = new CheckBox(\"Restore .RData into workspace at startup\"));\n      lessSpaced(loadRData_); \n      \n      saveWorkspace_ = new SelectWidget(\n            \"Save workspace to .RData on exit:\",\n            new String[] {\n                  \"Always\",\n                  \"Never\",\n                  \"Ask\"\n            });\n      spaced(saveWorkspace_);\n      add(saveWorkspace_);\n      \n      alwaysSaveHistory_ = new CheckBox(\n            \"Always save history (even when not saving .RData)\");\n      lessSpaced(alwaysSaveHistory_);\n      add(alwaysSaveHistory_);\n      \n      removeHistoryDuplicates_ = new CheckBox(\n                                 \"Remove duplicate entries in history\");\n      spaced(removeHistoryDuplicates_);\n      add(removeHistoryDuplicates_);\n\n      rProfileOnResume_ = new CheckBox(\"Run Rprofile when resuming suspended session\");\n      spaced(rProfileOnResume_);\n      if (!Desktop.isDesktop())\n         add(rProfileOnResume_);\n           \n      encodingValue_ = prefs_.defaultEncoding().getGlobalValue();\n      add(encoding_ = new TextBoxWithButton(\n            \"Default text encoding:\",\n            \"Change...\",\n            new ClickHandler()\n            {\n               public void onClick(ClickEvent event)\n               {\n                  server_.iconvlist(new SimpleRequestCallback<IconvListResult>()\n                  {\n                     @Override\n                     public void onResponseReceived(IconvListResult response)\n                     {\n                        new ChooseEncodingDialog(\n                              response.getCommon(),\n                              response.getAll(),\n                              encodingValue_,\n                              true,\n                              false,\n                              new OperationWithInput<String>()\n                              {\n                                 public void execute(String encoding)\n                                 {\n                                    if (encoding == null)\n                                       return;\n\n                                    setEncoding(encoding);\n                                 }\n                              }).showModal();\n                     }\n                  });\n\n               }\n            }));\n      nudgeRight(encoding_);\n      textBoxWithChooser(encoding_);\n      spaced(encoding_);\n      setEncoding(prefs.defaultEncoding().getGlobalValue());\n      \n      add(checkboxPref(\n            \"Use debug error handler only when errors contain my code\", \n            prefs_.handleErrorsInUserCodeOnly()));\n      add(checkboxPref(\"Automatically expand error tracebacks\", \n            prefs_.autoExpandErrorTracebacks()));\n            \n      saveWorkspace_.setEnabled(false);\n      loadRData_.setEnabled(false);\n      dirChooser_.setEnabled(false);\n      alwaysSaveHistory_.setEnabled(false);\n      removeHistoryDuplicates_.setEnabled(false);\n      rProfileOnResume_.setEnabled(false);\n      restoreLastProject_.setEnabled(false);\n   }","id":74710,"modified_method":"@Inject\n   public GeneralPreferencesPane(RemoteFileSystemContext fsContext,\n                                 FileDialogs fileDialogs,\n                                 UIPrefs prefs,\n                                 final GlobalDisplay globalDisplay,\n                                 SourceServerOperations server)\n   {\n      fsContext_ = fsContext;\n      fileDialogs_ = fileDialogs;\n      prefs_ = prefs;\n      server_ = server;\n\n      if (Desktop.isDesktop())\n      {\n         if (Desktop.getFrame().canChooseRVersion())\n         {\n            rVersion_ = new TextBoxWithButton(\n                  \"R version:\",\n                  \"Change...\",\n                  new ClickHandler()\n                  {\n                     public void onClick(ClickEvent event)\n                     {\n                        String ver = Desktop.getFrame().chooseRVersion();\n                        if (!StringUtil.isNullOrEmpty(ver))\n                        {\n                           rVersion_.setText(ver);\n\n                           globalDisplay.showMessage(MessageDialog.INFO,\n                                 \"Change R Version\",\n                                 \"You need to quit and re-open RStudio \" +\n                                 \"in order for this change to take effect.\");\n                        }\n                     }\n                  });\n            rVersion_.setWidth(\"100%\");\n            rVersion_.setText(Desktop.getFrame().getRVersion());\n            spaced(rVersion_);\n            add(rVersion_);\n         }\n      }\n\n      Label defaultLabel = new Label(\"Default working directory (when not in a project):\");\n      nudgeRight(defaultLabel);\n      add(tight(defaultLabel));\n      add(dirChooser_ = new DirectoryChooserTextBox(null, \n                                                    null,\n                                                    fileDialogs_, \n                                                    fsContext_));  \n      spaced(dirChooser_);\n      nudgeRight(dirChooser_);\n      textBoxWithChooser(dirChooser_);\n\n      restoreLastProject_ = new CheckBox(\"Restore most recently opened project at startup\");\n      lessSpaced(restoreLastProject_);\n      add(restoreLastProject_);\n      \n      add(checkboxPref(\"Restore previously open source documents at startup\", prefs_.restoreSourceDocuments()));\n        \n      add(loadRData_ = new CheckBox(\"Restore .RData into workspace at startup\"));\n      lessSpaced(loadRData_); \n      \n      saveWorkspace_ = new SelectWidget(\n            \"Save workspace to .RData on exit:\",\n            new String[] {\n                  \"Always\",\n                  \"Never\",\n                  \"Ask\"\n            });\n      spaced(saveWorkspace_);\n      add(saveWorkspace_);\n      \n      alwaysSaveHistory_ = new CheckBox(\n            \"Always save history (even when not saving .RData)\");\n      lessSpaced(alwaysSaveHistory_);\n      add(alwaysSaveHistory_);\n      \n      removeHistoryDuplicates_ = new CheckBox(\n                                 \"Remove duplicate entries in history\");\n      spaced(removeHistoryDuplicates_);\n      add(removeHistoryDuplicates_);\n\n      rProfileOnResume_ = new CheckBox(\"Run Rprofile when resuming suspended session\");\n      spaced(rProfileOnResume_);\n      if (!Desktop.isDesktop())\n         add(rProfileOnResume_);\n           \n      add(checkboxPref(\n            \"Use debug error handler only when errors contain my code\", \n            prefs_.handleErrorsInUserCodeOnly()));\n      CheckBox chkTracebacks = checkboxPref(\n            \"Automatically expand tracebacks in error inspector\", \n            prefs_.autoExpandErrorTracebacks());\n      chkTracebacks.getElement().getStyle().setMarginBottom(15, Unit.PX);\n      add(chkTracebacks);\n      \n      encodingValue_ = prefs_.defaultEncoding().getGlobalValue();\n      add(encoding_ = new TextBoxWithButton(\n            \"Default text encoding:\",\n            \"Change...\",\n            new ClickHandler()\n            {\n               public void onClick(ClickEvent event)\n               {\n                  server_.iconvlist(new SimpleRequestCallback<IconvListResult>()\n                  {\n                     @Override\n                     public void onResponseReceived(IconvListResult response)\n                     {\n                        new ChooseEncodingDialog(\n                              response.getCommon(),\n                              response.getAll(),\n                              encodingValue_,\n                              true,\n                              false,\n                              new OperationWithInput<String>()\n                              {\n                                 public void execute(String encoding)\n                                 {\n                                    if (encoding == null)\n                                       return;\n\n                                    setEncoding(encoding);\n                                 }\n                              }).showModal();\n                     }\n                  });\n\n               }\n            }));\n      nudgeRight(encoding_);\n      textBoxWithChooser(encoding_);\n      spaced(encoding_);\n      setEncoding(prefs.defaultEncoding().getGlobalValue());\n            \n      saveWorkspace_.setEnabled(false);\n      loadRData_.setEnabled(false);\n      dirChooser_.setEnabled(false);\n      alwaysSaveHistory_.setEnabled(false);\n      removeHistoryDuplicates_.setEnabled(false);\n      rProfileOnResume_.setEnabled(false);\n      restoreLastProject_.setEnabled(false);\n   }","commit_id":"25bc5b104675089d72030133a1de0619bfcab803","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public WritingPreferencesPane(UIPrefs prefs,\n                                 PreferencesDialogResources res)\n   {\n      prefs_ = prefs;\n      res_ = res;\n      PreferencesDialogBaseResources baseRes = PreferencesDialogBaseResources.INSTANCE;\n\n      Label pdfCompilationLabel = new Label(\"Compile PDF\");\n      pdfCompilationLabel.addStyleName(baseRes.styles().headerLabel());\n      nudgeRight(pdfCompilationLabel);\n      add(pdfCompilationLabel);\n            \n      defaultSweaveEngine_ = new RnwWeaveSelectWidget();\n      defaultSweaveEngine_.setValue(\n                              prefs.defaultSweaveEngine().getGlobalValue());\n      add(defaultSweaveEngine_);\n      \n      defaultLatexProgram_ = new LatexProgramSelectWidget();\n      defaultLatexProgram_.setValue(\n                              prefs.defaultLatexProgram().getGlobalValue());\n      add(defaultLatexProgram_);\n      \n      Label perProjectLabel = new Label(\n            \"NOTE: The Rnw weave and LaTeX program options are also set on a \" +\n            \"per-project (and optionally per-file) basis. Click the help \" +\n            \"icons above for more details.\");\n           \n      perProjectLabel.addStyleName(baseRes.styles().infoLabel());\n      nudgeRight(perProjectLabel);\n      spaced(perProjectLabel);\n      add(perProjectLabel);\n      \n      add(checkboxPref(\n            \"Resolve cross-references and build indices using texi2dvi\",\n            prefs_.useTexi2Dvi()));\n      \n   }","id":74711,"modified_method":"@Inject\n   public WritingPreferencesPane(UIPrefs prefs,\n                                 PreferencesDialogResources res)\n   {\n      prefs_ = prefs;\n      res_ = res;\n      PreferencesDialogBaseResources baseRes = PreferencesDialogBaseResources.INSTANCE;\n\n      Label pdfCompilationLabel = new Label(\"Compile PDF\");\n      pdfCompilationLabel.addStyleName(baseRes.styles().headerLabel());\n      nudgeRight(pdfCompilationLabel);\n      add(pdfCompilationLabel);\n            \n      defaultSweaveEngine_ = new RnwWeaveSelectWidget();\n      defaultSweaveEngine_.setValue(\n                              prefs.defaultSweaveEngine().getGlobalValue());\n      add(defaultSweaveEngine_);\n      \n      defaultLatexProgram_ = new LatexProgramSelectWidget();\n      defaultLatexProgram_.setValue(\n                              prefs.defaultLatexProgram().getGlobalValue());\n      add(defaultLatexProgram_);\n      \n      Label perProjectLabel = new Label(\n            \"NOTE: The Rnw weave and LaTeX program options are also set on a \" +\n            \"per-project (and optionally per-file) basis. Click the help \" +\n            \"icons above for more details.\");\n           \n      perProjectLabel.addStyleName(baseRes.styles().infoLabel());\n      nudgeRight(perProjectLabel);\n      spaced(perProjectLabel);\n      add(perProjectLabel);\n      \n      CheckBox checkBox = checkboxPref(\n            \"Resolve cross-references and build indices using texi2dvi\",\n            prefs_.useTexi2Dvi());\n      add(checkBox);\n      \n   }","commit_id":"82f737f86ff84da703852d6594ba0aabe7951382","url":"https://github.com/rstudio/rstudio"},{"original_method":"@Inject\n   public EditingPreferencesPane(UIPrefs prefs)\n   {\n      prefs_ = prefs;\n      \n      VerticalPanel editingPanel = new VerticalPanel();\n      editingPanel.add(tight(spacesForTab_ = checkboxPref(\"Insert spaces for tab\", prefs.useSpacesForTab())));\n      editingPanel.add(indent(tabWidth_ = numericPref(\"Tab width\", prefs.numSpacesForTab())));   \n      editingPanel.add(checkboxPref(\"Insert matching parens/quotes\", prefs_.insertMatching()));\n      editingPanel.add(checkboxPref(\"Auto-indent code after paste\", prefs_.reindentOnPaste()));\n      editingPanel.add(checkboxPref(\"Vertically align arguments in auto-indent\", prefs_.verticallyAlignArgumentIndent()));\n      editingPanel.add(checkboxPref(\"Soft-wrap R source files\", prefs_.softWrapRFiles()));\n      editingPanel.add(checkboxPref(\"Ensure that source files end with newline\", prefs_.autoAppendNewline()));\n      editingPanel.add(checkboxPref(\"Strip trailing horizontal whitespace when saving\", prefs_.stripTrailingWhitespace()));\n      editingPanel.add(checkboxPref(\"Focus console after executing from source\", prefs_.focusConsoleAfterExec()));\n      editingPanel.add(checkboxPref(\"Enable vim editing mode\", prefs_.useVimMode()));\n      editingPanel.add(checkboxPref(\n            \"Continue comment when inserting new line\",\n            prefs_.continueCommentsOnNewline(),\n            \"When enabled, pressing enter will continue comments on new lines. Press Shift + Enter to exit a comment.\"));\n      \n      VerticalPanel displayPanel = new VerticalPanel();\n      displayPanel.add(checkboxPref(\"Highlight selected word\", prefs.highlightSelectedWord()));\n      displayPanel.add(checkboxPref(\"Highlight selected line\", prefs.highlightSelectedLine()));\n      displayPanel.add(checkboxPref(\"Show line numbers\", prefs.showLineNumbers()));\n      displayPanel.add(tight(showMargin_ = checkboxPref(\"Show margin\", prefs.showMargin())));\n      displayPanel.add(indent(marginCol_ = numericPref(\"Margin column\", prefs.printMarginColumn())));\n      displayPanel.add(checkboxPref(\"Show whitespace characters\", prefs_.showInvisibles()));\n      displayPanel.add(checkboxPref(\"Show indent guides\", prefs_.showIndentGuides()));\n      displayPanel.add(checkboxPref(\"Blinking cursor\", prefs_.blinkingCursor()));\n      displayPanel.add(checkboxPref(\"Show syntax highlighting in console input\", prefs_.syntaxColorConsole()));\n      \n      VerticalPanel completionPanel = new VerticalPanel();\n      showCompletions_ = new SelectWidget(\n            \"Show code completions:\",\n            new String[] {\n                  \"Always\",\n                  \"When Triggered\",\n                  \"Manually (Tab)\"\n            },\n            new String[] {\n                  UIPrefsAccessor.COMPLETION_ALWAYS,\n                  UIPrefsAccessor.COMPLETION_WHEN_TRIGGERED,\n                  UIPrefsAccessor.COMPLETION_MANUAL\n            },\n            false, \n            true, \n            false);\n      \n      spaced(showCompletions_);\n      completionPanel.add(showCompletions_);\n      \n      completionPanel.add(checkboxPref(\"Insert parentheses after function completions\", prefs.insertParensAfterFunctionCompletion()));\n      completionPanel.add(checkboxPref(\"Show help tooltip after function completions\", prefs.showSignatureTooltips()));    \n      completionPanel.add(checkboxPref(\"Insert spaces around equals for argument completions\", prefs.insertSpacesAroundEquals()));\n      completionPanel.add(checkboxPref(\"Use tab for multiline autocompletions\", prefs.allowTabMultilineCompletion()));\n      \n      DialogTabLayoutPanel tabPanel = new DialogTabLayoutPanel();\n      tabPanel.setSize(\"435px\", \"460px\");     \n      tabPanel.add(editingPanel, \"Editing\");\n      tabPanel.add(displayPanel, \"Display\");\n      tabPanel.add(completionPanel, \"Completion\");\n      tabPanel.selectTab(0);\n      add(tabPanel);\n   }","id":74712,"modified_method":"@Inject\n   public EditingPreferencesPane(UIPrefs prefs)\n   {\n      prefs_ = prefs;\n      \n      VerticalPanel editingPanel = new VerticalPanel();\n      editingPanel.add(tight(spacesForTab_ = checkboxPref(\"Insert spaces for tab\", prefs.useSpacesForTab())));\n      editingPanel.add(indent(tabWidth_ = numericPref(\"Tab width\", prefs.numSpacesForTab())));   \n      editingPanel.add(checkboxPref(\"Insert matching parens/quotes\", prefs_.insertMatching()));\n      editingPanel.add(checkboxPref(\"Auto-indent code after paste\", prefs_.reindentOnPaste()));\n      editingPanel.add(checkboxPref(\"Vertically align arguments in auto-indent\", prefs_.verticallyAlignArgumentIndent()));\n      editingPanel.add(checkboxPref(\"Soft-wrap R source files\", prefs_.softWrapRFiles()));\n      editingPanel.add(checkboxPref(\"Ensure that source files end with newline\", prefs_.autoAppendNewline()));\n      editingPanel.add(checkboxPref(\"Strip trailing horizontal whitespace when saving\", prefs_.stripTrailingWhitespace()));\n      editingPanel.add(checkboxPref(\"Focus console after executing from source\", prefs_.focusConsoleAfterExec()));\n      editingPanel.add(checkboxPref(\"Enable vim editing mode\", prefs_.useVimMode()));\n      editingPanel.add(checkboxPref(\n            \"Continue comment when inserting new line\",\n            prefs_.continueCommentsOnNewline(),\n            \"When enabled, pressing enter will continue comments on new lines. Press Shift + Enter to exit a comment.\"));\n      \n      VerticalPanel displayPanel = new VerticalPanel();\n      displayPanel.add(checkboxPref(\"Highlight selected word\", prefs.highlightSelectedWord()));\n      displayPanel.add(checkboxPref(\"Highlight selected line\", prefs.highlightSelectedLine()));\n      displayPanel.add(checkboxPref(\"Show line numbers\", prefs.showLineNumbers()));\n      displayPanel.add(tight(showMargin_ = checkboxPref(\"Show margin\", prefs.showMargin())));\n      displayPanel.add(indent(marginCol_ = numericPref(\"Margin column\", prefs.printMarginColumn())));\n      displayPanel.add(checkboxPref(\"Show whitespace characters\", prefs_.showInvisibles()));\n      displayPanel.add(checkboxPref(\"Show indent guides\", prefs_.showIndentGuides()));\n      displayPanel.add(checkboxPref(\"Blinking cursor\", prefs_.blinkingCursor()));\n      displayPanel.add(checkboxPref(\"Show syntax highlighting in console input\", prefs_.syntaxColorConsole()));\n      \n      VerticalPanel completionPanel = new VerticalPanel();\n      showCompletions_ = new SelectWidget(\n            \"Show code completions:\",\n            new String[] {\n                  \"Always\",\n                  \"When Triggered\",\n                  \"Manually (Tab)\"\n            },\n            new String[] {\n                  UIPrefsAccessor.COMPLETION_ALWAYS,\n                  UIPrefsAccessor.COMPLETION_WHEN_TRIGGERED,\n                  UIPrefsAccessor.COMPLETION_MANUAL\n            },\n            false, \n            true, \n            false);\n      \n      spaced(showCompletions_);\n      completionPanel.add(showCompletions_);\n      \n      final CheckBox insertParensAfterFunctionCompletionsCheckbox =\n           checkboxPref(\"Insert parentheses after function completions\",\n                 prefs.insertParensAfterFunctionCompletion());\n      \n      final CheckBox showSignatureTooltipsCheckbox =\n           checkboxPref(\"Show help tooltip after function completions\",\n                 prefs.showSignatureTooltips());\n      \n      if (insertParensAfterFunctionCompletionsCheckbox.getValue() == false)\n         disable(showSignatureTooltipsCheckbox);\n      \n      insertParensAfterFunctionCompletionsCheckbox.addValueChangeHandler(\n            new ValueChangeHandler<Boolean>()\n            {\n               @Override\n               public void onValueChange(ValueChangeEvent<Boolean> event)\n               {\n                  if (event.getValue() == false)\n                     disable(showSignatureTooltipsCheckbox);\n                  else\n                     enable(showSignatureTooltipsCheckbox);\n               }\n            });\n      \n      completionPanel.add(insertParensAfterFunctionCompletionsCheckbox);\n      completionPanel.add(showSignatureTooltipsCheckbox);\n      completionPanel.add(checkboxPref(\"Insert spaces around equals for argument completions\", prefs.insertSpacesAroundEquals()));\n      completionPanel.add(checkboxPref(\"Use tab for multiline autocompletions\", prefs.allowTabMultilineCompletion()));\n      \n      DialogTabLayoutPanel tabPanel = new DialogTabLayoutPanel();\n      tabPanel.setSize(\"435px\", \"460px\");     \n      tabPanel.add(editingPanel, \"Editing\");\n      tabPanel.add(displayPanel, \"Display\");\n      tabPanel.add(completionPanel, \"Completion\");\n      tabPanel.selectTab(0);\n      add(tabPanel);\n   }","commit_id":"60a44bb348da35130030529ee5545b8d1a047d94","url":"https://github.com/rstudio/rstudio"},{"original_method":"/**\n     * Builds a list of nodes. If matchAnyShard is set to false, only nodes that have an allocation id matching\n     * lastActiveAllocationIds are added to the list. Otherwise, any node that has a shard is added to the list, but\n     * entries with matching allocation id are always at the front of the list.\n     */\n    protected NodesAndVersions buildAllocationIdBasedNodes(ShardRouting shard, boolean matchAnyShard, Set<String> ignoreNodes,\n                                                           Set<String> lastActiveAllocationIds, AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState) {\n        List<DiscoveryNode> matchingNodes = new ArrayList<>();\n        List<DiscoveryNode> nonMatchingNodes = new ArrayList<>();\n        long highestVersion = -1;\n        for (TransportNodesListGatewayStartedShards.NodeGatewayStartedShards nodeShardState : shardState.getData().values()) {\n            DiscoveryNode node = nodeShardState.getNode();\n            String allocationId = nodeShardState.allocationId();\n\n            if (ignoreNodes.contains(node.id())) {\n                continue;\n            }\n\n            if (nodeShardState.storeException() == null) {\n                if (allocationId == null && nodeShardState.version() != -1) {\n                    // old shard with no allocation id, assign dummy value so that it gets added below in case of matchAnyShard\n                    allocationId = \"_n/a_\";\n                }\n\n                logger.trace(\"[{}] on node [{}] has allocation id [{}] of shard\", shard, nodeShardState.getNode(), allocationId);\n            } else {\n                logger.trace(\"[{}] on node [{}] has allocation id [{}] but the store can not be opened, treating as no allocation id\", nodeShardState.storeException(), shard, nodeShardState.getNode(), allocationId);\n                allocationId = null;\n            }\n\n            if (allocationId != null) {\n                if (lastActiveAllocationIds.contains(allocationId)) {\n                    matchingNodes.add(node);\n                    highestVersion = Math.max(highestVersion, nodeShardState.version());\n                } else if (matchAnyShard) {\n                    nonMatchingNodes.add(node);\n                    highestVersion = Math.max(highestVersion, nodeShardState.version());\n                }\n            }\n        }\n\n        List<DiscoveryNode> nodes = new ArrayList<>();\n        nodes.addAll(matchingNodes);\n        nodes.addAll(nonMatchingNodes);\n\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"{} candidates for allocation: {}\", shard, nodes.stream().map(DiscoveryNode::name).collect(Collectors.joining(\", \")));\n        }\n        return new NodesAndVersions(nodes, nodes.size(), highestVersion);\n    }","id":74713,"modified_method":"/**\n     * Builds a list of nodes. If matchAnyShard is set to false, only nodes that have an allocation id matching\n     * lastActiveAllocationIds are added to the list. Otherwise, any node that has a shard is added to the list, but\n     * entries with matching allocation id are always at the front of the list.\n     */\n    protected NodesAndVersions buildAllocationIdBasedNodes(ShardRouting shard, boolean matchAnyShard, Set<String> ignoreNodes,\n                                                           Set<String> lastActiveAllocationIds, AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState) {\n        LinkedList<DiscoveryNode> matchingNodes = new LinkedList<>();\n        LinkedList<DiscoveryNode> nonMatchingNodes = new LinkedList<>();\n        long highestVersion = -1;\n        for (TransportNodesListGatewayStartedShards.NodeGatewayStartedShards nodeShardState : shardState.getData().values()) {\n            DiscoveryNode node = nodeShardState.getNode();\n            String allocationId = nodeShardState.allocationId();\n\n            if (ignoreNodes.contains(node.id())) {\n                continue;\n            }\n\n            if (nodeShardState.storeException() == null) {\n                if (allocationId == null && nodeShardState.version() != -1) {\n                    // old shard with no allocation id, assign dummy value so that it gets added below in case of matchAnyShard\n                    allocationId = \"_n/a_\";\n                }\n\n                logger.trace(\"[{}] on node [{}] has allocation id [{}] of shard\", shard, nodeShardState.getNode(), allocationId);\n            } else {\n                logger.trace(\"[{}] on node [{}] has allocation id [{}] but the store can not be opened, treating as no allocation id\", nodeShardState.storeException(), shard, nodeShardState.getNode(), allocationId);\n                allocationId = null;\n            }\n\n            if (allocationId != null) {\n                if (lastActiveAllocationIds.contains(allocationId)) {\n                    if (nodeShardState.primary()) {\n                        matchingNodes.addFirst(node);\n                    } else {\n                        matchingNodes.addLast(node);\n                    }\n                    highestVersion = Math.max(highestVersion, nodeShardState.version());\n                } else if (matchAnyShard) {\n                    if (nodeShardState.primary()) {\n                        nonMatchingNodes.addFirst(node);\n                    } else {\n                        nonMatchingNodes.addLast(node);\n                    }\n                    highestVersion = Math.max(highestVersion, nodeShardState.version());\n                }\n            }\n        }\n\n        List<DiscoveryNode> nodes = new ArrayList<>();\n        nodes.addAll(matchingNodes);\n        nodes.addAll(nonMatchingNodes);\n\n        if (logger.isTraceEnabled()) {\n            logger.trace(\"{} candidates for allocation: {}\", shard, nodes.stream().map(DiscoveryNode::name).collect(Collectors.joining(\", \")));\n        }\n        return new NodesAndVersions(nodes, nodes.size(), highestVersion);\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests when the node returns data with a shard allocation id that does not match active allocation ids, it will be moved to ignore unassigned.\n     */\n    public void testNoMatchingAllocationIdFound() {\n        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.CURRENT, \"id2\");\n        testAllocator.addData(node1, 1, \"id1\");\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","id":74714,"modified_method":"/**\n     * Tests when the node returns data with a shard allocation id that does not match active allocation ids, it will be moved to ignore unassigned.\n     */\n    public void testNoMatchingAllocationIdFound() {\n        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.CURRENT, \"id2\");\n        testAllocator.addData(node1, 1, \"id1\", randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when restoring from a snapshot and we find a node with a shard copy but allocation\n     * deciders say no, we still allocate to that node.\n     */\n    public void testRestoreForcesAllocateIfShardAvailable() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(noAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"some allocId\"));\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","id":74715,"modified_method":"/**\n     * Tests that when restoring from a snapshot and we find a node with a shard copy but allocation\n     * deciders say no, we still allocate to that node.\n     */\n    public void testRestoreForcesAllocateIfShardAvailable() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(noAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"some allocId\"), randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when restoring from a snapshot and we don't find a node with a shard copy, the shard will remain in\n     * the unassigned list to be allocated later.\n     */\n    public void testRestoreDoesNotAssignIfNoShardAvailable() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, -1, null);\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1));\n    }","id":74716,"modified_method":"/**\n     * Tests that when restoring from a snapshot and we don't find a node with a shard copy, the shard will remain in\n     * the unassigned list to be allocated later.\n     */\n    public void testRestoreDoesNotAssignIfNoShardAvailable() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, -1, null, false);\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when restoring from a snapshot and we find a node with a shard copy and allocation\n     * deciders say throttle, we add it to ignored shards.\n     */\n    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"));\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n    }","id":74717,"modified_method":"/**\n     * Tests that when restoring from a snapshot and we find a node with a shard copy and allocation\n     * deciders say throttle, we add it to ignored shards.\n     */\n    public void testRestoreThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"), randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that only when enough copies of the shard exists we are going to allocate it. This test\n     * verifies that with same version (1), and quorum allocation.\n     */\n    public void testEnoughCopiesFoundForAllocationOnLegacyIndex() {\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.V_2_0_0)).numberOfShards(1).numberOfReplicas(2))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsRecovery(metaData.index(shardId.getIndex()))\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n\n        RoutingAllocation allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node1, 1, null);\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node2, 1, null);\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(0));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), anyOf(equalTo(node2.id()), equalTo(node1.id())));\n    }","id":74718,"modified_method":"/**\n     * Tests that only when enough copies of the shard exists we are going to allocate it. This test\n     * verifies that with same version (1), and quorum allocation.\n     */\n    public void testEnoughCopiesFoundForAllocationOnLegacyIndex() {\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.V_2_0_0)).numberOfShards(1).numberOfReplicas(2))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsRecovery(metaData.index(shardId.getIndex()))\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n\n        RoutingAllocation allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node1, 1, null, randomBoolean());\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node2, 1, null, randomBoolean());\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(0));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), anyOf(equalTo(node2.id()), equalTo(node1.id())));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we find a node with a shard copy and allocation\n     * deciders say throttle, we add it to ignored shards.\n     */\n    public void testRecoverOnAnyNodeThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"));\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n    }","id":74719,"modified_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we find a node with a shard copy and allocation\n     * deciders say throttle, we add it to ignored shards.\n     */\n    public void testRecoverOnAnyNodeThrottle() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"), randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when there is a node to allocate the shard to, it will be allocated to it.\n     */\n    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\");\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_2_0);\n            testAllocator.addData(node1, 3, null);\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.id()));\n    }","id":74720,"modified_method":"/**\n     * Tests that when there is a node to allocate the shard to, it will be allocated to it.\n     */\n    public void testFoundAllocationAndAllocating() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\", randomBoolean());\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_2_0);\n            testAllocator.addData(node1, 3, null, randomBoolean());\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.id()));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private RoutingAllocation getRecoverOnAnyNodeRoutingAllocation(AllocationDeciders allocationDeciders) {\n        Version version = randomFrom(Version.CURRENT, Version.V_2_0_0);\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(version)\n                .put(IndexMetaData.SETTING_SHARED_FILESYSTEM, true)\n                .put(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, true))\n                .numberOfShards(1).numberOfReplicas(0).putActiveAllocationIds(0, version == Version.CURRENT ? new HashSet<>(Arrays.asList(\"allocId\")) : Collections.emptySet()))\n            .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsRestore(metaData.index(shardId.getIndex()), new RestoreSource(new SnapshotId(\"test\", \"test\"), Version.CURRENT, shardId.getIndex()))\n            .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n            .metaData(metaData)\n            .routingTable(routingTable)\n            .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(allocationDeciders, new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n    }","id":74721,"modified_method":"private RoutingAllocation getRecoverOnAnyNodeRoutingAllocation(AllocationDeciders allocationDeciders) {\n        Version version = randomFrom(Version.CURRENT, Version.V_2_0_0);\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(version)\n                .put(IndexMetaData.SETTING_SHARED_FILESYSTEM, true)\n                .put(IndexMetaData.SETTING_SHARED_FS_ALLOW_RECOVERY_ON_ANY_NODE, true))\n                .numberOfShards(1).numberOfReplicas(0).putActiveAllocationIds(0, version == Version.CURRENT ? Sets.newHashSet(\"allocId\") : Collections.emptySet()))\n            .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsRestore(metaData.index(shardId.getIndex()), new RestoreSource(new SnapshotId(\"test\", \"test\"), Version.CURRENT, shardId.getIndex()))\n            .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n            .metaData(metaData)\n            .routingTable(routingTable)\n            .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(allocationDeciders, new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public TestAllocator addData(DiscoveryNode node, long version, String allocationId) {\n            return addData(node, version, allocationId, null);\n        }","id":74722,"modified_method":"public TestAllocator addData(DiscoveryNode node, long version, String allocationId, boolean primary) {\n            return addData(node, version, allocationId, primary, null);\n        }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that the highest version node is chosen for allocation.\n     */\n    public void testAllocateToTheHighestVersionOnLegacyIndex() {\n        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_0_0);\n        testAllocator.addData(node1, 10, null).addData(node2, 12, null);\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.id()));\n    }","id":74723,"modified_method":"/**\n     * Tests that the highest version node is chosen for allocation.\n     */\n    public void testAllocateToTheHighestVersionOnLegacyIndex() {\n        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_0_0);\n        testAllocator.addData(node1, 10, null, randomBoolean()).addData(node2, 12, null, randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.id()));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private RoutingAllocation getRestoreRoutingAllocation(AllocationDeciders allocationDeciders) {\n        Version version = randomFrom(Version.CURRENT, Version.V_2_0_0);\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(version)).numberOfShards(1).numberOfReplicas(0)\n                .putActiveAllocationIds(0, version == Version.CURRENT ? new HashSet<>(Arrays.asList(\"allocId\")) : Collections.emptySet()))\n            .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsRestore(metaData.index(shardId.getIndex()), new RestoreSource(new SnapshotId(\"test\", \"test\"), version, shardId.getIndex()))\n            .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n            .metaData(metaData)\n            .routingTable(routingTable)\n            .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(allocationDeciders, new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n    }","id":74724,"modified_method":"private RoutingAllocation getRestoreRoutingAllocation(AllocationDeciders allocationDeciders) {\n        Version version = randomFrom(Version.CURRENT, Version.V_2_0_0);\n        MetaData metaData = MetaData.builder()\n            .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(version)).numberOfShards(1).numberOfReplicas(0)\n                .putActiveAllocationIds(0, version == Version.CURRENT ? Sets.newHashSet(\"allocId\") : Collections.emptySet()))\n            .build();\n\n        RoutingTable routingTable = RoutingTable.builder()\n            .addAsRestore(metaData.index(shardId.getIndex()), new RestoreSource(new SnapshotId(\"test\", \"test\"), version, shardId.getIndex()))\n            .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n            .metaData(metaData)\n            .routingTable(routingTable)\n            .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(allocationDeciders, new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when there is a node to allocate to, but it is throttling (and it is the only one),\n     * it will be moved to ignore unassigned until it can be allocated to.\n     */\n    public void testFoundAllocationButThrottlingDecider() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\");\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), false, Version.V_2_2_0);\n            testAllocator.addData(node1, 3, null);\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","id":74725,"modified_method":"/**\n     * Tests that when there is a node to allocate to, but it is throttling (and it is the only one),\n     * it will be moved to ignore unassigned until it can be allocated to.\n     */\n    public void testFoundAllocationButThrottlingDecider() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\", randomBoolean());\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), false, Version.V_2_2_0);\n            testAllocator.addData(node1, 3, null, randomBoolean());\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we find a node with a shard copy but allocation\n     * deciders say no, we still allocate to that node.\n     */\n    public void testRecoverOnAnyNodeForcesAllocateIfShardAvailable() {\n        RoutingAllocation allocation = getRecoverOnAnyNodeRoutingAllocation(noAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"));\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","id":74726,"modified_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we find a node with a shard copy but allocation\n     * deciders say no, we still allocate to that node.\n     */\n    public void testRecoverOnAnyNodeForcesAllocateIfShardAvailable() {\n        RoutingAllocation allocation = getRecoverOnAnyNodeRoutingAllocation(noAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"), randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests when the node returns that no data was found for it, it will be moved to ignore unassigned.\n     */\n    public void testStoreException() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\", new CorruptIndexException(\"test\", \"test\"));\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_1_1);\n            testAllocator.addData(node1, 3, null, new CorruptIndexException(\"test\", \"test\"));\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","id":74727,"modified_method":"/**\n     * Tests when the node returns that no data was found for it, it will be moved to ignore unassigned.\n     */\n    public void testStoreException() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\", randomBoolean(), new CorruptIndexException(\"test\", \"test\"));\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_1_1);\n            testAllocator.addData(node1, 3, null, randomBoolean(), new CorruptIndexException(\"test\", \"test\"));\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private RoutingAllocation routingAllocationWithOnePrimaryNoReplicas(AllocationDeciders deciders, boolean asNew, Version version, String... activeAllocationIds) {\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(version))\n                    .numberOfShards(1).numberOfReplicas(0).putActiveAllocationIds(0, new HashSet<>(Arrays.asList(activeAllocationIds))))\n            .build();\n        RoutingTable.Builder routingTableBuilder = RoutingTable.builder();\n        if (asNew) {\n            routingTableBuilder.addAsNew(metaData.index(shardId.getIndex()));\n        } else {\n            routingTableBuilder.addAsRecovery(metaData.index(shardId.getIndex()));\n        }\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTableBuilder.build())\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n    }","id":74728,"modified_method":"private RoutingAllocation routingAllocationWithOnePrimaryNoReplicas(AllocationDeciders deciders, boolean asNew, Version version, String... activeAllocationIds) {\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(version))\n                    .numberOfShards(1).numberOfReplicas(0).putActiveAllocationIds(0, Sets.newHashSet(activeAllocationIds)))\n            .build();\n        RoutingTable.Builder routingTableBuilder = RoutingTable.builder();\n        if (asNew) {\n            routingTableBuilder.addAsNew(metaData.index(shardId.getIndex()));\n        } else {\n            routingTableBuilder.addAsRecovery(metaData.index(shardId.getIndex()));\n        }\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTableBuilder.build())\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests when the node returns that no data was found for it (-1 for version and null for allocation id),\n     * it will be moved to ignore unassigned.\n     */\n    public void testNoAllocationFound() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.CURRENT, \"allocId\");\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_1_0);\n        }\n        testAllocator.addData(node1, -1, null);\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","id":74729,"modified_method":"/**\n     * Tests when the node returns that no data was found for it (-1 for version and null for allocation id),\n     * it will be moved to ignore unassigned.\n     */\n    public void testNoAllocationFound() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.CURRENT, \"allocId\");\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_1_0);\n        }\n        testAllocator.addData(node1, -1, null, randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when restoring from a snapshot and we find a node with a shard copy and allocation\n     * deciders say yes, we allocate to that node.\n     */\n    public void testRestore() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"));\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","id":74730,"modified_method":"/**\n     * Tests that when restoring from a snapshot and we find a node with a shard copy and allocation\n     * deciders say yes, we allocate to that node.\n     */\n    public void testRestore() {\n        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"), randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public TestAllocator addData(DiscoveryNode node, long version, String allocationId, @Nullable Throwable storeException) {\n            if (data == null) {\n                data = new HashMap<>();\n            }\n            data.put(node, new TransportNodesListGatewayStartedShards.NodeGatewayStartedShards(node, version, allocationId, storeException));\n            return this;\n        }","id":74731,"modified_method":"public TestAllocator addData(DiscoveryNode node, long version, String allocationId, boolean primary, @Nullable Throwable storeException) {\n            if (data == null) {\n                data = new HashMap<>();\n            }\n            data.put(node, new TransportNodesListGatewayStartedShards.NodeGatewayStartedShards(node, version, allocationId, primary, storeException));\n            return this;\n        }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we find a node with a shard copy and allocation\n     * deciders say yes, we allocate to that node.\n     */\n    public void testRecoverOnAnyNode() {\n        RoutingAllocation allocation = getRecoverOnAnyNodeRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"));\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","id":74732,"modified_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we find a node with a shard copy and allocation\n     * deciders say yes, we allocate to that node.\n     */\n    public void testRecoverOnAnyNode() {\n        RoutingAllocation allocation = getRecoverOnAnyNodeRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, 1, randomFrom(null, \"allocId\"), randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we don't find a node with a shard copy we let\n     * BalancedShardAllocator assign the shard\n     */\n    public void testRecoverOnAnyNodeDoesNotAssignIfNoShardAvailable() {\n        RoutingAllocation allocation = getRecoverOnAnyNodeRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, -1, null);\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1));\n    }","id":74733,"modified_method":"/**\n     * Tests that when recovering using \"recover_on_any_node\" and we don't find a node with a shard copy we let\n     * BalancedShardAllocator assign the shard\n     */\n    public void testRecoverOnAnyNodeDoesNotAssignIfNoShardAvailable() {\n        RoutingAllocation allocation = getRecoverOnAnyNodeRoutingAllocation(yesAllocationDeciders());\n        testAllocator.addData(node1, -1, null, randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when there is a node to be allocated to, but it the decider said \"no\", we still\n     * force the allocation to it.\n     */\n    public void testFoundAllocationButNoDecider() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\");\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), false, Version.V_2_0_0);\n            testAllocator.addData(node1, 3, null);\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.id()));\n    }","id":74734,"modified_method":"/**\n     * Tests that when there is a node to be allocated to, but it the decider said \"no\", we still\n     * force the allocation to it.\n     */\n    public void testFoundAllocationButNoDecider() {\n        final RoutingAllocation allocation;\n        if (randomBoolean()) {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), false, randomFrom(Version.V_2_0_0, Version.CURRENT), \"allocId1\");\n            testAllocator.addData(node1, 1, \"allocId1\", randomBoolean());\n        } else {\n            allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), false, Version.V_2_0_0);\n            testAllocator.addData(node1, 3, null, randomBoolean());\n        }\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.id()));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that only when enough copies of the shard exists we are going to allocate it. This test\n     * verifies that even with different version, we treat different versions as a copy, and count them.\n     */\n    public void testEnoughCopiesFoundForAllocationOnLegacyIndexWithDifferentVersion() {\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.V_2_0_0)).numberOfShards(1).numberOfReplicas(2))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsRecovery(metaData.index(shardId.getIndex()))\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n\n        RoutingAllocation allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node1, 1, null);\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node2, 2, null);\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(0));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.id()));\n    }","id":74735,"modified_method":"/**\n     * Tests that only when enough copies of the shard exists we are going to allocate it. This test\n     * verifies that even with different version, we treat different versions as a copy, and count them.\n     */\n    public void testEnoughCopiesFoundForAllocationOnLegacyIndexWithDifferentVersion() {\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.V_2_0_0)).numberOfShards(1).numberOfReplicas(2))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .addAsRecovery(metaData.index(shardId.getIndex()))\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n\n        RoutingAllocation allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node1, 1, null, randomBoolean());\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(false));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1));\n        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n\n        testAllocator.addData(node2, 2, null, randomBoolean());\n        allocation = new RoutingAllocation(yesAllocationDeciders(), new RoutingNodes(state, false), state.nodes(), null, System.nanoTime());\n        changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(0));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(2)); // replicas\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.id()));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n     * Tests that when there is a node to allocate the shard to, and there are no active allocation ids, it will be allocated to it.\n     * This is the case when we have old shards from pre-3.0 days.\n     */\n    public void testNoActiveAllocationIds() {\n        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_1_1);\n        testAllocator.addData(node1, 1, null);\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.id()));\n    }","id":74736,"modified_method":"/**\n     * Tests that when there is a node to allocate the shard to, and there are no active allocation ids, it will be allocated to it.\n     * This is the case when we have old shards from pre-3.0 days.\n     */\n    public void testNoActiveAllocationIds() {\n        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), false, Version.V_2_1_1);\n        testAllocator.addData(node1, 1, null, randomBoolean());\n        boolean changed = testAllocator.allocateUnassigned(allocation);\n        assertThat(changed, equalTo(true));\n        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1));\n        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.id()));\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId.getIndex(), shardId.getId(), node1.id(), true, ShardRoutingState.STARTED, 10);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.CURRENT).put(settings))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putActiveAllocationIds(0, new HashSet<>(Arrays.asList(primaryShard.allocationId().getId()))))\n            .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId.getIndex(), shardId.getId(), null, false, new UnassignedInfo(reason, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state.nodes(), ClusterInfo.EMPTY, System.nanoTime());\n    }","id":74737,"modified_method":"private RoutingAllocation onePrimaryOnNode1And1Replica(AllocationDeciders deciders, Settings settings, UnassignedInfo.Reason reason) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId.getIndex(), shardId.getId(), node1.id(), true, ShardRoutingState.STARTED, 10);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.CURRENT).put(settings))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putActiveAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n            .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(ShardRouting.newUnassigned(shardId.getIndex(), shardId.getId(), null, false, new UnassignedInfo(reason, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state.nodes(), ClusterInfo.EMPTY, System.nanoTime());\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId.getIndex(), shardId.getId(), node1.id(), true, ShardRoutingState.STARTED, 10);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putActiveAllocationIds(0, new HashSet<>(Arrays.asList(primaryShard.allocationId().getId()))))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId.getIndex(), shardId.getId(), node2.id(), null, null, false, ShardRoutingState.INITIALIZING, 10, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state.nodes(), ClusterInfo.EMPTY, System.nanoTime());\n    }","id":74738,"modified_method":"private RoutingAllocation onePrimaryOnNode1And1ReplicaRecovering(AllocationDeciders deciders) {\n        ShardRouting primaryShard = TestShardRouting.newShardRouting(shardId.getIndex(), shardId.getId(), node1.id(), true, ShardRoutingState.STARTED, 10);\n        MetaData metaData = MetaData.builder()\n                .put(IndexMetaData.builder(shardId.getIndex()).settings(settings(Version.CURRENT))\n                    .numberOfShards(1).numberOfReplicas(1)\n                    .putActiveAllocationIds(0, Sets.newHashSet(primaryShard.allocationId().getId())))\n                .build();\n        RoutingTable routingTable = RoutingTable.builder()\n                .add(IndexRoutingTable.builder(shardId.getIndex())\n                                .addIndexShard(new IndexShardRoutingTable.Builder(shardId)\n                                        .addShard(primaryShard)\n                                        .addShard(TestShardRouting.newShardRouting(shardId.getIndex(), shardId.getId(), node2.id(), null, null, false, ShardRoutingState.INITIALIZING, 10, new UnassignedInfo(UnassignedInfo.Reason.CLUSTER_RECOVERED, null)))\n                                        .build())\n                )\n                .build();\n        ClusterState state = ClusterState.builder(org.elasticsearch.cluster.ClusterName.DEFAULT)\n                .metaData(metaData)\n                .routingTable(routingTable)\n                .nodes(DiscoveryNodes.builder().put(node1).put(node2).put(node3)).build();\n        return new RoutingAllocation(deciders, new RoutingNodes(state, false), state.nodes(), ClusterInfo.EMPTY, System.nanoTime());\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public NodeGatewayStartedShards(DiscoveryNode node, long version, String allocationId, Throwable storeException) {\n            super(node);\n            this.version = version;\n            this.allocationId = allocationId;\n            this.storeException = storeException;\n        }","id":74739,"modified_method":"public NodeGatewayStartedShards(DiscoveryNode node, long version, String allocationId, boolean primary, Throwable storeException) {\n            super(node);\n            this.version = version;\n            this.allocationId = allocationId;\n            this.primary = primary;\n            this.storeException = storeException;\n        }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"public NodeGatewayStartedShards(DiscoveryNode node, long version, String allocationId) {\n            this(node, version, allocationId, null);\n        }","id":74740,"modified_method":"public NodeGatewayStartedShards(DiscoveryNode node, long version, String allocationId, boolean primary) {\n            this(node, version, allocationId, primary, null);\n        }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n    protected NodeGatewayStartedShards nodeOperation(NodeRequest request) {\n        try {\n            final ShardId shardId = request.getShardId();\n            final String indexUUID = request.getIndexUUID();\n            logger.trace(\"{} loading local shard state info\", shardId);\n            ShardStateMetaData shardStateMetaData = ShardStateMetaData.FORMAT.loadLatestState(logger, nodeEnv.availableShardPaths(request.shardId));\n            if (shardStateMetaData != null) {\n                final IndexMetaData metaData = clusterService.state().metaData().index(shardId.index().name()); // it's a mystery why this is sometimes null\n                if (metaData != null) {\n                    ShardPath shardPath = null;\n                    try {\n                        IndexSettings indexSettings = new IndexSettings(metaData, settings);\n                        shardPath = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);\n                        if (shardPath == null) {\n                            throw new IllegalStateException(shardId + \" no shard path found\");\n                        }\n                        Store.tryOpenIndex(shardPath.resolveIndex());\n                    } catch (Exception exception) {\n                        logger.trace(\"{} can't open index for shard [{}] in path [{}]\", exception, shardId, shardStateMetaData, (shardPath != null) ? shardPath.resolveIndex() : \"\");\n                        String allocationId = shardStateMetaData.allocationId != null ? shardStateMetaData.allocationId.getId() : null;\n                        return new NodeGatewayStartedShards(clusterService.localNode(), shardStateMetaData.version, allocationId, exception);\n                    }\n                }\n                // old shard metadata doesn't have the actual index UUID so we need to check if the actual uuid in the metadata\n                // is equal to IndexMetaData.INDEX_UUID_NA_VALUE otherwise this shard doesn't belong to the requested index.\n                if (indexUUID.equals(shardStateMetaData.indexUUID) == false\n                        && IndexMetaData.INDEX_UUID_NA_VALUE.equals(shardStateMetaData.indexUUID) == false) {\n                    logger.warn(\"{} shard state info found but indexUUID didn't match expected [{}] actual [{}]\", shardId, indexUUID, shardStateMetaData.indexUUID);\n                } else {\n                    logger.debug(\"{} shard state info found: [{}]\", shardId, shardStateMetaData);\n                    String allocationId = shardStateMetaData.allocationId != null ? shardStateMetaData.allocationId.getId() : null;\n                    return new NodeGatewayStartedShards(clusterService.localNode(), shardStateMetaData.version, allocationId);\n                }\n            }\n            logger.trace(\"{} no local shard info found\", shardId);\n            return new NodeGatewayStartedShards(clusterService.localNode(), -1, null);\n        } catch (Exception e) {\n            throw new ElasticsearchException(\"failed to load started shards\", e);\n        }\n    }","id":74741,"modified_method":"@Override\n    protected NodeGatewayStartedShards nodeOperation(NodeRequest request) {\n        try {\n            final ShardId shardId = request.getShardId();\n            final String indexUUID = request.getIndexUUID();\n            logger.trace(\"{} loading local shard state info\", shardId);\n            ShardStateMetaData shardStateMetaData = ShardStateMetaData.FORMAT.loadLatestState(logger, nodeEnv.availableShardPaths(request.shardId));\n            if (shardStateMetaData != null) {\n                final IndexMetaData metaData = clusterService.state().metaData().index(shardId.index().name()); // it's a mystery why this is sometimes null\n                if (metaData != null) {\n                    ShardPath shardPath = null;\n                    try {\n                        IndexSettings indexSettings = new IndexSettings(metaData, settings);\n                        shardPath = ShardPath.loadShardPath(logger, nodeEnv, shardId, indexSettings);\n                        if (shardPath == null) {\n                            throw new IllegalStateException(shardId + \" no shard path found\");\n                        }\n                        Store.tryOpenIndex(shardPath.resolveIndex());\n                    } catch (Exception exception) {\n                        logger.trace(\"{} can't open index for shard [{}] in path [{}]\", exception, shardId, shardStateMetaData, (shardPath != null) ? shardPath.resolveIndex() : \"\");\n                        String allocationId = shardStateMetaData.allocationId != null ? shardStateMetaData.allocationId.getId() : null;\n                        return new NodeGatewayStartedShards(clusterService.localNode(), shardStateMetaData.version, allocationId, shardStateMetaData.primary, exception);\n                    }\n                }\n                // old shard metadata doesn't have the actual index UUID so we need to check if the actual uuid in the metadata\n                // is equal to IndexMetaData.INDEX_UUID_NA_VALUE otherwise this shard doesn't belong to the requested index.\n                if (indexUUID.equals(shardStateMetaData.indexUUID) == false\n                        && IndexMetaData.INDEX_UUID_NA_VALUE.equals(shardStateMetaData.indexUUID) == false) {\n                    logger.warn(\"{} shard state info found but indexUUID didn't match expected [{}] actual [{}]\", shardId, indexUUID, shardStateMetaData.indexUUID);\n                } else {\n                    logger.debug(\"{} shard state info found: [{}]\", shardId, shardStateMetaData);\n                    String allocationId = shardStateMetaData.allocationId != null ? shardStateMetaData.allocationId.getId() : null;\n                    return new NodeGatewayStartedShards(clusterService.localNode(), shardStateMetaData.version, allocationId, shardStateMetaData.primary);\n                }\n            }\n            logger.trace(\"{} no local shard info found\", shardId);\n            return new NodeGatewayStartedShards(clusterService.localNode(), -1, null, false);\n        } catch (Exception e) {\n            throw new ElasticsearchException(\"failed to load started shards\", e);\n        }\n    }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            out.writeLong(version);\n            out.writeOptionalString(allocationId);\n            if (storeException != null) {\n                out.writeBoolean(true);\n                out.writeThrowable(storeException);\n            } else {\n                out.writeBoolean(false);\n            }\n        }","id":74742,"modified_method":"@Override\n        public void writeTo(StreamOutput out) throws IOException {\n            super.writeTo(out);\n            out.writeLong(version);\n            out.writeOptionalString(allocationId);\n            out.writeBoolean(primary);\n            if (storeException != null) {\n                out.writeBoolean(true);\n                out.writeThrowable(storeException);\n            } else {\n                out.writeBoolean(false);\n            }\n        }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            version = in.readLong();\n            allocationId = in.readOptionalString();\n            if (in.readBoolean()) {\n                storeException = in.readThrowable();\n            }\n        }","id":74743,"modified_method":"@Override\n        public void readFrom(StreamInput in) throws IOException {\n            super.readFrom(in);\n            version = in.readLong();\n            allocationId = in.readOptionalString();\n            primary = in.readBoolean();\n            if (in.readBoolean()) {\n                storeException = in.readThrowable();\n            }\n        }","commit_id":"1eb8d5bd6fe4c4c493a62caa3bf91afad1b8406a","url":"https://github.com/elastic/elasticsearch"},{"original_method":"/**\n   * precondition: TypeConversionUtil.isAssignable(lType, rType) || expressionAssignable\n   */\n  public static HighlightInfo checkRawToGenericAssignment(PsiType lType, PsiType rType, PsiElement elementToHighlight) {\n    if (elementToHighlight.getManager().getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_5) < 0) return null;\n    if (!InspectionProjectProfileManager.getInstance(elementToHighlight.getProject()).getProfile(elementToHighlight).isToolEnabled(HighlightDisplayKey.UNCHECKED_WARNING)) return null;\n    if (!isGenericToRaw(lType, rType)) return null;\n    String description = JavaErrorMessages.message(\"generics.unchecked.assignment\",\n                                                   HighlightUtil.formatType(rType),\n                                                   HighlightUtil.formatType(lType));\n\n    if (InspectionManagerEx.inspectionResultSuppressed(elementToHighlight, HighlightDisplayKey.UNCHECKED_WARNING.getID())) return null;\n    HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.UNCHECKED_WARNING,\n                                                                    elementToHighlight,\n                                                                    description);\n    List<IntentionAction> options = IntentionManager.getInstance(elementToHighlight.getProject()).getStandardIntentionOptions(HighlightDisplayKey.UNCHECKED_WARNING,elementToHighlight);\n    QuickFixAction.registerQuickFixAction(highlightInfo, new GenerifyFileFix(elementToHighlight.getContainingFile()), options);\n    return highlightInfo;\n  }","id":74744,"modified_method":"public static HighlightInfo checkRawToGenericAssignment(PsiType lType, PsiType rType, PsiElement elementToHighlight) {\n    if (elementToHighlight.getManager().getEffectiveLanguageLevel().compareTo(LanguageLevel.JDK_1_5) < 0) return null;\n    if (!InspectionProjectProfileManager.getInstance(elementToHighlight.getProject()).getProfile(elementToHighlight).isToolEnabled(HighlightDisplayKey.UNCHECKED_WARNING)) return null;\n    if (!isGenericToRaw(lType, rType)) return null;\n    String description = JavaErrorMessages.message(\"generics.unchecked.assignment\",\n                                                   HighlightUtil.formatType(rType),\n                                                   HighlightUtil.formatType(lType));\n\n    if (InspectionManagerEx.inspectionResultSuppressed(elementToHighlight, HighlightDisplayKey.UNCHECKED_WARNING.getID())) return null;\n    HighlightInfo highlightInfo = HighlightInfo.createHighlightInfo(HighlightInfoType.UNCHECKED_WARNING,\n                                                                    elementToHighlight,\n                                                                    description);\n    List<IntentionAction> options = IntentionManager.getInstance(elementToHighlight.getProject()).getStandardIntentionOptions(HighlightDisplayKey.UNCHECKED_WARNING,elementToHighlight);\n    QuickFixAction.registerQuickFixAction(highlightInfo, new GenerifyFileFix(elementToHighlight.getContainingFile()), options);\n    return highlightInfo;\n  }","commit_id":"bedf6622e3cee77067a0166eaf304f4c59776edf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkInstanceOfGenericType(PsiInstanceOfExpression expression) {\n    final PsiTypeElement checkTypeElement = expression.getCheckType();\n    PsiElement ref = checkTypeElement.getInnermostComponentReferenceElement();\n    while (ref instanceof PsiJavaCodeReferenceElement) {\n      final HighlightInfo result = isIllegalForInstanceOf((PsiJavaCodeReferenceElement)ref, checkTypeElement);\n      if (result != null) return result;\n      ref = ((PsiJavaCodeReferenceElement)ref).getQualifier();\n    }\n    return null;\n  }","id":74745,"modified_method":"public static HighlightInfo checkInstanceOfGenericType(PsiInstanceOfExpression expression) {\n    final PsiTypeElement checkTypeElement = expression.getCheckType();\n    if (checkTypeElement == null) return null;\n    PsiElement ref = checkTypeElement.getInnermostComponentReferenceElement();\n    while (ref instanceof PsiJavaCodeReferenceElement) {\n      final HighlightInfo result = isIllegalForInstanceOf((PsiJavaCodeReferenceElement)ref, checkTypeElement);\n      if (result != null) return result;\n      ref = ((PsiJavaCodeReferenceElement)ref).getQualifier();\n    }\n    return null;\n  }","commit_id":"bedf6622e3cee77067a0166eaf304f4c59776edf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static HighlightInfo checkEnumSuperConstructorCall(PsiMethodCallExpression expr) {\n    PsiReferenceExpression methodExpression = expr.getMethodExpression();\n    if (PsiKeyword.SUPER.equals(methodExpression.getReferenceNameElement().getText())) {\n      final PsiMember constructor = PsiUtil.findEnclosingConstructorOrInitializer(expr);\n      if (constructor instanceof PsiMethod && constructor.getContainingClass().isEnum()) {\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                 expr,\n                                                 JavaErrorMessages.message(\"call.to.super.is.not.allowed.in.enum.constructor\"));\n      }\n    }\n    return null;\n  }","id":74746,"modified_method":"public static HighlightInfo checkEnumSuperConstructorCall(PsiMethodCallExpression expr) {\n    PsiReferenceExpression methodExpression = expr.getMethodExpression();\n    final PsiElement refNameElement = methodExpression.getReferenceNameElement();\n    if (refNameElement != null && PsiKeyword.SUPER.equals(refNameElement.getText())) {\n      final PsiMember constructor = PsiUtil.findEnclosingConstructorOrInitializer(expr);\n      if (constructor instanceof PsiMethod && constructor.getContainingClass().isEnum()) {\n        return HighlightInfo.createHighlightInfo(HighlightInfoType.ERROR,\n                                                 expr,\n                                                 JavaErrorMessages.message(\"call.to.super.is.not.allowed.in.enum.constructor\"));\n      }\n    }\n    return null;\n  }","commit_id":"bedf6622e3cee77067a0166eaf304f4c59776edf","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    PsiElement element = resolveResult.getElement();\n    if (element != null) {\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (element instanceof PsiMethod && element.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        PsiType[] argumentTypes = PsiUtil.getArgumentTypes(refExpr);\n        if (argumentTypes != null && !PsiUtil.isApplicable(argumentTypes, (PsiMethod)element)) {\n          GroovyPsiElement elementToHighlight = PsiUtil.getArgumentsElement(refExpr);\n          LOG.assertTrue(elementToHighlight != null);\n          //todo more specific error message\n          String message = GroovyBundle.message(\"cannot.apply.method\", refExpr.getReferenceName());\n          holder.createWarningAnnotation(elementToHighlight, message);\n        }\n      }\n      if (isAssignmentLHS(refExpr) || element instanceof PsiPackage) return;\n    } else {\n      if (isAssignmentLHS(refExpr)) return;\n\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n        } else {\n          if (refExpr.getParent() instanceof GrReferenceExpression) {\n            Annotation annotation = holder.createWarningAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n            registerAddImportFixes(refExpr, annotation);\n          }\n        }\n      }\n    }\n\n    if (refExpr.getType() == null) {\n      Annotation annotation = holder.createInformationAnnotation(refExpr.getReferenceNameElement(),\n          GroovyBundle.message(\"untyped.access\", refExpr.getReferenceName()));\n\n      annotation.setEnforcedTextAttributes(new TextAttributes(Color.black, null, Color.MAGENTA, EffectType.LINE_UNDERSCORE, 0));\n    }\n  }","id":74747,"modified_method":"private void checkReferenceExpression(AnnotationHolder holder, final GrReferenceExpression refExpr) {\n    GroovyResolveResult resolveResult = refExpr.advancedResolve();\n    PsiElement element = resolveResult.getElement();\n    if (element != null) {\n      if (!resolveResult.isAccessible()) {\n        String message = GroovyBundle.message(\"cannot.access\", refExpr.getReferenceName());\n        holder.createWarningAnnotation(refExpr, message);\n      } else if (element instanceof PsiMethod && element.getUserData(GrMethod.BUILDER_METHOD) == null) {\n        PsiType[] argumentTypes = PsiUtil.getArgumentTypes(refExpr);\n        if (argumentTypes != null && !PsiUtil.isApplicable(argumentTypes, (PsiMethod)element)) {\n          GroovyPsiElement elementToHighlight = PsiUtil.getArgumentsElement(refExpr);\n          LOG.assertTrue(elementToHighlight != null);\n          //todo more specific error message\n          String message = GroovyBundle.message(\"cannot.apply.method\", refExpr.getReferenceName());\n          holder.createWarningAnnotation(elementToHighlight, message);\n        }\n      }\n      if (isAssignmentLHS(refExpr) || element instanceof PsiPackage) return;\n    } else {\n      if (isAssignmentLHS(refExpr)) return;\n\n      GrExpression qualifier = refExpr.getQualifierExpression();\n      if (qualifier == null) {\n        GroovyPsiElement context = PsiTreeUtil.getParentOfType(refExpr, GrMethod.class, GrField.class, GrClosableBlock.class);\n        if (context instanceof PsiModifierListOwner && ((PsiModifierListOwner) context).hasModifierProperty(PsiModifier.STATIC)) {\n          Annotation annotation = holder.createErrorAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n          annotation.setHighlightType(ProblemHighlightType.LIKE_UNKNOWN_SYMBOL);\n        } else {\n          if (refExpr.getParent() instanceof GrReferenceExpression) {\n            Annotation annotation = holder.createWarningAnnotation(refExpr, GroovyBundle.message(\"cannot.resolve\", refExpr.getReferenceName()));\n            registerAddImportFixes(refExpr, annotation);\n          }\n        }\n      }\n    }\n\n    if (refExpr.getType() == null) {\n      PsiElement refNameElement = refExpr.getReferenceNameElement();\n      PsiElement elt = refNameElement == null ? refExpr : refNameElement;\n      Annotation annotation = holder.createInformationAnnotation(elt,\n          GroovyBundle.message(\"untyped.access\", refExpr.getReferenceName()));\n\n      annotation.setEnforcedTextAttributes(new TextAttributes(Color.black, null, Color.MAGENTA, EffectType.LINE_UNDERSCORE, 0));\n    }\n  }","commit_id":"5f97f7dc81b9dd5197abcb950c43b9f23ec77d00","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement handleElementRenameSimple(String newElementName) throws IncorrectOperationException {\n    if (!PsiUtil.isValidReferenceName(newElementName)) {\n      PsiElement element = GroovyPsiElementFactory.getInstance(getProject()).createStringLiteralForReference(newElementName);\n      getReferenceNameElement().replace(element);\n      return this;\n    }\n\n    return super.handleElementRenameSimple(newElementName);\n  }","id":74748,"modified_method":"public PsiElement handleElementRenameSimple(String newElementName) throws IncorrectOperationException {\n    if (!PsiUtil.isValidReferenceName(newElementName)) {\n      final PsiElement old = getReferenceNameElement();\n      if (old == null) throw new IncorrectOperationException(\"ref has no name element\");\n\n      PsiElement element = GroovyPsiElementFactory.getInstance(getProject()).createStringLiteralForReference(newElementName);\n      old.replace(element);\n      return this;\n    }\n\n    return super.handleElementRenameSimple(newElementName);\n  }","commit_id":"a527a47c05bb1c68ee9be46d5a4e602f76cfc524","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public PsiElement setName(@NonNls @NotNull String name) throws IncorrectOperationException {\n    PsiElement nameElement = getReferenceNameElement();\n    ASTNode node = nameElement.getNode();\n    ASTNode newNameNode = GroovyPsiElementFactory.getInstance(getProject()).createReferenceNameFromText(name).getNode();\n    assert newNameNode != null && node != null;\n    node.getTreeParent().replaceChild(node, newNameNode);\n\n    return this;\n  }","id":74749,"modified_method":"public PsiElement setName(@NonNls @NotNull String name) throws IncorrectOperationException {\n    PsiElement nameElement = getReferenceNameElement();\n    if (nameElement == null) throw new IncorrectOperationException(\"ref has no name element\");\n\n    ASTNode node = nameElement.getNode();\n    ASTNode newNameNode = GroovyPsiElementFactory.getInstance(getProject()).createReferenceNameFromText(name).getNode();\n    assert newNameNode != null && node != null;\n    node.getTreeParent().replaceChild(node, newNameNode);\n\n    return this;\n  }","commit_id":"a527a47c05bb1c68ee9be46d5a4e602f76cfc524","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   * in other places: local variable, c.method, c.getter, c.property\n   */\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, @Nullable GrExpression upToArgument, boolean genericsMatter) {\n    final String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    GrReferenceResolveUtil.resolveImpl(propertyResolver, this);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        if (candidate.getElement() instanceof GrVariable && !(candidate.getElement() instanceof GrField)) {\n          return propertyResolver.getCandidates();\n        }\n      }\n    }\n\n    final Pair<Boolean, GroovyResolveResult[]> shapeResults = resolveByShape(allVariants, upToArgument);\n    if (!genericsMatter && !allVariants && shapeResults.first) {\n      for (GroovyResolveResult candidate : shapeResults.second) {\n        assert candidate.getElement().isValid();\n      }\n      return shapeResults.second;\n    }\n\n    MethodResolverProcessor methodResolver = null;\n    if (genericsMatter) {\n      methodResolver = createMethodProcessor(allVariants, name, false, upToArgument);\n\n      for (GroovyResolveResult result : shapeResults.second) {\n        final ResolveState state = ResolveState.initial().\n          put(PsiSubstitutor.KEY, result.getSubstitutor()).\n          put(ResolverProcessor.RESOLVE_CONTEXT, result.getCurrentFileResolveContext()).\n          put(SpreadState.SPREAD_STATE, result.getSpreadState());\n        methodResolver.execute(result.getElement(), state);\n      }\n\n      if (!allVariants && methodResolver.hasApplicableCandidates()) {\n        return methodResolver.getCandidates();\n      }\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isContextAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, genericsMatter ? methodResolver.getCandidates() : shapeResults.second);\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver =\n        new AccessorResolverProcessor(getterName, name, this, true, genericsMatter, getThisType(), getTypeArguments());\n      GrReferenceResolveUtil.resolveImpl(getterResolver, this);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (allCandidates.size() > 0) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","id":74750,"modified_method":"/**\n   * priority: inside class C: local variable, c.method, c.property, c.getter\n   * in other places: local variable, c.method, c.getter, c.property\n   */\n  private GroovyResolveResult[] resolveMethodOrProperty(boolean allVariants, @Nullable GrExpression upToArgument, boolean genericsMatter) {\n    final String name = getReferenceName();\n    if (name == null) return GroovyResolveResult.EMPTY_ARRAY;\n\n    PropertyResolverProcessor propertyResolver = new PropertyResolverProcessor(name, this);\n    GrReferenceResolveUtil.resolveImpl(propertyResolver, this);\n    final GroovyResolveResult[] propertyCandidates = propertyResolver.getCandidates();\n\n    if (!allVariants) { //search for local variables\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        if (candidate.getElement() instanceof GrVariable && !(candidate.getElement() instanceof GrField)) {\n          return propertyResolver.getCandidates();\n        }\n      }\n    }\n\n    final Pair<Boolean, GroovyResolveResult[]> shapeResults = resolveByShape(allVariants, upToArgument);\n    if (!genericsMatter && !allVariants && shapeResults.first) {\n      assertAllAreValid(shapeResults.second);\n      return shapeResults.second;\n    }\n\n    MethodResolverProcessor methodResolver = null;\n    if (genericsMatter) {\n      methodResolver = createMethodProcessor(allVariants, name, false, upToArgument);\n\n      for (GroovyResolveResult result : shapeResults.second) {\n        final ResolveState state = ResolveState.initial().\n          put(PsiSubstitutor.KEY, result.getSubstitutor()).\n          put(ResolverProcessor.RESOLVE_CONTEXT, result.getCurrentFileResolveContext()).\n          put(SpreadState.SPREAD_STATE, result.getSpreadState());\n        methodResolver.execute(result.getElement(), state);\n      }\n\n      if (!allVariants && methodResolver.hasApplicableCandidates()) {\n        return methodResolver.getCandidates();\n      }\n    }\n\n    //search for fields inside its class\n    if (!allVariants) {\n      for (GroovyResolveResult candidate : propertyCandidates) {\n        final PsiElement element = candidate.getElement();\n        if (element instanceof GrField) {\n          final PsiClass containingClass = ((PsiField)element).getContainingClass();\n          if (containingClass != null && PsiTreeUtil.isContextAncestor(containingClass, this, true)) return propertyCandidates;\n        }\n      }\n    }\n\n    List<GroovyResolveResult> allCandidates = new ArrayList<GroovyResolveResult>();\n    ContainerUtil.addAll(allCandidates, propertyCandidates);\n    ContainerUtil.addAll(allCandidates, genericsMatter ? methodResolver.getCandidates() : shapeResults.second);\n\n    //search for getters\n    for (String getterName : GroovyPropertyUtils.suggestGettersName(name)) {\n      AccessorResolverProcessor getterResolver =\n        new AccessorResolverProcessor(getterName, name, this, true, genericsMatter, getThisType(), getTypeArguments());\n      GrReferenceResolveUtil.resolveImpl(getterResolver, this);\n      final GroovyResolveResult[] candidates = getterResolver.getCandidates(); //can be only one candidate\n      if (!allVariants && candidates.length == 1) {\n        return candidates;\n      }\n      ContainerUtil.addAll(allCandidates, candidates);\n    }\n\n    if (allCandidates.size() > 0) {\n      return allCandidates.toArray(new GroovyResolveResult[allCandidates.size()]);\n    }\n    return GroovyResolveResult.EMPTY_ARRAY;\n  }","commit_id":"a527a47c05bb1c68ee9be46d5a4e602f76cfc524","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private Pair<Boolean, GroovyResolveResult[]> doResolveByShape(boolean allVariants, @Nullable GrExpression upToArgument) {\n    final String name = getReferenceName();\n    assert name != null;\n\n    final MethodResolverProcessor shapeProcessor = createMethodProcessor(allVariants, name, true, upToArgument);\n    processMethods(shapeProcessor);\n    GroovyResolveResult[] candidates = shapeProcessor.getCandidates();\n    for (GroovyResolveResult candidate : candidates) {\n      assert candidate.getElement().isValid();\n    }\n    return Pair.create(shapeProcessor.hasApplicableCandidates(), candidates);\n  }","id":74751,"modified_method":"private Pair<Boolean, GroovyResolveResult[]> doResolveByShape(boolean allVariants, @Nullable GrExpression upToArgument) {\n    final String name = getReferenceName();\n    assert name != null;\n\n    final MethodResolverProcessor shapeProcessor = createMethodProcessor(allVariants, name, true, upToArgument);\n    processMethods(shapeProcessor);\n    GroovyResolveResult[] candidates = shapeProcessor.getCandidates();\n    assertAllAreValid(candidates);\n    return Pair.create(shapeProcessor.hasApplicableCandidates(), candidates);\n  }","commit_id":"a527a47c05bb1c68ee9be46d5a4e602f76cfc524","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n    public PsiType fun(GrReferenceExpressionImpl refExpr) {\n      final PsiType inferred = TypeInferenceHelper.getInferredType(refExpr);\n      final PsiType nominal = refExpr.getNominalType();\n      if (inferred == null || PsiType.NULL.equals(inferred)) {\n        if (nominal == null) {\n          //inside nested closure we could still try to infer from variable initializer. Not sound, but makes sense\n          if (!refExpr.isValid()) {\n            throw new AssertionError(\"invalid reference\");\n          }\n          final PsiElement resolved = refExpr.resolve();\n          if (resolved instanceof GrVariable) {\n            if (!resolved.isValid()) {\n              throw new AssertionError(\"Invalid target of a valid reference\");\n            }\n            return ((GrVariable)resolved).getTypeGroovy();\n          }\n        }\n\n        return nominal;\n      }\n\n      if (nominal == null) return inferred;\n      if (!TypeConversionUtil.isAssignable(nominal, inferred, false)) {\n        final PsiElement resolved = refExpr.resolve();\n        if (resolved instanceof GrVariable && ((GrVariable)resolved).getTypeElementGroovy() != null) {\n          return nominal; //see GRVY-487\n        }\n      }\n      return inferred;\n    }","id":74752,"modified_method":"@Nullable\n    public PsiType fun(GrReferenceExpressionImpl refExpr) {\n      final PsiType inferred = TypeInferenceHelper.getInferredType(refExpr);\n      final PsiType nominal = refExpr.getNominalType();\n      if (inferred == null || PsiType.NULL.equals(inferred)) {\n        if (nominal == null) {\n          //inside nested closure we could still try to infer from variable initializer. Not sound, but makes sense\n          assert refExpr.isValid();\n          final PsiElement resolved = refExpr.resolve();\n          if (resolved instanceof GrVariable) {\n            assert resolved.isValid();\n            return ((GrVariable)resolved).getTypeGroovy();\n          }\n        }\n\n        return nominal;\n      }\n\n      if (nominal == null) return inferred;\n      if (!TypeConversionUtil.isAssignable(nominal, inferred, false)) {\n        final PsiElement resolved = refExpr.resolve();\n        if (resolved instanceof GrVariable && ((GrVariable)resolved).getTypeElementGroovy() != null) {\n          return nominal;\n        }\n      }\n      return inferred;\n    }","commit_id":"a527a47c05bb1c68ee9be46d5a4e602f76cfc524","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitReferenceExpression(final PsiReferenceExpression reference) {\n    if (reference.getQualifier()==null) {\n      final PsiElement nameElement = reference.getReferenceNameElement();\n\n      if(nameElement != null && matchContext.getPattern().isTypedVar(nameElement)) {\n        if (element instanceof PsiReferenceExpression) {\n          final PsiReferenceExpression psiReferenceExpression = ((PsiReferenceExpression)element);\n\n          if (psiReferenceExpression.getQualifierExpression()==null) {\n            element = psiReferenceExpression.getReferenceNameElement();\n          }\n        }\n        result = handleTypedElement(nameElement, element);\n        return;\n      }\n    }\n\n    if (!(element instanceof PsiReferenceExpression)) {\n      result = false;\n      return;\n    }\n\n    final PsiReferenceExpression reference2 = (PsiReferenceExpression) element;\n\n    // just variable\n    if (reference.getQualifier()==null &&\n        reference2.getQualifier() == null\n       ) {\n      result = reference.getReferenceNameElement().textMatches(reference2.getReferenceNameElement());\n      return;\n    }\n\n    // handle field selection\n    if ( !(element.getParent() instanceof PsiMethodCallExpression) && // element is not a method) &&\n         reference.getQualifierExpression()!=null &&\n         ( reference2.getQualifierExpression()!=null ||\n           ( reference.getQualifierExpression() instanceof PsiThisExpression &&\n             reference2.getQualifierExpression() == null &&\n             MatchUtils.getReferencedElement(element) instanceof PsiField\n           )\n         )\n       ) {\n      if (matchContext.getPattern().isTypedVar(reference.getReferenceNameElement())) {\n        result = handleTypedElement(reference.getReferenceNameElement(), reference2.getReferenceNameElement());\n      } else {\n        result = reference.getReferenceNameElement().textMatches(reference2.getReferenceNameElement());\n      }\n\n      // @todo fixme here\n      if (result &&\n          reference.getQualifierExpression()!=null &&\n          reference2.getQualifierExpression()!=null\n         ) {\n        result = match(reference.getQualifierExpression(), reference2.getQualifierExpression());\n      }\n\n      return;\n    }\n\n    result = false;\n  }","id":74753,"modified_method":"public void visitReferenceExpression(final PsiReferenceExpression reference) {\n    if (reference.getQualifier()==null) {\n      final PsiElement nameElement = reference.getReferenceNameElement();\n\n      if(nameElement != null && matchContext.getPattern().isTypedVar(nameElement)) {\n        if (element instanceof PsiReferenceExpression) {\n          final PsiReferenceExpression psiReferenceExpression = ((PsiReferenceExpression)element);\n\n          if (psiReferenceExpression.getQualifierExpression()==null) {\n            element = psiReferenceExpression.getReferenceNameElement();\n          }\n        }\n        result = handleTypedElement(nameElement, element);\n        return;\n      }\n    }\n\n    if (!(element instanceof PsiReferenceExpression)) {\n      result = false;\n      return;\n    }\n\n    final PsiReferenceExpression reference2 = (PsiReferenceExpression) element;\n\n    // just variable\n    if (reference.getQualifier()==null &&\n        reference2.getQualifier() == null\n       ) {\n      result = reference.getReferenceNameElement().textMatches(reference2.getReferenceNameElement());\n      return;\n    }\n\n    // handle field selection\n    if ( !(element.getParent() instanceof PsiMethodCallExpression) && // element is not a method) &&\n         reference.getQualifierExpression()!=null &&\n         ( reference2.getQualifierExpression()!=null ||\n           ( reference.getQualifierExpression() instanceof PsiThisExpression &&\n             reference2.getQualifierExpression() == null &&\n             MatchUtils.getReferencedElement(element) instanceof PsiField\n           )\n         )\n       ) {\n      final PsiElement referenceElement = reference.getReferenceNameElement();\n      final PsiElement referenceElement2 = reference2.getReferenceNameElement();\n\n      if (matchContext.getPattern().isTypedVar(referenceElement)) {\n        result = handleTypedElement(referenceElement, referenceElement2);\n      } else {\n        result = (referenceElement2 != null && referenceElement != null && referenceElement.textMatches(referenceElement2)) ||\n          referenceElement == referenceElement2;\n      }\n\n      if (result &&\n          reference.getQualifierExpression()!=null &&\n          reference2.getQualifierExpression()!=null\n         ) {\n        result = match(reference.getQualifierExpression(), reference2.getQualifierExpression());\n      }\n\n      return;\n    }\n\n    result = false;\n  }","commit_id":"546ab0e79eae9b600eedb2ef514a6d8ab06cf6e5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean mightBeLValue(GrExpression expr) {\n    if (expr instanceof GrParenthesizedExpression) return mightBeLValue(((GrParenthesizedExpression)expr).getOperand());\n\n    if (expr instanceof GrListOrMap) {\n      GrListOrMap listOrMap = (GrListOrMap)expr;\n      if (listOrMap.isMap()) return false;\n      GrExpression[] initializers = listOrMap.getInitializers();\n      for (GrExpression initializer : initializers) {\n        if (!mightBeLValue(initializer)) return false;\n      }\n      return true;\n    }\n    if (expr instanceof GrTupleExpression) return true;\n    if (expr instanceof GrReferenceExpression || expr instanceof GrIndexProperty || expr instanceof GrPropertySelection) return true;\n\n    if ((expr instanceof GrThisReferenceExpression || expr instanceof GrSuperReferenceExpression) &&\n        GroovyConfigUtils.getInstance().isVersionAtLeast(expr, GroovyConfigUtils.GROOVY1_8)) {\n      return true;\n    }\n    return false;\n  }","id":74754,"modified_method":"public static boolean mightBeLValue(GrExpression expr) {\n    if (expr instanceof GrParenthesizedExpression) return mightBeLValue(((GrParenthesizedExpression)expr).getOperand());\n\n    if (expr instanceof GrListOrMap) {\n      GrListOrMap listOrMap = (GrListOrMap)expr;\n      if (listOrMap.isMap()) return false;\n      GrExpression[] initializers = listOrMap.getInitializers();\n      for (GrExpression initializer : initializers) {\n        if (!mightBeLValue(initializer)) return false;\n      }\n      return true;\n    }\n    if (expr instanceof GrTupleExpression) return true;\n    if (expr instanceof GrReferenceExpression || expr instanceof GrIndexProperty) return true;\n\n    if ((expr instanceof GrThisReferenceExpression || expr instanceof GrSuperReferenceExpression) &&\n        GroovyConfigUtils.getInstance().isVersionAtLeast(expr, GroovyConfigUtils.GROOVY1_8)) {\n      return true;\n    }\n    return false;\n  }","commit_id":"5fd448dcf7889db0f137abab8e6156d3e793a8e6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean seemsToBeQualifiedClassName(@Nullable GrExpression qualifier) {\n    if (qualifier == null) return false;\n    while (qualifier instanceof GrReferenceExpression) {\n      if (((GrReferenceExpression)qualifier).getReferenceNameElement() instanceof GrLiteral) return false;\n      qualifier = ((GrReferenceExpression)qualifier).getQualifierExpression();\n    }\n    return qualifier == null;\n  }","id":74755,"modified_method":"public static boolean seemsToBeQualifiedClassName(@Nullable GrExpression qualifier) {\n    if (qualifier == null) return false;\n    while (qualifier instanceof GrReferenceExpression) {\n      final PsiElement nameElement = ((GrReferenceExpression)qualifier).getReferenceNameElement();\n      if (((GrReferenceExpression)qualifier).getTypeArguments().length > 0) return false;\n      if (nameElement == null || nameElement.getNode().getElementType() != GroovyTokenTypes.mIDENT) return false;\n      qualifier = ((GrReferenceExpression)qualifier).getQualifierExpression();\n    }\n    return qualifier == null;\n  }","commit_id":"5fd448dcf7889db0f137abab8e6156d3e793a8e6","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  public PsiElement createReferenceNameFromText(String refName) {\n    PsiFile file = createGroovyFile(\"a.\" + refName);\n    GrTopStatement statement = ((GroovyFileBase) file).getTopStatements()[0];\n    if (!(statement instanceof GrReferenceExpression)) return null;\n\n    return ((GrReferenceExpression) statement).getReferenceNameElement();\n  }","id":74756,"modified_method":"@NotNull\n  public PsiElement createReferenceNameFromText(String refName) {\n    PsiFile file = createGroovyFile(\"a.\" + refName);\n    GrTopStatement statement = ((GroovyFileBase) file).getTopStatements()[0];\n    if (!(statement instanceof GrReferenceExpression)) return null;\n    final PsiElement element = ((GrReferenceExpression)statement).getReferenceNameElement();\n    if (element == null) {\n      throw new IncorrectOperationException(\"Incorrect reference name: \" + refName);\n    }\n    return element;\n  }","commit_id":"260b21e3b00b336a57c64832a45926939c490797","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Set<LookupElement> suggestQualifierItems(CompletionParameters parameters,\n                                                          PsiJavaCodeReferenceElement qualifier,\n                                                          ElementFilter filter) {\n    String referenceName = qualifier.getReferenceName();\n    if (referenceName == null) {\n      return Collections.emptySet();\n    }\n\n    PrefixMatcher qMatcher = new CamelHumpMatcher(referenceName);\n    Set<LookupElement> plainVariants =\n      JavaSmartCompletionContributor.completeReference(qualifier, qualifier, filter, true, true, parameters, qMatcher);\n\n    for (PsiClass aClass : PsiShortNamesCache.getInstance(qualifier.getProject()).getClassesByName(referenceName, qualifier.getResolveScope())) {\n      plainVariants.add(JavaClassNameCompletionContributor.createClassLookupItem(aClass, true));\n    }\n\n    if (!plainVariants.isEmpty()) {\n      return plainVariants;\n    }\n\n    final Set<LookupElement> allClasses = new LinkedHashSet<LookupElement>();\n    JavaClassNameCompletionContributor.addAllClasses(parameters.withPosition(qualifier.getReferenceNameElement(), qualifier.getTextRange().getEndOffset()),\n                                                     true, qMatcher, new CollectConsumer<LookupElement>(allClasses));\n    return allClasses;\n  }","id":74757,"modified_method":"private static Set<LookupElement> suggestQualifierItems(CompletionParameters parameters,\n                                                          PsiJavaCodeReferenceElement qualifier,\n                                                          ElementFilter filter) {\n    String referenceName = qualifier.getReferenceName();\n    if (referenceName == null) {\n      return Collections.emptySet();\n    }\n\n    PrefixMatcher qMatcher = new CamelHumpMatcher(referenceName);\n    Set<LookupElement> plainVariants =\n      JavaSmartCompletionContributor.completeReference(qualifier, qualifier, filter, true, true, parameters, qMatcher);\n\n    for (PsiClass aClass : PsiShortNamesCache.getInstance(qualifier.getProject()).getClassesByName(referenceName, qualifier.getResolveScope())) {\n      plainVariants.add(JavaClassNameCompletionContributor.createClassLookupItem(aClass, true));\n    }\n\n    if (!plainVariants.isEmpty()) {\n      return plainVariants;\n    }\n\n    final Set<LookupElement> allClasses = new LinkedHashSet<LookupElement>();\n    PsiElement qualifierName = qualifier.getReferenceNameElement();\n    if (qualifierName != null) {\n      JavaClassNameCompletionContributor.addAllClasses(parameters.withPosition(qualifierName, qualifierName.getTextRange().getEndOffset()),\n                                                       true, qMatcher, new CollectConsumer<LookupElement>(allClasses));\n    }\n    return allClasses;\n  }","commit_id":"e4812372b909f685237972c60f9fcef3a1f9a5a5","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  @Override\n  public Magnificator getMagnificator() {\n    JComponent view = (JComponent)getView();\n    return view != null ? (Magnificator)view.getClientProperty(Magnificator.CLIENT_PROPERTY_KEY) : null;\n  }","id":74758,"modified_method":"@Nullable\n  @Override\n  public Magnificator getMagnificator() {\n    JComponent view = (JComponent)getView();\n    return view != null ? UIUtil.getClientProperty(view, Magnificator.CLIENT_PROPERTY_KEY) : null;\n  }","commit_id":"2f0a28b21228a490a5459bac5176d80655adc829","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private MyPanel getEditorPanel(JTable table) {\n    MyPanel panel = (MyPanel)table.getClientProperty(MY_PANEL_PROPERTY);\n    if (panel != null) {\n      EditorColorsScheme scheme = panel.myEditor.getColorsScheme();\n      if (scheme instanceof DelegateColorScheme) {\n        ((DelegateColorScheme)scheme).setDelegate(getColorScheme());\n      }\n      return panel;\n    }\n\n    // reuse EditorTextField initialization logic\n    EditorTextField field = new EditorTextField(new MyDocument(), null, FileTypes.PLAIN_TEXT);\n    field.setSupplementary(true);\n    field.addNotify(); // creates editor\n\n    EditorEx editor = (EditorEx)ObjectUtils.assertNotNull(field.getEditor());\n    editor.setRendererMode(true);\n\n    editor.setColorsScheme(editor.createBoundColorSchemeDelegate(null));\n    editor.getColorsScheme().setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    editor.getScrollPane().setBorder(null);\n\n    panel = new MyPanel(editor);\n    Disposer.register(this, panel);\n\n    table.putClientProperty(MY_PANEL_PROPERTY, panel);\n    return panel;\n  }","id":74759,"modified_method":"@NotNull\n  private MyPanel getEditorPanel(JTable table) {\n    MyPanel panel = UIUtil.getClientProperty(table, MY_PANEL_PROPERTY);\n    if (panel != null) {\n      EditorColorsScheme scheme = panel.myEditor.getColorsScheme();\n      if (scheme instanceof DelegateColorScheme) {\n        ((DelegateColorScheme)scheme).setDelegate(getColorScheme());\n      }\n      return panel;\n    }\n\n    // reuse EditorTextField initialization logic\n    EditorTextField field = new EditorTextField(new MyDocument(), null, FileTypes.PLAIN_TEXT);\n    field.setSupplementary(true);\n    field.addNotify(); // creates editor\n\n    EditorEx editor = (EditorEx)ObjectUtils.assertNotNull(field.getEditor());\n    editor.setRendererMode(true);\n\n    editor.setColorsScheme(editor.createBoundColorSchemeDelegate(null));\n    editor.getColorsScheme().setColor(EditorColors.CARET_ROW_COLOR, null);\n\n    editor.getScrollPane().setBorder(null);\n\n    panel = new MyPanel(editor);\n    Disposer.register(this, panel);\n\n    table.putClientProperty(MY_PANEL_PROPERTY, panel);\n    return panel;\n  }","commit_id":"db41dda5cadd8b681845aef159cd953095ff880b","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IdeTooltip getCustomTooltip(JComponent component) {\n    return ObjectUtils.tryCast(component.getClientProperty(CUSTOM_TOOLTIP), IdeTooltip.class);\n  }","id":74760,"modified_method":"public IdeTooltip getCustomTooltip(JComponent component) {\n    return UIUtil.getClientProperty(component, CUSTOM_TOOLTIP);\n  }","commit_id":"e4e98fe046df6412343db0cc3289f79e1d5ed402","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void setCustomTooltip(JComponent component, IdeTooltip tooltip) {\n    component.putClientProperty(CUSTOM_TOOLTIP, tooltip);\n  }","id":74761,"modified_method":"public void setCustomTooltip(JComponent component, IdeTooltip tooltip) {\n    UIUtil.putClientProperty(component, CUSTOM_TOOLTIP, tooltip);\n  }","commit_id":"e4e98fe046df6412343db0cc3289f79e1d5ed402","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void visit(int version, int a, String n, String sig, String s, String[] i) {\n      takeIntoAccount = notPrivate(a);\n\n      access = a;\n      name = context.get(n);\n      signature = denullify(sig);\n      superClass = denullify(s);\n      interfaces = i;\n\n      classNameHolder.set(n);\n\n      if (superClass != null) {\n        usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, context.get(superClass)));\n        usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassExtendsUsage(context, context.get(superClass)));\n      }\n\n      if (interfaces != null) {\n        for (String it : interfaces) {\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, context.get(it)));\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassExtendsUsage(context, context.get(it)));\n        }\n      }\n\n      processSignature(sig);\n    }","id":74762,"modified_method":"@Override\n    public void visit(int version, int a, String n, String sig, String s, String[] i) {\n      takeIntoAccount = notPrivate(a);\n\n      access = a;\n      name = context.get(n);\n      signature = sig;\n      superClass = s;\n      interfaces = i;\n\n      classNameHolder.set(n);\n\n      if (superClass != null) {\n        usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, context.get(superClass)));\n        usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassExtendsUsage(context, context.get(superClass)));\n      }\n\n      if (interfaces != null) {\n        for (String it : interfaces) {\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, context.get(it)));\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassExtendsUsage(context, context.get(it)));\n        }\n      }\n\n      processSignature(sig);\n    }","commit_id":"5f225f896c7df79518c77e17bf252888aecf46c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public FieldVisitor visitField(int access, String n, String desc, String signature, Object value) {\n      processSignature(signature);\n\n      fields.add(new FieldRepr(context, access, context.get(n), context.get(desc), context.get(denullify(signature)), value));\n\n      return new EmptyVisitor() {\n        @Override\n        public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n          return new AnnotationCrawler((TypeRepr.ClassType)TypeRepr.getType(context, context.get(desc)), ElementType.FIELD);\n        }\n      };\n    }","id":74763,"modified_method":"@Override\n    public FieldVisitor visitField(int access, String n, String desc, String signature, Object value) {\n      processSignature(signature);\n\n      fields.add(new FieldRepr(context, access, context.get(n), context.get(desc), context.get(signature), value));\n\n      return new EmptyVisitor() {\n        @Override\n        public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n          return new AnnotationCrawler((TypeRepr.ClassType)TypeRepr.getType(context, context.get(desc)), ElementType.FIELD);\n        }\n      };\n    }","commit_id":"5f225f896c7df79518c77e17bf252888aecf46c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public MethodVisitor visitMethod(final int access,\n                                     final String n,\n                                     final String desc,\n                                     final String signature,\n                                     final String[] exceptions) {\n      final Holder<Object> defaultValue = new Holder<Object>();\n\n      processSignature(signature);\n\n      return new EmptyVisitor() {\n        @Override\n        public void visitEnd() {\n          methods.add(new MethodRepr(context, access, context.get(n), context.get(denullify(signature)), desc, exceptions, defaultValue.get()));\n        }\n\n        @Override\n        public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n          return new AnnotationCrawler((TypeRepr.ClassType)TypeRepr.getType(context, context.get(desc)),\n                                       n.equals(\"<init>\") ? ElementType.CONSTRUCTOR : ElementType.METHOD);\n        }\n\n        @Override\n        public AnnotationVisitor visitAnnotationDefault() {\n          return new EmptyVisitor() {\n            public void visit(String name, Object value) {\n              defaultValue.set(value);\n            }\n          };\n        }\n\n        @Override\n        public AnnotationVisitor visitParameterAnnotation(int parameter, String desc, boolean visible) {\n          return new AnnotationCrawler((TypeRepr.ClassType)TypeRepr.getType(context, context.get(desc)), ElementType.PARAMETER);\n        }\n\n        @Override\n        public void visitMultiANewArrayInsn(String desc, int dims) {\n          final TypeRepr.ArrayType typ = (TypeRepr.ArrayType)TypeRepr.getType(context, context.get(desc));\n          final TypeRepr.AbstractType element = typ.getDeepElementType();\n\n          if (element instanceof TypeRepr.ClassType) {\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, ((TypeRepr.ClassType)element).className));\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassNewUsage(context, ((TypeRepr.ClassType)element).className));\n          }\n\n          typ.updateClassUsages(context, name, usages);\n\n          super.visitMultiANewArrayInsn(desc, dims);\n        }\n\n        @Override\n        public void visitLocalVariable(String n, String desc, String signature, Label start, Label end, int index) {\n          processSignature(signature);\n          TypeRepr.getType(context, context.get(desc)).updateClassUsages(context, name, usages);\n          super.visitLocalVariable(n, desc, signature, start, end, index);\n        }\n\n        @Override\n        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n          if (type != null) {\n            TypeRepr.createClassType(context, context.get(type)).updateClassUsages(context, name, usages);\n          }\n\n          super.visitTryCatchBlock(start, end, handler, type);\n        }\n\n        @Override\n        public void visitTypeInsn(int opcode, String type) {\n          final TypeRepr.AbstractType typ = type.startsWith(\"[\") ? TypeRepr.getType(context, context.get(type)) : TypeRepr.createClassType(context, context.get(type));\n\n          if (opcode == Opcodes.NEW) {\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, ((TypeRepr.ClassType)typ).className));\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassNewUsage(context, ((TypeRepr.ClassType)typ).className));\n          }\n          else if (opcode == Opcodes.ANEWARRAY) {\n            if (typ instanceof TypeRepr.ClassType) {\n              usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, ((TypeRepr.ClassType)typ).className));\n              usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassNewUsage(context, ((TypeRepr.ClassType)typ).className));\n            }\n          }\n\n          typ.updateClassUsages(context, name, usages);\n\n          super.visitTypeInsn(opcode, type);\n        }\n\n        @Override\n        public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n          if (opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC) {\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createFieldAssignUsage(context, context.get(name), context.get(owner), context.get(desc)));\n          }\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createFieldUsage(context, context.get(name), context.get(owner), context.get(desc)));\n          super.visitFieldInsn(opcode, owner, name, desc);\n        }\n\n        @Override\n        public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createMethodUsage(context, context.get(name), context.get(owner),\n                                                                                          desc));\n          super.visitMethodInsn(opcode, owner, name, desc);\n        }\n      };\n    }","id":74764,"modified_method":"@Override\n    public MethodVisitor visitMethod(final int access,\n                                     final String n,\n                                     final String desc,\n                                     final String signature,\n                                     final String[] exceptions) {\n      final Holder<Object> defaultValue = new Holder<Object>();\n\n      processSignature(signature);\n\n      return new EmptyVisitor() {\n        @Override\n        public void visitEnd() {\n          methods.add(new MethodRepr(context, access, context.get(n), context.get(signature), desc, exceptions, defaultValue.get()));\n        }\n\n        @Override\n        public AnnotationVisitor visitAnnotation(String desc, boolean visible) {\n          return new AnnotationCrawler((TypeRepr.ClassType)TypeRepr.getType(context, context.get(desc)),\n                                       n.equals(\"<init>\") ? ElementType.CONSTRUCTOR : ElementType.METHOD);\n        }\n\n        @Override\n        public AnnotationVisitor visitAnnotationDefault() {\n          return new EmptyVisitor() {\n            public void visit(String name, Object value) {\n              defaultValue.set(value);\n            }\n          };\n        }\n\n        @Override\n        public AnnotationVisitor visitParameterAnnotation(int parameter, String desc, boolean visible) {\n          return new AnnotationCrawler((TypeRepr.ClassType)TypeRepr.getType(context, context.get(desc)), ElementType.PARAMETER);\n        }\n\n        @Override\n        public void visitMultiANewArrayInsn(String desc, int dims) {\n          final TypeRepr.ArrayType typ = (TypeRepr.ArrayType)TypeRepr.getType(context, context.get(desc));\n          final TypeRepr.AbstractType element = typ.getDeepElementType();\n\n          if (element instanceof TypeRepr.ClassType) {\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, ((TypeRepr.ClassType)element).className));\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassNewUsage(context, ((TypeRepr.ClassType)element).className));\n          }\n\n          typ.updateClassUsages(context, name, usages);\n\n          super.visitMultiANewArrayInsn(desc, dims);\n        }\n\n        @Override\n        public void visitLocalVariable(String n, String desc, String signature, Label start, Label end, int index) {\n          processSignature(signature);\n          TypeRepr.getType(context, context.get(desc)).updateClassUsages(context, name, usages);\n          super.visitLocalVariable(n, desc, signature, start, end, index);\n        }\n\n        @Override\n        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {\n          if (type != null) {\n            TypeRepr.createClassType(context, context.get(type)).updateClassUsages(context, name, usages);\n          }\n\n          super.visitTryCatchBlock(start, end, handler, type);\n        }\n\n        @Override\n        public void visitTypeInsn(int opcode, String type) {\n          final TypeRepr.AbstractType typ = type.startsWith(\"[\") ? TypeRepr.getType(context, context.get(type)) : TypeRepr.createClassType(context, context.get(type));\n\n          if (opcode == Opcodes.NEW) {\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, ((TypeRepr.ClassType)typ).className));\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassNewUsage(context, ((TypeRepr.ClassType)typ).className));\n          }\n          else if (opcode == Opcodes.ANEWARRAY) {\n            if (typ instanceof TypeRepr.ClassType) {\n              usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassUsage(context, ((TypeRepr.ClassType)typ).className));\n              usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createClassNewUsage(context, ((TypeRepr.ClassType)typ).className));\n            }\n          }\n\n          typ.updateClassUsages(context, name, usages);\n\n          super.visitTypeInsn(opcode, type);\n        }\n\n        @Override\n        public void visitFieldInsn(int opcode, String owner, String name, String desc) {\n          if (opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC) {\n            usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createFieldAssignUsage(context, context.get(name), context.get(owner), context.get(desc)));\n          }\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createFieldUsage(context, context.get(name), context.get(owner), context.get(desc)));\n          super.visitFieldInsn(opcode, owner, name, desc);\n        }\n\n        @Override\n        public void visitMethodInsn(int opcode, String owner, String name, String desc) {\n          usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createMethodUsage(context, context.get(name), context.get(owner),\n                                                                                          desc));\n          super.visitMethodInsn(opcode, owner, name, desc);\n        }\n      };\n    }","commit_id":"5f225f896c7df79518c77e17bf252888aecf46c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public Pair<ClassRepr, Pair<UsageRepr.Cluster, Set<UsageRepr.Usage>>> getResult() {\n      final ClassRepr repr =\n        takeIntoAccount ? new ClassRepr(context, access, sourceFile, fileName, name, context.get(signature), context.get(superClass), interfaces, nestedClasses, fields,\n                                        methods, targets, policy, context.get(denullify(outerClassName.get())), localClassFlag.get()) : null;\n\n      if (repr != null) {\n        repr.updateClassUsages(context, usages);\n      }\n\n      return new Pair<ClassRepr, Pair<UsageRepr.Cluster, Set<UsageRepr.Usage>>>(repr,\n                                                                                new Pair<UsageRepr.Cluster, Set<UsageRepr.Usage>>(usages,\n                                                                                                                                  annotationUsages));\n    }","id":74765,"modified_method":"public Pair<ClassRepr, Pair<UsageRepr.Cluster, Set<UsageRepr.Usage>>> getResult() {\n      final ClassRepr repr =\n        takeIntoAccount ? new ClassRepr(context, access, sourceFile, fileName, name, context.get(signature), context.get(superClass), interfaces, nestedClasses, fields,\n                                        methods, targets, policy, context.get(outerClassName.get()), localClassFlag.get()) : null;\n\n      if (repr != null) {\n        repr.updateClassUsages(context, usages);\n      }\n\n      return new Pair<ClassRepr, Pair<UsageRepr.Cluster, Set<UsageRepr.Usage>>>(repr,\n                                                                                new Pair<UsageRepr.Cluster, Set<UsageRepr.Usage>>(usages,\n                                                                                                                                  annotationUsages));\n    }","commit_id":"5f225f896c7df79518c77e17bf252888aecf46c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void visitEnum(String name, String desc, String value) {\n        final String denullified = denullify(name);\n        usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createMethodUsage(context, context.get(denullified), type.className, \"()\" + desc));\n        usedArguments.add(context.get(denullified));\n      }","id":74766,"modified_method":"public void visitEnum(String name, String desc, String value) {\n        usages.addUsage(context.get(classNameHolder.get()), UsageRepr.createMethodUsage(context, context.get(name), type.className, \"()\" + desc));\n        usedArguments.add(context.get(name));\n      }","commit_id":"5f225f896c7df79518c77e17bf252888aecf46c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public S get(final String s) {\n    try {\n      final int i = enumerator.enumerate(s);\n\n      return new S(i);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":74767,"modified_method":"public S get(final String s) {\n    try {\n      final int i = s == null ? enumerator.enumerate(\"\") : enumerator.enumerate(s);\n\n      return new S(i);\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }","commit_id":"5f225f896c7df79518c77e17bf252888aecf46c4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static void writeNAME(DataOutput record, final String name, PersistentStringEnumerator nameStore) throws IOException {\n    final int nameId = nameStore.enumerate(name);\n    record.writeByte(nameId & 0xFF);\n    writeINT(record, (nameId >> 8));\n  }","id":74768,"modified_method":"public static void writeNAME(DataOutput record, final String name, PersistentStringEnumerator nameStore) throws IOException {\n    final int nameId = name != null ? nameStore.enumerate(name) : 0;\n    record.writeByte(nameId & 0xFF);\n    writeINT(record, (nameId >> 8));\n  }","commit_id":"ad293392c926b653e30b187b2549d12bd4fb3d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String readNAME(DataInput record, PersistentStringEnumerator nameStore) throws IOException {\n    final int low = record.readUnsignedByte();\n    final int nameId = (readINT(record) << 8) | low;\n    return nameStore.valueOf(nameId);\n  }","id":74769,"modified_method":"public static String readNAME(DataInput record, PersistentStringEnumerator nameStore) throws IOException {\n    final int low = record.readUnsignedByte();\n    final int nameId = (readINT(record) << 8) | low;\n    return nameId == 0 ? null : nameStore.valueOf(nameId);\n  }","commit_id":"ad293392c926b653e30b187b2549d12bd4fb3d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public List<StubElement> getChildStubs() {\n    return myChildren;\n  }","id":74770,"modified_method":"public List<StubElement> getChildrenStubs() {\n    return myChildren;\n  }","commit_id":"ad293392c926b653e30b187b2549d12bd4fb3d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void bindChildTrees() {\n    final ASTNode node = getNode();\n    final List<StubElement> childStubs = myStub.getChildStubs();\n    final Iterator<StubElement> it = childStubs.iterator();\n    ASTNode childNode = node.getFirstChildNode();\n    while (it.hasNext()) {\n      StubBasedPsiElementBase stubChild = (StubBasedPsiElementBase)it.next().getPsi();\n      while (stubChild.myElementType == childNode.getElementType()) {\n        childNode = childNode.getTreeNext();\n      }\n      stubChild.myNode = childNode;\n      stubChild.myStub = null;\n      childNode = childNode.getTreeNext();\n\n      // TODO: need assertions we've bind that correctly.\n    }\n  }","id":74771,"modified_method":"private void bindChildTrees() {\n    final ASTNode node = getNode();\n    final List<StubElement> childStubs = myStub.getChildrenStubs();\n    final Iterator<StubElement> it = childStubs.iterator();\n    ASTNode childNode = node.getFirstChildNode();\n    while (it.hasNext()) {\n      StubBasedPsiElementBase stubChild = (StubBasedPsiElementBase)it.next().getPsi();\n      while (stubChild.myElementType == childNode.getElementType()) {\n        childNode = childNode.getTreeNext();\n      }\n      stubChild.myNode = childNode;\n      stubChild.myStub = null;\n      childNode = childNode.getTreeNext();\n\n      // TODO: need assertions we've bind that correctly.\n    }\n  }","commit_id":"ad293392c926b653e30b187b2549d12bd4fb3d57","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public boolean write(XmlTag tag, Module module) {\n    data = null;\n    \n    PsiElement host = XmlTagValueProvider.getInjectedHost(tag);\n    if (host == null) {\n      return false;\n    }\n    \n    InjectedPsiVisitor visitor = new InjectedPsiVisitor(host);\n    InjectedLanguageUtil.enumerate(host, visitor);\n    if (visitor.getCssFile() == null) {\n      return false;\n    }\n\n    data = cssWriter.write(visitor.getCssFile(), module);\n    return true;\n  }","id":74772,"modified_method":"public boolean write(XmlTag tag, Module module) {\n    data = null;\n\n    CssFile cssFile = null;\n    XmlAttribute source = tag.getAttribute(\"source\");\n    if (source != null) {\n      XmlAttributeValue valueElement = source.getValueElement();\n      if (valueElement != null) {\n        PsiReference reference = valueElement.getReference();\n        if (reference != null) {\n          PsiElement element = reference.resolve();\n          if (element != null && element instanceof CssFile) {\n            cssFile = (CssFile) element;\n          }\n        }\n      }\n    }\n    else {\n      PsiElement host = XmlTagValueProvider.getInjectedHost(tag);\n      if (host != null) {\n        InjectedPsiVisitor visitor = new InjectedPsiVisitor(host);\n        InjectedLanguageUtil.enumerate(host, visitor);\n        cssFile = visitor.getCssFile();\n      }\n    }\n    \n    if (cssFile == null) {\n      return false;\n    }\n  \n    data = cssWriter.write(cssFile, module);\n    return true;\n  }","commit_id":"73f214b11b7b3fd0110004cb6fdba997b2df19f3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"private void resetAfterMessage() {\n    xmlAttributeValueProvider.setAttribute(null);\n    xmlTextValueProvider = null;\n    xmlTagValueProvider = null;\n    localStyleWriter = null;\n  }","id":74773,"modified_method":"private void resetAfterMessage() {\n    xmlAttributeValueProvider.setAttribute(null);\n    xmlTextValueProvider = null;\n    xmlTagValueProvider = null;\n  }","commit_id":"73f214b11b7b3fd0110004cb6fdba997b2df19f3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void testFiles(Tester tester, VirtualFile... originalVFiles) throws Exception {\n    VirtualFile[] testVFiles = configureByFiles(null, originalVFiles).getChildren();\n    collectLocalStyleHolders();\n\n    for (int i = 0, childrenLength = testVFiles.length; i < childrenLength; i++) {\n      VirtualFile file = testVFiles[i];\n      XmlFile xmlFile = (XmlFile) myPsiManager.findFile(file);\n      assert xmlFile != null;\n      tester.test(file, xmlFile, originalVFiles[childrenLength - i - 1]);\n    }\n  }","id":74774,"modified_method":"protected void testFiles(Tester tester, VirtualFile... originalVFiles) throws Exception {\n    VirtualFile[] testVFiles = configureByFiles(null, originalVFiles).getChildren();\n    collectLocalStyleHolders();\n\n    for (int i = 0, childrenLength = testVFiles.length; i < childrenLength; i++) {\n      VirtualFile file = testVFiles[i];\n      if (!file.getPath().endsWith(\".mxml\")) {\n        continue; // may be auxiliary files, e.g. css files\n      }\n      \n      XmlFile xmlFile = (XmlFile) myPsiManager.findFile(file);\n      assert xmlFile != null;\n      tester.test(file, xmlFile, originalVFiles[childrenLength - i - 1]);\n    }\n  }","commit_id":"73f214b11b7b3fd0110004cb6fdba997b2df19f3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void testFile(String originalVFilePath, Tester tester) throws Exception {\n    VirtualFile virtualFile = LocalFileSystem.getInstance().findFileByPath(getTestMxmlPath() + \"/\" + originalVFilePath);\n    assert virtualFile != null;\n    testFiles(tester, virtualFile);\n  }","id":74775,"modified_method":"protected void testFile(Tester tester, String... originalPaths) throws Exception {\n    VirtualFile[] originalVFiles = new VirtualFile[originalPaths.length];\n    for (int i = 0, originalPathsLength = originalPaths.length; i < originalPathsLength; i++) {\n      VirtualFile originalVFile = LocalFileSystem.getInstance().findFileByPath(getTestMxmlPath() + \"/\" + originalPaths[i]);\n      assert originalVFile != null;\n      originalVFiles[i] = originalVFile;\n    }\n    \n    testFiles(tester, originalVFiles);\n  }","commit_id":"73f214b11b7b3fd0110004cb6fdba997b2df19f3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void testFile(String originalVFilePath) throws Exception {\n    testFile(originalVFilePath, new MyTester());\n  }","id":74776,"modified_method":"protected void testFile(String... originalVFilePath) throws Exception {\n    testFile(new MyTester(), originalVFilePath);\n  }","commit_id":"73f214b11b7b3fd0110004cb6fdba997b2df19f3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"@JSTestOptions({WithGumboSdk, WithFlexSdk})\n  @Flex(version=\"4.5\")\n  public void testStyleNavigation() throws Exception {\n    testFile(\"Form.mxml\", new Tester() {\n      @Override\n      public void test(VirtualFile file, XmlFile xmlFile, VirtualFile originalFile) throws Exception {\n        client.openDocument(myModule, xmlFile);\n        client.test(getTestName(true), 5);\n\n        assertResult(getTestName(true), -1);\n\n        roboflest.setStageOffset(reader);\n        assertTrue(reader.readBoolean());\n\n        interact(new Assert() {\n          @Override\n          public void test() throws Exception {\n            assertEquals(ServerMethod.resolveExternalInlineStyleDeclarationSource, reader.read());\n            assertEquals(myModule, client.getModule(reader.readInt()));\n\n            XmlAttribute attribute = (XmlAttribute) new ResolveExternalInlineStyleSourceAction(reader, myModule).find();\n            assertEquals(\"spark.skins.spark.ButtonBarLastButtonSkin\", attribute.getDisplayValue());\n            assertEquals(2186, attribute.getTextOffset());\n          }\n        });\n      }\n    });\n  }","id":74777,"modified_method":"@JSTestOptions({WithGumboSdk, WithFlexSdk})\n  @Flex(version=\"4.5\")\n  public void testStyleNavigation() throws Exception {\n    testFile(new Tester() {\n      @Override\n      public void test(VirtualFile file, XmlFile xmlFile, VirtualFile originalFile) throws Exception {\n        client.openDocument(myModule, xmlFile);\n        client.test(getTestName(true), 5);\n\n        assertResult(getTestName(true), -1);\n\n        roboflest.setStageOffset(reader);\n        assertTrue(reader.readBoolean());\n\n        interact(new Assert() {\n          @Override\n          public void test() throws Exception {\n            assertEquals(ServerMethod.resolveExternalInlineStyleDeclarationSource, reader.read());\n            assertEquals(myModule, client.getModule(reader.readInt()));\n\n            XmlAttribute attribute = (XmlAttribute) new ResolveExternalInlineStyleSourceAction(reader, myModule).find();\n            assertEquals(\"spark.skins.spark.ButtonBarLastButtonSkin\", attribute.getDisplayValue());\n            assertEquals(2186, attribute.getTextOffset());\n          }\n        });\n      }\n    }, \"Form.mxml\");\n  }","commit_id":"73f214b11b7b3fd0110004cb6fdba997b2df19f3","url":"https://github.com/JetBrains/intellij-plugins"},{"original_method":"protected void init() {\n\t\tif (logger.isDebugEnabled()) logger.debug(\"loadData assignment=\" + assignment + \", previousAssignment=\" + previousAssignment + \", nextAssignment=\" + nextAssignment);\n\t\t\n\t\tif (logger.isDebugEnabled()) logger.debug(\"workInProgress=\" + workInProgress);\n\t\tif (workInProgress) {\t\t\t\n\t\t\t// Keeping the current form values in memory is a one-shot deal at\n\t\t\t// present. The next time the user does anything, the form will be\n\t\t\t// refreshed from the database.\n\t\t\tworkInProgress = false;\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.init();\n\n        // Clear view state.\n        previousAssignment = null;\n        nextAssignment = null;\n\t\tscoreRows = new ArrayList();\n\t\tupdatedComments = new ArrayList();\n\t\tupdatedGradeRecords = new ArrayList();\n\n\t\tif (assignmentId != null) {\n\t\t\tassignment = getGradebookManager().getAssignmentWithStats(assignmentId);\n\t\t\tif (assignment != null) {\n                // Get the list of assignments.  If we are sorting by mean, we\n                // need to fetch the assignment statistics as well. If categories\n\t\t\t\t// are enabled, we need to retrieve the categories and extract the assignments\n\t\t\t\t// b/c the assignments will be grouped by category\n\t\t\t\tList assignments;\n                if(!getCategoriesEnabled() && Assignment.SORT_BY_MEAN.equals(getAssignmentSortColumn())) {\n                    assignments = getGradebookManager().getAssignmentsWithStats(getGradebookId(),\n                            getAssignmentSortColumn(), isAssignmentSortAscending());\n                } else if (!getCategoriesEnabled()){\n                    assignments = getGradebookManager().getAssignments(getGradebookId(),\n                            getAssignmentSortColumn(), isAssignmentSortAscending());\n                } else {\n                \t// Categories are enabled, so the assignments are grouped by category\n                \tassignments = new ArrayList();\n                \tList categories = getGradebookManager().getCategoriesWithStats(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending(), getCategorySortColumn(), isCategorySortAscending());\n                \tif (categories != null) {\n                \t\tIterator catIter = categories.iterator();\n                \t\twhile (catIter.hasNext()) {\n                \t\t\tObject myObj = catIter.next();\n                \t\t\tif (myObj instanceof Category) {\n                \t\t\t\tCategory myCat = (Category) myObj;\n                \t\t\t\tList catAssigns = myCat.getAssignmentList();\n                \t\t\t\tif (catAssigns != null) {\n                \t\t\t\t\tassignments.addAll(catAssigns);\n                \t\t\t\t}\n                \t\t\t}\n                \t\t}\n                \t}\n                \t// we also need to retrieve all of the assignments that have not\n                \t// yet been assigned a category\n                \tList assignNoCategory = getGradebookManager().getAssignmentsWithNoCategory(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending());\n                \tif (assignNoCategory != null) {\n                \t\tassignments.addAll(assignNoCategory);\n                \t}\n                }\n\n                // Set up next and previous links, if any.\n                int thisIndex = assignments.indexOf(assignment);\n\t\t\t\tif (thisIndex > 0) {\n\t\t\t\t\tpreviousAssignment = (Assignment)assignments.get(thisIndex - 1);\n\t\t\t\t}\n\t\t\t\tif (thisIndex < (assignments.size() - 1)) {\n\t\t\t\t\tnextAssignment = (Assignment)assignments.get(thisIndex + 1);\n\t\t\t\t}\n\n\t\t\t\t// Set up score rows.\n\t\t\t\tMap enrollmentMap = getOrderedEnrollmentMap();\n\t\t\t\tList studentUids = new ArrayList(enrollmentMap.keySet());\n\t\t\t\tList gradeRecords = new ArrayList();\n\t\t\t\tif (getGradeEntryByPoints())\n\t\t\t\t\tgradeRecords = getGradebookManager().getAssignmentGradeRecords(assignment, studentUids);\n\t\t\t\telse if (getGradeEntryByPercent())\n\t\t\t\t\tgradeRecords = getGradebookManager().getAssignmentGradeRecordsConverted(assignment, studentUids);\n\n\t\t\t\tif (!isEnrollmentSort()) {\n\t\t\t\t\t// Need to sort and page based on a scores column.\n\t\t\t\t\tList scoreSortedStudentUids = new ArrayList();\n\t\t\t\t\tfor(Iterator iter = gradeRecords.iterator(); iter.hasNext();) {\n\t\t\t\t\t\tAbstractGradeRecord agr = (AbstractGradeRecord)iter.next();\n\t\t\t\t\t\tscoreSortedStudentUids.add(agr.getStudentId());\n\t\t\t\t\t}\n\n\t\t\t\t\t// Put enrollments with no scores at the beginning of the final list.\n\t\t\t\t\tstudentUids.removeAll(scoreSortedStudentUids);\n\n\t\t\t\t\t// Add all sorted enrollments with scores into the final list\n\t\t\t\t\tstudentUids.addAll(scoreSortedStudentUids);\n\n\t\t\t\t\tstudentUids = finalizeSortingAndPaging(studentUids);\n\t\t\t\t}\n\n                // Get all of the grading events for these enrollments on this assignment\n                GradingEvents allEvents = getGradebookManager().getGradingEvents(assignment, studentUids);\n                getGradebookManager().convertGradingEventsConverted(assignment, allEvents, studentUids, getGradebook().getGrade_type());\n                \n                Map gradeRecordMap = new HashMap();\n                for (Iterator iter = gradeRecords.iterator(); iter.hasNext(); ) {\n\t\t\t\t\tAssignmentGradeRecord gradeRecord = (AssignmentGradeRecord)iter.next();\n\t\t\t\t\tif (studentUids.contains(gradeRecord.getStudentId())) {\n\t\t\t\t\t\tgradeRecordMap.put(gradeRecord.getStudentId(), gradeRecord);\n\t\t\t\t\t}\n\t\t\t\t}\n\n                // If the table is not being sorted by enrollment information, then\n                // we had to gather grade records for all students to set up the\n                // current page. In that case, eliminate the undisplayed grade records\n                // to reduce data contention.\n                if (!isEnrollmentSort()) {\n                \tgradeRecords = new ArrayList(gradeRecordMap.values());\n                }\n\n                // Get all of the comments for these enrollments on this assignment.\n                List comments = getGradebookManager().getComments(assignment, studentUids);\n                Map commentMap = new HashMap();\n                for (Iterator iter = comments.iterator(); iter.hasNext(); ) {\n\t\t\t\t\tComment comment = (Comment)iter.next();\n\t\t\t\t\tcommentMap.put(comment.getStudentId(), comment);\n\t\t\t\t}\n\n\t\t\t\tfor (Iterator iter = studentUids.iterator(); iter.hasNext(); ) {\n\t\t\t\t\tString studentUid = (String)iter.next();\n\t\t\t\t\tEnrollmentRecord enrollment = (EnrollmentRecord)enrollmentMap.get(studentUid);\n\t\t\t\t\tAssignmentGradeRecord gradeRecord = (AssignmentGradeRecord)gradeRecordMap.get(studentUid);\n\t\t            if(gradeRecord == null) {\n\t\t                gradeRecord = new AssignmentGradeRecord(assignment, studentUid, null);\n\t\t                gradeRecords.add(gradeRecord);\n\t\t            }\n\t\t            // we may have some decimals with more than 2 places from the % conversion from points\n\t\t            if (gradeRecord != null && gradeRecord.getPointsEarned() != null && getGradeEntryByPercent()) {\n\t\t            \tdouble pointsEarned = gradeRecord.getPointsEarned().doubleValue();\n\t\t            \tpointsEarned = FacesUtil.getRoundDown(pointsEarned, 2);\n\t\t            \tgradeRecord.setPointsEarned(new Double(pointsEarned));\n\t\t            }\n\t\t            Comment comment = (Comment)commentMap.get(studentUid);\n\t\t            if (comment == null) {\n\t\t            \tcomment = new Comment(studentUid, null, assignment);\n\t\t            }\n\n\t\t\t\t\tscoreRows.add(new ScoreRow(enrollment, gradeRecord, comment, allEvents.getEvents(studentUid)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (getCategoriesEnabled()) {\n\t\t\t\t\tif (assignment.getCategory() != null) {\n\t\t\t\t\t\tif (getWeightingEnabled()) {\n\t\t\t\t\t\t\tassignmentWeight = assignment.getCategory().getWeight().toString();\n\t\t\t\t\t\t\tassignmentCategory = assignment.getCategory().getName() + \" \" + getLocalizedString(\"cat_weight_display\", new String[] {assignmentWeight});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassignmentCategory = assignment.getCategory().getName();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassignmentCategory = getLocalizedString(\"assignment_details_assign_category\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// The assignment might have been removed since this link was set up.\n\t\t\t\tif (logger.isWarnEnabled()) logger.warn(\"No assignmentId=\" + assignmentId + \" in gradebookUid \" + getGradebookUid());\n                FacesUtil.addErrorMessage(getLocalizedString(\"assignment_details_assignment_removed\"));\n\t\t\t}\n\t\t}\n\t}","id":74778,"modified_method":"protected void init() {\n\t\tif (logger.isDebugEnabled()) logger.debug(\"loadData assignment=\" + assignment + \", previousAssignment=\" + previousAssignment + \", nextAssignment=\" + nextAssignment);\n\t\t\n\t\tif (logger.isDebugEnabled()) logger.debug(\"workInProgress=\" + workInProgress);\n\t\tif (workInProgress) {\t\t\t\n\t\t\t// Keeping the current form values in memory is a one-shot deal at\n\t\t\t// present. The next time the user does anything, the form will be\n\t\t\t// refreshed from the database.\n\t\t\tworkInProgress = false;\n\t\t\treturn;\n\t\t}\n\n\t\tsuper.init();\n\n        // Clear view state.\n        previousAssignment = null;\n        nextAssignment = null;\n\t\tscoreRows = new ArrayList();\n\t\tupdatedComments = new ArrayList();\n\t\tupdatedGradeRecords = new ArrayList();\n\n\t\tif (assignmentId != null) {\n\t\t\tassignment = getGradebookManager().getAssignmentWithStats(assignmentId);\n\t\t\tif (assignment != null) {\n                // Get the list of assignments.  If we are sorting by mean, we\n                // need to fetch the assignment statistics as well. If categories\n\t\t\t\t// are enabled, we need to retrieve the categories and extract the assignments\n\t\t\t\t// b/c the assignments will be grouped by category\n\t\t\t\tList assignments;\n                if(!getCategoriesEnabled() && Assignment.SORT_BY_MEAN.equals(getAssignmentSortColumn())) {\n                    assignments = getGradebookManager().getAssignmentsWithStats(getGradebookId(),\n                            getAssignmentSortColumn(), isAssignmentSortAscending());\n                } else if (!getCategoriesEnabled()){\n                    assignments = getGradebookManager().getAssignments(getGradebookId(),\n                            getAssignmentSortColumn(), isAssignmentSortAscending());\n                } else {\n                \t// Categories are enabled, so the assignments are grouped by category\n                \tassignments = new ArrayList();\n                \tList categories = getGradebookManager().getCategoriesWithStats(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending(), getCategorySortColumn(), isCategorySortAscending());\n                \tif (categories != null) {\n                \t\tIterator catIter = categories.iterator();\n                \t\twhile (catIter.hasNext()) {\n                \t\t\tObject myObj = catIter.next();\n                \t\t\tif (myObj instanceof Category) {\n                \t\t\t\tCategory myCat = (Category) myObj;\n                \t\t\t\tList catAssigns = myCat.getAssignmentList();\n                \t\t\t\tif (catAssigns != null) {\n                \t\t\t\t\tassignments.addAll(catAssigns);\n                \t\t\t\t}\n                \t\t\t}\n                \t\t}\n                \t}\n                \t// we also need to retrieve all of the assignments that have not\n                \t// yet been assigned a category\n                \tList assignNoCategory = getGradebookManager().getAssignmentsWithNoCategory(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending());\n                \tif (assignNoCategory != null) {\n                \t\tassignments.addAll(assignNoCategory);\n                \t}\n                }\n\n                // Set up next and previous links, if any.\n                int thisIndex = assignments.indexOf(assignment);\n\t\t\t\tif (thisIndex > 0) {\n\t\t\t\t\tpreviousAssignment = (Assignment)assignments.get(thisIndex - 1);\n\t\t\t\t}\n\t\t\t\tif (thisIndex < (assignments.size() - 1)) {\n\t\t\t\t\tnextAssignment = (Assignment)assignments.get(thisIndex + 1);\n\t\t\t\t}\n\n\t\t\t\t// Set up score rows.\n\t\t\t\tMap enrollmentMap = getOrderedEnrollmentMap();\n\t\t\t\tList studentUids = new ArrayList(enrollmentMap.keySet());\n\t\t\t\tList gradeRecords = new ArrayList();\n\t\t\t\tif (getGradeEntryByPoints())\n\t\t\t\t\tgradeRecords = getGradebookManager().getAssignmentGradeRecords(assignment, studentUids);\n\t\t\t\telse if (getGradeEntryByPercent())\n\t\t\t\t\tgradeRecords = getGradebookManager().getAssignmentGradeRecordsConverted(assignment, studentUids);\n\n\t\t\t\tif (!isEnrollmentSort()) {\n\t\t\t\t\t// Need to sort and page based on a scores column.\n\t\t\t\t\tList scoreSortedStudentUids = new ArrayList();\n\t\t\t\t\tfor(Iterator iter = gradeRecords.iterator(); iter.hasNext();) {\n\t\t\t\t\t\tAbstractGradeRecord agr = (AbstractGradeRecord)iter.next();\n\t\t\t\t\t\tscoreSortedStudentUids.add(agr.getStudentId());\n\t\t\t\t\t}\n\n\t\t\t\t\t// Put enrollments with no scores at the beginning of the final list.\n\t\t\t\t\tstudentUids.removeAll(scoreSortedStudentUids);\n\n\t\t\t\t\t// Add all sorted enrollments with scores into the final list\n\t\t\t\t\tstudentUids.addAll(scoreSortedStudentUids);\n\n\t\t\t\t\tstudentUids = finalizeSortingAndPaging(studentUids);\n\t\t\t\t}\n\n                // Get all of the grading events for these enrollments on this assignment\n                GradingEvents allEvents = getGradebookManager().getGradingEvents(assignment, studentUids);\n                getGradebookManager().convertGradingEventsConverted(assignment, allEvents, studentUids, getGradebook().getGrade_type());\n                \n                Map gradeRecordMap = new HashMap();\n                for (Iterator iter = gradeRecords.iterator(); iter.hasNext(); ) {\n\t\t\t\t\tAssignmentGradeRecord gradeRecord = (AssignmentGradeRecord)iter.next();\n\t\t\t\t\tif (studentUids.contains(gradeRecord.getStudentId())) {\n\t\t\t\t\t\tgradeRecordMap.put(gradeRecord.getStudentId(), gradeRecord);\n\t\t\t\t\t}\n\t\t\t\t}\n\n                // If the table is not being sorted by enrollment information, then\n                // we had to gather grade records for all students to set up the\n                // current page. In that case, eliminate the undisplayed grade records\n                // to reduce data contention.\n                if (!isEnrollmentSort()) {\n                \tgradeRecords = new ArrayList(gradeRecordMap.values());\n                }\n\n                // Get all of the comments for these enrollments on this assignment.\n                List comments = getGradebookManager().getComments(assignment, studentUids);\n                Map commentMap = new HashMap();\n                for (Iterator iter = comments.iterator(); iter.hasNext(); ) {\n\t\t\t\t\tComment comment = (Comment)iter.next();\n\t\t\t\t\tcommentMap.put(comment.getStudentId(), comment);\n\t\t\t\t}\n\n\t\t\t\tfor (Iterator iter = studentUids.iterator(); iter.hasNext(); ) {\n\t\t\t\t\tString studentUid = (String)iter.next();\n\t\t\t\t\tEnrollmentRecord enrollment = (EnrollmentRecord)enrollmentMap.get(studentUid);\n\t\t\t\t\tAssignmentGradeRecord gradeRecord = (AssignmentGradeRecord)gradeRecordMap.get(studentUid);\n\t\t            if(gradeRecord == null) {\n\t\t                gradeRecord = new AssignmentGradeRecord(assignment, studentUid, null);\n\t\t                gradeRecords.add(gradeRecord);\n\t\t            }\n\t\t            // we may have some decimals with more than 2 places from the % conversion from points\n\t\t            if (gradeRecord != null && gradeRecord.getPointsEarned() != null && getGradeEntryByPercent()) {\n\t\t            \tdouble pointsEarned = gradeRecord.getPointsEarned().doubleValue();\n\t\t            \tpointsEarned = FacesUtil.getRoundDown(pointsEarned, 2);\n\t\t            \tgradeRecord.setPointsEarned(new Double(pointsEarned));\n\t\t            }\n\t\t            Comment comment = (Comment)commentMap.get(studentUid);\n\t\t            if (comment == null) {\n\t\t            \tcomment = new Comment(studentUid, null, assignment);\n\t\t            }\n\n\t\t\t\t\tscoreRows.add(new ScoreRow(enrollment, gradeRecord, comment, allEvents.getEvents(studentUid)));\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (getCategoriesEnabled()) {\n\t\t\t\t\tif (assignment.getCategory() != null) {\n\t\t\t\t\t\tif (getWeightingEnabled()) {\n\t\t\t\t\t\t\tDouble weight = assignment.getCategory().getWeight();\n\t\t\t\t\t\t\tif (weight != null && weight.doubleValue() > 0)\n\t\t\t\t\t\t\t\tweight = new Double(weight.doubleValue() * 100);\n\t\t\t\t\t\t\tassignmentWeight = weight.toString();\n\t\t\t\t\t\t\tassignmentCategory = assignment.getCategory().getName() + \" \" + getLocalizedString(\"cat_weight_display\", new String[] {assignmentWeight});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassignmentCategory = assignment.getCategory().getName();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tassignmentCategory = getLocalizedString(\"assignment_details_assign_category\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\t// The assignment might have been removed since this link was set up.\n\t\t\t\tif (logger.isWarnEnabled()) logger.warn(\"No assignmentId=\" + assignmentId + \" in gradebookUid \" + getGradebookUid());\n                FacesUtil.addErrorMessage(getLocalizedString(\"assignment_details_assignment_removed\"));\n\t\t\t}\n\t\t}\n\t}","commit_id":"68b44133085bd31f0b4199dd676f6ebf248b8267","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public String getAsString(FacesContext context, UIComponent component, Object value) {\n\t\tif (log.isDebugEnabled()) log.debug(\"getAsString(\" + context + \", \" + component + \", \" + value + \")\");\n\n\t\tString formattedAvg;\n\t\tString formattedPtsPossible;\n\t\tboolean notCounted = false;\n\t\tboolean isPoints = false;\n\t\tboolean isPercent = false;\n\t\tObject classAvg = value;\n\t\tObject pointsPossible = null;\n\t\tGradebook gradebook;\n\n\t\tif (value != null) {\n\t\t\tif (value instanceof Assignment) {\n\t\t\t\tAssignment assignment = (Assignment)value;\n\t\t\t\tgradebook = assignment.getGradebook();\n\t\t\t\tpointsPossible = assignment.getPointsPossible();\n\n\t\t\t\tif (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_POINTS) {\n\t\t\t\t\tisPoints = true;\n\t\t\t\t\tclassAvg = assignment.getAverageTotal();\n\t\t\t\t} else if (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_PERCENTAGE) {\n\t\t\t\t\tisPercent = true;\n\t\t\t\t\tclassAvg = assignment.getMean();\n\t\t\t\t}\n\t\t\t\tnotCounted = assignment.isNotCounted();\n\t\t\t\t\n\t\t\t} else if (value instanceof Category) {\n\t\t\t\tCategory category = (Category) value;\n\t\t\t\tgradebook = category.getGradebook();\n\t\t\t\tpointsPossible = category.getAverageTotalPoints();\n\t\t\t\t\n\t\t\t\t// Unassigned category won't have avg\n\t\t\t\tif (category.getId() == null) {\n\t\t\t\t\treturn FacesUtil.getLocalizedString(\"overview_unassigned_cat_avg\");\n\t\t\t\t}\n\t\t\t\telse if (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_POINTS) {\n\t\t\t\t\tisPoints = true;\n\t\t\t\t\tclassAvg = category.getAverageScore();\n\t\t\t\t} else if (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_PERCENTAGE) {\n\t\t\t\t\tisPercent = true;\n\t\t\t\t\tclassAvg = category.getMean();\n\t\t\t\t}\n\t\t\n\t\t\t} else if (value instanceof CourseGrade) {\n\t\t\t\t// course grade is always displayed as %\n\t\t\t\tisPercent = true;\n\t\t\t\tCourseGrade courseGrade = (CourseGrade) value;\n\t\t\t\tclassAvg = courseGrade.getMean();\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tformattedAvg = getFormattedValue(context, component, classAvg);\n\t\tformattedPtsPossible = getFormattedValue(context, component, pointsPossible);\n\t\t\n\t\tif (classAvg != null) {\n\t\t\tif (isPoints) {\n\t\t\t\tformattedAvg = FacesUtil.getLocalizedString(\"overview_avg_display_points\", new String[] {formattedAvg, formattedPtsPossible} );\n\t\t\t} else if (isPercent) {\n\t\t\t\tformattedAvg = FacesUtil.getLocalizedString(\"overview_avg_display_percent\", new String[] {formattedAvg} );\n\t\t\t}\n\n\t\t\tif (notCounted) {\n\t\t\t\tformattedAvg = FacesUtil.getLocalizedString(\"score_not_counted\",\n\t\t\t\t\t\tnew String[] {formattedAvg, FacesUtil.getLocalizedString(\"score_not_counted_tooltip\")});\n\t\t\t}\n\t\t}\n\t\treturn formattedAvg;\n\t}","id":74779,"modified_method":"public String getAsString(FacesContext context, UIComponent component, Object value) {\n\t\tif (log.isDebugEnabled()) log.debug(\"getAsString(\" + context + \", \" + component + \", \" + value + \")\");\n\n\t\tString formattedAvg;\n\t\tString formattedPtsPossible;\n\t\tboolean notCounted = false;\n\t\tboolean isPoints = false;\n\t\tboolean isPercent = false;\n\t\tObject avg = null;\n\t\tObject pointsPossible = null;\n\t\tGradebook gradebook;\n\n\t\tif (value != null) {\n\t\t\tif (value instanceof Assignment) {\n\t\t\t\tAssignment assignment = (Assignment)value;\n\t\t\t\tgradebook = assignment.getGradebook();\n\t\t\t\tpointsPossible = assignment.getPointsPossible();\n\n\t\t\t\tif (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_POINTS) {\n\t\t\t\t\tisPoints = true;\n\t\t\t\t\tavg = assignment.getAverageTotal();\n\t\t\t\t} else if (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_PERCENTAGE) {\n\t\t\t\t\tisPercent = true;\n\t\t\t\t\tavg = assignment.getMean();\n\t\t\t\t}\n\t\t\t\tnotCounted = assignment.isNotCounted();\n\t\t\t\t\n\t\t\t} else if (value instanceof Category) {\n\t\t\t\tCategory category = (Category) value;\n\t\t\t\tgradebook = category.getGradebook();\n\t\t\t\tpointsPossible = category.getAverageTotalPoints();\n\t\t\t\t\n\t\t\t\t// Unassigned category won't have avg\n\t\t\t\tif (category.getId() == null) {\n\t\t\t\t\treturn FacesUtil.getLocalizedString(\"overview_unassigned_cat_avg\");\n\t\t\t\t}\n\t\t\t\telse if (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_POINTS) {\n\t\t\t\t\tisPoints = true;\n\t\t\t\t\tavg = category.getAverageScore();\n\t\t\t\t} else if (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_PERCENTAGE) {\n\t\t\t\t\tisPercent = true;\n\t\t\t\t\tavg = category.getMean();\n\t\t\t\t}\n\t\t\n\t\t\t} else if (value instanceof CourseGrade) {\n\t\t\t\t// course grade is always displayed as %\n\t\t\t\tisPercent = true;\n\t\t\t\tCourseGrade courseGrade = (CourseGrade) value;\n\t\t\t\tavg = courseGrade.getMean();\t\n\t\t\t\t\n\t\t\t} else if (value instanceof AssignmentGradeRow) {\n\t\t\t\tAssignmentGradeRow gradeRow = (AssignmentGradeRow) value;\n\t\t\t\tgradebook = gradeRow.getGradebook();\n\t\t\t\tif (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_POINTS) {\n\t\t\t\t\tisPoints = true;\n\t\t\t\t\tpointsPossible = gradeRow.getAssociatedAssignment().getPointsPossible();\n\t\t\t\t\tavg = gradeRow.getPointsEarned();\n\t\t\n\t\t\t\t} else if (gradebook.getGrade_type() == GradebookService.GRADE_TYPE_PERCENTAGE) {\n\t\t\t\t\tisPercent = true;\n\t\t\t\t\tavg = gradeRow.getGradeAsPercentage();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tformattedAvg = getFormattedValue(context, component, avg);\n\t\tformattedPtsPossible = getFormattedValue(context, component, pointsPossible);\n\t\t\n\t\tif (avg != null) {\n\t\t\tif (isPoints) {\n\t\t\t\tformattedAvg = FacesUtil.getLocalizedString(\"overview_avg_display_points\", new String[] {formattedAvg, formattedPtsPossible} );\n\t\t\t} else if (isPercent) {\n\t\t\t\tformattedAvg = FacesUtil.getLocalizedString(\"overview_avg_display_percent\", new String[] {formattedAvg} );\n\t\t\t}\n\n\t\t\tif (notCounted) {\n\t\t\t\tformattedAvg = FacesUtil.getLocalizedString(\"score_not_counted\",\n\t\t\t\t\t\tnew String[] {formattedAvg, FacesUtil.getLocalizedString(\"score_not_counted_tooltip\")});\n\t\t\t}\n\t\t}\n\t\treturn formattedAvg;\n\t}","commit_id":"68b44133085bd31f0b4199dd676f6ebf248b8267","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * We put all our processing in the encodeChildren method\n\t * @param context\n\t * @param component\n\t * @throws IOException\n\t */\n\tpublic void encodeChildren(FacesContext context, UIComponent component)\n\tthrows IOException\n\t{\n\n\t\tif ((context == null) || (component == null)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!component.isRendered()) {\n\t\t\treturn;\n\t\t}\n\n\t\tUIData data = (UIData) component;\n\n\t\tValueBinding gbItemsBinding = component.getValueBinding(\"value\");\n\t\tList gbItemList = (List)gbItemsBinding.getValue(context);\n\n\t\t// Set up variables we will need\n\t\tString columnClasses[] = getColumnClasses(data);\n\t\tint columnStyle = 0;\n\t\tint columnStyles = columnClasses.length;\n\t\tString rowClasses[] = getRowClasses(data);\n\t\tint rowStyles = rowClasses.length;\n\t\tResponseWriter writer = context.getResponseWriter();\n\t\tIterator kids = null;\n\t\tIterator grandkids = null;\n\n\t\t// Iterate over the rows of data that are provided\n\t\tint processed = 0;\n\t\tint rowIndex = data.getFirst() - 1;\n\t\tint rows = data.getRows();\n\t\tint rowStyle = 0;\n\n\t\t\n\n\t\twriter.startElement(\"tbody\", component);\n\t\twriter.writeText(\"\\n\", null);\n\t\tint hideDivNo = 0;\n\t\twhile (true) {\n\t\t\tCategory gbCategory = null;\n\t\t\tGradableObject go = null;\n\t\t\tboolean isCategory = false;\n\t\t\tboolean isAssignment = false;\n\t\t\tboolean isCourseGrade = false;\n\t\t\t\n\t\t\tif(gbItemList !=null && gbItemList.size() > (rowIndex+1) && rowIndex > -2)\n\t\t\t{\n\t\t\t\tObject gbItem = gbItemList.get(rowIndex+1);\n\t\t\t\tif (gbItem instanceof Category) {\n\t\t\t\t\tisCategory = true;\n\t\t\t\t\tisCourseGrade = false;\n\t\t\t\t\tisAssignment = false;\n\t\t\t\t\tgbCategory = (Category) gbItem;\n\t\t\t\t}\n\t\t\t\telse if (gbItem instanceof GradableObject){\n\t\t\t\t\tisCategory = false;\n\t\t\t\t\tgo = (GradableObject) gbItem;\n\t\t\t\t\tif (go.isAssignment()) {\n\t\t\t\t\t\tisAssignment = true;\n\t\t\t\t\t\tisCourseGrade = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisAssignment = false;\n\t\t\t\t\t\tisCourseGrade = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid class passed to renderer: \" + gbItem.getClass());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean hasChildBoolean = false;\n\t\t\tif(isCategory && gbCategory != null && gbItemList.size() > rowIndex + 2)\n\t\t\t{\n\t\t\t\tObject nextItem = gbItemList.get(rowIndex+2);\n\t\t\t\tif (nextItem instanceof GradableObject) {\n\t\t\t\t\tGradableObject nextGo = (GradableObject) nextItem;\n\t\t\t\t\tif (nextGo.isAssignment())\n\t\t\t\t\t\thasChildBoolean = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Have we displayed the requested number of rows?\n\t\t\tif ((rows > 0) && (++processed > rows)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Select the current row\n\t\t\tdata.setRowIndex(++rowIndex);\n\t\t\tif (!data.isRowAvailable()) {\n\t\t\t\tbreak; // Scrolled past the last row\n\t\t\t}\n\n\t\t\t// Render the beginning of this row\n\t\t\twriter.startElement(\"tr\", data);\n\t\t\tif(isAssignment)\n\t\t\t{\n\t\t\t\tString assignId = \"_id_\" + new Integer(hideDivNo).toString() + \"__hide_division_\";\n\t\t\t\twriter.writeAttribute(\"id\", assignId, null);\n\t\t\t\tif (!expanded) \n\t\t\t\t\twriter.writeAttribute(\"style\", \"display:none;\", null);\n\t\t\t}\n\n\t\t\tif (rowStyles > 0) {\n\t\t\t\twriter.writeAttribute(\"class\", rowClasses[rowStyle++],\n\t\t\t\t\"rowClasses\");\n\t\t\t\tif (rowStyle >= rowStyles) {\n\t\t\t\t\trowStyle = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twriter.writeText(\"\\n\", null);\n\n\t\t\t// Iterate over the child UIColumn components for each row\n\t\t\tcolumnStyle = 0;\n\t\t\tkids = getColumns(data);\n\t\t\twhile (kids.hasNext()) {\n\n\t\t\t\t// Identify the next renderable column\n\t\t\t\tUIColumn column = (UIColumn) kids.next();\n\n\t\t\t\t// Render the beginning of this cell\n\t\t\t\twriter.startElement(\"td\", column);\n\t\t\t\tif (columnStyles > 0) {\n\t\t\t\t\twriter.writeAttribute(\"class\", columnClasses[columnStyle++],\n\t\t\t\t\t\"columnClasses\");\n\t\t\t\t\tif (columnStyle >= columnStyles) {\n\t\t\t\t\t\tcolumnStyle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif((isAssignment || isCourseGrade || isCategory) && column.getId().endsWith(\"_toggle\"))\n\t\t\t\t{\n\t\t\t\t\tif(hasChildBoolean && isCategory)\n\t\t\t\t\t{\n\t\t\t\t\t\tList assignList = gbCategory.getAssignmentList();\n\t\t\t\t\t\tint childNo = 0;\n\t\t\t\t\t\tif (assignList != null && !assignList.isEmpty())\n\t\t\t\t\t\t\tchildNo = assignList.size();\n\t\t\n\t\t\t\t\t\tString imgId = \"_id_\" + new Integer(hideDivNo).toString() + \"__img_hide_division_\";\n\t\t\t\t\t\tString hideTr = \"\";\n\t\t\t\t\t\tfor(int i=0; i<childNo; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thideTr += \"javascript:showHideDiv('_id_\" + new Integer(hideDivNo+i).toString() + \n\t\t\t\t\t\t\t\t\"', '\" +  path + \"', '\" + imgExpandAlt  + \"', '\" + imgCollapseAlt  + \"', '\" + imgExpandTitle + \"', '\" + imgCollapseTitle + \"');\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\thideTr += \"mySetMainFrameHeight('Main\" + ToolManager.getCurrentPlacement().getId().replace('-','x') + \"');\";\n\n\t\t\t\t\t\twriter.startElement(HTML.IMG_ELEM, image);\n\t\t\t\t\t\twriter.writeURIAttribute(\"src\", image.getValue(), null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"onclick\", hideTr, null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"style\", CURSOR, null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"alt\", image.getAlt(), null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"title\", image.getTitle(), null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"id\", imgId, null);\n\t\t\t\t\t\twriter.endElement(HTML.IMG_ELEM);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twriter.endElement(\"td\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\t\t\t\t// Render the contents of this cell by iterating over\n\t\t\t\t// the kids of our kids\n\t\t\t\tgrandkids = getChildren(column);\n\t\t\t\twhile (grandkids.hasNext()) {\n\t\t\t\t\tencodeRecursive(context, (UIComponent) grandkids.next());\n\t\t\t\t}\n\n\t\t\t\t// Render the ending of this cell\n\t\t\t\twriter.endElement(\"td\");\n\t\t\t\twriter.writeText(\"\\n\", null);\n\n\t\t\t}\n\n\t\t\t// Render the ending of this row\n\t\t\twriter.endElement(\"tr\");\n\t\t\twriter.writeText(\"\\n\", null);\n\n\t\t\tif(isAssignment)\n\t\t\t{\n\t\t\t\tif(expanded)\n\t\t\t\t{\n\t\t\t\t\twriter.write(\"<script type=\\\"text/javascript\\\">\");\n\t\t\t\t\twriter.write(\"  showHideDiv('_id_\" + new Integer(hideDivNo).toString() +\n\t\t\t\t\t\t\t\"', '\" +  path + \"', '\" + imgExpandAlt  + \"', '\" + imgCollapseAlt  + \"', '\" + imgExpandTitle + \"', '\" + imgCollapseTitle + \"');\");\n\t\t\t\t\twriter.write(\"<\/script>\");\n\t\t\t\t}\n\n\t\t\t\thideDivNo++;\n\t\t\t}\n\t\t}\n\t\twriter.endElement(\"tbody\");\n\t\twriter.writeText(\"\\n\", null);\n\n\t\t// Clean up after ourselves\n\t\tdata.setRowIndex(-1);\n\t\tif (log.isTraceEnabled()) {\n\t\t\tlog.trace(\"End encoding children \" +\n\t\t\t\t\tcomponent.getId());\n\t\t}\n\t}","id":74780,"modified_method":"/**\n\t * We put all our processing in the encodeChildren method\n\t * @param context\n\t * @param component\n\t * @throws IOException\n\t */\n\tpublic void encodeChildren(FacesContext context, UIComponent component)\n\tthrows IOException\n\t{\n\n\t\tif ((context == null) || (component == null)) {\n\t\t\treturn;\n\t\t}\n\t\tif (!component.isRendered()) {\n\t\t\treturn;\n\t\t}\n\n\t\tUIData data = (UIData) component;\n\n\t\tValueBinding gbItemsBinding = component.getValueBinding(\"value\");\n\t\tList gbItemList = (List)gbItemsBinding.getValue(context);\n\n\t\t// Set up variables we will need\n\t\tString columnClasses[] = getColumnClasses(data);\n\t\tint columnStyle = 0;\n\t\tint columnStyles = columnClasses.length;\n\t\tString rowClasses[] = getRowClasses(data);\n\t\tint rowStyles = rowClasses.length;\n\t\tResponseWriter writer = context.getResponseWriter();\n\t\tIterator kids = null;\n\t\tIterator grandkids = null;\n\n\t\t// Iterate over the rows of data that are provided\n\t\tint processed = 0;\n\t\tint rowIndex = data.getFirst() - 1;\n\t\tint rows = data.getRows();\n\t\tint rowStyle = 0;\n\n\t\t\n\n\t\twriter.startElement(\"tbody\", component);\n\t\twriter.writeText(\"\\n\", null);\n\t\tint hideDivNo = 0;\n\t\twhile (true) {\n\t\t\tCategory gbCategory = null;\n\n\t\t\tboolean isCategory = false;\n\t\t\tboolean isAssignment = false;\n\t\t\tboolean isCourseGrade = false;\n\t\t\tboolean isGradeRow = false;\n\t\t\t\n\t\t\tif(gbItemList !=null && gbItemList.size() > (rowIndex+1) && rowIndex > -2)\n\t\t\t{\n\t\t\t\tObject gbItem = gbItemList.get(rowIndex+1);\n\t\t\t\tif (gbItem instanceof Category) {\n\t\t\t\t\tisCategory = true;\n\t\t\t\t\tisCourseGrade = false;\n\t\t\t\t\tisAssignment = false;\n\t\t\t\t\tgbCategory = (Category) gbItem;\n\t\t\t\t}\n\t\t\t\telse if (gbItem instanceof GradableObject){\n\t\t\t\t\tisCategory = false;\n\t\t\t\t\tGradableObject go = (GradableObject) gbItem;\n\t\t\t\t\tif (go.isAssignment()) {\n\t\t\t\t\t\tisAssignment = true;\n\t\t\t\t\t\tisCourseGrade = true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tisAssignment = false;\n\t\t\t\t\t\tisCourseGrade = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (gbItem instanceof AssignmentGradeRow) {\n\t\t\t\t\tisCategory = false;\n\t\t\t\t\tisCourseGrade = false;\n\t\t\t\t\tisAssignment = false;\n\t\t\t\t\tisGradeRow = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid class passed to renderer: \" + gbItem.getClass());\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean hasChildBoolean = false;\n\t\t\tint childNo = 0;\n\t\t\tif(isCategory && gbCategory != null && gbItemList.size() > rowIndex + 2)\n\t\t\t{\n\t\t\t\tfor (int i=rowIndex+2; i < gbItemList.size(); i++) {\n\t\t\t\t\tObject nextItem = gbItemList.get(i);\n\t\t\t\t\tif (nextItem instanceof GradableObject) {\n\t\t\t\t\t\tGradableObject nextGo = (GradableObject) nextItem;\n\t\t\t\t\t\tif (nextGo.isAssignment()) {\n\t\t\t\t\t\t\thasChildBoolean = true;\n\t\t\t\t\t\t\tchildNo++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} \n\t\t\t\t\telse if (nextItem instanceof AssignmentGradeRow) {\n\t\t\t\t\t\thasChildBoolean = true;\n\t\t\t\t\t\tchildNo++;\n\t\t\t\t\t} else if (nextItem instanceof Category) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} \n\n\t\t\t// Have we displayed the requested number of rows?\n\t\t\tif ((rows > 0) && (++processed > rows)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Select the current row\n\t\t\tdata.setRowIndex(++rowIndex);\n\t\t\tif (!data.isRowAvailable()) {\n\t\t\t\tbreak; // Scrolled past the last row\n\t\t\t}\n\n\t\t\t// Render the beginning of this row\n\t\t\twriter.startElement(\"tr\", data);\n\t\t\tif(isAssignment || isGradeRow)\n\t\t\t{\n\t\t\t\tString assignId = \"_id_\" + new Integer(hideDivNo).toString() + \"__hide_division_\";\n\t\t\t\twriter.writeAttribute(\"id\", assignId, null);\n\t\t\t\tif (!expanded) \n\t\t\t\t\twriter.writeAttribute(\"style\", \"display:none;\", null);\n\t\t\t}\n\n\t\t\tif (rowStyles > 0) {\n\t\t\t\twriter.writeAttribute(\"class\", rowClasses[rowStyle++],\n\t\t\t\t\"rowClasses\");\n\t\t\t\tif (rowStyle >= rowStyles) {\n\t\t\t\t\trowStyle = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\twriter.writeText(\"\\n\", null);\n\n\t\t\t// Iterate over the child UIColumn components for each row\n\t\t\tcolumnStyle = 0;\n\t\t\tkids = getColumns(data);\n\t\t\twhile (kids.hasNext()) {\n\n\t\t\t\t// Identify the next renderable column\n\t\t\t\tUIColumn column = (UIColumn) kids.next();\n\n\t\t\t\t// Render the beginning of this cell\n\t\t\t\twriter.startElement(\"td\", column);\n\t\t\t\tif (columnStyles > 0) {\n\t\t\t\t\twriter.writeAttribute(\"class\", columnClasses[columnStyle++],\n\t\t\t\t\t\"columnClasses\");\n\t\t\t\t\tif (columnStyle >= columnStyles) {\n\t\t\t\t\t\tcolumnStyle = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif((isAssignment || isCourseGrade || isCategory || isGradeRow) \n\t\t\t\t\t\t&& column.getId().endsWith(\"_toggle\"))\n\t\t\t\t{\n\t\t\t\t\tif(hasChildBoolean && isCategory)\n\t\t\t\t\t{\n\t\t\t\t\t\tString imgId = \"_id_\" + new Integer(hideDivNo).toString() + \"__img_hide_division_\";\n\t\t\t\t\t\tString hideTr = \"\";\n\t\t\t\t\t\tfor(int i=0; i<childNo; i++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thideTr += \"javascript:showHideDiv('_id_\" + new Integer(hideDivNo+i).toString() + \n\t\t\t\t\t\t\t\t\"', '\" +  path + \"', '\" + imgExpandAlt  + \"', '\" + imgCollapseAlt  + \"', '\" + imgExpandTitle + \"', '\" + imgCollapseTitle + \"');\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\thideTr += \"mySetMainFrameHeight('Main\" + ToolManager.getCurrentPlacement().getId().replace('-','x') + \"');\";\n\n\t\t\t\t\t\twriter.startElement(HTML.IMG_ELEM, image);\n\t\t\t\t\t\twriter.writeURIAttribute(\"src\", image.getValue(), null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"onclick\", hideTr, null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"style\", CURSOR, null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"alt\", image.getAlt(), null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"title\", image.getTitle(), null);\n\t\t\t\t\t\twriter.writeURIAttribute(\"id\", imgId, null);\n\t\t\t\t\t\twriter.endElement(HTML.IMG_ELEM);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\twriter.endElement(\"td\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\n\t\t\t\t// Render the contents of this cell by iterating over\n\t\t\t\t// the kids of our kids\n\t\t\t\tgrandkids = getChildren(column);\n\t\t\t\twhile (grandkids.hasNext()) {\n\t\t\t\t\tencodeRecursive(context, (UIComponent) grandkids.next());\n\t\t\t\t}\n\n\t\t\t\t// Render the ending of this cell\n\t\t\t\twriter.endElement(\"td\");\n\t\t\t\twriter.writeText(\"\\n\", null);\n\n\t\t\t}\n\n\t\t\t// Render the ending of this row\n\t\t\twriter.endElement(\"tr\");\n\t\t\twriter.writeText(\"\\n\", null);\n\n\t\t\tif(isAssignment || isGradeRow)\n\t\t\t{\n\t\t\t\tif(expanded)\n\t\t\t\t{\n\t\t\t\t\twriter.write(\"<script type=\\\"text/javascript\\\">\");\n\t\t\t\t\twriter.write(\"  showHideDiv('_id_\" + new Integer(hideDivNo).toString() +\n\t\t\t\t\t\t\t\"', '\" +  path + \"', '\" + imgExpandAlt  + \"', '\" + imgCollapseAlt  + \"', '\" + imgExpandTitle + \"', '\" + imgCollapseTitle + \"');\");\n\t\t\t\t\twriter.write(\"<\/script>\");\n\t\t\t\t}\n\n\t\t\t\thideDivNo++;\n\t\t\t}\n\t\t}\n\t\twriter.endElement(\"tbody\");\n\t\twriter.writeText(\"\\n\", null);\n\n\t\t// Clean up after ourselves\n\t\tdata.setRowIndex(-1);\n\t\tif (log.isTraceEnabled()) {\n\t\t\tlog.trace(\"End encoding children \" +\n\t\t\t\t\tcomponent.getId());\n\t\t}\n\t}","commit_id":"68b44133085bd31f0b4199dd676f6ebf248b8267","url":"https://github.com/sakaiproject/sakai"},{"original_method":"protected void init() {\n\n\t\tgradebookItemList = new ArrayList();\n\t\ttotalPoints = 0;\n\n\t\tif (getCategoriesEnabled()) {\n\t\t\t/* if categories are enabled, we need to display a table that includes\n\t\t\t * categories, assignments, and possibly the course grade. Thus,\n\t\t\t * we use a generic DecoratedGradebookItem\n\t\t\t */\n\t\t\tCourseGrade courseGrade = new CourseGrade();\n\t\t\tList categoryList = getGradebookManager().getCategoriesWithStats(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending(), getCategorySortColumn(), isCategorySortAscending());\n\t\t\tif (categoryList != null && !categoryList.isEmpty()) {\n\t\t\t\tIterator catIter = categoryList.iterator();\n\t\t\t\twhile (catIter.hasNext()) {\n\t\t\t\t\tObject catOrCourseGrade = catIter.next();\n\t\t\t\t\tif (catOrCourseGrade instanceof Category) {\n\t\t\t\t\t\tCategory myCat = (Category) catOrCourseGrade;\n\t\t\t\t\t\tgradebookItemList.add(myCat);\n\t\t\t\t\t\tList assignmentList = myCat.getAssignmentList();\n\t\t\t\t\t\tif (assignmentList != null && !assignmentList.isEmpty()) {\n\t\t\t\t\t\t\tIterator assignIter = assignmentList.iterator();\n\t\t\t\t\t\t\twhile (assignIter.hasNext()) {\n\t\t\t\t\t\t\t\tAssignment assign = (Assignment) assignIter.next();\n\t\t\t\t\t\t\t\tgradebookItemList.add(assign);\n\t\t\t\t\t\t\t\tif (assign.isCounted()) {\n\t\t\t\t\t\t\t\t\ttotalPoints += assign.getPointsPossible().doubleValue();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (catOrCourseGrade instanceof CourseGrade) {\n\t\t\t\t\t\tcourseGrade = (CourseGrade) catOrCourseGrade;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tList unassignedList = getGradebookManager().getAssignmentsWithNoCategoryWithStats(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending());\n\t\t\tif (unassignedList != null && !unassignedList.isEmpty()) {\n\t\t\t\tCategory unassignedCat = new Category();\n\t\t\t\tunassignedCat.setGradebook(getGradebook());\n\t\t\t\tunassignedCat.setAverageScore(new Double(0));\n\t\t\t\tunassignedCat.setName(getLocalizedString(\"cat_unassigned\"));\n\t\t\t\tunassignedCat.setAssignmentList(unassignedList);\n\t\t\t\tgradebookItemList.add(unassignedCat);\n\n\t\t\t\tIterator unassignedIter = unassignedList.iterator();\n\t\t\t\twhile (unassignedIter.hasNext()) {\n\t\t\t\t\tAssignment assignWithNoCat = (Assignment) unassignedIter.next();\n\t\t\t\t\tgradebookItemList.add(assignWithNoCat);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// finally, append the course grade to the list\n\t\t\tif (courseGrade != null) {\n\t\t\t\tgradebookItemList.add(courseGrade);\n\t\t\t}\n\t        \n\t\t} else {\n\t\t\t// Get the list of assignments for this gradebook, sorted as defined in the overview page.\n\t\t\tList goList = getGradebookManager().getAssignmentsAndCourseGradeWithStats(getGradebookId(),\n\t\t\t\t\tgetAssignmentSortColumn(), isAssignmentSortAscending());\n\t\t\tif (goList != null && !goList.isEmpty()) {\n\t\t\t\tIterator goIter = goList.iterator();\n\t\t\t\twhile (goIter.hasNext()) {\n\t\t\t\t\tGradableObject go = (GradableObject) goIter.next();\n\t\t\t\t\tif (go.isCourseGrade())\n\t\t\t\t\t\tgradebookItemList.add((CourseGrade)go);\n\t\t\t\t\telse {\n\t\t\t\t\t\tAssignment assign = (Assignment) go;\n\t\t\t\t\t\tgradebookItemList.add(assign);\n\t\t\t\t\t\tif (assign.isCounted()) {\n\t\t\t\t\t\t\ttotalPoints += assign.getPointsPossible().doubleValue();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":74781,"modified_method":"protected void init() {\n\n\t\tgradebookItemList = new ArrayList();\n\t\tcourseGrade = new CourseGrade();\n\n\t\tif (getCategoriesEnabled()) {\n\t\t\t/* if categories are enabled, we need to display a table that includes\n\t\t\t * categories, assignments, and the course grade.\n\t\t\t */\n\t\t\tList categoryList = getGradebookManager().getCategoriesWithStats(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending(), getCategorySortColumn(), isCategorySortAscending());\n\t\t\tif (categoryList != null && !categoryList.isEmpty()) {\n\t\t\t\tIterator catIter = categoryList.iterator();\n\t\t\t\twhile (catIter.hasNext()) {\n\t\t\t\t\tObject catOrCourseGrade = catIter.next();\n\t\t\t\t\tif (catOrCourseGrade instanceof Category) {\n\t\t\t\t\t\tCategory myCat = (Category) catOrCourseGrade;\n\t\t\t\t\t\tgradebookItemList.add(myCat);\n\t\t\t\t\t\tList assignmentList = myCat.getAssignmentList();\n\t\t\t\t\t\tif (assignmentList != null && !assignmentList.isEmpty()) {\n\t\t\t\t\t\t\tIterator assignIter = assignmentList.iterator();\n\t\t\t\t\t\t\twhile (assignIter.hasNext()) {\n\t\t\t\t\t\t\t\tAssignment assign = (Assignment) assignIter.next();\n\t\t\t\t\t\t\t\tgradebookItemList.add(assign);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (catOrCourseGrade instanceof CourseGrade) {\n\t\t\t\t\t\tcourseGrade = (CourseGrade) catOrCourseGrade;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tList unassignedList = getGradebookManager().getAssignmentsWithNoCategoryWithStats(getGradebookId(), getAssignmentSortColumn(), isAssignmentSortAscending());\n\t\t\tif (unassignedList != null && !unassignedList.isEmpty()) {\n\t\t\t\tCategory unassignedCat = new Category();\n\t\t\t\tunassignedCat.setGradebook(getGradebook());\n\t\t\t\tunassignedCat.setAverageScore(new Double(0));\n\t\t\t\tunassignedCat.setName(getLocalizedString(\"cat_unassigned\"));\n\t\t\t\tunassignedCat.setAssignmentList(unassignedList);\n\t\t\t\tgradebookItemList.add(unassignedCat);\n\n\t\t\t\tIterator unassignedIter = unassignedList.iterator();\n\t\t\t\twhile (unassignedIter.hasNext()) {\n\t\t\t\t\tAssignment assignWithNoCat = (Assignment) unassignedIter.next();\n\t\t\t\t\tgradebookItemList.add(assignWithNoCat);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// finally, append the course grade to the list\n\t\t\tif (courseGrade != null) {\n\t\t\t\tgradebookItemList.add(courseGrade);\n\t\t\t}\n\t        \n\t\t} else {\n\t\t\t// Get the list of assignments for this gradebook, sorted as defined in the overview page.\n\t\t\tList goList = getGradebookManager().getAssignmentsAndCourseGradeWithStats(getGradebookId(),\n\t\t\t\t\tgetAssignmentSortColumn(), isAssignmentSortAscending());\n\t\t\tif (goList != null && !goList.isEmpty()) {\n\t\t\t\tIterator goIter = goList.iterator();\n\t\t\t\twhile (goIter.hasNext()) {\n\t\t\t\t\tGradableObject go = (GradableObject) goIter.next();\n\t\t\t\t\tif (go.isCourseGrade()) {\n\t\t\t\t\t\tgradebookItemList.add((CourseGrade)go);\n\t\t\t\t\t\tcourseGrade = (CourseGrade) go;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAssignment assign = (Assignment) go;\n\t\t\t\t\t\tgradebookItemList.add(assign);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"68b44133085bd31f0b4199dd676f6ebf248b8267","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n     * @see org.sakaiproject.tool.gradebook.ui.InitializableBean#init()\n     */\n    public void init() {\n        // Get the active gradebook\n        Gradebook gradebook = getGradebook();\n\n        // Set the display name\n        try {\n            userDisplayName = getUserDirectoryService().getUserDisplayName(getUserUid());\n        } catch (UnknownUserException e) {\n            if(logger.isErrorEnabled())logger.error(\"User \" + getUserUid() + \" is unknown but logged in as student in gradebook \" + gradebook.getUid());\n            userDisplayName = \"\";\n        }\n        courseGradeReleased = gradebook.isCourseGradeDisplayed();\n        assignmentsReleased = gradebook.isAssignmentsDisplayed();\n\n        // Reset the row styles\n        rowStyles = new StringBuffer();\n\n        // Display course grade if we've been instructed to.\n        if (gradebook.isCourseGradeDisplayed()) {\n            CourseGradeRecord gradeRecord = getGradebookManager().getStudentCourseGradeRecord(gradebook, getUserUid());\n            if (gradeRecord != null) {\n                courseGrade = gradeRecord.getDisplayGrade();\n                // Note that the percentage will be null for a manual-only grade\n                // code (such as \"I\" for incomplete).\n                percent = gradeRecord.getGradeAsPercentage();\n            }\n        }\n        //get grade comments and load them into a map assignmentId->comment\n        commentMap = new HashMap();\n        List assignmentComments = getGradebookManager().getStudentAssignmentComments(getUserUid(),getGradebookId());\n        logger.debug(\"number of comments \"+assignmentComments.size());\n        Iterator iteration = assignmentComments.iterator();\n        while (iteration.hasNext()){\n            Comment comment = (Comment)iteration.next();\n            commentMap.put(comment.getGradableObject().getId(),comment);\n        }\n\n        // Don't display any assignments if they have not been released\n        if(!gradebook.isAssignmentsDisplayed()) {\n            assignmentGradeRows = new ArrayList();\n        } else {\n            List assignments = getGradebookManager().getAssignments(gradebook.getId());\n            if(logger.isDebugEnabled())logger.debug(assignments.size() + \" total assignments\");\n            List gradeRecords = getGradebookManager().getStudentGradeRecords(gradebook.getId(), getUserUid());\n            if(logger.isDebugEnabled())logger.debug(gradeRecords.size()  +\"  grade records\");\n\n            // Create a map of assignments to assignment grade rows\n            Map asnMap = new HashMap();\n            for(Iterator iter = assignments.iterator(); iter.hasNext();) {\n\n                Assignment asn = (Assignment)iter.next();\n                asnMap.put(asn, new AssignmentGradeRow(asn));\n\n                if (asn.isNotCounted()) {\n                    anyNotCounted = true;\n                }\n\n            }\n\n            for(Iterator iter = gradeRecords.iterator(); iter.hasNext();) {\n                AssignmentGradeRecord asnGr = (AssignmentGradeRecord)iter.next();\n                if(logger.isDebugEnabled()) logger.debug(\"Adding \" + asnGr.getPointsEarned() + \" to totalPointsEarned\");\n                // Update the AssignmentGradeRow in the map\n                AssignmentGradeRow asnGradeRow = (AssignmentGradeRow)asnMap.get(asnGr.getAssignment());\n                asnGradeRow.setGradeRecord(asnGr);\n\n            }\n\n            //iterate through the assignments and update the comments\n            Iterator assignmentIterator = assignments.iterator();\n            while(assignmentIterator.hasNext()){\n                Assignment assignment = (Assignment) assignmentIterator.next();\n                AssignmentGradeRow asnGradeRow = (AssignmentGradeRow)asnMap.get(assignment);\n                try{\n                    Comment comment = (Comment)commentMap.get(asnGradeRow.getAssignment().getId());\n                    if(comment.getCommentText().length() > 0)asnGradeRow.getComments().add(comment);\n                }catch(NullPointerException npe){\n                    if(logger.isDebugEnabled())logger.debug(\"assignment has no associated comment\");\n                }\n            }\n\n            assignmentGradeRows = new ArrayList(asnMap.values());\n\n            //remove assignments that are not released\n            Iterator i = assignmentGradeRows.iterator();\n            while(i.hasNext()){\n                AssignmentGradeRow assignmentGradeRow = (AssignmentGradeRow)i.next();\n                if(!(assignmentGradeRow.getAssignment().isReleased())) i.remove();\n            }\n\n            Collections.sort(assignmentGradeRows, (Comparator)columnSortMap.get(sortColumn));\n            if(!sortAscending) {\n                Collections.reverse(assignmentGradeRows);\n            }\n\n            // Set the row css classes\n            for(Iterator iter = assignmentGradeRows.iterator(); iter.hasNext();) {\n                AssignmentGradeRow gr = (AssignmentGradeRow)iter.next();\n                if(gr.getAssignment().isExternallyMaintained()) {\n                    rowStyles.append(\"external\");\n                } else {\n                    rowStyles.append(\"internal\");\n                }\n                if(iter.hasNext()) {\n                    rowStyles.append(\",\");\n                }\n            }\n        }\n    }","id":74782,"modified_method":"/**\n     * @see org.sakaiproject.tool.gradebook.ui.InitializableBean#init()\n     */\n    public void init() {\n    \t// Get the active gradebook\n    \tGradebook gradebook = getGradebook();\n\n    \t// Set the display name\n    \ttry {\n    \t\tuserDisplayName = getUserDirectoryService().getUserDisplayName(getUserUid());\n    \t} catch (UnknownUserException e) {\n    \t\tif(logger.isErrorEnabled())logger.error(\"User \" + getUserUid() + \" is unknown but logged in as student in gradebook \" + gradebook.getUid());\n    \t\tuserDisplayName = \"\";\n    \t}\n    \tcourseGradeReleased = gradebook.isCourseGradeDisplayed();\n    \tassignmentsReleased = gradebook.isAssignmentsDisplayed();\n\n    \t// Reset the row styles\n    \trowStyles = new StringBuffer();\n\n    \t// Display course grade if we've been instructed to.\n    \tCourseGradeRecord gradeRecord = getGradebookManager().getStudentCourseGradeRecord(gradebook, getUserUid());\n    \tif (gradeRecord != null) {\n    \t\tif (courseGradeReleased) {\n    \t\t\tcourseGrade = gradeRecord.getDisplayGrade();\n    \t\t}\n\t\t\t// Note that the percentage will be null for a manual-only grade\n\t\t\t// code (such as \"I\" for incomplete).\n\t\t\tpercent = gradeRecord.getGradeAsPercentage();\n    \t}\n\n    \t// do not retrieve assignments if not displayed for students\n    \tif (assignmentsReleased) {\n\n    \t\t//get grade comments and load them into a map assignmentId->comment\n    \t\tcommentMap = new HashMap();\n    \t\tList assignmentComments = getGradebookManager().getStudentAssignmentComments(getUserUid(),getGradebookId());\n    \t\tlogger.debug(\"number of comments \"+assignmentComments.size());\n    \t\tIterator iteration = assignmentComments.iterator();\n    \t\twhile (iteration.hasNext()){\n    \t\t\tComment comment = (Comment)iteration.next();\n    \t\t\tcommentMap.put(comment.getGradableObject().getId(),comment);\n    \t\t}\n\n    \t\t// get the student grade records\n    \t\tList gradeRecords = getGradebookManager().getStudentGradeRecords(gradebook.getId(), getUserUid());\n\n    \t\t// The display may include categories and assignments, so we need a generic list\n    \t\tgradebookItems = new ArrayList();\n\n    \t\tif (getCategoriesEnabled()) {\n    \t\t\t// we will also have to determine the student's category avg - the category stats\n    \t\t\t// are for class avg\n    \t\t\tList categoryList = new ArrayList();\n    \t\t\tif (sortColumn.equals(Category.SORT_BY_WEIGHT))\n    \t\t\t\tcategoryList = getGradebookManager().getCategoriesWithStats(getGradebookId(), Assignment.DEFAULT_SORT, true, sortColumn, sortAscending);\n    \t\t\telse\n    \t\t\t\tcategoryList = getGradebookManager().getCategoriesWithStats(getGradebookId(), Assignment.DEFAULT_SORT, true, Category.SORT_BY_NAME, true);\n    \t\t\t\n    \t\t\t// first, we deal with the categories and their associated assignments\n    \t\t\tif (categoryList != null && !categoryList.isEmpty()) {\n    \t\t\t\tIterator catIter = categoryList.iterator();\n    \t\t\t\twhile (catIter.hasNext()) {\n    \t\t\t\t\tObject catObject = catIter.next();\n    \t\t\t\t\tif (catObject instanceof Category) {\n    \t\t\t\t\t\tCategory category = (Category) catObject;\n    \t\t\t\t\t\tgradebookItems.add(category);\n    \t\t\t\t\t\tList catAssign = category.getAssignmentList();\n    \t\t\t\t\t\tif (catAssign != null && !catAssign.isEmpty()) {\n    \t\t\t\t\t\t\t// we want to create the grade rows for these assignments\n    \t\t\t\t\t\t\tList gradeRows = retrieveGradeRows(catAssign, gradeRecords, gradebook);\n\t\t\t\t\t\t\t\tcalculateCategoryAverages(category, gradeRows);\n    \t\t\t\t\t\t\tif (gradeRows != null && !gradeRows.isEmpty()) {\n    \t\t\t\t\t\t\t\tgradebookItems.addAll(gradeRows);\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t// now we need to grab all of the assignments w/o a category\n    \t\t\tList assignNoCat = getGradebookManager().getAssignmentsWithNoCategory(getGradebookId(), Assignment.DEFAULT_SORT, true);\n    \t\t\tif (assignNoCat != null && !assignNoCat.isEmpty()) {\n    \t\t\t\tCategory unassignedCat = new Category();\n    \t\t\t\tunassignedCat.setGradebook(gradebook);\n    \t\t\t\tunassignedCat.setName(getLocalizedString(\"cat_unassigned\"));\n    \t\t\t\tunassignedCat.setAssignmentList(assignNoCat);\n    \t\t\t\t//add this category to our list\n    \t\t\t\tgradebookItems.add(unassignedCat);\n\n    \t\t\t\t// now create grade rows for the unassigned assignments\n    \t\t\t\tList gradeRows = retrieveGradeRows(assignNoCat, gradeRecords, gradebook);\n    \t\t\t\tif (gradeRows != null && !gradeRows.isEmpty()) {\n    \t\t\t\t\tgradebookItems.addAll(gradeRows);\n    \t\t\t\t}\n    \t\t\t}\n\n    \t\t} else {\n    \t\t\t// there are no categories, so we will be returning a list of grade rows\n    \t\t\tList assignList = getGradebookManager().getAssignments(getGradebookId());\n    \t\t\tif (assignList != null && !assignList.isEmpty()) {\n    \t\t\t\tList gradeRows = retrieveGradeRows(assignList, gradeRecords, gradebook);\n    \t\t\t\tif (gradeRows != null && !gradeRows.isEmpty()) {\n    \t\t\t\t\tgradebookItems.addAll(gradeRows);\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n\n    \t\tfor(Iterator iter = gradebookItems.iterator(); iter.hasNext();) {\n    \t\t\tObject gradebookItem = iter.next();\n    \t\t\tif (gradebookItem instanceof AssignmentGradeRow) {\n    \t\t\t\tAssignmentGradeRow gr = (AssignmentGradeRow)gradebookItem;\n    \t\t\t\tif(gr.getAssociatedAssignment().isExternallyMaintained()) {\n    \t\t\t\t\trowStyles.append(\"external\");\n    \t\t\t\t} else {\n    \t\t\t\t\trowStyles.append(\"internal\");\n    \t\t\t\t}\n    \t\t\t} \n\n    \t\t\tif(iter.hasNext()) {\n    \t\t\t\trowStyles.append(\",\");\n    \t\t\t}\n\n    \t\t}\n    \t}\n\n    }","commit_id":"68b44133085bd31f0b4199dd676f6ebf248b8267","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Format a grade, e.g. 00 => 0 0001 => 1 1.0 => 1 1.25 => 1.25\n\t *\n\t * @param grade\n\t * @return\n\t */\n\tpublic static String formatGrade(final String grade) {\n\t\tif (StringUtils.isBlank(grade)) {\n\t\t\treturn \"\";\n\t\t}\n\t\treturn StringUtils.removeEnd(String.valueOf(Double.parseDouble(grade)), \".0\");\n\t}","id":74783,"modified_method":"/**\n\t * Format a grade, e.g. 00 => 0 0001 => 1 1.0 => 1 1.25 => 1.25\n\t *\n\t * @param grade\n\t * @return\n\t */\n\tpublic static String formatGrade(final String grade) {\n\t\tif (StringUtils.isBlank(grade)) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tString s = null;\n\t\ttry {\n\t\t\tfinal Double d = Double.parseDouble(grade);\n\t\t\ts = String.valueOf(d);\n\t\t} catch (final NumberFormatException e) {\n\t\t\tlog.debug(\"Bad format, returning original string: \" + grade);\n\t\t\ts = grade;\n\t\t}\n\n\t\treturn StringUtils.removeEnd(s, \".0\");\n\t}","commit_id":"c9131ebd07d020166c633b7b9c62c3eb6528dd22","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t\t * Back to object for the model.\n\t\t *\n\t\t * this is persisted as a fraction between 0 and 1 so for two decimal place precision in the UI we need 4 here.\n\t\t *\n\t\t * String will be a percentage, get it back to a decimal fraction.\n\t\t */\n\t\t@Override\n\t\tpublic Double convertToObject(final String value, final Locale locale) throws ConversionException {\n\n\t\t\t// want this truncated to four decimal places, or less\n\t\t\tfinal NumberFormat df = NumberFormat.getInstance();\n\t\t\tdf.setMinimumFractionDigits(0);\n\t\t\tdf.setMaximumFractionDigits(4);\n\t\t\tdf.setRoundingMode(RoundingMode.HALF_UP);\n\n\t\t\t// convert\n\t\t\tDouble d;\n\t\t\ttry {\n\t\t\t\td = Double.valueOf(value) / 100;\n\t\t\t} catch (final NumberFormatException e) {\n\t\t\t\tthrow new ConversionException(e).setResourceKey(\"settingspage.update.failure.categoryweightnumber\");\n\t\t\t}\n\n\t\t\t// to string for the rounding/truncation\n\t\t\tfinal String s = df.format(d);\n\n\t\t\t// back to double\n\t\t\treturn Double.valueOf(s);\n\t\t}","id":74784,"modified_method":"/**\n\t\t * Back to object for the model.\n\t\t *\n\t\t * this is persisted as a fraction between 0 and 1 so for two decimal place precision in the UI we need 4 here.\n\t\t *\n\t\t * String will be a percentage, get it back to a decimal fraction.\n\t\t */\n\t\t@Override\n\t\tpublic Double convertToObject(final String value, final Locale locale) throws ConversionException {\n\n\t\t\t// convert\n\t\t\tDouble d;\n\t\t\ttry {\n\t\t\t\td = Double.valueOf(value) / 100;\n\t\t\t} catch (final NumberFormatException e) {\n\t\t\t\tthrow new ConversionException(e).setResourceKey(\"settingspage.update.failure.categoryweightnumber\");\n\t\t\t}\n\n\t\t\t// want this truncated to four decimal places, or less\n\t\t\t// format, then parse back into a double\n\t\t\tfinal DecimalFormat df = new DecimalFormat();\n\t\t\tdf.setMinimumFractionDigits(0);\n\t\t\tdf.setMaximumFractionDigits(4);\n\t\t\tdf.setRoundingMode(RoundingMode.HALF_UP);\n\n\t\t\tfinal String s = df.format(d);\n\n\t\t\ttry {\n\t\t\t\treturn df.parse(s).doubleValue();\n\t\t\t} catch (final ParseException e) {\n\t\t\t\tthrow new ConversionException(e).setResourceKey(\"settingspage.update.failure.categoryweightnumber\");\n\t\t\t}\n\n\t\t}","commit_id":"c9131ebd07d020166c633b7b9c62c3eb6528dd22","url":"https://github.com/sakaiproject/sakai"},{"original_method":"/**\n\t * Helper to handle the value and style updates of the running total label\n\t *\n\t * @param runningTotal label component to update\n\t * @param runningTotalMessage error message component\n\t * @return\n\t */\n\tprivate void updateRunningTotal(final Component runningTotal, final Component runningTotalMessage) {\n\n\t\tfinal List<CategoryDefinition> categories = SettingsCategoryPanel.this.model.getObject().getGradebookInformation().getCategories();\n\n\t\tBigDecimal total = BigDecimal.ZERO;\n\t\tfor (final CategoryDefinition categoryDefinition : categories) {\n\n\t\t\tBigDecimal weight = BigDecimal.valueOf(categoryDefinition.getWeight());\n\t\t\tif (weight == null) {\n\t\t\t\tweight = BigDecimal.ZERO;\n\t\t\t}\n\n\t\t\tif (!categoryDefinition.isExtraCredit()) {\n\t\t\t\ttotal = total.add(weight);\n\t\t\t}\n\t\t}\n\n\t\t// if comparison passes, we have '1' as the value\n\t\tif (total.compareTo(BigDecimal.ONE) == 0) {\n\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-success\"));\n\t\t\trunningTotalMessage.setVisible(false);\n\t\t} else {\n\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-danger\"));\n\t\t\trunningTotalMessage.setVisible(true);\n\t\t}\n\n\t\trunningTotal.setDefaultModel(Model.of(FormatHelper.formatDoubleAsPercentage(total.doubleValue() * 100)));\n\t}","id":74785,"modified_method":"/**\n\t * Helper to handle the value and style updates of the running total label\n\t *\n\t * @param runningTotal label component to update\n\t * @param runningTotalMessage error message component\n\t * @return\n\t */\n\tprivate void updateRunningTotal(final Component runningTotal, final Component runningTotalMessage) {\n\n\t\tfinal List<CategoryDefinition> categories = SettingsCategoryPanel.this.model.getObject().getGradebookInformation().getCategories();\n\n\t\tBigDecimal total = BigDecimal.ZERO;\n\t\tfor (final CategoryDefinition categoryDefinition : categories) {\n\n\t\t\tDouble catWeight = categoryDefinition.getWeight();\n\t\t\tif (catWeight == null) {\n\t\t\t\tcatWeight = 0D;\n\t\t\t}\n\n\t\t\tBigDecimal weight = BigDecimal.valueOf(catWeight);\n\t\t\tif (weight == null) {\n\t\t\t\tweight = BigDecimal.ZERO;\n\t\t\t}\n\n\t\t\tif (!categoryDefinition.isExtraCredit()) {\n\t\t\t\ttotal = total.add(weight);\n\t\t\t}\n\t\t}\n\n\t\t// if comparison passes, we have '1' as the value\n\t\tif (total.compareTo(BigDecimal.ONE) == 0) {\n\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-success\"));\n\t\t\trunningTotalMessage.setVisible(false);\n\t\t} else {\n\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-danger\"));\n\t\t\trunningTotalMessage.setVisible(true);\n\t\t}\n\n\t\trunningTotal.setDefaultModel(Model.of(FormatHelper.formatDoubleAsPercentage(total.doubleValue() * 100)));\n\t}","commit_id":"c9131ebd07d020166c633b7b9c62c3eb6528dd22","url":"https://github.com/sakaiproject/sakai"},{"original_method":"private Double calculateCategoryWeightTotal(List<CategoryDefinition> categories) {\n\t\tDouble total = new Double(0);\n\t\tfor (CategoryDefinition categoryDefinition : categories) {\n\t\t\tif (!categoryDefinition.isExtraCredit()) {\n\t\t\t\ttotal += categoryDefinition.getWeight();\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}","id":74786,"modified_method":"private Double calculateCategoryWeightTotal(List<CategoryDefinition> categories) {\n\t\tDouble total = new Double(0);\n\t\tfor (CategoryDefinition categoryDefinition : categories) {\n\t\t\t\n\t\t\tDouble weight = categoryDefinition.getWeight();\n\t\t\tif(weight == null) {\n\t\t\t\tweight = new Double(0);\n\t\t\t}\n\t\t\t\n\t\t\tif (!categoryDefinition.isExtraCredit()) {\n\t\t\t\ttotal += weight;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}","commit_id":"74d52326fc9e92885c405babbdb8961ebef4d7a2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\t\t\n\t\t//get categories, passed in\n\t\tfinal List<CategoryDefinition> categories = this.model.getObject().getGradebookInformation().getCategories();\n\t\t\t\t\n\t\t//parse the categories and see if we have any drophighest/lowest/keep highest and set the flags for the checkboxes to use\n\t\t//also build a map that we can use to add/remove from\n\t\tfor(CategoryDefinition category: categories) {\n\t\t\t\t\t\t\n\t\t\tif(category.getDropHighest() != null && category.getDropHighest() > 0) {\n\t\t\t\tisDropHighest = true;\n\t\t\t}\n\t\t\tif(category.getDrop_lowest() != null && category.getDrop_lowest() > 0) {\n\t\t\t\tisDropLowest = true;\n\t\t\t}\n\t\t\tif(category.getKeepHighest() != null && category.getKeepHighest() > 0) {\n\t\t\t\tisKeepHighest = true;\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\t//category types\n\t\tRadioGroup<Integer> categoryType = new RadioGroup<>(\"categoryType\", new PropertyModel<Integer>(model, \"gradebookInformation.categoryType\"));\n\t\tcategoryType.add(new Radio<>(\"none\", new Model<>(1)));\n\t\tcategoryType.add(new Radio<>(\"categoriesOnly\", new Model<>(2)));\n\t\tcategoryType.add(new Radio<>(\"categoriesAndWeighting\", new Model<>(3)));\n\t\t\n\t\tcategoryType.setRequired(true);\n\t\tadd(categoryType);\n\t\t\t\t\n\t\t//enable drop highest\n        final AjaxCheckBox dropHighest = new AjaxCheckBox(\"dropHighest\", Model.of(isDropHighest)) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\tisDropHighest = this.getModelObject();\n\t\t\t\t\n\t\t\t\t//reset\n\t\t\t\tif(!isDropHighest) {\n\t\t\t\t\tfor(CategoryDefinition c: model.getObject().getGradebookInformation().getCategories()) {\n\t\t\t\t\t\tc.setDropHighest(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        dropHighest.setOutputMarkupId(true);\n        add(dropHighest);\n        \n        //enable drop lowest\n        final AjaxCheckBox dropLowest = new AjaxCheckBox(\"dropLowest\", Model.of(isDropLowest)) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\tisDropLowest = this.getModelObject();\n\t\t\t\t\n\t\t\t\t//reset\n\t\t\t\tif(!isDropLowest) {\n\t\t\t\t\tfor(CategoryDefinition c: model.getObject().getGradebookInformation().getCategories()) {\n\t\t\t\t\t\tc.setDrop_lowest(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        dropLowest.setOutputMarkupId(true);\n        add(dropLowest);\n        \n     \t//enable keep highest\n        final AjaxCheckBox keepHighest = new AjaxCheckBox(\"keepHighest\", Model.of(isKeepHighest)) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\tisKeepHighest = this.getModelObject();\n\t\t\t\t\n\t\t\t\t//reset\n\t\t\t\tif(!isKeepHighest) {\n\t\t\t\t\tfor(CategoryDefinition c: model.getObject().getGradebookInformation().getCategories()) {\n\t\t\t\t\t\tc.setKeepHighest(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        keepHighest.setOutputMarkupId(true);\n        add(keepHighest);\n                \n        //render rows of categories\n        categoriesWrap = new WebMarkupContainer(\"categoriesWrap\");\n\n\t\tfinal Label runningTotal = new Label(\"runningTotal\", FormatHelper.formatDoubleAsPercentage(calculateCategoryWeightTotal(categories) * 100));\n\t\trunningTotal.setOutputMarkupId(true);\n\t\tcategoriesWrap.add(runningTotal);\n\n    \tListView<CategoryDefinition> categoriesView = new ListView<CategoryDefinition>(\"categoriesView\", model.getObject().getGradebookInformation().getCategories()) {\n\n  \t\t\tprivate static final long serialVersionUID = 1L;\n\n  \t\t\t@Override\n  \t\t\tprotected void populateItem(final ListItem<CategoryDefinition> item) {\n  \t\t\t\t\n  \t\t\t\tCategoryDefinition category = item.getModelObject();\n  \t\t\t\t\n  \t\t\t\t//name\n  \t\t\t\tTextField<String> name = new TextField<String>(\"name\", new PropertyModel<String>(category, \"name\"));\n  \t\t\t\titem.add(name);\n  \t\t\t\t\n  \t\t\t\t//weight\n  \t\t\t\tTextField<Double> weight = new TextField<Double>(\"weight\", new PropertyModel<Double>(category, \"weight\"));\n\t\t\t\tweight.add(new OnChangeAjaxBehavior() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\t\t\tDouble newTotal = calculateCategoryWeightTotal(categories);\n\n\t\t\t\t\t\tif (newTotal.equals(new Double(1))) {\n\t\t\t\t\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-success\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-danger\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trunningTotal.setDefaultModel(Model.of(FormatHelper.formatDoubleAsPercentage(newTotal * 100)));\n\t\t\t\t\t\ttarget.add(runningTotal);\n\t\t\t\t\t}\n\t\t\t\t});\n  \t\t\t\titem.add(weight);\n  \t\t\t\t\n  \t\t\t\t//num assignments\n  \t\t\t\tLabel numItems = new Label(\"numItems\", new StringResourceModel(\"settingspage.categories.items\", null, new Object[] {category.getAssignmentList().size()}));\n  \t\t\t\titem.add(numItems);\n  \t\t\t\t\n  \t\t\t\t//extra credit\n  \t\t        final CheckBox extraCredit = new CheckBox(\"extraCredit\", new PropertyModel<Boolean>(category, \"extraCredit\"));\n  \t\t        extraCredit.setOutputMarkupId(true);\n  \t\t        item.add(extraCredit);\n  \t\t\t\t\n  \t\t\t\t//drop highest\n  \t\t\t\tfinal TextField<Integer> categoryDropHighest = new TextField<Integer>(\"categoryDropHighest\", new PropertyModel<Integer>(category, \"dropHighest\"));\n  \t\t        categoryDropHighest.setOutputMarkupId(true);\n  \t\t        if(!isDropHighest) {\n  \t\t        \tcategoryDropHighest.setEnabled(false);\n  \t\t        }\n  \t\t        item.add(categoryDropHighest);\n  \t\t        \n  \t\t        //drop lowest\n  \t\t\t\tfinal TextField<Integer> categoryDropLowest = new TextField<Integer>(\"categoryDropLowest\", new PropertyModel<Integer>(category, \"drop_lowest\"));\n  \t\t        categoryDropLowest.setOutputMarkupId(true);\n  \t\t        if(!isDropLowest) {\n  \t\t        \tcategoryDropLowest.setEnabled(false);\n\t\t        }\n  \t\t        item.add(categoryDropLowest);\n  \t\t        \n  \t\t     \t//keep highest\n  \t\t\t\tfinal TextField<Integer> categoryKeepHighest = new TextField<Integer>(\"categoryKeepHighest\", new PropertyModel<Integer>(category, \"keepHighest\"));\n  \t\t        categoryKeepHighest.setOutputMarkupId(true);\n  \t\t        if(!isKeepHighest) {\n  \t\t        \tcategoryKeepHighest.setEnabled(false);\n\t\t        }\n  \t\t        item.add(categoryKeepHighest);\n  \t\t\t\t\n  \t\t\t\t//remove button\n\t\t\t\tAjaxButton remove = new AjaxButton(\"remove\") {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onSubmit(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//remove this category from the model\n\t\t\t\t\t\tCategoryDefinition current = item.getModelObject();\n\t\t\t\t\t\t\n\t\t\t\t\t\tmodel.getObject().getGradebookInformation().getCategories().remove(current);\n\t\t\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tremove.setDefaultFormProcessing(false);\n\t\t\t\titem.add(remove);\n  \t\t\t}\n  \t\t};\n  \t\t//categoriesView.setReuseItems(true);\n  \t\tcategoriesWrap.add(categoriesView);\n  \t\tcategoriesWrap.setOutputMarkupId(true);\n  \t\tadd(categoriesWrap);\n  \t\t\n        \n        //add category button\n        AjaxButton addCategory = new AjaxButton(\"addCategory\") {\n\t\t\tprivate static final long serialVersionUID = 1L;\n        \t\n\t\t\t@Override\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form<?> f) {\n\t\t\t\t\n\t\t\t\t//add a new category to the model\n\t\t\t\tCategoryDefinition cd = new CategoryDefinition();\n\t\t\t\tcd.setAssignmentList(Collections.<Assignment> emptyList());\n\t\t\t\t\n\t\t\t\tmodel.getObject().getGradebookInformation().getCategories().add(cd);\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        addCategory.setDefaultFormProcessing(false);\n        add(addCategory);\n\t\t\n\t}","id":74787,"modified_method":"@Override\n\tpublic void onInitialize() {\n\t\tsuper.onInitialize();\n\t\t\n\t\t//get categories, passed in\n\t\tfinal List<CategoryDefinition> categories = this.model.getObject().getGradebookInformation().getCategories();\n\t\t\t\t\n\t\t//parse the categories and see if we have any drophighest/lowest/keep highest and set the flags for the checkboxes to use\n\t\t//also build a map that we can use to add/remove from\n\t\tfor(CategoryDefinition category: categories) {\n\t\t\t\t\t\t\n\t\t\tif(category.getDropHighest() != null && category.getDropHighest() > 0) {\n\t\t\t\tisDropHighest = true;\n\t\t\t}\n\t\t\tif(category.getDrop_lowest() != null && category.getDrop_lowest() > 0) {\n\t\t\t\tisDropLowest = true;\n\t\t\t}\n\t\t\tif(category.getKeepHighest() != null && category.getKeepHighest() > 0) {\n\t\t\t\tisKeepHighest = true;\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\t//category types\n\t\tRadioGroup<Integer> categoryType = new RadioGroup<>(\"categoryType\", new PropertyModel<Integer>(model, \"gradebookInformation.categoryType\"));\n\t\tcategoryType.add(new Radio<>(\"none\", new Model<>(1)));\n\t\tcategoryType.add(new Radio<>(\"categoriesOnly\", new Model<>(2)));\n\t\tcategoryType.add(new Radio<>(\"categoriesAndWeighting\", new Model<>(3)));\n\t\t\n\t\tcategoryType.setRequired(true);\n\t\tadd(categoryType);\n\t\t\t\t\n\t\t//enable drop highest\n        final AjaxCheckBox dropHighest = new AjaxCheckBox(\"dropHighest\", Model.of(isDropHighest)) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\tisDropHighest = this.getModelObject();\n\t\t\t\t\n\t\t\t\t//reset\n\t\t\t\tif(!isDropHighest) {\n\t\t\t\t\tfor(CategoryDefinition c: model.getObject().getGradebookInformation().getCategories()) {\n\t\t\t\t\t\tc.setDropHighest(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        dropHighest.setOutputMarkupId(true);\n        add(dropHighest);\n        \n        //enable drop lowest\n        final AjaxCheckBox dropLowest = new AjaxCheckBox(\"dropLowest\", Model.of(isDropLowest)) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\tisDropLowest = this.getModelObject();\n\t\t\t\t\n\t\t\t\t//reset\n\t\t\t\tif(!isDropLowest) {\n\t\t\t\t\tfor(CategoryDefinition c: model.getObject().getGradebookInformation().getCategories()) {\n\t\t\t\t\t\tc.setDrop_lowest(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        dropLowest.setOutputMarkupId(true);\n        add(dropLowest);\n        \n     \t//enable keep highest\n        final AjaxCheckBox keepHighest = new AjaxCheckBox(\"keepHighest\", Model.of(isKeepHighest)) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\tisKeepHighest = this.getModelObject();\n\t\t\t\t\n\t\t\t\t//reset\n\t\t\t\tif(!isKeepHighest) {\n\t\t\t\t\tfor(CategoryDefinition c: model.getObject().getGradebookInformation().getCategories()) {\n\t\t\t\t\t\tc.setKeepHighest(0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        keepHighest.setOutputMarkupId(true);\n        add(keepHighest);\n                \n        //render rows of categories\n        categoriesWrap = new WebMarkupContainer(\"categoriesWrap\");\n\n\t\tfinal Label runningTotal = new Label(\"runningTotal\", FormatHelper.formatDoubleAsPercentage(calculateCategoryWeightTotal(categories) * 100));\n\t\trunningTotal.setOutputMarkupId(true);\n\t\tcategoriesWrap.add(runningTotal);\n\n    \tListView<CategoryDefinition> categoriesView = new ListView<CategoryDefinition>(\"categoriesView\", model.getObject().getGradebookInformation().getCategories()) {\n\n  \t\t\tprivate static final long serialVersionUID = 1L;\n\n  \t\t\t@Override\n  \t\t\tprotected void populateItem(final ListItem<CategoryDefinition> item) {\n  \t\t\t\t\n  \t\t\t\tCategoryDefinition category = item.getModelObject();\n  \t\t\t\t\n  \t\t\t\t//name\n  \t\t\t\tTextField<String> name = new TextField<String>(\"name\", new PropertyModel<String>(category, \"name\"));\n  \t\t\t\titem.add(name);\n  \t\t\t\t\n  \t\t\t\t//weight\n  \t\t\t\tTextField<Double> weight = new TextField<Double>(\"weight\", new PropertyModel<Double>(category, \"weight\"));\n\t\t\t\tweight.add(new OnChangeAjaxBehavior() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void onUpdate(AjaxRequestTarget target) {\n\t\t\t\t\t\tDouble newTotal = calculateCategoryWeightTotal(categories);\n\n\t\t\t\t\t\tif (newTotal.equals(new Double(1))) {\n\t\t\t\t\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-success\"));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trunningTotal.add(new AttributeModifier(\"class\", \"text-danger\"));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\trunningTotal.setDefaultModel(Model.of(FormatHelper.formatDoubleAsPercentage(newTotal * 100)));\n\t\t\t\t\t\ttarget.add(runningTotal);\n\t\t\t\t\t}\n\t\t\t\t});\n  \t\t\t\titem.add(weight);\n  \t\t\t\t\n  \t\t\t\t//num assignments\n  \t\t\t\tLabel numItems = new Label(\"numItems\", new StringResourceModel(\"settingspage.categories.items\", null, new Object[] {category.getAssignmentList().size()}));\n  \t\t\t\titem.add(numItems);\n  \t\t\t\t\n  \t\t\t\t//extra credit\n  \t\t        final CheckBox extraCredit = new CheckBox(\"extraCredit\", new PropertyModel<Boolean>(category, \"extraCredit\"));\n  \t\t        extraCredit.setOutputMarkupId(true);\n  \t\t        item.add(extraCredit);\n  \t\t\t\t\n  \t\t\t\t//drop highest\n  \t\t\t\tfinal TextField<Integer> categoryDropHighest = new TextField<Integer>(\"categoryDropHighest\", new PropertyModel<Integer>(category, \"dropHighest\"));\n  \t\t        categoryDropHighest.setOutputMarkupId(true);\n  \t\t        if(!isDropHighest) {\n  \t\t        \tcategoryDropHighest.setEnabled(false);\n  \t\t        }\n  \t\t        item.add(categoryDropHighest);\n  \t\t        \n  \t\t        //drop lowest\n  \t\t\t\tfinal TextField<Integer> categoryDropLowest = new TextField<Integer>(\"categoryDropLowest\", new PropertyModel<Integer>(category, \"drop_lowest\"));\n  \t\t        categoryDropLowest.setOutputMarkupId(true);\n  \t\t        if(!isDropLowest) {\n  \t\t        \tcategoryDropLowest.setEnabled(false);\n\t\t        }\n  \t\t        item.add(categoryDropLowest);\n  \t\t        \n  \t\t     \t//keep highest\n  \t\t\t\tfinal TextField<Integer> categoryKeepHighest = new TextField<Integer>(\"categoryKeepHighest\", new PropertyModel<Integer>(category, \"keepHighest\"));\n  \t\t        categoryKeepHighest.setOutputMarkupId(true);\n  \t\t        if(!isKeepHighest) {\n  \t\t        \tcategoryKeepHighest.setEnabled(false);\n\t\t        }\n  \t\t        item.add(categoryKeepHighest);\n  \t\t\t\t\n  \t\t\t\t//remove button\n\t\t\t\tAjaxButton remove = new AjaxButton(\"remove\") {\n\t\t\t\t\tprivate static final long serialVersionUID = 1L;\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onSubmit(AjaxRequestTarget target, Form<?> form) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t//remove this category from the model\n\t\t\t\t\t\tCategoryDefinition current = item.getModelObject();\n\t\t\t\t\t\t\n\t\t\t\t\t\tmodel.getObject().getGradebookInformation().getCategories().remove(current);\n\t\t\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tremove.setDefaultFormProcessing(false);\n\t\t\t\titem.add(remove);\n  \t\t\t}\n  \t\t};\n  \t\tcategoriesView.setReuseItems(true);\n  \t\tcategoriesWrap.add(categoriesView);\n  \t\tcategoriesWrap.setOutputMarkupId(true);\n  \t\tadd(categoriesWrap);\n  \t\t\n        \n        //add category button\n        AjaxButton addCategory = new AjaxButton(\"addCategory\") {\n\t\t\tprivate static final long serialVersionUID = 1L;\n        \t\n\t\t\t@Override\n\t\t\tprotected void onSubmit(AjaxRequestTarget target, Form<?> f) {\n\t\t\t\t\n\t\t\t\t//add a new empty category to the model\n\t\t\t\tCategoryDefinition cd = new CategoryDefinition();\n\t\t\t\tcd.setExtraCredit(false);\n\t\t\t\tcd.setAssignmentList(Collections.<Assignment> emptyList());\n\t\t\t\t\n\t\t\t\tmodel.getObject().getGradebookInformation().getCategories().add(cd);\n\t\t\t\t\n\t\t\t\ttarget.add(categoriesWrap);\n\t\t\t}\n        };\n        addCategory.setDefaultFormProcessing(false);\n        add(addCategory);\n\t\t\n\t}","commit_id":"74d52326fc9e92885c405babbdb8961ebef4d7a2","url":"https://github.com/sakaiproject/sakai"},{"original_method":"public int compareTo(final WeighingComparable<T,Loc> comparable) {\n    assert myWeighers == comparable.myWeighers;\n\n    for (int i = 0; i < myComputedWeighs.length; i++) {\n      final int result = getWeight(i).compareTo(comparable.getWeight(i));\n      if (result != 0) return result;\n    }\n    return 0;\n  }","id":74788,"modified_method":"public int compareTo(final WeighingComparable<T,Loc> comparable) {\n    assert myWeighers == comparable.myWeighers;\n\n    for (int i = 0; i < myComputedWeighs.length; i++) {\n      final Comparable weight1 = getWeight(i);\n      final Comparable weight2 = comparable.getWeight(i);\n      if (weight1 == null ^ weight2 == null) {\n        return weight1 == null ? -1 : 1;\n      }\n\n      if (weight1 != null) {\n        final int result = weight1.compareTo(weight2);\n        if (result != 0) return result;\n      }\n    }\n    return 0;\n  }","commit_id":"fb2fa1f044427398e03ba930df4974b7e4ec4db4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  private Comparable getWeight(final int index) {\n    Comparable weight = myComputedWeighs[index];\n    if (weight == null) {\n      weight = myWeighers[index].weigh(myElement, myLocation);\n      if (weight == null) weight = 0;\n      myComputedWeighs[index] = weight;\n    }\n    return weight;\n  }","id":74789,"modified_method":"@Nullable\n  private Comparable getWeight(final int index) {\n    Comparable weight = myComputedWeighs[index];\n    if (weight == null) {\n      weight = myWeighers[index].weigh(myElement, myLocation);\n      if (weight == null) weight = NULL;\n      myComputedWeighs[index] = weight;\n    }\n    return weight;\n  }","commit_id":"fb2fa1f044427398e03ba930df4974b7e4ec4db4","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n\t * submit the form. note that submit() can be executed only once.\n\t */\n\tpublic void submit()\n\t{\n\t\tcheckClosed();\n\t\ttry\n\t\t{\n\t\t\twicketTester.getServletRequest().setRequestToComponent(workingForm);\n\t\t\twicketTester.processRequestCycle();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tclosed = true;\n\t\t}\n\t}","id":74790,"modified_method":"/**\n\t * submit the form. note that submit() can be executed only once.\n\t */\n\tpublic void submit()\n\t{\n\t\tcheckClosed();\n\t\ttry\n\t\t{\n\t\t\tMockHttpServletRequest servletRequest = wicketTester.getServletRequest();\n\t\t\tWebRequestCycle requestCycle = wicketTester.createRequestCycle();\n\t\t\tservletRequest.setRequestToComponent(workingForm);\n\n\t\t\tif (servletRequest.hasUploadedFiles())\n\t\t\t{\n\t\t\t\trequestCycle.setRequest(new MultipartServletWebRequest(servletRequest, workingForm\n\t\t\t\t\t\t.getMaxSize()));\n\t\t\t}\n\n\t\t\twicketTester.processRequestCycle(requestCycle);\n\t\t}\n\t\tcatch (FileUploadException e)\n\t\t{\n\t\t\tthrow new IllegalStateException(e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tclosed = true;\n\t\t}\n\t}","commit_id":"fa3c5996b5a798fa3851de3a3ade883e43d28687","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * Test direct access (with wicket parameters) to a mounted page that should\n\t * NOT be allowed due to the {@link ISecuritySettings#getEnforceMounts()}\n\t * setting being set to true.\n\t */\n\tpublic void testDirectAccessToMountedPageNotAllowed()\n\t{\n\t\ttester.getApplication().getSecuritySettings().setEnforceMounts(true);\n\n\t\ttester.setupRequestAndResponse();\n\t\ttester.getServletRequest().setURL(\n\t\t\t\t\"?wicket:bookmarkablePage=:\" + TestPage.class.getName() + \"\");\n\t\ttry\n\t\t{\n\t\t\ttester.processRequestCycle();\n\t\t\tfail(\"This request should not have been allowed\");\n\t\t}\n\t\tcatch (AbortWithWebErrorCodeException e)\n\t\t{\n\t\t\tassertEquals(e.getErrorCode(), HttpServletResponse.SC_FORBIDDEN);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttester.getApplication().getSecuritySettings().setEnforceMounts(false);\n\t\t}\n\t}","id":74791,"modified_method":"/**\n\t * Test direct access (with wicket parameters) to a mounted page that should\n\t * NOT be allowed due to the {@link ISecuritySettings#getEnforceMounts()}\n\t * setting being set to true.\n\t */\n\tpublic void testDirectAccessToMountedPageNotAllowed()\n\t{\n\t\ttester.getApplication().getSecuritySettings().setEnforceMounts(true);\n\n\t\ttester.setupRequestAndResponse();\n\t\ttester.getServletRequest().setURL(\n\t\t\t\t\"?wicket:bookmarkablePage=:\" + TestPage.class.getName() + \"\");\n\t\ttry\n\t\t{\n\t\t\tWebRequestCycle requestCycle = tester.createRequestCycle();\n\t\t\ttester.processRequestCycle(requestCycle);\n\t\t\tIRequestTarget requestTarget = requestCycle.getRequestTarget();\n\t\t\tassertTrue(requestTarget instanceof WebErrorCodeResponseTarget);\n\t\t\tWebErrorCodeResponseTarget error = (WebErrorCodeResponseTarget)requestTarget;\n\t\t\tassertEquals(HttpServletResponse.SC_FORBIDDEN, error.getErrorCode());\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\ttester.getApplication().getSecuritySettings().setEnforceMounts(false);\n\t\t}\n\t}","commit_id":"2f3eeed18ea8c5082e08a4ae85d89b4168602ccf","url":"https://github.com/apache/wicket"},{"original_method":"/**\n\t * submit the form. note that submit() can be executed only once.\n\t */\n\tpublic void submit()\n\t{\n\t\tcheckClosed();\n\t\ttry\n\t\t{\n\t\t\twicketTester.getServletRequest().setRequestToComponent(workingForm);\n\t\t\twicketTester.processRequestCycle();\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tclosed = true;\n\t\t}\n\t}","id":74792,"modified_method":"/**\n\t * submit the form. note that submit() can be executed only once.\n\t */\n\tpublic void submit()\n\t{\n\t\tcheckClosed();\n\t\ttry\n\t\t{\n\t\t\tMockHttpServletRequest servletRequest = wicketTester.getServletRequest();\n\t\t\tWebRequestCycle requestCycle = wicketTester.createRequestCycle();\n\t\t\tservletRequest.setRequestToComponent(workingForm);\n\n\t\t\tif (servletRequest.hasUploadedFiles())\n\t\t\t{\n\t\t\t\trequestCycle.setRequest(new MultipartServletWebRequest(servletRequest, workingForm\n\t\t\t\t\t\t.getMaxSize()));\n\t\t\t}\n\n\t\t\twicketTester.processRequestCycle(requestCycle);\n\t\t}\n\t\tcatch (FileUploadException e)\n\t\t{\n\t\t\tthrow new WicketRuntimeException(e);\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tclosed = true;\n\t\t}\n\t}","commit_id":"69e15a2809ad15448df79a60721b23020f29da05","url":"https://github.com/apache/wicket"},{"original_method":"@Override\n\t@UiThread\n\tpublic void newDownloadIndexes() {\n\t\tvisibleBanner.updateBannerInProgress();\n\t\tfor (WeakReference<Fragment> ref : fragSet) {\n\t\t\tFragment f = ref.get();\n\t\t\tif (f.isAdded()) {\n\t\t\t\tif(f instanceof DownloadEvents) {\n\t\t\t\t\t((DownloadEvents) f).newDownloadIndexes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdownloadHasFinished();\n\t}","id":74793,"modified_method":"@Override\n\t@UiThread\n\tpublic void newDownloadIndexes() {\n\t\tvisibleBanner.updateBannerInProgress();\n\t\tfor (WeakReference<Fragment> ref : fragSet) {\n\t\t\tFragment f = ref.get();\n\t\t\tif (f instanceof DownloadEvents && f.isAdded()) {\n\t\t\t\t((DownloadEvents) f).newDownloadIndexes();\n\t\t\t}\n\t\t}\n\t\tdownloadHasFinished();\n\t}","commit_id":"c47083dc91aedfffff184cc25192552592f1cbcf","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t@UiThread\n\tpublic void downloadInProgress() {\n\t\tvisibleBanner.updateBannerInProgress();\n\t\tfor (WeakReference<Fragment> ref : fragSet) {\n\t\t\tFragment f = ref.get();\n\t\t\tif (f.isAdded()) {\n\t\t\t\tif(f instanceof DownloadEvents) {\n\t\t\t\t\t((DownloadEvents) f).downloadInProgress();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":74794,"modified_method":"@Override\n\t@UiThread\n\tpublic void downloadInProgress() {\n\t\tvisibleBanner.updateBannerInProgress();\n\t\tfor (WeakReference<Fragment> ref : fragSet) {\n\t\t\tFragment f = ref.get();\n\t\t\tif (f instanceof DownloadEvents && f.isAdded()) {\n\t\t\t\t((DownloadEvents) f).downloadInProgress();\n\t\t\t}\n\t\t}\n\t}","commit_id":"c47083dc91aedfffff184cc25192552592f1cbcf","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\n\t@UiThread\n\tpublic void downloadHasFinished() {\n\t\tvisibleBanner.updateBannerInProgress();\n\t\tfor (WeakReference<Fragment> ref : fragSet) {\n\t\t\tFragment f = ref.get();\n\t\t\tif (f.isAdded()) {\n\t\t\t\tif(f instanceof DownloadEvents) {\n\t\t\t\t\t((DownloadEvents) f).downloadHasFinished();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":74795,"modified_method":"@Override\n\t@UiThread\n\tpublic void downloadHasFinished() {\n\t\tvisibleBanner.updateBannerInProgress();\n\t\tfor (WeakReference<Fragment> ref : fragSet) {\n\t\t\tFragment f = ref.get();\n\t\t\tif (f instanceof DownloadEvents && f.isAdded()) {\n\t\t\t\t((DownloadEvents) f).downloadHasFinished();\n\t\t\t}\n\t\t}\n\t}","commit_id":"c47083dc91aedfffff184cc25192552592f1cbcf","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void preloadBuildings(Street str){\r\n\t\t// TODO\r\n\t}","id":74796,"modified_method":"public void preloadBuildings(Street street){\r\n\t\tif (street.getBuildings().isEmpty()) {\r\n\t\t\tCursor query = db.query(IndexBuildingTable.getTable(), IndexConstants.generateColumnNames(IndexBuildingTable.values()), \"? = street\",\r\n\t\t\t\t\tnew String[] { street.getId() + \"\" }, null, null, null);\r\n\t\t\tlog.debug(\"Start loading buildings for \"  + street.getName());\r\n\t\t\tif (query.moveToFirst()) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tBuilding building = new Building();\r\n\t\t\t\t\tbuilding.setId(query.getLong(IndexBuildingTable.ID.ordinal()));\r\n\t\t\t\t\tbuilding.setLocation(query.getDouble(IndexBuildingTable.LATITUDE.ordinal()), query.getDouble(IndexBuildingTable.LONGITUDE\r\n\t\t\t\t\t\t\t.ordinal()));\r\n\t\t\t\t\tbuilding.setName(query.getString(IndexBuildingTable.NAME.ordinal()));\r\n\t\t\t\t\tstreet.registerBuilding(building);\r\n\t\t\t\t} while (query.moveToNext());\r\n\t\t\t}\r\n\t\t\tquery.close();\r\n\t\t\tlog.debug(\"Loaded \" + street.getBuildings().size() + \" buildings\");\r\n\t\t}\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void fillWithSuggestedCities(String name, List<City> citiesToFill, List<City> source){\r\n\t\tpreloadCities();\r\n\t\tif(name.length() < 3){\r\n\t\t\tEnumSet<CityType> set = EnumSet.of(CityType.CITY, CityType.TOWN); \r\n\t\t\tfor(CityType t : set){\r\n\t\t\t\tif(name.length() == 0){\r\n\t\t\t\t\tcitiesToFill.addAll(cityTypes.get(t));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tname = name.toLowerCase();\r\n\t\t\t\t\tfor (City c : cityTypes.get(t)) {\r\n\t\t\t\t\t\tString lowerCase = c.getName().toLowerCase();\r\n\t\t\t\t\t\tif(lowerCase.startsWith(name)){\r\n\t\t\t\t\t\t\tcitiesToFill.add(c);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// essentially index is created that cities towns are first in cities map\r\n\t\t\tname = name.toLowerCase();\r\n\t\t\tint ind = 0;\r\n\t\t\tCollection<City> src = source == null ? cities.values() : source;\r\n\t\t\tfor (City c : src) {\r\n\t\t\t\tString lowerCase = c.getName().toLowerCase();\r\n\t\t\t\tif (lowerCase.startsWith(name)) {\r\n\t\t\t\t\tcitiesToFill.add(ind, c);\r\n\t\t\t\t\tind++;\r\n\t\t\t\t} else if (lowerCase.contains(name)) {\r\n\t\t\t\t\tcitiesToFill.add(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}","id":74797,"modified_method":"public void fillWithSuggestedCities(String name, List<City> citiesToFill){\r\n\t\tpreloadCities();\r\n\t\tif(name.length() < 3){\r\n\t\t\tEnumSet<CityType> set = EnumSet.of(CityType.CITY, CityType.TOWN); \r\n\t\t\tfor(CityType t : set){\r\n\t\t\t\tif(name.length() == 0){\r\n\t\t\t\t\tcitiesToFill.addAll(cityTypes.get(t));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tname = name.toLowerCase();\r\n\t\t\t\t\tfor (City c : cityTypes.get(t)) {\r\n\t\t\t\t\t\tString lowerCase = c.getName().toLowerCase();\r\n\t\t\t\t\t\tif(lowerCase.startsWith(name)){\r\n\t\t\t\t\t\t\tcitiesToFill.add(c);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\t// essentially index is created that cities towns are first in cities map\r\n\t\t\tint ind = 0;\r\n\t\t\tname = name.toLowerCase();\r\n\t\t\tCollection<City> src = cities.values();\r\n\t\t\tfor (City c : src) {\r\n\t\t\t\tString lowerCase = c.getName().toLowerCase();\r\n\t\t\t\tif (lowerCase.startsWith(name)) {\r\n\t\t\t\t\tcitiesToFill.add(ind, c);\r\n\t\t\t\t\tind++;\r\n\t\t\t\t} else if (lowerCase.contains(name)) {\r\n\t\t\t\t\tcitiesToFill.add(c);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tint initialsize = citiesToFill.size();\r\n\t\t\tlog.debug(\"Start loading cities for \" +getName() + \" filter \" + name);\r\n\t\t\t// lower function in SQLite requires ICU extension\r\n\t\t\tname = Algoritms.capitalizeFirstLetterAndLowercase(name);\r\n\t\t\tStringBuilder where = new StringBuilder(80);\r\n\t\t\twhere.\r\n\t\t\t\t  append(IndexCityTable.CITY_TYPE.toString()).append(\" not in (\").\r\n\t\t\t\t  append('\\'').append(CityType.valueToString(CityType.CITY)).append('\\'').append(\", \").\r\n\t\t\t\t  append('\\'').append(CityType.valueToString(CityType.TOWN)).append('\\'').append(\") and \").\r\n\t\t\t\t  append(IndexCityTable.NAME.toString()).append(\" LIKE '\"+name+\"%'\");\r\n\t\t\tCursor query = db.query(IndexCityTable.getTable(), IndexConstants.generateColumnNames(IndexCityTable.values()), \r\n\t\t\t\t\twhere.toString(), null, null, null, null);\r\n\t\t\tif (query.moveToFirst()) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tcitiesToFill.add(parseCityFromCursor(query));\r\n\t\t\t\t} while (query.moveToNext());\r\n\t\t\t}\r\n\t\t\tquery.close();\r\n\r\n\t\t\t\r\n\t\t\tlog.debug(\"Loaded citites \" + (citiesToFill.size() - initialsize));\r\n\t\t}\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void preloadCities(){\r\n\t\tif (cities.isEmpty()) {\r\n\t\t\tlog.debug(\"Start loading cities for \" +getName());\r\n\t\t\t// TODO allow cities of all types\r\n\t\t\tStringBuilder where = new StringBuilder();\r\n\t\t\twhere.append(IndexCityTable.CITY_TYPE.toString()).append('=').\r\n\t\t\t\t  append('\\'').append(CityType.valueToString(CityType.CITY)).append('\\'').append(\" or \").\r\n\t\t\t\t  append(IndexCityTable.CITY_TYPE.toString()).append('=').\r\n\t\t\t\t  append('\\'').append(CityType.valueToString(CityType.TOWN)).append('\\'');\r\n\t\t\tCursor query = db.query(IndexCityTable.getTable(), IndexConstants.generateColumnNames(IndexCityTable.values()), \r\n\t\t\t\t\twhere.toString(), null, null, null, null);\r\n\t\t\tif(query.moveToFirst()){\r\n\t\t\t\tdo {\r\n\t\t\t\t\tCityType type = CityType.valueFromString(query.getString(IndexCityTable.CITY_TYPE.ordinal()));\r\n\t\t\t\t\tif (type != null) {\r\n\t\t\t\t\t\tCity city = new City(type);\r\n\t\t\t\t\t\tcity.setId(query.getLong(IndexCityTable.ID.ordinal()));\r\n\t\t\t\t\t\tcity.setLocation(query.getDouble(IndexCityTable.LATITUDE.ordinal()), query.getDouble(IndexCityTable.LONGITUDE\r\n\t\t\t\t\t\t\t\t.ordinal()));\r\n\t\t\t\t\t\tcity.setName(query.getString(IndexCityTable.NAME.ordinal()));\r\n\t\t\t\t\t\tcities.put(city.getId(), city);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!cityTypes.containsKey(type)){\r\n\t\t\t\t\t\t\tcityTypes.put(type, new ArrayList<City>());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcityTypes.get(type).add(city);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} while(query.moveToNext());\r\n\t\t\t}\r\n\t\t\tlog.debug(\"Loaded \" + cities.size() + \" cities\");\r\n\t\t\tquery.close();\r\n\t\t}\r\n\t}","id":74798,"modified_method":"public void preloadCities(){\r\n\t\tif (cities.isEmpty()) {\r\n\t\t\tlog.debug(\"Start loading cities for \" +getName());\r\n\t\t\tStringBuilder where = new StringBuilder();\r\n\t\t\twhere.append(IndexCityTable.CITY_TYPE.toString()).append('=').\r\n\t\t\t\t  append('\\'').append(CityType.valueToString(CityType.CITY)).append('\\'').append(\" or \").\r\n\t\t\t\t  append(IndexCityTable.CITY_TYPE.toString()).append('=').\r\n\t\t\t\t  append('\\'').append(CityType.valueToString(CityType.TOWN)).append('\\'');\r\n\t\t\tCursor query = db.query(IndexCityTable.getTable(), IndexConstants.generateColumnNames(IndexCityTable.values()), \r\n\t\t\t\t\twhere.toString(), null, null, null, null);\r\n\t\t\tif(query.moveToFirst()){\r\n\t\t\t\tdo {\r\n\t\t\t\t\tCity city = parseCityFromCursor(query);\r\n\t\t\t\t\tif (city != null) {\r\n\t\t\t\t\t\tcities.put(city.getId(), city);\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif(!cityTypes.containsKey(city.getType())){\r\n\t\t\t\t\t\t\tcityTypes.put(city.getType(), new ArrayList<City>());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcityTypes.get(city.getType()).add(city);\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t} while(query.moveToNext());\r\n\t\t\t}\r\n\t\t\tlog.debug(\"Loaded \" + cities.size() + \" cities\");\r\n\t\t\tquery.close();\r\n\t\t}\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public void preloadStreets(City city){\r\n\t\tif (city.isEmptyWithStreets()) {\r\n\t\t\tCursor query = db.query(IndexStreetTable.getTable(), IndexConstants.generateColumnNames(IndexStreetTable.values()), \"? = city\",\r\n\t\t\t\t\tnew String[] { city.getId() + \"\" }, null, null, null);\r\n\t\t\tif (query.moveToFirst()) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tStreet street = new Street(city);\r\n\t\t\t\t\tstreet.setId(query.getLong(IndexStreetTable.ID.ordinal()));\r\n\t\t\t\t\tstreet.setLocation(query.getDouble(IndexStreetTable.LATITUDE.ordinal()), query.getDouble(IndexStreetTable.LONGITUDE\r\n\t\t\t\t\t\t\t.ordinal()));\r\n\t\t\t\t\tstreet.setName(query.getString(IndexStreetTable.NAME.ordinal()));\r\n\t\t\t\t\tcity.registerStreet(street);\r\n\t\t\t\t} while (query.moveToNext());\r\n\t\t\t}\r\n\t\t\tquery.close();\r\n\t\t}\r\n\t}","id":74799,"modified_method":"public void preloadStreets(City city){\r\n\t\tif (city.isEmptyWithStreets()) {\r\n\t\t\tlog.debug(\"Start loading streets for \"  + city.getName());\r\n\t\t\tCursor query = db.query(IndexStreetTable.getTable(), IndexConstants.generateColumnNames(IndexStreetTable.values()), \"? = city\",\r\n\t\t\t\t\tnew String[] { city.getId() + \"\" }, null, null, null);\r\n\t\t\tif (query.moveToFirst()) {\r\n\t\t\t\tdo {\r\n\t\t\t\t\tStreet street = new Street(city);\r\n\t\t\t\t\tstreet.setId(query.getLong(IndexStreetTable.ID.ordinal()));\r\n\t\t\t\t\tstreet.setLocation(query.getDouble(IndexStreetTable.LATITUDE.ordinal()), query.getDouble(IndexStreetTable.LONGITUDE\r\n\t\t\t\t\t\t\t.ordinal()));\r\n\t\t\t\t\tstreet.setName(query.getString(IndexStreetTable.NAME.ordinal()));\r\n\t\t\t\t\tcity.registerStreet(street);\r\n\t\t\t\t} while (query.moveToNext());\r\n\t\t\t}\r\n\t\t\tquery.close();\r\n\t\t\tlog.debug(\"Loaded \" + city.getStreets().size() + \" streets\");\r\n\t\t}\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tprotected void onResume() {\r\n\t\tsuper.onResume();\r\n\t\tregion = null;\r\n\t\tcity = null;\r\n\t\tstreet = null;\r\n\t\tbuilding = null;\r\n\t\tString lastSearchedRegion = OsmandSettings.getLastSearchedRegion(this);\r\n\t\tregion = ResourceManager.getResourceManager().getRegionRepository(lastSearchedRegion);\r\n\t\tif(region != null){\r\n\t\t\tcity = region.getCityById(OsmandSettings.getLastSearchedCity(this));\r\n\t\t\tif(city != null){\r\n\t\t\t\tstreet = region.getStreetByName(city, OsmandSettings.getLastSearchedStreet(this));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tupdateUI();\r\n\t}","id":74800,"modified_method":"@Override\r\n\tprotected void onResume() {\r\n\t\tsuper.onResume();\r\n\t\tregion = null;\r\n\t\tcity = null;\r\n\t\tstreet = null;\r\n\t\tbuilding = null;\r\n\t\tString lastSearchedRegion = OsmandSettings.getLastSearchedRegion(this);\r\n\t\tregion = ResourceManager.getResourceManager().getRegionRepository(lastSearchedRegion);\r\n\t\tif(region != null){\r\n\t\t\tcity = region.getCityById(OsmandSettings.getLastSearchedCity(this));\r\n\t\t\tif(city != null){\r\n\t\t\t\tstreet = region.getStreetByName(city, OsmandSettings.getLastSearchedStreet(this));\r\n\t\t\t\tif(street != null){\r\n\t\t\t\t\tbuilding = region.getBuildingByName(street, OsmandSettings.getLastSearchedBuilding(this));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tupdateUI();\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"private void attachListeners() {\r\n\t\tcountryButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchRegionByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tcityButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchCityByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tstreetButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchStreetByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tbuildingButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchBuildingByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tfindViewById(R.id.ResetBuilding).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tbuilding = null;\r\n\t\t\t\tupdateUI();\r\n\t\t\t}\r\n\t\t });\r\n\t\t findViewById(R.id.ResetStreet).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(View v) {\r\n\t\t\t\t\tstreet = null;\r\n\t\t\t\t\tbuilding = null;\r\n\t\t\t\t\tupdateUI();\r\n\t\t\t\t}\r\n\t\t });\r\n\t\t findViewById(R.id.ResetCity).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(View v) {\r\n\t\t\t\t\tcity = null;\r\n\t\t\t\t\tstreet = null;\r\n\t\t\t\t\tbuilding = null;\r\n\t\t\t\t\tupdateUI();\r\n\t\t\t\t}\r\n\t\t });\r\n\t\t findViewById(R.id.ResetCountry).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(View v) {\r\n\t\t\t\t\tregion = null;\r\n\t\t\t\t\tcity = null;\r\n\t\t\t\t\tstreet = null;\r\n\t\t\t\t\tbuilding = null;\r\n\t\t\t\t\tupdateUI();\r\n\t\t\t\t}\r\n\t\t });\r\n\t\t\r\n\t}","id":74801,"modified_method":"private void attachListeners() {\r\n\t\tcountryButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchRegionByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tcityButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchCityByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tstreetButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchStreetByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tbuildingButton.setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, SearchBuildingByNameActivity.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\tshowOnMap.setOnClickListener(new View.OnClickListener() {\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tLatLon l = null;\r\n\t\t\t\tint zoom = 12;\r\n\t\t\t\tif (building != null) {\r\n\t\t\t\t\tl = building.getLocation();\r\n\t\t\t\t\tzoom = 16;\r\n\t\t\t\t} else if (street != null) {\r\n\t\t\t\t\tl = street.getLocation();\r\n\t\t\t\t\tzoom = 14;\r\n\t\t\t\t} else if (city != null) {\r\n\t\t\t\t\tl = city.getLocation();\r\n\t\t\t\t\tzoom = 12;\r\n\t\t\t\t}\r\n\t\t\t\tif (l != null) {\r\n\t\t\t\t\tOsmandSettings.setLastKnownMapLocation(SearchAddressActivity.this, l.getLatitude(), l.getLongitude());\r\n\t\t\t\t\tOsmandSettings.setLastKnownMapZoom(SearchAddressActivity.this, zoom);\r\n\t\t\t\t\tstartActivity(new Intent(SearchAddressActivity.this, MapActivity.class));\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t});\r\n\t\tfindViewById(R.id.ResetBuilding).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tbuilding = null;\r\n\t\t\t\tupdateUI();\r\n\t\t\t}\r\n\t\t });\r\n\t\t findViewById(R.id.ResetStreet).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(View v) {\r\n\t\t\t\t\tstreet = null;\r\n\t\t\t\t\tbuilding = null;\r\n\t\t\t\t\tupdateUI();\r\n\t\t\t\t}\r\n\t\t });\r\n\t\t findViewById(R.id.ResetCity).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(View v) {\r\n\t\t\t\t\tcity = null;\r\n\t\t\t\t\tstreet = null;\r\n\t\t\t\t\tbuilding = null;\r\n\t\t\t\t\tupdateUI();\r\n\t\t\t\t}\r\n\t\t });\r\n\t\t findViewById(R.id.ResetCountry).setOnClickListener(new View.OnClickListener(){\r\n\t\t\t\t@Override\r\n\t\t\t\tpublic void onClick(View v) {\r\n\t\t\t\t\tregion = null;\r\n\t\t\t\t\tcity = null;\r\n\t\t\t\t\tstreet = null;\r\n\t\t\t\t\tbuilding = null;\r\n\t\t\t\t\tupdateUI();\r\n\t\t\t\t}\r\n\t\t });\r\n\t\t\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic void updateTextView(Street obj, TextView txt) {\r\n\t\ttxt.setText(obj.getName());\r\n\t}","id":74802,"modified_method":"@Override\r\n\tpublic List<Building> getObjects(String filter) {\r\n\t\tList<Building> l = new ArrayList<Building>();\r\n\t\tif(street != null){\r\n\t\t\tregion.fillWithSuggestedBuildings(street, filter, l);\r\n\t\t}\r\n\t\treturn l;\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tregion = ResourceManager.getResourceManager().getRegionRepository(OsmandSettings.getLastSearchedRegion(this));\r\n\t\tif(region != null){\r\n\t\t\tcity = region.getCityById(OsmandSettings.getLastSearchedCity(this));\r\n\t\t}\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t}","id":74803,"modified_method":"@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tregion = ResourceManager.getResourceManager().getRegionRepository(OsmandSettings.getLastSearchedRegion(this));\r\n\t\tif(region != null){\r\n\t\t\tcity = region.getCityById(OsmandSettings.getLastSearchedCity(this));\r\n\t\t\tif(city != null){\r\n\t\t\t\tstreet = region.getStreetByName(city, OsmandSettings.getLastSearchedStreet(this));\r\n\t\t\t}\r\n\t\t}\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\r\n\t\tsetContentView(R.layout.search_by_name);\r\n\t\tNamesAdapter namesAdapter = new NamesAdapter(getObjects());\r\n\t\tsetListAdapter(namesAdapter);\r\n\t}","id":74804,"modified_method":"@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t\trequestWindowFeature(Window.FEATURE_NO_TITLE);\r\n\t\tsetContentView(R.layout.search_by_name);\r\n\t\tNamesAdapter namesAdapter = new NamesAdapter(getObjects(\"\"));\r\n\t\tsetListAdapter(namesAdapter);\r\n\t\tsearchText = (EditText) findViewById(R.id.SearchText);\r\n\t\tsearchText.addTextChangedListener(new TextWatcher(){\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void afterTextChanged(Editable s) {\r\n\t\t\t\tsetText(s.toString());\r\n\t\t\t}\r\n\t\t\t@Override\r\n\t\t\tpublic void beforeTextChanged(CharSequence s, int start, int count, int after) {\r\n\t\t\t}\r\n\t\t\t@Override\r\n\t\t\tpublic void onTextChanged(CharSequence s, int start, int before, int count) {\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t\tfindViewById(R.id.ResetButton).setOnClickListener(new View.OnClickListener(){\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tsearchText.setText(\"\");\r\n\t\t\t}\r\n\t\t\t\r\n\t\t});\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public View getView(int position, View convertView, ViewGroup parent) {\r\n\t\t\tLayoutInflater inflater = getLayoutInflater();\r\n\t\t\tView row = inflater.inflate(R.layout.searchbyname_list, parent, false);\r\n\t\t\tTextView label = (TextView) row.findViewById(R.id.NameLabel);\r\n\t\t\tupdateTextView(getItem(position), label);\r\n\t\t\treturn row;\r\n\t\t}","id":74805,"modified_method":"public View getView(int position, View convertView, ViewGroup parent) {\r\n\t\t\tView row;\r\n\t\t\tif (convertView != null) {\r\n\t\t\t\trow = convertView;\r\n\t\t\t} else {\r\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\r\n\t\t\t\trow = inflater.inflate(R.layout.searchbyname_list, parent, false);\r\n\t\t\t}\r\n\t\t\tTextView label = (TextView) row.findViewById(R.id.NameLabel);\r\n\t\t\tupdateTextView(getItem(position), label);\r\n\t\t\treturn row;\r\n\t\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tregion = ResourceManager.getResourceManager().getRegionRepository(OsmandSettings.getLastSearchedRegion(this));\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t}","id":74806,"modified_method":"@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tregion = ResourceManager.getResourceManager().getRegionRepository(OsmandSettings.getLastSearchedRegion(this));\r\n\t\tlocation = OsmandSettings.getLastKnownMapLocation(this);\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic void updateTextView(City obj, TextView txt) {\r\n\t\ttxt.setText(obj.getName());\r\n\t}","id":74807,"modified_method":"@Override\r\n\tpublic void updateTextView(City obj, TextView txt) {\r\n\t\tif(getFilter().length() > 2){\r\n\t\t\ttxt.setText(obj.getName() + \" - \" + MapUtils.getFormattedDistance((int) MapUtils.getDistance(obj.getLocation(), location)));\r\n\t\t} else {\r\n\t\t\ttxt.setText(obj.getName());\r\n\t\t}\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic void itemSelected(City obj) {\r\n\t\tOsmandSettings.setLastSearchedCity(this, obj.getId());\r\n\t\tfinish();\r\n\t\t\r\n\t}","id":74808,"modified_method":"@Override\r\n\tpublic void itemSelected(City obj) {\r\n\t\tOsmandSettings.setLastSearchedCity(this, obj.getId());\r\n\t\tif(region.getCityById(obj.getId()) == null){\r\n\t\t\tregion.registerCity(obj);\r\n\t\t}\r\n\t\tfinish();\r\n\t\t\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic List<City> getObjects() {\r\n\t\tList<City> l = new ArrayList<City>();\r\n\t\tif(region != null){\r\n\t\t\tregion.fillWithSuggestedCities(\"\", l, null);\r\n\t\t}\r\n\t\treturn l;\r\n\t}","id":74809,"modified_method":"@Override\r\n\tpublic List<City> getObjects(String filter) {\r\n\t\tList<City> l = new ArrayList<City>();\r\n\t\tif(region != null){\r\n\t\t\tregion.fillWithSuggestedCities(filter, l);\r\n\t\t}\r\n\t\treturn l;\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"public View getView(int position, View convertView, ViewGroup parent) {\r\n\t\t\tLayoutInflater inflater = getLayoutInflater();\r\n\t\t\tView row = inflater.inflate(R.layout.searchpoi_list, parent, false);\r\n\t\t\tTextView label = (TextView) row.findViewById(R.id.poi_label);\r\n\t\t\tTextView distanceLabel = (TextView) row.findViewById(R.id.poidistance_label);\r\n\t\t\tImageView icon = (ImageView) row.findViewById(R.id.poi_icon);\r\n\t\t\tObject model = getModel(position);\r\n\t\t\tif (model instanceof Amenity) {\r\n\t\t\t\tAmenity anemity = (Amenity) model;\r\n\t\t\t\tif (anemity != null) {\r\n\t\t\t\t\tLatLon lastKnownMapLocation = OsmandSettings.getLastKnownMapLocation(SearchPOIActivity.this);\r\n\t\t\t\t\tint dist = (int) (MapUtils.getDistance(anemity.getLocation(), lastKnownMapLocation.getLatitude(), lastKnownMapLocation\r\n\t\t\t\t\t\t\t.getLongitude()));\r\n\t\t\t\t\tString str = anemity.getStringWithoutType();\r\n\t\t\t\t\tlabel.setText(str);\r\n\t\t\t\t\ticon.setImageResource(R.drawable.poi);\r\n\t\t\t\t\tdistanceLabel.setText(\" \" +dist + \" m  \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn (row);\r\n\t\t}","id":74810,"modified_method":"public View getView(int position, View convertView, ViewGroup parent) {\r\n\t\t\tView row = convertView;\r\n\t\t\tif (row == null) {\r\n\t\t\t\tLayoutInflater inflater = getLayoutInflater();\r\n\t\t\t\trow = inflater.inflate(R.layout.searchpoi_list, parent, false);\r\n\t\t\t}\r\n\t\t\tTextView label = (TextView) row.findViewById(R.id.poi_label);\r\n\t\t\tTextView distanceLabel = (TextView) row.findViewById(R.id.poidistance_label);\r\n\t\t\tImageView icon = (ImageView) row.findViewById(R.id.poi_icon);\r\n\t\t\tObject model = getModel(position);\r\n\t\t\tif (model instanceof Amenity) {\r\n\t\t\t\tAmenity anemity = (Amenity) model;\r\n\t\t\t\tif (anemity != null) {\r\n\t\t\t\t\tLatLon lastKnownMapLocation = OsmandSettings.getLastKnownMapLocation(SearchPOIActivity.this);\r\n\t\t\t\t\tint dist = (int) (MapUtils.getDistance(anemity.getLocation(), lastKnownMapLocation.getLatitude(), lastKnownMapLocation\r\n\t\t\t\t\t\t\t.getLongitude()));\r\n\t\t\t\t\tString str = anemity.getStringWithoutType();\r\n\t\t\t\t\tlabel.setText(str);\r\n\t\t\t\t\ticon.setImageResource(R.drawable.poi);\r\n\t\t\t\t\tdistanceLabel.setText(\" \" +dist + \" m  \");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn (row);\r\n\t\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic List<RegionAddressRepository> getObjects() {\r\n\t\treturn new ArrayList<RegionAddressRepository>(ResourceManager.getResourceManager().getAddressRepositories());\r\n\t}","id":74811,"modified_method":"@Override\r\n\tpublic List<RegionAddressRepository> getObjects(String filter) {\r\n\t\treturn new ArrayList<RegionAddressRepository>(ResourceManager.getResourceManager().getAddressRepositories());\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"@Override\r\n\tpublic List<Street> getObjects() {\r\n\t\tList<Street> l = new ArrayList<Street>();\r\n\t\tif(city != null){\r\n\t\t\tregion.fillWithSuggestedStreets(city, \"\", l);\r\n\t\t}\r\n\t\treturn l;\r\n\t}","id":74812,"modified_method":"@Override\r\n\tpublic List<Street> getObjects(String filter) {\r\n\t\tList<Street> l = new ArrayList<Street>();\r\n\t\tif(city != null){\r\n\t\t\tregion.fillWithSuggestedStreets(city, filter, l);\r\n\t\t}\r\n\t\treturn l;\r\n\t}","commit_id":"8c2ae5e8c2186eddaf3d6532c9a4c7c0093ad42a","url":"https://github.com/osmandapp/Osmand"},{"original_method":"/**\n   * Builds a Service instance for this component using the provided service\n   * configuration.\n   * \n   * @return Service instance of the service\n   * @throws ServiceRegistrationException\n   */\n  public CheckedListenableFuture<ServiceConfiguration> loadService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    this.lookupRegisteredService( config );\n    if ( State.PRIMORDIAL.equals( config.lookupState( ) ) || State.INITIALIZED.equals( config.lookupState( ) ) ) {\n      try {\n        return Automata.sequenceTransitions( config,\n                                      Component.State.PRIMORDIAL,\n                                      Component.State.INITIALIZED,\n                                      Component.State.LOADED ).call( );//.get( );\n      } catch ( Throwable ex ) {\n        throw Exceptions.debug( new ServiceRegistrationException( \"Failed to initialize service state: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n      }\n    }\n    if ( State.LOADED.isIn( config ) ) {\n      return Futures.predestinedFuture( config );\n    } else {\n      return Futures.predestinedFuture( config );\n    }\n  }","id":74813,"modified_method":"/**\n   * Builds a Service instance for this component using the provided service\n   * configuration.\n   * \n   * @return Service instance of the service\n   * @throws ServiceRegistrationException\n   */\n  public CheckedListenableFuture<ServiceConfiguration> loadService( final ServiceConfiguration config ) throws ServiceRegistrationException {\n    this.lookupRegisteredService( config );\n    if ( State.PRIMORDIAL.equals( config.lookupState( ) ) || State.INITIALIZED.equals( config.lookupState( ) ) ) {\n      try {\n        CheckedListenableFuture<ServiceConfiguration> ret = Automata.sequenceTransitions( config,\n                                      Component.State.PRIMORDIAL,\n                                      Component.State.INITIALIZED,\n                                      Component.State.LOADED ).call( );//.get( );\n        ret.get( );\n        return ret;\n      } catch ( Throwable ex ) {\n        throw Exceptions.debug( new ServiceRegistrationException( \"Failed to initialize service state: \" + config + \" because of: \" + ex.getMessage( ), ex ) );\n      }\n    }\n    if ( State.LOADED.isIn( config ) ) {\n      return Futures.predestinedFuture( config );\n    } else {\n      return Futures.predestinedFuture( config );\n    }\n  }","commit_id":"32965769427a0c4c264e4e2be6701035af416de7","url":"https://github.com/eucalyptus/eucalyptus"},{"original_method":"protected Result doRun(final BuildListener listener) throws Exception {\n            PrintStream logger = listener.getLogger();\n            try {\n                EnvVars envVars = getEnvironment(listener);\n                MavenInstallation mvn = project.getMaven();\n                if(mvn==null)\n                    throw new AbortException(\"A Maven installation needs to be available for this project to be built.\\n\"+\n                                             \"Either your server has no Maven installations defined, or the requested Maven version does not exist.\");\n                \n                mvn = mvn.forEnvironment(envVars).forNode(Computer.currentComputer().getNode(), listener);\n\n                if(!project.isAggregatorStyleBuild()) {\n                    parsePoms(listener, logger, envVars, mvn);\n                    // start module builds\n                    logger.println(\"Triggering \"+project.getRootModule().getModuleName());\n                    project.getRootModule().scheduleBuild(new UpstreamCause((Run<?,?>)MavenModuleSetBuild.this));\n                } else {\n                    // do builds here\n                    try {\n                        List<BuildWrapper> wrappers = new ArrayList<BuildWrapper>();\n                        for (BuildWrapper w : project.getBuildWrappersList())\n                            wrappers.add(w);\n                        ParametersAction parameters = getAction(ParametersAction.class);\n                        if (parameters != null)\n                            parameters.createBuildWrappers(MavenModuleSetBuild.this,wrappers);\n\n                        for( BuildWrapper w : wrappers) {\n                            Environment e = w.setUp(MavenModuleSetBuild.this, launcher, listener);\n                            if(e==null)\n                                return Result.FAILURE;\n                            buildEnvironments.add(e);\n                            e.buildEnvVars(envVars); // #3502: too late for getEnvironment to do this\n                        }\n\n                        if(!preBuild(listener, project.getPublishers()))\n                            return Result.FAILURE;\n\n                        parsePoms(listener, logger, envVars, mvn); // #5428 : do pre-build *before* parsing pom\n                        SplittableBuildListener slistener = new SplittableBuildListener(listener);\n                        proxies = new HashMap<ModuleName, ProxyImpl2>();\n                        List<String> changedModules = new ArrayList<String>();\n\n                        for (MavenModule m : project.sortedActiveModules) {\n                            MavenBuild mb = m.newBuild();\n                            \n                            // Check if incrementalBuild is selected and that there are changes -\n                            // we act as if incrementalBuild is not set if there are no changes.\n                            if (!MavenModuleSetBuild.this.getChangeSet().isEmptySet()\n                                && project.isIncrementalBuild()) {\n\t\t\t\t// If there are changes for this module, add it.\n\t\t\t\t// Also add it if we've never seen this module before,\n\t\t\t\t// or if the previous build of this module failed or was unstable.\n                                if ((mb.getPreviousBuiltBuild() == null) ||\n                                    (!getChangeSetFor(m).isEmpty()) \n                                    || (mb.getPreviousBuiltBuild().getResult().isWorseThan(Result.SUCCESS))) {\n                                    changedModules.add(m.getModuleName().toString());\n                                }\n                            }\n\n                            mb.setWorkspace(getModuleRoot().child(m.getRelativePath()));\n                            proxies.put(m.getModuleName(), mb.new ProxyImpl2(MavenModuleSetBuild.this,slistener));\n                        }\n\n                        // run the complete build here\n\n                        // figure out the root POM location.\n                        // choice of module root ('ws' in this method) is somewhat arbitrary\n                        // when multiple CVS/SVN modules are checked out, so also check\n                        // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                        String rootPOM = project.getRootPOM();\n                        FilePath pom = getModuleRoot().child(rootPOM);\n                        FilePath parentLoc = getWorkspace().child(rootPOM);\n                        if(!pom.exists() && parentLoc.exists())\n                            pom = parentLoc;\n\n                        ProcessCache.MavenProcess process = MavenBuild.mavenProcessCache.get(launcher.getChannel(), slistener,\n                            new MavenProcessFactory(project,launcher,envVars,pom.getParent()));\n\n                        ArgumentListBuilder margs = new ArgumentListBuilder().add(\"-B\").add(\"-f\", pom.getRemote());\n                        if(project.usesPrivateRepository())\n                            margs.add(\"-Dmaven.repo.local=\"+getWorkspace().child(\".repository\"));\n                        // If incrementalBuild is set, and we're on Maven 2.1 or later, *and* there's at least one module\n                        // listed in changedModules, do the Maven incremental build commands - if there are no changed modules,\n                        // We're building everything anyway.\n                        if (project.isIncrementalBuild() && mvn.isMaven2_1(launcher) && !changedModules.isEmpty()) {\n                            margs.add(\"-amd\");\n                            margs.add(\"-pl\", Util.join(changedModules, \",\"));\n                        }\n\n                        if (project.getAlternateSettings() != null) {\n                            if (IOUtils.isAbsolute(project.getAlternateSettings())) {\n                                margs.add(\"-s\").add(project.getAlternateSettings());\n                            } else {\n                                FilePath mrSettings = getModuleRoot().child(project.getAlternateSettings());\n                                FilePath wsSettings = getWorkspace().child(project.getAlternateSettings());\n                                if (!wsSettings.exists() && mrSettings.exists())\n                                    wsSettings = mrSettings;\n                                \n                                margs.add(\"-s\").add(wsSettings.getRemote());\n                            }\n                        }\n\n                        margs.addTokenized(envVars.expand(project.getGoals()));\n\n                        Builder builder = new Builder(slistener, proxies, project.sortedActiveModules, margs.toList(), envVars);\n                        MavenProbeAction mpa=null;\n                        try {\n                            mpa = new MavenProbeAction(project,process.channel);\n                            addAction(mpa);\n                            return process.call(builder);\n                        } finally {\n                            builder.end(launcher);\n                            getActions().remove(mpa);\n                            process.discard();\n                        }\n                    } finally {\n                        // tear down in reverse order\n                        boolean failed=false;\n                        for( int i=buildEnvironments.size()-1; i>=0; i-- ) {\n                            if (!buildEnvironments.get(i).tearDown(MavenModuleSetBuild.this,listener)) {\n                                failed=true;\n                            }                    \n                        }\n                        // WARNING The return in the finally clause will trump any return before\n                        if (failed) return Result.FAILURE;\n                    }\n                }\n                \n                return null;\n            } catch (AbortException e) {\n                if(e.getMessage()!=null)\n                    listener.error(e.getMessage());\n                return Result.FAILURE;\n            } catch (InterruptedIOException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedIOException\"));\n                return Result.ABORTED;\n            } catch (IOException e) {\n                e.printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                return Result.FAILURE;\n            } catch (RunnerAbortedException e) {\n                return Result.FAILURE;\n            } catch (RuntimeException e) {\n                // bug in the code.\n                e.printStackTrace(listener.error(\"Processing failed due to a bug in the code. Please report this to users@hudson.dev.java.net\"));\n                logger.println(\"project=\"+project);\n                logger.println(\"project.getModules()=\"+project.getModules());\n                logger.println(\"project.getRootModule()=\"+project.getRootModule());\n                throw e;\n            }\n        }","id":74814,"modified_method":"protected Result doRun(final BuildListener listener) throws Exception {\n            PrintStream logger = listener.getLogger();\n            Result r = null;\n            try {\n                EnvVars envVars = getEnvironment(listener);\n                MavenInstallation mvn = project.getMaven();\n                if(mvn==null)\n                    throw new AbortException(\"A Maven installation needs to be available for this project to be built.\\n\"+\n                                             \"Either your server has no Maven installations defined, or the requested Maven version does not exist.\");\n                \n                mvn = mvn.forEnvironment(envVars).forNode(Computer.currentComputer().getNode(), listener);\n\n                if(!project.isAggregatorStyleBuild()) {\n                    parsePoms(listener, logger, envVars, mvn);\n                    // start module builds\n                    logger.println(\"Triggering \"+project.getRootModule().getModuleName());\n                    project.getRootModule().scheduleBuild(new UpstreamCause((Run<?,?>)MavenModuleSetBuild.this));\n                } else {\n                    // do builds here\n                    try {\n                        List<BuildWrapper> wrappers = new ArrayList<BuildWrapper>();\n                        for (BuildWrapper w : project.getBuildWrappersList())\n                            wrappers.add(w);\n                        ParametersAction parameters = getAction(ParametersAction.class);\n                        if (parameters != null)\n                            parameters.createBuildWrappers(MavenModuleSetBuild.this,wrappers);\n\n                        for( BuildWrapper w : wrappers) {\n                            Environment e = w.setUp(MavenModuleSetBuild.this, launcher, listener);\n                            if(e==null)\n                                return (r = Result.FAILURE);\n                            buildEnvironments.add(e);\n                            e.buildEnvVars(envVars); // #3502: too late for getEnvironment to do this\n                        }\n\n                        if(!preBuild(listener, project.getPublishers()))\n                            return Result.FAILURE;\n\n                        parsePoms(listener, logger, envVars, mvn); // #5428 : do pre-build *before* parsing pom\n                        SplittableBuildListener slistener = new SplittableBuildListener(listener);\n                        proxies = new HashMap<ModuleName, ProxyImpl2>();\n                        List<String> changedModules = new ArrayList<String>();\n\n                        for (MavenModule m : project.sortedActiveModules) {\n                            MavenBuild mb = m.newBuild();\n                            \n                            // Check if incrementalBuild is selected and that there are changes -\n                            // we act as if incrementalBuild is not set if there are no changes.\n                            if (!MavenModuleSetBuild.this.getChangeSet().isEmptySet()\n                                && project.isIncrementalBuild()) {\n\t\t\t\t// If there are changes for this module, add it.\n\t\t\t\t// Also add it if we've never seen this module before,\n\t\t\t\t// or if the previous build of this module failed or was unstable.\n                                if ((mb.getPreviousBuiltBuild() == null) ||\n                                    (!getChangeSetFor(m).isEmpty()) \n                                    || (mb.getPreviousBuiltBuild().getResult().isWorseThan(Result.SUCCESS))) {\n                                    changedModules.add(m.getModuleName().toString());\n                                }\n                            }\n\n                            mb.setWorkspace(getModuleRoot().child(m.getRelativePath()));\n                            proxies.put(m.getModuleName(), mb.new ProxyImpl2(MavenModuleSetBuild.this,slistener));\n                        }\n\n                        // run the complete build here\n\n                        // figure out the root POM location.\n                        // choice of module root ('ws' in this method) is somewhat arbitrary\n                        // when multiple CVS/SVN modules are checked out, so also check\n                        // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                        String rootPOM = project.getRootPOM();\n                        FilePath pom = getModuleRoot().child(rootPOM);\n                        FilePath parentLoc = getWorkspace().child(rootPOM);\n                        if(!pom.exists() && parentLoc.exists())\n                            pom = parentLoc;\n\n                        ProcessCache.MavenProcess process = MavenBuild.mavenProcessCache.get(launcher.getChannel(), slistener,\n                            new MavenProcessFactory(project,launcher,envVars,pom.getParent()));\n\n                        ArgumentListBuilder margs = new ArgumentListBuilder().add(\"-B\").add(\"-f\", pom.getRemote());\n                        if(project.usesPrivateRepository())\n                            margs.add(\"-Dmaven.repo.local=\"+getWorkspace().child(\".repository\"));\n                        // If incrementalBuild is set, and we're on Maven 2.1 or later, *and* there's at least one module\n                        // listed in changedModules, do the Maven incremental build commands - if there are no changed modules,\n                        // We're building everything anyway.\n                        if (project.isIncrementalBuild() && mvn.isMaven2_1(launcher) && !changedModules.isEmpty()) {\n                            margs.add(\"-amd\");\n                            margs.add(\"-pl\", Util.join(changedModules, \",\"));\n                        }\n\n                        if (project.getAlternateSettings() != null) {\n                            if (IOUtils.isAbsolute(project.getAlternateSettings())) {\n                                margs.add(\"-s\").add(project.getAlternateSettings());\n                            } else {\n                                FilePath mrSettings = getModuleRoot().child(project.getAlternateSettings());\n                                FilePath wsSettings = getWorkspace().child(project.getAlternateSettings());\n                                if (!wsSettings.exists() && mrSettings.exists())\n                                    wsSettings = mrSettings;\n                                \n                                margs.add(\"-s\").add(wsSettings.getRemote());\n                            }\n                        }\n\n                        margs.addTokenized(envVars.expand(project.getGoals()));\n\n                        Builder builder = new Builder(slistener, proxies, project.sortedActiveModules, margs.toList(), envVars);\n                        MavenProbeAction mpa=null;\n                        try {\n                            mpa = new MavenProbeAction(project,process.channel);\n                            addAction(mpa);\n                            r = process.call(builder);\n                            return r;\n                        } finally {\n                            builder.end(launcher);\n                            getActions().remove(mpa);\n                            process.discard();\n                        }\n                    } finally {\n                        if (r != null) {\n                            setResult(r);\n                        }\n                        // tear down in reverse order\n                        boolean failed=false;\n                        for( int i=buildEnvironments.size()-1; i>=0; i-- ) {\n                            if (!buildEnvironments.get(i).tearDown(MavenModuleSetBuild.this,listener)) {\n                                failed=true;\n                            }                    \n                        }\n                        // WARNING The return in the finally clause will trump any return before\n                        if (failed) return Result.FAILURE;\n                    }\n                }\n                \n                return r;\n            } catch (AbortException e) {\n                if(e.getMessage()!=null)\n                    listener.error(e.getMessage());\n                return Result.FAILURE;\n            } catch (InterruptedIOException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedIOException\"));\n                return Result.ABORTED;\n            } catch (IOException e) {\n                e.printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                return Result.FAILURE;\n            } catch (RunnerAbortedException e) {\n                return Result.FAILURE;\n            } catch (RuntimeException e) {\n                // bug in the code.\n                e.printStackTrace(listener.error(\"Processing failed due to a bug in the code. Please report this to users@hudson.dev.java.net\"));\n                logger.println(\"project=\"+project);\n                logger.println(\"project.getModules()=\"+project.getModules());\n                logger.println(\"project.getRootModule()=\"+project.getRootModule());\n                throw e;\n            }\n        }","commit_id":"9f53cf3dbed5b5c86d448372c0cd27266ae75ca8","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n         * Builds the command line argument list to launch the maven process.\n         *\n         * UGLY.\n         */\n        private ArgumentListBuilder buildMavenCmdLine(BuildListener listener) throws IOException, InterruptedException {\n            MavenInstallation mvn = getParent().getParent().getMaven();\n            if(mvn==null) {\n                listener.error(\"Maven version is not configured for this project. Can't determine which Maven to run\");\n                throw new RunnerAbortedException();\n            }\n\n            // find classworlds.jar\n            File bootDir = new File(mvn.getHomeDir(), \"core/boot\");\n            File[] classworlds = bootDir.listFiles(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    return name.startsWith(\"classworlds\") && name.endsWith(\".jar\");\n                }\n            });\n            if(classworlds==null || classworlds.length==0) {\n                listener.error(\"No classworlds*.jar found in \"+bootDir+\" -- Is this a valid maven2 directory?\");\n                throw new RunnerAbortedException();\n            }\n\n            boolean isMaster = getCurrentNode()==Hudson.getInstance();\n            FilePath slaveRoot=null;\n            if(!isMaster)\n                slaveRoot = ((Slave)getCurrentNode()).getFilePath();\n\n            ArgumentListBuilder args = new ArgumentListBuilder();\n            args.add(launcher.getChannel().call(new GetJavaExe()));\n\n            if(debugPort!=0)\n                args.add(\"-Xrunjdwp:transport=dt_socket,server=y,address=\"+debugPort);\n\n            args.addTokenized(getParent().getParent().getMavenOpts());\n\n            args.add(\"-cp\");\n            args.add(\n                (isMaster?Which.jarFile(Main.class).getAbsolutePath():slaveRoot.child(\"maven-agent.jar\").getRemote())+\n                (launcher.isUnix()?\":\":\";\")+\n                classworlds[0].getAbsolutePath());\n            args.add(Main.class.getName());\n\n            // M2_HOME\n            args.add(mvn.getMavenHome());\n\n            // remoting.jar\n            args.add(launcher.getChannel().call(new GetRemotingJar()));\n            // interceptor.jar\n            args.add(isMaster?\n                Which.jarFile(hudson.maven.agent.PluginManagerInterceptor.class).getAbsolutePath():\n                slaveRoot.child(\"maven-interceptor.jar\").getRemote());\n            return args;\n        }","id":74815,"modified_method":"/**\n         * Builds the command line argument list to launch the maven process.\n         *\n         * UGLY.\n         */\n        private ArgumentListBuilder buildMavenCmdLine(BuildListener listener) throws IOException, InterruptedException {\n            MavenInstallation mvn = getParent().getParent().getMaven();\n            if(mvn==null) {\n                listener.error(\"Maven version is not configured for this project. Can't determine which Maven to run\");\n                throw new RunnerAbortedException();\n            }\n\n            // find classworlds.jar\n            File bootDir = new File(mvn.getHomeDir(), \"core/boot\");\n            File[] classworlds = bootDir.listFiles(new FilenameFilter() {\n                public boolean accept(File dir, String name) {\n                    return name.startsWith(\"classworlds\") && name.endsWith(\".jar\");\n                }\n            });\n            if(classworlds==null || classworlds.length==0) {\n                listener.error(\"No classworlds*.jar found in \"+bootDir+\" -- Is this a valid maven2 directory?\");\n                throw new RunnerAbortedException();\n            }\n\n            boolean isMaster = getCurrentNode()==Hudson.getInstance();\n            FilePath slaveRoot=null;\n            if(!isMaster)\n                slaveRoot = ((Slave)getCurrentNode()).getFilePath();\n\n            ArgumentListBuilder args = new ArgumentListBuilder();\n            args.add(launcher.getChannel().call(new GetJavaExe()));\n\n            if(debugPort!=0)\n                args.add(\"-Xrunjdwp:transport=dt_socket,server=y,address=\"+debugPort);\n\n            args.addTokenized(getMavenOpts());\n\n            args.add(\"-cp\");\n            args.add(\n                (isMaster?Which.jarFile(Main.class).getAbsolutePath():slaveRoot.child(\"maven-agent.jar\").getRemote())+\n                (launcher.isUnix()?\":\":\";\")+\n                classworlds[0].getAbsolutePath());\n            args.add(Main.class.getName());\n\n            // M2_HOME\n            args.add(mvn.getMavenHome());\n\n            // remoting.jar\n            args.add(launcher.getChannel().call(new GetRemotingJar()));\n            // interceptor.jar\n            args.add(isMaster?\n                Which.jarFile(hudson.maven.agent.PluginManagerInterceptor.class).getAbsolutePath():\n                slaveRoot.child(\"maven-interceptor.jar\").getRemote());\n            return args;\n        }","commit_id":"aa05673424172a449021307221ba4030ed4e7782","url":"https://github.com/kohsuke/hudson"},{"original_method":"protected Result doRun(BuildListener listener) throws Exception {\n            // pick up a list of reporters to run\n            getProject().getReporters().addAllTo(reporters);\n            getProject().getParent().getReporters().addAllTo(reporters);\n            \n            for (MavenReporterDescriptor d : MavenReporters.LIST) {\n                if(getProject().getReporters().contains(d))\n                    continue;   // already configured\n                MavenReporter auto = d.newAutoInstance(getProject());\n                if(auto!=null)\n                    reporters.add(auto);\n            }\n\n            // start maven process\n            ArgumentListBuilder args = buildMavenCmdLine(listener);\n\n            Channel channel = launcher.launchChannel(args.toCommandArray(),\n                listener.getLogger(), getProject().getModuleRoot());\n\n            // Maven started.\n\n            ArgumentListBuilder margs = new ArgumentListBuilder();\n            margs.add(\"-N\");\n            margs.addTokenized(getProject().getGoals());\n\n            try {\n                return channel.call(new Builder(\n                    listener,new ProxyImpl(),\n                    reporters.toArray(new MavenReporter[0]), margs.toList()));\n            } finally {\n                channel.close();\n            }\n        }","id":74816,"modified_method":"protected Result doRun(BuildListener listener) throws Exception {\n            this.listener = listener;\n\n            // pick up a list of reporters to run\n            getProject().getReporters().addAllTo(reporters);\n            getProject().getParent().getReporters().addAllTo(reporters);\n            \n            for (MavenReporterDescriptor d : MavenReporters.LIST) {\n                if(getProject().getReporters().contains(d))\n                    continue;   // already configured\n                MavenReporter auto = d.newAutoInstance(getProject());\n                if(auto!=null)\n                    reporters.add(auto);\n            }\n\n            ProcessCache.MavenProcess process = mavenProcessCache.get(launcher.getChannel(), getMavenOpts(), this);\n\n            ArgumentListBuilder margs = new ArgumentListBuilder();\n            margs.add(\"-N\");\n            margs.addTokenized(getProject().getGoals());\n\n            boolean normalExit = false;\n            try {\n                Result r = process.channel.call(new Builder(\n                    listener,new ProxyImpl(),\n                    reporters.toArray(new MavenReporter[0]), margs.toList()));\n                normalExit = true;\n                return r;\n            } finally {\n                if(normalExit)  process.recycle();\n                else            process.discard();\n            }\n        }","commit_id":"aa05673424172a449021307221ba4030ed4e7782","url":"https://github.com/kohsuke/hudson"},{"original_method":"/**\n     * Displays the combined status of all modules. \n     */\n    @Override\n    public Result getResult() {\n        Result r = super.getResult();\n\n        for (List<MavenBuild> list : getModuleBuilds().values())\n            for (MavenBuild build : list)\n                r = r.combine(build.getResult());\n\n        return r;\n    }","id":74817,"modified_method":"/**\n     * Displays the combined status of all modules. \n     */\n    @Override\n    public Result getResult() {\n        Result r = super.getResult();\n\n        for (List<MavenBuild> list : getModuleBuilds().values())\n            for (MavenBuild build : list) {\n                Result br = build.getResult();\n                if(br!=null)\n                    r = r.combine(br);\n            }\n\n        return r;\n    }","commit_id":"aa05673424172a449021307221ba4030ed4e7782","url":"https://github.com/kohsuke/hudson"},{"original_method":"private GroovyCodeBlockCompiler() {\n\n        CompilerConfiguration conf = new CompilerConfiguration(CompilerConfiguration.DEFAULT);\n\n        ImportCustomizer imports = new ImportCustomizer();\n        imports.addStarImports(\"org.voltdb\");\n        imports.addStaticStars(\"org.voltdb.VoltProcedure\",\"org.voltdb.VoltType\");\n\n        conf.addCompilationCustomizers(imports);\n        conf.getOptimizationOptions().put(\"indy\", true);\n        conf.setScriptBaseClass(DelegatingScript.class.getName());\n\n        File groovyOut = new File(\"groovyout\");\n        if (!groovyOut.exists()) groovyOut.mkdir();\n        if (!groovyOut.isDirectory() || !groovyOut.canRead() || !groovyOut.canWrite()) {\n            throw new RuntimeException(\"Cannot access directory\\\"\" + groovyOut + \"\\\"\");\n        }\n        List<String> classPath = conf.getClasspath();\n        classPath.add(groovyOut.getName());\n        conf.setClasspathList(classPath);\n\n        conf.setTargetDirectory(groovyOut);\n\n        gcl = new GroovyClassLoader(Thread.currentThread().getContextClassLoader(), conf);\n    }","id":74818,"modified_method":"private GroovyCodeBlockCompiler() {\n\n        CompilerConfiguration conf = new CompilerConfiguration(CompilerConfiguration.DEFAULT);\n\n        ImportCustomizer imports = new ImportCustomizer();\n        imports.addStarImports(\"org.voltdb\");\n        imports.addImports(\"org.voltdb.groovy.TableBuilder\",\"org.voltdb.groovy.Tuplerator\");\n        imports.addStaticStars(\"org.voltdb.VoltProcedure\",\"org.voltdb.VoltType\");\n\n        conf.addCompilationCustomizers(imports);\n        conf.getOptimizationOptions().put(\"indy\", true);\n        conf.setScriptBaseClass(DelegatingScript.class.getName());\n\n        File groovyOut = new File(\"groovyout\");\n        if (!groovyOut.exists()) groovyOut.mkdir();\n        if (!groovyOut.isDirectory() || !groovyOut.canRead() || !groovyOut.canWrite()) {\n            throw new RuntimeException(\"Cannot access directory\\\"\" + groovyOut + \"\\\"\");\n        }\n        List<String> classPath = conf.getClasspath();\n        classPath.add(groovyOut.getName());\n        conf.setClasspathList(classPath);\n\n        conf.setTargetDirectory(groovyOut);\n\n        gcl = new GroovyClassLoader(Thread.currentThread().getContextClassLoader(), conf);\n    }","commit_id":"1621f3eea5f12e00cd0c5b52a034d40e080498ff","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public GroovyScriptProcedureDelegate(Class<?> scriptClass)  {\n        String shortName = scriptClass.getSimpleName();\n\n        if (!JvmProbe.mayLoadGroovy()) {\n            throw new UnsupportedOperationException(\"Groovy procedures are supported on Java version 7 or higher\");\n        }\n\n        // all groovy scripts have an implicit run method defined\n        Method run;\n        try {\n            run = scriptClass.getMethod(\"run\", (Class<?>[]) null);\n        } catch (NoSuchMethodException e) {\n            throw new SetupException(\n                    \"Procedure \\\"\" + scriptClass.getName() + \"\\\" is not a groovy script\", e\n                    );\n        }\n        try {\n            m_script = (DelegatingScript)scriptClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new SetupException(\n                    \"Error instantiating the code block script for \\\"\" + shortName + \"\\\"\", e\n                    );\n        } catch (IllegalAccessException e) {\n            throw new SetupException(\n                    \"Error instantiating the code block script for \\\"\" + shortName + \"\\\"\", e\n                    );\n        } catch (ClassCastException e) {\n            throw new SetupException(\n                    \"Procedure \\\"\" + shortName + \"\\\" is not a groovy script\", e\n                    );\n        }\n        // inject the required volt binding\n        Binding binding = new Binding();\n        binding.setVariable(GVY_PROCEDURE_INSTANCE_VAR, this);\n        m_script.setBinding(binding);\n        m_script.setDelegate(this);\n\n        try {\n            run.invoke(m_script, (Object[]) null);\n        } catch (IllegalAccessException e) {\n            throw new SetupException(\n                    \"Error running the code block script for \\\"\" + shortName+ \"\\\"\", e\n                    );\n        } catch (InvocationTargetException e) {\n            throw new SetupException(\n                    \"Error running the code block script for \\\"\" + shortName + \"\\\"\",\n                    e.getTargetException() == null ? e : e.getTargetException()\n                    );\n        }\n        Object transactOn = null;\n        try {\n            transactOn = binding.getVariable(GVY_PROCEDURE_ENTRY_CLOSURE);\n        } catch ( MissingPropertyException mpex) {\n            throw new SetupException(String.format(\n                    \"Procedure \\\"%s\\\" code block does not contain the required \\\"%s\\\" closure\",\n                    shortName, GVY_PROCEDURE_ENTRY_CLOSURE\n                    ));\n        }\n        if (transactOn == null || ! (transactOn instanceof Closure)) {\n            throw new SetupException(String.format(\n                    \"Procedure \\\"%s\\\" code block does not contain the required \\\"%s\\\" closure\",\n                    shortName, GVY_PROCEDURE_ENTRY_CLOSURE\n                    ));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String,Object> bindings = binding.getVariables();\n        ImmutableMap.Builder<String, SQLStmt> builder = ImmutableMap.builder();\n\n        for (Map.Entry<String, Object>entry: bindings.entrySet()) {\n            if (entry.getValue() != null && entry.getValue() instanceof SQLStmt) {\n                SQLStmt statement = SQLStmt.class.cast(entry.getValue());\n                builder.put(entry.getKey(), statement);\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Closure<Object> procedureInvocationClosure = (Closure<Object>)transactOn;\n\n        m_procedureName = shortName;\n        m_closure = procedureInvocationClosure;\n        m_parameterTypes = procedureInvocationClosure.getParameterTypes();\n        m_statementMap = builder.build();\n    }","id":74819,"modified_method":"public GroovyScriptProcedureDelegate(Class<?> scriptClass)  {\n        String shortName = scriptClass.getSimpleName();\n\n        if (!JvmProbe.mayLoadGroovy()) {\n            throw new UnsupportedOperationException(\"Groovy procedures are supported on Java version 7 or higher\");\n        }\n\n        // all groovy scripts have an implicit run method defined\n        Method run;\n        try {\n            run = scriptClass.getMethod(\"run\", (Class<?>[]) null);\n        } catch (NoSuchMethodException e) {\n            throw new SetupException(\n                    \"Procedure \\\"\" + scriptClass.getName() + \"\\\" is not a groovy script\", e\n                    );\n        }\n        try {\n            m_script = (DelegatingScript)scriptClass.newInstance();\n        } catch (InstantiationException e) {\n            throw new SetupException(\n                    \"Error instantiating the code block script for \\\"\" + shortName + \"\\\"\", e\n                    );\n        } catch (IllegalAccessException e) {\n            throw new SetupException(\n                    \"Error instantiating the code block script for \\\"\" + shortName + \"\\\"\", e\n                    );\n        } catch (ClassCastException e) {\n            throw new SetupException(\n                    \"Procedure \\\"\" + shortName + \"\\\" is not a groovy script\", e\n                    );\n        }\n        // inject the required volt binding\n        Binding binding = new Binding();\n        binding.setVariable(GVY_PROCEDURE_INSTANCE_VAR, this);\n        m_script.setBinding(binding);\n        m_script.setDelegate(this);\n\n        try {\n            run.invoke(m_script, (Object[]) null);\n        } catch (IllegalAccessException e) {\n            throw new SetupException(\n                    \"Error running the code block script for \\\"\" + shortName+ \"\\\"\", e\n                    );\n        } catch (InvocationTargetException e) {\n            throw new SetupException(\n                    \"Error running the code block script for \\\"\" + shortName + \"\\\"\",\n                    e.getTargetException() == null ? e : e.getTargetException()\n                    );\n        }\n        Object transactOn = null;\n        try {\n            transactOn = binding.getVariable(GVY_PROCEDURE_ENTRY_CLOSURE);\n        } catch ( MissingPropertyException mpex) {\n            throw new SetupException(String.format(\n                    \"Procedure \\\"%s\\\" code block does not contain the required \\\"%s\\\" closure\",\n                    shortName, GVY_PROCEDURE_ENTRY_CLOSURE\n                    ));\n        }\n        if (transactOn == null || ! (transactOn instanceof Closure)) {\n            throw new SetupException(String.format(\n                    \"Procedure \\\"%s\\\" code block does not contain the required \\\"%s\\\" closure\",\n                    shortName, GVY_PROCEDURE_ENTRY_CLOSURE\n                    ));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Map<String,Object> bindings = binding.getVariables();\n        ImmutableMap.Builder<String, SQLStmt> builder = ImmutableMap.builder();\n\n        for (Map.Entry<String, Object>entry: bindings.entrySet()) {\n            if (entry.getValue() != null && entry.getValue() instanceof SQLStmt) {\n                SQLStmt statement = SQLStmt.class.cast(entry.getValue());\n                builder.put(entry.getKey(), statement);\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        Closure<Object> procedureInvocationClosure = (Closure<Object>)transactOn;\n\n        m_procedureName = shortName;\n        m_closure = procedureInvocationClosure;\n\n        Class<?> [] parameterTypes = procedureInvocationClosure.getParameterTypes();\n        // closure with no parameters has an object as the default parameter\n        if (parameterTypes.length == 1 && parameterTypes[0] == Object.class) {\n            m_parameterTypes = new Class<?>[0];\n        } else {\n            m_parameterTypes = parameterTypes;\n        }\n\n        m_statementMap = builder.build();\n    }","commit_id":"1621f3eea5f12e00cd0c5b52a034d40e080498ff","url":"https://github.com/VoltDB/voltdb"},{"original_method":"public Object invoke(Object[] paramList) {\n        return m_closure.call(paramList);\n    }","id":74820,"modified_method":"public Object invoke(Object[] paramList) throws InvocationTargetException {\n        Object retVal;\n        try {\n            retVal = m_closure.call(paramList);\n        } catch (Exception e) {\n            throw new InvocationTargetException(e);\n        }\n        return retVal;\n    }","commit_id":"1621f3eea5f12e00cd0c5b52a034d40e080498ff","url":"https://github.com/VoltDB/voltdb"},{"original_method":"/**\n     * Starts a task asynchronously.\n     * In its present implementation can only run tasks which expect a\n     * {@code Future} result.\n     * @param task The task to run.\n     * @param <V> The type of result expected.\n     * @return A listenable future for the expected result.\n     */\n    public <V> ListenableFuture<V> startTask(\n            final @Nonnull AsyncTask<Future<V>> task) {\n        HAccount taskOwner = ServiceLocator.instance()\n                .getInstance(HAccount.class, new AuthenticatedLiteral());\n        ZanataIdentity ownerIdentity = ZanataIdentity.instance();\n\n        // Extract security context from current thread\n        final String taskOwnerUsername =\n                taskOwner != null ? taskOwner.getUsername() : null;\n        final Principal runAsPpal = ownerIdentity.getPrincipal();\n        final Subject runAsSubject = ownerIdentity.getSubject();\n\n        // final result\n        final AsyncTaskResult<V> taskFuture = new AsyncTaskResult<V>();\n\n        // The logic to run to setup all necessary contexts and specific logic\n        final Runnable executableCommand = () -> {\n            ContextControl ctxCtrl = null;\n\n            try {\n                // Start CDI contexts\n                ctxCtrl =\n                        ServiceLocator.instance().getInstance(\n                                ContextControl.class);\n                ctxCtrl.startContexts();\n                // Prepare the security context\n                prepareSecurityContext(taskOwnerUsername, runAsPpal, runAsSubject);\n                // run the task and capture the result\n                V returnValue = getReturnValue(task.call());\n                taskFuture.set(returnValue);\n            } catch (Throwable t) {\n                taskFuture.setException(t);\n                log.error(\n                        \"Exception when executing an asynchronous task.\", t);\n            } finally {\n                // stop the contexts to make sure all beans are cleaned up\n                if(ctxCtrl != null) {\n                    ctxCtrl.stopContexts();\n                }\n            }\n        };\n\n        scheduler.execute(executableCommand);\n        return taskFuture;\n    }","id":74821,"modified_method":"/**\n     * Starts a task asynchronously.\n     * In its present implementation can only run tasks which expect a\n     * {@code Future} result.\n     * @param task The task to run.\n     * @param <V> The type of result expected.\n     * @return A listenable future for the expected result.\n     */\n    public <V> ListenableFuture<V> startTask(\n            final @Nonnull AsyncTask<Future<V>> task) {\n        HAccount taskOwner = ServiceLocator.instance()\n                .getInstance(HAccount.class, new AuthenticatedLiteral());\n        ZanataIdentity ownerIdentity = ZanataIdentity.instance();\n\n        // Extract security context from current thread\n        final String taskOwnerUsername =\n                taskOwner != null ? taskOwner.getUsername() : null;\n        final Principal runAsPpal = ownerIdentity.getPrincipal();\n        final Subject runAsSubject = ownerIdentity.getSubject();\n\n        // final result\n        final AsyncTaskResult<V> taskFuture = new AsyncTaskResult<V>();\n\n        // The logic to run to setup all necessary contexts and specific logic\n        final Runnable executableCommand = () -> {\n            ContextControl ctxCtrl = null;\n\n            try {\n                // Start CDI contexts\n                ctxCtrl =\n                        ServiceLocator.instance().getInstance(\n                                ContextControl.class);\n                ctxCtrl.startContext(RequestScoped.class);\n                ctxCtrl.startContext(SessionScoped.class);\n                // Prepare the security context\n                prepareSecurityContext(taskOwnerUsername, runAsPpal, runAsSubject);\n                // run the task and capture the result\n                V returnValue = getReturnValue(task.call());\n                taskFuture.set(returnValue);\n            } catch (Throwable t) {\n                taskFuture.setException(t);\n                log.error(\n                        \"Exception when executing an asynchronous task.\", t);\n            } finally {\n                // stop the contexts to make sure all beans are cleaned up\n                if (ctxCtrl != null) {\n                    ctxCtrl.stopContext(RequestScoped.class);\n                    ctxCtrl.stopContext(SessionScoped.class);\n                }\n            }\n        };\n\n        scheduler.execute(executableCommand);\n        return taskFuture;\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Deployment(name = \"zanata.war\")\n    public static Archive<?> createDeployment() {\n        WebArchive archive =\n                ShrinkWrap.create(WebArchive.class, DEPLOYMENT_NAME + \".war\");\n        archive.addAsLibraries(runtimeAndTestDependenciesFromPom());\n\n        // Local packages\n        Filter<ArchivePath> archivePathFilter = object -> {\n            // Avoid the model package (for some reason it's being included\n            // as a class file)\n            return !object.get().startsWith(\"/org/zanata/model/\") &&\n                    !object.get().startsWith(\"/org/zanata/util/RequestContextValueStore\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/AutowireContexts\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/AutowireInstance\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/AutowireTransaction\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/FieldComponentAccessor\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/MethodComponentAccessor\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/SeamAutowire\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/test\") &&\n                    !object.get().startsWith(\"/org/zanata/webtrans/client\") &&\n                    notUnitTest(object);\n        };\n        archive.addPackages(true, archivePathFilter, \"org.zanata\");\n\n        // Resources (descriptors, etc)\n        archive.addAsResource(\"pluralforms.properties\");\n        archive.addAsResource(\"META-INF/apache-deltaspike.properties\");\n        // JaxRSClassIndexProcessor generated class index\n//        archive.addAsResource(\"META-INF/services/javax.annotation.processing.Processor\");\n\n        File jaxRsPathIndex = concatenatePathClassIndice();\n        archive.addAsResource(jaxRsPathIndex,\n                \"META-INF/annotations/javax.ws.rs.Path\");\n        archive.addAsResource(\"META-INF/annotations/javax.ws.rs.ext.Provider\");\n\n        archive.addAsResource(new ClassLoaderAsset(\"META-INF/orm.xml\"),\n                \"META-INF/orm.xml\");\n        archive.addAsResource(\n                new ClassLoaderAsset(\"arquillian/persistence.xml\"),\n                \"META-INF/persistence.xml\");\n        archive.addAsResource(\"import.sql\");\n        archive.addAsResource(\"messages.properties\");\n        archive.addAsWebInfResource(\n                new File(\"src/main/webapp-jboss/WEB-INF/jboss-web.xml\"));\n        archive.addAsWebInfResource(\n                new File(\"src/main/webapp-jboss/WEB-INF/beans.xml\"));\n        archive.addAsWebInfResource(new File(\n                \"src/main/webapp-jboss/WEB-INF/jboss-deployment-structure.xml\"));\n        archive.setWebXML(\"arquillian/test-web.xml\");\n\n        addRemoteHelpers(archive);\n\n        // Export (to actually see what is being deployed)\n//         archive.as(ZipExporter.class).exportTo(new\n//         File(\"/home/pahuang/temp/archive.war\"), true);\n\n        return archive;\n    }","id":74822,"modified_method":"@Deployment(name = \"zanata.war\")\n    public static Archive<?> createDeployment() {\n        WebArchive archive =\n                ShrinkWrap.create(WebArchive.class, DEPLOYMENT_NAME + \".war\");\n        archive.addAsLibraries(runtimeAndTestDependenciesFromPom());\n\n        // Local packages\n        Filter<ArchivePath> archivePathFilter = object -> {\n            // Avoid the model package (for some reason it's being included\n            // as a class file)\n            return !object.get().startsWith(\"/org/zanata/model/\") &&\n                    !object.get().startsWith(\"/org/zanata/util/RequestContextValueStore\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/AutowireContexts\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/AutowireInstance\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/AutowireTransaction\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/FieldComponentAccessor\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/MethodComponentAccessor\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/SeamAutowire\") &&\n                    !object.get().startsWith(\"/org/zanata/seam/test\") &&\n                    !object.get().startsWith(\"/org/zanata/webtrans\") &&\n                    notUnitTest(object);\n        };\n        archive.addPackages(true, archivePathFilter, \"org.zanata\");\n\n        // Resources (descriptors, etc)\n        archive.addAsResource(\"pluralforms.properties\");\n        archive.addAsResource(\"META-INF/apache-deltaspike.properties\");\n        // JaxRSClassIndexProcessor generated class index\n        File jaxRsPathIndex = concatenatePathClassIndice();\n        archive.addAsResource(jaxRsPathIndex,\n                \"META-INF/annotations/javax.ws.rs.Path\");\n        archive.addAsResource(\"META-INF/annotations/javax.ws.rs.ext.Provider\");\n\n        archive.addAsResource(new ClassLoaderAsset(\"META-INF/orm.xml\"),\n                \"META-INF/orm.xml\");\n        archive.addAsResource(\n                new ClassLoaderAsset(\"arquillian/persistence.xml\"),\n                \"META-INF/persistence.xml\");\n        archive.addAsResource(\"import.sql\");\n        archive.addAsResource(\"messages.properties\");\n        archive.addAsWebInfResource(\n                new File(\"src/main/webapp-jboss/WEB-INF/jboss-web.xml\"));\n        archive.addAsWebInfResource(\n                new File(\"src/main/webapp-jboss/WEB-INF/beans.xml\"));\n        archive.addAsWebInfResource(new File(\n                \"src/main/webapp-jboss/WEB-INF/jboss-deployment-structure.xml\"));\n        archive.setWebXML(\"arquillian/test-web.xml\");\n\n        addRemoteHelpers(archive);\n\n        // Export (to actually see what is being deployed)\n//         archive.as(ZipExporter.class).exportTo(new\n//         File(\"/home/pahuang/temp/archive.war\"), true);\n\n        return archive;\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"@PreDestroy\n    protected void destroy() {\n        // help Hibernate Search to shut down cleanly (delete Lucene index locks)\n        if (entityManagerFactory.isOpen()) {\n            entityManagerFactory.close();\n        }\n    }","id":74823,"modified_method":"@PreDestroy\n    protected void destroy() {\n        // help Hibernate Search to shut down cleanly (delete Lucene index locks)\n        if (entityManagerFactory.isOpen()) {\n            log.debug(\"!!!!!!!!!!!! shutting down entityManagerFactory\");\n            entityManagerFactory.close();\n        }\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected void closeEntityManager(@Disposes EntityManager entityManager) {\n        // sometimes EntityManager.isOpen() returns true when the Session\n        // is actually closed, so we ask the Session\n        if (entityManager.unwrap(Session.class).isOpen()) {\n            entityManager.close();\n        }\n    }","id":74824,"modified_method":"protected void closeEntityManager(@Disposes EntityManager entityManager) {\n        // sometimes EntityManager.isOpen() returns true when the Session\n        // is actually closed, so we ask the Session\n        if (entityManager.unwrap(Session.class).isOpen()) {\n            log.debug(\"___________ closing entityManager: {}\", entityManager);\n            entityManager.close();\n        }\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected void closeFullTextSession(@Disposes @FullText FullTextSession fullTextSession) {\n        if (fullTextSession.isOpen()) {\n            fullTextSession.close();\n        }\n    }","id":74825,"modified_method":"protected void closeFullTextSession(@Disposes @FullText FullTextSession fullTextSession) {\n        if (fullTextSession.isOpen()) {\n            log.debug(\"___________ closing FullTextSession: {}\", fullTextSession);\n            fullTextSession.close();\n        }\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected void closeSession(@Disposes Session session) {\n        if (session.isOpen()) {\n            session.close();\n        }\n    }","id":74826,"modified_method":"protected void closeSession(@Disposes Session session) {\n        if (session.isOpen()) {\n            log.debug(\"___________ closing session: {}\", session);\n            session.close();\n        }\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"protected void closeFTEntityManager(@Disposes @FullText FullTextEntityManager entityManager) {\n        if (entityManager.isOpen()) {\n            entityManager.close();\n        }\n    }","id":74827,"modified_method":"protected void closeFTEntityManager(@Disposes @FullText FullTextEntityManager entityManager) {\n        if (entityManager.isOpen()) {\n            log.debug(\"___________ closing FullTextEntityManager: {}\", entityManager);\n            entityManager.close();\n        }\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"@Transactional\n    public <R> R runInTransaction(Callable<R> function) throws Exception {\n        return function.call();\n    }","id":74828,"modified_method":"public <R> R runInTransaction(Callable<R> function) throws Exception {\n        R result = null;\n        try {\n//            transactionManager.setTransactionTimeout(30);\n            transactionManager.begin();\n            result = function.call();\n            transactionManager.commit();\n        } catch (Throwable t) {\n            log.error(\"error running in transaction\",\n                    Throwables.getRootCause(t));\n            transactionManager.rollback();\n        }\n        return result;\n    }","commit_id":"43e4cb2d5194de19f43639800fcba957e3b78889","url":"https://github.com/zanata/zanata-server"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tFolder folder, HttpServletRequest request,\n\t\t\tLiferayPortletResponse liferayPortletResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletURL portletURL =\n\t\t\t(PortletURL)liferayPortletResponse.createResourceURL();\n\n\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\tportletURL.setParameter(\"showSiblings\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewAddButton\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewBreadcrumb\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\n\t\t\t\"viewDisplayStyleButttons\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewEntries\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\n\t\t\t\"viewFileEntrySearch\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewFolders\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewSortButton\", Boolean.TRUE.toString());\n\n\t\tMap<String, Object> data = new HashMap<String, Object>();\n\n\t\tdata.put(\"folder-id\", _getDefaultFolderId(request));\n\t\tdata.put(\"refresh-folders\", Boolean.TRUE.toString());\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, themeDisplay.translate(\"documents-home\"),\n\t\t\tportletURL.toString(), data);\n\n\t\taddPortletBreadcrumbEntries(folder, request, portletURL);\n\t}","id":74829,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tFolder folder, HttpServletRequest request,\n\t\t\tLiferayPortletResponse liferayPortletResponse)\n\t\tthrows Exception {\n\n\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\tPortletURL portletURL =\n\t\t\t(PortletURL)liferayPortletResponse.createResourceURL();\n\n\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\tportletURL.setParameter(\"showSiblings\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewAddButton\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewBreadcrumb\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\n\t\t\t\"viewDisplayStyleButttons\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewEntries\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\n\t\t\t\"viewFileEntrySearch\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewFolders\", Boolean.TRUE.toString());\n\t\tportletURL.setParameter(\"viewSortButton\", Boolean.TRUE.toString());\n\n\t\tMap<String, Object> data = new HashMap<String, Object>();\n\n\t\tdata.put(\"folder-id\", _getDefaultFolderId(request));\n\t\tdata.put(\"refresh-folders\", Boolean.TRUE.toString());\n\n        if(folder != null) {\n            PortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"documents-home\"),\n\t\t\t\tportletURL.toString(), data);\n        }\n\n\t\taddPortletBreadcrumbEntries(folder, request, portletURL);\n\t}","commit_id":"11ee3caae5980ed19a9c5718cd6c5bc0f401b6cf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/journal/select_document_library\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_file_entry\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_folder\") ||\n\t\t\tstrutsAction.equals(\"/document_library_display/select_folder\")) {\n\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setParameter(\"groupId\", String.valueOf(groupId));\n\n\t\t\tMap<String, Object> data = new HashMap<String, Object>();\n\n\t\t\tdata.put(\"folder-id\", _getDefaultFolderId(request));\n\t\t\tdata.put(\"refresh-folders\", Boolean.TRUE.toString());\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"documents-home\"),\n\t\t\t\tportletURL.toString(), data);\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\t}\n\n\t\taddPortletBreadcrumbEntries(folder, request, portletURL);\n\t}","id":74830,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tlong groupId = ParamUtil.getLong(request, \"groupId\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (strutsAction.equals(\"/journal/select_document_library\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_file_entry\") ||\n\t\t\tstrutsAction.equals(\"/document_library/select_folder\") ||\n\t\t\tstrutsAction.equals(\"/document_library_display/select_folder\")) {\n\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\"struts_action\", strutsAction);\n\t\t\tportletURL.setParameter(\"groupId\", String.valueOf(groupId));\n\n\t\t\tMap<String, Object> data = new HashMap<String, Object>();\n\n\t\t\tdata.put(\"folder-id\", _getDefaultFolderId(request));\n\t\t\tdata.put(\"refresh-folders\", Boolean.TRUE.toString());\n\n            if(folder != null){\n                PortalUtil.addPortletBreadcrumbEntry(\n                    request, themeDisplay.translate(\"documents-home\"),\n                    portletURL.toString(), data);\n            }\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/document_library/view\");\n\t\t}\n\n\t\taddPortletBreadcrumbEntries(folder, request, portletURL);\n\t}","commit_id":"11ee3caae5980ed19a9c5718cd6c5bc0f401b6cf","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tBookmarksEntry entry, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tBookmarksFolder folder = entry.getFolder();\n\n\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\"struts_action\", \"/bookmarks/view_entry\");\n\t\tportletURL.setParameter(\"entryId\", String.valueOf(entry.getEntryId()));\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, entry.getName(), portletURL.toString());\n\t}","id":74831,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tBookmarksEntry entry, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tBookmarksFolder folder = entry.getFolder();\n\n\t\tif (folder.getFolderId() !=\n\t\t\t\tBookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\taddPortletBreadcrumbEntries(folder, request, renderResponse);\n\t\t}\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tportletURL.setParameter(\"struts_action\", \"/bookmarks/view_entry\");\n\t\tportletURL.setParameter(\"entryId\", String.valueOf(entry.getEntryId()));\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, entry.getName(), portletURL.toString());\n\t}","commit_id":"bb105d45c73029faeb54bb6412b63ba9bd9e3c7f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tBookmarksFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tboolean selectFolder = strutsAction.equals(\"/bookmarks/select_folder\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (selectFolder) {\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/bookmarks/select_folder\");\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"bookmarks-home\"),\n\t\t\t\tportletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/bookmarks/view\");\n\t\t}\n\n\t\tList<BookmarksFolder> ancestorFolders = folder.getAncestors();\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (BookmarksFolder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\trequest, folder.getName(), portletURL.toString());\n\t}","id":74832,"modified_method":"public static void addPortletBreadcrumbEntries(\n\t\t\tBookmarksFolder folder, HttpServletRequest request,\n\t\t\tRenderResponse renderResponse)\n\t\tthrows Exception {\n\n\t\tString strutsAction = ParamUtil.getString(\n\t\t\trequest, \"struts_action\");\n\n\t\tboolean selectFolder = strutsAction.equals(\"/bookmarks/select_folder\");\n\n\t\tPortletURL portletURL = renderResponse.createRenderURL();\n\n\t\tif (selectFolder) {\n\t\t\tThemeDisplay themeDisplay =\t(ThemeDisplay)request.getAttribute(\n\t\t\t\tWebKeys.THEME_DISPLAY);\n\n\t\t\tportletURL.setWindowState(LiferayWindowState.POP_UP);\n\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"struts_action\", \"/bookmarks/select_folder\");\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, themeDisplay.translate(\"bookmarks-home\"),\n\t\t\t\tportletURL.toString());\n\t\t}\n\t\telse {\n\t\t\tportletURL.setParameter(\"struts_action\", \"/bookmarks/view\");\n\t\t}\n\n\t\tList<BookmarksFolder> ancestorFolders = folder.getAncestors();\n\n\t\tCollections.reverse(ancestorFolders);\n\n\t\tfor (BookmarksFolder ancestorFolder : ancestorFolders) {\n\t\t\tportletURL.setParameter(\n\t\t\t\t\"folderId\", String.valueOf(ancestorFolder.getFolderId()));\n\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, ancestorFolder.getName(), portletURL.toString());\n\t\t}\n\n\t\tportletURL.setParameter(\n\t\t\t\"folderId\", String.valueOf(folder.getFolderId()));\n\n\t\tif (folder.getFolderId()\n\t\t\t\t!= BookmarksFolderConstants.DEFAULT_PARENT_FOLDER_ID) {\n\t\t\tPortalUtil.addPortletBreadcrumbEntry(\n\t\t\t\trequest, folder.getName(), portletURL.toString());\n\t\t}\n\t}","commit_id":"bb105d45c73029faeb54bb6412b63ba9bd9e3c7f","url":"https://github.com/liferay/liferay-portal"},{"original_method":"public DismissTopMappingRuleException(DismissTopMappingRuleException.MessageType messageType) {\n    myMessageType = messageType;\n  }","id":74833,"modified_method":"public DismissTopMappingRuleException(DismissTopMappingRuleException.MessageType messageType) {\n    this(messageType, null);\n  }","commit_id":"d59b3e9bae37f7af3565fd670fe8a01d6aad92a1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n    public void dismissTopRule(SNode ruleConsequence) {\n      SNode message = RuleUtil.getDismissTopRule_message(ruleConsequence);\n      DismissTopMappingRuleException.MessageType messageType = GeneratorUtilEx.getGeneratorMessage_kind(message);\n      String text = GeneratorUtilEx.getGeneratorMessage_text(message);\n      if (messageType != null) {\n        if (messageType == MessageType.error) {\n          showErrorMessage(ruleConsequence, text);\n        } else if (messageType == MessageType.warning) {\n          getLog().warning(myTemplateContext.getInput(), text);\n        } else {\n          getLog().info(myTemplateContext.getInput(), text);\n        }\n      }\n      myDismissRuleException = new DismissTopMappingRuleException(messageType); // TODO pass message text as well\n    }","id":74834,"modified_method":"@Override\n    public void dismissTopRule(SNode ruleConsequence) {\n      SNode message = RuleUtil.getDismissTopRule_message(ruleConsequence);\n      DismissTopMappingRuleException.MessageType messageType = GeneratorUtilEx.getGeneratorMessage_kind(message);\n      String text = GeneratorUtilEx.getGeneratorMessage_text(message);\n      GeneratorUtil.log(getLog(),ruleConsequence.getReference(), messageType, text, GeneratorUtil.describeIfExists(myTemplateContext.getInput(), \"input node\"));\n      myDismissRuleException = new DismissTopMappingRuleException(messageType, text);\n    }","commit_id":"d59b3e9bae37f7af3565fd670fe8a01d6aad92a1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void processNull(TemplateExecutionEnvironment environment, SNodeReference templateSwitch, TemplateContext context) {\n\n    SNode generatorMessage = RuleUtil.getSwitch_NullInputMessage(mySwitch);\n    if (generatorMessage != null) {\n      // TODO there's little value in GeneratorUtilEx.processGeneratorMessage per se, and once the code to process consequences moved out from\n      // GeneratorUtilEx to RuleConsequenceProcessor, and doesn't use processGeneratorMessage any longer, there's no justification for this method to survive in\n      // its present state\n      GeneratorUtilEx.processGeneratorMessage(generatorMessage, context.getInput(), templateSwitch.resolve(MPSModuleRepository.getInstance()), null, environment.getGenerator());\n    }\n  }","id":74835,"modified_method":"@Override\n  public void processNull(TemplateExecutionEnvironment environment, SNodeReference templateSwitch, TemplateContext context) {\n\n    SNode message = RuleUtil.getSwitch_NullInputMessage(mySwitch);\n    if (message != null) {\n      DismissTopMappingRuleException.MessageType messageType = GeneratorUtilEx.getGeneratorMessage_kind(message);\n      String text = GeneratorUtilEx.getGeneratorMessage_text(message);\n      GeneratorUtil.log(environment.getLogger(), templateSwitch, messageType, text, GeneratorUtil.describeIfExists(context.getInput(), \"input node\"));\n    }\n  }","commit_id":"d59b3e9bae37f7af3565fd670fe8a01d6aad92a1","url":"https://github.com/JetBrains/MPS"},{"original_method":"@Override\n  public void recoverTask(TaskAttemptContext context)\n      throws IOException {\n    context.progress();\n    TaskAttemptID attemptId = context.getTaskAttemptID();\n    int previousAttempt = getAppAttemptId(context) - 1;\n    if (previousAttempt < 0) {\n      throw new IOException (\"Cannot recover task output for first attempt...\");\n    }\n    \n    Path committedTaskPath = getCommittedTaskPath(context);\n    Path previousCommittedTaskPath = getCommittedTaskPath(\n        previousAttempt, context);\n    FileSystem fs = committedTaskPath.getFileSystem(context.getConfiguration());\n    \n    LOG.debug(\"Trying to recover task from \" + previousCommittedTaskPath \n        + \" into \" + committedTaskPath);\n    if (fs.exists(previousCommittedTaskPath)) {\n      if(fs.exists(committedTaskPath)) {\n        if(!fs.delete(committedTaskPath, true)) {\n          throw new IOException(\"Could not delete \"+committedTaskPath);\n        }\n      }\n      //Rename can fail if the parent directory does not yet exist.\n      Path committedParent = committedTaskPath.getParent();\n      fs.mkdirs(committedParent);\n      if(!fs.rename(previousCommittedTaskPath, committedTaskPath)) {\n        throw new IOException(\"Could not rename \" + previousCommittedTaskPath +\n            \" to \" + committedTaskPath);\n      }\n      LOG.info(\"Saved output of \" + attemptId + \" to \" + committedTaskPath);\n    } else {\n      LOG.warn(attemptId+\" had no output to recover.\");\n    }\n  }","id":74836,"modified_method":"@Override\n  public void recoverTask(TaskAttemptContext context)\n      throws IOException {\n    if(hasOutputPath()) {\n      context.progress();\n      TaskAttemptID attemptId = context.getTaskAttemptID();\n      int previousAttempt = getAppAttemptId(context) - 1;\n      if (previousAttempt < 0) {\n        throw new IOException (\"Cannot recover task output for first attempt...\");\n      }\n\n      Path committedTaskPath = getCommittedTaskPath(context);\n      Path previousCommittedTaskPath = getCommittedTaskPath(\n          previousAttempt, context);\n      FileSystem fs = committedTaskPath.getFileSystem(context.getConfiguration());\n\n      LOG.debug(\"Trying to recover task from \" + previousCommittedTaskPath \n          + \" into \" + committedTaskPath);\n      if (fs.exists(previousCommittedTaskPath)) {\n        if(fs.exists(committedTaskPath)) {\n          if(!fs.delete(committedTaskPath, true)) {\n            throw new IOException(\"Could not delete \"+committedTaskPath);\n          }\n        }\n        //Rename can fail if the parent directory does not yet exist.\n        Path committedParent = committedTaskPath.getParent();\n        fs.mkdirs(committedParent);\n        if(!fs.rename(previousCommittedTaskPath, committedTaskPath)) {\n          throw new IOException(\"Could not rename \" + previousCommittedTaskPath +\n              \" to \" + committedTaskPath);\n        }\n        LOG.info(\"Saved output of \" + attemptId + \" to \" + committedTaskPath);\n      } else {\n        LOG.warn(attemptId+\" had no output to recover.\");\n      }\n    } else {\n      LOG.warn(\"Output Path is null in recoverTask()\");\n    }\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"private Path getTaskAttemptPath(TaskAttemptContext context, Path out) throws IOException {\n    Path workPath = FileOutputFormat.getWorkOutputPath(context.getJobConf());\n    if(workPath == null) {\n      return org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter\n      .getTaskAttemptPath(context, out);\n    }\n    return workPath;\n  }","id":74837,"modified_method":"private Path getTaskAttemptPath(TaskAttemptContext context, Path out) throws IOException {\n    Path workPath = FileOutputFormat.getWorkOutputPath(context.getJobConf());\n    if(workPath == null && out != null) {\n      return org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter\n      .getTaskAttemptPath(context, out);\n    }\n    return workPath;\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Compute the path where the output of a committed task is stored until\n   * the entire job is committed.\n   * @param context the context of the task attempt\n   * @return the path where the output of a committed task is stored until\n   * the entire job is committed.\n   */\n  Path getCommittedTaskPath(TaskAttemptContext context) {\n    return org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter\n        .getCommittedTaskPath(context, getOutputPath(context));\n  }","id":74838,"modified_method":"/**\n   * Compute the path where the output of a committed task is stored until\n   * the entire job is committed.\n   * @param context the context of the task attempt\n   * @return the path where the output of a committed task is stored until\n   * the entire job is committed.\n   */\n  @Private\n  Path getCommittedTaskPath(TaskAttemptContext context) {\n    Path out = getOutputPath(context);\n    return out == null ? null : \n      org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter\n        .getCommittedTaskPath(context, out);\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"/**\n   * Compute the path where the output of a given job attempt will be placed. \n   * @param context the context of the job.  This is used to get the\n   * application attempt id.\n   * @return the path to store job attempt data.\n   */\n  @Private\n  Path getJobAttemptPath(JobContext context) {\n    return org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter\n        .getJobAttemptPath(context, getOutputPath(context));\n  }","id":74839,"modified_method":"/**\n   * Compute the path where the output of a given job attempt will be placed. \n   * @param context the context of the job.  This is used to get the\n   * application attempt id.\n   * @return the path to store job attempt data.\n   */\n  @Private\n  Path getJobAttemptPath(JobContext context) {\n    Path out = getOutputPath(context);\n    return out == null ? null : \n      org.apache.hadoop.mapreduce.lib.output.FileOutputCommitter\n        .getJobAttemptPath(context, out);\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"@Private\n  Path getTaskAttemptPath(TaskAttemptContext context) throws IOException {\n    return getTaskAttemptPath(context, getOutputPath(context));\n  }","id":74840,"modified_method":"@Private\n  Path getTaskAttemptPath(TaskAttemptContext context) throws IOException {\n    Path out = getOutputPath(context);\n    return out == null ? null : getTaskAttemptPath(context, out);\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"public Path getWorkPath(TaskAttemptContext context, Path outputPath) \n  throws IOException {\n    return getTaskAttemptPath(context, outputPath);\n  }","id":74841,"modified_method":"public Path getWorkPath(TaskAttemptContext context, Path outputPath) \n  throws IOException {\n    return outputPath == null ? null : getTaskAttemptPath(context, outputPath);\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"public void testMapFileOutputCommitter() throws Exception {\n    JobConf conf = new JobConf();\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    JobContext jContext = new JobContextImpl(conf, taskID.getJobID());\n    TaskAttemptContext tContext = new TaskAttemptContextImpl(conf, taskID);\n    FileOutputCommitter committer = new FileOutputCommitter();    \n    \n    // setup\n    committer.setupJob(jContext);\n    committer.setupTask(tContext);\n\n    // write output\n    MapFileOutputFormat theOutputFormat = new MapFileOutputFormat();\n    RecordWriter theRecordWriter = theOutputFormat.getRecordWriter(null, conf, partFile, null);\n    writeMapFileOutput(theRecordWriter, tContext);\n\n    // do commit\n    committer.commitTask(tContext);\n    committer.commitJob(jContext);\n\n    // validate output\n    validateMapFileOutputContent(FileSystem.get(conf), outDir);\n    FileUtil.fullyDelete(new File(outDir.toString()));\n  }","id":74842,"modified_method":"public void testMapFileOutputCommitter() throws Exception {\n    JobConf conf = new JobConf();\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    JobContext jContext = new JobContextImpl(conf, taskID.getJobID());\n    TaskAttemptContext tContext = new TaskAttemptContextImpl(conf, taskID);\n    FileOutputCommitter committer = new FileOutputCommitter();    \n    \n    // setup\n    committer.setupJob(jContext);\n    committer.setupTask(tContext);\n\n    // write output\n    MapFileOutputFormat theOutputFormat = new MapFileOutputFormat();\n    RecordWriter theRecordWriter = theOutputFormat.getRecordWriter(null, conf, partFile, null);\n    writeMapFileOutput(theRecordWriter, tContext);\n\n    // do commit\n    if(committer.needsTaskCommit(tContext)) {\n      committer.commitTask(tContext);\n    }\n    committer.commitJob(jContext);\n\n    // validate output\n    validateMapFileOutputContent(FileSystem.get(conf), outDir);\n    FileUtil.fullyDelete(new File(outDir.toString()));\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"public void testCommitter() throws Exception {\n    JobConf conf = new JobConf();\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    JobContext jContext = new JobContextImpl(conf, taskID.getJobID());\n    TaskAttemptContext tContext = new TaskAttemptContextImpl(conf, taskID);\n    FileOutputCommitter committer = new FileOutputCommitter();\n\n    // setup\n    committer.setupJob(jContext);\n    committer.setupTask(tContext);\n\n    // write output\n    TextOutputFormat theOutputFormat = new TextOutputFormat();\n    RecordWriter theRecordWriter = \n        theOutputFormat.getRecordWriter(null, conf, partFile, null);\n    writeOutput(theRecordWriter, tContext);\n\n    // do commit\n    committer.commitTask(tContext);\n    committer.commitJob(jContext);\n\n    // validate output\n    validateContent(outDir);\n    FileUtil.fullyDelete(new File(outDir.toString()));\n  }","id":74843,"modified_method":"public void testCommitter() throws Exception {\n    JobConf conf = new JobConf();\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    JobContext jContext = new JobContextImpl(conf, taskID.getJobID());\n    TaskAttemptContext tContext = new TaskAttemptContextImpl(conf, taskID);\n    FileOutputCommitter committer = new FileOutputCommitter();\n\n    // setup\n    committer.setupJob(jContext);\n    committer.setupTask(tContext);\n\n    // write output\n    TextOutputFormat theOutputFormat = new TextOutputFormat();\n    RecordWriter theRecordWriter = \n        theOutputFormat.getRecordWriter(null, conf, partFile, null);\n    writeOutput(theRecordWriter, tContext);\n\n    // do commit\n    if(committer.needsTaskCommit(tContext)) {\n      committer.commitTask(tContext);\n    }\n    committer.commitJob(jContext);\n\n    // validate output\n    validateContent(outDir);\n    FileUtil.fullyDelete(new File(outDir.toString()));\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"public void testRecovery() throws Exception {\n    JobConf conf = new JobConf();\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    conf.setInt(MRConstants.APPLICATION_ATTEMPT_ID, 1);\n    JobContext jContext = new JobContextImpl(conf, taskID.getJobID());\n    TaskAttemptContext tContext = new TaskAttemptContextImpl(conf, taskID);\n    FileOutputCommitter committer = new FileOutputCommitter();\n\n    // setup\n    committer.setupJob(jContext);\n    committer.setupTask(tContext);\n\n    // write output\n    TextOutputFormat theOutputFormat = new TextOutputFormat();\n    RecordWriter theRecordWriter = \n        theOutputFormat.getRecordWriter(null, conf, partFile, null);\n    writeOutput(theRecordWriter, tContext);\n\n    // do commit\n    committer.commitTask(tContext);\n    Path jobTempDir1 = committer.getCommittedTaskPath(tContext);\n    File jtd1 = new File(jobTempDir1.toUri().getPath());\n    assertTrue(jtd1.exists());\n    validateContent(jobTempDir1);        \n    \n    //now while running the second app attempt, \n    //recover the task output from first attempt\n    JobConf conf2 = new JobConf(conf);\n    conf2.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    conf2.setInt(MRConstants.APPLICATION_ATTEMPT_ID, 2);\n    JobContext jContext2 = new JobContextImpl(conf2, taskID.getJobID());\n    TaskAttemptContext tContext2 = new TaskAttemptContextImpl(conf2, taskID);\n    FileOutputCommitter committer2 = new FileOutputCommitter();\n    committer2.setupJob(jContext2);\n    Path jobTempDir2 = committer2.getCommittedTaskPath(tContext2);\n    \n    committer2.recoverTask(tContext2);\n    File jtd2 = new File(jobTempDir2.toUri().getPath());\n    assertTrue(jtd2.exists());\n    validateContent(jobTempDir2);\n    \n    committer2.commitJob(jContext2);\n    validateContent(outDir);\n    FileUtil.fullyDelete(new File(outDir.toString()));\n  }","id":74844,"modified_method":"public void testRecovery() throws Exception {\n    JobConf conf = new JobConf();\n    FileOutputFormat.setOutputPath(conf, outDir);\n    conf.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    conf.setInt(MRConstants.APPLICATION_ATTEMPT_ID, 1);\n    JobContext jContext = new JobContextImpl(conf, taskID.getJobID());\n    TaskAttemptContext tContext = new TaskAttemptContextImpl(conf, taskID);\n    FileOutputCommitter committer = new FileOutputCommitter();\n\n    // setup\n    committer.setupJob(jContext);\n    committer.setupTask(tContext);\n\n    // write output\n    TextOutputFormat theOutputFormat = new TextOutputFormat();\n    RecordWriter theRecordWriter = \n        theOutputFormat.getRecordWriter(null, conf, partFile, null);\n    writeOutput(theRecordWriter, tContext);\n\n    // do commit\n    if(committer.needsTaskCommit(tContext)) {\n      committer.commitTask(tContext);\n    }\n    Path jobTempDir1 = committer.getCommittedTaskPath(tContext);\n    File jtd1 = new File(jobTempDir1.toUri().getPath());\n    assertTrue(jtd1.exists());\n    validateContent(jobTempDir1);        \n    \n    //now while running the second app attempt, \n    //recover the task output from first attempt\n    JobConf conf2 = new JobConf(conf);\n    conf2.set(JobContext.TASK_ATTEMPT_ID, attempt);\n    conf2.setInt(MRConstants.APPLICATION_ATTEMPT_ID, 2);\n    JobContext jContext2 = new JobContextImpl(conf2, taskID.getJobID());\n    TaskAttemptContext tContext2 = new TaskAttemptContextImpl(conf2, taskID);\n    FileOutputCommitter committer2 = new FileOutputCommitter();\n    committer2.setupJob(jContext2);\n    Path jobTempDir2 = committer2.getCommittedTaskPath(tContext2);\n    \n    committer2.recoverTask(tContext2);\n    File jtd2 = new File(jobTempDir2.toUri().getPath());\n    assertTrue(jtd2.exists());\n    validateContent(jobTempDir2);\n    \n    committer2.commitJob(jContext2);\n    validateContent(outDir);\n    FileUtil.fullyDelete(new File(outDir.toString()));\n  }","commit_id":"9f2b77aee496b0636aabafa61f13903f28bd86fe","url":"https://github.com/apache/hadoop"},{"original_method":"private static void createClasspathIndex(final ModuleChunk chunk, boolean forTests) {\n    final Set<File> outputPaths = new LinkedHashSet<File>();\n    for (Module module : chunk.getModules()) {\n      if (forTests) {\n        outputPaths.add(new File(module.getTestOutputPath()));\n      }\n      else {\n        outputPaths.add(new File(module.getOutputPath()));\n      }\n    }\n    for (File outputRoot : outputPaths) {\n      try {\n        BufferedWriter writer = new BufferedWriter(new FileWriter(new File(outputRoot, CLASSPATH_INDEX_FINE_NAME)));\n        try {\n          writeIndex(writer, outputRoot, \"\");\n        }\n        finally {\n          writer.close();\n        }\n      }\n      catch (IOException e) {\n        // Ignore. Failed to create optional classpath index\n      }\n    }\n  }","id":74845,"modified_method":"private static void createClasspathIndex(final ModuleChunk chunk, boolean forTests) {\n    final Set<File> outputPaths = new LinkedHashSet<File>();\n    for (Module module : chunk.getModules()) {\n      final String out = forTests? module.getTestOutputPath() : module.getOutputPath();\n      if (out != null) {\n        outputPaths.add(new File(out));\n      }\n    }\n    for (File outputRoot : outputPaths) {\n      try {\n        BufferedWriter writer = new BufferedWriter(new FileWriter(new File(outputRoot, CLASSPATH_INDEX_FINE_NAME)));\n        try {\n          writeIndex(writer, outputRoot, \"\");\n        }\n        finally {\n          writer.close();\n        }\n      }\n      catch (IOException e) {\n        // Ignore. Failed to create optional classpath index\n      }\n    }\n  }","commit_id":"4da01b7bab374266b8599a1d60beaaffa2bfa177","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"/**\n     * Will be called after each bundle load. We use it to know when the last bundle loaded so we can\n     * post a notification for it. Note that the bundles will get loaded in the order of the classpath\n     * but the main bundle will get loaded last. So in order to set the properties correctly,\n     * we first add all the props that are not already set, then we add the main bundle and the WebObjects.properties\n     * and finally the command line props.\n     * @param n\n     */\n    public static void bundleDidLoad(NSNotification n) {\n    \tNSBundle bundle = (NSBundle) n.object();\n    \t// System.out.println(bundle.name() + \": \" + allFrameworks);\n    \tallFrameworks.remove(bundle.name());\n    \tif(allBundleProps == null) {\n    \t\tallBundleProps = new Properties();\n    \t}\n    \tProperties bundleProps = bundle.properties();\n    \tif(bundleProps != null) {\n    \t\tfor (Iterator iter = bundleProps.entrySet().iterator(); iter.hasNext();) {\n    \t\t\tMap.Entry entry = (Map.Entry) iter.next();\n    \t\t\tif(!allBundleProps.containsKey(entry.getKey())) {\n    \t\t\t\tallBundleProps.setProperty((String)entry.getKey(), (String)entry.getValue());\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tif(allFrameworks.size() == 0) {\n    \t\tProperties mainProps = null;\n    \t\tif(NSBundle.mainBundle() != null) {\n    \t\t\tmainProps = NSBundle.mainBundle().properties();\n    \t\t} \n    \t\tif(mainProps == null) {\n    \t\t\tString woUserDir = NSProperties.getProperty(\"webobjects.user.dir\");\n    \t\t\tif(woUserDir == null) {\n    \t\t\t\twoUserDir = System.getProperty(\"user.dir\");\n    \t\t\t}\n    \t\t\tmainProps = readProperties(new File(woUserDir, \"Contents\" + File.separator + \"Resources\" + File.separator + \"Properties\"));\n    \t\t}\n    \t\tallBundleProps.putAll(mainProps);\n    \t\t\n    \t\tString userhome = System.getProperty(\"user.home\");\n    \t\tProperties userProps = new Properties();\n    \t\tif(userhome != null && userhome.length() > 0) {\n    \t\t\tuserProps = readProperties(new File(userhome, \"WebObjects.properties\"));\n    \t\t}\n    \t\tallBundleProps.putAll(userProps);\n    \t\t\n\t\t\tProperties props = NSProperties._getProperties();\n\t\t\tprops.putAll(allBundleProps);\n\t\t\tNSProperties._setProperties(props);\n\t\t\tNSNotificationCenter.defaultCenter().postNotification(new NSNotification(AllBundlesLoadedNotification, NSKeyValueCoding.NullValue));\n    \t}\n    }","id":74846,"modified_method":"/**\n     * Will be called after each bundle load. We use it to know when the last bundle loaded so we can\n     * post a notification for it. Note that the bundles will get loaded in the order of the classpath\n     * but the main bundle will get loaded last. So in order to set the properties correctly,\n     * we first add all the props that are not already set, then we add the main bundle and the WebObjects.properties\n     * and finally the command line props.\n     * @param n\n     */\n    public static void bundleDidLoad(NSNotification n) {\n    \tNSBundle bundle = (NSBundle) n.object();\n    \t// System.out.println(bundle.name() + \": \" + allFrameworks);\n    \tallFrameworks.remove(bundle.name());\n    \tif(allBundleProps == null) {\n    \t\tallBundleProps = new Properties();\n    \t}\n    \tProperties bundleProps = bundle.properties();\n    \tif(bundleProps != null) {\n    \t\tfor (Iterator iter = bundleProps.entrySet().iterator(); iter.hasNext();) {\n    \t\t\tMap.Entry entry = (Map.Entry) iter.next();\n    \t\t\tif(!allBundleProps.containsKey(entry.getKey())) {\n    \t\t\t\tallBundleProps.setProperty((String)entry.getKey(), (String)entry.getValue());\n    \t\t\t}\n    \t\t}\n    \t}\n\n    \tif(allFrameworks.size() == 0) {\n    \t\tProperties mainProps = null;\n    \t\tNSBundle mainBundle = null;\n    \t\tString mainBundleName = NSProperties._mainBundleName();\n            if(mainBundleName != null) {\n            \tmainBundle = NSBundle.bundleForName(mainBundleName);\n            } \n            if(mainBundle == null) {\n            \tmainBundle = NSBundle.mainBundle();\n            }\n            if(mainBundle == null) {\n            \t// AK: when we get here, the main bundle wasn't inited yet\n            \t// so we do it ourself...\n            \ttry {\n\t\t\t\t\tMethod init = NSBundle.class.getDeclaredMethod(\"InitMainBundle\", null);\n\t            \tinit.setAccessible(true);\n\t            \tinit.invoke(NSBundle.class, null);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tSystem.err.println(e);\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n            \tmainBundle = NSBundle.mainBundle();\n            }\n            if(mainBundle != null) {\n    \t\t\tmainProps = NSBundle.mainBundle().properties();\n    \t\t} \n    \t\tif(mainProps == null) {\n    \t\t\tString woUserDir = NSProperties.getProperty(\"webobjects.user.dir\");\n    \t\t\tif(woUserDir == null) {\n    \t\t\t\twoUserDir = System.getProperty(\"user.dir\");\n    \t\t\t}\n    \t\t\tmainProps = readProperties(new File(woUserDir, \"Contents\" + File.separator + \"Resources\" + File.separator + \"Properties\"));\n    \t\t}\n    \t\tallBundleProps.putAll(mainProps);\n    \t\t\n    \t\tString userhome = System.getProperty(\"user.home\");\n    \t\tProperties userProps = new Properties();\n    \t\tif(userhome != null && userhome.length() > 0) {\n    \t\t\tuserProps = readProperties(new File(userhome, \"WebObjects.properties\"));\n    \t\t}\n    \t\tallBundleProps.putAll(userProps);\n    \t\t\n\t\t\tProperties props = NSProperties._getProperties();\n\t\t\tprops.putAll(allBundleProps);\n\t\t\tNSProperties._setProperties(props);\n\t\t\tNSNotificationCenter.defaultCenter().postNotification(new NSNotification(AllBundlesLoadedNotification, NSKeyValueCoding.NullValue));\n    \t}\n    }","commit_id":"0196f86a0cdb0524c96a9fee7e13fd798ca33cca","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n     * Returns the path to the application-specific system-wide file \"fileName\".  By default this path is /etc/WebObjects, \n     * and the application name will be appended.  For instance, if you are asking for the MyApp Properties file for the\n     * system, it would go in /etc/WebObjects/MyApp/Properties.\n     * \n     * @return the path, or null if the path does not exist\n     */\n    public static String applicationMachinePropertiesPath(String fileName) {\n    \tString applicationMachinePropertiesPath = null;\n    \tString machinePropertiesPath = ERXSystem.getProperty(\"er.extensions.ERXProperties.machinePropertiesPath\", \"/etc/WebObjects\");\n    \tWOApplication application = WOApplication.application();\n    \tString applicationName;\n    \tif (application != null) {\n    \t\tapplicationName = application.name();\n    \t}\n    \telse {\n    \t\tapplicationName = ERXSystem.getProperty(\"WOApplicationName\");\n    \t\tif (applicationName == null) {\n    \t\t\tapplicationName = NSBundle.mainBundle().name();\n    \t\t\tif (applicationName == null) {\n    \t\t\t\tapplicationName = \"Unknown\";\n    \t\t\t}\n    \t\t}\n    \t}\n    \tFile applicationPropertiesFile = new File(machinePropertiesPath + File.separator + fileName);\n    \tif (!applicationPropertiesFile.exists()) {\n    \t\tapplicationPropertiesFile = new File(machinePropertiesPath + File.separator + applicationName + File.separator + fileName);\n    \t}\n    \tif (applicationPropertiesFile.exists()) {\n    \t\ttry {\n    \t\t\tapplicationMachinePropertiesPath = applicationPropertiesFile.getCanonicalPath();\n    \t\t}\n    \t\tcatch (IOException e) {\n    \t\t\tERXProperties.log.error(\"Failed to load machine Properties file '\" + fileName + \"'.\", e);\n    \t\t}\n    \t}\n    \treturn applicationMachinePropertiesPath;\n    }","id":74847,"modified_method":"/**\n     * Returns the path to the application-specific system-wide file \"fileName\".  By default this path is /etc/WebObjects, \n     * and the application name will be appended.  For instance, if you are asking for the MyApp Properties file for the\n     * system, it would go in /etc/WebObjects/MyApp/Properties.\n     * \n     * @return the path, or null if the path does not exist\n     */\n    public static String applicationMachinePropertiesPath(String fileName) {\n    \tString applicationMachinePropertiesPath = null;\n    \tString machinePropertiesPath = ERXSystem.getProperty(\"er.extensions.ERXProperties.machinePropertiesPath\", \"/etc/WebObjects\");\n    \tWOApplication application = WOApplication.application();\n    \tString applicationName;\n    \tif (application != null) {\n    \t\tapplicationName = application.name();\n    \t}\n    \telse {\n    \t\tapplicationName = ERXSystem.getProperty(\"WOApplicationName\");\n    \t\tif (applicationName == null) {\n    \t\t\tNSBundle mainBundle = NSBundle.mainBundle();\n    \t\t\tif (mainBundle != null) {\n    \t\t\t\tapplicationName = mainBundle.name();\n    \t\t\t}\n    \t\t\tif (applicationName == null) {\n    \t\t\t\tapplicationName = \"Unknown\";\n    \t\t\t}\n    \t\t}\n    \t}\n    \tFile applicationPropertiesFile = new File(machinePropertiesPath + File.separator + fileName);\n    \tif (!applicationPropertiesFile.exists()) {\n    \t\tapplicationPropertiesFile = new File(machinePropertiesPath + File.separator + applicationName + File.separator + fileName);\n    \t}\n    \tif (applicationPropertiesFile.exists()) {\n    \t\ttry {\n    \t\t\tapplicationMachinePropertiesPath = applicationPropertiesFile.getCanonicalPath();\n    \t\t}\n    \t\tcatch (IOException e) {\n    \t\t\tERXProperties.log.error(\"Failed to load machine Properties file '\" + fileName + \"'.\", e);\n    \t\t}\n    \t}\n    \treturn applicationMachinePropertiesPath;\n    }","commit_id":"a89a2da99b654426bd4d5d4317969421b17520a4","url":"https://github.com/wocommunity/wonder"},{"original_method":"public static NSArray pathsForUserAndBundleProperties(boolean reportLoggingEnabled) {\n        NSMutableArray<String> propertiesPaths = new NSMutableArray();\n        NSMutableArray<String> projectsInfo = new NSMutableArray();\n\n        /*  Properties for frameworks */\n        NSArray frameworkNames = (NSArray) NSBundle.frameworkBundles().valueForKey(\"name\");\n        Enumeration e = frameworkNames.reverseObjectEnumerator();\n        while (e.hasMoreElements()) {\n        \tString frameworkName = (String) e.nextElement();\n\n        \tString propertyPath = ERXFileUtilities.pathForResourceNamed(\"Properties\", frameworkName, null);\n        \taddIfPresent(frameworkName + \".framework\", propertyPath, propertiesPaths, projectsInfo);\n\n        \t/** Properties.<userName> -- per-Framework-per-User properties */\n        \tString userPropertiesPath = ERXProperties.variantPropertiesInBundle(ERXSystem.getProperty(\"user.name\"), frameworkName);\n        \taddIfPresent(frameworkName + \".framework.user\", userPropertiesPath, propertiesPaths, projectsInfo);\n        }\n\n        String mainBundleName = NSBundle.mainBundle().name();\n\n        String appPath = ERXFileUtilities.pathForResourceNamed(\"Properties\", \"app\", null);\n    \taddIfPresent(mainBundleName + \".app\", appPath, propertiesPaths, projectsInfo);\n\n\t\t/*  WebObjects.properties in the user home directory */\n\t\tString userHome = ERXSystem.getProperty(\"user.home\");\n\t\tif (userHome != null && userHome.length() > 0) {\n\t\t\tFile file = new File(userHome, \"WebObjects.properties\");\n\t\t\tif (file.exists() && file.isFile() && file.canRead()) {\n\t\t\t\ttry {\n\t\t\t\t\tString userHomePath = file.getCanonicalPath();\n\t\t\t    \taddIfPresent(\"{$user.home}/WebObjects.properties\", userHomePath, propertiesPaths, projectsInfo);\n\t\t\t\t}\n\t\t\t\tcatch (java.io.IOException ex) {\n\t\t\t\t\tERXProperties.log.error(\"Failed to load the configuration file '\" + file.getAbsolutePath() + \"'.\", ex);\n\t\t\t\t}\n\t\t\t}\n        }\n\n\t\t/*  Optional properties files */\n\t\tif (optionalConfigurationFiles() != null && optionalConfigurationFiles().count() > 0) {\n\t\t\tfor (Enumeration configEnumerator = optionalConfigurationFiles().objectEnumerator(); configEnumerator.hasMoreElements();) {\n\t\t\t\tString configFile = (String) configEnumerator.nextElement();\n\t\t\t\tFile file = new File(configFile);\n\t\t\t\tif (file.exists() && file.isFile() && file.canRead()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString optionalPath = file.getCanonicalPath();\n\t\t\t\t    \taddIfPresent(\"Optional Configuration\", optionalPath, propertiesPaths, projectsInfo);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.io.IOException ex) {\n\t\t\t\t\t\tERXProperties.log.error(\"Failed to load configuration file '\" + file.getAbsolutePath() + \"'.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tERXProperties.log.error(\"The optional configuration file '\" + file.getAbsolutePath() + \"' either does not exist or could not be read.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        /** /etc/WebObjects/AppName/Properties -- per-Application-per-Machine properties */\n        String applicationMachinePropertiesPath = ERXProperties.applicationMachinePropertiesPath(\"Properties\");\n    \taddIfPresent(\"Application-Machine Properties\", applicationMachinePropertiesPath, propertiesPaths, projectsInfo);\n\n        /** Properties.<userName> -- per-Application-per-User properties */\n        String applicationDeveloperPropertiesPath = ERXProperties.applicationDeveloperProperties();\n    \taddIfPresent(\"Application-Developer Properties\", applicationDeveloperPropertiesPath, propertiesPaths, projectsInfo);\n\n        /** Properties.<userName> -- per-Application-per-User properties */\n        String applicationUserPropertiesPath = ERXProperties.applicationUserProperties();\n    \taddIfPresent(\"Application-User Properties\", applicationUserPropertiesPath, propertiesPaths, projectsInfo);\n        \n        /*  Report the result */\n\t\tif (reportLoggingEnabled && projectsInfo.count() > 0 && log.isInfoEnabled()) {\n\t\t\tStringBuffer message = new StringBuffer();\n\t\t\tmessage.append(\"\\n\\n\").append(\"ERXProperties has found the following Properties files: \\n\");\n\t\t\tmessage.append(projectsInfo.componentsJoinedByString(\"\\n\"));\n\t\t\tmessage.append(\"\\n\");\n\t\t\tmessage.append(\"ERXProperties currently has the following properties:\\n\");\n\t\t\tmessage.append(ERXProperties.logString(ERXSystem.getProperties()));\n\t\t\t// ERXLogger.configureLoggingWithSystemProperties();\n\t\t\tlog.info(message.toString());\n\t\t}\n\n    \treturn propertiesPaths.immutableClone();\n    }","id":74848,"modified_method":"public static NSArray pathsForUserAndBundleProperties(boolean reportLoggingEnabled) {\n        NSMutableArray<String> propertiesPaths = new NSMutableArray();\n        NSMutableArray<String> projectsInfo = new NSMutableArray();\n\n        /*  Properties for frameworks */\n        NSArray frameworkNames = (NSArray) NSBundle.frameworkBundles().valueForKey(\"name\");\n        Enumeration e = frameworkNames.reverseObjectEnumerator();\n        while (e.hasMoreElements()) {\n        \tString frameworkName = (String) e.nextElement();\n\n        \tString propertyPath = ERXFileUtilities.pathForResourceNamed(\"Properties\", frameworkName, null);\n        \taddIfPresent(frameworkName + \".framework\", propertyPath, propertiesPaths, projectsInfo);\n\n        \t/** Properties.<userName> -- per-Framework-per-User properties */\n        \tString userPropertiesPath = ERXProperties.variantPropertiesInBundle(ERXSystem.getProperty(\"user.name\"), frameworkName);\n        \taddIfPresent(frameworkName + \".framework.user\", userPropertiesPath, propertiesPaths, projectsInfo);\n        }\n\n\t\tNSBundle mainBundle = NSBundle.mainBundle();\n\t\t\n\t\tif( mainBundle != null ) {\n\t        String mainBundleName = mainBundle.name();\n\t\n\t        String appPath = ERXFileUtilities.pathForResourceNamed(\"Properties\", \"app\", null);\n\t    \taddIfPresent(mainBundleName + \".app\", appPath, propertiesPaths, projectsInfo);\n\t\t}\n\n\t\t/*  WebObjects.properties in the user home directory */\n\t\tString userHome = ERXSystem.getProperty(\"user.home\");\n\t\tif (userHome != null && userHome.length() > 0) {\n\t\t\tFile file = new File(userHome, \"WebObjects.properties\");\n\t\t\tif (file.exists() && file.isFile() && file.canRead()) {\n\t\t\t\ttry {\n\t\t\t\t\tString userHomePath = file.getCanonicalPath();\n\t\t\t    \taddIfPresent(\"{$user.home}/WebObjects.properties\", userHomePath, propertiesPaths, projectsInfo);\n\t\t\t\t}\n\t\t\t\tcatch (java.io.IOException ex) {\n\t\t\t\t\tERXProperties.log.error(\"Failed to load the configuration file '\" + file.getAbsolutePath() + \"'.\", ex);\n\t\t\t\t}\n\t\t\t}\n        }\n\n\t\t/*  Optional properties files */\n\t\tif (optionalConfigurationFiles() != null && optionalConfigurationFiles().count() > 0) {\n\t\t\tfor (Enumeration configEnumerator = optionalConfigurationFiles().objectEnumerator(); configEnumerator.hasMoreElements();) {\n\t\t\t\tString configFile = (String) configEnumerator.nextElement();\n\t\t\t\tFile file = new File(configFile);\n\t\t\t\tif (file.exists() && file.isFile() && file.canRead()) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString optionalPath = file.getCanonicalPath();\n\t\t\t\t    \taddIfPresent(\"Optional Configuration\", optionalPath, propertiesPaths, projectsInfo);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (java.io.IOException ex) {\n\t\t\t\t\t\tERXProperties.log.error(\"Failed to load configuration file '\" + file.getAbsolutePath() + \"'.\", ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tERXProperties.log.error(\"The optional configuration file '\" + file.getAbsolutePath() + \"' either does not exist or could not be read.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        /** /etc/WebObjects/AppName/Properties -- per-Application-per-Machine properties */\n        String applicationMachinePropertiesPath = ERXProperties.applicationMachinePropertiesPath(\"Properties\");\n    \taddIfPresent(\"Application-Machine Properties\", applicationMachinePropertiesPath, propertiesPaths, projectsInfo);\n\n        /** Properties.<userName> -- per-Application-per-User properties */\n        String applicationDeveloperPropertiesPath = ERXProperties.applicationDeveloperProperties();\n    \taddIfPresent(\"Application-Developer Properties\", applicationDeveloperPropertiesPath, propertiesPaths, projectsInfo);\n\n        /** Properties.<userName> -- per-Application-per-User properties */\n        String applicationUserPropertiesPath = ERXProperties.applicationUserProperties();\n    \taddIfPresent(\"Application-User Properties\", applicationUserPropertiesPath, propertiesPaths, projectsInfo);\n        \n        /*  Report the result */\n\t\tif (reportLoggingEnabled && projectsInfo.count() > 0 && log.isInfoEnabled()) {\n\t\t\tStringBuffer message = new StringBuffer();\n\t\t\tmessage.append(\"\\n\\n\").append(\"ERXProperties has found the following Properties files: \\n\");\n\t\t\tmessage.append(projectsInfo.componentsJoinedByString(\"\\n\"));\n\t\t\tmessage.append(\"\\n\");\n\t\t\tmessage.append(\"ERXProperties currently has the following properties:\\n\");\n\t\t\tmessage.append(ERXProperties.logString(ERXSystem.getProperties()));\n\t\t\t// ERXLogger.configureLoggingWithSystemProperties();\n\t\t\tlog.info(message.toString());\n\t\t}\n\n    \treturn propertiesPaths.immutableClone();\n    }","commit_id":"f3f6ad9bb42f7cca7ca74c509785a7a7abe019a2","url":"https://github.com/wocommunity/wonder"},{"original_method":"/**\n\t * @return a {@link JvmOperation} with common denominator argument types of all given operations\n\t */\n\tprotected JvmOperation deriveGenericDispatchOperationSignature(Collection<JvmOperation> operations) {\n\t\tif (operations.isEmpty())\n\t\t\treturn null;\n\t\tJvmOperation result = null;\n\t\tfinal Iterator<JvmOperation> iterator = operations.iterator();\n\t\tJvmOperation first = iterator.next();\n\t\tif (operations.size() == 1) {\n\t\t\tresult = EcoreUtil2.clone(first);\n\t\t} else {\n\t\t\tresult = typesFactory.createJvmOperation();\n\t\t\tfor (int i = 0; i < first.getParameters().size(); i++) {\n\t\t\t\tJvmFormalParameter parameter2 = first.getParameters().get(i);\n\t\t\t\tfinal int index = i;\n\t\t\t\tJvmTypeReference commonType = commonType(operations, new Function<JvmOperation, JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference apply(JvmOperation from) {\n\t\t\t\t\t\treturn from.getParameters().get(index).getParameterType();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tJvmFormalParameter parameter = typesFactory.createJvmFormalParameter();\n\t\t\t\tparameter.setName(parameter2.getName());\n\t\t\t\tparameter.setParameterType(EcoreUtil2.cloneIfContained(commonType));\n\t\t\t\tresult.getParameters().add(parameter);\n\t\t\t}\n\t\t}\n\t\tfor (JvmOperation jvmOperation : operations) {\n\t\t\tIterable<XtendFunction> xtendFunctions = associator.getAssociatedElements(jvmOperation, XtendFunction.class);\n\t\t\tfor (XtendFunction func : xtendFunctions) {\n\t\t\t\tassociator.associate(func, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":74849,"modified_method":"/**\n\t * @return a {@link JvmOperation} with common denominator argument types of all given operations\n\t */\n\tprotected JvmOperation deriveGenericDispatchOperationSignature(Collection<JvmOperation> operations) {\n\t\tif (operations.isEmpty())\n\t\t\treturn null;\n\t\tJvmOperation result = null;\n\t\tfinal Iterator<JvmOperation> iterator = operations.iterator();\n\t\tJvmOperation first = iterator.next();\n\t\tif (operations.size() == 1) {\n\t\t\tresult = EcoreUtil2.clone(first);\n\t\t} else {\n\t\t\tresult = typesFactory.createJvmOperation();\n\t\t\tfor (int i = 0; i < first.getParameters().size(); i++) {\n\t\t\t\tJvmFormalParameter parameter2 = first.getParameters().get(i);\n\t\t\t\tfinal int index = i;\n\t\t\t\tJvmTypeReference commonType = commonType(operations, new Function<JvmOperation, JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference apply(JvmOperation from) {\n\t\t\t\t\t\treturn from.getParameters().get(index).getParameterType();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tJvmFormalParameter parameter = typesFactory.createJvmFormalParameter();\n\t\t\t\tparameter.setName(parameter2.getName());\n\t\t\t\tif (commonType != null)\n\t\t\t\t\tparameter.setParameterType(EcoreUtil2.cloneIfContained(commonType));\n\t\t\t\tresult.getParameters().add(parameter);\n\t\t\t}\n\t\t}\n\t\tfor (JvmOperation jvmOperation : operations) {\n\t\t\tIterable<XtendFunction> xtendFunctions = associator.getAssociatedElements(jvmOperation, XtendFunction.class);\n\t\t\tfor (XtendFunction func : xtendFunctions) {\n\t\t\t\tassociator.associate(func, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"0b0afbef318ace34029b051eef65748a5312ec28","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * Delegates to the BatchLinkingService to resolve all references. The linking service\n\t * is responsible to lock the resource or resource set. \n\t */\n\t@Override\n\tpublic void resolveLazyCrossReferences(CancelIndicator monitor) {\n\t\tIParseResult parseResult = getParseResult();\n\t\tif (parseResult != null) {\n\t\t\tbatchLinkingService.resolveBatched(parseResult.getRootASTElement());\n\t\t}\n\t\tif (!monitor.isCanceled())\n\t\t\tsuper.resolveLazyCrossReferences(monitor);\n\t}","id":74850,"modified_method":"/**\n\t * Delegates to the BatchLinkingService to resolve all references. The linking service\n\t * is responsible to lock the resource or resource set. \n\t */\n\t@Override\n\tpublic void resolveLazyCrossReferences(CancelIndicator monitor) {\n\t\tIParseResult parseResult = getParseResult();\n\t\tif (parseResult != null) {\n\t\t\tbatchLinkingService.resolveBatched(parseResult.getRootASTElement());\n\t\t}\n\t\tif (monitor == null || !monitor.isCanceled())\n\t\t\tsuper.resolveLazyCrossReferences(monitor);\n\t}","commit_id":"b5d9667e7b6526b31ea3cc8778c6aa9a771361f9","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\tprotected void clearReference(EObject obj, EReference ref) {\n\t\tsuper.clearReference(obj, ref);\n\t\tif (obj instanceof XAbstractFeatureCall) {\n\t\t\tXAbstractFeatureCall featureCall = (XAbstractFeatureCall) obj;\n\t\t\tfeatureCall.setImplicitReceiver(null);\n\t\t\tfeatureCall.setInvalidFeatureIssueCode(null);\n\t\t\tfeatureCall.setImplicitFirstArgument(null);\n\t\t} else if (obj instanceof JvmSpecializedTypeReference) {\n\t\t\t((JvmSpecializedTypeReference) obj).setEquivalent(null);\n\t\t\tif (ref == XtypePackage.Literals.XFUNCTION_TYPE_REF__TYPE) {\n\t\t\t\tobj.eUnset(ref);\n\t\t\t}\n\t\t} else if (obj instanceof JvmFormalParameter && obj.eContainingFeature() == XbasePackage.Literals.XCLOSURE__IMPLICIT_PARAMETER) {\n\t\t\tJvmFormalParameter parameter = (JvmFormalParameter) obj;\n\t\t\tparameter.setParameterType(null);\n\t\t}\n\t}","id":74851,"modified_method":"@Override\n\tprotected void clearReference(EObject obj, EReference ref) {\n\t\tsuper.clearReference(obj, ref);\n\t\tif (obj instanceof XAbstractFeatureCall) {\n\t\t\tXAbstractFeatureCall featureCall = (XAbstractFeatureCall) obj;\n\t\t\tfeatureCall.setImplicitReceiver(null);\n\t\t\tfeatureCall.setInvalidFeatureIssueCode(null);\n\t\t\tfeatureCall.setImplicitFirstArgument(null);\n\t\t} else if (obj instanceof JvmSpecializedTypeReference) {\n\t\t\t((JvmSpecializedTypeReference) obj).setEquivalent(null);\n\t\t\tif (ref == XtypePackage.Literals.XFUNCTION_TYPE_REF__TYPE) {\n\t\t\t\tobj.eUnset(ref);\n\t\t\t}\n\t\t} else if (obj instanceof XClosure) {\n\t\t\t// EMF 2.5 does not dive into derived contained things thus we do it explicitly\n\t\t\tJvmFormalParameter implicitParameter = ((XClosure) obj).getImplicitParameter();\n\t\t\tif (implicitParameter != null)\n\t\t\t\timplicitParameter.setParameterType(null);\n\t\t}\n\t}","commit_id":"b5d9667e7b6526b31ea3cc8778c6aa9a771361f9","url":"https://github.com/eclipse/xtext"},{"original_method":"/**\n\t * @return a {@link JvmOperation} with common denominator argument types of all given operations\n\t */\n\tprotected JvmOperation deriveGenericDispatchOperationSignature(Collection<JvmOperation> operations) {\n\t\tif (operations.isEmpty())\n\t\t\treturn null;\n\t\tJvmOperation result = null;\n\t\tfinal Iterator<JvmOperation> iterator = operations.iterator();\n\t\tJvmOperation first = iterator.next();\n\t\tif (operations.size() == 1) {\n\t\t\tresult = EcoreUtil2.clone(first);\n\t\t} else {\n\t\t\tresult = typesFactory.createJvmOperation();\n\t\t\tfor (int i = 0; i < first.getParameters().size(); i++) {\n\t\t\t\tJvmFormalParameter parameter2 = first.getParameters().get(i);\n\t\t\t\tfinal int index = i;\n\t\t\t\tJvmTypeReference commonType = commonType(operations, new Function<JvmOperation, JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference apply(JvmOperation from) {\n\t\t\t\t\t\treturn from.getParameters().get(index).getParameterType();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tJvmFormalParameter parameter = typesFactory.createJvmFormalParameter();\n\t\t\t\tparameter.setName(parameter2.getName());\n\t\t\t\tparameter.setParameterType(EcoreUtil2.cloneIfContained(commonType));\n\t\t\t\tresult.getParameters().add(parameter);\n\t\t\t}\n\t\t}\n\t\tfor (JvmOperation jvmOperation : operations) {\n\t\t\tIterable<XtendFunction> xtendFunctions = associator.getAssociatedElements(jvmOperation, XtendFunction.class);\n\t\t\tfor (XtendFunction func : xtendFunctions) {\n\t\t\t\tassociator.associate(func, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","id":74852,"modified_method":"/**\n\t * @return a {@link JvmOperation} with common denominator argument types of all given operations\n\t */\n\tprotected JvmOperation deriveGenericDispatchOperationSignature(Collection<JvmOperation> operations) {\n\t\tif (operations.isEmpty())\n\t\t\treturn null;\n\t\tJvmOperation result = null;\n\t\tfinal Iterator<JvmOperation> iterator = operations.iterator();\n\t\tJvmOperation first = iterator.next();\n\t\tif (operations.size() == 1) {\n\t\t\tresult = EcoreUtil2.clone(first);\n\t\t} else {\n\t\t\tresult = typesFactory.createJvmOperation();\n\t\t\tfor (int i = 0; i < first.getParameters().size(); i++) {\n\t\t\t\tJvmFormalParameter parameter2 = first.getParameters().get(i);\n\t\t\t\tfinal int index = i;\n\t\t\t\tJvmTypeReference commonType = commonType(operations, new Function<JvmOperation, JvmTypeReference>() {\n\t\t\t\t\tpublic JvmTypeReference apply(JvmOperation from) {\n\t\t\t\t\t\treturn from.getParameters().get(index).getParameterType();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tJvmFormalParameter parameter = typesFactory.createJvmFormalParameter();\n\t\t\t\tparameter.setName(parameter2.getName());\n\t\t\t\tif (commonType != null)\n\t\t\t\t\tparameter.setParameterType(EcoreUtil2.cloneIfContained(commonType));\n\t\t\t\tresult.getParameters().add(parameter);\n\t\t\t}\n\t\t}\n\t\tfor (JvmOperation jvmOperation : operations) {\n\t\t\tIterable<XtendFunction> xtendFunctions = associator.getAssociatedElements(jvmOperation, XtendFunction.class);\n\t\t\tfor (XtendFunction func : xtendFunctions) {\n\t\t\t\tassociator.associate(func, result);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}","commit_id":"00982ebebb17adfbe7ef4e728a227a3d949e3a1b","url":"https://github.com/eclipse/xtext"},{"original_method":"@NotNull\n  protected List<AnAction> createEditorPopupActions() {\n    return ContainerUtil.list(\n      ActionManager.getInstance().getAction(\"CompareClipboardWithSelection\")\n    );\n  }","id":74853,"modified_method":"@NotNull\n  protected List<AnAction> createEditorPopupActions() {\n    List<AnAction> result = new ArrayList<AnAction>();\n    result.add(ActionManager.getInstance().getAction(\"CompareClipboardWithSelection\"));\n\n    result.add(Separator.getInstance());\n    ContainerUtil.addAll(result, ((ActionGroup)ActionManager.getInstance().getAction(IdeActions.GROUP_DIFF_EDITOR_POPUP)).getChildren(null));\n\n    return result;\n  }","commit_id":"5998cd20ab82d56fbfa288b6f0272d46e7f77b5a","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n    public void doTest(@NotNull String filename) throws Exception {\n        File root = new File(filename);\n        final List<String> sourceFiles = new ArrayList<String>(2);\n\n        FileUtil.processFilesRecursively(root, new Processor<File>() {\n            @Override\n            public boolean process(File file) {\n                if (file.getName().endsWith(\".kt\")) {\n                    sourceFiles.add(relativePath(file));\n                    return true;\n                }\n                return true;\n            }\n        }, new Processor<File>() {\n            @Override\n            public boolean process(File file) {\n                return !LIBRARY.equals(file.getName());\n            }\n        });\n\n        File library = new File(root, LIBRARY);\n        List<File> classPath = library.exists() ?\n                               Collections.singletonList(MockLibraryUtil.compileLibraryToJar(library.getPath(), false)) :\n                               Collections.<File>emptyList();\n\n        assert !sourceFiles.isEmpty() : getTestName(true) + \" should contain at least one .kt file\";\n        Collections.sort(sourceFiles);\n\n        myEnvironment = JetCoreEnvironment.createForTests(getTestRootDisposable(), JetTestUtils.compilerConfigurationForTests(\n                ConfigurationKind.JDK_ONLY, TestJdkKind.MOCK_JDK, Arrays.asList(JetTestUtils.getAnnotationsJar()), classPath));\n\n        loadFiles(ArrayUtil.toStringArray(sourceFiles));\n\n        List<OccurrenceInfo> expected =\n                readExpectedOccurrences(JetTestCaseBuilder.getTestDataPathBase() + \"/codegen/\" + sourceFiles.get(0));\n        countAndCompareActualOccurrences(expected);\n    }","id":74854,"modified_method":"@Override\n    public void doTest(@NotNull String filename) throws Exception {\n        File root = new File(filename);\n        final List<String> sourceFiles = new ArrayList<String>(2);\n\n        FileUtil.processFilesRecursively(root, new Processor<File>() {\n            @Override\n            public boolean process(File file) {\n                if (file.getName().endsWith(\".kt\")) {\n                    sourceFiles.add(relativePath(file));\n                    return true;\n                }\n                return true;\n            }\n        }, new Processor<File>() {\n            @Override\n            public boolean process(File file) {\n                return !LIBRARY.equals(file.getName());\n            }\n        });\n\n        File library = new File(root, LIBRARY);\n        List<File> classPath = library.exists() ?\n                               Collections.singletonList(MockLibraryUtil.compileLibraryToJar(library.getPath(), LIBRARY, false)) :\n                               Collections.<File>emptyList();\n\n        assert !sourceFiles.isEmpty() : getTestName(true) + \" should contain at least one .kt file\";\n        Collections.sort(sourceFiles);\n\n        myEnvironment = JetCoreEnvironment.createForTests(getTestRootDisposable(), JetTestUtils.compilerConfigurationForTests(\n                ConfigurationKind.JDK_ONLY, TestJdkKind.MOCK_JDK, Arrays.asList(JetTestUtils.getAnnotationsJar()), classPath));\n\n        loadFiles(ArrayUtil.toStringArray(sourceFiles));\n\n        List<OccurrenceInfo> expected =\n                readExpectedOccurrences(JetTestCaseBuilder.getTestDataPathBase() + \"/codegen/\" + sourceFiles.get(0));\n        countAndCompareActualOccurrences(expected);\n    }","commit_id":"a8d77887afc20f814317d9b2be561bf5981c36af","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@NotNull\n    private File compileLibrary(@NotNull String sourcePath) {\n        return MockLibraryUtil.compileLibraryToJar(new File(getTestDataDirectory(), sourcePath).getPath(), false);\n    }","id":74855,"modified_method":"@NotNull\n    private File compileLibrary(@NotNull String sourcePath) {\n        return MockLibraryUtil.compileLibraryToJar(new File(getTestDataDirectory(), sourcePath).getPath(), \"customKotlinLib\", false);\n    }","commit_id":"a8d77887afc20f814317d9b2be561bf5981c36af","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@Override\n    public void configureModule(Module module, ModifiableRootModel model, ContentEntry contentEntry) {\n        File libraryJar = MockLibraryUtil.compileLibraryToJar(sourcesPath, withSources);\n        String jarUrl = \"jar://\" + FileUtilRt.toSystemIndependentName(libraryJar.getAbsolutePath()) + \"!/\";\n\n        Library.ModifiableModel libraryModel = model.getModuleLibraryTable().getModifiableModel().createLibrary(\"myKotlinLib\").getModifiableModel();\n        libraryModel.addRoot(jarUrl, OrderRootType.CLASSES);\n        if (withSources) {\n            libraryModel.addRoot(jarUrl + \"src/\", OrderRootType.SOURCES);\n        }\n        libraryModel.commit();\n    }","id":74856,"modified_method":"@Override\n    public void configureModule(Module module, ModifiableRootModel model, ContentEntry contentEntry) {\n        File libraryJar = MockLibraryUtil.compileLibraryToJar(sourcesPath, \"myKotlinLib,\", withSources);\n        String jarUrl = \"jar://\" + FileUtilRt.toSystemIndependentName(libraryJar.getAbsolutePath()) + \"!/\";\n\n        Library.ModifiableModel libraryModel = model.getModuleLibraryTable().getModifiableModel().createLibrary(\"myKotlinLib\").getModifiableModel();\n        libraryModel.addRoot(jarUrl, OrderRootType.CLASSES);\n        if (withSources) {\n            libraryModel.addRoot(jarUrl + \"src/\", OrderRootType.SOURCES);\n        }\n        libraryModel.commit();\n    }","commit_id":"a8d77887afc20f814317d9b2be561bf5981c36af","url":"https://github.com/JetBrains/kotlin"},{"original_method":"@SuppressWarnings(\"AssignmentToStaticFieldFromInstanceMethod\")\n    @Override\n    protected void ensureCompiledAppExists() throws Exception {\n        if (!IS_TINY_APP_COMPILED) {\n            String modulePath = getTestAppPath();\n\n            CUSTOM_LIBRARY_JAR = MockLibraryUtil.compileLibraryToJar(CUSTOM_LIBRARY_SOURCES.getPath(), true);\n\n            String outputDir = modulePath + File.separator + \"classes\";\n            String sourcesDir = modulePath + File.separator + \"src\";\n\n            MockLibraryUtil.compileKotlin(sourcesDir, new File(outputDir), CUSTOM_LIBRARY_JAR.getPath());\n\n            List<String> options = Arrays.asList(\"-d\", outputDir, \"-classpath\", ForTestCompileRuntime.runtimeJarForTests().getPath());\n            JetTestUtils.compileJavaFiles(findJavaFiles(new File(sourcesDir)), options);\n\n            IS_TINY_APP_COMPILED = true;\n        }\n    }","id":74857,"modified_method":"@SuppressWarnings(\"AssignmentToStaticFieldFromInstanceMethod\")\n    @Override\n    protected void ensureCompiledAppExists() throws Exception {\n        if (!IS_TINY_APP_COMPILED) {\n            String modulePath = getTestAppPath();\n\n            CUSTOM_LIBRARY_JAR = MockLibraryUtil.compileLibraryToJar(CUSTOM_LIBRARY_SOURCES.getPath(), \"debuggerCustomLibrary\", true);\n\n            String outputDir = modulePath + File.separator + \"classes\";\n            String sourcesDir = modulePath + File.separator + \"src\";\n\n            MockLibraryUtil.compileKotlin(sourcesDir, new File(outputDir), CUSTOM_LIBRARY_JAR.getPath());\n\n            List<String> options = Arrays.asList(\"-d\", outputDir, \"-classpath\", ForTestCompileRuntime.runtimeJarForTests().getPath());\n            JetTestUtils.compileJavaFiles(findJavaFiles(new File(sourcesDir)), options);\n\n            IS_TINY_APP_COMPILED = true;\n        }\n    }","commit_id":"a8d77887afc20f814317d9b2be561bf5981c36af","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static File compileLibraryToJar(String sourcesPath, boolean addSources) {\n        try {\n            File contentDir = JetTestUtils.tmpDir(\"lib-content\");\n\n            File classesDir = new File(contentDir, \"classes\");\n            compileKotlin(sourcesPath, classesDir);\n\n            List<File> javaFiles = FileUtil.findFilesByMask(Pattern.compile(\".*\\\\.java\"), new File(sourcesPath));\n            if (!javaFiles.isEmpty()) {\n                List<String> classPath = ContainerUtil.list(ForTestCompileRuntime.runtimeJarForTests().getPath(),\n                                                            JetTestUtils.getAnnotationsJar().getPath());\n\n                // Probably no kotlin files were present, so dir might not have been created after kotlin compiler\n                if (classesDir.exists()) {\n                    classPath.add(classesDir.getPath());\n                }\n                else {\n                    FileUtil.createDirectory(classesDir);\n                }\n\n                List<String> options = Arrays.asList(\n                        \"-classpath\", StringUtil.join(classPath, File.pathSeparator),\n                        \"-d\", classesDir.getPath()\n                );\n\n                JetTestUtils.compileJavaFiles(javaFiles, options);\n            }\n\n            File jarFile = new File(contentDir, \"library.jar\");\n\n            ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(jarFile));\n            ZipUtil.addDirToZipRecursively(zip, jarFile, classesDir, \"\", null, null);\n            if (addSources) {\n                ZipUtil.addDirToZipRecursively(zip, jarFile, new File(sourcesPath), \"src\", null, null);\n            }\n            zip.close();\n\n            return jarFile;\n        }\n        catch (IOException e) {\n            throw UtilsPackage.rethrow(e);\n        }\n    }","id":74858,"modified_method":"@NotNull\n    public static File compileLibraryToJar(\n            @NotNull String sourcesPath,\n            @NotNull String jarName,\n            boolean addSources,\n            @NotNull String... extraClasspath\n    ) {\n        try {\n            File contentDir = JetTestUtils.tmpDir(\"testLibrary-\" + jarName);\n\n            File classesDir = new File(contentDir, \"classes\");\n            compileKotlin(sourcesPath, classesDir, extraClasspath);\n\n            List<File> javaFiles = FileUtil.findFilesByMask(Pattern.compile(\".*\\\\.java\"), new File(sourcesPath));\n            if (!javaFiles.isEmpty()) {\n                List<String> classpath = new ArrayList<String>();\n                classpath.add(ForTestCompileRuntime.runtimeJarForTests().getPath());\n                classpath.add(JetTestUtils.getAnnotationsJar().getPath());\n                Collections.addAll(classpath, extraClasspath);\n\n                // Probably no kotlin files were present, so dir might not have been created after kotlin compiler\n                if (classesDir.exists()) {\n                    classpath.add(classesDir.getPath());\n                }\n                else {\n                    FileUtil.createDirectory(classesDir);\n                }\n\n                List<String> options = Arrays.asList(\n                        \"-classpath\", StringUtil.join(classpath, File.pathSeparator),\n                        \"-d\", classesDir.getPath()\n                );\n\n                JetTestUtils.compileJavaFiles(javaFiles, options);\n            }\n\n            File jarFile = new File(contentDir, jarName + \".jar\");\n\n            ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(jarFile));\n            ZipUtil.addDirToZipRecursively(zip, jarFile, classesDir, \"\", null, null);\n            if (addSources) {\n                ZipUtil.addDirToZipRecursively(zip, jarFile, new File(sourcesPath), \"src\", null, null);\n            }\n            zip.close();\n\n            return jarFile;\n        }\n        catch (IOException e) {\n            throw UtilsPackage.rethrow(e);\n        }\n    }","commit_id":"a8d77887afc20f814317d9b2be561bf5981c36af","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public static void compileKotlin(@NotNull String sourcesPath, @NotNull File outDir, @NotNull String classpath) {\n        try {\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            Class<?> compilerClass = getCompilerClass();\n            Object compilerObject = compilerClass.newInstance();\n            Method execMethod = compilerClass.getMethod(\"exec\", PrintStream.class, String[].class);\n\n            String newClasspath = classpath.contains(sourcesPath) ? classpath : classpath + File.pathSeparator + sourcesPath;\n\n            //noinspection IOResourceOpenedButNotSafelyClosed\n            Enum<?> invocationResult = (Enum<?>) execMethod.invoke(\n                    compilerObject, new PrintStream(outStream),\n                    new String[] {sourcesPath, \"-d\", outDir.getAbsolutePath(), \"-classpath\", newClasspath}\n            );\n\n            assertEquals(new String(outStream.toByteArray()), ExitCode.OK.name(), invocationResult.name());\n        }\n        catch (Throwable e) {\n            throw UtilsPackage.rethrow(e);\n        }\n    }","id":74859,"modified_method":"public static void compileKotlin(@NotNull String sourcesPath, @NotNull File outDir, @NotNull String... extraClasspath) {\n        try {\n            ByteArrayOutputStream outStream = new ByteArrayOutputStream();\n            Class<?> compilerClass = getCompilerClass();\n            Object compilerObject = compilerClass.newInstance();\n            Method execMethod = compilerClass.getMethod(\"exec\", PrintStream.class, String[].class);\n\n            List<String> classpath = new ArrayList<String>();\n            classpath.add(sourcesPath);\n            Collections.addAll(classpath, extraClasspath);\n            String newClasspath = StringUtil.join(classpath, File.pathSeparator);\n\n            //noinspection IOResourceOpenedButNotSafelyClosed\n            Enum<?> invocationResult = (Enum<?>) execMethod.invoke(\n                    compilerObject, new PrintStream(outStream),\n                    new String[] {sourcesPath, \"-d\", outDir.getAbsolutePath(), \"-classpath\", newClasspath}\n            );\n\n            assertEquals(new String(outStream.toByteArray()), ExitCode.OK.name(), invocationResult.name());\n        }\n        catch (Throwable e) {\n            throw UtilsPackage.rethrow(e);\n        }\n    }","commit_id":"a8d77887afc20f814317d9b2be561bf5981c36af","url":"https://github.com/JetBrains/kotlin"},{"original_method":"public Object receiveBodyNoWait(String endpointUri) {\n        Exchange exchange = receiveNoWait(endpointUri);\n        return extractResultBody(exchange);\n    }","id":74860,"modified_method":"public Object receiveBodyNoWait(String endpointUri) {\n        Object answer = null;\n        Exchange exchange = receiveNoWait(endpointUri);\n        try {\n            answer = extractResultBody(exchange);\n        } finally {\n            doneUoW(exchange);\n        }\n        return answer;\n    }","commit_id":"e57790cfb1ba507baddf88a39edbd3028efa97df","url":"https://github.com/apache/camel"},{"original_method":"public Object receiveBody(String endpointUri) {\n        Exchange exchange = receive(endpointUri);\n        return extractResultBody(exchange);\n    }","id":74861,"modified_method":"public Object receiveBody(String endpointUri) {\n        Object answer = null;\n        Exchange exchange = receive(endpointUri);\n        try {\n            answer = extractResultBody(exchange);\n        } finally {\n            doneUoW(exchange);\n        }\n        return answer;\n    }","commit_id":"e57790cfb1ba507baddf88a39edbd3028efa97df","url":"https://github.com/apache/camel"},{"original_method":"public <T> T receiveBodyNoWait(String endpointUri, Class<T> type) {\n        Object body = receiveBodyNoWait(endpointUri);\n        return context.getTypeConverter().convertTo(type, body);\n    }","id":74862,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public <T> T receiveBodyNoWait(String endpointUri, Class<T> type) {\n        Object answer = null;\n        Exchange exchange = receiveNoWait(endpointUri);\n        try {\n            answer = extractResultBody(exchange);\n            answer = context.getTypeConverter().convertTo(type, answer);\n        } finally {\n            doneUoW(exchange);\n        }\n        return (T) answer;\n    }","commit_id":"e57790cfb1ba507baddf88a39edbd3028efa97df","url":"https://github.com/apache/camel"},{"original_method":"public Object receiveBody(String endpointUri, long timeout) {\n        Exchange exchange = receive(endpointUri, timeout);\n        return extractResultBody(exchange);\n    }","id":74863,"modified_method":"public Object receiveBody(String endpointUri, long timeout) {\n        Object answer = null;\n        Exchange exchange = receive(endpointUri, timeout);\n        try {\n            answer = extractResultBody(exchange);\n        } finally {\n            doneUoW(exchange);\n        }\n        return answer;\n    }","commit_id":"e57790cfb1ba507baddf88a39edbd3028efa97df","url":"https://github.com/apache/camel"},{"original_method":"public <T> T receiveBody(String endpointUri, Class<T> type) {\n        Object body = receiveBody(endpointUri);\n        return context.getTypeConverter().convertTo(type, body);\n    }","id":74864,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public <T> T receiveBody(String endpointUri, Class<T> type) {\n        Object answer = null;\n        Exchange exchange = receive(endpointUri);\n        try {\n            answer = extractResultBody(exchange);\n            answer = context.getTypeConverter().convertTo(type, answer);\n        } finally {\n            doneUoW(exchange);\n        }\n        return (T) answer;\n    }","commit_id":"e57790cfb1ba507baddf88a39edbd3028efa97df","url":"https://github.com/apache/camel"},{"original_method":"public <T> T receiveBody(String endpointUri, long timeout, Class<T> type) {\n        Object body = receiveBody(endpointUri, timeout);\n        return context.getTypeConverter().convertTo(type, body);\n    }","id":74865,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public <T> T receiveBody(String endpointUri, long timeout, Class<T> type) {\n        Object answer = null;\n        Exchange exchange = receive(endpointUri, timeout);\n        try {\n            answer = extractResultBody(exchange);\n            answer = context.getTypeConverter().convertTo(type, answer);\n        } finally {\n            doneUoW(exchange);\n        }\n        return (T) answer;\n    }","commit_id":"e57790cfb1ba507baddf88a39edbd3028efa97df","url":"https://github.com/apache/camel"},{"original_method":"@SuppressWarnings(\"unchecked\")\n    public void done(Exchange exchange) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"UnitOfWork done for ExchangeId: \" + exchange.getExchangeId() + \" with \" + exchange);\n        }\n\n        boolean failed = exchange.isFailed();\n\n        // fire event to signal the exchange is done\n        try {\n            if (failed) {\n                EventHelper.notifyExchangeFailed(exchange.getContext(), exchange);\n            } else {\n                EventHelper.notifyExchangeDone(exchange.getContext(), exchange);\n            }\n        } catch (Exception e) {\n            // must catch exceptions to ensure synchronizations is also invoked\n            LOG.warn(\"Exception occurred during event notification. This exception will be ignored.\", e);\n        }\n\n        if (synchronizations != null && !synchronizations.isEmpty()) {\n            // reverse so we invoke it FILO style instead of FIFO\n            Collections.reverse(synchronizations);\n            // and honor if any was ordered by sorting it accordingly\n            Collections.sort(synchronizations, new OrderedComparator());\n            // invoke synchronization callbacks\n            for (Synchronization synchronization : synchronizations) {\n                try {\n                    if (failed) {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Invoking synchronization.onFailure: \" + synchronization + \" with \" + exchange);\n                        }\n                        synchronization.onFailure(exchange);\n                    } else {\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"Invoking synchronization.onComplete: \" + synchronization + \" with \" + exchange);\n                        }\n                        synchronization.onComplete(exchange);\n                    }\n                } catch (Exception e) {\n                    // must catch exceptions to ensure all synchronizations have a chance to run\n                    LOG.warn(\"Exception occurred during onCompletion. This exception will be ignored.\", e);\n                }\n            }\n        }\n\n        // unregister from inflight registry\n        if (exchange.getContext() != null) {\n            exchange.getContext().getInflightRepository().remove(exchange);\n        }\n    }","id":74866,"modified_method":"@SuppressWarnings(\"unchecked\")\n    public void done(Exchange exchange) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"UnitOfWork done for ExchangeId: \" + exchange.getExchangeId() + \" with \" + exchange);\n        }\n\n        boolean failed = exchange.isFailed();\n\n        // fire event to signal the exchange is done\n        try {\n            if (failed) {\n                EventHelper.notifyExchangeFailed(exchange.getContext(), exchange);\n            } else {\n                EventHelper.notifyExchangeDone(exchange.getContext(), exchange);\n            }\n        } catch (Exception e) {\n            // must catch exceptions to ensure synchronizations is also invoked\n            LOG.warn(\"Exception occurred during event notification. This exception will be ignored.\", e);\n        }\n\n        // done the synchronizations\n        UnitOfWorkHelper.doneSynchronizations(exchange, synchronizations, LOG);\n\n        // unregister from inflight registry\n        if (exchange.getContext() != null) {\n            exchange.getContext().getInflightRepository().remove(exchange);\n        }\n    }","commit_id":"e57790cfb1ba507baddf88a39edbd3028efa97df","url":"https://github.com/apache/camel"},{"original_method":"private void get() {\n    try {\n      RowMetaInterface r = transMeta.getPrevStepFields( stepname );\n      if ( r != null ) {\n        TableItemInsertListener insertListener = new TableItemInsertListener() {\n          public boolean tableItemInserted( TableItem tableItem, ValueMetaInterface v ) {\n            tableItem.setText( 2, BaseMessages.getString( PKG, \"System.Combo.Yes\" ) );\n            return true;\n          }\n        };\n        BaseStepDialog\n          .getFieldsFromPrevious( r, wFields, 1, new int[] { 1 }, new int[] {}, -1, -1, insertListener );\n      }\n    } catch ( KettleException ke ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"System.Dialog.GetFieldsFailed.Title\" ), BaseMessages\n        .getString( PKG, \"System.Dialog.GetFieldsFailed.Message\" ), ke );\n    }\n  }","id":74867,"modified_method":"private void get() {\n    try {\n      RowMetaInterface r = transMeta.getPrevStepFields( stepname );\n      if ( r != null ) {\n        TableItemInsertListener insertListener = new TableItemInsertListener() {\n          @Override\n          public boolean tableItemInserted( TableItem tableItem, ValueMetaInterface v ) {\n            tableItem.setText( 2, BaseMessages.getString( PKG, \"System.Combo.Yes\" ) );\n            return true;\n          }\n        };\n        BaseStepDialog\n          .getFieldsFromPrevious( r, wFields, 1, new int[] { 1 }, new int[] {}, -1, -1, insertListener );\n      }\n    } catch ( KettleException ke ) {\n      new ErrorDialog( shell, BaseMessages.getString( PKG, \"System.Dialog.GetFieldsFailed.Title\" ), BaseMessages\n        .getString( PKG, \"System.Dialog.GetFieldsFailed.Message\" ), ke );\n    }\n  }","commit_id":"26e25c3c90f2bd8bec36938f7a267dd162187d6c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public String open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX );\n    props.setLook( shell );\n    setShellImage( shell, input );\n\n    ModifyListener lsMod = new ModifyListener() {\n      public void modifyText( ModifyEvent e ) {\n        input.setChanged();\n      }\n    };\n    changed = input.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Shell.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Stepname line\n    wlStepname = new Label( shell, SWT.RIGHT );\n    wlStepname.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Stepname.Label\" ) );\n    props.setLook( wlStepname );\n    fdlStepname = new FormData();\n    fdlStepname.left = new FormAttachment( 0, 0 );\n    fdlStepname.right = new FormAttachment( middle, -margin );\n    fdlStepname.top = new FormAttachment( 0, margin );\n    wlStepname.setLayoutData( fdlStepname );\n    wStepname = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wStepname.setText( stepname );\n    props.setLook( wStepname );\n    wStepname.addModifyListener( lsMod );\n    fdStepname = new FormData();\n    fdStepname.left = new FormAttachment( middle, 0 );\n    fdStepname.top = new FormAttachment( 0, margin );\n    fdStepname.right = new FormAttachment( 100, 0 );\n    wStepname.setLayoutData( fdStepname );\n\n    // Type\n    wlType = new Label( shell, SWT.RIGHT );\n    wlType.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Type.Label\" ) );\n    props.setLook( wlType );\n    fdlType = new FormData();\n    fdlType.left = new FormAttachment( 0, 0 );\n    fdlType.right = new FormAttachment( middle, -margin );\n    fdlType.top = new FormAttachment( wStepname, margin );\n    wlType.setLayoutData( fdlType );\n    wType = new CCombo( shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wType.add( BaseMessages.getString( PKG, \"CheckSumDialog.Type.CRC32\" ) );\n    wType.add( BaseMessages.getString( PKG, \"CheckSumDialog.Type.ADLER32\" ) );\n    wType.add( BaseMessages.getString( PKG, \"CheckSumDialog.Type.MD5\" ) );\n    wType.add( BaseMessages.getString( PKG, \"CheckSumDialog.Type.SHA1\" ) );\n    wType.select( 0 );\n    props.setLook( wType );\n    fdType = new FormData();\n    fdType.left = new FormAttachment( middle, 0 );\n    fdType.top = new FormAttachment( wStepname, margin );\n    fdType.right = new FormAttachment( 100, 0 );\n    wType.setLayoutData( fdType );\n    wType.addSelectionListener( new SelectionAdapter() {\n\n      public void widgetSelected( SelectionEvent e ) {\n        activeResultType();\n      }\n    } );\n\n    // ResultType\n    wlResultType = new Label( shell, SWT.RIGHT );\n    wlResultType.setText( BaseMessages.getString( PKG, \"CheckSumDialog.ResultType.Label\" ) );\n    props.setLook( wlResultType );\n    fdlResultType = new FormData();\n    fdlResultType.left = new FormAttachment( 0, 0 );\n    fdlResultType.right = new FormAttachment( middle, -margin );\n    fdlResultType.top = new FormAttachment( wType, 2 * margin );\n    wlResultType.setLayoutData( fdlResultType );\n    wResultType = new CCombo( shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wResultType.setItems( CheckSumMeta.resultTypeDesc );\n    wResultType.select( 0 );\n    props.setLook( wResultType );\n    fdResultType = new FormData();\n    fdResultType.left = new FormAttachment( middle, 0 );\n    fdResultType.top = new FormAttachment( wType, 2 * margin );\n    fdResultType.right = new FormAttachment( 100, 0 );\n    wResultType.setLayoutData( fdResultType );\n    wResultType.addSelectionListener( new SelectionAdapter() {\n\n      public void widgetSelected( SelectionEvent e ) {\n        input.setChanged();\n        activeHexa();\n      }\n    } );\n\n    // Result line...\n    wlResult = new Label( shell, SWT.RIGHT );\n    wlResult.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Result.Label\" ) );\n    props.setLook( wlResult );\n    fdlResult = new FormData();\n    fdlResult.left = new FormAttachment( 0, 0 );\n    fdlResult.right = new FormAttachment( middle, -margin );\n    fdlResult.top = new FormAttachment( wResultType, margin * 2 );\n    wlResult.setLayoutData( fdlResult );\n    wResult = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wResult );\n    wResult.addModifyListener( lsMod );\n    fdResult = new FormData();\n    fdResult.left = new FormAttachment( middle, 0 );\n    fdResult.top = new FormAttachment( wResultType, margin * 2 );\n    fdResult.right = new FormAttachment( 100, 0 );\n    wResult.setLayoutData( fdResult );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wGet = new Button( shell, SWT.PUSH );\n    wGet.setText( BaseMessages.getString( PKG, \"System.Button.GetFields\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    setButtonPositions( new Button[] { wOK, wGet, wCancel }, margin, null );\n\n    // Are we operating in compatibility mode?\n    wlCompatibility = new Label( shell, SWT.RIGHT );\n    wlCompatibility.setText( BaseMessages.getString( PKG, \"CheckSumDialog.CompatibilityMode.Label\" ) );\n    props.setLook( wlCompatibility );\n    fdlCompatibility = new FormData();\n    fdlCompatibility.left = new FormAttachment( 0, 0 );\n    fdlCompatibility.top = new FormAttachment( wResult, margin );\n    fdlCompatibility.right = new FormAttachment( middle, -margin );\n    wlCompatibility.setLayoutData( fdlCompatibility );\n    wCompatibility = new Button( shell, SWT.CHECK );\n    wCompatibility.setToolTipText( BaseMessages.getString( PKG, \"CheckSumDialog.CompatibilityMode.Tooltip\" ) );\n    props.setLook( wCompatibility );\n    fdCompatibility = new FormData();\n    fdCompatibility.left = new FormAttachment( middle, 0 );\n    fdCompatibility.top = new FormAttachment( wResult, margin );\n    fdCompatibility.right = new FormAttachment( 100, 0 );\n    wCompatibility.setLayoutData( fdCompatibility );\n    SelectionAdapter lsSelR = new SelectionAdapter() {\n      public void widgetSelected( SelectionEvent arg0 ) {\n        input.setChanged();\n      }\n    };\n    wCompatibility.addSelectionListener( lsSelR );\n\n    // Table with fields\n    wlFields = new Label( shell, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.top = new FormAttachment( wCompatibility, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    final int FieldsCols = 1;\n    final int FieldsRows = input.getFieldName().length;\n\n    colinf = new ColumnInfo[FieldsCols];\n    colinf[0] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"CheckSumDialog.Fieldname.Column\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] { \"\" }, false );\n    wFields =\n      new TableView(\n        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( 100, 0 );\n    fdFields.bottom = new FormAttachment( wOK, -2 * margin );\n    wFields.setLayoutData( fdFields );\n\n    //\n    // Search the fields in the background\n\n    final Runnable runnable = new Runnable() {\n      public void run() {\n        StepMeta stepMeta = transMeta.findStep( stepname );\n        if ( stepMeta != null ) {\n          try {\n            RowMetaInterface row = transMeta.getPrevStepFields( stepMeta );\n\n            // Remember these fields...\n            for ( int i = 0; i < row.size(); i++ ) {\n              inputFields.put( row.getValueMeta( i ).getName(), Integer.valueOf( i ) );\n            }\n\n            setComboBoxes();\n          } catch ( KettleException e ) {\n            logError( BaseMessages.getString( PKG, \"System.Dialog.GetFieldsFailed.Message\" ) );\n          }\n        }\n      }\n    };\n    new Thread( runnable ).start();\n\n    // Add listeners\n    lsCancel = new Listener() {\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsGet = new Listener() {\n      public void handleEvent( Event e ) {\n        get();\n      }\n    };\n    lsOK = new Listener() {\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n    wGet.addListener( SWT.Selection, lsGet );\n\n    lsDef = new SelectionAdapter() {\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wStepname.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    // Set the shell size, based upon previous time...\n    setSize();\n\n    getData();\n    activeHexa();\n    activeResultType();\n    input.setChanged( changed );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return stepname;\n  }","id":74868,"modified_method":"@Override\n  public String open() {\n    Shell parent = getParent();\n    Display display = parent.getDisplay();\n\n    shell = new Shell( parent, SWT.DIALOG_TRIM | SWT.RESIZE | SWT.MIN | SWT.MAX );\n    props.setLook( shell );\n    setShellImage( shell, input );\n\n    ModifyListener lsMod = new ModifyListener() {\n      @Override\n      public void modifyText( ModifyEvent e ) {\n        input.setChanged();\n      }\n    };\n    changed = input.hasChanged();\n\n    FormLayout formLayout = new FormLayout();\n    formLayout.marginWidth = Const.FORM_MARGIN;\n    formLayout.marginHeight = Const.FORM_MARGIN;\n\n    shell.setLayout( formLayout );\n    shell.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Shell.Title\" ) );\n\n    int middle = props.getMiddlePct();\n    int margin = Const.MARGIN;\n\n    // Stepname line\n    wlStepname = new Label( shell, SWT.RIGHT );\n    wlStepname.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Stepname.Label\" ) );\n    props.setLook( wlStepname );\n    fdlStepname = new FormData();\n    fdlStepname.left = new FormAttachment( 0, 0 );\n    fdlStepname.right = new FormAttachment( middle, -margin );\n    fdlStepname.top = new FormAttachment( 0, margin );\n    wlStepname.setLayoutData( fdlStepname );\n    wStepname = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    wStepname.setText( stepname );\n    props.setLook( wStepname );\n    wStepname.addModifyListener( lsMod );\n    fdStepname = new FormData();\n    fdStepname.left = new FormAttachment( middle, 0 );\n    fdStepname.top = new FormAttachment( 0, margin );\n    fdStepname.right = new FormAttachment( 100, 0 );\n    wStepname.setLayoutData( fdStepname );\n\n    // Type\n    wlType = new Label( shell, SWT.RIGHT );\n    wlType.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Type.Label\" ) );\n    props.setLook( wlType );\n    fdlType = new FormData();\n    fdlType.left = new FormAttachment( 0, 0 );\n    fdlType.right = new FormAttachment( middle, -margin );\n    fdlType.top = new FormAttachment( wStepname, margin );\n    wlType.setLayoutData( fdlType );\n    wType = new CCombo( shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    for ( int i = 0; i < CheckSumMeta.checksumtypeDescs.length; i++ ) {\n      wType.add( CheckSumMeta.checksumtypeDescs[i] );\n    }\n    wType.select( 0 );\n    props.setLook( wType );\n    fdType = new FormData();\n    fdType.left = new FormAttachment( middle, 0 );\n    fdType.top = new FormAttachment( wStepname, margin );\n    fdType.right = new FormAttachment( 100, 0 );\n    wType.setLayoutData( fdType );\n    wType.addSelectionListener( new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        input.setChanged();\n        activeResultType();\n      }\n    } );\n\n    // ResultType\n    wlResultType = new Label( shell, SWT.RIGHT );\n    wlResultType.setText( BaseMessages.getString( PKG, \"CheckSumDialog.ResultType.Label\" ) );\n    props.setLook( wlResultType );\n    fdlResultType = new FormData();\n    fdlResultType.left = new FormAttachment( 0, 0 );\n    fdlResultType.right = new FormAttachment( middle, -margin );\n    fdlResultType.top = new FormAttachment( wType, 2 * margin );\n    wlResultType.setLayoutData( fdlResultType );\n    wResultType = new CCombo( shell, SWT.SINGLE | SWT.READ_ONLY | SWT.BORDER );\n    wResultType.setItems( CheckSumMeta.resultTypeDesc );\n    wResultType.select( 0 );\n    props.setLook( wResultType );\n    fdResultType = new FormData();\n    fdResultType.left = new FormAttachment( middle, 0 );\n    fdResultType.top = new FormAttachment( wType, 2 * margin );\n    fdResultType.right = new FormAttachment( 100, 0 );\n    wResultType.setLayoutData( fdResultType );\n    wResultType.addSelectionListener( new SelectionAdapter() {\n\n      @Override\n      public void widgetSelected( SelectionEvent e ) {\n        input.setChanged();\n        activeHexa();\n      }\n    } );\n\n    // Result line...\n    wlResult = new Label( shell, SWT.RIGHT );\n    wlResult.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Result.Label\" ) );\n    props.setLook( wlResult );\n    fdlResult = new FormData();\n    fdlResult.left = new FormAttachment( 0, 0 );\n    fdlResult.right = new FormAttachment( middle, -margin );\n    fdlResult.top = new FormAttachment( wResultType, margin * 2 );\n    wlResult.setLayoutData( fdlResult );\n    wResult = new Text( shell, SWT.SINGLE | SWT.LEFT | SWT.BORDER );\n    props.setLook( wResult );\n    wResult.addModifyListener( lsMod );\n    fdResult = new FormData();\n    fdResult.left = new FormAttachment( middle, 0 );\n    fdResult.top = new FormAttachment( wResultType, margin * 2 );\n    fdResult.right = new FormAttachment( 100, 0 );\n    wResult.setLayoutData( fdResult );\n\n    wOK = new Button( shell, SWT.PUSH );\n    wOK.setText( BaseMessages.getString( PKG, \"System.Button.OK\" ) );\n    wGet = new Button( shell, SWT.PUSH );\n    wGet.setText( BaseMessages.getString( PKG, \"System.Button.GetFields\" ) );\n    wCancel = new Button( shell, SWT.PUSH );\n    wCancel.setText( BaseMessages.getString( PKG, \"System.Button.Cancel\" ) );\n\n    setButtonPositions( new Button[] { wOK, wGet, wCancel }, margin, null );\n\n    // Are we operating in compatibility mode?\n    wlCompatibility = new Label( shell, SWT.RIGHT );\n    wlCompatibility.setText( BaseMessages.getString( PKG, \"CheckSumDialog.CompatibilityMode.Label\" ) );\n    props.setLook( wlCompatibility );\n    fdlCompatibility = new FormData();\n    fdlCompatibility.left = new FormAttachment( 0, 0 );\n    fdlCompatibility.top = new FormAttachment( wResult, margin );\n    fdlCompatibility.right = new FormAttachment( middle, -margin );\n    wlCompatibility.setLayoutData( fdlCompatibility );\n    wCompatibility = new Button( shell, SWT.CHECK );\n    wCompatibility.setToolTipText( BaseMessages.getString( PKG, \"CheckSumDialog.CompatibilityMode.Tooltip\" ) );\n    props.setLook( wCompatibility );\n    fdCompatibility = new FormData();\n    fdCompatibility.left = new FormAttachment( middle, 0 );\n    fdCompatibility.top = new FormAttachment( wResult, margin );\n    fdCompatibility.right = new FormAttachment( 100, 0 );\n    wCompatibility.setLayoutData( fdCompatibility );\n    SelectionAdapter lsSelR = new SelectionAdapter() {\n      @Override\n      public void widgetSelected( SelectionEvent arg0 ) {\n        input.setChanged();\n      }\n    };\n    wCompatibility.addSelectionListener( lsSelR );\n\n    // Table with fields\n    wlFields = new Label( shell, SWT.NONE );\n    wlFields.setText( BaseMessages.getString( PKG, \"CheckSumDialog.Fields.Label\" ) );\n    props.setLook( wlFields );\n    fdlFields = new FormData();\n    fdlFields.left = new FormAttachment( 0, 0 );\n    fdlFields.top = new FormAttachment( wCompatibility, margin );\n    wlFields.setLayoutData( fdlFields );\n\n    final int FieldsCols = 1;\n    final int FieldsRows = input.getFieldName().length;\n\n    colinf = new ColumnInfo[FieldsCols];\n    colinf[0] =\n      new ColumnInfo(\n        BaseMessages.getString( PKG, \"CheckSumDialog.Fieldname.Column\" ), ColumnInfo.COLUMN_TYPE_CCOMBO,\n        new String[] { \"\" }, false );\n    wFields =\n      new TableView(\n        transMeta, shell, SWT.BORDER | SWT.FULL_SELECTION | SWT.MULTI, colinf, FieldsRows, lsMod, props );\n\n    fdFields = new FormData();\n    fdFields.left = new FormAttachment( 0, 0 );\n    fdFields.top = new FormAttachment( wlFields, margin );\n    fdFields.right = new FormAttachment( 100, 0 );\n    fdFields.bottom = new FormAttachment( wOK, -2 * margin );\n    wFields.setLayoutData( fdFields );\n\n    //\n    // Search the fields in the background\n\n    final Runnable runnable = new Runnable() {\n      @Override\n      public void run() {\n        StepMeta stepMeta = transMeta.findStep( stepname );\n        if ( stepMeta != null ) {\n          try {\n            RowMetaInterface row = transMeta.getPrevStepFields( stepMeta );\n\n            // Remember these fields...\n            for ( int i = 0; i < row.size(); i++ ) {\n              inputFields.put( row.getValueMeta( i ).getName(), Integer.valueOf( i ) );\n            }\n\n            setComboBoxes();\n          } catch ( KettleException e ) {\n            logError( BaseMessages.getString( PKG, \"System.Dialog.GetFieldsFailed.Message\" ) );\n          }\n        }\n      }\n    };\n    new Thread( runnable ).start();\n\n    // Add listeners\n    lsCancel = new Listener() {\n      @Override\n      public void handleEvent( Event e ) {\n        cancel();\n      }\n    };\n    lsGet = new Listener() {\n      @Override\n      public void handleEvent( Event e ) {\n        get();\n      }\n    };\n    lsOK = new Listener() {\n      @Override\n      public void handleEvent( Event e ) {\n        ok();\n      }\n    };\n\n    wCancel.addListener( SWT.Selection, lsCancel );\n    wOK.addListener( SWT.Selection, lsOK );\n    wGet.addListener( SWT.Selection, lsGet );\n\n    lsDef = new SelectionAdapter() {\n      @Override\n      public void widgetDefaultSelected( SelectionEvent e ) {\n        ok();\n      }\n    };\n\n    wStepname.addSelectionListener( lsDef );\n\n    // Detect X or ALT-F4 or something that kills this window...\n    shell.addShellListener( new ShellAdapter() {\n      @Override\n      public void shellClosed( ShellEvent e ) {\n        cancel();\n      }\n    } );\n\n    // Set the shell size, based upon previous time...\n    setSize();\n\n    getData();\n    activeHexa();\n    activeResultType();\n    input.setChanged( changed );\n\n    shell.open();\n    while ( !shell.isDisposed() ) {\n      if ( !display.readAndDispatch() ) {\n        display.sleep();\n      }\n    }\n    return stepname;\n  }","commit_id":"26e25c3c90f2bd8bec36938f7a267dd162187d6c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void activeResultType() {\n    boolean active = wType.getSelectionIndex() == 2 || wType.getSelectionIndex() == 3;\n    wlResultType.setEnabled( active );\n    wResultType.setEnabled( active );\n  }","id":74869,"modified_method":"private void activeResultType() {\n    int currentType = wType.getSelectionIndex();\n    boolean active = currentType == 2 || currentType == 3 || currentType == 4;\n    wlResultType.setEnabled( active );\n    wResultType.setEnabled( active );\n  }","commit_id":"26e25c3c90f2bd8bec36938f7a267dd162187d6c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"public int getTypeByDesc() {\n    if ( checksumtype == null ) {\n      return 0;\n    }\n    int retval;\n    if ( checksumtype.equals( checksumtypeCodes[1] ) ) {\n      retval = 1;\n    } else if ( checksumtype.equals( checksumtypeCodes[2] ) ) {\n      retval = 2;\n    } else if ( checksumtype.equals( checksumtypeCodes[3] ) ) {\n      retval = 3;\n    } else {\n      retval = 0;\n    }\n    return retval;\n  }","id":74870,"modified_method":"public int getTypeByDesc() {\n    if ( checksumtype == null ) {\n      return 0;\n    }\n    for ( int i = 0; i < checksumtypeCodes.length; i++ ) {\n      if ( checksumtype.equals( checksumtypeCodes[i] ) ) {\n        return i;\n      }\n    }\n    return 0;\n  }","commit_id":"26e25c3c90f2bd8bec36938f7a267dd162187d6c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Override\r\n  public void modify( CheckSumMeta someMeta ) {\r\n    if ( someMeta instanceof CheckSumMeta ) {\r\n      someMeta.allocate( 5 );\r\n    }\r\n  }","id":74871,"modified_method":"@Override\r\n  public void modify( CheckSumMeta someMeta ) {\r\n    someMeta.allocate( 5 );\r\n  }","commit_id":"26e25c3c90f2bd8bec36938f7a267dd162187d6c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Test\r\n  public void testConstants() {\r\n    assertEquals( \"CRC32\", CheckSumMeta.TYPE_CRC32 );\r\n    assertEquals( \"CRC32\", CheckSumMeta.checksumtypeCodes[0] );\r\n    assertEquals( \"ADLER32\", CheckSumMeta.TYPE_ADLER32 );\r\n    assertEquals( \"ADLER32\", CheckSumMeta.checksumtypeCodes[1] );\r\n    assertEquals( \"MD5\", CheckSumMeta.TYPE_MD5 );\r\n    assertEquals( \"MD5\", CheckSumMeta.checksumtypeCodes[2] );\r\n    assertEquals( \"SHA-1\", CheckSumMeta.TYPE_SHA1 );\r\n    assertEquals( \"SHA-1\", CheckSumMeta.checksumtypeCodes[3] );\r\n    assertEquals( \"SHA-256\", CheckSumMeta.TYPE_SHA256 );\r\n    assertEquals( \"SHA-256\", CheckSumMeta.checksumtypeCodes[4] );\r\n  }","id":74872,"modified_method":"@Test\r\n  public void testConstants() {\r\n    assertEquals( \"CRC32\", CheckSumMeta.TYPE_CRC32 );\r\n    assertEquals( \"CRC32\", CheckSumMeta.checksumtypeCodes[0] );\r\n    assertEquals( \"ADLER32\", CheckSumMeta.TYPE_ADLER32 );\r\n    assertEquals( \"ADLER32\", CheckSumMeta.checksumtypeCodes[1] );\r\n    assertEquals( \"MD5\", CheckSumMeta.TYPE_MD5 );\r\n    assertEquals( \"MD5\", CheckSumMeta.checksumtypeCodes[2] );\r\n    assertEquals( \"SHA-1\", CheckSumMeta.TYPE_SHA1 );\r\n    assertEquals( \"SHA-1\", CheckSumMeta.checksumtypeCodes[3] );\r\n    assertEquals( \"SHA-256\", CheckSumMeta.TYPE_SHA256 );\r\n    assertEquals( \"SHA-256\", CheckSumMeta.checksumtypeCodes[4] );\r\n    assertEquals( CheckSumMeta.checksumtypeCodes.length, CheckSumMeta.checksumtypeDescs.length );\r\n  }","commit_id":"26e25c3c90f2bd8bec36938f7a267dd162187d6c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"@Test\r\n  public void testSerialization() throws KettleException {\r\n    loadSaveTester.testSerialization();\r\n  }","id":74873,"modified_method":"@Test\r\n  public void testSerialization() throws KettleException {\r\n    List<String> attributes =\r\n      Arrays.asList( \"FieldName\", \"ResultFieldName\", \"CheckSumType\", \"CompatibilityMode\", \"ResultType\" );\r\n\r\n    Map<String, String> getterMap = new HashMap<String, String>();\r\n    Map<String, String> setterMap = new HashMap<String, String>();\r\n    getterMap.put( \"CheckSumType\", \"getTypeByDesc\" );\r\n\r\n    FieldLoadSaveValidator<String[]> stringArrayLoadSaveValidator =\r\n      new ArrayLoadSaveValidator<String>( new StringLoadSaveValidator(), 5 );\r\n\r\n    Map<String, FieldLoadSaveValidator<?>> attrValidatorMap = new HashMap<String, FieldLoadSaveValidator<?>>();\r\n    attrValidatorMap.put( \"FieldName\", stringArrayLoadSaveValidator );\r\n    attrValidatorMap.put( \"CheckSumType\", new IntLoadSaveValidator( CheckSumMeta.checksumtypeCodes.length ) );\r\n    attrValidatorMap.put( \"ResultType\", new IntLoadSaveValidator( CheckSumMeta.resultTypeCode.length ) );\r\n\r\n    Map<String, FieldLoadSaveValidator<?>> typeValidatorMap = new HashMap<String, FieldLoadSaveValidator<?>>();\r\n\r\n    LoadSaveTester<CheckSumMeta> loadSaveTester =\r\n      new LoadSaveTester<>( CheckSumMeta.class, attributes, getterMap, setterMap,\r\n        attrValidatorMap, typeValidatorMap, this );\r\n\r\n    loadSaveTester.testSerialization();\r\n  }","commit_id":"26e25c3c90f2bd8bec36938f7a267dd162187d6c","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void ok()\r\n\t{        \r\n\t\tprops.setFixedFont     ( fixedFontData );\r\n\t\tprops.setGraphFont     ( graphFontData );\r\n\t\tprops.setNoteFont      ( noteFontData  );\r\n\t\tprops.setBackgroundRGB ( backgroundRGB  );\r\n\t\tprops.setGraphColorRGB ( graphColorRGB    );\r\n\t\tprops.setTabColorRGB   ( tabColorRGB      );\r\n\t\tprops.setIconSize      ( Const.toInt(wIconsize.getText(), props.getIconSize() ));\r\n\t\tprops.setLineWidth     ( Const.toInt(wLineWidth.getText(), props.getLineWidth() ));\r\n\t\tprops.setShadowSize    ( Const.toInt(wShadowSize.getText(), props.getShadowSize() ));\r\n\t\tprops.setMiddlePct     ( Const.toInt(wMiddlePct.getText(), props.getMiddlePct() ));\n        \n        props.setDefaultPreviewSize( Const.toInt( wDefaultPreview.getText(), props.getDefaultPreviewSize() ));\r\n\r\n\t\tprops.setMaxUndo                         ( Const.toInt(wMaxUndo.getText(), props.getMaxUndo() ));\r\n\t\tprops.setShowTips                        ( wShowTips.getSelection()    );\r\n\t\tprops.setUseDBCache                      ( wUseCache.getSelection()    );\r\n\t\tprops.setOpenLastFile                    ( wOpenLast.getSelection()    );\r\n\t\tprops.setAutoSave                        ( wAutoSave.getSelection()    );\n        props.setOnlyUsedConnectionsSavedToXML   ( wDBConnXML.getSelection()   );\n\t\tprops.setSaveConfirmation                ( wSaveConf.getSelection()    );\r\n\t\tprops.setAutoSplit                       ( wAutoSplit.getSelection()   );\n        props.setRepositoriesDialogAtStartupShown( wShowRep.getSelection()     );\r\n        props.setAntiAliasingEnabled             ( wAntiAlias.getSelection()   );\n        props.setExitWarningShown                ( wExitWarning.getSelection() );\n        props.setOSLookShown                     ( wOriginalLook.getSelection());\n\t\t\n        LanguageChoice.getInstance().setDefaultLocale( new Locale( GlobalMessages.localeCodes[ wDefaultLocale.getSelectionIndex()]) );\n        LanguageChoice.getInstance().setFailoverLocale( new Locale( GlobalMessages.localeCodes[ wFailoverLocale.getSelectionIndex()]) );\n        LanguageChoice.getInstance().saveSettings();\n        \n        props.saveProps();\n        \r\n\t\tdispose();\r\n\t}","id":74874,"modified_method":"private void ok()\r\n\t{        \r\n\t\tprops.setFixedFont     ( fixedFontData );\r\n\t\tprops.setGraphFont     ( graphFontData );\r\n\t\tprops.setNoteFont      ( noteFontData  );\r\n\t\tprops.setBackgroundRGB ( backgroundRGB  );\r\n\t\tprops.setGraphColorRGB ( graphColorRGB    );\r\n\t\tprops.setTabColorRGB   ( tabColorRGB      );\r\n\t\tprops.setIconSize      ( Const.toInt(wIconsize.getText(), props.getIconSize() ));\r\n\t\tprops.setLineWidth     ( Const.toInt(wLineWidth.getText(), props.getLineWidth() ));\r\n\t\tprops.setShadowSize    ( Const.toInt(wShadowSize.getText(), props.getShadowSize() ));\r\n\t\tprops.setMiddlePct     ( Const.toInt(wMiddlePct.getText(), props.getMiddlePct() ));\n        \n        props.setDefaultPreviewSize( Const.toInt( wDefaultPreview.getText(), props.getDefaultPreviewSize() ));\r\n\r\n\t\tprops.setMaxUndo                         ( Const.toInt(wMaxUndo.getText(), props.getMaxUndo() ));\r\n\t\tprops.setShowTips                        ( wShowTips.getSelection()    );\r\n\t\tprops.setUseDBCache                      ( wUseCache.getSelection()    );\r\n\t\tprops.setOpenLastFile                    ( wOpenLast.getSelection()    );\r\n\t\tprops.setAutoSave                        ( wAutoSave.getSelection()    );\n        props.setOnlyUsedConnectionsSavedToXML   ( wDBConnXML.getSelection()   );\n\t\tprops.setSaveConfirmation                ( wSaveConf.getSelection()    );\r\n\t\tprops.setAutoSplit                       ( wAutoSplit.getSelection()   );\n        props.setRepositoriesDialogAtStartupShown( wShowRep.getSelection()     );\r\n        props.setAntiAliasingEnabled             ( wAntiAlias.getSelection()   );\n        props.setExitWarningShown                ( wExitWarning.getSelection() );\n        props.setOSLookShown                     ( wOriginalLook.getSelection());\n\n        int defaultLocaleIndex = wDefaultLocale.getSelectionIndex();\n        if ( defaultLocaleIndex < 0 || \n             defaultLocaleIndex >= GlobalMessages.localeCodes.length )\n        {\n        \t// Code hardening, when the combo-box ever gets in a strange state,\n        \t// use the first language as default (should be English)\n            defaultLocaleIndex = 0;\n        }\n        int failoverLocaleIndex = wFailoverLocale.getSelectionIndex();\n        if ( failoverLocaleIndex < 0  ||\n        \t failoverLocaleIndex >= GlobalMessages.localeCodes.length )\n        {\n        \tfailoverLocaleIndex = 0;\n        }\n       \n        LanguageChoice.getInstance().setDefaultLocale( new Locale( GlobalMessages.localeCodes[defaultLocaleIndex]) );\n        LanguageChoice.getInstance().setFailoverLocale( new Locale( GlobalMessages.localeCodes[failoverLocaleIndex]) );\n        LanguageChoice.getInstance().saveSettings();\n        \n        props.saveProps();\n        \r\n\t\tdispose();\r\n\t}","commit_id":"ca6367b82670c654a2dcdbe61d8c7c4c6c125ec5","url":"https://github.com/pentaho/pentaho-kettle"},{"original_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries,\n                                  Collection<String> unknownJdks,\n                                  final Set<String> usedVariables,\n                                  Set<String> refsToModules,\n                                  final String testPattern,\n                                  Element element) throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        getContentEntry().addSourceFolder(VfsUtil.pathToUrl(myRootPath + \"/\" + path), testPattern != null && testPattern.length() > 0 && path.matches(testPattern));\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      final CompilerModuleExtension compilerModuleExtension = rootModel.getModuleExtension(CompilerModuleExtension.class);\n      compilerModuleExtension.setCompilerOutputPath(VfsUtil.pathToUrl(myRootPath + \"/\" + path));\n      compilerModuleExtension.inheritCompilerOutputPath(false);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      modifiableModel.addRoot(getUrl(path), OrderRootType.CLASSES);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        modifiableModel.addRoot(getUrl(sourcePath), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getClasspathEntryAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n\n      final String clsVar;\n      final String clsPath;\n      if (slash > 0) {\n        clsVar = path.substring(0, slash);\n        clsPath = path.substring(slash + 1);\n      }\n      else {\n        clsVar = path;\n        clsPath = null;\n      }\n      usedVariables.add(clsVar);\n      final String url = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(clsVar, clsPath));\n      modifiableModel.addRoot(getUrl(url), OrderRootType.CLASSES);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcVar;\n        final String srcPath;\n        final int varStart = srcPathAttr.startsWith(\"/\") ? 1 : 0;\n\n        int slash2 = srcPathAttr.indexOf(\"/\", varStart);\n        if (slash2 > 0) {\n          srcVar = srcPathAttr.substring(varStart, slash2);\n          srcPath = srcPathAttr.substring(slash2 + 1);\n        }\n        else {\n          srcVar = srcPathAttr.substring(varStart);\n          srcPath = null;\n        }\n        usedVariables.add(srcVar);\n        final String srcUrl = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(srcVar, srcPath));\n        modifiableModel.addRoot(getUrl(srcUrl), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getClasspathEntryAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        OrderEntry[] orderEntries = rootModel.getOrderEntries();\n        orderEntries = ArrayUtil.append(orderEntries, orderEntries[0]);\n        rootModel.rearrangeOrderEntries(ArrayUtil.remove(orderEntries, 0));\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path), LibraryTablesRegistrar.PROJECT_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","id":74875,"modified_method":"private void readClasspathEntry(ModifiableRootModel rootModel,\n                                  final Collection<String> unknownLibraries,\n                                  Collection<String> unknownJdks,\n                                  final Set<String> usedVariables,\n                                  Set<String> refsToModules,\n                                  final String testPattern,\n                                  Element element) throws ConversionException {\n    String kind = element.getAttributeValue(EclipseXml.KIND_ATTR);\n    if (kind == null) {\n      throw new ConversionException(\"Missing classpathentry/@kind\");\n    }\n\n\n    String path = element.getAttributeValue(EclipseXml.PATH_ATTR);\n    if (path == null) {\n      throw new ConversionException(\"Missing classpathentry/@path\");\n    }\n\n    final boolean exported = EclipseXml.TRUE_VALUE.equals(element.getAttributeValue(EclipseXml.EXPORTED_ATTR));\n\n    if (kind.equals(EclipseXml.SRC_KIND)) {\n      if (path.startsWith(\"/\")) {\n        final String moduleName = path.substring(1);\n        refsToModules.add(moduleName);\n        rootModel.addInvalidModuleEntry(moduleName).setExported(exported);\n      }\n      else {\n        getContentEntry().addSourceFolder(VfsUtil.pathToUrl(myRootPath + \"/\" + path), testPattern != null && testPattern.length() > 0 && path.matches(testPattern));\n      }\n    }\n\n    else if (kind.equals(EclipseXml.OUTPUT_KIND)) {\n      final CompilerModuleExtension compilerModuleExtension = rootModel.getModuleExtension(CompilerModuleExtension.class);\n      compilerModuleExtension.setCompilerOutputPath(VfsUtil.pathToUrl(myRootPath + \"/\" + path));\n      compilerModuleExtension.inheritCompilerOutputPath(false);\n    }\n\n    else if (kind.equals(EclipseXml.LIB_KIND)) {\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n      modifiableModel.addRoot(getUrl(path), OrderRootType.CLASSES);\n\n      final String sourcePath = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (sourcePath != null) {\n        modifiableModel.addRoot(getUrl(sourcePath), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getJavadocAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.VAR_KIND)) {\n      int slash = path.indexOf(\"/\");\n      if (slash == 0) {\n        throw new ConversionException(\"Incorrect 'classpathentry/var@path' format\");\n      }\n\n      final String libName = getPresentableName(path);\n      final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(libName);\n      final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n\n\n      final String clsVar;\n      final String clsPath;\n      if (slash > 0) {\n        clsVar = path.substring(0, slash);\n        clsPath = path.substring(slash + 1);\n      }\n      else {\n        clsVar = path;\n        clsPath = null;\n      }\n      usedVariables.add(clsVar);\n      final String url = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(clsVar, clsPath));\n      modifiableModel.addRoot(getUrl(url), OrderRootType.CLASSES);\n\n      final String srcPathAttr = element.getAttributeValue(EclipseXml.SOURCEPATH_ATTR);\n      if (srcPathAttr != null) {\n        final String srcVar;\n        final String srcPath;\n        final int varStart = srcPathAttr.startsWith(\"/\") ? 1 : 0;\n\n        int slash2 = srcPathAttr.indexOf(\"/\", varStart);\n        if (slash2 > 0) {\n          srcVar = srcPathAttr.substring(varStart, slash2);\n          srcPath = srcPathAttr.substring(slash2 + 1);\n        }\n        else {\n          srcVar = srcPathAttr.substring(varStart);\n          srcPath = null;\n        }\n        usedVariables.add(srcVar);\n        final String srcUrl = PathMacroManager.getInstance(rootModel.getModule()).expandPath(getVariableRelatedPath(srcVar, srcPath));\n        modifiableModel.addRoot(getUrl(srcUrl), OrderRootType.SOURCES);\n      }\n\n      final List<String> docPaths = getJavadocAttribute(element);\n      if (docPaths != null) {\n        for (String docPath : docPaths) {\n          modifiableModel.addRoot(docPath, JavadocOrderRootType.getInstance());\n        }\n      }\n\n      modifiableModel.commit();\n\n      setLibraryEntryExported(rootModel, exported, library);\n    }\n    else if (kind.equals(EclipseXml.CON_KIND)) {\n      if (path.equals(EclipseXml.ECLIPSE_PLATFORM)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, IdeaXml.ECLIPSE_LIBRARY, LibraryTablesRegistrar.APPLICATION_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JRE_CONTAINER)) {\n\n        final String jdkName = getLastPathComponent(path);\n        if (jdkName == null) {\n          rootModel.inheritSdk();\n        }\n        else {\n          final Sdk moduleJdk = ProjectJdkTable.getInstance().findJdk(jdkName);\n          if (moduleJdk != null) {\n            rootModel.setSdk(moduleJdk);\n          }\n          else {\n            rootModel.setInvalidSdk(jdkName, IdeaXml.JAVA_SDK_TYPE);\n            unknownJdks.add(jdkName);\n          }\n        }\n        OrderEntry[] orderEntries = rootModel.getOrderEntries();\n        orderEntries = ArrayUtil.append(orderEntries, orderEntries[0]);\n        rootModel.rearrangeOrderEntries(ArrayUtil.remove(orderEntries, 0));\n      }\n      else if (path.startsWith(EclipseXml.USER_LIBRARY)) {\n        addNamedLibrary(rootModel, unknownLibraries, exported, getPresentableName(path), LibraryTablesRegistrar.PROJECT_LEVEL);\n      }\n      else if (path.startsWith(EclipseXml.JUNIT_CONTAINER)) {\n        final String junitName = IdeaXml.JUNIT + getPresentableName(path);\n        final Library library = rootModel.getModuleLibraryTable().getModifiableModel().createLibrary(junitName);\n        final Library.ModifiableModel modifiableModel = library.getModifiableModel();\n        modifiableModel.addRoot(getJunitClsUrl(junitName.contains(\"4\")), OrderRootType.CLASSES);\n        modifiableModel.commit();\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown classpathentry/@kind: \" + kind);\n    }\n  }","commit_id":"7ed512998322e638d6eb055460d5088cb8d8e57d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private List<String> getClasspathEntryAttribute(Element element) {\n    Element attributes = element.getChild(\"attributes\");\n    if (attributes == null) {\n      return null;\n    }\n    List<String> result = new ArrayList<String>();\n    for (Object o : attributes.getChildren(\"attribute\")) {\n      if (Comparing.strEqual(((Element)o).getAttributeValue(\"name\"), \"javadoc_location\")) {\n        Element attribute = (Element)o;\n        String javadocPath = attribute.getAttributeValue(\"value\");\n        if (!SystemInfo.isWindows) {\n          javadocPath = javadocPath.replaceFirst(EclipseXml.FILE_PROTOCOL, EclipseXml.FILE_PROTOCOL + \"/\");\n        }\n        if (javadocPath.startsWith(EclipseXml.FILE_PROTOCOL) &&\n            new File(javadocPath.substring(EclipseXml.FILE_PROTOCOL.length())).exists()) {\n          result.add(VfsUtil.pathToUrl(javadocPath.substring(EclipseXml.FILE_PROTOCOL.length())));\n        }\n        else {\n\n          final String protocol = VirtualFileManager.extractProtocol(javadocPath);\n          if (Comparing.strEqual(protocol, HttpFileSystem.getInstance().getProtocol())) {\n            result.add(javadocPath);\n          }\n          else if (javadocPath.startsWith(EclipseXml.JAR_PREFIX)) {\n            final String jarJavadocPath = javadocPath.substring(EclipseXml.JAR_PREFIX.length());\n            if (jarJavadocPath.startsWith(EclipseXml.PLATFORM_PROTOCOL)) {\n              String relativeToPlatform = jarJavadocPath.substring(EclipseXml.PLATFORM_PROTOCOL.length() + \"resources\".length());\n              result\n                .add(VirtualFileManager.constructUrl(JarFileSystem.PROTOCOL, new File(myRootPath).getParent() + \"/\" + relativeToPlatform));\n            }\n            else if (jarJavadocPath.startsWith(EclipseXml.FILE_PROTOCOL)) {\n              result\n                .add(VirtualFileManager.constructUrl(JarFileSystem.PROTOCOL, jarJavadocPath.substring(EclipseXml.FILE_PROTOCOL.length())));\n            }\n            else {\n              result.add(javadocPath);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","id":74876,"modified_method":"@Nullable\n  private List<String> getJavadocAttribute(Element element) {\n    Element attributes = element.getChild(\"attributes\");\n    if (attributes == null) {\n      return null;\n    }\n    List<String> result = new ArrayList<String>();\n    for (Object o : attributes.getChildren(\"attribute\")) {\n      if (Comparing.strEqual(((Element)o).getAttributeValue(\"name\"), \"javadoc_location\")) {\n        Element attribute = (Element)o;\n        String javadocPath = attribute.getAttributeValue(\"value\");\n        if (!SystemInfo.isWindows) {\n          javadocPath = javadocPath.replaceFirst(EclipseXml.FILE_PROTOCOL, EclipseXml.FILE_PROTOCOL + \"/\");\n        }\n        if (javadocPath.startsWith(EclipseXml.FILE_PROTOCOL) &&\n            new File(javadocPath.substring(EclipseXml.FILE_PROTOCOL.length())).exists()) {\n          result.add(VfsUtil.pathToUrl(javadocPath.substring(EclipseXml.FILE_PROTOCOL.length())));\n        }\n        else {\n\n          final String protocol = VirtualFileManager.extractProtocol(javadocPath);\n          if (Comparing.strEqual(protocol, HttpFileSystem.getInstance().getProtocol())) {\n            result.add(javadocPath);\n          }\n          else if (javadocPath.startsWith(EclipseXml.JAR_PREFIX)) {\n            final String jarJavadocPath = javadocPath.substring(EclipseXml.JAR_PREFIX.length());\n            if (jarJavadocPath.startsWith(EclipseXml.PLATFORM_PROTOCOL)) {\n              String relativeToPlatform = jarJavadocPath.substring(EclipseXml.PLATFORM_PROTOCOL.length() + \"resources\".length());\n              result\n                .add(VirtualFileManager.constructUrl(JarFileSystem.PROTOCOL, new File(myRootPath).getParent() + \"/\" + relativeToPlatform));\n            }\n            else if (jarJavadocPath.startsWith(EclipseXml.FILE_PROTOCOL)) {\n              result\n                .add(VirtualFileManager.constructUrl(JarFileSystem.PROTOCOL, jarJavadocPath.substring(EclipseXml.FILE_PROTOCOL.length())));\n            }\n            else {\n              result.add(javadocPath);\n            }\n          }\n        }\n      }\n    }\n    return result;\n  }","commit_id":"7ed512998322e638d6eb055460d5088cb8d8e57d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getUrl(final String path) {\n    String url = null;\n    if (path.startsWith(\"/\")) {\n      final String relativePath = new File(myRootPath).getParent() + \"/\" + path;\n      final File file = new File(relativePath);\n      if (file.exists()) {\n        url = VfsUtil.pathToUrl(relativePath);\n      } else if (new File(path).exists()) {\n        url = VfsUtil.pathToUrl(path);\n      } else if (path.indexOf('/') < path.length() - 1){\n        final String relativeToOtherModule = path.substring(path.indexOf('/', 1) + 1);\n        final Module otherModule = ModuleManager.getInstance(myProject).findModuleByName(path.substring(1, path.indexOf('/', 1)));\n        if (otherModule != null) {\n          final VirtualFile[] contentRoots = ModuleRootManager.getInstance(otherModule).getContentRoots();\n          if (contentRoots.length > 0) {\n            final File relativeToOtherModuleFile = new File(contentRoots[0].getPath(), relativeToOtherModule);\n            if (relativeToOtherModuleFile.exists()) {\n              url = VfsUtil.pathToUrl(relativeToOtherModuleFile.getPath());\n            }\n          }\n        } else if (myCurrentRoots != null) {\n          for (String currentRoot : myCurrentRoots) {\n            final File relativeToOtherModuleFile = new File(currentRoot, relativeToOtherModule);\n            if (relativeToOtherModuleFile.exists()) {\n              url = VfsUtil.pathToUrl(relativeToOtherModuleFile.getPath());\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (url == null) {\n      final String absPath = myRootPath + \"/\" + path;\n      if (new File(absPath).exists()) {\n        url = VfsUtil.pathToUrl(absPath);\n      }\n      else {\n        url = VfsUtil.pathToUrl(path);\n      }\n    }\n    final VirtualFile localFile = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (localFile != null) {\n      final VirtualFile jarFile = JarFileSystem.getInstance().getJarRootForLocalFile(localFile);\n      if (jarFile != null) {\n        url = jarFile.getUrl();\n      }\n    }\n    return url;\n  }","id":74877,"modified_method":"private String getUrl(final String path) {\n    String url = null;\n    if (path.startsWith(\"/\")) {\n      final String relativePath = new File(myRootPath).getParent() + \"/\" + path;\n      final File file = new File(relativePath);\n      if (file.exists()) {\n        url = VfsUtil.pathToUrl(relativePath);\n      } else if (new File(path).exists()) {\n        url = VfsUtil.pathToUrl(path);\n      } else if (path.indexOf('/') < path.length() - 1){\n        final String relativeToOtherModule = path.substring(path.indexOf('/', 1) + 1);\n        final Module otherModule = ModuleManager.getInstance(myProject).findModuleByName(path.substring(1, path.indexOf('/', 1)));\n        if (otherModule != null) {\n          final VirtualFile[] contentRoots = ModuleRootManager.getInstance(otherModule).getContentRoots();\n          for (VirtualFile contentRoot : contentRoots) {\n            final File relativeToOtherModuleFile = new File(contentRoot.getPath(), relativeToOtherModule);\n            if (relativeToOtherModuleFile.exists()) {\n              url = VfsUtil.pathToUrl(relativeToOtherModuleFile.getPath());\n              break;\n            }\n          }\n\n        } else if (myCurrentRoots != null) {\n          for (String currentRoot : myCurrentRoots) {\n            final File relativeToOtherModuleFile = new File(currentRoot, relativeToOtherModule);\n            if (relativeToOtherModuleFile.exists()) {\n              url = VfsUtil.pathToUrl(relativeToOtherModuleFile.getPath());\n              break;\n            }\n          }\n        }\n      }\n    }\n    if (url == null) {\n      final String absPath = myRootPath + \"/\" + path;\n      if (new File(absPath).exists()) {\n        url = VfsUtil.pathToUrl(absPath);\n      }\n      else {\n        url = VfsUtil.pathToUrl(path);\n      }\n    }\n    final VirtualFile localFile = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (localFile != null) {\n      final VirtualFile jarFile = JarFileSystem.getInstance().getJarRootForLocalFile(localFile);\n      if (jarFile != null) {\n        url = jarFile.getUrl();\n      }\n    }\n    return url;\n  }","commit_id":"7ed512998322e638d6eb055460d5088cb8d8e57d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static String getRelativePath(final String url,\n                                       String[] kind,\n                                       boolean replaceVars,\n                                       final Project project,\n                                       final VirtualFile contentRoot) {\n    final VirtualFile projectBaseDir = contentRoot != null ? contentRoot.getParent() : project.getBaseDir();\n    assert projectBaseDir != null;\n    VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (file != null) {\n      if (file.getFileSystem() instanceof JarFileSystem) {\n        file = JarFileSystem.getInstance().getVirtualFileForJar(file);\n      }\n      assert file != null;\n      if (contentRoot != null) {\n        if (VfsUtil.isAncestor(contentRoot, file, false)) {\n          return VfsUtil.getRelativePath(file, contentRoot, '/');\n        } else {\n          final Module module = ModuleUtil.findModuleForFile(file, project);\n          if (module != null) {\n            final VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n            if (contentRoots.length > 0 && VfsUtil.isAncestor(contentRoots[0], file, false)) {\n              return \"/\" + module.getName() + \"/\" + VfsUtil.getRelativePath(file, contentRoots[0], '/');\n            }\n          }\n        }\n      }\n      if (VfsUtil.isAncestor(projectBaseDir, file, false)) {\n        return \"/\" + VfsUtil.getRelativePath(file, projectBaseDir, '/');\n      }\n      else {\n        return replaceVars ? stripIDEASpecificPrefix(url, kind) : ProjectRootManagerImpl.extractLocalPath(url);\n      }\n    }\n    else {\n      if (contentRoot != null) {\n        final String rootUrl = contentRoot.getUrl();\n        if (url.startsWith(rootUrl) && url.length() > rootUrl.length()) {\n          return url.substring(rootUrl.length() + 1); //without leading /\n        }\n      }\n      final String projectUrl = projectBaseDir.getUrl();\n      if (url.startsWith(projectUrl)) {\n        return url.substring(projectUrl.length()); //leading /\n      }\n\n      return replaceVars ? stripIDEASpecificPrefix(url, kind) : ProjectRootManagerImpl.extractLocalPath(url);\n    }\n  }","id":74878,"modified_method":"public static String getRelativePath(final String url,\n                                       String[] kind,\n                                       boolean replaceVars,\n                                       final Project project,\n                                       final VirtualFile contentRoot) {\n    final VirtualFile projectBaseDir = contentRoot != null ? contentRoot.getParent() : project.getBaseDir();\n    assert projectBaseDir != null;\n    VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (file != null) {\n      if (file.getFileSystem() instanceof JarFileSystem) {\n        file = JarFileSystem.getInstance().getVirtualFileForJar(file);\n      }\n      assert file != null;\n      if (contentRoot != null) {\n        if (VfsUtil.isAncestor(contentRoot, file, false)) {\n          return VfsUtil.getRelativePath(file, contentRoot, '/');\n        } else {\n          final Module module = ModuleUtil.findModuleForFile(file, project);\n          if (module != null) {\n            final VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n            for (VirtualFile otherRoot : contentRoots) {\n              if (VfsUtil.isAncestor(otherRoot, file, false)) {\n                return \"/\" + module.getName() + \"/\" + VfsUtil.getRelativePath(file, otherRoot, '/');\n              }\n            }\n          }\n        }\n      }\n      if (VfsUtil.isAncestor(projectBaseDir, file, false)) {\n        return \"/\" + VfsUtil.getRelativePath(file, projectBaseDir, '/');\n      }\n      else {\n        return replaceVars ? stripIDEASpecificPrefix(url, kind) : ProjectRootManagerImpl.extractLocalPath(url);\n      }\n    }\n    else {\n      if (contentRoot != null) {\n        final String rootUrl = contentRoot.getUrl();\n        if (url.startsWith(rootUrl) && url.length() > rootUrl.length()) {\n          return url.substring(rootUrl.length() + 1); //without leading /\n        }\n      }\n      final String projectUrl = projectBaseDir.getUrl();\n      if (url.startsWith(projectUrl)) {\n        return url.substring(projectUrl.length()); //leading /\n      }\n\n      return replaceVars ? stripIDEASpecificPrefix(url, kind) : ProjectRootManagerImpl.extractLocalPath(url);\n    }\n  }","commit_id":"7ed512998322e638d6eb055460d5088cb8d8e57d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void createClasspathEntry(OrderEntry entry, Element classpathRoot, Element oldRoot) throws ConversionException {\n    if (entry instanceof ModuleSourceOrderEntry) {\n      final ContentEntry[] entries = ((ModuleSourceOrderEntry)entry).getRootModel().getContentEntries();\n      if (entries.length > 0) {\n        final ContentEntry contentEntry = entries[0];\n        for (SourceFolder sourceFolder : contentEntry.getSourceFolders()) {\n          addOrderEntry(EclipseXml.SRC_KIND, getRelativePath(sourceFolder.getUrl()), classpathRoot, oldRoot);\n        }\n      }\n    }\n    else if (entry instanceof ModuleOrderEntry) {\n      Element orderEntry = addOrderEntry(EclipseXml.SRC_KIND, \"/\" + ((ModuleOrderEntry)entry).getModuleName(), classpathRoot, oldRoot);\n      setAttributeIfAbsent(orderEntry, EclipseXml.COMBINEACCESSRULES_ATTR, EclipseXml.FALSE_VALUE);\n      setExported(orderEntry, ((ExportableOrderEntry)entry));\n    }\n    else if (entry instanceof LibraryOrderEntry) {\n      final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)entry;\n      final String libraryName = libraryOrderEntry.getLibraryName();\n      if (libraryOrderEntry.isModuleLevel()) {\n        if (libraryName != null && libraryName.contains(IdeaXml.JUNIT)) {\n          final Element orderEntry =\n            addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JUNIT_CONTAINER + \"/\" + libraryName.substring(IdeaXml.JUNIT.length()),\n                          classpathRoot, oldRoot);\n          setExported(orderEntry, libraryOrderEntry);\n        }\n        else {\n          final String[] files = libraryOrderEntry.getUrls(OrderRootType.CLASSES);\n          if (files.length > 0) {\n            final String[] kind = new String[]{EclipseXml.LIB_KIND};\n            final String relativeClassPath = getRelativePath(files[0], kind);\n            final Element orderEntry = addOrderEntry(kind[0], relativeClassPath, classpathRoot, oldRoot);\n\n            final String[] srcFiles = libraryOrderEntry.getUrls(OrderRootType.SOURCES);\n            setOrRemoveAttribute(orderEntry, EclipseXml.SOURCEPATH_ATTR, srcFiles.length == 0\n                                                                         ? null\n                                                                         : getRelativePath(srcFiles[srcFiles.length - 1], new String[1],\n                                                                                           Comparing.strEqual(kind[0], EclipseXml.VAR_KIND),\n                                                                                           myModel.getModule().getProject(),\n                                                                                           getContentRoot()));\n\n            //clear javadocs before write new\n            final List children = new ArrayList(orderEntry.getChildren(EclipseXml.ATTRIBUTES_TAG));\n            for (Object o : children) {\n              ((Element)o).detach();\n            }\n            final String[] docUrls = libraryOrderEntry.getUrls(JavadocOrderRootType.getInstance());\n            for (final String docUrl : docUrls) {\n              setJavadocPath(orderEntry, docUrl);\n            }\n\n            setExported(orderEntry, libraryOrderEntry);\n          }\n        }\n\n      }\n      else {\n        final Element orderEntry;\n        if (Comparing.strEqual(libraryName, IdeaXml.ECLIPSE_LIBRARY)) {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.ECLIPSE_PLATFORM, classpathRoot, oldRoot);\n        }\n        else {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.USER_LIBRARY + \"/\" + libraryName, classpathRoot, oldRoot);\n        }\n        setExported(orderEntry, libraryOrderEntry);\n      }\n    }\n    else if (entry instanceof JdkOrderEntry) {\n      if (entry instanceof InheritedJdkOrderEntry) {\n        addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JRE_CONTAINER, classpathRoot, oldRoot);\n      }\n      else {\n        final Sdk jdk = ((JdkOrderEntry)entry).getJdk();\n        String jdkLink;\n        if (jdk == null) {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n        }\n        else {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n          if (jdk.getSdkType() instanceof JavaSdkType) {\n            jdkLink += EclipseXml.JAVA_SDK_TYPE;\n          }\n          jdkLink += \"/\" + jdk.getName();\n        }\n        addOrderEntry(EclipseXml.CON_KIND, jdkLink, classpathRoot, oldRoot);\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown EclipseProjectModel.ClasspathEntry: \" + entry.getClass());\n    }\n  }","id":74879,"modified_method":"private void createClasspathEntry(OrderEntry entry, Element classpathRoot, Element oldRoot) throws ConversionException {\n    if (entry instanceof ModuleSourceOrderEntry) {\n      final ContentEntry[] entries = ((ModuleSourceOrderEntry)entry).getRootModel().getContentEntries();\n      if (entries.length > 0) {\n        final ContentEntry contentEntry = entries[0];\n        for (SourceFolder sourceFolder : contentEntry.getSourceFolders()) {\n          addOrderEntry(EclipseXml.SRC_KIND, getRelativePath(sourceFolder.getUrl()), classpathRoot, oldRoot);\n        }\n      }\n    }\n    else if (entry instanceof ModuleOrderEntry) {\n      Element orderEntry = addOrderEntry(EclipseXml.SRC_KIND, \"/\" + ((ModuleOrderEntry)entry).getModuleName(), classpathRoot, oldRoot);\n      setAttributeIfAbsent(orderEntry, EclipseXml.COMBINEACCESSRULES_ATTR, EclipseXml.FALSE_VALUE);\n      setExported(orderEntry, ((ExportableOrderEntry)entry));\n    }\n    else if (entry instanceof LibraryOrderEntry) {\n      final LibraryOrderEntry libraryOrderEntry = (LibraryOrderEntry)entry;\n      final String libraryName = libraryOrderEntry.getLibraryName();\n      if (libraryOrderEntry.isModuleLevel()) {\n        if (libraryName != null && libraryName.contains(IdeaXml.JUNIT)) {\n          final Element orderEntry =\n            addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JUNIT_CONTAINER + \"/\" + libraryName.substring(IdeaXml.JUNIT.length()),\n                          classpathRoot, oldRoot);\n          setExported(orderEntry, libraryOrderEntry);\n        }\n        else {\n          final String[] files = libraryOrderEntry.getUrls(OrderRootType.CLASSES);\n          if (files.length > 0) {\n            final Project project = myModel.getModule().getProject();\n            final String[] kind = new String[]{EclipseXml.LIB_KIND};\n            String relativeClassPath = getRelativePath(files[0], kind);\n\n            final String[] srcFiles = libraryOrderEntry.getUrls(OrderRootType.SOURCES);\n            final String relativePath;\n            if (srcFiles.length == 0) {\n              relativePath = null;\n            }\n            else {\n              final String[] srcKind = new String[1];\n              final boolean replaceVarsInSrc = Comparing.strEqual(kind[0], EclipseXml.VAR_KIND);\n              relativePath = getRelativePath(srcFiles[srcFiles.length - 1], srcKind, replaceVarsInSrc, project, getContentRoot());\n              if (replaceVarsInSrc && srcKind[0] == null) {\n                kind[0] = EclipseXml.LIB_KIND;\n                relativeClassPath = getRelativePath(files[0], kind, false, project, getContentRoot());\n              }\n            }\n\n            final Element orderEntry = addOrderEntry(kind[0], relativeClassPath, classpathRoot, oldRoot);\n            setOrRemoveAttribute(orderEntry, EclipseXml.SOURCEPATH_ATTR, relativePath);\n\n            //clear javadocs before write new\n            final List children = new ArrayList(orderEntry.getChildren(EclipseXml.ATTRIBUTES_TAG));\n            for (Object o : children) {\n              ((Element)o).detach();\n            }\n            final String[] docUrls = libraryOrderEntry.getUrls(JavadocOrderRootType.getInstance());\n            for (final String docUrl : docUrls) {\n              setJavadocPath(orderEntry, docUrl);\n            }\n\n            setExported(orderEntry, libraryOrderEntry);\n          }\n        }\n\n      }\n      else {\n        final Element orderEntry;\n        if (Comparing.strEqual(libraryName, IdeaXml.ECLIPSE_LIBRARY)) {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.ECLIPSE_PLATFORM, classpathRoot, oldRoot);\n        }\n        else {\n          orderEntry = addOrderEntry(EclipseXml.CON_KIND, EclipseXml.USER_LIBRARY + \"/\" + libraryName, classpathRoot, oldRoot);\n        }\n        setExported(orderEntry, libraryOrderEntry);\n      }\n    }\n    else if (entry instanceof JdkOrderEntry) {\n      if (entry instanceof InheritedJdkOrderEntry) {\n        addOrderEntry(EclipseXml.CON_KIND, EclipseXml.JRE_CONTAINER, classpathRoot, oldRoot);\n      }\n      else {\n        final Sdk jdk = ((JdkOrderEntry)entry).getJdk();\n        String jdkLink;\n        if (jdk == null) {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n        }\n        else {\n          jdkLink = EclipseXml.JRE_CONTAINER;\n          if (jdk.getSdkType() instanceof JavaSdkType) {\n            jdkLink += EclipseXml.JAVA_SDK_TYPE;\n          }\n          jdkLink += \"/\" + jdk.getName();\n        }\n        addOrderEntry(EclipseXml.CON_KIND, jdkLink, classpathRoot, oldRoot);\n      }\n    }\n    else {\n      throw new ConversionException(\"Unknown EclipseProjectModel.ClasspathEntry: \" + entry.getClass());\n    }\n  }","commit_id":"7ed512998322e638d6eb055460d5088cb8d8e57d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void populateModulesMenuItemsFromModels( List models, Menu menu )\n    {\n        if ( models != null && models.size() > 1 )\n        {\n            Iterator reactorItr = models.iterator();\n\n            while ( reactorItr.hasNext() )\n            {\n                Model model = (Model) reactorItr.next();\n\n                String reactorUrl = model.getUrl();\n                String name = model.getName();\n\n                appendMenuItem( menu, name, reactorUrl );\n            }\n        }\n    }","id":74880,"modified_method":"private void populateModulesMenuItemsFromModels( List models, Menu menu )\n    {\n        if ( models != null && models.size() > 1 )\n        {\n            Iterator reactorItr = models.iterator();\n\n            while ( reactorItr.hasNext() )\n            {\n                Model model = (Model) reactorItr.next();\n\n                String reactorUrl = model.getUrl();\n                String name = model.getName();\n\n                appendMenuItem( menu, name, reactorUrl, model.getArtifactId() );\n            }\n        }\n    }","commit_id":"05370d0f5f046763b302a572d5161e6d7e9d4258","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void populateModulesMenuItemsFromReactorProjects( Menu menu )\n    {\n        if ( reactorProjects != null && reactorProjects.size() > 1 )\n        {\n            Iterator reactorItr = reactorProjects.iterator();\n\n            while ( reactorItr.hasNext() )\n            {\n                MavenProject reactorProject = (MavenProject) reactorItr.next();\n\n                if ( reactorProject != null && reactorProject.getParent() != null &&\n                    project.getArtifactId().equals( reactorProject.getParent().getArtifactId() ) )\n                {\n                    String reactorUrl = reactorProject.getUrl();\n                    String name = reactorProject.getName();\n\n                    appendMenuItem( menu, name, reactorUrl );\n                }\n            }\n        }\n    }","id":74881,"modified_method":"private void populateModulesMenuItemsFromReactorProjects( Menu menu )\n    {\n        if ( reactorProjects != null && reactorProjects.size() > 1 )\n        {\n            Iterator reactorItr = reactorProjects.iterator();\n\n            while ( reactorItr.hasNext() )\n            {\n                MavenProject reactorProject = (MavenProject) reactorItr.next();\n\n                if ( reactorProject != null && reactorProject.getParent() != null &&\n                    project.getArtifactId().equals( reactorProject.getParent().getArtifactId() ) )\n                {\n                    String reactorUrl = reactorProject.getUrl();\n                    String name = reactorProject.getName();\n\n                    appendMenuItem( menu, name, reactorUrl, reactorProject.getArtifactId() );\n                }\n            }\n        }\n    }","commit_id":"05370d0f5f046763b302a572d5161e6d7e9d4258","url":"https://github.com/apache/maven-plugins"},{"original_method":"private void appendMenuItem( Menu menu, String name, String href )\n    {\n        if ( href != null )\n        {\n            MenuItem item = new MenuItem();\n            item.setName( name );\n\n            String baseUrl = project.getUrl();\n            href = getRelativePath( href, baseUrl );\n\n            if ( href.endsWith( \"/\" ) )\n            {\n                item.setHref( href + \"index.html\" );\n            }\n            else\n            {\n                item.setHref( href + \"/index.html\" );\n            }\n            menu.addItem( item );\n        }\n    }","id":74882,"modified_method":"private void appendMenuItem( Menu menu, String name, String href, String defaultHref )\n    {\n        String selectedHref = href;\n\n        if ( selectedHref == null )\n        {\n            selectedHref = defaultHref;\n        }\n\n        MenuItem item = new MenuItem();\n        item.setName( name );\n\n        String baseUrl = project.getUrl();\n        if ( baseUrl != null )\n        {\n            selectedHref = getRelativePath( selectedHref, baseUrl );\n        }\n\n        if ( selectedHref.endsWith( \"/\" ) )\n        {\n            item.setHref( selectedHref + \"index.html\" );\n        }\n        else\n        {\n            item.setHref( selectedHref + \"/index.html\" );\n        }\n        menu.addItem( item );\n    }","commit_id":"05370d0f5f046763b302a572d5161e6d7e9d4258","url":"https://github.com/apache/maven-plugins"},{"original_method":"private Module setUpModule(final String path) throws IOException, JDOMException, ConversionException {\n    final File classpathFile = new File(path, EclipseXml.DOT_CLASSPATH_EXT);\n    String fileText = new String(FileUtil.loadFileText(classpathFile)).replaceAll(\"\\\\$ROOT\\\\$\", getProject().getBaseDir().getPath());\n    if (!SystemInfo.isWindows) {\n      fileText = fileText.replaceAll(EclipseXml.FILE_PROTOCOL + \"/\", EclipseXml.FILE_PROTOCOL);\n    }\n    final Element classpathElement = JDOMUtil.loadDocument(fileText).getRootElement();\n    final Module module = ApplicationManager.getApplication().runWriteAction(new Computable<Module>() {\n      public Module compute() {\n        return ModuleManager.getInstance(getProject())\n          .newModule(path + \"/\" + EclipseProjectFinder.findProjectName(path) + IdeaXml.IML_EXT, StdModuleTypes.JAVA);\n      }\n    });\n    final ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();\n    final EclipseClasspathReader classpathReader = new EclipseClasspathReader(path, getProject(), null);\n    classpathReader.init(rootModel);\n    classpathReader\n      .readClasspath(rootModel, new ArrayList<String>(), new ArrayList<String>(), new HashSet<String>(), new HashSet<String>(), null,\n                     classpathElement);\n    rootModel.commit();\n    return module;\n  }","id":74883,"modified_method":"private static Module setUpModule(final String path, final Project project) throws IOException, JDOMException, ConversionException {\n    final File classpathFile = new File(path, EclipseXml.DOT_CLASSPATH_EXT);\n    String fileText = new String(FileUtil.loadFileText(classpathFile)).replaceAll(\"\\\\$ROOT\\\\$\", project.getBaseDir().getPath());\n    if (!SystemInfo.isWindows) {\n      fileText = fileText.replaceAll(EclipseXml.FILE_PROTOCOL + \"/\", EclipseXml.FILE_PROTOCOL);\n    }\n    final Element classpathElement = JDOMUtil.loadDocument(fileText).getRootElement();\n    final Module module = ApplicationManager.getApplication().runWriteAction(new Computable<Module>() {\n      public Module compute() {\n        return ModuleManager.getInstance(project)\n          .newModule(path + \"/\" + EclipseProjectFinder.findProjectName(path) + IdeaXml.IML_EXT, StdModuleTypes.JAVA);\n      }\n    });\n    final ModifiableRootModel rootModel = ModuleRootManager.getInstance(module).getModifiableModel();\n    final EclipseClasspathReader classpathReader = new EclipseClasspathReader(path, project, null);\n    classpathReader.init(rootModel);\n    classpathReader\n      .readClasspath(rootModel, new ArrayList<String>(), new ArrayList<String>(), new HashSet<String>(), new HashSet<String>(), null,\n                     classpathElement);\n    rootModel.commit();\n    return module;\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testAbsolutePaths() throws Exception {\n    doTest(\"/parent/parent/test\");\n  }","id":74884,"modified_method":"public void testAbsolutePaths() throws Exception {\n    doTest(\"/parent/parent/test\", getProject());\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest(final String relativePath) throws Exception {\n    final String path = getProject().getBaseDir().getPath() + relativePath;\n    checkModule(path, setUpModule(path));\n  }","id":74885,"modified_method":"protected static void doTest(final String relativePath, final Project project) throws Exception {\n    final String path = project.getBaseDir().getPath() + relativePath;\n    checkModule(path, setUpModule(path, project));\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void doTest() throws Exception {\n    doTest(\"/test\");\n  }","id":74886,"modified_method":"private void doTest() throws Exception {\n    doTest(\"/test\", getProject());\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public void testMultiModuleDependencies() throws Exception {\n    List<String> paths = Arrays.asList(getProject().getBaseDir().getPath() + \"/multi/m1\", getProject().getBaseDir().getPath() + \"/multi/m2/m22\");\n\n    for (final String path: paths) {\n      setUpModule(path);\n    }\n\n    for (Module module : ModuleManager.getInstance(getProject()).getModules()) {\n      checkModule(new File(module.getModuleFilePath()).getParent(), module);\n    }\n  }","id":74887,"modified_method":"public void testMultiModuleDependencies() throws Exception {\n    List<String> paths = Arrays.asList(getProject().getBaseDir().getPath() + \"/multi/m1\", getProject().getBaseDir().getPath() + \"/multi/m2/m22\");\n\n    for (final String path: paths) {\n      setUpModule(path, getProject());\n    }\n\n    for (Module module : ModuleManager.getInstance(getProject()).getModules()) {\n      checkModule(new File(module.getModuleFilePath()).getParent(), module);\n    }\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void checkModule(String path, Module module) throws IOException, JDOMException, ConversionException {\n    final File classpathFile1 = new File(path, EclipseXml.DOT_CLASSPATH_EXT);\n    if (!classpathFile1.exists()) return;\n    String fileText1 = new String(FileUtil.loadFileText(classpathFile1)).replaceAll(\"\\\\$ROOT\\\\$\", getProject().getBaseDir().getPath());\n    if (!SystemInfo.isWindows) {\n      fileText1 = fileText1.replaceAll(EclipseXml.FILE_PROTOCOL + \"/\", EclipseXml.FILE_PROTOCOL);\n    }\n    final Element classpathElement1 = JDOMUtil.loadDocument(fileText1).getRootElement();\n    final ModifiableRootModel model = ModuleRootManager.getInstance(module).getModifiableModel();\n    final Element resultClasspathElement = new Element(EclipseXml.CLASSPATH_TAG);\n    new EclipseClasspathWriter(model).writeClasspath(resultClasspathElement, classpathElement1);\n    model.dispose();\n\n    String resulted = new String(JDOMUtil.printDocument(new Document(resultClasspathElement), \"\\n\"));\n    Assert.assertTrue(resulted.replaceAll(StringUtil.escapeToRegexp(getProject().getBaseDir().getPath()), \"\\\\$ROOT\\\\$\"),\n                      JDOMUtil.areElementsEqual(classpathElement1, resultClasspathElement));\n  }","id":74888,"modified_method":"private static void checkModule(String path, Module module) throws IOException, JDOMException, ConversionException {\n    final File classpathFile1 = new File(path, EclipseXml.DOT_CLASSPATH_EXT);\n    if (!classpathFile1.exists()) return;\n    String fileText1 = new String(FileUtil.loadFileText(classpathFile1)).replaceAll(\"\\\\$ROOT\\\\$\", module.getProject().getBaseDir().getPath());\n    if (!SystemInfo.isWindows) {\n      fileText1 = fileText1.replaceAll(EclipseXml.FILE_PROTOCOL + \"/\", EclipseXml.FILE_PROTOCOL);\n    }\n    final Element classpathElement1 = JDOMUtil.loadDocument(fileText1).getRootElement();\n    final ModifiableRootModel model = ModuleRootManager.getInstance(module).getModifiableModel();\n    final Element resultClasspathElement = new Element(EclipseXml.CLASSPATH_TAG);\n    new EclipseClasspathWriter(model).writeClasspath(resultClasspathElement, classpathElement1);\n    model.dispose();\n\n    String resulted = new String(JDOMUtil.printDocument(new Document(resultClasspathElement), \"\\n\"));\n    Assert.assertTrue(resulted.replaceAll(StringUtil.escapeToRegexp(module.getProject().getBaseDir().getPath()), \"\\\\$ROOT\\\\$\"),\n                      JDOMUtil.areElementsEqual(classpathElement1, resultClasspathElement));\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private String getRelativePath(String url) {\n    final Project project = myModel.getModule().getProject();\n    final VirtualFile contentRoot = getContentRoot();\n    final VirtualFile projectBaseDir = contentRoot != null ? contentRoot.getParent() : project.getBaseDir();\n    assert projectBaseDir != null;\n    VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (file != null) {\n      if (file.getFileSystem() instanceof JarFileSystem) {\n        file = JarFileSystem.getInstance().getVirtualFileForJar(file);\n      }\n      assert file != null;\n      if (contentRoot != null) {\n        if (VfsUtil.isAncestor(contentRoot, file, false)) {\n          return VfsUtil.getRelativePath(file, contentRoot, '/');\n        } else {\n          final Module module = ModuleUtil.findModuleForFile(file, project);\n          if (module != null) {\n            final VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\n            for (VirtualFile otherRoot : contentRoots) {\n              if (VfsUtil.isAncestor(otherRoot, file, false)) {\n                return \"/\" + module.getName() + \"/\" + VfsUtil.getRelativePath(file, otherRoot, '/');\n              }\n            }\n          }\n        }\n      }\n      if (VfsUtil.isAncestor(projectBaseDir, file, false)) {\n        return \"/\" + VfsUtil.getRelativePath(file, projectBaseDir, '/');\n      }\n      else {\n        return ProjectRootManagerImpl.extractLocalPath(url);\n      }\n    }\n    else {\n      if (contentRoot != null) {\n        final String rootUrl = contentRoot.getUrl();\n        if (url.startsWith(rootUrl) && url.length() > rootUrl.length()) {\n          return url.substring(rootUrl.length() + 1); //without leading /\n        }\n      }\n      final String projectUrl = projectBaseDir.getUrl();\n      if (url.startsWith(projectUrl)) {\n        return url.substring(projectUrl.length()); //leading /\n      }\n\n      return ProjectRootManagerImpl.extractLocalPath(url);\n    }\n  }","id":74889,"modified_method":"private String getRelativePath(String url) {\n    final Project project = myModel.getModule().getProject();\n    final VirtualFile contentRoot = getContentRoot();\n    final VirtualFile projectBaseDir = contentRoot != null ? contentRoot.getParent() : project.getBaseDir();\n    assert projectBaseDir != null;\n    VirtualFile file = VirtualFileManager.getInstance().findFileByUrl(url);\n    if (file != null) {\n      if (file.getFileSystem() instanceof JarFileSystem) {\n        file = JarFileSystem.getInstance().getVirtualFileForJar(file);\n      }\n      assert file != null;\n      if (contentRoot != null) {\n        if (VfsUtil.isAncestor(contentRoot, file, false)) {\n          return VfsUtil.getRelativePath(file, contentRoot, '/');\n        } else {\n          final String path = relativeToOtherModulePath(project, file);\n          if (path != null) {\n            return path;\n          }\n        }\n      }\n      if (VfsUtil.isAncestor(projectBaseDir, file, false)) {\n        return \"/\" + VfsUtil.getRelativePath(file, projectBaseDir, '/');\n      }\n      else {\n        return ProjectRootManagerImpl.extractLocalPath(url);\n      }\n    }\n    else {\n      if (contentRoot != null) {\n        final String rootUrl = contentRoot.getUrl();\n        if (url.startsWith(rootUrl) && url.length() > rootUrl.length()) {\n          return url.substring(rootUrl.length() + 1); //without leading /\n        }\n      }\n      final String projectUrl = projectBaseDir.getUrl();\n      if (url.startsWith(projectUrl)) {\n        return url.substring(projectUrl.length()); //leading /\n      }\n\n      return ProjectRootManagerImpl.extractLocalPath(url);\n    }\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void setJavadocPath(final Element element, String javadocPath) {\n    if (javadocPath != null) {\n      Element child = new Element(EclipseXml.ATTRIBUTES_TAG);\n      element.addContent(child);\n\n      Element attrElement = child.getChild(EclipseXml.ATTRIBUTE_TAG);\n      if (attrElement == null) {\n        attrElement = new Element(EclipseXml.ATTRIBUTE_TAG);\n        child.addContent(attrElement);\n      }\n\n      attrElement.setAttribute(\"name\", \"javadoc_location\");\n\n      final String protocol = VirtualFileManager.extractProtocol(javadocPath);\n      if (!Comparing.strEqual(protocol, HttpFileSystem.getInstance().getProtocol())) {\n        final String path = VfsUtil.urlToPath(javadocPath);\n        final VirtualFile contentRoot = getContentRoot();\n        final VirtualFile baseDir = contentRoot != null ? contentRoot.getParent() : myModel.getModule().getProject().getBaseDir();\n        if (Comparing.strEqual(protocol, JarFileSystem.getInstance().getProtocol())) {\n          final VirtualFile javadocFile =\n            JarFileSystem.getInstance().getVirtualFileForJar(VirtualFileManager.getInstance().findFileByUrl(javadocPath));\n          if (javadocFile != null && VfsUtil.isAncestor(baseDir, javadocFile, false)) {\n            if (javadocPath.indexOf(JarFileSystem.JAR_SEPARATOR) == -1) {\n              javadocPath = StringUtil.trimEnd(javadocPath, \"/\") + JarFileSystem.JAR_SEPARATOR;\n            }\n            javadocPath = EclipseXml.JAR_PREFIX +\n                          EclipseXml.PLATFORM_PROTOCOL +\n                          \"resource/\" +\n                          VfsUtil.getRelativePath(javadocFile, baseDir, '/') +\n                          javadocPath.substring(javadocFile.getUrl().length() - 1);\n          }\n          else {\n            javadocPath = EclipseXml.JAR_PREFIX + EclipseXml.FILE_PROTOCOL + StringUtil.trimStart(path, \"/\");\n          }\n        }\n        else if (new File(path).exists()) {\n          javadocPath = EclipseXml.FILE_PROTOCOL + StringUtil.trimStart(path, \"/\");\n        }\n      }\n\n      attrElement.setAttribute(\"value\", javadocPath);\n    }\n  }","id":74890,"modified_method":"private void setJavadocPath(final Element element, String javadocPath) {\n    if (javadocPath != null) {\n      Element child = new Element(EclipseXml.ATTRIBUTES_TAG);\n      element.addContent(child);\n\n      Element attrElement = child.getChild(EclipseXml.ATTRIBUTE_TAG);\n      if (attrElement == null) {\n        attrElement = new Element(EclipseXml.ATTRIBUTE_TAG);\n        child.addContent(attrElement);\n      }\n\n      attrElement.setAttribute(\"name\", \"javadoc_location\");\n\n      final String protocol = VirtualFileManager.extractProtocol(javadocPath);\n      if (!Comparing.strEqual(protocol, HttpFileSystem.getInstance().getProtocol())) {\n        final String path = VfsUtil.urlToPath(javadocPath);\n        final VirtualFile contentRoot = getContentRoot();\n        final Project project = myModel.getModule().getProject();\n        final VirtualFile baseDir = contentRoot != null ? contentRoot.getParent() : project.getBaseDir();\n        if (Comparing.strEqual(protocol, JarFileSystem.getInstance().getProtocol())) {\n          final VirtualFile javadocFile =\n            JarFileSystem.getInstance().getVirtualFileForJar(VirtualFileManager.getInstance().findFileByUrl(javadocPath));\n          if (javadocFile != null) {\n            String relativeUrl = relativeToOtherModulePath(project, javadocFile);\n            if (relativeUrl == null && VfsUtil.isAncestor(baseDir, javadocFile, false)) {\n              relativeUrl = \"/\" + VfsUtil.getRelativePath(javadocFile, baseDir, '/');\n            }\n            if (relativeUrl != null) {\n              if (javadocPath.indexOf(JarFileSystem.JAR_SEPARATOR) == -1) {\n                javadocPath = StringUtil.trimEnd(javadocPath, \"/\") + JarFileSystem.JAR_SEPARATOR;\n              }\n              javadocPath = EclipseXml.JAR_PREFIX +\n                            EclipseXml.PLATFORM_PROTOCOL +\n                            \"resource\" +\n                            relativeUrl +\n                            javadocPath.substring(javadocFile.getUrl().length() - 1);\n            } else {\n              javadocPath = EclipseXml.JAR_PREFIX + EclipseXml.FILE_PROTOCOL + StringUtil.trimStart(path, \"/\");\n            }\n          }\n          else {\n            javadocPath = EclipseXml.JAR_PREFIX + EclipseXml.FILE_PROTOCOL + StringUtil.trimStart(path, \"/\");\n          }\n        }\n        else if (new File(path).exists()) {\n          javadocPath = EclipseXml.FILE_PROTOCOL + StringUtil.trimStart(path, \"/\");\n        }\n      }\n\n      attrElement.setAttribute(\"value\", javadocPath);\n    }\n  }","commit_id":"556f44a5106fcbb7a4cc3f971fdbb6126c0a3a0f","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private List getReports()\n        throws MojoExecutionException\n    {\n        // TODO: not the best solution. Perhaps a mojo tag that causes the plugin manager to populate project reports instead?\n\n        List reportPlugins = project.getReportPlugins();\n\n        if ( project.getModel().getReports() != null )\n        {\n            getLog().error(\n                \"DEPRECATED: Plugin contains a <reports/> section: this is IGNORED - please use <reporting/> instead.\" );\n        }\n\n        List reports = new ArrayList();\n        if ( reportPlugins != null )\n        {\n            for ( Iterator it = reportPlugins.iterator(); it.hasNext(); )\n            {\n                org.apache.maven.model.ReportPlugin reportPlugin = (org.apache.maven.model.ReportPlugin) it.next();\n\n                try\n                {\n                    pluginManager.verifyPlugin( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                reportPlugin.getVersion(), project, settings, localRepository );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve version for report plugin\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n\n                try\n                {\n                    List reportSets = reportPlugin.getReportSets();\n                    if ( reportSets == null || reportSets.isEmpty() )\n                    {\n                        reports.addAll(\n                            pluginManager.getReports( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                      reportPlugin.getVersion(), null, session, project ) );\n\n                    }\n                    else\n                    {\n                        for ( Iterator j = reportSets.iterator(); j.hasNext(); )\n                        {\n                            ReportSet reportSet = (ReportSet) j.next();\n\n                            reports.addAll(\n                                pluginManager.getReports( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                          reportPlugin.getVersion(), reportSet, session, project ) );\n                        }\n                    }\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginConfigurationException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n            }\n        }\n        return reports;\n    }","id":74891,"modified_method":"private List getReports()\n        throws MojoExecutionException\n    {\n        // TODO: not the best solution. Perhaps a mojo tag that causes the plugin manager to populate project reports instead?\n\n        List reportPlugins = project.getReportPlugins();\n\n        if ( project.getModel().getReports() != null )\n        {\n            getLog().error(\n                \"DEPRECATED: Plugin contains a <reports/> section: this is IGNORED - please use <reporting/> instead.\" );\n        }\n\n        List reports = new ArrayList();\n        if ( reportPlugins != null )\n        {\n            for ( Iterator it = reportPlugins.iterator(); it.hasNext(); )\n            {\n                org.apache.maven.model.ReportPlugin reportPlugin = (org.apache.maven.model.ReportPlugin) it.next();\n\n                try\n                {\n                    pluginManager.verifyPlugin( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                reportPlugin.getVersion(), project, settings, localRepository );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve version for report plugin\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n\n                try\n                {\n                    List reportSets = reportPlugin.getReportSets();\n\n                    List reportsList = new ArrayList();\n\n                    if ( reportSets == null || reportSets.isEmpty() )\n                    {\n                        reportsList = pluginManager.getReports( reportPlugin.getGroupId(),\n                                                                reportPlugin.getArtifactId(),\n                                                                reportPlugin.getVersion(),\n                                                                null,\n                                                                session,\n                                                                project );\n\n                    }\n                    else\n                    {\n                        for ( Iterator j = reportSets.iterator(); j.hasNext(); )\n                        {\n                            ReportSet reportSet = (ReportSet) j.next();\n\n                            reportsList = pluginManager.getReports( reportPlugin.getGroupId(),\n                                                                    reportPlugin.getArtifactId(),\n                                                                    reportPlugin.getVersion(),\n                                                                    reportSet,\n                                                                    session,\n                                                                    project );\n                        }\n                    }\n\n                    for ( Iterator i = reportsList.iterator(); i.hasNext(); )\n                    {\n                        Object obj = i.next();\n\n                        //TODO: Remove this test when getReports will return only reports object\n                        if ( obj instanceof MavenReport )\n                        {\n                            reports.add( obj );\n                        }\n                    }\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginConfigurationException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n            }\n        }\n        return reports;\n    }","commit_id":"504e281d0ed2f163eb7a476b4701ea96f2095620","url":"https://github.com/apache/maven"},{"original_method":"private List getReports()\n        throws MojoExecutionException\n    {\n        // TODO: not the best solution. Perhaps a mojo tag that causes the plugin manager to populate project reports instead?\n\n        List reportPlugins = project.getReportPlugins();\n\n        if ( project.getModel().getReports() != null )\n        {\n            getLog().error(\n                \"DEPRECATED: Plugin contains a <reports/> section: this is IGNORED - please use <reporting/> instead.\" );\n        }\n\n        List reports = new ArrayList();\n        if ( reportPlugins != null )\n        {\n            for ( Iterator it = reportPlugins.iterator(); it.hasNext(); )\n            {\n                org.apache.maven.model.ReportPlugin reportPlugin = (org.apache.maven.model.ReportPlugin) it.next();\n\n                try\n                {\n                    pluginManager.verifyPlugin( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                reportPlugin.getVersion(), project, settings, localRepository );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve version for report plugin\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n\n                try\n                {\n                    List reportSets = reportPlugin.getReportSets();\n                    if ( reportSets == null || reportSets.isEmpty() )\n                    {\n                        reports.addAll(\n                            pluginManager.getReports( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                      reportPlugin.getVersion(), null, session, project ) );\n\n                    }\n                    else\n                    {\n                        for ( Iterator j = reportSets.iterator(); j.hasNext(); )\n                        {\n                            ReportSet reportSet = (ReportSet) j.next();\n\n                            reports.addAll(\n                                pluginManager.getReports( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                          reportPlugin.getVersion(), reportSet, session, project ) );\n                        }\n                    }\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginConfigurationException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n            }\n        }\n        return reports;\n    }","id":74892,"modified_method":"private List getReports()\n        throws MojoExecutionException\n    {\n        // TODO: not the best solution. Perhaps a mojo tag that causes the plugin manager to populate project reports instead?\n\n        List reportPlugins = project.getReportPlugins();\n\n        if ( project.getModel().getReports() != null )\n        {\n            getLog().error(\n                \"DEPRECATED: Plugin contains a <reports/> section: this is IGNORED - please use <reporting/> instead.\" );\n        }\n\n        List reports = new ArrayList();\n        if ( reportPlugins != null )\n        {\n            for ( Iterator it = reportPlugins.iterator(); it.hasNext(); )\n            {\n                org.apache.maven.model.ReportPlugin reportPlugin = (org.apache.maven.model.ReportPlugin) it.next();\n\n                try\n                {\n                    pluginManager.verifyPlugin( reportPlugin.getGroupId(), reportPlugin.getArtifactId(),\n                                                reportPlugin.getVersion(), project, settings, localRepository );\n                }\n                catch ( ArtifactResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Cannot resolve version for report plugin\", e );\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Cannot find report plugin\", e );\n                }\n\n                try\n                {\n                    List reportSets = reportPlugin.getReportSets();\n\n                    List reportsList = new ArrayList();\n\n                    if ( reportSets == null || reportSets.isEmpty() )\n                    {\n                        reportsList = pluginManager.getReports( reportPlugin.getGroupId(),\n                                                                reportPlugin.getArtifactId(),\n                                                                reportPlugin.getVersion(),\n                                                                null,\n                                                                session,\n                                                                project );\n\n                    }\n                    else\n                    {\n                        for ( Iterator j = reportSets.iterator(); j.hasNext(); )\n                        {\n                            ReportSet reportSet = (ReportSet) j.next();\n\n                            reportsList = pluginManager.getReports( reportPlugin.getGroupId(),\n                                                                    reportPlugin.getArtifactId(),\n                                                                    reportPlugin.getVersion(),\n                                                                    reportSet,\n                                                                    session,\n                                                                    project );\n                        }\n                    }\n\n                    for ( Iterator i = reportsList.iterator(); i.hasNext(); )\n                    {\n                        Object obj = i.next();\n\n                        //TODO: Remove this test when getReports will return only reports object\n                        if ( obj instanceof MavenReport )\n                        {\n                            reports.add( obj );\n                        }\n                    }\n                }\n                catch ( PluginManagerException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginVersionResolutionException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n                catch ( PluginConfigurationException e )\n                {\n                    throw new MojoExecutionException( \"Error getting reports\", e );\n                }\n            }\n        }\n        return reports;\n    }","commit_id":"8dd18cfb991cd9ee3118eba4eb3612c17589a4c0","url":"https://github.com/apache/maven-plugins"},{"original_method":"/**\n     * Called upon stopping the bundle. This will block until all pending events are\n     * delivered. An IllegalStateException will be thrown on new events starting with\n     * the begin of this method. However, it might take some time until we settle\n     * down which is somewhat cumbersome given that the spec asks for return in\n     * a timely manner.\n     *\n     * @param context The bundle context passed by the framework\n     *\n     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n     */\n    public void stop(final BundleContext context)\n    {\n        if ( m_config != null )\n        {\n            m_config.destroy();\n        }\n        m_config = null;\n    }","id":74893,"modified_method":"/**\n     * Called upon stopping the bundle. This will block until all pending events are\n     * delivered. An IllegalStateException will be thrown on new events starting with\n     * the begin of this method. However, it might take some time until we settle\n     * down which is somewhat cumbersome given that the spec asks for return in\n     * a timely manner.\n     *\n     * @param context The bundle context passed by the framework\n     *\n     * @see org.osgi.framework.BundleActivator#stop(org.osgi.framework.BundleContext)\n     */\n    public void stop(final BundleContext context)\n    {\n        if ( m_config != null )\n        {\n            m_config.destroy();\n        }\n        m_config = null;\n\n        // FELIX-2089: \"unset\" the bundle context on stop\n        LogWrapper.setContext(null);\n    }","commit_id":"2b09d4867dbc47bb3f6f2e63120ab4cbe73e12e4","url":"https://github.com/apache/felix"},{"original_method":"/**\n     * Set the <tt>BundleContext<\/tt> of the bundle. This method registers a service\n     * listener for LogServices with the framework that are subsequently used to \n     * log messages.\n     * \n     *  @param context The context of the bundle.\n     */\n    public static void setContext(final BundleContext context)\n    {\n        LogWrapperLoader.m_singleton.setBundleContext(context);\n\n        try\n        {\n            context.addServiceListener(new ServiceListener()\n            {\n                // Add a newly available LogService reference to the singleton.\n                public void serviceChanged(final ServiceEvent event)\n                {\n                    if (ServiceEvent.REGISTERED == event.getType())\n                    {\n                        LogWrapperLoader.m_singleton.addLoggerRef(\n                            event.getServiceReference());\n                    }\n                    // unregistered services are handled in the next log operation.\n                }\n\n            }, \"(\" + Constants.OBJECTCLASS\n                + \"=org.osgi.service.log.LogService)\");\n\n            // Add all available LogService references to the singleton.\n            final ServiceReference[] refs = context.getServiceReferences(\n                \"org.osgi.service.log.LogService\", null);\n\n            if (null != refs)\n            {\n                for (int i = 0; i < refs.length; i++)\n                {\n                    LogWrapperLoader.m_singleton.addLoggerRef(refs[i]);\n                }\n            }\n        } catch (InvalidSyntaxException e)\n        {\n            // this never happens\n        }\n    }","id":74894,"modified_method":"/**\n     * Set the <tt>BundleContext<\/tt> of the bundle. This method registers a service\n     * listener for LogServices with the framework that are subsequently used to\n     * log messages.\n     * <p>\n     * If the bundle context is <code>null<\/code>, the service listener is\n     * unregistered and all remaining references to LogServices dropped before\n     * internally clearing the bundle context field.\n     *\n     *  @param context The context of the bundle.\n     */\n    public static void setContext( final BundleContext context )\n    {\n        LogWrapper logWrapper = LogWrapperLoader.m_singleton;\n\n        // context is removed, unregister and drop references\n        if ( context == null )\n        {\n            if ( logWrapper.m_logServiceListener != null )\n            {\n                logWrapper.m_context.removeServiceListener( logWrapper.m_logServiceListener );\n                logWrapper.m_logServiceListener = null;\n            }\n            logWrapper.removeLoggerRefs();\n        }\n\n        // set field\n        logWrapper.setBundleContext( context );\n\n        // context is set, register and get existing services\n        if ( context != null )\n        {\n            try\n            {\n                ServiceListener listener = new ServiceListener()\n                {\n                    // Add a newly available LogService reference to the singleton.\n                    public void serviceChanged( final ServiceEvent event )\n                    {\n                        if ( ServiceEvent.REGISTERED == event.getType() )\n                        {\n                            LogWrapperLoader.m_singleton.addLoggerRef( event.getServiceReference() );\n                        }\n                        // unregistered services are handled in the next log operation.\n                    }\n\n                };\n                context.addServiceListener( listener, \"(\" + Constants.OBJECTCLASS + \"=org.osgi.service.log.LogService)\" );\n                logWrapper.m_logServiceListener = listener;\n\n                // Add all available LogService references to the singleton.\n                final ServiceReference[] refs = context.getServiceReferences( \"org.osgi.service.log.LogService\", null );\n\n                if ( null != refs )\n                {\n                    for ( int i = 0; i < refs.length; i++ )\n                    {\n                        logWrapper.addLoggerRef( refs[i] );\n                    }\n                }\n            }\n            catch ( InvalidSyntaxException e )\n            {\n                // this never happens\n            }\n        }\n    }","commit_id":"2b09d4867dbc47bb3f6f2e63120ab4cbe73e12e4","url":"https://github.com/apache/felix"},{"original_method":"public X509TrustManager getTrustManager(\r\n        final Iterable<String> identitiesToTest,\r\n        final CertificateMatcher clientVerifier,\r\n        final CertificateMatcher serverVerifier)\r\n        throws GeneralSecurityException\r\n    {\r\n        // obtain the default X509 trust manager\r\n        X509TrustManager defaultTm = null;\r\n        TrustManagerFactory tmFactory =\r\n            TrustManagerFactory.getInstance(TrustManagerFactory\r\n                .getDefaultAlgorithm());\r\n        tmFactory.init((KeyStore) null);\r\n        for (TrustManager m : tmFactory.getTrustManagers())\r\n        {\r\n            if (m instanceof X509TrustManager)\r\n            {\r\n                defaultTm = (X509TrustManager) m;\r\n                break;\r\n            }\r\n        }\r\n        if (defaultTm == null)\r\n            throw new GeneralSecurityException(\r\n                \"No default X509 trust manager found\");\r\n\r\n        final X509TrustManager tm = defaultTm;\r\n\r\n        return new X509TrustManager()\r\n        {\r\n            private boolean serverCheck;\r\n\r\n            public X509Certificate[] getAcceptedIssuers()\r\n            {\r\n                return tm.getAcceptedIssuers();\r\n            }\r\n\r\n            public void checkServerTrusted(X509Certificate[] chain,\r\n                String authType) throws CertificateException\r\n            {\r\n                serverCheck = true;\r\n                checkCertTrusted(chain, authType);\r\n            }\r\n\r\n            public void checkClientTrusted(X509Certificate[] chain,\r\n                String authType) throws CertificateException\r\n            {\r\n                serverCheck = false;\r\n                checkCertTrusted(chain, authType);\r\n            }\r\n\r\n            private void checkCertTrusted(X509Certificate[] chain,\r\n                String authType) throws CertificateException\r\n            {\r\n                if(config.getBoolean(PNAME_ALWAYS_TRUST, false))\r\n                    return;\r\n\r\n                try\r\n                {\r\n                    // check the certificate itself (issuer, validity)\r\n                    try\r\n                    {\r\n                        chain = tryBuildChain(chain);\r\n                    }\r\n                    catch (Exception e)\r\n                    {} // don't care and take the chain as is\r\n\r\n                    if(serverCheck)\r\n                        tm.checkServerTrusted(chain, authType);\r\n                    else\r\n                        tm.checkClientTrusted(chain, authType);\r\n\r\n                    if(identitiesToTest == null\r\n                        || !identitiesToTest.iterator().hasNext())\r\n                        return;\r\n                    else if(serverCheck)\r\n                        serverVerifier.verify(identitiesToTest, chain[0]);\r\n                    else\r\n                        clientVerifier.verify(identitiesToTest, chain[0]);\r\n\r\n                    // ok, globally valid cert\r\n                }\r\n                catch (CertificateException e)\r\n                {\r\n                    String thumbprint = getThumbprint(\r\n                        chain[0], THUMBPRINT_HASH_ALGORITHM);\r\n                    String propName = null;\r\n                    String message = null;\r\n                    String storedCert = null;\r\n                    String appName =\r\n                        R.getSettingsString(\"service.gui.APPLICATION_NAME\");\r\n\r\n                    if (identitiesToTest == null\r\n                        || !identitiesToTest.iterator().hasNext())\r\n                    {\r\n                        propName =\r\n                            PNAME_CERT_TRUST_PREFIX + \".server.\" + thumbprint;\r\n                        message =\r\n                            R.getI18NString(\"service.gui.\"\r\n                                + \"CERT_DIALOG_DESCRIPTION_TXT_NOHOST\",\r\n                                new String[] {\r\n                                    appName\r\n                                }\r\n                            );\r\n\r\n                        // get the thumbprint from the permanent allowances\r\n                        storedCert = config.getString(propName);\r\n                        // not found? check the session allowances\r\n                        if (storedCert == null)\r\n                            storedCert =\r\n                                sessionAllowedCertificates.get(propName);\r\n                    }\r\n                    else\r\n                    {\r\n                        for (String identity : identitiesToTest)\r\n                        {\r\n                            if (serverCheck)\r\n                            {\r\n                                message =\r\n                                    R.getI18NString(\r\n                                        \"service.gui.\"\r\n                                        + \"CERT_DIALOG_DESCRIPTION_TXT\",\r\n                                        new String[] {\r\n                                            appName,\r\n                                            identitiesToTest.toString()\r\n                                        }\r\n                                    );\r\n                                propName =\r\n                                    PNAME_CERT_TRUST_PREFIX + \".param.\"\r\n                                        + identity;\r\n                            }\r\n                            else\r\n                            {\r\n                                message =\r\n                                    R.getI18NString(\r\n                                        \"service.gui.\"\r\n                                        + \"CERT_DIALOG_PEER_DESCRIPTION_TXT\",\r\n                                        new String[] {\r\n                                            appName,\r\n                                            identitiesToTest.toString()\r\n                                        }\r\n                                    );\r\n                                propName =\r\n                                    PNAME_CERT_TRUST_PREFIX + \".param.\"\r\n                                        + identity;\r\n                            }\r\n\r\n                            // get the thumbprint from the permanent allowances\r\n                            storedCert = config.getString(propName);\r\n                            // not found? check the session allowances\r\n                            if (storedCert == null)\r\n                                storedCert =\r\n                                    sessionAllowedCertificates.get(propName);\r\n\r\n                            // stop search for further saved allowances if we\r\n                            // found a match\r\n                            if (storedCert != null)\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n                    if (!thumbprint.equals(storedCert))\r\n                    {\r\n                        switch (verify(chain, message))\r\n                        {\r\n                        case DO_NOT_TRUST:\r\n                            throw new CertificateException(\r\n                                \"The peer provided certificate with Subject <\"\r\n                                    + chain[0].getSubjectDN()\r\n                                    + \"> is not trusted\");\r\n                        case TRUST_ALWAYS:\r\n                            config.setProperty(propName, thumbprint);\r\n                            break;\r\n                        case TRUST_THIS_SESSION_ONLY:\r\n                            sessionAllowedCertificates\r\n                                .put(propName, thumbprint);\r\n                            break;\r\n                        }\r\n                    }\r\n                    // ok, we've seen this certificate before\r\n                }\r\n            }\r\n\r\n            private X509Certificate[] tryBuildChain(X509Certificate[] chain)\r\n                throws IOException,\r\n                URISyntaxException,\r\n                CertificateException\r\n            {\r\n                // Only try to build chains for servers that send only their\r\n                // own cert, but no issuer. This also matches self signed (will\r\n                // be ignored later) and Root-CA signed certs. In this case we\r\n                // throw the Root-CA away after the lookup\r\n                if (chain.length != 1)\r\n                    return chain;\r\n\r\n                // ignore self signed certs\r\n                if (chain[0].getIssuerDN().equals(chain[0].getSubjectDN()))\r\n                    return chain;\r\n\r\n                // prepare for the newly created chain\r\n                List<X509Certificate> newChain =\r\n                    new ArrayList<X509Certificate>(chain.length + 4);\r\n                for (X509Certificate cert : chain)\r\n                {\r\n                    newChain.add(cert);\r\n                }\r\n\r\n                // search from the topmost certificate upwards\r\n                CertificateFactory certFactory =\r\n                    CertificateFactory.getInstance(\"X.509\");\r\n                X509Certificate current = chain[chain.length - 1];\r\n                boolean foundParent;\r\n                int chainLookupCount = 0;\r\n                do\r\n                {\r\n                    foundParent = false;\r\n                    // extract the url(s) where the parent certificate can be\r\n                    // found\r\n                    byte[] aiaBytes =\r\n                        current.getExtensionValue(\r\n                            X509Extension.authorityInfoAccess.getId());\r\n                    if (aiaBytes == null)\r\n                        break;\r\n\r\n                    DEROctetString octs =\r\n                        (DEROctetString) ASN1Object.fromByteArray(aiaBytes);\r\n                    ASN1InputStream as = new ASN1InputStream(octs.getOctets());\r\n                    AuthorityInformationAccess aia =\r\n                        AuthorityInformationAccess\r\n                            .getInstance(as.readObject());\r\n                    // the AIA may contain different URLs and types, try all\r\n                    // of them\r\n                    for (AccessDescription ad : aia.getAccessDescriptions())\r\n                    {\r\n                        // we are only interested in the issuer certificate,\r\n                        // not in OCSP urls the like\r\n                        if (!ad.getAccessMethod().equals(\r\n                            AccessDescription.id_ad_caIssuers))\r\n                            continue;\r\n\r\n                        GeneralName gn = ad.getAccessLocation();\r\n                        if (!(gn.getTagNo() ==\r\n                                GeneralName.uniformResourceIdentifier\r\n                            && gn.getName() instanceof DERIA5String))\r\n                            continue;\r\n\r\n                        URI uri =\r\n                            new URI(((DERIA5String) gn.getName()).getString());\r\n                        // only http(s) urls; LDAP is taken care of in the\r\n                        // default implementation\r\n                        if (!(uri.getScheme().equalsIgnoreCase(\"http\") || uri\r\n                            .getScheme().equals(\"https\")))\r\n                            continue;\r\n\r\n                        if (logger.isDebugEnabled())\r\n                            logger\r\n                                .debug(\"Downloading parent certificate for <\"\r\n                                    + current.getSubjectDN()\r\n                                    + \"> from <\"\r\n                                    + uri\r\n                                    + \">\");\r\n\r\n                        try\r\n                        {\r\n                            InputStream is =\r\n                                HttpUtils.openURLConnection(uri.toString())\r\n                                    .getContent();\r\n                            X509Certificate cert =\r\n                                (X509Certificate) certFactory\r\n                                    .generateCertificate(is);\r\n                            if(!cert.getIssuerDN().equals(cert.getSubjectDN()))\r\n                            {\r\n                                newChain.add(cert);\r\n                                foundParent = true;\r\n                                current = cert;\r\n                                break; // an AD was valid, ignore others\r\n                            }\r\n                            else\r\n                                logger.debug(\"Parent is self-signed, ignoring\");\r\n                        }\r\n                        catch (Exception e)\r\n                        {\r\n                            logger.debug(\"Could not download from <\" + uri\r\n                                + \">\");\r\n                        }\r\n                    }\r\n                    chainLookupCount++;\r\n                }\r\n                while (foundParent && chainLookupCount < 10);\r\n                chain = newChain.toArray(chain);\r\n                return chain;\r\n            }\r\n        };\r\n    }","id":74895,"modified_method":"public X509TrustManager getTrustManager(\r\n        final Iterable<String> identitiesToTest,\r\n        final CertificateMatcher clientVerifier,\r\n        final CertificateMatcher serverVerifier)\r\n        throws GeneralSecurityException\r\n    {\r\n        // obtain the default X509 trust manager\r\n        X509TrustManager defaultTm = null;\r\n        TrustManagerFactory tmFactory =\r\n            TrustManagerFactory.getInstance(TrustManagerFactory\r\n                .getDefaultAlgorithm());\r\n        tmFactory.init((KeyStore) null);\r\n        for (TrustManager m : tmFactory.getTrustManagers())\r\n        {\r\n            if (m instanceof X509TrustManager)\r\n            {\r\n                defaultTm = (X509TrustManager) m;\r\n                break;\r\n            }\r\n        }\r\n        if (defaultTm == null)\r\n            throw new GeneralSecurityException(\r\n                \"No default X509 trust manager found\");\r\n\r\n        final X509TrustManager tm = defaultTm;\r\n\r\n        return new X509TrustManager()\r\n        {\r\n            private boolean serverCheck;\r\n\r\n            public X509Certificate[] getAcceptedIssuers()\r\n            {\r\n                return tm.getAcceptedIssuers();\r\n            }\r\n\r\n            public void checkServerTrusted(X509Certificate[] chain,\r\n                String authType) throws CertificateException\r\n            {\r\n                serverCheck = true;\r\n                checkCertTrusted(chain, authType);\r\n            }\r\n\r\n            public void checkClientTrusted(X509Certificate[] chain,\r\n                String authType) throws CertificateException\r\n            {\r\n                serverCheck = false;\r\n                checkCertTrusted(chain, authType);\r\n            }\r\n\r\n            private void checkCertTrusted(X509Certificate[] chain,\r\n                String authType) throws CertificateException\r\n            {\r\n                // check and default configurations for property\r\n                // if missing default is null - false\r\n                String defaultAlwaysTrustMode =\r\n                    CertificateVerificationActivator.getResources()\r\n                        .getSettingsString(\r\n                            CertificateService.PNAME_ALWAYS_TRUST);\r\n\r\n                if(config.getBoolean(PNAME_ALWAYS_TRUST,\r\n                            Boolean.parseBoolean(defaultAlwaysTrustMode)))\r\n                    return;\r\n\r\n                try\r\n                {\r\n                    // check the certificate itself (issuer, validity)\r\n                    try\r\n                    {\r\n                        chain = tryBuildChain(chain);\r\n                    }\r\n                    catch (Exception e)\r\n                    {} // don't care and take the chain as is\r\n\r\n                    if(serverCheck)\r\n                        tm.checkServerTrusted(chain, authType);\r\n                    else\r\n                        tm.checkClientTrusted(chain, authType);\r\n\r\n                    if(identitiesToTest == null\r\n                        || !identitiesToTest.iterator().hasNext())\r\n                        return;\r\n                    else if(serverCheck)\r\n                        serverVerifier.verify(identitiesToTest, chain[0]);\r\n                    else\r\n                        clientVerifier.verify(identitiesToTest, chain[0]);\r\n\r\n                    // ok, globally valid cert\r\n                }\r\n                catch (CertificateException e)\r\n                {\r\n                    String thumbprint = getThumbprint(\r\n                        chain[0], THUMBPRINT_HASH_ALGORITHM);\r\n                    String propName = null;\r\n                    String message = null;\r\n                    String storedCert = null;\r\n                    String appName =\r\n                        R.getSettingsString(\"service.gui.APPLICATION_NAME\");\r\n\r\n                    if (identitiesToTest == null\r\n                        || !identitiesToTest.iterator().hasNext())\r\n                    {\r\n                        propName =\r\n                            PNAME_CERT_TRUST_PREFIX + \".server.\" + thumbprint;\r\n                        message =\r\n                            R.getI18NString(\"service.gui.\"\r\n                                + \"CERT_DIALOG_DESCRIPTION_TXT_NOHOST\",\r\n                                new String[] {\r\n                                    appName\r\n                                }\r\n                            );\r\n\r\n                        // get the thumbprint from the permanent allowances\r\n                        storedCert = config.getString(propName);\r\n                        // not found? check the session allowances\r\n                        if (storedCert == null)\r\n                            storedCert =\r\n                                sessionAllowedCertificates.get(propName);\r\n                    }\r\n                    else\r\n                    {\r\n                        for (String identity : identitiesToTest)\r\n                        {\r\n                            if (serverCheck)\r\n                            {\r\n                                message =\r\n                                    R.getI18NString(\r\n                                        \"service.gui.\"\r\n                                        + \"CERT_DIALOG_DESCRIPTION_TXT\",\r\n                                        new String[] {\r\n                                            appName,\r\n                                            identitiesToTest.toString()\r\n                                        }\r\n                                    );\r\n                                propName =\r\n                                    PNAME_CERT_TRUST_PREFIX + \".param.\"\r\n                                        + identity;\r\n                            }\r\n                            else\r\n                            {\r\n                                message =\r\n                                    R.getI18NString(\r\n                                        \"service.gui.\"\r\n                                        + \"CERT_DIALOG_PEER_DESCRIPTION_TXT\",\r\n                                        new String[] {\r\n                                            appName,\r\n                                            identitiesToTest.toString()\r\n                                        }\r\n                                    );\r\n                                propName =\r\n                                    PNAME_CERT_TRUST_PREFIX + \".param.\"\r\n                                        + identity;\r\n                            }\r\n\r\n                            // get the thumbprint from the permanent allowances\r\n                            storedCert = config.getString(propName);\r\n                            // not found? check the session allowances\r\n                            if (storedCert == null)\r\n                                storedCert =\r\n                                    sessionAllowedCertificates.get(propName);\r\n\r\n                            // stop search for further saved allowances if we\r\n                            // found a match\r\n                            if (storedCert != null)\r\n                                break;\r\n                        }\r\n                    }\r\n\r\n                    if (!thumbprint.equals(storedCert))\r\n                    {\r\n                        switch (verify(chain, message))\r\n                        {\r\n                        case DO_NOT_TRUST:\r\n                            throw new CertificateException(\r\n                                \"The peer provided certificate with Subject <\"\r\n                                    + chain[0].getSubjectDN()\r\n                                    + \"> is not trusted\");\r\n                        case TRUST_ALWAYS:\r\n                            config.setProperty(propName, thumbprint);\r\n                            break;\r\n                        case TRUST_THIS_SESSION_ONLY:\r\n                            sessionAllowedCertificates\r\n                                .put(propName, thumbprint);\r\n                            break;\r\n                        }\r\n                    }\r\n                    // ok, we've seen this certificate before\r\n                }\r\n            }\r\n\r\n            private X509Certificate[] tryBuildChain(X509Certificate[] chain)\r\n                throws IOException,\r\n                URISyntaxException,\r\n                CertificateException\r\n            {\r\n                // Only try to build chains for servers that send only their\r\n                // own cert, but no issuer. This also matches self signed (will\r\n                // be ignored later) and Root-CA signed certs. In this case we\r\n                // throw the Root-CA away after the lookup\r\n                if (chain.length != 1)\r\n                    return chain;\r\n\r\n                // ignore self signed certs\r\n                if (chain[0].getIssuerDN().equals(chain[0].getSubjectDN()))\r\n                    return chain;\r\n\r\n                // prepare for the newly created chain\r\n                List<X509Certificate> newChain =\r\n                    new ArrayList<X509Certificate>(chain.length + 4);\r\n                for (X509Certificate cert : chain)\r\n                {\r\n                    newChain.add(cert);\r\n                }\r\n\r\n                // search from the topmost certificate upwards\r\n                CertificateFactory certFactory =\r\n                    CertificateFactory.getInstance(\"X.509\");\r\n                X509Certificate current = chain[chain.length - 1];\r\n                boolean foundParent;\r\n                int chainLookupCount = 0;\r\n                do\r\n                {\r\n                    foundParent = false;\r\n                    // extract the url(s) where the parent certificate can be\r\n                    // found\r\n                    byte[] aiaBytes =\r\n                        current.getExtensionValue(\r\n                            X509Extension.authorityInfoAccess.getId());\r\n                    if (aiaBytes == null)\r\n                        break;\r\n\r\n                    DEROctetString octs =\r\n                        (DEROctetString) ASN1Object.fromByteArray(aiaBytes);\r\n                    ASN1InputStream as = new ASN1InputStream(octs.getOctets());\r\n                    AuthorityInformationAccess aia =\r\n                        AuthorityInformationAccess\r\n                            .getInstance(as.readObject());\r\n                    // the AIA may contain different URLs and types, try all\r\n                    // of them\r\n                    for (AccessDescription ad : aia.getAccessDescriptions())\r\n                    {\r\n                        // we are only interested in the issuer certificate,\r\n                        // not in OCSP urls the like\r\n                        if (!ad.getAccessMethod().equals(\r\n                            AccessDescription.id_ad_caIssuers))\r\n                            continue;\r\n\r\n                        GeneralName gn = ad.getAccessLocation();\r\n                        if (!(gn.getTagNo() ==\r\n                                GeneralName.uniformResourceIdentifier\r\n                            && gn.getName() instanceof DERIA5String))\r\n                            continue;\r\n\r\n                        URI uri =\r\n                            new URI(((DERIA5String) gn.getName()).getString());\r\n                        // only http(s) urls; LDAP is taken care of in the\r\n                        // default implementation\r\n                        if (!(uri.getScheme().equalsIgnoreCase(\"http\") || uri\r\n                            .getScheme().equals(\"https\")))\r\n                            continue;\r\n\r\n                        if (logger.isDebugEnabled())\r\n                            logger\r\n                                .debug(\"Downloading parent certificate for <\"\r\n                                    + current.getSubjectDN()\r\n                                    + \"> from <\"\r\n                                    + uri\r\n                                    + \">\");\r\n\r\n                        try\r\n                        {\r\n                            InputStream is =\r\n                                HttpUtils.openURLConnection(uri.toString())\r\n                                    .getContent();\r\n                            X509Certificate cert =\r\n                                (X509Certificate) certFactory\r\n                                    .generateCertificate(is);\r\n                            if(!cert.getIssuerDN().equals(cert.getSubjectDN()))\r\n                            {\r\n                                newChain.add(cert);\r\n                                foundParent = true;\r\n                                current = cert;\r\n                                break; // an AD was valid, ignore others\r\n                            }\r\n                            else\r\n                                logger.debug(\"Parent is self-signed, ignoring\");\r\n                        }\r\n                        catch (Exception e)\r\n                        {\r\n                            logger.debug(\"Could not download from <\" + uri\r\n                                + \">\");\r\n                        }\r\n                    }\r\n                    chainLookupCount++;\r\n                }\r\n                while (foundParent && chainLookupCount < 10);\r\n                chain = newChain.toArray(chain);\r\n                return chain;\r\n            }\r\n        };\r\n    }","commit_id":"bbb7ea155dc2b62a15cf03cbedc2d0261547a28e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     * @param bc the bundle context\n     * @throws Exception if something goes wrong\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        uiService = (UIService) bundleContext.getService(uiServiceRef);\n\n        Dictionary<String, String> properties\n            = new Hashtable<String, String>();\n\n        // If the general configuration form is disabled don't continue.\n        if (!getConfigurationService().getBoolean(DISABLED_PROP, false))\n        {\n            ConfigurationManager.loadGuiConfigurations();\n\n            properties.put( ConfigurationForm.FORM_TYPE,\n                            ConfigurationForm.GENERAL_TYPE);\n            bundleContext\n                .registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                        \"net.java.sip.communicator.plugin.\" +\n                        \"generalconfig.GeneralConfigurationPanel\",\n                        getClass().getClassLoader(),\n                        \"plugin.generalconfig.PLUGIN_ICON\",\n                        \"service.gui.GENERAL\",\n                        0),\n                    properties);\n        }\n\n        // Registers the sip config panel as advanced configuration form.\n        properties.put( ConfigurationForm.FORM_TYPE,\n                        ConfigurationForm.ADVANCED_TYPE);\n        bundleContext.registerService(\n            ConfigurationForm.class.getName(),\n            new LazyConfigurationForm(\n                SIPConfigForm.class.getName(),\n                getClass().getClassLoader(),\n                null,\n                \"plugin.generalconfig.SIP_CALL_CONFIG\",\n                52, true),\n            properties);\n\n        /*\n         * Wait for the first ProtocolProviderService to register in order to\n         * start the auto-away functionality i.e. to call #startThread().\n         */\n        bundleContext.addServiceListener(this);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"PREFERENCES PLUGIN... [REGISTERED]\");\n    }","id":74896,"modified_method":"/**\n     * Starts this bundle.\n     * @param bc the bundle context\n     * @throws Exception if something goes wrong\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        uiService = (UIService) bundleContext.getService(uiServiceRef);\n\n        Dictionary<String, String> properties\n            = new Hashtable<String, String>();\n\n        // If the general configuration form is disabled don't continue.\n        if (!getConfigurationService().getBoolean(DISABLED_PROP, false))\n        {\n            ConfigurationManager.loadGuiConfigurations();\n\n            properties.put( ConfigurationForm.FORM_TYPE,\n                            ConfigurationForm.GENERAL_TYPE);\n            bundleContext\n                .registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                        \"net.java.sip.communicator.plugin.\" +\n                        \"generalconfig.GeneralConfigurationPanel\",\n                        getClass().getClassLoader(),\n                        \"plugin.generalconfig.PLUGIN_ICON\",\n                        \"service.gui.GENERAL\",\n                        0),\n                    properties);\n        }\n\n        // Registers the sip config panel as advanced configuration form.\n        properties.put( ConfigurationForm.FORM_TYPE,\n                        ConfigurationForm.ADVANCED_TYPE);\n        bundleContext.registerService(\n            ConfigurationForm.class.getName(),\n            new LazyConfigurationForm(\n                SIPConfigForm.class.getName(),\n                getClass().getClassLoader(),\n                null,\n                \"plugin.generalconfig.SIP_CALL_CONFIG\",\n                52, true),\n            properties);\n\n        /*\n         * Wait for the first ProtocolProviderService to register in order to\n         * start the auto-away functionality i.e. to call #startThread().\n         */\n        ServiceReference[] protocolRefs = bundleContext.getServiceReferences(\n                ProtocolProviderService.class.getName(), null);\n        if(protocolRefs != null && protocolRefs.length > 0)\n        {\n            try\n            {\n                synchronized (GeneralConfigPluginActivator.class)\n                {\n                    if (!startThreadIsCalled)\n                    {\n                        startThread();\n                        startThreadIsCalled = true;\n                    }\n                }\n            }\n            catch(Throwable t)\n            {\n                // not supposed to happen\n                logger.error(\"Error starting auto away thread\", t);\n            }\n        }\n        else\n            bundleContext.addServiceListener(this);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"PREFERENCES PLUGIN... [REGISTERED]\");\n    }","commit_id":"bbb7ea155dc2b62a15cf03cbedc2d0261547a28e","url":"https://github.com/jitsi/jitsi"},{"original_method":"/**\n     * Starts this bundle.\n     * @param bc the bundle context\n     * @throws Exception if something goes wrong\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        uiService = (UIService) bundleContext.getService(uiServiceRef);\n\n        Dictionary<String, String> properties\n            = new Hashtable<String, String>();\n\n        // If the general configuration form is disabled don't continue.\n        if (!getConfigurationService().getBoolean(DISABLED_PROP, false))\n        {\n            ConfigurationManager.loadGuiConfigurations();\n\n            properties.put( ConfigurationForm.FORM_TYPE,\n                            ConfigurationForm.GENERAL_TYPE);\n            bundleContext\n                .registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                        \"net.java.sip.communicator.plugin.\" +\n                        \"generalconfig.GeneralConfigurationPanel\",\n                        getClass().getClassLoader(),\n                        \"plugin.generalconfig.PLUGIN_ICON\",\n                        \"service.gui.GENERAL\",\n                        0),\n                    properties);\n        }\n\n        // Registers the sip config panel as advanced configuration form.\n        properties.put( ConfigurationForm.FORM_TYPE,\n                        ConfigurationForm.ADVANCED_TYPE);\n        bundleContext.registerService(\n            ConfigurationForm.class.getName(),\n            new LazyConfigurationForm(\n                SIPConfigForm.class.getName(),\n                getClass().getClassLoader(),\n                null,\n                \"plugin.generalconfig.SIP_CALL_CONFIG\",\n                52, true),\n            properties);\n\n        /*\n         * Wait for the first ProtocolProviderService to register in order to\n         * start the auto-away functionality i.e. to call #startThread().\n         */\n        bundleContext.addServiceListener(this);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"PREFERENCES PLUGIN... [REGISTERED]\");\n    }","id":74897,"modified_method":"/**\n     * Starts this bundle.\n     * @param bc the bundle context\n     * @throws Exception if something goes wrong\n     */\n    public void start(BundleContext bc)\n        throws Exception\n    {\n        bundleContext = bc;\n\n        ServiceReference uiServiceRef = bundleContext\n            .getServiceReference(UIService.class.getName());\n\n        uiService = (UIService) bundleContext.getService(uiServiceRef);\n\n        Dictionary<String, String> properties\n            = new Hashtable<String, String>();\n\n        // If the general configuration form is disabled don't continue.\n        if (!getConfigurationService().getBoolean(DISABLED_PROP, false))\n        {\n            ConfigurationManager.loadGuiConfigurations();\n\n            properties.put( ConfigurationForm.FORM_TYPE,\n                            ConfigurationForm.GENERAL_TYPE);\n            bundleContext\n                .registerService(\n                    ConfigurationForm.class.getName(),\n                    new LazyConfigurationForm(\n                        \"net.java.sip.communicator.plugin.\" +\n                        \"generalconfig.GeneralConfigurationPanel\",\n                        getClass().getClassLoader(),\n                        \"plugin.generalconfig.PLUGIN_ICON\",\n                        \"service.gui.GENERAL\",\n                        0),\n                    properties);\n        }\n\n        // Registers the sip config panel as advanced configuration form.\n        properties.put( ConfigurationForm.FORM_TYPE,\n                        ConfigurationForm.ADVANCED_TYPE);\n        bundleContext.registerService(\n            ConfigurationForm.class.getName(),\n            new LazyConfigurationForm(\n                SIPConfigForm.class.getName(),\n                getClass().getClassLoader(),\n                null,\n                \"plugin.generalconfig.SIP_CALL_CONFIG\",\n                52, true),\n            properties);\n\n        /*\n         * Wait for the first ProtocolProviderService to register in order to\n         * start the auto-away functionality i.e. to call #startThread().\n         */\n        ServiceReference[] protocolRefs = bundleContext.getServiceReferences(\n                ProtocolProviderService.class.getName(), null);\n        if(protocolRefs != null && protocolRefs.length > 0)\n        {\n            try\n            {\n                synchronized (GeneralConfigPluginActivator.class)\n                {\n                    if (!startThreadIsCalled)\n                    {\n                        startThread();\n                        startThreadIsCalled = true;\n                    }\n                }\n            }\n            catch(Throwable t)\n            {\n                // not supposed to happen\n                logger.error(\"Error starting auto away thread\", t);\n            }\n        }\n        else\n            bundleContext.addServiceListener(this);\n\n        if (logger.isInfoEnabled())\n            logger.info(\"PREFERENCES PLUGIN... [REGISTERED]\");\n    }","commit_id":"53bcd5d1d5c9cbfeed87973991df474fd1d37040","url":"https://github.com/jitsi/jitsi"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        String runtimeName = depUnit.getName();\n\n        // Check if we already have a bundle {@link Deployment}\n        if (BundleLifecycleIntegration.getDeployment(runtimeName) != null)\n            return;\n\n        // Get the manifest from the deployment's virtual file\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        if (metadata != null) {\n            try {\n                // Construct and attach the {@link BundleInfo} from {@link OSGiMetaData}\n                VirtualFile virtualFile = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n                BundleInfo info = BundleInfo.createBundleInfo(AbstractVFS.adapt(virtualFile), runtimeName, metadata);\n                depUnit.putAttachment(OSGiConstants.BUNDLE_INFO_KEY, info);\n            } catch (BundleException ex) {\n                throw MESSAGES.cannotCreateBundleDeployment(ex, depUnit);\n            }\n        }\n    }","id":74898,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        String runtimeName = depUnit.getName();\n\n        // Check if we already have a bundle {@link Deployment}\n        if (BundleLifecycleIntegration.getDeployment(runtimeName) != null)\n            return;\n\n        // Construct the {@link BundleInfo} if we have valid {@link OSGiMetaData} for a bundle deployment\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        DeploymentType deploymentType = depUnit.getAttachment(OSGiConstants.DEPLOYMENT_TYPE_KEY);\n        if (metadata != null && deploymentType != DeploymentType.Module) {\n            try {\n                // Construct and attach the {@link BundleInfo} from {@link OSGiMetaData}\n                VirtualFile virtualFile = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n                BundleInfo info = BundleInfo.createBundleInfo(AbstractVFS.adapt(virtualFile), runtimeName, metadata);\n                depUnit.putAttachment(OSGiConstants.BUNDLE_INFO_KEY, info);\n            } catch (BundleException ex) {\n                throw MESSAGES.cannotCreateBundleDeployment(ex, depUnit);\n            }\n        }\n    }","commit_id":"9b511217deafd499e2384b29763c7f71e06d7044","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        final DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(Attachments.OSGI_MANIFEST))\n            return;\n\n        // Check if we already have a bundle {@link Deployment}\n        Deployment dep = BundleLifecycleIntegration.getDeployment(depUnit.getName());\n        if (dep != null) {\n            Manifest manifest = dep.getAttachment(IntegrationConstants.MANIFEST_KEY);\n            if (manifest != null) {\n                depUnit.putAttachment(Attachments.OSGI_MANIFEST, manifest);\n                return;\n            }\n        }\n\n        final ResourceRoot deploymentRoot = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        if (deploymentRoot == null)\n            return;\n\n        // Check whether this is an OSGi manifest\n        Manifest manifest = deploymentRoot.getAttachment(Attachments.MANIFEST);\n        if (OSGiManifestBuilder.isValidBundleManifest(manifest)) {\n            depUnit.putAttachment(Attachments.OSGI_MANIFEST, manifest);\n        }\n    }","id":74899,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        Manifest manifest = depUnit.getAttachment(Attachments.OSGI_MANIFEST);\n        if (manifest != null)\n            return;\n\n        // Check if we already have a bundle {@link Deployment}\n        Deployment dep = BundleLifecycleIntegration.getDeployment(depUnit.getName());\n        if (dep != null) {\n            manifest = dep.getAttachment(IntegrationConstants.MANIFEST_KEY);\n        }\n\n        ResourceRoot deploymentRoot = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT);\n        if (manifest == null && deploymentRoot != null) {\n            manifest = deploymentRoot.getAttachment(Attachments.MANIFEST);\n        }\n\n        // Check whether this is an OSGi manifest\n        if (OSGiManifestBuilder.isValidBundleManifest(manifest)) {\n            depUnit.putAttachment(Attachments.OSGI_MANIFEST, manifest);\n            depUnit.putAttachment(OSGiConstants.DEPLOYMENT_TYPE_KEY, DeploymentType.Bundle);\n        }\n    }","commit_id":"9b511217deafd499e2384b29763c7f71e06d7044","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(OSGiConstants.OSGI_METADATA_KEY))\n            return;\n\n        // Check if we already have a bundle {@link Deployment}\n        Deployment dep = BundleLifecycleIntegration.getDeployment(depUnit.getName());\n        if (dep != null) {\n            OSGiMetaData metadata = dep.getAttachment(IntegrationConstants.OSGI_METADATA_KEY);\n            if (metadata != null) {\n                depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n                return;\n            }\n        }\n\n        Manifest manifest = depUnit.getAttachment(Attachments.OSGI_MANIFEST);\n        if (manifest != null) {\n            OSGiMetaData metadata = OSGiMetaDataBuilder.load(manifest);\n            depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n        }\n    }","id":74900,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n\n        // Check if we already have a bundle {@link Deployment}\n        Deployment dep = BundleLifecycleIntegration.getDeployment(depUnit.getName());\n        if (metadata == null && dep != null) {\n            metadata = dep.getAttachment(IntegrationConstants.OSGI_METADATA_KEY);\n        }\n\n        Manifest manifest = depUnit.getAttachment(Attachments.OSGI_MANIFEST);\n        if (metadata == null && manifest != null) {\n            metadata = OSGiMetaDataBuilder.load(manifest);\n        }\n\n        // Add a dependency on the {@link FrameworkBootstrapService}\n        // for any deployment that has valid {@link OSGiMetaData}\n        if (metadata != null) {\n            depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n            phaseContext.addDependency(FrameworkBootstrapService.SERVICE_NAME, AttachmentKey.create(Void.class));\n        }\n    }","commit_id":"9b511217deafd499e2384b29763c7f71e06d7044","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final Activation activation = Activation.valueOf(OSGiRootResource.ACTIVATION.resolveModelAttribute(context, model).asString().toUpperCase(Locale.ENGLISH));\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context);\n        final ModuleRegistrationTracker registrationTracker = new ModuleRegistrationTracker();\n\n        // Collect the subsystem extensions\n        final List<SubsystemExtension> extensions = new ArrayList<SubsystemExtension>();\n        final Iterator<SubsystemExtension> services = ServiceLoader.load(SubsystemExtension.class, getClass().getClassLoader()).iterator();\n        while(services.hasNext()) {\n            extensions.add(services.next());\n        }\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, deploymentTracker, extensions, verificationHandler));\n                newControllers.add(registrationTracker.install(serviceTarget, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_METADATA, new OSGiMetaDataStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_COMPONENTS, new OSGiComponentParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new FrameworkActivateProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_BUNDLE, new BundleDependenciesProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_DEFERRED_PHASE, new DeferredPhaseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor(registrationTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        for(SubsystemExtension extension : extensions) {\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activation));\n    }","id":74901,"modified_method":"@Override\n    protected void performBoottime(final OperationContext context, final ModelNode operation, final ModelNode model,\n            final ServiceVerificationHandler verificationHandler, final List<ServiceController<?>> newControllers) throws OperationFailedException {\n\n        LOGGER.infoActivatingSubsystem();\n\n        final Activation activation = Activation.valueOf(OSGiRootResource.ACTIVATION.resolveModelAttribute(context, model).asString().toUpperCase(Locale.ENGLISH));\n        final ServiceTarget serviceTarget = context.getServiceTarget();\n        final InitialDeploymentTracker deploymentTracker = new InitialDeploymentTracker(context);\n        final ModuleRegistrationTracker registrationTracker = new ModuleRegistrationTracker();\n\n        // Collect the subsystem extensions\n        final List<SubsystemExtension> extensions = new ArrayList<SubsystemExtension>();\n        final Iterator<SubsystemExtension> services = ServiceLoader.load(SubsystemExtension.class, getClass().getClassLoader()).iterator();\n        while(services.hasNext()) {\n            extensions.add(services.next());\n        }\n\n        context.addStep(new OperationStepHandler() {\n            @Override\n            public void execute(OperationContext context, ModelNode operation) throws OperationFailedException {\n                newControllers.add(FrameworkBootstrapService.addService(serviceTarget, resource, deploymentTracker, extensions, verificationHandler));\n                newControllers.add(registrationTracker.install(serviceTarget, verificationHandler));\n                context.completeStep(OperationContext.RollbackHandler.NOOP_ROLLBACK_HANDLER);\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        context.addStep(new AbstractDeploymentChainStep() {\n            @Override\n            protected void execute(DeploymentProcessorTarget processorTarget) {\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_MANIFEST, new OSGiManifestStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_PROPERTIES, new OSGiXServiceParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_OSGI_METADATA, new OSGiMetaDataStructureProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.STRUCTURE, Phase.STRUCTURE_BUNDLE_SUB_DEPLOYMENT, new BundleSubDeploymentMarkingProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_BUNDLE_INFO, new OSGiBundleInfoParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_DEPLOYMENT, new BundleDeploymentProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_COMPONENTS, new OSGiComponentParseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.PARSE, Phase.PARSE_OSGI_SUBSYSTEM_ACTIVATOR, new FrameworkActivateProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.REGISTER, Phase.REGISTER_BUNDLE_INSTALL, new BundleInstallProcessor(deploymentTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.DEPENDENCIES, Phase.DEPENDENCIES_BUNDLE, new BundleDependenciesProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_RESOLVE_BUNDLE, new BundleResolveProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.CONFIGURE_MODULE, Phase.CONFIGURE_DEFERRED_PHASE, new DeferredPhaseProcessor());\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_RESOLVER_MODULE, new ModuleRegisterProcessor(registrationTracker));\n                processorTarget.addDeploymentProcessor(OSGiExtension.SUBSYSTEM_NAME, Phase.INSTALL, Phase.INSTALL_BUNDLE_ACTIVATE, new BundleActivateProcessor());\n            }\n        }, OperationContext.Stage.RUNTIME);\n\n        // Perform boottime on subsystem extensions\n        for(SubsystemExtension extension : extensions) {\n            extension.performBoottime(context, operation, model, verificationHandler, newControllers);\n        }\n\n        // Add the subsystem state as a service\n        newControllers.add(SubsystemState.addService(serviceTarget, activation));\n    }","commit_id":"9b511217deafd499e2384b29763c7f71e06d7044","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Check if we already have an OSGi deployment\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        if (depUnit.hasAttachment(OSGiConstants.OSGI_METADATA_KEY))\n            return;\n\n        // Get the OSGi XService properties\n        VirtualFile virtualFile = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        VirtualFile xserviceFile = virtualFile.getChild(XSERVICE_PROPERTIES_NAME);\n        if (xserviceFile.exists() == false)\n            return;\n\n        try {\n            Properties props = new Properties();\n            props.load(xserviceFile.openStream());\n            OSGiMetaData metadata = OSGiMetaDataBuilder.load(props);\n            depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n        } catch (IOException ex) {\n            throw MESSAGES.cannotParseOSGiMetadata(ex, xserviceFile);\n        }\n    }","id":74902,"modified_method":"@Override\n    public void deploy(DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Check if we already have {@link OSGiMetaData} attached\n        // or if we already have a bundle {@link Deployment}\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        Deployment dep = BundleLifecycleIntegration.getDeployment(depUnit.getName());\n        if (metadata != null || dep != null)\n            return;\n\n        // Get the OSGi XService properties\n        VirtualFile virtualFile = depUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n        VirtualFile xserviceFile = virtualFile.getChild(XSERVICE_PROPERTIES_NAME);\n        if (xserviceFile.exists() == false)\n            return;\n\n        try {\n            Properties props = new Properties();\n            props.load(xserviceFile.openStream());\n            metadata = OSGiMetaDataBuilder.load(props);\n        } catch (IOException ex) {\n            throw MESSAGES.cannotParseOSGiMetadata(ex, xserviceFile);\n        }\n\n        depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n        depUnit.putAttachment(OSGiConstants.DEPLOYMENT_TYPE_KEY, DeploymentType.Module);\n    }","commit_id":"9b511217deafd499e2384b29763c7f71e06d7044","url":"https://github.com/wildfly/wildfly"},{"original_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Generate the OSGi metadata from a webbundle:// URI\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        if (metadata == null) {\n            // [TODO] this should generate OSGiMetaData directly\n            Manifest manifest = WebBundleURIParser.parse(depUnit.getName());\n            if (manifest != null) {\n                metadata = OSGiMetaDataBuilder.load(manifest);\n                depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n                depUnit.putAttachment(Attachments.OSGI_MANIFEST, manifest);\n            }\n        }\n    }","id":74903,"modified_method":"@Override\n    public void deploy(final DeploymentPhaseContext phaseContext) throws DeploymentUnitProcessingException {\n\n        // Check if we already have {@link OSGiMetaData} or a bundle {@link Deployment}\n        DeploymentUnit depUnit = phaseContext.getDeploymentUnit();\n        OSGiMetaData metadata = depUnit.getAttachment(OSGiConstants.OSGI_METADATA_KEY);\n        if (metadata != null)\n            return;\n\n        // Check if we already have a bundle {@link Deployment}\n        Deployment dep = BundleLifecycleIntegration.getDeployment(depUnit.getName());\n        if (dep != null)\n            return;\n\n        // Generate the OSGi metadata from a webbundle:// URI\n        // [TODO] this should generate OSGiMetaData directly\n        Manifest manifest = WebBundleURIParser.parse(depUnit.getName());\n        if (manifest != null) {\n            metadata = OSGiMetaDataBuilder.load(manifest);\n            depUnit.putAttachment(OSGiConstants.OSGI_METADATA_KEY, metadata);\n            depUnit.putAttachment(Attachments.OSGI_MANIFEST, manifest);\n        }\n    }","commit_id":"9b511217deafd499e2384b29763c7f71e06d7044","url":"https://github.com/wildfly/wildfly"},{"original_method":"/**\n     * Finds a ejb-jar.xml (at WEB-INF of a .war or META-INF of a .jar) parses the file and creates\n     * metadata out of it. The metadata is then attached to the deployment unit.\n     *\n     * @param deploymentPhase\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext deploymentPhase) throws DeploymentUnitProcessingException {\n\n        // get hold of the deployment unit.\n        DeploymentUnit deploymentUnit = deploymentPhase.getDeploymentUnit();\n\n        // get the root of the deployment unit\n        VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationClasses applicationClassesDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n\n        // Locate a ejb-jar.xml\n        VirtualFile ejbJarXml = null;\n        // EJB 3.1 FR 20.4 Enterprise Beans Packaged in a .war\n        // TODO: Is there a better way to do this?\n        if (deploymentRoot.getName().toLowerCase().endsWith(WAR_FILE_EXTENSION)) {\n            // it's a .war file, so look for the ejb-jar.xml in WEB-INF\n            ejbJarXml = deploymentRoot.getChild(EJB_JAR_XML_LOCATION_IN_WAR);\n        } else if (deploymentRoot.getName().toLowerCase().endsWith(JAR_FILE_EXTENSION)) {\n            ejbJarXml = deploymentRoot.getChild(EJB_JAR_XML_LOCATION_IN_JAR);\n        } else {\n            // neither a .jar nor a .war. Return\n            return;\n        }\n\n        if (ejbJarXml == null || !ejbJarXml.exists()) {\n            // no ejb-jar.xml found, nothing to do!\n            return;\n        }\n        // Mark it as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        if (!deploymentUnit.hasAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_DESCRIPTION)) {\n            final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n            final EjbJarDescription ejbModuleDescription = new EjbJarDescription(moduleDescription, applicationClassesDescription, deploymentUnit.getName().endsWith(\".war\"));\n            deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_DESCRIPTION, ejbModuleDescription);\n        }\n\n        // get the XMLStreamReader and parse the ejb-jar.xml\n        MetaDataElementParser.DTDInfo dtdInfo = new MetaDataElementParser.DTDInfo();\n        InputStream stream = null;\n        try {\n            stream = ejbJarXml.openStream();\n\n            XMLStreamReader reader = this.getXMLStreamReader(stream, ejbJarXml, dtdInfo);\n\n            EjbJarMetaData ejbJarMetaData = EjbJarMetaDataParser.parse(reader, dtdInfo);\n            // attach the EjbJarMetaData to the deployment unit\n            deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_METADATA, ejbJarMetaData);\n\n            if (ejbJarMetaData instanceof EjbJar31MetaData) {\n                EjbJar31MetaData ejbJar31MetaData = (EjbJar31MetaData) ejbJarMetaData;\n                if (ejbJar31MetaData.getModuleName() != null) {\n                    eeModuleDescription.setModuleName(ejbJar31MetaData.getModuleName());\n                }\n                if (ejbJar31MetaData.isMetadataComplete()) {\n                    MetadataCompleteMarker.setMetadataComplete(deploymentUnit, true);\n                }\n            } else if (!ejbJarMetaData.isEJB3x()) {\n                //EJB spec 20.5.1, we do not process annotations for older deployments\n                MetadataCompleteMarker.setMetadataComplete(deploymentUnit, true);\n            }\n\n        } catch (XMLStreamException xmlse) {\n            throw new DeploymentUnitProcessingException(\"Exception while parsing ejb-jar.xml: \" + ejbJarXml.getPathName(), xmlse);\n        } catch (IOException ioe) {\n            throw new DeploymentUnitProcessingException(\"Failed to create reader for ejb-jar.xml: \" + ejbJarXml.getPathName(), ioe);\n        } finally {\n            try {\n                if (stream != null) {\n                    stream.close();\n                }\n            } catch (IOException ioe) {\n                logger.debug(\"Ignoring exception while closing the InputStream \", ioe);\n            }\n        }\n\n    }","id":74904,"modified_method":"/**\n     * Finds a ejb-jar.xml (at WEB-INF of a .war or META-INF of a .jar) parses the file and creates\n     * metadata out of it. The metadata is then attached to the deployment unit.\n     *\n     * @param deploymentPhase\n     * @throws DeploymentUnitProcessingException\n     *\n     */\n    @Override\n    public void deploy(DeploymentPhaseContext deploymentPhase) throws DeploymentUnitProcessingException {\n\n        // get hold of the deployment unit.\n        DeploymentUnit deploymentUnit = deploymentPhase.getDeploymentUnit();\n\n        // get the root of the deployment unit\n        VirtualFile deploymentRoot = deploymentUnit.getAttachment(Attachments.DEPLOYMENT_ROOT).getRoot();\n\n        final EEModuleDescription eeModuleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n        final EEApplicationClasses applicationClassesDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_APPLICATION_CLASSES_DESCRIPTION);\n\n        final EjbJarMetaData ejbJarMetaData;\n        final EjbJarMetaData specMetaData = parseEjbJarXml(deploymentUnit);\n        final EjbJarMetaData jbossMetaData = parseJBossEjb3Xml(deploymentUnit);\n        if (specMetaData == null) {\n            if (jbossMetaData == null)\n                return;\n            ejbJarMetaData = jbossMetaData;\n        } else if (jbossMetaData == null) {\n            ejbJarMetaData = specMetaData;\n        } else {\n            throw new UnsupportedOperationException(\"NYI: descriptor merging\");\n        }\n\n        // Mark it as a EJB deployment\n        EjbDeploymentMarker.mark(deploymentUnit);\n        if (!deploymentUnit.hasAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_DESCRIPTION)) {\n            final EEModuleDescription moduleDescription = deploymentUnit.getAttachment(org.jboss.as.ee.component.Attachments.EE_MODULE_DESCRIPTION);\n            final EjbJarDescription ejbModuleDescription = new EjbJarDescription(moduleDescription, applicationClassesDescription, deploymentUnit.getName().endsWith(\".war\"));\n            deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_DESCRIPTION, ejbModuleDescription);\n        }\n\n        // attach the EjbJarMetaData to the deployment unit\n        deploymentUnit.putAttachment(EjbDeploymentAttachmentKeys.EJB_JAR_METADATA, ejbJarMetaData);\n\n        if(ejbJarMetaData instanceof EjbJar31MetaData) {\n            EjbJar31MetaData ejbJar31MetaData = (EjbJar31MetaData)ejbJarMetaData;\n            if(ejbJar31MetaData.getModuleName() != null) {\n                eeModuleDescription.setModuleName(ejbJar31MetaData.getModuleName());\n            }\n            if (ejbJar31MetaData.isMetadataComplete()) {\n                MetadataCompleteMarker.setMetadataComplete(deploymentUnit, true);\n            }\n        } else if (!ejbJarMetaData.isEJB3x()) {\n            //EJB spec 20.5.1, we do not process annotations for older deployments\n            MetadataCompleteMarker.setMetadataComplete(deploymentUnit, true);\n        }\n    }","commit_id":"20f42e919aefb8aabcc0fa37c0bd87731a3de157","url":"https://github.com/wildfly/wildfly"},{"original_method":"public static boolean isStatement(@NotNull PsiElement element) {\n    if (!(element instanceof GrStatement) && !(element instanceof PsiComment) &&\n        !element.getText().equals(\";\") && !StringUtil.isEmptyOrSpaces(element.getText())) {\n      return false;\n    }\n    return element.getParent() instanceof GrStatementOwner;\n  }","id":74905,"modified_method":"public static boolean isStatement(@NotNull PsiElement element) {\n    return \";\".equals(element.getText()) || element instanceof PsiComment || StringUtil.isEmptyOrSpaces(element.getText()) || PsiUtil.isExpressionStatement(element);\n  }","commit_id":"169622b3e3fafc4b46f0d452175c696d8c5605dc","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IpnbConnection(@NotNull URI uri, @NotNull IpnbConnectionListener listener) throws IOException, URISyntaxException {\n    myURI = uri;\n    myListener = listener;\n    mySessionId = UUID.randomUUID().toString();\n    myKernelId = startKernel();\n\n    initializeClients();\n  }","id":74906,"modified_method":"public IpnbConnection(@NotNull String uri, @NotNull IpnbConnectionListener listener) throws IOException, URISyntaxException {\n    myURI = new URI(uri);\n    myListener = listener;\n    mySessionId = UUID.randomUUID().toString();\n    myKernelId = startKernel();\n\n    initializeClients();\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static String showDialogUrl(@NotNull final String initialUrl) {\n    final String url = Messages.showInputDialog(\"IPython Notebook URL:\", \"Start IPython Notebook\", null, initialUrl,\n                                                new InputValidator() {\n                                                  @Override\n                                                  public boolean checkInput(String inputString) {\n                                                    try {\n                                                      new URL(inputString);\n                                                    }\n                                                    catch (MalformedURLException e) {\n                                                      return false;\n                                                    }\n                                                    return !inputString.isEmpty();\n                                                  }\n\n                                                  @Override\n                                                  public boolean canClose(String inputString) {\n                                                    return true;\n                                                  }\n                                                });\n    return url == null ? null : StringUtil.trimEnd(url, \"/\");\n  }","id":74907,"modified_method":"@Nullable\n  private static String showDialogUrl(@NotNull final String initialUrl) {\n    final String url = Messages.showInputDialog(\"IPython Notebook URL:\", \"Start IPython Notebook\", null, initialUrl,\n                                                new InputValidator() {\n                                                  @Override\n                                                  public boolean checkInput(String inputString) {\n                                                    try {\n                                                      final URI uri = new URI(inputString);\n                                                      if (uri.getPort() == -1 || StringUtil.isEmptyOrSpaces(uri.getHost())) {\n                                                        return false;\n                                                      }\n                                                    }\n                                                    catch (URISyntaxException e) {\n                                                      return false;\n                                                    }\n                                                    return !inputString.isEmpty();\n                                                  }\n\n                                                  @Override\n                                                  public boolean canClose(String inputString) {\n                                                    return true;\n                                                  }\n                                                });\n    return url == null ? null : StringUtil.trimEnd(url, \"/\");\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean startConnection(@NotNull final IpnbCodePanel codePanel, @NotNull final String path, @NotNull final String urlString,\n                                  final boolean showNotification) {\n    try {\n      final IpnbConnectionListenerBase listener = new IpnbConnectionListenerBase() {\n        @Override\n        public void onOpen(@NotNull IpnbConnection connection) {\n          final String messageId = connection.execute(codePanel.getCell().getSourceAsString());\n          myUpdateMap.put(messageId, codePanel);\n        }\n\n        @Override\n        public void onOutput(@NotNull IpnbConnection connection,\n                             @NotNull String parentMessageId,\n                             @NotNull List<IpnbOutputCell> outputs,\n                             @Nullable Integer execCount) {\n          if (!myUpdateMap.containsKey(parentMessageId)) return;\n          final IpnbCodePanel cell = myUpdateMap.remove(parentMessageId);\n          cell.getCell().setPromptNumber(execCount);\n          cell.updatePanel(outputs);\n        }\n      };\n      final URI url = new URI(urlString);\n\n      HttpRequests.request(urlString + \"/api\").connect(new HttpRequests.RequestProcessor<Object>() {\n        @Override\n        public Object process(@NotNull HttpRequests.Request request) throws IOException {\n          final IpnbConnection connection;\n          try {\n            if (request.isSuccessful()) {\n              connection = new IpnbConnectionV3(url, listener);\n            }\n            else {\n              connection = new IpnbConnection(url, listener);\n            }\n            myKernels.put(path, connection);\n          }\n          catch (URISyntaxException e) {\n            if (showNotification) {\n              showWarning(codePanel.getFileEditor(), \"IPython Notebook connection refused\");\n              LOG.warn(\"IPython Notebook connection refused: \" + e.getMessage());\n            }\n          }\n          return null;\n        }\n      });\n    }\n    catch (URISyntaxException e) {\n      if (showNotification) {\n        showWarning(codePanel.getFileEditor(), \"Please, check IPython Notebook URL in <a href=\\\"\\\">Settings->Tools->IPython Notebook<\/a>\",\n                    new HyperlinkAdapter() {\n                      @Override\n                      protected void hyperlinkActivated(HyperlinkEvent e) {\n                        ShowSettingsUtil.getInstance().showSettingsDialog(myProject, \"IPython Notebook\");\n                      }\n                    });\n        LOG.warn(\"IPython Notebook URI Syntax Error: \" + e.getMessage());\n      }\n      return false;\n    }\n    catch (IOException e) {\n      if (showNotification) {\n        showWarning(codePanel.getFileEditor(), \"IPython Notebook connection refused\");\n        LOG.warn(\"IPython Notebook connection refused: \" + e.getMessage());\n      }\n      return false;\n    }\n    return true;\n  }","id":74908,"modified_method":"private boolean startConnection(@NotNull final IpnbCodePanel codePanel, @NotNull final String path, @NotNull final String urlString,\n                                  final boolean showNotification) {\n    try {\n      final IpnbConnectionListenerBase listener = new IpnbConnectionListenerBase() {\n        @Override\n        public void onOpen(@NotNull IpnbConnection connection) {\n          final String messageId = connection.execute(codePanel.getCell().getSourceAsString());\n          myUpdateMap.put(messageId, codePanel);\n        }\n\n        @Override\n        public void onOutput(@NotNull IpnbConnection connection,\n                             @NotNull String parentMessageId,\n                             @NotNull List<IpnbOutputCell> outputs,\n                             @Nullable Integer execCount) {\n          if (!myUpdateMap.containsKey(parentMessageId)) return;\n          final IpnbCodePanel cell = myUpdateMap.remove(parentMessageId);\n          cell.getCell().setPromptNumber(execCount);\n          cell.updatePanel(outputs);\n        }\n      };\n\n      HttpRequests.request(urlString + \"/api\").connect(new HttpRequests.RequestProcessor<Object>() {\n        @Override\n        public Object process(@NotNull HttpRequests.Request request) throws IOException {\n          final IpnbConnection connection;\n          try {\n            if (request.isSuccessful()) {\n              connection = new IpnbConnectionV3(urlString, listener);\n            }\n            else {\n              connection = new IpnbConnection(urlString, listener);\n            }\n            myKernels.put(path, connection);\n          }\n          catch (URISyntaxException e) {\n            if (showNotification) {\n              showWarning(codePanel.getFileEditor(), \"Please, check IPython Notebook URL in <a href=\\\"\\\">Settings->Tools->IPython Notebook<\/a>\",\n                          new IpnbSettingsAdapter());\n              LOG.warn(\"IPython Notebook connection refused: \" + e.getMessage());\n            }\n          }\n          return null;\n        }\n      });\n    }\n    catch (IOException e) {\n      if (showNotification) {\n        showWarning(codePanel.getFileEditor(), \"IPython Notebook connection refused\", null);\n        LOG.warn(\"IPython Notebook connection refused: \" + e.getMessage());\n      }\n      return false;\n    }\n    return true;\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void showWarning(@NotNull final IpnbFileEditor fileEditor, @NotNull final String message,\n                                  @Nullable final HyperlinkAdapter listener) {\n    BalloonBuilder balloonBuilder = JBPopupFactory.getInstance().createHtmlTextBalloonBuilder(\n      message, null, MessageType.WARNING.getPopupBackground(), listener);\n    final Balloon balloon = balloonBuilder.createBalloon();\n    balloon.showInCenterOf(fileEditor.getRunCellButton());\n  }","id":74909,"modified_method":"private static void showWarning(@NotNull final IpnbFileEditor fileEditor, @NotNull final String message,\n                                  @Nullable final HyperlinkAdapter listener) {\n    BalloonBuilder balloonBuilder = JBPopupFactory.getInstance().createHtmlTextBalloonBuilder(\n      message, null, MessageType.WARNING.getPopupBackground(), listener);\n    final Balloon balloon = balloonBuilder.createBalloon();\n    ApplicationManager.getApplication().invokeLater(new Runnable() {\n      @Override\n      public void run() {\n        balloon.showInCenterOf(fileEditor.getRunCellButton());\n      }\n    });\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private boolean startIpythonServer(@NotNull final String url, @NotNull final IpnbFileEditor fileEditor) {\n    final Module module = ProjectFileIndex.SERVICE.getInstance(myProject).getModuleForFile(fileEditor.getVirtualFile());\n    if (module == null) return false;\n    final Sdk sdk = PythonSdkType.findPythonSdk(module);\n    if (sdk == null) {\n      showWarning(fileEditor, \"Please check Python Interpreter in Settings->Python Interpreter\");\n      return false;\n    }\n    try {\n      final PyPackage ipythonPackage = PyPackageManager.getInstance(sdk).findPackage(\"ipython\", false);\n      if (ipythonPackage == null) {\n        showWarning(fileEditor, \"Add IPython to the interpreter of the current project.\");\n        return false;\n      }\n    }\n    catch (ExecutionException ignored) {\n    }\n    final Map<String, String> env = ImmutableMap.of(\"PYCHARM_EP_DIST\", \"ipython\", \"PYCHARM_EP_NAME\", \"ipython\");\n\n    final Pair<String, String> hostPort = getHostPortFromUrl(url);\n    final String ipython = PythonHelpersLocator.getHelperPath(\"pycharm/pycharm_load_entry_point.py\");\n    final ArrayList<String> parameters = Lists.newArrayList(sdk.getHomePath(), ipython, \"notebook\", \"--no-browser\");\n    if (hostPort.getFirst() != null) {\n      parameters.add(\"--ip\");\n      parameters.add(hostPort.getFirst());\n    }\n    if (hostPort.getSecond() != null) {\n      parameters.add(\"--port\");\n      parameters.add(hostPort.getSecond());\n    }\n    final GeneralCommandLine commandLine = new GeneralCommandLine(parameters).withWorkDirectory(myProject.getBasePath()).\n      withEnvironment(env);\n\n    try {\n      myProcessHandler = new KillableColoredProcessHandler(commandLine) {\n        @Override\n        public boolean isSilentlyDestroyOnClose() {\n          return true;\n        }\n      };\n      myProcessHandler.setShouldDestroyProcessRecursively(true);\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          new RunContentExecutor(myProject, myProcessHandler)\n            .withConsole(new IpnbConsole(myProject, myProcessHandler))\n            .run();\n        }\n      });\n      return true;\n    }\n    catch (ExecutionException e) {\n      return false;\n    }\n  }","id":74910,"modified_method":"private boolean startIpythonServer(@NotNull final String url, @NotNull final IpnbFileEditor fileEditor) {\n    final Module module = ProjectFileIndex.SERVICE.getInstance(myProject).getModuleForFile(fileEditor.getVirtualFile());\n    if (module == null) return false;\n    final Sdk sdk = PythonSdkType.findPythonSdk(module);\n    if (sdk == null) {\n      showWarning(fileEditor, \"Please check Python Interpreter in Settings->Python Interpreter\", null);\n      return false;\n    }\n    try {\n      final PyPackage ipythonPackage = PyPackageManager.getInstance(sdk).findPackage(\"ipython\", false);\n      if (ipythonPackage == null) {\n        showWarning(fileEditor, \"Add IPython to the interpreter of the current project.\", null);\n        return false;\n      }\n    }\n    catch (ExecutionException ignored) {\n    }\n    final Map<String, String> env = ImmutableMap.of(\"PYCHARM_EP_DIST\", \"ipython\", \"PYCHARM_EP_NAME\", \"ipython\");\n\n    final Pair<String, String> hostPort = getHostPortFromUrl(url);\n    if (hostPort == null) {\n      showWarning(fileEditor, \"Please, check IPython Notebook URL in <a href=\\\"\\\">Settings->Tools->IPython Notebook<\/a>\",\n                  new IpnbSettingsAdapter());\n      return false;\n    }\n    final String ipython = PythonHelpersLocator.getHelperPath(\"pycharm/pycharm_load_entry_point.py\");\n    final ArrayList<String> parameters = Lists.newArrayList(sdk.getHomePath(), ipython, \"notebook\", \"--no-browser\");\n    if (hostPort.getFirst() != null) {\n      parameters.add(\"--ip\");\n      parameters.add(hostPort.getFirst());\n    }\n    if (hostPort.getSecond() != null) {\n      parameters.add(\"--port\");\n      parameters.add(hostPort.getSecond());\n    }\n    final GeneralCommandLine commandLine = new GeneralCommandLine(parameters).withWorkDirectory(myProject.getBasePath()).\n      withEnvironment(env);\n\n    try {\n      myProcessHandler = new KillableColoredProcessHandler(commandLine) {\n        @Override\n        public boolean isSilentlyDestroyOnClose() {\n          return true;\n        }\n      };\n      myProcessHandler.setShouldDestroyProcessRecursively(true);\n      ApplicationManager.getApplication().invokeLater(new Runnable() {\n        @Override\n        public void run() {\n          new RunContentExecutor(myProject, myProcessHandler)\n            .withConsole(new IpnbConsole(myProject, myProcessHandler))\n            .run();\n        }\n      });\n      return true;\n    }\n    catch (ExecutionException e) {\n      return false;\n    }\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void startConnection(@NotNull final IpnbCodePanel codePanel, final IpnbFileEditor fileEditor, final String path) {\n    String url = IpnbSettings.getInstance(myProject).getURL();\n    if (StringUtil.isEmptyOrSpaces(url)) {\n      showWarning(fileEditor, \"Please, specify IPython Notebook URL in <a href=\\\"\\\">Settings->Tools->IPython Notebook<\/a>\",\n                  new HyperlinkAdapter() {\n                    @Override\n                    protected void hyperlinkActivated(HyperlinkEvent e) {\n                      ShowSettingsUtil.getInstance().showSettingsDialog(myProject, \"IPython Notebook\");\n                    }\n                  });\n      return;\n    }\n    if (startConnection(codePanel, path, url, false)) {\n      return;\n    }\n    url = showDialogUrl(url);\n    if (url == null) return;\n    IpnbSettings.getInstance(myProject).setURL(url);\n    boolean connectionStarted = startConnection(codePanel, path, url, false);\n    if (!connectionStarted) {\n      final String finalUrl = url;\n      ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n        @Override\n        public void run() {\n          final boolean serverStarted = startIpythonServer(finalUrl, fileEditor);\n          if (!serverStarted) {\n            return;\n          }\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              new Alarm(Alarm.ThreadToUse.SWING_THREAD).addRequest(new Runnable() {\n                @Override\n                public void run() {\n                  final Notification notification =\n                    new Notification(\"IPythonNotebook\", \"\", \"<html>IPython notebook started at <a href=\\\"\" + finalUrl +\n                                                            \"\\\">\" + finalUrl + \"<\/a><\/html>\", NotificationType.INFORMATION,\n                                     NotificationListener.URL_OPENING_LISTENER);\n                  notification.notify(myProject);\n                  startConnection(codePanel, path, finalUrl, true);\n                }\n              }, 3000);\n            }\n          });\n        }\n      });\n    }\n  }","id":74911,"modified_method":"private void startConnection(@NotNull final IpnbCodePanel codePanel, final IpnbFileEditor fileEditor, final String path) {\n    String url = IpnbSettings.getInstance(myProject).getURL();\n    if (StringUtil.isEmptyOrSpaces(url)) {\n      url = IpnbSettings.DEFAULT_URL;\n    }\n    url = showDialogUrl(url);\n    if (url == null) return;\n    IpnbSettings.getInstance(myProject).setURL(url);\n\n    boolean connectionStarted = startConnection(codePanel, path, url, false);\n    if (!connectionStarted) {\n      final String finalUrl = url;\n      ApplicationManager.getApplication().executeOnPooledThread(new Runnable() {\n        @Override\n        public void run() {\n          final boolean serverStarted = startIpythonServer(finalUrl, fileEditor);\n          if (!serverStarted) {\n            return;\n          }\n          ApplicationManager.getApplication().invokeLater(new Runnable() {\n            @Override\n            public void run() {\n              new Alarm(Alarm.ThreadToUse.SWING_THREAD).addRequest(new Runnable() {\n                @Override\n                public void run() {\n                  startConnection(codePanel, path, finalUrl, true);\n                }\n              }, 3000);\n            }\n          });\n        }\n      });\n    }\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static Pair<String, String> getHostPortFromUrl(@NotNull String url) {\n    String host = null;\n    String port = null;\n    int index = url.indexOf(\"://\");\n    if (index != -1) {\n      url = url.substring(index + 3);\n    }\n    index = url.indexOf(':');\n    if (index != -1) {\n      host = url.substring(0, index);\n      port = url.substring(index + 1);\n    }\n    return Pair.create(host, port);\n  }","id":74912,"modified_method":"@Nullable\n  public static Pair<String, String> getHostPortFromUrl(@NotNull String url) {\n    try {\n      final URI uri = new URI(url);\n      final int port = uri.getPort();\n      return Pair.create(uri.getHost(), port == -1 ? null : String.valueOf(port));\n    }\n    catch (URISyntaxException e) {\n      return null;\n    }\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public IpnbConnectionV3(@NotNull URI uri, @NotNull IpnbConnectionListener listener) throws IOException, URISyntaxException {\n    super(uri, listener);\n  }","id":74913,"modified_method":"public IpnbConnectionV3(@NotNull String uri, @NotNull IpnbConnectionListener listener) throws IOException, URISyntaxException {\n    super(uri, listener);\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static URI getTestServerURI() {\n    try {\n      return new URI(\"http://127.0.0.1:8888\");\n    }\n    catch (URISyntaxException e) {\n      throw new RuntimeException(e);\n    }\n  }","id":74914,"modified_method":"@NotNull\n  public static String getTestServerURI() {\n    return \"http://127.0.0.1:8888\";\n  }","commit_id":"279974effa4d4d3cd60ffe3b2672056ff44e6fde","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private Intersection checkIntersection(@Nullable final List<CommittedChangeList> lists, List<LocalChangeList> localChangeLists) {\n    if (lists == null || lists.isEmpty()) {\n      return null;\n    }\n    final Set<FilePath> mergePaths = new HashSet<FilePath>();\n    for (CommittedChangeList list : lists) {\n      final SvnChangeList svnList = (SvnChangeList)list;\n      final List<String> paths = new ArrayList<String>(svnList.getAddedPaths());\n      paths.addAll(svnList.getChangedPaths());\n      paths.addAll(svnList.getDeletedPaths());\n      for (String path : paths) {\n        final File localPath = getLocalPath(path);\n        if (localPath != null) {\n          mergePaths.add(new FilePathImpl(localPath, false));\n        }\n      }\n    }\n\n    final Intersection intersection = new Intersection();\n    for (LocalChangeList localChangeList : localChangeLists) {\n      final Collection<Change> localChanges = localChangeList.getChanges();\n\n      for (Change localChange : localChanges) {\n        final FilePath before = localChange.getBeforeRevision() == null ? null : localChange.getBeforeRevision().getFile();\n        final FilePath after = localChange.getAfterRevision() == null ? null : localChange.getAfterRevision().getFile();\n\n        if ((before != null && mergePaths.contains(before)) || (after != null && mergePaths.contains(after))) {\n          intersection.add(localChangeList.getName(), localChangeList.getComment(), localChange);\n        }\n      }\n    }\n    return intersection;\n  }","id":74915,"modified_method":"@Nullable\n  private Intersection getChangesIntersection(@NotNull List<LocalChangeList> localChangeLists,\n                                              @Nullable List<CommittedChangeList> changeListsToMerge) {\n    Intersection result = null;\n\n    if (!ContainerUtil.isEmpty(changeListsToMerge)) {\n      final Set<FilePath> pathsToMerge = collectPaths(changeListsToMerge);\n\n      result = getChangesIntersection(localChangeLists, new Condition<Change>() {\n        @Override\n        public boolean value(Change change) {\n          return notNullAndInSet(ChangesUtil.getBeforePath(change), pathsToMerge) ||\n                 notNullAndInSet(ChangesUtil.getAfterPath(change), pathsToMerge);\n        }\n      });\n    }\n\n    return result;\n  }","commit_id":"0cf576df20882fcd2e62dac8e87b72c9f1b46ff8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static Intersection getMergeAllIntersection(List<LocalChangeList> localChangeLists) {\n    final Intersection intersection = new Intersection();\n\n    for (LocalChangeList localChangeList : localChangeLists) {\n      final Collection<Change> localChanges = localChangeList.getChanges();\n      for (Change localChange : localChanges) {\n        intersection.add(localChangeList.getName(), localChangeList.getComment(), localChange);\n      }\n    }\n    return intersection;\n  }","id":74916,"modified_method":"@NotNull\n  private static Intersection getAllChangesIntersection(@NotNull List<LocalChangeList> localChangeLists) {\n    return getChangesIntersection(localChangeLists, Conditions.<Change>alwaysTrue());\n  }","commit_id":"0cf576df20882fcd2e62dac8e87b72c9f1b46ff8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Nullable\n  private File getLocalPath(final String relativeToRepoPath) {\n    // from source if not inverted\n    final String pathToCheck = SVNPathUtil.append(myMergeContext.getWcInfo().getRepositoryRoot(), relativeToRepoPath);\n    final SvnBranchPointsCalculator.BranchCopyData wrapped = myCopyPoint.getWrapped();\n    final String relativeInSource =\n      SVNPathUtil.getRelativePath(myCopyPoint.isInvertedSense() ? wrapped.getSource() : wrapped.getTarget(), pathToCheck);\n    if (StringUtil.isEmptyOrSpaces(relativeInSource)) return null;\n    final File local = new File(myMergeContext.getWcInfo().getPath(), relativeInSource);\n    return local;\n  }","id":74917,"modified_method":"@Nullable\n  private File getLocalPath(String repositoryRelativePath) {\n    // from source if not inverted\n    final String absolutePath = SVNPathUtil.append(myMergeContext.getWcInfo().getRepositoryRoot(), repositoryRelativePath);\n    final SvnBranchPointsCalculator.BranchCopyData wrapped = myCopyPoint.getWrapped();\n    final String sourceRelativePath =\n      SVNPathUtil.getRelativePath(myCopyPoint.isInvertedSense() ? wrapped.getSource() : wrapped.getTarget(), absolutePath);\n\n    return !StringUtil.isEmptyOrSpaces(sourceRelativePath) ? new File(myMergeContext.getWcInfo().getPath(), sourceRelativePath) : null;\n  }","commit_id":"0cf576df20882fcd2e62dac8e87b72c9f1b46ff8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void run(ContinuationContext context) {\n    final Intersection intersection;\n    final ChangeListManager listManager = ChangeListManager.getInstance(myMergeContext.getProject());\n    final List<LocalChangeList> localChangeLists = listManager.getChangeListsCopy();\n\n    if (myMergeAll) {\n      intersection = getMergeAllIntersection(localChangeLists);\n    }\n    else {\n      intersection = checkIntersection(myLists, localChangeLists);\n    }\n    if (intersection == null || intersection.getChangesSubset().isEmpty()) return;\n\n    final LocalChangesAction action = myInteraction.selectLocalChangesAction(myMergeAll);\n    switch (action) {\n      // shelve\n      case shelve:\n        context.next(new ShelveLocalChangesTask(myMergeContext, myInteraction, intersection));\n        return;\n      // cancel\n      case cancel:\n        context.cancelEverything();\n        return;\n      // continue\n      case continueMerge:\n        return;\n      // inspect\n      case inspect:\n        // here's cast is due to generic's bug\n        @SuppressWarnings(\"unchecked\") final Collection<Change> changes = (Collection<Change>)intersection.getChangesSubset().values();\n        final List<FilePath> paths = ChangesUtil.getPaths(changes);\n        Collections.sort(paths, FilePathByPathComparator.getInstance());\n        myInteraction.showIntersectedLocalPaths(paths);\n        context.cancelEverything();\n        return;\n      default:\n    }\n  }","id":74918,"modified_method":"@Override\n  public void run(ContinuationContext context) {\n    List<LocalChangeList> localChangeLists = ChangeListManager.getInstance(myMergeContext.getProject()).getChangeListsCopy();\n    Intersection intersection =\n      myMergeAll\n      ? getAllChangesIntersection(localChangeLists)\n      : getChangesIntersection(localChangeLists, myChangeListsToMerge);\n\n    if (intersection != null && !intersection.getChangesSubset().isEmpty()) {\n      processIntersection(context, intersection);\n    }\n  }","commit_id":"0cf576df20882fcd2e62dac8e87b72c9f1b46ff8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public LocalChangesPromptTask(@NotNull MergeContext mergeContext, @NotNull QuickMergeInteraction interaction, final boolean mergeAll,\n                                @Nullable final List<CommittedChangeList> lists,\n                                @Nullable SvnBranchPointsCalculator.WrapperInvertor copyPoint) {\n    super(mergeContext, interaction, \"local changes intersection check\", Where.AWT);\n    myMergeAll = mergeAll;\n    myLists = lists;\n    myCopyPoint = copyPoint;\n  }","id":74919,"modified_method":"public LocalChangesPromptTask(@NotNull MergeContext mergeContext,\n                                @NotNull QuickMergeInteraction interaction,\n                                boolean mergeAll,\n                                @Nullable List<CommittedChangeList> changeListsToMerge,\n                                @Nullable SvnBranchPointsCalculator.WrapperInvertor copyPoint) {\n    super(mergeContext, interaction, \"local changes intersection check\", Where.AWT);\n\n    myMergeAll = mergeAll;\n    myChangeListsToMerge = changeListsToMerge;\n    myCopyPoint = copyPoint;\n  }","commit_id":"0cf576df20882fcd2e62dac8e87b72c9f1b46ff8","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean variableIsAssignedBeforeReference(\n    @NotNull PsiReferenceExpression referenceExpression,\n    @Nullable PsiElement context) {\n    if (context == null) {\n      return false;\n    }\n    final PsiElement target = referenceExpression.resolve();\n    if (!(target instanceof PsiVariable)) {\n      return false;\n    }\n    final PsiVariable variable = (PsiVariable)target;\n    return variableIsAssignedAtPoint(variable, context,\n                                     referenceExpression);\n  }","id":74920,"modified_method":"public static boolean variableIsAssignedBeforeReference(@NotNull PsiReferenceExpression referenceExpression,\n                                                          @Nullable PsiElement context) {\n    if (context == null) {\n      return false;\n    }\n    final PsiElement target = referenceExpression.resolve();\n    if (!(target instanceof PsiVariable)) {\n      return false;\n    }\n    final PsiVariable variable = (PsiVariable)target;\n    return variableIsAssignedAtPoint(variable, context, referenceExpression);\n  }","commit_id":"9f3e64908830123bdf348049e9100bc43e9ca87d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean variableIsIncrementedOrDecremented(@NotNull PsiVariable variable, @Nullable PsiStatement statement,\n                                                            boolean incremented) {\n    if (!(statement instanceof PsiExpressionStatement)) {\n      return false;\n    }\n    final PsiExpressionStatement expressionStatement =\n      (PsiExpressionStatement)statement;\n    PsiExpression expression = expressionStatement.getExpression();\n    expression = ParenthesesUtils.stripParentheses(expression);\n    if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression =\n        (PsiPrefixExpression)expression;\n      final IElementType tokenType = prefixExpression.getOperationTokenType();\n      if (incremented ? !tokenType.equals(JavaTokenType.PLUSPLUS) : !tokenType.equals(JavaTokenType.MINUSMINUS)) {\n        return false;\n      }\n      final PsiExpression operand = prefixExpression.getOperand();\n      return evaluatesToVariable(operand, variable);\n    }\n    if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression =\n        (PsiPostfixExpression)expression;\n      final IElementType tokenType = postfixExpression.getOperationTokenType();\n      if (incremented ? !tokenType.equals(JavaTokenType.PLUSPLUS) : !tokenType.equals(JavaTokenType.MINUSMINUS)) {\n        return false;\n      }\n      final PsiExpression operand = postfixExpression.getOperand();\n      return evaluatesToVariable(operand, variable);\n    }\n    if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression =\n        (PsiAssignmentExpression)expression;\n      final IElementType tokenType =\n        assignmentExpression.getOperationTokenType();\n      final PsiExpression lhs = assignmentExpression.getLExpression();\n      if (!evaluatesToVariable(lhs, variable)) {\n        return false;\n      }\n      PsiExpression rhs = assignmentExpression.getRExpression();\n      rhs = ParenthesesUtils.stripParentheses(rhs);\n      if (tokenType == JavaTokenType.EQ) {\n        if (!(rhs instanceof PsiBinaryExpression)) {\n          return false;\n        }\n        final PsiBinaryExpression binaryExpression =\n          (PsiBinaryExpression)rhs;\n        final IElementType binaryTokenType =\n          binaryExpression.getOperationTokenType();\n        if (incremented ? binaryTokenType != JavaTokenType.PLUS : binaryTokenType != JavaTokenType.MINUS) {\n          return false;\n        }\n        final PsiExpression lOperand = binaryExpression.getLOperand();\n        final PsiExpression rOperand = binaryExpression.getROperand();\n        if (ExpressionUtils.isOne(lOperand)) {\n          if (evaluatesToVariable(rOperand, variable)) {\n            return true;\n          }\n        }\n        else if (ExpressionUtils.isOne(rOperand)) {\n          if (evaluatesToVariable(lOperand, variable)) {\n            return true;\n          }\n        }\n      }\n      else if (incremented ? tokenType == JavaTokenType.PLUSEQ : tokenType == JavaTokenType.MINUSEQ) {\n        if (ExpressionUtils.isOne(rhs)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","id":74921,"modified_method":"private static boolean variableIsIncrementedOrDecremented(@NotNull PsiVariable variable, @Nullable PsiStatement statement,\n                                                            boolean incremented) {\n    if (!(statement instanceof PsiExpressionStatement)) {\n      return false;\n    }\n    final PsiExpressionStatement expressionStatement =\n      (PsiExpressionStatement)statement;\n    PsiExpression expression = expressionStatement.getExpression();\n    expression = ParenthesesUtils.stripParentheses(expression);\n    if (expression instanceof PsiPrefixExpression) {\n      final PsiPrefixExpression prefixExpression =\n        (PsiPrefixExpression)expression;\n      final IElementType tokenType = prefixExpression.getOperationTokenType();\n      if (!tokenType.equals(incremented ? JavaTokenType.PLUSPLUS : JavaTokenType.MINUSMINUS)) {\n        return false;\n      }\n      final PsiExpression operand = prefixExpression.getOperand();\n      return evaluatesToVariable(operand, variable);\n    }\n    if (expression instanceof PsiPostfixExpression) {\n      final PsiPostfixExpression postfixExpression =\n        (PsiPostfixExpression)expression;\n      final IElementType tokenType = postfixExpression.getOperationTokenType();\n      if (!tokenType.equals(incremented ? JavaTokenType.PLUSPLUS : JavaTokenType.MINUSMINUS)) {\n        return false;\n      }\n      final PsiExpression operand = postfixExpression.getOperand();\n      return evaluatesToVariable(operand, variable);\n    }\n    if (expression instanceof PsiAssignmentExpression) {\n      final PsiAssignmentExpression assignmentExpression =\n        (PsiAssignmentExpression)expression;\n      final IElementType tokenType =\n        assignmentExpression.getOperationTokenType();\n      final PsiExpression lhs = assignmentExpression.getLExpression();\n      if (!evaluatesToVariable(lhs, variable)) {\n        return false;\n      }\n      PsiExpression rhs = assignmentExpression.getRExpression();\n      rhs = ParenthesesUtils.stripParentheses(rhs);\n      if (tokenType == JavaTokenType.EQ) {\n        if (!(rhs instanceof PsiBinaryExpression)) {\n          return false;\n        }\n        final PsiBinaryExpression binaryExpression =\n          (PsiBinaryExpression)rhs;\n        final IElementType binaryTokenType =\n          binaryExpression.getOperationTokenType();\n        if (binaryTokenType != (incremented ? JavaTokenType.PLUS : JavaTokenType.MINUS)) {\n          return false;\n        }\n        final PsiExpression lOperand = binaryExpression.getLOperand();\n        final PsiExpression rOperand = binaryExpression.getROperand();\n        if (ExpressionUtils.isOne(lOperand)) {\n          if (evaluatesToVariable(rOperand, variable)) {\n            return true;\n          }\n        }\n        else if (ExpressionUtils.isOne(rOperand)) {\n          if (evaluatesToVariable(lOperand, variable)) {\n            return true;\n          }\n        }\n      }\n      else if (tokenType == (incremented ? JavaTokenType.PLUSEQ : JavaTokenType.MINUSEQ)) {\n        if (ExpressionUtils.isOne(rhs)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }","commit_id":"9f3e64908830123bdf348049e9100bc43e9ca87d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"static boolean mayEvaluateToVariable(@Nullable PsiExpression expression, @NotNull PsiVariable variable, boolean builderPattern) {\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression containedExpression = parenthesizedExpression.getExpression();\n      return mayEvaluateToVariable(containedExpression, variable, builderPattern);\n    }\n    if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCastExpression = (PsiTypeCastExpression)expression;\n      final PsiExpression containedExpression = typeCastExpression.getOperand();\n      return mayEvaluateToVariable(containedExpression, variable, builderPattern);\n    }\n    if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional = (PsiConditionalExpression)expression;\n      final PsiExpression thenExpression = conditional.getThenExpression();\n      final PsiExpression elseExpression = conditional.getElseExpression();\n      return mayEvaluateToVariable(thenExpression, variable, builderPattern) ||\n             mayEvaluateToVariable(elseExpression, variable, builderPattern);\n    }\n    if (expression instanceof PsiArrayAccessExpression) {\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiArrayAccessExpression) {\n        return false;\n      }\n      final PsiType type = variable.getType();\n      if (!(type instanceof PsiArrayType)) {\n        return false;\n      }\n      final PsiArrayType arrayType = (PsiArrayType)type;\n      final int dimensions = arrayType.getArrayDimensions();\n      if (dimensions <= 1) {\n        return false;\n      }\n      PsiArrayAccessExpression arrayAccessExpression = (PsiArrayAccessExpression)expression;\n      PsiExpression arrayExpression = arrayAccessExpression.getArrayExpression();\n      int count = 1;\n      while (arrayExpression instanceof PsiArrayAccessExpression) {\n        arrayAccessExpression = (PsiArrayAccessExpression)arrayExpression;\n        arrayExpression = arrayAccessExpression.getArrayExpression();\n        count++;\n      }\n      return count != dimensions && mayEvaluateToVariable(arrayExpression, variable, builderPattern);\n    }\n    if (builderPattern && expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;\n      final PsiMethod method = methodCallExpression.resolveMethod();\n      if (method == null) {\n        return false;\n      }\n      final PsiType returnType = method.getReturnType();\n      final PsiType variableType = variable.getType();\n      if (!variableType.equals(returnType)) {\n        return false;\n      }\n      final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();\n      final PsiExpression qualifier = methodExpression.getQualifierExpression();\n      return mayEvaluateToVariable(qualifier, variable, builderPattern);\n    }\n    return evaluatesToVariable(expression, variable);\n  }","id":74922,"modified_method":"static boolean mayEvaluateToVariable(@Nullable PsiExpression expression, @NotNull PsiVariable variable, boolean builderPattern) {\n    if (expression == null) {\n      return false;\n    }\n    if (expression instanceof PsiParenthesizedExpression) {\n      final PsiParenthesizedExpression parenthesizedExpression = (PsiParenthesizedExpression)expression;\n      final PsiExpression containedExpression = parenthesizedExpression.getExpression();\n      return mayEvaluateToVariable(containedExpression, variable, builderPattern);\n    }\n    if (expression instanceof PsiTypeCastExpression) {\n      final PsiTypeCastExpression typeCastExpression = (PsiTypeCastExpression)expression;\n      final PsiExpression containedExpression = typeCastExpression.getOperand();\n      return mayEvaluateToVariable(containedExpression, variable, builderPattern);\n    }\n    if (expression instanceof PsiConditionalExpression) {\n      final PsiConditionalExpression conditional = (PsiConditionalExpression)expression;\n      final PsiExpression thenExpression = conditional.getThenExpression();\n      final PsiExpression elseExpression = conditional.getElseExpression();\n      return mayEvaluateToVariable(thenExpression, variable, builderPattern) ||\n             mayEvaluateToVariable(elseExpression, variable, builderPattern);\n    }\n    if (expression instanceof PsiArrayAccessExpression) {\n      final PsiElement parent = expression.getParent();\n      if (parent instanceof PsiArrayAccessExpression) {\n        return false;\n      }\n      final PsiType type = variable.getType();\n      if (!(type instanceof PsiArrayType)) {\n        return false;\n      }\n      final PsiArrayType arrayType = (PsiArrayType)type;\n      final int dimensions = arrayType.getArrayDimensions();\n      if (dimensions <= 1) {\n        return false;\n      }\n      PsiArrayAccessExpression arrayAccessExpression = (PsiArrayAccessExpression)expression;\n      PsiExpression arrayExpression = arrayAccessExpression.getArrayExpression();\n      int count = 1;\n      while (arrayExpression instanceof PsiArrayAccessExpression) {\n        arrayAccessExpression = (PsiArrayAccessExpression)arrayExpression;\n        arrayExpression = arrayAccessExpression.getArrayExpression();\n        count++;\n      }\n      return count != dimensions && mayEvaluateToVariable(arrayExpression, variable, builderPattern);\n    }\n    if (builderPattern && expression instanceof PsiMethodCallExpression) {\n      final PsiMethodCallExpression methodCallExpression = (PsiMethodCallExpression)expression;\n      final PsiMethod method = methodCallExpression.resolveMethod();\n      if (method == null) {\n        return false;\n      }\n      final PsiType returnType = method.getReturnType();\n      final PsiType variableType = variable.getType();\n      if (!variableType.equals(returnType)) {\n        return false;\n      }\n      final PsiReferenceExpression methodExpression = methodCallExpression.getMethodExpression();\n      final PsiExpression qualifier = methodExpression.getQualifierExpression();\n      return mayEvaluateToVariable(qualifier, variable, true);\n    }\n    return evaluatesToVariable(expression, variable);\n  }","commit_id":"9f3e64908830123bdf348049e9100bc43e9ca87d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static boolean variableIsAssigned(@NotNull PsiVariable variable) {\n    if (variable instanceof PsiField) {\n      if (variable.hasModifierProperty(PsiModifier.PRIVATE)) {\n        final PsiClass aClass = PsiUtil.getTopLevelClass(variable);\n        return variableIsAssigned(variable, aClass);\n      }\n      return !ReferencesSearch.search(variable, variable.getUseScope()).forEach(new Processor<PsiReference>() {\n        @Override\n        public boolean process(PsiReference reference) {\n          final PsiElement element = reference.getElement();\n          if (!(element instanceof PsiExpression)) {\n            return true;\n          }\n          final PsiExpression expression = (PsiExpression)element;\n          return !PsiUtil.isAccessedForWriting(expression);\n        }\n      });\n    }\n    final PsiElement context =\n      PsiTreeUtil.getParentOfType(variable, PsiCodeBlock.class, PsiMethod.class, PsiLambdaExpression.class,\n                                  PsiCatchSection.class, PsiForStatement.class, PsiForeachStatement.class);\n    return variableIsAssigned(variable, context);\n  }","id":74923,"modified_method":"public static boolean variableIsAssigned(@NotNull PsiVariable variable) {\n    if (variable instanceof PsiField) {\n      if (variable.hasModifierProperty(PsiModifier.PRIVATE)) {\n        final PsiClass aClass = PsiUtil.getTopLevelClass(variable);\n        return variableIsAssigned(variable, aClass);\n      }\n      return !ReferencesSearch.search(variable, variable.getUseScope()).forEach(reference -> {\n        final PsiElement element = reference.getElement();\n        if (!(element instanceof PsiExpression)) {\n          return true;\n        }\n        final PsiExpression expression = (PsiExpression)element;\n        return !PsiUtil.isAccessedForWriting(expression);\n      });\n    }\n    final PsiElement context =\n      PsiTreeUtil.getParentOfType(variable, PsiCodeBlock.class, PsiMethod.class, PsiLambdaExpression.class,\n                                  PsiCatchSection.class, PsiForStatement.class, PsiForeachStatement.class);\n    return variableIsAssigned(variable, context);\n  }","commit_id":"9f3e64908830123bdf348049e9100bc43e9ca87d","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"public static Pair<PsiMethod, PsiClass> getSiblingInheritedViaSubClass(@NotNull final PsiMethod method,\n                                                                         @NotNull Map<PsiClass, PsiClass> subClassCache) {\n    if (!method.hasModifierProperty(PsiModifier.PUBLIC)) return null;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return null;\n    final PsiClass containingClass = method.getContainingClass();\n    boolean hasSubClass = containingClass != null && !containingClass.isInterface() && subClassCache.get(containingClass) != null;\n    if (!hasSubClass) {\n      return null;\n    }\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(containingClass.getQualifiedName())) {\n      return null;\n    }\n    final Collection<PsiAnchor> checkedInterfaces = new THashSet<PsiAnchor>();\n    checkedInterfaces.add(PsiAnchor.create(containingClass));\n    final Ref<Pair<PsiMethod, PsiClass>> result = Ref.create();\n    ClassInheritorsSearch.search(containingClass, containingClass.getUseScope(), true, true, false).forEach(new Processor<PsiClass>() {\n      @Override\n      public boolean process(PsiClass inheritor) {\n        ProgressManager.checkCanceled();\n        for (PsiClassType interfaceType : inheritor.getImplementsListTypes()) {\n          ProgressManager.checkCanceled();\n          PsiClassType.ClassResolveResult resolved = interfaceType.resolveGenerics();\n          PsiClass anInterface = resolved.getElement();\n          if (anInterface == null || !checkedInterfaces.add(PsiAnchor.create(anInterface))) continue;\n          for (PsiMethod superMethod : anInterface.findMethodsByName(method.getName(), true)) {\n            PsiElement navigationElement = superMethod.getNavigationElement();\n            if (!(navigationElement instanceof PsiMethod)) continue; // Kotlin\n            superMethod = (PsiMethod)navigationElement;\n            ProgressManager.checkCanceled();\n            PsiClass superInterface = superMethod.getContainingClass();\n            if (superInterface == null) {\n              continue;\n            }\n            if (containingClass.isInheritor(superInterface, true)) {\n              // if containingClass implements the superInterface then it's not a sibling inheritance but a pretty boring the usual one\n              continue;\n            }\n\n            // calculate substitutor of containingClass --> inheritor\n            PsiSubstitutor substitutor = TypeConversionUtil.getSuperClassSubstitutor(containingClass, inheritor, PsiSubstitutor.EMPTY);\n            // calculate substitutor of inheritor --> superInterface\n            substitutor = TypeConversionUtil.getSuperClassSubstitutor(superInterface, inheritor, substitutor);\n\n            final MethodSignature superSignature = superMethod.getSignature(substitutor);\n            final MethodSignature derivedSignature = method.getSignature(PsiSubstitutor.EMPTY);\n            boolean isOverridden = MethodSignatureUtil.isSubsignature(superSignature, derivedSignature);\n\n            if (!isOverridden) {\n              continue;\n            }\n            result.set(Pair.create(superMethod, inheritor));\n            return false;\n          }\n        }\n        return true;\n      }\n    });\n    return result.get();\n  }","id":74924,"modified_method":"public static Pair<PsiMethod, PsiClass> getSiblingInheritedViaSubClass(@NotNull final PsiMethod method,\n                                                                         @NotNull Map<PsiClass, PsiClass> subClassCache) {\n    if (!method.hasModifierProperty(PsiModifier.PUBLIC)) return null;\n    if (method.hasModifierProperty(PsiModifier.STATIC)) return null;\n    final PsiClass containingClass = method.getContainingClass();\n    if (containingClass == null || containingClass.isInterface()) {\n      return null;\n    }\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(containingClass.getQualifiedName())) {\n      return null;\n    }\n    final Collection<PsiAnchor> checkedInterfaces = new THashSet<>();\n    checkedInterfaces.add(PsiAnchor.create(containingClass));\n    final Ref<Pair<PsiMethod, PsiClass>> result = Ref.create();\n    ClassInheritorsSearch.search(containingClass, containingClass.getUseScope(), true, true, false).forEach(\n    inheritor -> {\n        ProgressManager.checkCanceled();\n        for (PsiClassType interfaceType : inheritor.getImplementsListTypes()) {\n          ProgressManager.checkCanceled();\n          PsiClassType.ClassResolveResult resolved = interfaceType.resolveGenerics();\n          PsiClass anInterface = resolved.getElement();\n          if (anInterface == null || !checkedInterfaces.add(PsiAnchor.create(anInterface))) continue;\n          for (PsiMethod superMethod : anInterface.findMethodsByName(method.getName(), true)) {\n            PsiElement navigationElement = superMethod.getNavigationElement();\n            if (!(navigationElement instanceof PsiMethod)) continue; // Kotlin\n            superMethod = (PsiMethod)navigationElement;\n            ProgressManager.checkCanceled();\n            PsiClass superInterface = superMethod.getContainingClass();\n            if (superInterface == null) {\n              continue;\n            }\n            if (containingClass.isInheritor(superInterface, true)) {\n              // if containingClass implements the superInterface then it's not a sibling inheritance but a pretty boring the usual one\n              continue;\n            }\n\n            // calculate substitutor of containingClass --> inheritor\n            PsiSubstitutor substitutor = TypeConversionUtil.getSuperClassSubstitutor(containingClass, inheritor, PsiSubstitutor.EMPTY);\n            // calculate substitutor of inheritor --> superInterface\n            substitutor = TypeConversionUtil.getSuperClassSubstitutor(superInterface, inheritor, substitutor);\n\n            final MethodSignature superSignature = superMethod.getSignature(substitutor);\n            final MethodSignature derivedSignature = method.getSignature(PsiSubstitutor.EMPTY);\n            boolean isOverridden = MethodSignatureUtil.isSubsignature(superSignature, derivedSignature);\n\n            if (!isOverridden) {\n              continue;\n            }\n            result.set(Pair.create(superMethod, inheritor));\n            return false;\n          }\n        }\n        return true;\n    });\n    return result.get();\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n  public static PsiElement[] findSuperElements(@NotNull PsiElement element) {\n    if (element instanceof PsiClass) {\n      PsiClass aClass = (PsiClass) element;\n      List<PsiClass> allSupers = new ArrayList<PsiClass>(Arrays.asList(aClass.getSupers()));\n      for (Iterator<PsiClass> iterator = allSupers.iterator(); iterator.hasNext();) {\n        PsiClass superClass = iterator.next();\n        if (CommonClassNames.JAVA_LANG_OBJECT.equals(superClass.getQualifiedName())) iterator.remove();\n      }\n      return allSupers.toArray(new PsiClass[allSupers.size()]);\n    }\n    if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod) element;\n      if (method.isConstructor()) {\n        PsiMethod constructorInSuper = PsiSuperMethodUtil.findConstructorInSuper(method);\n        if (constructorInSuper != null) {\n          return new PsiMethod[]{constructorInSuper};\n        }\n      }\n      else {\n        PsiMethod[] superMethods = method.findSuperMethods(false);\n        if (superMethods.length == 0) {\n          PsiMethod superMethod = getSiblingInheritedViaSubClass(method);\n          if (superMethod != null) {\n            superMethods = new PsiMethod[]{superMethod};\n          }\n        }\n        return superMethods;\n      }\n    }\n    return PsiElement.EMPTY_ARRAY;\n  }","id":74925,"modified_method":"@NotNull\n  public static PsiElement[] findSuperElements(@NotNull PsiElement element) {\n    if (element instanceof PsiClass) {\n      PsiClass aClass = (PsiClass) element;\n      List<PsiClass> allSupers = new ArrayList<>(Arrays.asList(aClass.getSupers()));\n      for (Iterator<PsiClass> iterator = allSupers.iterator(); iterator.hasNext();) {\n        PsiClass superClass = iterator.next();\n        if (CommonClassNames.JAVA_LANG_OBJECT.equals(superClass.getQualifiedName())) iterator.remove();\n      }\n      return allSupers.toArray(new PsiClass[allSupers.size()]);\n    }\n    if (element instanceof PsiMethod) {\n      PsiMethod method = (PsiMethod) element;\n      if (method.isConstructor()) {\n        PsiMethod constructorInSuper = PsiSuperMethodUtil.findConstructorInSuper(method);\n        if (constructorInSuper != null) {\n          return new PsiMethod[]{constructorInSuper};\n        }\n      }\n      else {\n        PsiMethod[] superMethods = method.findSuperMethods(false);\n        if (superMethods.length == 0) {\n          PsiMethod superMethod = getSiblingInheritedViaSubClass(method);\n          if (superMethod != null) {\n            superMethods = new PsiMethod[]{superMethod};\n          }\n        }\n        return superMethods;\n      }\n    }\n    return PsiElement.EMPTY_ARRAY;\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isFinal(@NotNull final PsiClass baseClass) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return Boolean.valueOf(baseClass.hasModifierProperty(PsiModifier.FINAL));\n      }\n    }).booleanValue();\n  }","id":74926,"modified_method":"private static boolean isFinal(@NotNull final PsiClass baseClass) {\n    return ApplicationManager.getApplication().runReadAction((Computable<Boolean>)() -> baseClass.hasModifierProperty(PsiModifier.FINAL));\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean isJavaLangObject(@NotNull final PsiClass baseClass) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return baseClass.isValid() && CommonClassNames.JAVA_LANG_OBJECT.equals(baseClass.getQualifiedName());\n      }\n    });\n  }","id":74927,"modified_method":"static boolean isJavaLangObject(@NotNull final PsiClass baseClass) {\n    return ApplicationManager.getApplication().runReadAction(\n      (Computable<Boolean>)() -> baseClass.isValid() && CommonClassNames.JAVA_LANG_OBJECT.equals(baseClass.getQualifiedName()));\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static void processInheritors(@NotNull final Processor<PsiClass> consumer,\n                                           @NotNull final PsiClass baseClass,\n                                           @NotNull final SearchScope searchScope,\n                                           @NotNull final ClassInheritorsSearch.SearchParameters parameters) {\n    if (baseClass instanceof PsiAnonymousClass || isFinal(baseClass)) return;\n\n    Project project = PsiUtilCore.getProjectInReadAction(baseClass);\n    if (isJavaLangObject(baseClass)) {\n      AllClassesSearch.search(searchScope, project, parameters.getNameCondition()).forEach(new Processor<PsiClass>() {\n        @Override\n        public boolean process(final PsiClass aClass) {\n          ProgressManager.checkCanceled();\n          return isJavaLangObject(aClass) || consumer.process(aClass);\n        }\n      });\n      return;\n    }\n\n    final Ref<PsiClass> currentBase = Ref.create(null);\n    final Stack<PsiAnchor> stack = new Stack<PsiAnchor>();\n    final Set<PsiAnchor> processed = ContainerUtil.newTroveSet();\n\n    final Processor<PsiClass> processor = new ReadActionProcessor<PsiClass>() {\n      @Override\n      public boolean processInReadAction(PsiClass candidate) {\n        ProgressManager.checkCanceled();\n\n        if (parameters.isCheckInheritance() || parameters.isCheckDeep() && !(candidate instanceof PsiAnonymousClass)) {\n          if (!candidate.isInheritor(currentBase.get(), false)) {\n            return true;\n          }\n        }\n\n        if (PsiSearchScopeUtil.isInScope(searchScope, candidate)) {\n          if (candidate instanceof PsiAnonymousClass) {\n            return consumer.process(candidate);\n          }\n          \n          final String name = candidate.getName();\n          if (name != null && parameters.getNameCondition().value(name) && !consumer.process(candidate)) {\n            return false;\n          }\n        }\n\n        if (parameters.isCheckDeep() && !(candidate instanceof PsiAnonymousClass) && !isFinal(candidate)) {\n          stack.push(PsiAnchor.create(candidate));\n        }\n        return true;\n      }\n    };\n    \n    ApplicationManager.getApplication().runReadAction(new Runnable() {\n      @Override\n      public void run() {\n        stack.push(PsiAnchor.create(baseClass));\n      }\n    });\n    final GlobalSearchScope projectScope = GlobalSearchScope.allScope(project);\n    \n    while (!stack.isEmpty()) {\n      ProgressManager.checkCanceled();\n\n      final PsiAnchor anchor = stack.pop();\n      if (!processed.add(anchor)) continue;\n\n      PsiClass psiClass = ApplicationManager.getApplication().runReadAction(new Computable<PsiClass>() {\n          @Override\n          public PsiClass compute() {\n            return (PsiClass)anchor.retrieve();\n          }\n        });\n      if (psiClass == null) continue;\n\n      currentBase.set(psiClass);\n      if (!DirectClassInheritorsSearch.search(psiClass, projectScope, parameters.isIncludeAnonymous(), false).forEach(processor)) return;\n    }\n  }","id":74928,"modified_method":"private static boolean processInheritors(@NotNull final ClassInheritorsSearch.SearchParameters parameters,\n                                           @NotNull final Processor<PsiClass> consumer) {\n    @NotNull final PsiClass baseClass = parameters.getClassToProcess();\n    if (baseClass instanceof PsiAnonymousClass || isFinal(baseClass)) return true;\n\n    final SearchScope searchScope = parameters.getScope();\n    Project project = PsiUtilCore.getProjectInReadAction(baseClass);\n    if (isJavaLangObject(baseClass)) {\n      return AllClassesSearch.search(searchScope, project, parameters.getNameCondition()).forEach(aClass -> {\n          ProgressManager.checkCanceled();\n          return isJavaLangObject(aClass) || consumer.process(aClass);\n      });\n    }\n\n    final Ref<PsiClass> currentBase = Ref.create(null);\n    final Stack<PsiAnchor> stack = new Stack<>();\n    final Set<PsiAnchor> processed = ContainerUtil.newTroveSet();\n\n    final Processor<PsiClass> processor = new ReadActionProcessor<PsiClass>() {\n      @Override\n      public boolean processInReadAction(PsiClass candidate) {\n        ProgressManager.checkCanceled();\n\n        if (parameters.isCheckInheritance() || parameters.isCheckDeep() && !(candidate instanceof PsiAnonymousClass)) {\n          if (!candidate.isInheritor(currentBase.get(), false)) {\n            return true;\n          }\n        }\n\n        if (PsiSearchScopeUtil.isInScope(searchScope, candidate)) {\n          if (candidate instanceof PsiAnonymousClass) {\n            return consumer.process(candidate);\n          }\n          \n          final String name = candidate.getName();\n          if (name != null && parameters.getNameCondition().value(name) && !consumer.process(candidate)) {\n            return false;\n          }\n        }\n\n        if (parameters.isCheckDeep() && !(candidate instanceof PsiAnonymousClass) && !isFinal(candidate)) {\n          stack.push(PsiAnchor.create(candidate));\n        }\n        return true;\n      }\n    };\n    \n    ApplicationManager.getApplication().runReadAction(() -> {\n        stack.push(PsiAnchor.create(baseClass));\n    });\n    final GlobalSearchScope projectScope = GlobalSearchScope.allScope(project);\n    \n    while (!stack.isEmpty()) {\n      ProgressManager.checkCanceled();\n\n      final PsiAnchor anchor = stack.pop();\n      if (!processed.add(anchor)) continue;\n\n      PsiClass psiClass = ApplicationManager.getApplication().runReadAction((Computable<PsiClass>)() -> (PsiClass)anchor.retrieve());\n      if (psiClass == null) continue;\n\n      currentBase.set(psiClass);\n      if (!DirectClassInheritorsSearch.search(psiClass, projectScope, parameters.isIncludeAnonymous(), false).forEach(processor)) return false;\n    }\n    return true;\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void processQuery(@NotNull ClassInheritorsSearch.SearchParameters parameters, @NotNull Processor<PsiClass> consumer) {\n    final PsiClass baseClass = parameters.getClassToProcess();\n    final SearchScope searchScope = parameters.getScope();\n\n    LOG.assertTrue(searchScope != null);\n\n    ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n    if (progress != null) {\n      progress.pushState();\n      String className = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n        @Override\n        public String compute() {\n          return baseClass.getName();\n        }\n      });\n      progress.setText(className != null ?\n                       PsiBundle.message(\"psi.search.inheritors.of.class.progress\", className) :\n                       PsiBundle.message(\"psi.search.inheritors.progress\"));\n    }\n\n    try {\n      processInheritors(consumer, baseClass, searchScope, parameters);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n\n  }","id":74929,"modified_method":"@Override\n  public void processQuery(@NotNull ClassInheritorsSearch.SearchParameters parameters, @NotNull Processor<PsiClass> consumer) {\n    final PsiClass baseClass = parameters.getClassToProcess();\n    final SearchScope searchScope = parameters.getScope();\n\n    LOG.assertTrue(searchScope != null);\n\n    ProgressIndicator progress = ProgressIndicatorProvider.getGlobalProgressIndicator();\n    if (progress != null) {\n      progress.pushState();\n      String className = ApplicationManager.getApplication().runReadAction((Computable<String>)baseClass::getName);\n      progress.setText(className != null ?\n                       PsiBundle.message(\"psi.search.inheritors.of.class.progress\", className) :\n                       PsiBundle.message(\"psi.search.inheritors.progress\"));\n    }\n\n    try {\n      processInheritors(parameters, consumer);\n    }\n    finally {\n      if (progress != null) {\n        progress.popState();\n      }\n    }\n\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean execute(@NotNull final DirectClassInheritorsSearch.SearchParameters p, @NotNull final Processor<PsiClass> consumer) {\n    final PsiClass aClass = p.getClassToProcess();\n\n    final SearchScope useScope = ApplicationManager.getApplication().runReadAction((Computable<SearchScope>)aClass::getUseScope);\n\n    final String qualifiedName = ApplicationManager.getApplication().runReadAction((Computable<String>)aClass::getQualifiedName);\n\n    final Project project = PsiUtilCore.getProjectInReadAction(aClass);\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(qualifiedName)) {\n      return AllClassesSearch.search(useScope, project).forEach(psiClass -> {\n        ProgressManager.checkCanceled();\n        if (psiClass.isInterface()) {\n          return consumer.process(psiClass);\n        }\n        final PsiClass superClass = psiClass.getSuperClass();\n        if (superClass != null &&\n            CommonClassNames.JAVA_LANG_OBJECT.equals(ApplicationManager.getApplication().runReadAction((Computable<String>)superClass::getQualifiedName))) {\n          return consumer.process(psiClass);\n        }\n        return true;\n      });\n    }\n\n    final GlobalSearchScope scope = useScope instanceof GlobalSearchScope ? (GlobalSearchScope)useScope : new EverythingGlobalScope(project);\n    final String searchKey = ApplicationManager.getApplication().runReadAction((Computable<String>)aClass::getName);\n    if (StringUtil.isEmpty(searchKey)) {\n      return true;\n    }\n\n    Collection<PsiReferenceList> candidates =\n      MethodUsagesSearcher.resolveInReadAction(project, () -> JavaSuperClassNameOccurenceIndex.getInstance().get(searchKey, project, scope));\n\n    Map<String, List<PsiClass>> classes = new HashMap<>();\n\n    for (final PsiReferenceList referenceList : candidates) {\n      ProgressManager.checkCanceled();\n      final PsiClass candidate = (PsiClass)ApplicationManager.getApplication().runReadAction((Computable<PsiElement>)referenceList::getParent);\n      if (!checkInheritance(p, aClass, candidate, project)) continue;\n\n      String fqn = ApplicationManager.getApplication().runReadAction((Computable<String>)candidate::getQualifiedName);\n      List<PsiClass> list = classes.get(fqn);\n      if (list == null) {\n        list = new ArrayList<>();\n        classes.put(fqn, list);\n      }\n      list.add(candidate);\n    }\n\n    if (!classes.isEmpty()) {\n      final VirtualFile jarFile = getJarFile(aClass);\n      for (List<PsiClass> sameNamedClasses : classes.values()) {\n        ProgressManager.checkCanceled();\n        if (!processSameNamedClasses(sameNamedClasses, jarFile, consumer)) return false;\n      }\n    }\n\n    if (p.includeAnonymous()) {\n      Collection<PsiAnonymousClass> anonymousCandidates =\n        MethodUsagesSearcher.resolveInReadAction(project, () -> JavaAnonymousClassBaseRefOccurenceIndex.getInstance().get(searchKey, project, scope));\n\n      for (PsiAnonymousClass candidate : anonymousCandidates) {\n        ProgressManager.checkCanceled();\n        if (!checkInheritance(p, aClass, candidate, project)) continue;\n\n        if (!consumer.process(candidate)) return false;\n      }\n\n      boolean isEnum = ApplicationManager.getApplication().runReadAction((Computable<Boolean>)aClass::isEnum);\n      if (isEnum) {\n        // abstract enum can be subclassed in the body\n        PsiField[] fields = ApplicationManager.getApplication().runReadAction((Computable<PsiField[]>)aClass::getFields);\n        for (final PsiField field : fields) {\n          ProgressManager.checkCanceled();\n          if (field instanceof PsiEnumConstant) {\n            PsiEnumConstantInitializer initializingClass =\n              ApplicationManager.getApplication().runReadAction((Computable<PsiEnumConstantInitializer>)((PsiEnumConstant)field)::getInitializingClass);\n            if (initializingClass != null) {\n              if (!consumer.process(initializingClass)) return false;\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","id":74930,"modified_method":"@Override\n  public boolean execute(@NotNull final DirectClassInheritorsSearch.SearchParameters parameters, @NotNull final Processor<PsiClass> consumer) {\n    final PsiClass aClass = parameters.getClassToProcess();\n\n    final SearchScope useScope = ApplicationManager.getApplication().runReadAction((Computable<SearchScope>)aClass::getUseScope);\n\n    final Project project = PsiUtilCore.getProjectInReadAction(aClass);\n    if (JavaClassInheritorsSearcher.isJavaLangObject(aClass)) {\n      return AllClassesSearch.search(useScope, project).forEach(psiClass -> {\n        ProgressManager.checkCanceled();\n        if (psiClass.isInterface()) {\n          return consumer.process(psiClass);\n        }\n        final PsiClass superClass = psiClass.getSuperClass();\n        return superClass == null || !JavaClassInheritorsSearcher.isJavaLangObject(superClass) || consumer.process(psiClass);\n      });\n    }\n\n    final GlobalSearchScope scope = useScope instanceof GlobalSearchScope ? (GlobalSearchScope)useScope : new EverythingGlobalScope(project);\n    final String searchKey = ApplicationManager.getApplication().runReadAction((Computable<String>)aClass::getName);\n    if (StringUtil.isEmpty(searchKey)) {\n      return true;\n    }\n\n    Collection<PsiReferenceList> candidates =\n      MethodUsagesSearcher.resolveInReadAction(project, () -> JavaSuperClassNameOccurenceIndex.getInstance().get(searchKey, project, scope));\n\n    Map<String, List<PsiClass>> classes = new HashMap<>();\n\n    for (final PsiReferenceList referenceList : candidates) {\n      ProgressManager.checkCanceled();\n      final PsiClass candidate = (PsiClass)ApplicationManager.getApplication().runReadAction((Computable<PsiElement>)referenceList::getParent);\n      if (!checkInheritance(parameters, aClass, candidate, project)) continue;\n\n      String fqn = ApplicationManager.getApplication().runReadAction((Computable<String>)candidate::getQualifiedName);\n      List<PsiClass> list = classes.get(fqn);\n      if (list == null) {\n        list = new ArrayList<>();\n        classes.put(fqn, list);\n      }\n      list.add(candidate);\n    }\n\n    if (!classes.isEmpty()) {\n      final VirtualFile jarFile = getJarFile(aClass);\n      for (List<PsiClass> sameNamedClasses : classes.values()) {\n        ProgressManager.checkCanceled();\n        if (!processSameNamedClasses(sameNamedClasses, jarFile, consumer)) return false;\n      }\n    }\n\n    if (parameters.includeAnonymous()) {\n      Collection<PsiAnonymousClass> anonymousCandidates =\n        MethodUsagesSearcher.resolveInReadAction(project, () -> JavaAnonymousClassBaseRefOccurenceIndex.getInstance().get(searchKey, project, scope));\n\n      for (PsiAnonymousClass candidate : anonymousCandidates) {\n        ProgressManager.checkCanceled();\n        if (!checkInheritance(parameters, aClass, candidate, project)) continue;\n\n        if (!consumer.process(candidate)) return false;\n      }\n\n      boolean isEnum = ApplicationManager.getApplication().runReadAction((Computable<Boolean>)aClass::isEnum);\n      if (isEnum) {\n        // abstract enum can be subclassed in the body\n        PsiField[] fields = ApplicationManager.getApplication().runReadAction((Computable<PsiField[]>)aClass::getFields);\n        for (final PsiField field : fields) {\n          ProgressManager.checkCanceled();\n          if (field instanceof PsiEnumConstant) {\n            PsiEnumConstantInitializer initializingClass =\n              ApplicationManager.getApplication().runReadAction((Computable<PsiEnumConstantInitializer>)((PsiEnumConstant)field)::getInitializingClass);\n            if (initializingClass != null) {\n              if (!consumer.process(initializingClass)) return false;\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@NotNull\n    @Override\n    public Function<? super PsiElement, String> getCommonTooltip(@NotNull List<MergeableLineMarkerInfo> infos) {\n      return new Function<PsiElement, String>() {\n        @Override\n        public String fun(PsiElement element) {\n          return \"Multiple method overrides\";\n        }\n      };\n    }","id":74931,"modified_method":"@NotNull\n    @Override\n    public Function<? super PsiElement, String> getCommonTooltip(@NotNull List<MergeableLineMarkerInfo> infos) {\n      return (Function<PsiElement, String>)element -> \"Multiple method overrides\";\n    }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void collectOverridingMethods(@NotNull final Collection<PsiMethod> methods, @NotNull Collection<LineMarkerInfo> result) {\n    if (!myOverriddenOption.isEnabled() && !myImplementedOption.isEnabled()) return;\n    final Set<PsiMethod> overridden = new HashSet<PsiMethod>();\n    Set<PsiClass> classes = new THashSet<PsiClass>();\n    for (PsiMethod method : methods) {\n      ProgressManager.checkCanceled();\n      final PsiClass parentClass = method.getContainingClass();\n      if (!CommonClassNames.JAVA_LANG_OBJECT.equals(parentClass.getQualifiedName())) {\n        classes.add(parentClass);\n      }\n    }\n\n    for (final PsiClass aClass : classes) {\n      AllOverridingMethodsSearch.search(aClass).forEach(new Processor<Pair<PsiMethod, PsiMethod>>() {\n        @Override\n        public boolean process(final Pair<PsiMethod, PsiMethod> pair) {\n          ProgressManager.checkCanceled();\n\n          final PsiMethod superMethod = pair.getFirst();\n          if (methods.remove(superMethod)) {\n            overridden.add(superMethod);\n          }\n          return !methods.isEmpty();\n        }\n      });\n    }\n\n    if (!methods.isEmpty()) {\n      for (PsiClass aClass : classes) {\n        final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(aClass);\n        if (interfaceMethod != null) {\n          if (FunctionalExpressionSearch.search(aClass).findFirst() != null) {\n            overridden.add(interfaceMethod);\n          }\n        }\n      }\n    }\n\n    for (PsiMethod method : overridden) {\n      ProgressManager.checkCanceled();\n      boolean overrides = !method.hasModifierProperty(PsiModifier.ABSTRACT);\n      if (overrides) {\n        if (!myOverriddenOption.isEnabled()) return;\n      }\n      else {\n        if (!myImplementedOption.isEnabled()) return;\n      }\n      PsiElement range = getMethodRange(method);\n      final MarkerType type = MarkerType.OVERRIDDEN_METHOD;\n      final Icon icon = overrides ? AllIcons.Gutter.OverridenMethod : AllIcons.Gutter.ImplementedMethod;\n      LineMarkerInfo<PsiElement> info = new LineMarkerInfo<PsiElement>(range, range.getTextRange(),\n                                                                       icon, Pass.UPDATE_OVERRIDDEN_MARKERS, type.getTooltip(),\n                                                                       type.getNavigationHandler(),\n                                                                       GutterIconRenderer.Alignment.RIGHT);\n      NavigateAction.setNavigateAction(info, overrides ? \"Go to overriding methods\" : \"Go to implementation(s)\", IdeActions.ACTION_GOTO_IMPLEMENTATION);\n      result.add(info);\n    }\n  }","id":74932,"modified_method":"private void collectOverridingMethods(@NotNull final Collection<PsiMethod> methods, @NotNull Collection<LineMarkerInfo> result) {\n    if (!myOverriddenOption.isEnabled() && !myImplementedOption.isEnabled()) return;\n    final Set<PsiMethod> overridden = new HashSet<>();\n    Set<PsiClass> classes = new THashSet<>();\n    for (PsiMethod method : methods) {\n      ProgressManager.checkCanceled();\n      final PsiClass parentClass = method.getContainingClass();\n      if (!CommonClassNames.JAVA_LANG_OBJECT.equals(parentClass.getQualifiedName())) {\n        classes.add(parentClass);\n      }\n    }\n\n    for (final PsiClass aClass : classes) {\n      AllOverridingMethodsSearch.search(aClass).forEach(pair -> {\n        ProgressManager.checkCanceled();\n\n        final PsiMethod superMethod = pair.getFirst();\n        if (methods.remove(superMethod)) {\n          overridden.add(superMethod);\n        }\n        return !methods.isEmpty();\n      });\n    }\n\n    if (!methods.isEmpty()) {\n      for (PsiClass aClass : classes) {\n        final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(aClass);\n        if (interfaceMethod != null) {\n          if (FunctionalExpressionSearch.search(aClass).findFirst() != null) {\n            overridden.add(interfaceMethod);\n          }\n        }\n      }\n    }\n\n    for (PsiMethod method : overridden) {\n      ProgressManager.checkCanceled();\n      boolean overrides = !method.hasModifierProperty(PsiModifier.ABSTRACT);\n      if (overrides) {\n        if (!myOverriddenOption.isEnabled()) return;\n      }\n      else {\n        if (!myImplementedOption.isEnabled()) return;\n      }\n      PsiElement range = getMethodRange(method);\n      final MarkerType type = MarkerType.OVERRIDDEN_METHOD;\n      final Icon icon = overrides ? AllIcons.Gutter.OverridenMethod : AllIcons.Gutter.ImplementedMethod;\n      LineMarkerInfo<PsiElement> info = new LineMarkerInfo<PsiElement>(range, range.getTextRange(),\n                                                                       icon, Pass.UPDATE_OVERRIDDEN_MARKERS, type.getTooltip(),\n                                                                       type.getNavigationHandler(),\n                                                                       GutterIconRenderer.Alignment.RIGHT);\n      NavigateAction.setNavigateAction(info, overrides ? \"Go to overriding methods\" : \"Go to implementation(s)\", IdeActions.ACTION_GOTO_IMPLEMENTATION);\n      result.add(info);\n    }\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public void collectSlowLineMarkers(@NotNull final List<PsiElement> elements, @NotNull final Collection<LineMarkerInfo> result) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    Map<PsiClass, PsiClass> subClassCache = FindSuperElementsHelper.createSubClassCache();\n\n    Collection<PsiMethod> methods = new THashSet<PsiMethod>();\n    //noinspection ForLoopReplaceableByForEach\n    for (int i = 0; i < elements.size(); i++) {\n      PsiElement element = elements.get(i);\n      ProgressManager.checkCanceled();\n      if (!(element instanceof PsiIdentifier)) continue;\n      PsiElement parent = element.getParent();\n      if (parent instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)parent;\n        if (PsiUtil.canBeOverriden(method)) {\n          methods.add(method);\n        }\n      }\n      else if (parent instanceof PsiClass && !(parent instanceof PsiTypeParameter)) {\n        collectInheritingClasses((PsiClass)parent, result, subClassCache);\n      }\n    }\n    if (!methods.isEmpty()) {\n      collectOverridingMethods(methods, result);\n      collectSiblingInheritedMethods(methods, result, subClassCache);\n    }\n  }","id":74933,"modified_method":"@Override\n  public void collectSlowLineMarkers(@NotNull final List<PsiElement> elements, @NotNull final Collection<LineMarkerInfo> result) {\n    ApplicationManager.getApplication().assertReadAccessAllowed();\n    Map<PsiClass, PsiClass> subClassCache = FindSuperElementsHelper.createSubClassCache();\n\n    Collection<PsiMethod> methods = new THashSet<>();\n    //noinspection ForLoopReplaceableByForEach\n    for (int i = 0; i < elements.size(); i++) {\n      PsiElement element = elements.get(i);\n      ProgressManager.checkCanceled();\n      if (!(element instanceof PsiIdentifier)) continue;\n      PsiElement parent = element.getParent();\n      if (parent instanceof PsiMethod) {\n        final PsiMethod method = (PsiMethod)parent;\n        if (PsiUtil.canBeOverriden(method)) {\n          methods.add(method);\n        }\n      }\n      else if (parent instanceof PsiClass && !(parent instanceof PsiTypeParameter)) {\n        collectInheritingClasses((PsiClass)parent, result, subClassCache);\n      }\n    }\n    if (!methods.isEmpty()) {\n      collectOverridingMethods(methods, result);\n      collectSiblingInheritedMethods(methods, result, subClassCache);\n    }\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  @Nullable\n  public LineMarkerInfo getLineMarkerInfo(@NotNull final PsiElement element) {\n    PsiElement parent;\n    if (element instanceof PsiIdentifier && (parent = element.getParent()) instanceof PsiMethod) {\n      if (!myOverridingOption.isEnabled() && !myImplementingOption.isEnabled()) return null;\n      PsiMethod method = (PsiMethod)parent;\n      MethodSignatureBackedByPsiMethod superSignature = SuperMethodsSearch.search(method, null, true, false).findFirst();\n      if (superSignature != null) {\n        boolean overrides =\n          method.hasModifierProperty(PsiModifier.ABSTRACT) == superSignature.getMethod().hasModifierProperty(PsiModifier.ABSTRACT);\n\n        final Icon icon;\n        if (overrides) {\n          if (!myOverridingOption.isEnabled()) return null;\n          icon = AllIcons.Gutter.OverridingMethod;\n        }\n        else {\n          if (!myImplementingOption.isEnabled()) return null;\n          icon = AllIcons.Gutter.ImplementingMethod;\n        }\n        return createSuperMethodLineMarkerInfo(element, icon, Pass.UPDATE_ALL);\n      }\n    }\n\n    final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(element);\n    final PsiElement firstChild = element.getFirstChild();\n    if (interfaceMethod != null && firstChild != null && myLambdaOption.isEnabled()) {\n      return createSuperMethodLineMarkerInfo(firstChild, AllIcons.Gutter.ImplementingFunctionalInterface, Pass.UPDATE_ALL);\n    }\n\n    if (myDaemonSettings.SHOW_METHOD_SEPARATORS && firstChild == null) {\n      PsiElement element1 = element;\n      boolean isMember = false;\n      while (element1 != null && !(element1 instanceof PsiFile) && element1.getPrevSibling() == null) {\n        element1 = element1.getParent();\n        if (element1 instanceof PsiMember) {\n          isMember = true;\n          break;\n        }\n      }\n      if (isMember && !(element1 instanceof PsiAnonymousClass || element1.getParent() instanceof PsiAnonymousClass)) {\n        PsiFile file = element1.getContainingFile();\n        Document document = file == null ? null : PsiDocumentManager.getInstance(file.getProject()).getLastCommittedDocument(file);\n        boolean drawSeparator = false;\n\n        if (document != null) {\n          CharSequence documentChars = document.getCharsSequence();\n          int category = getCategory(element1, documentChars);\n          for (PsiElement child = element1.getPrevSibling(); child != null; child = child.getPrevSibling()) {\n            int category1 = getCategory(child, documentChars);\n            if (category1 == 0) continue;\n            drawSeparator = category != 1 || category1 != 1;\n            break;\n          }\n        }\n\n        if (drawSeparator) {\n          LineMarkerInfo info = new LineMarkerInfo<PsiElement>(element, element.getTextRange(), null, Pass.UPDATE_ALL,\n                                                               FunctionUtil.<Object, String>nullConstant(), null,\n                                                               GutterIconRenderer.Alignment.RIGHT);\n          EditorColorsScheme scheme = myColorsManager.getGlobalScheme();\n          info.separatorColor = scheme.getColor(CodeInsightColors.METHOD_SEPARATORS_COLOR);\n          info.separatorPlacement = SeparatorPlacement.TOP;\n          return info;\n        }\n      }\n    }\n\n    return null;\n  }","id":74934,"modified_method":"@Override\n  @Nullable\n  public LineMarkerInfo getLineMarkerInfo(@NotNull final PsiElement element) {\n    PsiElement parent;\n    if (element instanceof PsiIdentifier && (parent = element.getParent()) instanceof PsiMethod) {\n      if (!myOverridingOption.isEnabled() && !myImplementingOption.isEnabled()) return null;\n      PsiMethod method = (PsiMethod)parent;\n      MethodSignatureBackedByPsiMethod superSignature = SuperMethodsSearch.search(method, null, true, false).findFirst();\n      if (superSignature != null) {\n        boolean overrides =\n          method.hasModifierProperty(PsiModifier.ABSTRACT) == superSignature.getMethod().hasModifierProperty(PsiModifier.ABSTRACT);\n\n        final Icon icon;\n        if (overrides) {\n          if (!myOverridingOption.isEnabled()) return null;\n          icon = AllIcons.Gutter.OverridingMethod;\n        }\n        else {\n          if (!myImplementingOption.isEnabled()) return null;\n          icon = AllIcons.Gutter.ImplementingMethod;\n        }\n        return createSuperMethodLineMarkerInfo(element, icon, Pass.UPDATE_ALL);\n      }\n    }\n\n    final PsiMethod interfaceMethod = LambdaUtil.getFunctionalInterfaceMethod(element);\n    final PsiElement firstChild = element.getFirstChild();\n    if (interfaceMethod != null && firstChild != null && myLambdaOption.isEnabled()) {\n      return createSuperMethodLineMarkerInfo(firstChild, AllIcons.Gutter.ImplementingFunctionalInterface, Pass.UPDATE_ALL);\n    }\n\n    if (myDaemonSettings.SHOW_METHOD_SEPARATORS && firstChild == null) {\n      PsiElement element1 = element;\n      boolean isMember = false;\n      while (element1 != null && !(element1 instanceof PsiFile) && element1.getPrevSibling() == null) {\n        element1 = element1.getParent();\n        if (element1 instanceof PsiMember) {\n          isMember = true;\n          break;\n        }\n      }\n      if (isMember && !(element1 instanceof PsiAnonymousClass || element1.getParent() instanceof PsiAnonymousClass)) {\n        PsiFile file = element1.getContainingFile();\n        Document document = file == null ? null : PsiDocumentManager.getInstance(file.getProject()).getLastCommittedDocument(file);\n        boolean drawSeparator = false;\n\n        if (document != null) {\n          CharSequence documentChars = document.getCharsSequence();\n          int category = getCategory(element1, documentChars);\n          for (PsiElement child = element1.getPrevSibling(); child != null; child = child.getPrevSibling()) {\n            int category1 = getCategory(child, documentChars);\n            if (category1 == 0) continue;\n            drawSeparator = category != 1 || category1 != 1;\n            break;\n          }\n        }\n\n        if (drawSeparator) {\n          LineMarkerInfo info = new LineMarkerInfo<>(element, element.getTextRange(), null, Pass.UPDATE_ALL,\n                                                     FunctionUtil.<Object, String>nullConstant(), null,\n                                                     GutterIconRenderer.Alignment.RIGHT);\n          EditorColorsScheme scheme = myColorsManager.getGlobalScheme();\n          info.separatorColor = scheme.getColor(CodeInsightColors.METHOD_SEPARATORS_COLOR);\n          info.separatorPlacement = SeparatorPlacement.TOP;\n          return info;\n        }\n      }\n    }\n\n    return null;\n  }","commit_id":"cf996c91f05efce96ebe3df7851a2426114011c2","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static VirtualFile getJarFile(final PsiClass aClass) {\n    return ApplicationManager.getApplication().runReadAction(new Computable<VirtualFile>() {\n      @Override\n      public VirtualFile compute() {\n        return PsiUtil.getJarFile(aClass);\n      }\n    });\n  }","id":74935,"modified_method":"private static VirtualFile getJarFile(final PsiClass aClass) {\n    return ApplicationManager.getApplication().runReadAction((Computable<VirtualFile>)() -> PsiUtil.getJarFile(aClass));\n  }","commit_id":"2c52eb3033fcd57de5086dfc2a5bd25d6abde93e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"@Override\n  public boolean execute(@NotNull final DirectClassInheritorsSearch.SearchParameters p, @NotNull final Processor<PsiClass> consumer) {\n    final PsiClass aClass = p.getClassToProcess();\n\n    final SearchScope useScope = ApplicationManager.getApplication().runReadAction(new Computable<SearchScope>() {\n      @Override\n      public SearchScope compute() {\n        return aClass.getUseScope();\n      }\n    });\n\n    final String qualifiedName = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n      @Override\n      public String compute() {\n        return aClass.getQualifiedName();\n      }\n    });\n\n    final Project project = PsiUtilCore.getProjectInReadAction(aClass);\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(qualifiedName)) {\n      //[pasynkov]: WTF?\n      //final SearchScope scope = useScope.intersectWith(GlobalSearchScope.notScope(GlobalSearchScope.getScopeRestrictedByFileTypes(\n      //    GlobalSearchScope.allScope(psiManager.getProject()), StdFileTypes.JSP, StdFileTypes.JSPX)));\n\n      return AllClassesSearch.search(useScope, project).forEach(new Processor<PsiClass>() {\n        @Override\n        public boolean process(final PsiClass psiClass) {\n          ProgressManager.checkCanceled();\n          if (psiClass.isInterface()) {\n            return consumer.process(psiClass);\n          }\n          final PsiClass superClass = psiClass.getSuperClass();\n          if (superClass != null && CommonClassNames.JAVA_LANG_OBJECT.equals(ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n            public String compute() {\n              return superClass.getQualifiedName();\n            }\n          }))) {\n            return consumer.process(psiClass);\n          }\n          return true;\n        }\n      });\n    }\n\n    final GlobalSearchScope scope = useScope instanceof GlobalSearchScope ? (GlobalSearchScope)useScope : new EverythingGlobalScope(project);\n    final String searchKey = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n      @Override\n      public String compute() {\n        return aClass.getName();\n      }\n    });\n    if (StringUtil.isEmpty(searchKey)) {\n      return true;\n    }\n\n    Collection<PsiReferenceList> candidates = MethodUsagesSearcher.resolveInReadAction(project,\n                                                                                       new Computable<Collection<PsiReferenceList>>() {\n                                                                                         @Override\n                                                                                         public Collection<PsiReferenceList> compute() {\n                                                                                           return JavaSuperClassNameOccurenceIndex\n                                                                                             .getInstance().get(searchKey, project, scope);\n                                                                                         }\n                                                                                       });\n\n    Map<String, List<PsiClass>> classes = new HashMap<String, List<PsiClass>>();\n\n    for (final PsiReferenceList referenceList : candidates) {\n      ProgressManager.checkCanceled();\n      final PsiClass candidate = (PsiClass)ApplicationManager.getApplication().runReadAction(new Computable<PsiElement>() {\n        @Override\n        public PsiElement compute() {\n          return referenceList.getParent();\n        }\n      });\n      if (!checkInheritance(p, aClass, candidate, project)) continue;\n\n      String fqn = ApplicationManager.getApplication().runReadAction(new Computable<String>() {\n        @Override\n        public String compute() {\n          return candidate.getQualifiedName();\n        }\n      });\n      List<PsiClass> list = classes.get(fqn);\n      if (list == null) {\n        list = new ArrayList<PsiClass>();\n        classes.put(fqn, list);\n      }\n      list.add(candidate);\n    }\n\n    if (!classes.isEmpty()) {\n      final VirtualFile jarFile = getJarFile(aClass);\n      for (List<PsiClass> sameNamedClasses : classes.values()) {\n        ProgressManager.checkCanceled();\n        if (!processSameNamedClasses(consumer, sameNamedClasses, jarFile)) return false;\n      }\n    }\n\n    if (p.includeAnonymous()) {\n      Collection<PsiAnonymousClass> anonymousCandidates = MethodUsagesSearcher.resolveInReadAction(project,\n                                                                                                   new Computable<Collection<PsiAnonymousClass>>() {\n                                                                                                     @Override\n                                                                                                     public Collection<PsiAnonymousClass> compute() {\n                                                                                                       return JavaAnonymousClassBaseRefOccurenceIndex\n                                                                                                         .getInstance()\n                                                                                                         .get(searchKey, project, scope);\n                                                                                                     }\n                                                                                                   });\n\n      for (PsiAnonymousClass candidate : anonymousCandidates) {\n        ProgressManager.checkCanceled();\n        if (!checkInheritance(p, aClass, candidate, project)) continue;\n\n        if (!consumer.process(candidate)) return false;\n      }\n\n      boolean isEnum = ApplicationManager.getApplication().runReadAction(new Computable<Boolean>() {\n        @Override\n        public Boolean compute() {\n          return aClass.isEnum();\n        }\n      });\n      if (isEnum) {\n        // abstract enum can be subclassed in the body\n        PsiField[] fields = ApplicationManager.getApplication().runReadAction(new Computable<PsiField[]>() {\n          @Override\n          public PsiField[] compute() {\n            return aClass.getFields();\n          }\n        });\n        for (final PsiField field : fields) {\n          ProgressManager.checkCanceled();\n          if (field instanceof PsiEnumConstant) {\n            PsiEnumConstantInitializer initializingClass =\n              ApplicationManager.getApplication().runReadAction(new Computable<PsiEnumConstantInitializer>() {\n                @Override\n                public PsiEnumConstantInitializer compute() {\n                  return ((PsiEnumConstant)field).getInitializingClass();\n                }\n              });\n            if (initializingClass != null) {\n              if (!consumer.process(initializingClass)) return false;\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","id":74936,"modified_method":"@Override\n  public boolean execute(@NotNull final DirectClassInheritorsSearch.SearchParameters p, @NotNull final Processor<PsiClass> consumer) {\n    final PsiClass aClass = p.getClassToProcess();\n\n    final SearchScope useScope = ApplicationManager.getApplication().runReadAction((Computable<SearchScope>)aClass::getUseScope);\n\n    final String qualifiedName = ApplicationManager.getApplication().runReadAction((Computable<String>)aClass::getQualifiedName);\n\n    final Project project = PsiUtilCore.getProjectInReadAction(aClass);\n    if (CommonClassNames.JAVA_LANG_OBJECT.equals(qualifiedName)) {\n      return AllClassesSearch.search(useScope, project).forEach(psiClass -> {\n        ProgressManager.checkCanceled();\n        if (psiClass.isInterface()) {\n          return consumer.process(psiClass);\n        }\n        final PsiClass superClass = psiClass.getSuperClass();\n        if (superClass != null &&\n            CommonClassNames.JAVA_LANG_OBJECT.equals(ApplicationManager.getApplication().runReadAction((Computable<String>)superClass::getQualifiedName))) {\n          return consumer.process(psiClass);\n        }\n        return true;\n      });\n    }\n\n    final GlobalSearchScope scope = useScope instanceof GlobalSearchScope ? (GlobalSearchScope)useScope : new EverythingGlobalScope(project);\n    final String searchKey = ApplicationManager.getApplication().runReadAction((Computable<String>)aClass::getName);\n    if (StringUtil.isEmpty(searchKey)) {\n      return true;\n    }\n\n    Collection<PsiReferenceList> candidates =\n      MethodUsagesSearcher.resolveInReadAction(project, () -> JavaSuperClassNameOccurenceIndex.getInstance().get(searchKey, project, scope));\n\n    Map<String, List<PsiClass>> classes = new HashMap<>();\n\n    for (final PsiReferenceList referenceList : candidates) {\n      ProgressManager.checkCanceled();\n      final PsiClass candidate = (PsiClass)ApplicationManager.getApplication().runReadAction((Computable<PsiElement>)referenceList::getParent);\n      if (!checkInheritance(p, aClass, candidate, project)) continue;\n\n      String fqn = ApplicationManager.getApplication().runReadAction((Computable<String>)candidate::getQualifiedName);\n      List<PsiClass> list = classes.get(fqn);\n      if (list == null) {\n        list = new ArrayList<>();\n        classes.put(fqn, list);\n      }\n      list.add(candidate);\n    }\n\n    if (!classes.isEmpty()) {\n      final VirtualFile jarFile = getJarFile(aClass);\n      for (List<PsiClass> sameNamedClasses : classes.values()) {\n        ProgressManager.checkCanceled();\n        if (!processSameNamedClasses(consumer, sameNamedClasses, jarFile)) return false;\n      }\n    }\n\n    if (p.includeAnonymous()) {\n      Collection<PsiAnonymousClass> anonymousCandidates =\n        MethodUsagesSearcher.resolveInReadAction(project, () -> JavaAnonymousClassBaseRefOccurenceIndex.getInstance().get(searchKey, project, scope));\n\n      for (PsiAnonymousClass candidate : anonymousCandidates) {\n        ProgressManager.checkCanceled();\n        if (!checkInheritance(p, aClass, candidate, project)) continue;\n\n        if (!consumer.process(candidate)) return false;\n      }\n\n      boolean isEnum = ApplicationManager.getApplication().runReadAction((Computable<Boolean>)aClass::isEnum);\n      if (isEnum) {\n        // abstract enum can be subclassed in the body\n        PsiField[] fields = ApplicationManager.getApplication().runReadAction((Computable<PsiField[]>)aClass::getFields);\n        for (final PsiField field : fields) {\n          ProgressManager.checkCanceled();\n          if (field instanceof PsiEnumConstant) {\n            PsiEnumConstantInitializer initializingClass =\n              ApplicationManager.getApplication().runReadAction((Computable<PsiEnumConstantInitializer>)((PsiEnumConstant)field)::getInitializingClass);\n            if (initializingClass != null) {\n              if (!consumer.process(initializingClass)) return false;\n            }\n          }\n        }\n      }\n    }\n\n    return true;\n  }","commit_id":"2c52eb3033fcd57de5086dfc2a5bd25d6abde93e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private static boolean checkInheritance(final DirectClassInheritorsSearch.SearchParameters p, final PsiClass aClass, final PsiClass candidate, Project project) {\n    return MethodUsagesSearcher.resolveInReadAction(project, new Computable<Boolean>() {\n      @Override\n      public Boolean compute() {\n        return !p.isCheckInheritance() || candidate.isInheritor(aClass, false);\n      }\n    });\n  }","id":74937,"modified_method":"private static boolean checkInheritance(final DirectClassInheritorsSearch.SearchParameters p, final PsiClass aClass, final PsiClass candidate, Project project) {\n    return MethodUsagesSearcher.resolveInReadAction(project, () -> !p.isCheckInheritance() || candidate.isInheritor(aClass, false));\n  }","commit_id":"2c52eb3033fcd57de5086dfc2a5bd25d6abde93e","url":"https://github.com/JetBrains/intellij-community"},{"original_method":"private void evict() {\n    while (lruCapacity < lruList.size()) {\n      final OClosableEntry<K, V> entry = lruList.poll();\n      if (entry != null)\n        entry.get().close();\n    }\n  }","id":74938,"modified_method":"private void evict() {\n    while (lruList.size() > lruCapacity) {\n      Iterator<OClosableEntry<K, V>> iterator = lruList.iterator();\n\n      boolean entryClosed = false;\n\n      while (iterator.hasNext()) {\n        OClosableEntry<K, V> entry = iterator.next();\n        if (entry.makeClosed(entry.get())) {\n          iterator.remove();\n          entryClosed = true;\n          break;\n        }\n      }\n\n      if (!entryClosed)\n        break;\n    }\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OClosableHolder<V> acquire(K key) {\n    final OClosableEntry<K, V> entry = data.get(key);\n\n    if (entry != null) {\n      final OClosableHolder<V> holder = new OClosableHolder<V>(entry.get().isOpen(), entry);\n      logAcquire(entry);\n\n      return holder;\n    }\n\n    return null;\n  }","id":74939,"modified_method":"public OClosableEntry<K, V> acquire(K key) {\n    final OClosableEntry<K, V> entry = data.get(key);\n\n    if (entry == null)\n      return null;\n\n    while (true) {\n      if (entry.isRetired() || entry.isDead()) {\n        return null;\n      } else if (entry.isClosed()) {\n        if (entry.makeAcquiredFromClosed(entry.get())) {\n          assert entry.get().isOpen();\n          logOpen(entry);\n          return entry;\n        }\n      } else if (entry.isOpen()) {\n        if (entry.makeAcquiredFromOpen()) {\n          logAcquire(entry);\n          assert entry.get().isOpen();\n          return entry;\n        }\n      } else {\n        if (entry.incrementAcquired()) {\n          logAcquire(entry);\n          assert entry.get().isOpen();\n          return entry;\n        }\n      }\n    }\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private void applyRead(OClosableEntry<K, V> entry) {\n    if (entry.isAlive() && lruList.contains(entry)) {\n      lruList.moveToTheTail(entry);\n    }\n  }","id":74940,"modified_method":"private void applyRead(OClosableEntry<K, V> entry) {\n    if (lruList.contains(entry)) {\n      lruList.moveToTheTail(entry);\n    }\n    evict();\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public LogRemoved(OClosableEntry<K, V> entry) {\n      this.entry = entry;\n    }","id":74941,"modified_method":"private LogRemoved(OClosableEntry<K, V> entry) {\n      this.entry = entry;\n    }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public void run() {\n      //despite of the fact that status can be change it is safe to proceed because it means\n      //that LogRemove entree will be after LogAdd entree (we call markRetired firs and then only log entry removal)\n      if (entry.isAlive()) {\n        lruList.moveToTheTail(entry);\n        evict();\n      }\n    }","id":74942,"modified_method":"@Override\n    public void run() {\n      //despite of the fact that status can be change it is safe to proceed because it means\n      //that LogRemove entree will be after LogAdd entree (we call markRetired firs and then only log entry removal)\n      if (!entry.isDead() && !entry.isRetired()) {\n        lruList.moveToTheTail(entry);\n        evict();\n      }\n    }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public LogAdd(OClosableEntry<K, V> entry) {\n      this.entry = entry;\n    }","id":74943,"modified_method":"private LogAdd(OClosableEntry<K, V> entry) {\n      this.entry = entry;\n    }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"/**\n   * Put entry at the tail of LRU list only if it is absent.\n   *\n   * @param entry LRU entry\n   */\n  private void logRelease(OClosableEntry<K, V> entry) {\n    afterWrite(new LogRelease(entry));\n  }","id":74944,"modified_method":"public void release(OClosableEntry<K, V> entry) {\n    entry.releaseAcquired();\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public Void call() throws Exception {\n      latch.await();\n\n      try {\n        Random random = new Random();\n\n        while (!stop.get()) {\n          int index = random.nextInt(limit);\n\n          final OClosableHolder<CItem> holder = dictionary.acquire((long) index);\n          if (holder != null) {\n            holder.get().open();\n            dictionary.release(holder);\n          }\n        }\n\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw e;\n      }\n\n      return null;\n    }","id":74945,"modified_method":"@Override\n    public Void call() throws Exception {\n      latch.await();\n\n      long counter = 0;\n      long start = System.nanoTime();\n\n      try {\n        Random random = new Random();\n\n        while (!stop.get()) {\n          int index = random.nextInt(limit);\n          final OClosableEntry<Long, CItem> entry = dictionary.acquire((long) index);\n          if (entry != null) {\n            Assert.assertTrue(entry.get().isOpen());\n            counter++;\n            dictionary.release(entry);\n          }\n        }\n\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw e;\n      }\n\n      long end = System.nanoTime();\n\n      System.out.println(\"Files processed \" + counter + \" nanos per item \" + (end - start) / counter);\n      return null;\n    }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Adder(OClosableDictionary<Long, CItem> dictionary, CountDownLatch latch, int limit) {\n      this.dictionary = dictionary;\n      this.latch = latch;\n      this.limit = limit;\n    }","id":74946,"modified_method":"public Adder(OClosableDictionary<Long, CItem> dictionary, CountDownLatch latch, int from, int to) {\n      this.dictionary = dictionary;\n      this.latch = latch;\n      this.from = from;\n      this.to = to;\n    }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testMultipleThreadsConsistency() throws Exception {\n    ExecutorService executor = Executors.newFixedThreadPool(8);\n    List<Future<Void>> futures = new ArrayList<Future<Void>>();\n    CountDownLatch latch = new CountDownLatch(1);\n\n    int limit = 60000;\n\n    OClosableDictionary<Long, CItem> dictionary = new OClosableDictionary<Long, CItem>(500);\n    futures.add(executor.submit(new Adder(dictionary, latch, limit / 3)));\n    // futures.add(executor.submit(new Adder(dictionary, latch, limit / 3)));\n\n    AtomicBoolean stop = new AtomicBoolean();\n\n    for (int i = 0; i < 1; i++) {\n      futures.add(executor.submit(new Acquier(dictionary, latch, limit, stop)));\n    }\n\n    latch.countDown();\n\n    Thread.sleep(10000);\n\n    // futures.add(executor.submit(new Adder(dictionary, latch, limit / 3)));\n\n    stop.set(true);\n    for (Future<Void> future : futures) {\n      future.get();\n    }\n\n    dictionary.emptyBuffers();\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n  }","id":74947,"modified_method":"public void testMultipleThreadsConsistency() throws Exception {\n    ExecutorService executor = Executors.newCachedThreadPool();\n    List<Future<Void>> futures = new ArrayList<Future<Void>>();\n    CountDownLatch latch = new CountDownLatch(1);\n\n    int limit = 60000;\n\n    OClosableDictionary<Long, CItem> dictionary = new OClosableDictionary<Long, CItem>(500);\n    futures.add(executor.submit(new Adder(dictionary, latch, 0, limit / 3)));\n    futures.add(executor.submit(new Adder(dictionary, latch, limit / 3, 2 * limit / 3)));\n\n    AtomicBoolean stop = new AtomicBoolean();\n\n    for (int i = 0; i < 16; i++) {\n      futures.add(executor.submit(new Acquier(dictionary, latch, limit, stop)));\n    }\n\n    latch.countDown();\n\n    Thread.sleep(60000);\n\n    futures.add(executor.submit(new Adder(dictionary, latch, 2 * limit / 3, limit)));\n\n    Thread.sleep(10 * 60000);\n\n    stop.set(true);\n    for (Future<Void> future : futures) {\n      future.get();\n    }\n\n    dictionary.emptyBuffers();\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n    Assert.assertTrue(dictionary.checkNoClosedItemsInLRUList());\n    Assert.assertTrue(dictionary.checkLRUSize());\n    Assert.assertTrue(dictionary.checkLRUSizeEqualsToCapacity());\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testCloseHalfOfTheItems() {\n    final OClosableDictionary<Long, OClosableItem> dictionary = new OClosableDictionary<Long, OClosableItem>(10);\n\n    for (int i = 0; i < 10; i++) {\n      final OClosableItem closableItem = new CItem(i);\n      dictionary.add((long) i, closableItem);\n    }\n\n    OClosableHolder<OClosableItem> holder = dictionary.acquire(10L);\n    Assert.assertNull(holder);\n\n    for (int i = 0; i < 5; i++) {\n      holder = dictionary.acquire((long) i);\n      dictionary.release(holder);\n    }\n\n    dictionary.emptyBuffers();\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n\n    for (int i = 0; i < 5; i++) {\n      dictionary.add(10L + i, new CItem(10 + i));\n    }\n\n    for (int i = 0; i < 5; i++) {\n      Assert.assertTrue(dictionary.get((long) i).isOpen());\n    }\n\n    for (int i = 5; i < 10; i++) {\n      Assert.assertTrue(!dictionary.get((long) i).isOpen());\n    }\n\n    for (int i = 10; i < 15; i++) {\n      Assert.assertTrue(dictionary.get((long) i).isOpen());\n    }\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n  }","id":74948,"modified_method":"public void testCloseHalfOfTheItems() {\n    final OClosableDictionary<Long, OClosableItem> dictionary = new OClosableDictionary<Long, OClosableItem>(10);\n\n    for (int i = 0; i < 10; i++) {\n      final OClosableItem closableItem = new CItem(i);\n      dictionary.add((long) i, closableItem);\n    }\n\n    OClosableEntry<Long, OClosableItem> entry = dictionary.acquire(10L);\n    Assert.assertNull(entry);\n\n    for (int i = 0; i < 5; i++) {\n      entry = dictionary.acquire((long) i);\n      dictionary.release(entry);\n    }\n\n    dictionary.emptyBuffers();\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n\n    for (int i = 0; i < 5; i++) {\n      dictionary.add(10L + i, new CItem(10 + i));\n    }\n\n    for (int i = 0; i < 5; i++) {\n      Assert.assertTrue(dictionary.get((long) i).isOpen());\n    }\n\n    for (int i = 5; i < 10; i++) {\n      Assert.assertTrue(!dictionary.get((long) i).isOpen());\n    }\n\n    for (int i = 10; i < 15; i++) {\n      Assert.assertTrue(dictionary.get((long) i).isOpen());\n    }\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void testSingleItemAddRemove() {\n    final OClosableItem closableItem = new CItem(0);\n    final OClosableDictionary<Long, OClosableItem> dictionary = new OClosableDictionary<Long, OClosableItem>(10);\n\n    dictionary.add(1L, closableItem);\n\n    OClosableHolder<OClosableItem> holder = dictionary.acquire(0L);\n    Assert.assertNull(holder);\n\n    holder = dictionary.acquire(1L);\n    Assert.assertNotNull(holder);\n    dictionary.release(holder);\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n  }","id":74949,"modified_method":"public void testSingleItemAddRemove() {\n    final OClosableItem closableItem = new CItem(0);\n    final OClosableDictionary<Long, OClosableItem> dictionary = new OClosableDictionary<Long, OClosableItem>(10);\n\n    dictionary.add(1L, closableItem);\n\n    OClosableEntry<Long, OClosableItem> entry = dictionary.acquire(0L);\n    Assert.assertNull(entry);\n\n    entry = dictionary.acquire(1L);\n    Assert.assertNotNull(entry);\n    dictionary.release(entry);\n\n    Assert.assertTrue(dictionary.checkAllLRUListItemsInMap());\n    Assert.assertTrue(dictionary.checkAllOpenItemsInLRUList());\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"@Override\n    public Void call() throws Exception {\n      latch.await();\n\n      try {\n        for (int i = 0; i < limit; i++) {\n          dictionary.add((long) i, new CItem(i));\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw e;\n      }\n\n      return null;\n    }","id":74950,"modified_method":"@Override\n    public Void call() throws Exception {\n      latch.await();\n\n      try {\n        for (int i = from; i < to; i++) {\n          dictionary.add((long) i, new CItem(i));\n        }\n      } catch (Exception e) {\n        e.printStackTrace();\n        throw e;\n      }\n\n      System.out.println(\"Add from \" + from + \" to \" + to + \" completed\");\n\n      return null;\n    }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public OClosableEntry(V item) {\n    this.item = new AtomicReference<V>(item);\n  }","id":74951,"modified_method":"public OClosableEntry(V item) {\n    this.item = item;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean makeAcquired() {\n    return state.compareAndSet(State.ALIVE, State.ACQUIRED);\n  }","id":74952,"modified_method":"void releaseAcquired() {\n    stateLock.lock();\n    try {\n      long acquireCount = state >>> ACQUIRED_OFFSET;\n\n      if (acquireCount < 1)\n        throw new IllegalStateException(\"Amount of acquires less than one\");\n\n      acquireCount--;\n\n      if (acquireCount < 1)\n        state = STATUS_OPEN;\n      else\n        state = acquireCount << ACQUIRED_OFFSET;\n    } finally {\n      stateLock.unlock();\n    }\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean isRetired() {\n    return state.get().equals(State.RETIRED);\n  }","id":74953,"modified_method":"boolean isRetired() {\n    return state == STATUS_RETIRED;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void makeRetired() {\n    state.compareAndSet(State.ALIVE, State.RETIRED);\n  }","id":74954,"modified_method":"void makeRetired() {\n    state = STATUS_RETIRED;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean isDead() {\n    return state.get().equals(State.DEAD);\n  }","id":74955,"modified_method":"boolean isDead() {\n    return state == STATUS_DEAD;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public void makeDead() {\n    state.compareAndSet(State.RETIRED, State.DEAD);\n  }","id":74956,"modified_method":"void makeDead() {\n    state = STATUS_DEAD;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public V get() {\n    return item.get();\n  }","id":74957,"modified_method":"public V get() {\n    return item;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public boolean isClosed() {\n    return state.get().equals(State.CLOSED);\n  }","id":74958,"modified_method":"boolean isClosed() {\n    return state == STATUS_CLOSED;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"public Iterator<OClosableEntry<K, E>> iterator() {\n    return new Iterator<OClosableEntry<K, E>>() {\n      private OClosableEntry<K, E> next = tail;\n\n      @Override\n      public boolean hasNext() {\n        return next != null;\n      }\n\n      @Override\n      public OClosableEntry<K, E> next() {\n        if (next == null) {\n          throw new NoSuchElementException();\n        }\n\n        OClosableEntry<K, E> result = next;\n        next = next.getPrev();\n        return result;\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    };\n  }","id":74959,"modified_method":"public Iterator<OClosableEntry<K, E>> iterator() {\n    return new Iterator<OClosableEntry<K, E>>() {\n      private OClosableEntry<K, E> next = head;\n      private OClosableEntry<K, E> current = null;\n\n      @Override\n      public boolean hasNext() {\n        return next != null;\n      }\n\n      @Override\n      public OClosableEntry<K, E> next() {\n        if (next == null) {\n          throw new NoSuchElementException();\n        }\n\n        current = next;\n        next = next.getNext();\n        return current;\n      }\n\n      @Override\n      public void remove() {\n        if (current == null) {\n          throw new IllegalStateException(\"Method next was not called\");\n        }\n\n        OClosableLRUList.this.remove(current);\n        current = null;\n      }\n    };\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private boolean assertBackwardStructure() {\n    if (tail == null)\n      return head == null;\n\n    OClosableEntry<K, E> current = tail;\n\n    while (current.getPrev() != null) {\n      OClosableEntry<K, E> prev = current.getPrev();\n      OClosableEntry<K, E> next = current.getNext();\n\n      if (prev != null) {\n        assert prev.getNext() == current;\n      }\n\n      if (next != null) {\n        assert next.getPrev() == current;\n      }\n\n      current = current.getPrev();\n    }\n\n    return current == head;\n  }","id":74960,"modified_method":"boolean assertBackwardStructure() {\n    if (tail == null)\n      return head == null;\n\n    OClosableEntry<K, E> current = tail;\n\n    while (current.getPrev() != null) {\n      OClosableEntry<K, E> prev = current.getPrev();\n      OClosableEntry<K, E> next = current.getNext();\n\n      if (prev != null) {\n        assert prev.getNext() == current;\n      }\n\n      if (next != null) {\n        assert next.getPrev() == current;\n      }\n\n      current = current.getPrev();\n    }\n\n    return current == head;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private boolean assertForwardStructure() {\n    if (head == null)\n      return tail == null;\n\n    OClosableEntry<K, E> current = head;\n\n    while (current.getNext() != null) {\n      OClosableEntry<K, E> prev = current.getPrev();\n      OClosableEntry<K, E> next = current.getNext();\n\n      if (prev != null) {\n        assert prev.getNext() == current;\n      }\n\n      if (next != null) {\n        assert next.getPrev() == current;\n      }\n\n      current = current.getNext();\n    }\n\n    return current == tail;\n  }","id":74961,"modified_method":"boolean assertForwardStructure() {\n    if (head == null)\n      return tail == null;\n\n    OClosableEntry<K, E> current = head;\n\n    while (current.getNext() != null) {\n      OClosableEntry<K, E> prev = current.getPrev();\n      OClosableEntry<K, E> next = current.getNext();\n\n      if (prev != null) {\n        assert prev.getNext() == current;\n      }\n\n      if (next != null) {\n        assert next.getPrev() == current;\n      }\n\n      current = current.getNext();\n    }\n\n    return current == tail;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"void moveToTheTail(OClosableEntry<K, E> entry) {\n    if (tail == entry) {\n      assert entry.getNext() == null;\n      return;\n    }\n\n    final OClosableEntry<K, E> next = entry.getNext();\n    final OClosableEntry<K, E> prev = entry.getPrev();\n\n    boolean newEntry = !(next != null || prev != null || entry == head);\n\n    if (prev != null) {\n      assert prev.getNext() == entry;\n    }\n\n    if (next != null) {\n      assert next.getPrev() == entry;\n    }\n\n    if (prev != null) {\n      prev.setNext(next);\n    }\n\n    if (next != null) {\n      next.setPrev(prev);\n    }\n\n    if (head == entry) {\n      assert entry.getPrev() == null;\n      head = next;\n    }\n\n    entry.setPrev(tail);\n    entry.setNext(null);\n    if (tail != null) {\n      assert tail.getNext() == null;\n      tail.setNext(entry);\n      tail = entry;\n    } else {\n      tail = head = entry;\n    }\n\n    if (newEntry)\n      size++;\n\n    assert assertForwardStructure();\n    assert assertBackwardStructure();\n  }","id":74962,"modified_method":"void moveToTheTail(OClosableEntry<K, E> entry) {\n    if (tail == entry) {\n      assert entry.getNext() == null;\n      return;\n    }\n\n    final OClosableEntry<K, E> next = entry.getNext();\n    final OClosableEntry<K, E> prev = entry.getPrev();\n\n    boolean newEntry = !(next != null || prev != null || entry == head);\n\n    if (prev != null) {\n      assert prev.getNext() == entry;\n    }\n\n    if (next != null) {\n      assert next.getPrev() == entry;\n    }\n\n    if (prev != null) {\n      prev.setNext(next);\n    }\n\n    if (next != null) {\n      next.setPrev(prev);\n    }\n\n    if (head == entry) {\n      assert entry.getPrev() == null;\n      head = next;\n    }\n\n    entry.setPrev(tail);\n    entry.setNext(null);\n    if (tail != null) {\n      assert tail.getNext() == null;\n      tail.setNext(entry);\n      tail = entry;\n    } else {\n      tail = head = entry;\n    }\n\n    if (newEntry)\n      size++;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"void remove(OClosableEntry<K, E> entry) {\n    final OClosableEntry<K, E> next = entry.getNext();\n    final OClosableEntry<K, E> prev = entry.getPrev();\n\n    if (!(next != null || prev != null || entry == head))\n      return;\n\n    if (prev != null) {\n      assert prev.getNext() == entry;\n      prev.setNext(next);\n    }\n\n    if (next != null) {\n      assert next.getPrev() == entry;\n      next.setPrev(next);\n    }\n\n    if (head == entry) {\n      assert entry.getPrev() == null;\n      head = next;\n    }\n\n    if (tail == entry) {\n      assert entry.getNext() == null;\n      tail = prev;\n    }\n\n    entry.setNext(null);\n    entry.setPrev(null);\n\n    size--;\n  }","id":74963,"modified_method":"void remove(OClosableEntry<K, E> entry) {\n    final OClosableEntry<K, E> next = entry.getNext();\n    final OClosableEntry<K, E> prev = entry.getPrev();\n\n    if (!(next != null || prev != null || entry == head))\n      return;\n\n    if (prev != null) {\n      assert prev.getNext() == entry;\n    }\n\n    if (next != null) {\n      assert next.getPrev() == entry;\n    }\n\n    if (next != null) {\n      next.setPrev(prev);\n    }\n\n    if (prev != null) {\n      prev.setNext(next);\n    }\n\n    if (head == entry) {\n      assert entry.getPrev() == null;\n      head = next;\n    }\n\n    if (tail == entry) {\n      assert entry.getNext() == null;\n      tail = prev;\n    }\n\n    entry.setNext(null);\n    entry.setPrev(null);\n\n    size--;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"OClosableEntry<K, E> poll() {\n    if (head == null)\n      return null;\n\n    final OClosableEntry<K, E> entry = head;\n\n    OClosableEntry<K, E> next = head.getNext();\n    assert next.getPrev() == head;\n\n    head = next;\n    next.setPrev(null);\n\n    assert head.getPrev() == null;\n\n    if (head == null)\n      tail = null;\n\n    entry.setNext(null);\n    assert entry.getPrev() == null;\n\n    size--;\n\n    assert assertForwardStructure();\n    assert assertBackwardStructure();\n\n    return entry;\n  }","id":74964,"modified_method":"OClosableEntry<K, E> poll() {\n    if (head == null)\n      return null;\n\n    final OClosableEntry<K, E> entry = head;\n\n    OClosableEntry<K, E> next = head.getNext();\n    assert next.getPrev() == head;\n\n    head = next;\n    next.setPrev(null);\n\n    assert head.getPrev() == null;\n\n    if (head == null)\n      tail = null;\n\n    entry.setNext(null);\n    assert entry.getPrev() == null;\n\n    size--;\n\n    return entry;\n  }","commit_id":"2b22f7ee9174ac04645d78000896ae03544558f7","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"protected ForwardWalker() {\n            next = _headptr.getNext();\n        }","id":74965,"modified_method":"protected ForwardWalker() {\n\t\t\tnext = _firstItem;\n        }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void clear() {\n    \t// Help to detect removal after clear().\n    \t// The check in remove() is enough, strictly,\n    \t// as long as people don't add elements afterwards.\n    \tDoublyLinkedList.Item<T> pos = _headptr.next;\n    \tDoublyLinkedList.Item<T> opos = _headptr;\n    \twhile(true) {\n    \t\tif(pos == _tailptr) break;\n    \t\tif(pos == null) break;\n    \t\tpos.setParent(null);\n    \t\tpos.setPrev(null);\n    \t\topos = pos;\n    \t\tpos = pos.getNext();\n    \t\topos.setNext(null);\n    \t}\n        _headptr.next = _tailptr;\n        _tailptr.prev = _headptr;\n        size = 0;\n    }","id":74966,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void clear() {\n    \t// Help to detect removal after clear().\n    \t// The check in remove() is enough, strictly,\n    \t// as long as people don't add elements afterwards.\n\t\tif (_firstItem == null)\n\t\t\treturn;\n\n\t\tDoublyLinkedList.Item<T> pos = _firstItem;\n\t\tDoublyLinkedList.Item<T> opos;\n\n    \twhile(true) {\n    \t\tif(pos == null) break;\n    \t\tpos.setParent(null);\n    \t\tpos.setPrev(null);\n    \t\topos = pos;\n    \t\tpos = pos.getNext();\n    \t\topos.setNext(null);\n    \t}\n\n\t\t_firstItem = _lastItem = null;\n        size = 0;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"public final boolean hasMoreElements() {\n            return next != _headptr;\n        }","id":74967,"modified_method":"public final boolean hasMoreElements() {\n\t\t\treturn next != null;\n        }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> prev(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> prev = i.getPrev();\n        return prev == _headptr ? null : prev;\n    }","id":74968,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> prev(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> prev = i.getPrev();\n\t\treturn prev;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final void unshift(DoublyLinkedList.Item<T> i) {\n        insertNext(_headptr, i);\n    }","id":74969,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final void unshift(DoublyLinkedList.Item<T> i) {\n\t\tinsertNext(null, i);\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * A new list with no items.\n     */\n    public DoublyLinkedListImpl() {\n        _headptr = new Item<T>();\n        _tailptr = new Item<T>();\n        _headptr.setParent(this);\n        _tailptr.setParent(this);\n        clear();\n    }","id":74970,"modified_method":"/**\n     * A new list with no items.\n     */\n    public DoublyLinkedListImpl() {\n        clear();\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"public DoublyLinkedList.Item<T> nextElement() {\n            if (next == _headptr)\n                throw new NoSuchElementException();\n            DoublyLinkedList.Item<T> result = next;\n\t    if(next == null) throw new IllegalStateException(\"next==null\");\n            next = next.getPrev();\n            return result;\n        }","id":74971,"modified_method":"public T nextElement() {\n\t\t\tif (next == null)\n                throw new NoSuchElementException();\n            DoublyLinkedList.Item<T> result = next;\n\t    if(next == null) throw new IllegalStateException(\"next==null\");\n            next = next.getPrev();\n\t\t\treturn (T) result;\n        }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final int size() {\n        return size;\n    }","id":74972,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final int size() {\n\t\tassert size != 0 || (_firstItem == null && _lastItem == null);\n        return size;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> head() {\n        return size == 0 ? null : _headptr.next;\n    }","id":74973,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> head() {\n\t\treturn size == 0 ? null : _firstItem;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> tail() {\n        return size == 0 ? null : _tailptr.prev;\n    }","id":74974,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> tail() {\n\t\treturn size == 0 ? null : _lastItem;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final boolean hasNext(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> next = i.getNext();\n        return (next != null) && (next != _tailptr);\n    }","id":74975,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final boolean hasNext(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> next = i.getNext();\n\t\treturn next != null;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final void push(DoublyLinkedList.Item<T> i) {\n        insertPrev(_tailptr, i);\n    }","id":74976,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final void push(DoublyLinkedList.Item<T> i) {\n\t\tinsertPrev(null, i);\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final boolean hasPrev(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> prev = i.getPrev();\n        return (prev != null) && (prev != _headptr);\n    }","id":74977,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final boolean hasPrev(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> prev = i.getPrev();\n\t\treturn prev != null;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> shift() {\n        return size == 0 ? null : remove(_headptr.next);\n    }","id":74978,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> shift() {\n\t\treturn size == 0 ? null : remove(_firstItem);\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void insertPrev(DoublyLinkedList.Item<T> i, DoublyLinkedList.Item<T> j) {\n    \tif (i.getParent() == null)\n    \t\tthrow new PromiscuousItemException(i, i.getParent()); // different trace to make easier debugging\n    \tif (i.getParent() != this)\n    \t\tthrow new PromiscuousItemException(i, i.getParent());\n    \tif (j.getParent() != null)\n    \t\tthrow new PromiscuousItemException(j, j.getParent());\n        if ((j.getNext() != null) || (j.getPrev() != null))\n            throw new PromiscuousItemException(j);\n        DoublyLinkedList.Item<T> prev = i.getPrev();\n        if (prev == null)\n            throw new VirginItemException(i);\n        prev.setNext(j);\n        j.setPrev(prev);\n        i.setPrev(j);\n        j.setNext(i);\n        j.setParent(this);\n        ++size;\n    }","id":74979,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void insertPrev(DoublyLinkedList.Item<T> i, DoublyLinkedList.Item<T> j) {\n    \tif (j.getParent() != null)\n    \t\tthrow new PromiscuousItemException(j, j.getParent());\n        if ((j.getNext() != null) || (j.getPrev() != null))\n            throw new PromiscuousItemException(j);\n\n\t\tif (i == null) {\n\t\t\t// insert as tail\n\t\t\tj.setPrev(_lastItem);\n\t\t\tj.setNext(null);\n\t\t\tj.setParent(this);\n\t\t\tif (_lastItem != null) {\n\t\t\t\t_lastItem.setNext(j);\n\t\t\t\t_lastItem = j;\n\t\t\t} else {\n\t\t\t\t_firstItem = _lastItem = j;\n\t\t\t}\n\n\t\t\t++size;\n\t\t} else {\n\t\t\t// insert in middle\n\t\t\tif (i.getParent() == null)\n\t\t\t\tthrow new PromiscuousItemException(i, i.getParent()); // different trace to make easier debugging\n\t\t\tif (i.getParent() != this)\n\t\t\t\tthrow new PromiscuousItemException(i, i.getParent());\n\t\t\tDoublyLinkedList.Item<T> prev = i.getPrev();\n\t\t\tif (prev == null) {\n\t\t\t\tif (i != _firstItem)\n\t\t\t\t\tthrow new VirginItemException(i);\n\t\t\t\t_firstItem = j;\n\t\t\t} else\n\t\t\t\tprev.setNext(j);\n\t\t\tj.setPrev(prev);\n\t\t\ti.setPrev(j);\n\t\t\tj.setNext(i);\n\t\t\tj.setParent(this);\n\n\t\t\t++size;\n\t\t}\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public void insertNext(DoublyLinkedList.Item<T> i, DoublyLinkedList.Item<T> j) {\n    \tif (i.getParent() != this)\n    \t\tthrow new PromiscuousItemException(i, i.getParent());\n    \tif (j.getParent() != null)\n    \t\tthrow new PromiscuousItemException(j, i.getParent());\n        if ((j.getNext() != null) || (j.getPrev() != null))\n            throw new PromiscuousItemException(j);\n        DoublyLinkedList.Item next = i.getNext();\n        if (next == null)\n            throw new VirginItemException(i);\n        next.setPrev(j);\n        j.setNext(next);\n        i.setNext(j);\n        j.setPrev(i);\n        j.setParent(this);\n        ++size;\n    }","id":74980,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public void insertNext(DoublyLinkedList.Item<T> i, DoublyLinkedList.Item<T> j) {\n    \tif (j.getParent() != null)\n    \t\tthrow new PromiscuousItemException(j, i.getParent());\n        if ((j.getNext() != null) || (j.getPrev() != null))\n            throw new PromiscuousItemException(j);\n\n\t\tif (i == null) {\n\t\t\t// insert as head\n\t\t\tj.setPrev(null);\n\t\t\tj.setNext(_firstItem);\n\t\t\tj.setParent(this);\n\n\t\t\tif (_firstItem != null) {\n\t\t\t\t_firstItem.setPrev(j);\n\t\t\t\t_firstItem = j;\n\t\t\t} else {\n\t\t\t\t_firstItem = _lastItem = j;\n\t\t\t}\n\n\t\t\t++size;\n\t\t} else {\n\t\t\tif (i.getParent() != this)\n\t\t\t\tthrow new PromiscuousItemException(i, i.getParent());\n\t\t\tDoublyLinkedList.Item next = i.getNext();\n\t\t\tif (next == null) {\n\t\t\t\tif (i != _lastItem)\n\t\t\t\t\tthrow new VirginItemException(i);\n\t\t\t\t_lastItem = j;\n\t\t\t} else\n\t\t\t\tnext.setPrev(j);\n\t\t\tj.setNext(next);\n\t\t\ti.setNext(j);\n\t\t\tj.setPrev(i);\n\t\t\tj.setParent(this);\n\n\t\t\t++size;\n\t\t}\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final boolean isEmpty() {\n        return size == 0;\n    }","id":74981,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final boolean isEmpty() {\n\t\tassert size != 0 || (_firstItem == null && _lastItem == null);\n        return size == 0;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> pop() {\n        return size == 0 ? null : remove(_tailptr.prev);\n    }","id":74982,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> pop() {\n\t\treturn size == 0 ? null : remove(_lastItem);\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public DoublyLinkedList.Item<T> remove(DoublyLinkedList.Item<T> i) {\n    \tif (i.getParent() == null || isEmpty())\n\t\t\treturn null; // not in list\n    \tif (i.getParent() != this)\n    \t\tthrow new PromiscuousItemException(i, i.getParent());\n        DoublyLinkedList.Item<T> next = i.getNext(), prev = i.getPrev();\n        if ((next == null) && (prev == null)) return null;  // not in the list\n        if ((next == null) || (prev == null))\n        \tthrow new NullPointerException(\"next=\"+next+\", prev=\"+prev); // partially in the list?!\n        if((next.getPrev() != i) || (prev.getNext() != i)) {\n        \tString msg = \"Illegal ERROR: i=\"+i+\", next=\"+next+\", next.prev=\"+next.getPrev()+\", prev=\"+prev+\", prev.next=\"+prev.getNext();\n        \tLogger.error(this, msg);\n        \tthrow new IllegalStateException(msg);\n        }\n        prev.setNext(next);\n        next.setPrev(prev);\n        i.setNext(null);\n        i.setPrev(null);\n        --size;\n        i.setParent(null);\n        return i;\n    }","id":74983,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public DoublyLinkedList.Item<T> remove(DoublyLinkedList.Item<T> i) {\n    \tif (i.getParent() == null || isEmpty())\n\t\t\treturn null; // not in list\n    \tif (i.getParent() != this)\n    \t\tthrow new PromiscuousItemException(i, i.getParent());\n\n\t\tDoublyLinkedList.Item<T> next = i.getNext();\n\t\tDoublyLinkedList.Item<T> prev = i.getPrev();\n\n\t\tif ((next == null) && (prev == null)) // only item in list\n\t\t\tassert size == 1;\n\n\t\tif (next == null) { // last item\n\t\t\tassert _lastItem == i;\n\t\t\t_lastItem = prev;\n\t\t} else {\n\t\t\tassert next.getPrev() == i;\n\t\t\tnext.setPrev(prev);\n\t\t}\n\n\t\tif (prev == null) { // first item\n\t\t\tassert _firstItem == i;\n\t\t\t_firstItem = next;\n\t\t} else {\n\t\t\tassert prev.getNext() == i;\n\t\t\tprev.setNext(next);\n        }\n\n        i.setNext(null);\n        i.setPrev(null);\n        --size;\n        i.setParent(null);\n        return i;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"protected DoublyLinkedListImpl(DoublyLinkedListImpl.Item<T> _h, DoublyLinkedListImpl.Item<T> _t, int size) {\n        _headptr  = _h;\n        _tailptr  = _t;\n        _headptr.setParent(this);\n        _tailptr.setParent(this);\n        \n        DoublyLinkedList.Item i = _headptr;\n        while (i != null ) {\n        \ti.setParent(this);\n        \ti = i.getNext();\n        }\n        \n        this.size = size;\n    }","id":74984,"modified_method":"protected DoublyLinkedListImpl(DoublyLinkedList.Item<T> _h, DoublyLinkedList.Item<T> _t, int size) {\n\t\t_firstItem = _h;\n\t\t_lastItem = _t;\n        \n        DoublyLinkedList.Item i = _firstItem;\n        while (i != null ) {\n        \ti.setParent(this);\n        \ti = i.getNext();\n        }\n        \n        this.size = size;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public DoublyLinkedList<T> shift(int n) {\n\n        if (n > size) n = size;\n        if (n < 1) return new DoublyLinkedListImpl<T>();\n\n        DoublyLinkedList.Item<T> i = _headptr;\n        for (int m=0; m<n; ++m)\n            i = i.getNext();\n\n        DoublyLinkedList.Item<T> j = i.getNext();\n        Item<T> newheadptr = new Item<T>();\n        Item<T> newtailptr = new Item<T>();\n\n        j.setPrev(newheadptr);\n        newheadptr.setNext(j);\n\n        i.setNext(newtailptr);\n        newtailptr.setPrev(i);\n\n        DoublyLinkedList<T> newlist = new DoublyLinkedListImpl<T>(_headptr, newtailptr, n);\n        _headptr = newheadptr;\n        _headptr.setParent(this);\n        size -= n;\n        \n        return newlist;\n    }","id":74985,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public DoublyLinkedList<T> shift(int n) {\n        if (n > size) n = size;\n        if (n < 1) return new DoublyLinkedListImpl<T>();\n\n\t\tDoublyLinkedList.Item<T> i = _firstItem;\n\t\tfor (int m = 0; m < n - 1; ++m)\n            i = i.getNext();\n\n\t\tDoublyLinkedList.Item<T> newTailItem = i;\n\t\tDoublyLinkedList.Item<T> newFirstItem = newTailItem.getNext();\n\t\tnewTailItem.setNext(null);\n\n\t\tDoublyLinkedList<T> newlist = new DoublyLinkedListImpl<T>(_firstItem, newTailItem, n);\n\n\t\tif (newFirstItem != null) {\n\t\t\tnewFirstItem.setPrev(null);\n\t\t\t_firstItem = newFirstItem;\n\t\t} else {\n\t\t\t_firstItem = _lastItem = null;\n\t\t}\n        size -= n;\n        \n        return newlist;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public DoublyLinkedList<T> pop(int n) {\n\n        if (n > size) n = size;\n        if (n < 1) return new DoublyLinkedListImpl<T>();\n\n        DoublyLinkedList.Item<T> i = _tailptr;\n        for (int m=0; m<n; ++m)\n            i = i.getPrev();\n\n        DoublyLinkedList.Item<T> j = i.getPrev();\n        DoublyLinkedListImpl.Item<T> newtailptr = new Item<T>();\n        DoublyLinkedListImpl.Item<T> newheadptr = new Item<T>();\n\n        j.setNext(newtailptr);\n        newtailptr.setPrev(j);\n        newtailptr.setParent(this);\n\n        i.setPrev(newheadptr);\n        newheadptr.setNext(i);\n\n        DoublyLinkedList<T> newlist = new DoublyLinkedListImpl<T>(newheadptr, _tailptr, n);\n        _tailptr = newtailptr;\n        size -= n;\n        \n        return newlist;\n    }","id":74986,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public DoublyLinkedList<T> pop(int n) {\n        if (n > size) n = size;\n        if (n < 1) return new DoublyLinkedListImpl<T>();\n\n\t\tDoublyLinkedList.Item<T> i = _lastItem;\n\t\tfor (int m = 0; m < n - 1; ++m)\n            i = i.getPrev();\n\n\t\tDoublyLinkedList.Item<T> newFirstItem = i;\n\t\tDoublyLinkedList.Item<T> newLastItem = newFirstItem.getPrev();\n\t\tnewFirstItem.setPrev(null);\n\n\t\tDoublyLinkedList<T> newlist = new DoublyLinkedListImpl<T>(newFirstItem, _lastItem, n);\n\n\t\tif (newLastItem != null) {\n\t\t\tnewLastItem.setNext(null);\n\t\t\t_lastItem = newLastItem;\n\t\t} else\n\t\t\t_firstItem = _lastItem = null;\n        size -= n;\n        \n        return newlist;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> next(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> next = i.getNext();\n        return next == _tailptr ? null : next;\n    }","id":74987,"modified_method":"/**\n     * {@inheritDoc}\n     */\n    public final DoublyLinkedList.Item<T> next(DoublyLinkedList.Item<T> i) {\n        DoublyLinkedList.Item<T> next = i.getNext();\n\t\treturn next;\n    }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"protected ReverseWalker() {\n            next = _tailptr.getPrev();\n        }","id":74988,"modified_method":"protected ReverseWalker() {\n\t\t\tnext = _lastItem;\n        }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"public DoublyLinkedList.Item<T> nextElement() {\n            if (next == _tailptr)\n                throw new NoSuchElementException();\n            DoublyLinkedList.Item<T> result = next;\n            next = next.getNext();\n            return result;\n        }","id":74989,"modified_method":"public T nextElement() {\n\t\t\tif (next == null)\n                throw new NoSuchElementException();\n            DoublyLinkedList.Item<T> result = next;\n            next = next.getNext();\n\t\t\treturn (T) result;\n        }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"public final boolean hasMoreElements() {\n            return next != _tailptr;\n        }","id":74990,"modified_method":"public final boolean hasMoreElements() {\n\t\t\treturn next != null;\n        }","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"public void testRandomInsert() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\tlist.insertPrev(array[0], new T(100));\n\t\tlist.insertPrev(array[2], new T(102));\n\t\tlist.insertNext(array[4], new T(104));\n\t\tlist.insertNext(array[4], new T(105));\n\n\t\tDoublyLinkedList<T> list2 = new DoublyLinkedListImpl<T>();\n\t\tT l2 = new T(9999);\n\t\tlist2.push(l2);\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertPrev(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertNext(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertPrev(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertNext(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tlist2.insertPrev(l2.getPrev(), new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tlist2.insertNext(l2.getNext(), new T(8888));\n\t\t\tfail(\"VirginItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\n\t\t((T) list.shift()).assertV(100);\n\t\t((T) list.shift()).assertV(0);\n\t\t((T) list.shift()).assertV(1);\n\t\t((T) list.shift()).assertV(102);\n\t\t((T) list.shift()).assertV(2);\n\t\t((T) list.shift()).assertV(3);\n\t\t((T) list.shift()).assertV(4);\n\t\t((T) list.shift()).assertV(105);\n\t\t((T) list.shift()).assertV(104);\n\n\t}","id":74991,"modified_method":"public void testRandomInsert() {\n\t\tDoublyLinkedList<T> list = new DoublyLinkedListImpl<T>();\n\t\tT[] array = new T[5];\n\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tarray[i] = new T(i);\n\t\t\tlist.push(array[i]);\n\t\t}\n\n\t\tlist.insertPrev(array[0], new T(100));\n\t\tlist.insertPrev(array[2], new T(102));\n\t\tlist.insertNext(array[4], new T(104));\n\t\tlist.insertNext(array[4], new T(105));\n\n\t\tDoublyLinkedList<T> list2 = new DoublyLinkedListImpl<T>();\n\t\tT l2 = new T(9999);\n\t\tlist2.push(l2);\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// already exist\n\t\t\tlist2.insertNext(l2, l2);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertPrev(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// bad position\n\t\t\tlist2.insertNext(array[3], new T(8888));\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertPrev(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\t\ttry {\n\t\t\t// item in other list\n\t\t\tlist2.insertNext(l2, array[3]);\n\t\t\tfail(\"PromiscuousItemException\");\n\t\t} catch (PromiscuousItemException pie) {\n\t\t}\n\n\t\tT l3 = new T(9999);\n\t\tlist2.push(l3);\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tl3.setPrev(null); // corrupt it\n\t\t\tlist2.insertPrev(l3, new T(8888));\n\t\t\tfail(\"VirginItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\t\ttry {\n\t\t\t// VirginItemException\n\t\t\tl2.setNext(null); // corrupt it\n\t\t\tlist2.insertNext(l2, new T(8888));\n\t\t\tfail(\"VirginItemException\");\n\t\t} catch (VirginItemException vie) {\n\t\t}\n\n\t\t((T) list.shift()).assertV(100);\n\t\t((T) list.shift()).assertV(0);\n\t\t((T) list.shift()).assertV(1);\n\t\t((T) list.shift()).assertV(102);\n\t\t((T) list.shift()).assertV(2);\n\t\t((T) list.shift()).assertV(3);\n\t\t((T) list.shift()).assertV(4);\n\t\t((T) list.shift()).assertV(105);\n\t\t((T) list.shift()).assertV(104);\n\n\t}","commit_id":"2c88645f6f4c8aec01d8e02936fd0b5bea2dd9c1","url":"https://github.com/freenet/fred"},{"original_method":"OClosableEntry<K, E> poll() {\n    if (head == null)\n      return null;\n\n    final OClosableEntry<K, E> entry = head;\n\n    OClosableEntry<K, E> next = head.getNext();\n    assert next.getPrev() == head;\n\n    head = next;\n    next.setPrev(null);\n\n    assert head.getPrev() == null;\n\n    if (head == null)\n      tail = null;\n\n    entry.setNext(null);\n    assert entry.getPrev() == null;\n\n    size--;\n\n    return entry;\n  }","id":74992,"modified_method":"OClosableEntry<K, E> poll() {\n    if (head == null)\n      return null;\n\n    final OClosableEntry<K, E> entry = head;\n\n    OClosableEntry<K, E> next = head.getNext();\n    assert next == null || next.getPrev() == head;\n\n    head = next;\n    if (next != null) {\n      next.setPrev(null);\n    }\n\n    assert head == null || head.getPrev() == null;\n\n    if (head == null)\n      tail = null;\n\n    entry.setNext(null);\n    assert entry.getPrev() == null;\n\n    size--;\n\n    return entry;\n  }","commit_id":"c31d3690f207431d3c2839e1ff171eafbcd5333f","url":"https://github.com/orientechnologies/orientdb"},{"original_method":"private List<JCAnnotation> getAnnotations() {\n        if (noAnnotations) {\n            return List.nil();\n        }\n        if (ignoreAnnotations) {\n            return gen.makeAtIgnore();\n        }\n        return this.annotations.toList();\n    }","id":74993,"modified_method":"private List<JCAnnotation> getAnnotations() {\n        List<JCAnnotation> ret = List.nil();\n        if (noAnnotations) {\n            // nothing\n        }else if (ignoreAnnotations) {\n            ret = ret.prependList(gen.makeAtIgnore());\n        }else{\n            ret = ret.prependList(this.annotations.toList());\n        }\n        return ret;\n    }","commit_id":"0b95836ba4a382f14b51cbebdd78e33c449972b4","url":"https://github.com/ceylon/ceylon-compiler"},{"original_method":"protected void installResourceDescription(Resource resource) {\n\t\ttry {\n\t\t\tcompilerPhases.setIndexing(resource, true);\n\t\t\t/*\n\t\t\t * Avoid deadlocks when a language accesses the index during indexing, \n\t\t\t * e.g. Xtend active annotations\n\t\t\t */\n\t\t\tFileBasedIndexImpl.disableUpToDateCheckForCurrentThread();\n\t\t\tResourceDescriptionAdapter.install(resource);\n\t\t} catch(OperationCanceledError e) {\n\t\t\tthrow e.getWrapped();\n\t\t} finally {\n\t\t\tcompilerPhases.setIndexing(resource, false);\n\t\t\tFileBasedIndexImpl.enableUpToDateCheckForCurrentThread();\n\t\t}\n\t}","id":74994,"modified_method":"protected void installResourceDescription(Resource resource) {\n\t\ttry {\n\t\t\tif (compilerPhases.isIndexing(resource)) {\n\t\t\t\tthrow new IllegalStateException(\"Was already indexing resource set for \" + resource.getURI());\n\t\t\t}\n\t\t\tcompilerPhases.setIndexing(resource, true);\n\t\t\t/*\n\t\t\t * Avoid deadlocks when a language accesses the index during indexing, \n\t\t\t * e.g. Xtend active annotations\n\t\t\t */\n\t\t\tFileBasedIndexImpl.disableUpToDateCheckForCurrentThread();\n\t\t\tResourceDescriptionAdapter.install(resource);\n\t\t} catch(OperationCanceledError e) {\n\t\t\tthrow e.getWrapped();\n\t\t} finally {\n\t\t\tFileBasedIndexImpl.enableUpToDateCheckForCurrentThread();\n\t\t\tcompilerPhases.setIndexing(resource, false);\n\t\t}\n\t}","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"protected void installDerivedState(Resource resource) {\n\t\tif (resource instanceof DerivedStateAwareResource) {\n\t\t\tfinal DerivedStateAwareResource derivedStateAwareResource = (DerivedStateAwareResource) resource;\n\t\t\tif (derivedStateAwareResource instanceof ISynchronizable<?>) {\n\t\t\t\tISynchronizable<?> synchronizable = (ISynchronizable<?>) derivedStateAwareResource;\n\t\t\t\ttry {\n\t\t\t\t\tsynchronizable.execute(new IUnitOfWork<Void, Object>() {\n\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic java.lang.Void exec(Object state) throws Exception {\n\t\t\t\t\t\t\tdoInstallDerivedState(derivedStateAwareResource);\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tExceptions.sneakyThrow(e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdoInstallDerivedState(derivedStateAwareResource);\n\t\t\t}\n\t\t}\n\t}","id":74995,"modified_method":"protected void installDerivedState(Resource resource) {\n\t\tif (resource instanceof DerivedStateAwareResource) {\n\t\t\tfinal DerivedStateAwareResource derivedStateAwareResource = (DerivedStateAwareResource) resource;\n\t\t\t// avoid synchronization of the resource\n\t\t\tif (!derivedStateAwareResource.isFullyInitialized()) {\n\t\t\t\tif (derivedStateAwareResource instanceof ISynchronizable<?>) {\n\t\t\t\t\tISynchronizable<?> synchronizable = (ISynchronizable<?>) derivedStateAwareResource;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsynchronizable.execute(new IUnitOfWork<Void, Object>() {\n\t\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tpublic java.lang.Void exec(Object state) throws Exception {\n\t\t\t\t\t\t\t\tdoInstallDerivedState(derivedStateAwareResource);\n\t\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\tExceptions.sneakyThrow(e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdoInstallDerivedState(derivedStateAwareResource);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"@Override\n\t\tpublic boolean isAdapterForType(Object type) {\n\t\t\treturn IndexingAdapter.class.equals(type);\n\t\t}","id":74996,"modified_method":"@Override\n\t\tpublic boolean isAdapterForType(Object type) {\n\t\t\treturn INSTANCE == type;\n\t\t}","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"public boolean isIndexing(Notifier ctx) {\n\t\tResourceSet set = EcoreUtil2.getResourceSet(ctx);\n\t\tif (set != null) {\n\t\t\tIterator<Adapter> iterator = set.eAdapters().iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tif (iterator.next() instanceof IndexingAdapter) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}","id":74997,"modified_method":"public boolean isIndexing(Notifier ctx) {\n\t\tResourceSet set = EcoreUtil2.getResourceSet(ctx);\n\t\tif (set != null) {\n\t\t\treturn EcoreUtil.getAdapter(set.eAdapters(), IndexingAdapter.INSTANCE) != null;\n\t\t}\n\t\treturn false;\n\t}","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"public void setIndexing(Notifier ctx, boolean isIndex) {\n\t\tResourceSet set = EcoreUtil2.getResourceSet(ctx);\n\t\tif (isIndex) {\n\t\t\tset.eAdapters().add(new IndexingAdapter());\n\t\t} else {\n\t\t\tIterator<Adapter> iterator = set.eAdapters().iterator();\n\t\t\twhile (iterator.hasNext()) {\n\t\t\t\tif (iterator.next() instanceof IndexingAdapter) {\n\t\t\t\t\titerator.remove();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","id":74998,"modified_method":"public void setIndexing(Notifier ctx, boolean isIndex) {\n\t\tResourceSet set = EcoreUtil2.getResourceSet(ctx);\n\t\tif (isIndex) {\n\t\t\tset.eAdapters().add(IndexingAdapter.INSTANCE);\n\t\t} else {\n\t\t\tset.eAdapters().remove(IndexingAdapter.INSTANCE);\n\t\t}\n\t}","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"},{"original_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n\t\tif (!(element instanceof PsiEObject)) {\n\t\t\treturn;\n\t\t}\n\t\tPsiEObject psiEObject = (PsiEObject) element;\n\t\tif (!psiEObject.isRoot()) {\n\t\t\treturn;\n\t\t}\n\t\tResource resource = psiEObject.getResource();\n\t\tif (resource == null) {\n\t\t\treturn;\n\t\t}\n\t\tLanguage language = psiEObject.getLanguage();\n\t\tif (!(language instanceof IXtextLanguage)) {\n\t\t\treturn;\n\t\t}\n\t\tIXtextLanguage xtextLanguage = (IXtextLanguage) language;\n\t\tIResourceValidator resourceValidator = xtextLanguage.getInstance(IResourceValidator.class);\n\t\ttry {\n\t\t\tfor (Issue issue : getIssues(resource, resourceValidator)) {\n\t\t\t\tif (issue.isSyntaxError()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tHighlightSeverity highlightSeverity = getHighlightSeverity(issue.getSeverity());\n\t\t\t\tif (highlightSeverity == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint startOffset = 0;\n\t\t\t\tint endOffset = 0;\n\t\t\t\tif (issue.getOffset() != null) {\n\t\t\t\t\tstartOffset = issue.getOffset();\n\t\t\t\t\tendOffset = startOffset + issue.getLength();\n\t\t\t\t}\n\t\t\t\tholder.createAnnotation(highlightSeverity, new TextRange(startOffset, endOffset), issue.getMessage());\n\t\t\t}\n\t\t} catch (OperationCanceledError e) {\n\t\t\tthrow e.getWrapped();\n\t\t}\n\t}","id":74999,"modified_method":"public void annotate(PsiElement element, AnnotationHolder holder) {\n\t\tif (!(element instanceof PsiEObject)) {\n\t\t\treturn;\n\t\t}\n\t\tLanguage language = element.getLanguage();\n\t\tif (!(language instanceof IXtextLanguage)) {\n\t\t\treturn;\n\t\t}\n\t\tPsiEObject psiEObject = (PsiEObject) element;\n\t\tif (!psiEObject.isRoot()) {\n\t\t\treturn;\n\t\t}\n\t\tResource resource = psiEObject.getResource();\n\t\tif (resource == null) {\n\t\t\treturn;\n\t\t}\n\t\tIXtextLanguage xtextLanguage = (IXtextLanguage) language;\n\t\tIResourceValidator resourceValidator = xtextLanguage.getInstance(IResourceValidator.class);\n\t\ttry {\n\t\t\tfor (Issue issue : getIssues(resource, resourceValidator)) {\n\t\t\t\tif (issue.isSyntaxError()) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tHighlightSeverity highlightSeverity = getHighlightSeverity(issue.getSeverity());\n\t\t\t\tif (highlightSeverity == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint startOffset = 0;\n\t\t\t\tint endOffset = 0;\n\t\t\t\tif (issue.getOffset() != null) {\n\t\t\t\t\tstartOffset = issue.getOffset();\n\t\t\t\t\tendOffset = startOffset + issue.getLength();\n\t\t\t\t}\n\t\t\t\tholder.createAnnotation(highlightSeverity, new TextRange(startOffset, endOffset), issue.getMessage());\n\t\t\t}\n\t\t} catch (OperationCanceledError e) {\n\t\t\tthrow e.getWrapped();\n\t\t}\n\t}","commit_id":"8af85aa2c45607192f1ff7b9c08b02dd72bf6d03","url":"https://github.com/eclipse/xtext"}]